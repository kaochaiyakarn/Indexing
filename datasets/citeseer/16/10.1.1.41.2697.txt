dimacs series discrete mathematics theoretical computer science volume xx algorithms satisfiability sat problem survey jun gu paul purdom john franco benjamin wah 
satisfiability sat problem core problem mathematical logic computing theory 
practice sat fundamental solving problems automated reasoning computer aided design computeraided manufacturing machine vision database robotics integrated circuit design computer architecture design computer network design 
traditional methods treat sat discrete constrained decision problem 
years optimization methods parallel algorithms practical techniques developed solving sat 
survey general framework algorithm space integrates existing sat algorithms unified perspective 
describe sequential parallel sat algorithms including variable splitting resolution local search global optimization mathematical programming practical sat algorithms 
give performance evaluation existing sat algorithms 
provide set practical applications satisfiability problems 

instance satisfiability sat problem boolean formula components ffl set variables xn ffl set literals 
literal variable negation variable 
ffl set distinct clauses cm clause consists literals combined just logical connectives 
goal satisfiability problem determine exists assignment truth values variables conjunctive normal mathematics subject classification 
primary secondary 
key words phrases 
combinatorial optimization conjunctive normal form constraint satisfaction problem decision theory logic inference nonlinear programming parallel distributed processing propositional logic satisfiability problem search theorem proving 
research supported part acm ieee academic scholarship awards presently supported part nserc research ogp nserc strategic str nsf ccr onr nsf mip mip dimacs workshop satisfiability sat problems dimacs visitor program 
fl american mathematical society page algorithms satisfiability sat problem survey form cnf formula satisfiable delta delta delta cm logical connective 
sat problem core large family computationally intractable npcomplete problems 
np complete problems identified central number areas computing theory engineering 
sat np complete sat algorithm fast worst case time behavior 
clever algorithms rapidly solve sat formulas practical interest 
great interest designing efficient algorithms solve sat formulas 
practice sat fundamental solving problems automated reasoning computer aided design computer aided manufacturing machine vision database robotics integrated circuit design automation computer architecture design computer network design see section 
methods solve sat formulas play important role development efficient computing systems 
traditional methods treat sat formula discrete constrained decision problem 
years optimization methods parallel algorithms practical techniques developed 
survey general framework algorithm space integrates existing sat algorithms unified perspective 
describe sequential parallel sat algorithms compare performance major sat algorithms including variable setting resolution local search global optimization mathematical programming practical sat algorithms 
survey give collection practical applications satisfiability problem 
organized follows 


constraint satisfaction problems 
preliminaries 
algorithm space perspective sat algorithms 
sat input models 
splitting resolution 
local search 
global optimization 
integer programming method 
special subclasses sat 
advanced techniques 
probabilistic average case analysis 
performance experiments 
applications 

section describe constraint satisfaction problem csp close relationship sat problem 
section gives preliminaries 
section give general framework algorithm space puts existing sat algorithms unified perspective 
followed brief overview basic sat algorithm classes discussion general performance evaluation approaches sat algorithms 
section sat problem instance models 
section describes variable setting resolution procedures jun gu paul purdom john franco benjamin wah solving sat formulas 
local search algorithms global optimization techniques integer programming approaches solving sat formulas discussed respectively sections 
section discusses special subclasses sat problem 
advanced techniques solving sat formulas described section 
section gives probabilistic average case analysis sat problem 
experimental results performance comparisons major sat algorithms section 
presently hard random sat problem instances complete sat algorithm solve sat problem variables 
incomplete sat algorithm wsat solve sat problem instances variables sgi challenge mhz mips processor :10.1.1.21.2207
randomized local search algorithm sat solve various sat problem instances variables sun sparc workstation comfortably 
practical sat solvers industrial applications problem specific 
collected real experimental results section 
section summarizes applications sat problem 
sat research discussed section 
section concludes 

constraint satisfaction problems constraint satisfaction problem csp determine set constraints discrete variables satisfied 
constraint form easy evaluate difficulty solving problem comes interaction constraints need find setting variables simultaneously satisfies constraints 
sat formula constraint expressed clause making sat special case constraint satisfaction problem see 
due close relationship csp algorithm transformed sat algorithm usually done way maintains efficiency algorithm 
discrete csp model consists components ffl variables fx xng 
assignment tuple values assigned variables 
ffl domains fd dn domain contains possible values called labels may instantiated fl ffl subset theta theta theta dn set constraints 
set order constraints imposed subset variables fx fx xng denoted theta theta theta order constraint indicates compatibility consistency inconsistency conflicting measure variables variable assignment 
variables conflict values satisfy constraint 
practice frequently constraints unary constraints imposed single variable binary constraints imposed pair variables theta 
solving csp entails minimizing local inconsistency finding consistent value assignment consistent labeling variables subject constraints 
constraint satisfaction problems extremely common 
np complete problems initially stated constraint satisfaction problems 
proof algorithms satisfiability sat problem survey csp discrete csp queen problem graph coloring problem scheduling problem binary csp ae sat problem max sat problem 
examples constraint satisfaction problem csp 
sat problem special case csp csp binary values 
problem np complete implies efficient way transform problem constraint satisfaction problem 
special forms constraint satisfaction problem exist algorithms solve formulas polynomial worst case time 
polynomial time algorithm known particular form constraint satisfaction problem common practice solve formulas search algorithm 
problems commonly formulated constraint satisfaction satisfiability problems purposes benchmarking include graph coloring queens problems 
case queens problem analytical solutions problem exist provide restricted subset solutions 
practical applications search algorithm find general solution csp sat problems 

preliminaries simplify discussion ffl cnf boolean formula ffl number clauses ffl number variables ffl ith clause ffl jc number literals clause ffl jth literal ith clause ffl average number literals jc boolean space ffl function integer ffl jth variable ffl vector variables ffl ith clause function ffl jth literal function ith clause function real space ffl real function ffl real function ffl jth variable ffl vector variables jun gu paul purdom john franco benjamin wah ffl ith clause function ffl jth literal function ith clause function real space ffl jth integer variable ffl vector integer variables real valued function defined subset said continuous 
set real valued functions fm form vector function fm ith component continuous component functions continuous 
second partial derivatives continuous set define hessian theta matrix denoted call solution denoted aspects iterative optimization algorithms global convergence local convergence rates 
global convergence concerns starting initial point sequence points converge final solution point 
local convergence rate rate generated sequence points converge solution 

algorithm space perspective sat algorithms section describe various formulations sat give algorithm space perspective provides insights developing efficient algorithms solving sat 
give brief overview basic sequential parallel sat algorithms discuss various categories algorithms performance evaluation methods 

formulations sat 
sat problem expressed conjunctive normal form cnf formulas disjunctive normal form dnf formulas 
instances sat formulated discrete continuous variables 
discrete formulations 
classified unconstrained versus constrained 
discrete constrained feasibility formulations 
goal satisfy constraints 
possible formulation cnf formulas 
second formulation dnf formulas discussed section 
discrete unconstrained formulations 
common formulation cnf formulas exists :10.1.1.34.6853
goal minimize number unsatisfied clauses interpretation numeric variable boolean variable true false respectively 
min algorithms satisfiability sat problem survey gamma case clauses satisfied 
similar formulation dnf formulas exists see section 
interpretation numeric variable boolean variable true false respectively goal solve min gamma gamma clauses satisfied 
alternatively dnf formulas solved follows max 
usually question dnf formula interesting question satisfiability 
solved follows min 
formula falsifiable 
discrete constrained formulations 
various forms formulation 
approach formulate sat formulas instances integer linear programming ilp problem 
approach minimize objective function number unsatisfiable clauses subject set constraints follows min subject mg formulation dnf defined similarly 
jun gu paul purdom john franco benjamin wah formulation uses additional constraints guide search 
violated constraints provide mechanism bring search local minimum 
formulation lagrange multiplier method solve sat problem see section 
continuous formulations 
formulating discrete instance sat continuous space transform discrete variables original formula continuous variables way solutions continuous problem binary solutions original formula 
transformation potentially beneficial objective continuous space may smooth infeasible solutions leading smaller number local minima explored 
show formulations 
continuous unconstrained formulations 
possible formulations category 
simple formulation unisat universal sat problem models suggests min jy gamma jy positive constants 
special formulations exist 
unisat model jy gamma jy unisat model gamma values solutions original formula 
unisat solved efficient discrete greedy local search algorithms section 
unisat requires computationally expensive continuous optimization algorithms rendering applicable small formulas section 
continuous constrained formulations 
generally involves heuristic objective function measures quality solution obtained number clauses satisfied 
formulation similar follows 
min subject mg algorithms satisfiability sat problem survey unconstrained constrained continuous discrete parallel sequential 
algorithm space unified framework discrete search algorithms continuous optimization algorithms 
represent basic classes algorithms 
defined 
key approach lies transformation 
smooth local minima discrete space solution density low continuous methods computationally expensive apply discrete methods 
continuous constrained optimization problem nonlinear objective function nonlinear constraints apply existing methods solve 
experience lagrangian transformation reduce number local minima continuous lagrangian methods order magnitude expensive apply corresponding discrete algorithms 

algorithm space 
discrete search algorithms relate continuous optimization methods operations research 
discrete search problems solved numerical algorithms real space 
unified framework search optimization shed light developing efficient algorithms search problem 
shows typical algorithm space unifies variety search optimization algorithms terms variable domain constraint parallelism algorithms 
satisfiability expressed discrete variables algorithms calculations continuous variables 
leads discrete continuous axis space 
satisfiability set constraints satisfied exactly procedures local search consider changes variable values clauses satisfy constraints typically algorithms assign cost non satisfying constraints look cost solution 
defines vertical axis showing constraint characteristics algorithm space 
sat algorithms sequential implemented jun gu paul purdom john franco benjamin wah continuous discrete linear programming local search unconstrained optimization 
consistency checking constrained unconstrained 
dimensional cross section algorithm space cut sequential side 
indicates unified framework discrete search algorithms continuous optimization techniques solving sat 
parallel 
third axis indicating parallelism algorithms added algorithm space 
axes algorithm space divided representing sequential algorithm classes discrete constrained algorithms discrete unconstrained algorithms continuous constrained algorithms continuous unconstrained algorithms parallel algorithm classes parallel discrete constrained algorithms parallel discrete unconstrained algorithms parallel continuous constrained algorithms parallel continuous unconstrained algorithms 
gives typical examples sequential classes sat algorithms space discrete search space left half variables values constraints objective functions defined discrete values 
handles discrete search problem consistency checking constraint resolution approach belongs class discrete constrained methods 
alternatively formulate constraints objective function minimize objective function looking problem constraints 
algorithms category usually called discrete unconstrained methods local search procedure 

continuous search space right half variables values constraints objective functions defined quantitatively real values 
solves continuous optimization problem explicit constraints uses continuous constrained methods constrained minimization primal methods cutting plane methods 
problem constraints incorporated objective function problem transformed unconstrained 
solved continuous unconstrained methods descent methods conjugate direction methods newton methods 
algorithms satisfiability sat problem survey unconstrained constrained continuous discrete complete 
algorithm space incorporating algorithm completeness solving sat 
octant represents class sat algorithms 
operations research point view discrete search algorithms continuous optimization versions constrained search methods unconstrained counterparts 
instance discrete consistency algorithms constrained algorithms 
formulate amount inconsistency objective function local search method solve input efficiently 
furthermore local search works discrete search space 
extending search problem real search space constrained unconstrained global optimization algorithms developed solve sat 
algorithm space provides unified global perspective development search optimization algorithms solving sat 
general instance search problem find algorithm octant possibly find closely related algorithms 
left quadrants example consistency algorithms local search algorithms solving sat natural think unconstrained optimization algorithms solving sat right quadrants put meet natural symmetry 
original incentive develop unconstrained optimization algorithms solving sat 
ways looking variety sat algorithms 
different algorithm space sat incorporates algorithm completeness see 

basic sat algorithm classes 
algorithm space number major sat algorithm classes identified 
chronological order 
existing sat algorithms grouped categories 
ffl discrete constrained algorithms 
algorithms category treat sat formula instance constrained decision problem applying discrete jun gu paul purdom john franco benjamin wah discrete constrained davis putnam dp algorithm resolution consistency algorithms loveland davis putnam dpl parallel consistency chips binary decision diagrams bdd chip conquer dpl plus heuristic local search backtracking backtracking probing parallel dp algorithm matrix inequality system csat unconstrained randomized local search sat parallel local search sat local search queen unison algorithm hardware local search complexity local search sat local search traps sat greedy local search gsat continuous constrained branch bound apex programming models cutting plane branch cut interior point method unconstrained unisat models global optimization sat neural net models global optimization backtracking sat algorithms :10.1.1.1.5124:10.1.1.34.6853:10.1.1.40.9517
typical algorithms sat problem 
search inference procedures determine solution 
straightforward way solve instance sat enumerate possible truth assignments check see satisfies formula 
improved techniques consistency algorithms backtracking algorithms term rewriting production system multi valued logic binary decision diagrams chip conquer resolution regular resolution independent set algorithm matrix inequality system proposed :10.1.1.1.5124
algorithms satisfiability sat problem survey discrete constrained algorithms eliminate variable time 
done making repeated resolution done original version davis putnam dp procedure assigning variable possible value generating sub formula value done loveland modification dp procedure 
resolution generates new formula worst case number clauses new formula proportional square number clauses original formula 
assigning values variable called searching generates new formulas 
random formulas resolution methods fast number clauses small compared number values search methods fast number clauses expected number solutions near 
approaches combined resolution variables search 
specific algorithms principles include simplified dp algorithms simplified dp algorithm strict ordering variables 
dp algorithm improved certain aspects gilmore proof method 
analyses sat algorithms concentrates algorithms simple difficult correct analysis best algorithms 
conditions simple algorithms fast related practical algorithms fast 
difficult tell practical algorithm slow conditions corresponding simplified algorithm slow 
number special sat problems satisfiability horn clauses solvable polynomial time 
linear time algorithms polynomial time algorithms existing 
ffl discrete unconstrained algorithms 
approach number unsatisfiable cnf satisfiable dnf clauses formulated value objective function transforming sat formula discrete unconstrained minimization problem objective function 
local search major class discrete unconstrained search methods :10.1.1.34.6853
solve transformed formula see section 
ffl constrained programming algorithms 
methods class developed fact cnf dnf formulas transformed instances integer programming possibly solved linear programming relaxations 
approaches including branch bound cutting plane branch cut interior point improved interior point proposed solve integer program representing inference problem 
researchers integer programming methods faster resolution certain classes problems methods possess robust convergence property fail solve hard instances satisfiability 
ffl unconstrained global optimization algorithms 
special models formulated transform discrete formula boolean space decision problem unconstrained unisat problem real space unconstrained global optimization problem 
transformed formulas jun gu paul purdom john franco benjamin wah discrete constrained parallel clp algorithms parallel dra chips parallel dp algorithm parallel ac algorithms parallel csp architectures unison algorithm hardware vectorized dp algorithm mimd dp algorithm unconstrained cnf local search dnf local search parallel local search discrete fffi relaxation multiprocessor local search continuous constrained phi interior point method unconstrained unisat models global optimization sat continuous fffi relaxation sat algorithms parallel global optimization neurocomputing :10.1.1.40.9517
parallel sat csp algorithms 
solved existing global optimization methods see section 

parallel sat algorithms 
practice sequential sat algorithms mapped parallel computer systems resulting parallel sat algorithms 
speedup greater number processors occurs correlations variable settings lead solutions 
accordingly classes parallel algorithms solving sat 
ffl parallel discrete constrained algorithms 
discrete constrained sat csp algorithms implemented parallel algorithms put special purpose hardware vlsi architectures 
include parallel consistent labeling algorithms parallel discrete relaxation dra chips parallel arc consistency pac algorithms parallel constrained search architectures parallel unison algorithms parallel unison architectures parallel dp algorithms parallel logical programming languages 
ffl parallel discrete unconstrained algorithms 
number discrete local optimization algorithms implemented parallel computing machines 
include cnf local search dnf local search parallel local search multiprocessor local search 
algorithms satisfiability sat problem survey general purpose programming sequential machines ae vax sun workstations parallel machines multicomputers cray bbn butterfly plus connection machine vector computer eta vector computer inmos transputer special purpose architectures sequential machines ae analog processor dra architectures parallel machines dra architectures architectures csp architectures architectures dra model architecture dra model architecture unison architectures :10.1.1.40.9517
computer architectures running sat csp algorithms 
new fffi relaxation technique developed parallel distributed environment 
ffl parallel constrained programming algorithms 
kamath implemented interior point zero integer programming algorithm parallel vector computer 
ffl parallel unconstrained global optimization algorithms 
algorithms implemented unisat models parallel continuous fffi relaxation parallel global optimization algorithms 
computer architectures affect data structures implementation details performance sat algorithms 
variety computer systems running sat algorithms 
early studies csp sat algorithms performed sequential computers 
concentrated parallel programming multiprocessors 
mccall simulated processor architecture various system topology performance criteria forward checking csp algorithm 
samal implemented parallel ac algorithms cray computer node bbn butterfly plus mimd shared memory homogeneous parallel processor 
cooper swain implemented parallel ac algorithms connection machine 
kamath karmarkar implemented interior point zero integer programming algorithm sat parallel vector computer 
fang chen implemented vectorized dp algorithm eta vector computer 
bohm experimented parallelization jun gu paul purdom john franco benjamin wah variants davis putnam loveland dpl procedure message mimd transputer system built inmos mb processors :10.1.1.40.9517
implementation small processors solves formula arising depth dpl search tree computation ceases soon processor reports formula satisfiable 
noticed time completion usually time taken serial version :10.1.1.40.9517
research works continue building special purpose vlsi architectures speed sat csp computations 
variable value instance csp wang gu gave time parallel dra algorithm simd dra architecture 
furthermore gu wang gave time parallel dra algorithm dynamic dra architecture solving general dra problems 
gu wang developed nd time massively parallel dra algorithm parallel dra vlsi architecture 
problems practical interest parallel dra algorithms running special purpose vlsi architectures offer orders magnitude performance improvement sequential algorithms 
sosic gu johnson developed number parallel algorithms architectures differential non clausal inference sat formulas 
extreme example parallel processing compute chemistry dna molecules 
appear lead factor degrees parallelism slow time computation steps approach investigated detail determine practical limitations 
sat evaluation approach parallel random says solution definitely says probably 

algorithm categories 
sat algorithms complete definitely determine input solution incomplete determine input solution cases find :10.1.1.1.5124
incomplete algorithms find solution solutions favorable cases give terminate cases 
cases know input solution algorithm search hard 
incomplete algorithms verify formula solution find solution exists 
case incomplete algorithms check patterns imply unsatisfiability 
strict sense word algorithm incomplete algorithms algorithms procedures particular interest inputs difficult complete algorithm solve reasonable time 
complete algorithms perform actions determine solution exists give variable settings solution find solutions optimal solution prove solution 
algorithms type theoretical interest fact algorithm modified little loss efficiency give algorithm second type 
algorithms third type needed measure solution quality optimal solution sought algorithms satisfiability sat problem survey problem constraints addition sat instance 
algorithms essential important practical applications np hard nature 
major sat precede program calculate chemical interaction energies predict rna folding 
gu puri developed efficient complete sat algorithm asynchronous computer circuit design aiming producing minimal circuit structure 
incomplete algorithms optimize solution quality playing little role solving practical optimization problems 
requiring program produce solution explicit form ensures worst case time exponential np inputs exponential number solutions 
alternative give solutions compressed form 
example algorithms implicitly list solutions giving cylinders solutions settings variables understanding remaining variables don cares value 
formulas approach represent solutions compact explicit representation 
binary decision diagrams bdd sophisticated compact way represent set solutions :10.1.1.1.5124
instances sat structure faster generate solution various subsets constraints depending subset variables test various solution sets common try solve entire formula 
type sat algorithm shows greater efficiency improvements certain practical engineering design problems 
techniques complete sat algorithms usually adapted provide exact solutions optimization problems 
techniques incomplete sat algorithms usually adapted provide approximate solutions optimizations problems 
normally lead algorithms produce low necessarily lowest value function 
random sets formulas probability particular formula solution important parameter determining difficult set particular algorithm 
best known algorithms difficulty probability near fast probability close 
formulas generated sat model example 
shows variables real execution results dp algorithm clauses 
computing time program dp algorithm shown sat model solid line average sat model dotted line 
random formulas generated left region usually satisfiable procedure fast 
random formulas right region usually unsatisfiable procedure fast 
random formulas middle satisfiable unsatisfiable procedure slow 
dp algorithm complete algorithm able verify satisfiability unsatisfiability 
gives results random formulas regions 
results dp algorithm may hold different sat algorithm 
local search may find solution satisfiable cnf quickly dp algorithm verify satisfiability prove unsatisfiability 
particular gives answer cnf formula satisfiable 
formulas peak region nearly formulas right region local search algorithm terminate reasonable amount time 
jun gu paul purdom john franco benjamin wah computing time msec 
number clauses exact sat average sat 
computing time exact average sat models variables sun sparc workstation 
horizontal axis measured 
performance evaluation 
performance algorithm determined experimentally analytically 
feasible experimental studies typical random formulas worst case formulas formulas size experimentally determine leads worst case time 
feasible analytical studies random worst case formulas typical formulas typical sets formulas seldom mathematical structure suitable analysis 
experimental studies inconclusive consider relatively small number input possibilities 
restrictions forced space input formulas size formulas large 
analytical studies intended determine performance broad families inputs family typically represents class formulas particular size 
studies drawback simplest algorithms analyzed 
compensate features complex algorithm removed leaving simple analyzable 
simplified algorithm usually contains simple techniques unit clause rule pure literal rule 
analytical result simplified algorithm provides bound performance complex algorithm bound sufficient understand behavior complex algorithm 
approach side benefit analytical studies suggest simple techniques included practical algorithms 
fact prize winners sat contest associated analytical studies sat algorithms 
top winners associated experimental analytical studies sat algorithms 
analytical studies sat algorithms involve 

worst case studies 
algorithms satisfiability sat problem survey np sat algorithms worst case time superpolynomial input size 
number studies concentrated worst case analysis variable setting algorithms solving sat 

probabilistic studies 
typical performance satisfiability algorithms better proven worst case results considerable interest evaluating probabilistic performance algorithms 
studies model generating random formulas calculate performance algorithms formulas 
widely measures performance average time probabilistic time 
average time weighted average time related measure number nodes solve sample formulas 
algorithm solve formula average defined 
probabilistic time studies algorithm deadline usually specified polynomial length input formulas studies fraction formulas solved deadline 
probabilistic time studies performed algorithms give fraction formulas long fraction goal fraction 
incomplete algorithms average time defined fraction inputs solved studied 
various hybrid measures average time solve easiest percent inputs 
literature contains number studies average time probabilistic time performance certain sat algorithms 
despite worst case complexity sat algorithms heuristics polynomial average time complexities reported 
subject treated detail section 

number solutions 
researchers investigated number solutions random sat formulas 
extending dubois gave combinatorial formula computing number solutions set clauses 
dubois carlier studied mathematical expectation number solutions probabilistic model 
past decades performance studies performed sampling techniques experimental simulations analytical studies combined effort approaches 

sat input models section describe basic sat input models characteristics 
knuth showed measure size backtrack tree repeatedly random paths root 
purdom gave modified version knuth algorithm greatly increases efficiency knuth method occasionally path node 
stone stone variant algorithms knuth purdom estimating size unvisited portion statistics visited portion 
jun gu paul purdom john franco benjamin wah 
random input models 
running time sat algorithm depends type input solved 
sat input models generate variety input types 
ffl hardest formulas 
generate formula difficult algorithm measured 
approach analytical studies 
possible formulas approach experimental studies 
brown reported effects minor variations average time needed simple backtracking algorithm 
experimental studies include results hardest formulas set formulas tested results quite different results entire set possible formulas tested 
analytical studies basic models generate random cnf formulas 
model variations depending identical clauses permitted variable negation occur clause ffl sat model 
sat model randomly generated cnf formula consists independently generated random clauses 
clause chosen uniformly set possible clauses exactly literals composed variable set fx xng literals equal complementary 
number possible clauses model called fixed clause length model 
similar models 
ffl average sat model 
average sat model randomly generated cnf formula consists independently generated random clauses 
clause variables occurs positively probability gamma negatively probability gamma positively negatively probability probability gamma function average number literals clause pn 
model called random clause length model 
model variations 
papers just model performance simple backtracking considered number related models 

hardness 
various sat algorithms differ greatly amount time need solve particular inputs 
example algorithm fast random formulas lots solutions slow random formulas solutions simple backtracking fast formulas solutions slow formulas solutions 
hard easy distributions sat formulas depend inherent property sat input models algorithms solve formulas 
particular sat formula easy algorithm example table lookup algorithm formula lookup table 
hardness property large sets formulas individual formulas 
sets formulas generated random models parameters probability finding solution varies parameter settings 
sets generated parameters set regions solutions going common particularly difficult algorithms studied see 
algorithms satisfiability sat problem survey percentage satisfiability number clauses exact sat average sat 
percentage satisfiability formulas variables generated sat average sat input models respectively 
horizontal axis measured random sat formulas fewer literals larger number clauses reduce possibility making clauses jointly satisfiable 
computing time random sat formulas increases point increases number literals clause decreases 
inspection reveals hump difficulty sat formulas sample space satisfiable flat increase difficulty random sat formulas correspondingly similar region parameter space 

comparison random input models 
structural properties random formulas generated input models quite different significant impact performance complete sat algorithm 
significance felt especially region parameter space random formulas nearly equally satisfiable unsatisfiable 
shows variables actual computing time complete sat sat algorithm random formulas generated sat model average sat model 
shows percent random formulas satisfiable function formula size models 
complete algorithm problem instances generated average sat model easier generated sat model 
takes complete algorithm computing time solve formulas generated average sat model 
incomplete algorithm local search situation different 
number clauses values problem instances generated average sat model lower percentage satisfiability compared generated sat model 
sat unsat boundary average sat model shifted left sat backtracking algorithm combined coordinate descent real space 
jun gu paul purdom john franco benjamin wah percentage satisfiability number clauses minimum minimum 
percentage satisfiability average sat problem models jcj min jcj min variables respectively 
problem instances generated smaller length shortest clauses lower percentage satisfiability 
drawn smaller values sat problem model 
values problem instances generated average sat model unsatisfiable making harder local search algorithm handle average sat problem model 
experimental results confirmed took local search algorithm sat example longer time solve problem instances generated average sat models 
factors affect property random models significantly 
average sat problem model slight variation length shortest clause cnf formula significantly shift sat unsat boundary 
solid curve generated average sat model 
length shortest clause model 
dotted curve generated average sat model length shortest clause set 
clearly shorter clauses enforce tighter constraints generate harder random instances model 
incomplete algorithms fail unsatisfiable inputs effective half planes sat model pn ln average sat model probability random formula satisfiable high see section 
incomplete algorithms fail satisfiable inputs effective regions complementary 
experience best complete algorithms caused conclude 
average sat formulas easy best algorithms 
sat formulas difficult best algorithms 
formulas generated models similar difficulty average clause length large 
obviously conflicts beliefs 
algorithms satisfiability sat problem survey 
practical input models 
random input models discussed suitable analytical studies sat algorithms generate formulas possess symmetry exploited analysis 
actual formulas different structure 
structured problem instances practical sat applications essential evaluate performance sat algorithms 
examples ffl regular sat models 
models derived problems graph coloring queens assess performance sat algorithms 
ffl practical applications problems 
models derived practical application domains integrated circuit design mobile communications computer architecture network design computer aided manufacturing real time scheduling variety special characteristics see section 
experiments strongly suggest little correlation performance sat algorithm tested random input models performance algorithm tested practical input models 
local search faster random inputs slower complete sat algorithm problems raised practical applications 
boundary phenomenon discussed random models artifact probabilistic models 
observed practical input models 
practical applications ultimately important difficult people outside area application understand important difficult particular application problem difficult develop general theory speed sat algorithms applications 
research done regular source problems hope better understanding speed sat algorithms applied wide range practical applications 

splitting resolution recursive replacement formula formulas solution implies solution original formula effective paradigm solving cnf formulas 
recursion continues primitive formulas generated solved determine satisfiability original 
way achieve splitting 
splitting variable selected formula formula replaced sub formula possible truth assignments subformula clauses original satisfied assignment literals original formula falsified assignment 
sub formula contains original formula satisfying truth assignment sub formula 
splitting insures search solution terminates result 
effective paradigm resolution 
resolution variable selected resolvent see obtained added original formula 
process repeated exhaustion empty clause generated 
original formula satisfiable empty clause resolvent 
new formula step total number steps resolvents extremely large compared number clauses jun gu paul purdom john franco benjamin wah original formula 
algorithms resolution form possible resolvents particular variable time 
done original clauses contain variable negation may dropped 
algorithm may splitting resolution 
early examples approaches forms davis putnam procedure 
original dp procedure resolution revised version davis putnam loveland dpl procedure splitting 
combining splitting depth search dpl procedure avoids memory explosion occurs inputs solved original dp procedure 
recursive sat algorithms primitive conditions recursion 
formulas empty clause solution 

formulas clauses solution 

formulas variables variables assigned values trivial 
subsections various sat algorithms organized basic approach algorithm takes 
algorithms simpler want practice interest possible analyze running time random formulas 

resolution 
clauses distinct resolvent clause disjunction resolvent logical consequence logical pair clauses 
resolution process repeatedly generating resolvents original clauses previously generated resolvents null clause derived resolvents created 
case refutation formula unsatisfiable case satisfiable 
formulas order clauses resolved big effect effort needed solve 
worst case associated best possible order order selected formula received considerable study 
studies formulas solution obvious resolution algorithm 
eventually stronger result shown nearly random sat formulas need exponential time ratio clauses variables constant value depends 
constant nearly formulas set solution 
number restrictions extension resolution proposed applied cnf formulas 
restrictions aim shorten amount time needed compute resolution derivation limiting number possible resolvents choose resolution step 
extension aims provide shorter derivations possible resolution adding equivalences offer clauses resolve 
nice treatment refinements chapter 
mention 
set support 
split formula sets clauses satisfiable 
permit resolutions involving clause appropriate previous resolvent 
set called support set 
algorithms satisfiability sat problem survey restriction useful large portion formula easily determined satisfiable 
resolution 
clauses resolved positive literals resp 
negative literals resolution step called resolution resp 
resolution step 
resolution resp 
resolution resolution resp 
resolution steps 
clearly great potential gain restriction due usually low number possible resolvents consider step 
shown formulas solved polynomial time general resolution require exponential time resolution 
linear resolution 
linear resolution resolution step involves generated resolvent clause previous resolvent clause formula 
depending choice initial clause previous resolvents possible complete refutation 
regular resolution 
path resolution tree variable eliminated 
davis putnam resolution 
resolvents respect particular variable formed clauses original formula containing variable dropped 
doing change satisfiability formula change set solutions extent value variable longer relevant 
dropping clauses natural form resolvents variable resolvents second variable 
doing resolution way easy find satisfying assignment formula satisfiable 
step formula just variable value tested see satisfies formula 
pick satisfying value plug formula step converting variable formula 
solve formula proceed manner assignment variables 
extended resolution 
pair variables formula create variable append expression 
judicious extensions result polynomial size refutations problems polynomial size refutations extension 
strategies help reduce time compute resolution derivation 
subsumption 
literals clause subset clause smaller clause said subsume larger 
assignment values variables satisfies smaller clause satisfies larger larger dropped changing set solutions 
subsumption particular importance resolution algorithms resolution tends produce large clauses 
jun gu paul purdom john franco benjamin wah pure literals 
literal pure occurrences positive negative 
resolvents generated resolving pure literal clauses containing pure literal removed loss 
important improvement basic resolution algorithm remove clauses containing pure literals resolving non pure literals 
resolution applied sat main reason interest resolution applied difficult problem solving sentences order predicate logic 
vast literature subject 
bibel book topic 

backtracking 
backtracking algorithms splitting 
iteration procedure selects variable generates sub formulas assigning values true false selected variable 
subformula clauses containing literal true variable assignment erased formula clauses contain literal false literal removed 
backtrack algorithms differ way select variable set iteration 
unit clause rule pure literal rule smallest clause rule common ones 
state algorithm informally 
flow control splitting algorithms represented search tree 
root tree corresponds initial formula 
internal nodes tree correspond sub formulas solved directly leaf nodes correspond sub formulas solved directly 
nodes connected arcs labeled variable assignments 
simple backtracking 
formula empty clause clause value false exit report formula solution 
formula variables exit report formula solution 
current assignment values variables solution original formula 
select variable value 
generate sub formulas assigning possible value selected variable 
solve subformulas recursively 
report solution sub formula solution report solution 
unit clause backtracking 
algorithm simple backtracking variables selected 
clause contains unset variables select variable assign value satisfies clause containing select unset variable 
practice improved variable selection results faster backtracking 
clause order backtracking 
algorithm simple backtracking variables selected 
setting solve formula select clause evaluate true false depending setting unset variables 
select variables clause value determined 
setting variables affect value clauses algorithm avoids need assign values variables 
algorithm algorithms satisfiability sat problem survey stated finds solutions compressed form 
solutions come cylinders variables value don care 
single solution unset variables represents set solutions obtained making possible assignment unset variables 
probe order backtracking 
algorithm simple backtracking clauses selected 
temporarily set unset variables predetermined value 
select clause evaluates false setting 
return previously unset variables back unset continue clause order backtracking 
practical formulas consider adding refinements probe order backtracking search soon solution carefully choose probing sequence just setting variables fixed value probe sequences time carefully select variable set resolution increase input size 
sixth best prize winning entry sat competition improvement probe order backtracking 
franco noticed random assignment solves nonzero fraction formulas average sat model pn large compared ln simple uses idea lead average time combining idea clause order backtracking leads probe order backtracking fast pn ln probe order backtracking appears similarities method humans problem solving focuses algorithm attention aspects problem causing difficulty setting variables causing certain clauses evaluate false 
reason somewhat similar incomplete searching algorithms discussed section 
shortest clause backtracking 
algorithm clause order backtracking clause selected 
case select shortest clause 
corresponding idea constraint satisfaction set variable constraining relation 
idea quite important practice 
jeroslow wang 
backtrack search terminated early checking remaining clauses solved linear programming relaxation see sections 
implementation idea expensive 
jeroslow wang proposed simpler effective technique similar spirit 
idea splitting apply procedure iteratively chooses variable value sense maximizes chance satisfying remaining clauses 
procedure backtrack reasonably fast 
assignments determined procedure temporarily added current partial truth assignment 
procedure succeeds eliminating clauses search terminated formula satisfiable 
procedure fails control passed split temporary assignments undone backtracking resumes 
choice variable value iteration maximizes weight subset clauses subset remaining clauses containing variable positive literal jun gu paul purdom john franco benjamin wah negative literal 
length clause denoted jcj number literals falsified current partial assignment sum clauses satisfied current partial assignment 
weight may compared johnson see non backtracking heuristics 

backtracking resolution 
algorithms adapted ideas inspired resolution splitting algorithms 
example resolution view point pure literals interesting lead single sub formula complex original formula perspective splitting pure literals lead sub formulas solutions sub formula literal value false subset literal value true 
original formula solution formula associated true literal 
pure literal rule algorithm 
select variable value 
variables values current setting solution satisfies clauses 
value selected variable results clauses depend variable having value true generate subformula assigning selected variable value literals true 
generate sub formula values selected variable 
solve sub formulas 

clause area 
clause distinct literals leads fraction possible variable settings solutions 
think clause blocking area venn diagram formula 
showed combining idea inclusion exclusion careful programming leads algorithm runs polynomial average time ln 
sum area clauses variable setting leads solution 
idea works particularly shortest clause backtracking algorithm tends eliminate short clauses 
see probabilistic analysis idea 
average time analysis done 

improved techniques backtracking 
section considers refinements added basic backtracking resolution techniques 
similar techniques discussed 
branch merging 
complementary preclusion 
backtracking frequently problems queens problem known symmetry group set solutions 
cases search trees possess equivalent branches merged reduce search effort 
symmetry group greatly speed finding solutions 
see examples field group theory 
brown purdom gave additional problems arise making backtracking techniques backtracking algorithm needs set variables different orders different branches search tree 
search rearrangement 
known constrained search ordering search 
faced choices extending algorithms satisfiability sat problem survey partial solution efficient choose offers fewest alternatives 
nodes fewer successors generated early search tree nodes successors considered 
vertical variable ordering horizontal value ordering special cases search rearrangement 
rule determine variable select called branching rule 
researchers actively investigating selection branching variables dp procedures 
hooker studied branching rule effect respect particular problem instances 
bohm experimented branching effect parallel dp procedure implemented mimd machine :10.1.1.40.9517
hammer kogan developed branching rules aim fastest achievement horn structures 
particular forms search rearrangement discussed section 
sat general sat 
practical applications constraints problems coded sat formulas 
sat problem formulation frequently practical applications constraints coded sat clauses 
important heuristic sat problem solving solve sat clauses fast polynomial time algorithms 
fast operation significantly reduce search space 
truth assignment rest variables handled dp procedure 
idea sat solver gallo sat relaxation algorithm 
similar ideas solving sat clauses developed 
sat solver uses weighted number occurrences occurrences sat clauses count occurrences 
added limited amount forward checking quickly determine sat formulas sat solver 
sat contest winning programs sat solvers slightly slower 
similar techniques developed horn sat relaxation satisfiability testing 
crawford tableau horn clauses separated non horn clauses 
dpl procedure tableau applies priority unit clause rule necessary branches variable selected non horn clauses successive heuristics 
backmarking 
failure observed detected algorithm simply records source failure jumps back source failure skipping irrelevant levels search tree 
effective search rearrangement need backjumping 
search orders tend associated source failure level back 
backtracking lookahead 
lookahead processor preprocessing filter prunes search space inconsistency checking 
backtracking lookahead processing performed depth tree traversal lookahead tree pruning processor deletes nodes search tree value assignments inconsistent partial search path 
techniques class include partial lookahead full lookahead jun gu paul purdom john franco benjamin wah forward checking network heuristics discrete relaxation 
backtracking proving non existence 
dubois andre carlier proposed complete sat algorithm csat 
csat developed proof non existence solution 
algorithm uses simple branching rule local processing nodes search trees detect search path consistency search decision 
performed efficiently dimacs benchmarks 
intelligent backtracking 
performed directly variable causes failure reducing effect thrashing behavior 
methods category include dependency directed backtracking revised backtracking simple intelligent backtracking number simplifications 
freeman intelligent backtracking algorithm posit propositional testbed 
algorithm mom heuristic detecting failed literals minimizing constant factors speed backtracking search 
effort devoted development backtracking oriented programming languages special purpose computer architectures parallel processing techniques macro expansion 
applications backtracking require relatively little storage method decrease running time program increasing storage requirements 
idea macros assembly language way done assembly time times run time 
increases speed nodes processed tree 
backtrack programming 
focused developing new programming language backtracking search 
includes sequential prolog programming language prolog intelligent backtracking scheme logic programming 
special purpose architectures 
special purpose hardware machines built prune search space perform backtracking search ai computations 
parallel processing 
parallel processing techniques developed speed search computation 
branch bound 
known ordered depth search 
select variable 
possible value variable generate sub formula compute backtracking mechanism parallel prolog programming languages 
algorithms satisfiability sat problem survey quick compute upper bound quality solution subformula 
solve recursively sub formulas cost best solution far 
branch bound recognized generalization heuristic search procedures ao sss alpha beta dynamic programming algorithm 

remarks complexity 
worst case time known sat algorithms exponential power input size 
naive algorithm tries variable setting requires time variable formulas 
sat best known bound worst case complexity worked slightly obtained 
topic 
np complete problems exponential lower bound results sat 
proven resolution algorithms need time exponential power input size 
lower bound analyses done splitting algorithms 
comprehensive treatment complexity propositional proofs see survey urquhart 

local search local search major class discrete unconstrained optimization procedures applied discrete search space 
procedures solve sat introducing objective function counts number unsatisfiable cnf satisfiable dnf clauses solving minimize value function :10.1.1.34.6853
section summarize basic framework including search space model essential components ideas early development local search algorithms sat problem 
describe randomized local search randomized local search trap handling greedy local search detail 

framework 
local search local optimization primitive forms continuous optimization applied discrete search space 
early techniques proposed cope overwhelming computational intractability np hard combinatorial optimization problems 
major periods development local search 
early greedy local search method able solve small size unconstrained pathfinding problems tsp 
middle late eighties powerful techniques see section randomized local search developed 
randomized local search algorithm handle large size constrained problems csp sat problems efficiently 
minimization maximization problem objective function feasible region typical local search procedure requires solution point predefined neighborhood ae current solution point set searched point 
point exists new current solution point process iterated 
retained local optimum respect 
set feasible solution points generated jun gu paul purdom john franco benjamin wah valley basin terrace trap plateau 
number local minimum structures 
trap local minima difficult deal 
locally improved neighborhood 
apply local search particular problem needs specify neighborhood procedure obtaining feasible starting solution 
local search efficient reasons 
search full assignment assigned variables search space 
search efforts focused single path search space 
second local search refines improvement local neighborhood testing improvement improvement takes action improvement 
objective function polynomial number input numbers testing action done efficiently 
little effort needed generate solution point 
major weakness local search algorithm tendency get stuck locally optimum configuration local minimum 
greedy local search pursues paths step leads improvement leads procedure stuck randomized local search 
greedy local search procedure gets stuck flat places local minima 
search techniques statistical optimization simulated annealing stochastic evolution conflict minimization local search variations local search :10.1.1.123.7607
search problems encountered terms computing time memory space local search achieves orders magnitude performance improvement conventional techniques branch bound 
algorithms satisfiability sat problem survey 
level search space model 
large number real experimental data suggest typical local minimum structures see 
valley basin ideal cases find global minimum quickly 
local search related heuristics handle terrace plateau difficulty 
difficult situation trap group local minima confined 
search process walks set local minima periodically get away special mechanism 
general may traps search problem 
characteristics trap closely related search algorithm objective function search space structure 

informal example level search space model 
search process go open search upper open portion search space peak search middle portion search space trap search valley portion search space 
observations suggest search space may roughly divided different levels depending problem structures 
level search space structure proposed development sat algorithm see section 
informal example model 
model search space roughly viewed levels top level middle level bottom level 
top level upper open portion search space smoothing edges 
optimization algorithms descend quickly top level perform quite 
middle level middle portion search space relatively big mountain peaks 
descent search process may encounter problems may tunneling random heuristics see section proceed 
bottom level bottom portion valleys particular lowest valley traps 
local search falls trap may locked loop local minima 
algorithms succeed stage difficulty continuing 
sat problem high probability greedy local search fall trap easily 
case variables updated quickly 
jun gu paul purdom john franco benjamin wah related clauses oscillate sat unsat states 
search limited states 
help little chance getting explore states 
observations suggest multiphase search handle np hard problems 
may open search top level peak search searching coarse peak structures middle level trap search tracking fine rugged trap surface structures valleys 
major heuristics local search discussed subsection 

components local search 
number efficient local search algorithms sat problem developed 
previous experience indicated greedy local search strategy adapted perform sat formulas 
past lessons showed components crucial development efficient local search algorithm satisfiability np hard problems 
min conflict heuristics best neighbor heuristics random value variable selection heuristics trap handling heuristics 

min conflicts heuristics 
different forms min conflict heuristics proposed solving sat csp problems 
min conflict heuristics aim performing local conflict minimization boolean discrete real spaces min conflict heuristics important handle constraints constrained optimization problem 
min conflict heuristic boolean space 
multiple values assigned variable represented vector boolean labels 
boolean label indicates variable instantiation specific value 
labels conflicting values satisfy constraint 
conflicts due assignment formulated set objective functions 
objective functions minimized changing values assigned labels 
min conflict heuristic discrete space 
interrelated objects chosen variables 
variables conflicting values satisfy constraint 
number conflicts due assignment formulated objective function 
objective function iteratively minimized changing values assigned variables 
min conflict sat 
inconsistency objective objective function sat problem gives number unsatisfied clauses 
cnf true objective function takes global minimum value corresponding solution point 
early days min conflict variously called inconsistency removing inconsistency resolution conflict resolution enforce local consistency local conflict minimization 
minton shortened words concise term min conflicts 
min conflict heuristics real space see examples section 
algorithms satisfiability sat problem survey objective function basis design sat sat sat gsat algorithms 
performance 
min conflict heuristics applied solve csp sat problems 
showed significant performance improvements compared traditional backtracking search algorithms 
effectiveness min conflicts heuristic observed russel norvig kumar johnson minton selman :10.1.1.34.6853
early local search algorithm handle small size path finding problem tsp 
introducing min conflicts heuristics local search handle difficult constrained problems 

best neighbor heuristics 
local search proceeds feasible solution point reduces objective function 
neighboring feasible solution points local search take account neighbors relative performance respect objective function 
best neighbor heuristic 
greedy algorithm selects best neighbor yields minimum value objective function takes best neighbor direction descent direction objective function 
real search space continuous optimization algorithms find best neighbor feasible solution efficiently 
number local global optimization algorithms developed solve sat problem 
version gsat algorithm proposed greedy local search algorithm :10.1.1.34.6853
performance 
greedy local search may stuck local minima may efficient practice 
best neighbor heuristic conjunction random value variable selection trap handling heuristics described 

random value variable heuristics 
random value assignment random variable selection techniques fundamental design effective local search algorithm np hard problems 
random flip heuristic randomly flip truth values variables sat formula 
simple heuristic implemented sat algorithms local handler 
proven effective improving performance greedy local search algorithms 
similar heuristic random swap develop local search algorithms csp queen problems 
showed significant jun gu paul purdom john franco benjamin wah performance improvement solving large size queen problems 
random value assignment heuristics 
include randomly select value generates minimum number conflicts randomly select value symmetry value producing performance randomly select value conflict minimization local minima encountered 
simple random value assignment heuristic random disturbance early solving tsp problem 
random variable selection heuristics 
important heuristics 
variable heuristic select variable randomly 

bad variable heuristic select variable set conflicting variables randomly 
random variable selection heuristic important heuristics design local search algorithms np hard problems 
local search solution sat problem local search solution csp queen problems 
conflicting variables sat problem contribute unsatisfied clauses 
accordingly bad variable heuristic sat problem randomly select variable unsatisfied clauses conflict minimization 
bad variable heuristic implemented solve large size queen problems implemented sat algorithm 
bad variable heuristic independently developed papadimitriou sat problem wsat algorithm selman 
partial pre random variable selection heuristics 
partial variable random selection partial alternating variable selection techniques 
variants partial random selection include partial alternating selection conflicting non conflicting variables combination partial deterministic partial random variable selection partial interleaved selection different search phases partial random selection meta heuristic control 
simplest selection strategies include select variable deterministically randomly select variable randomly conflict minimization select variable deterministically randomly set conflicting variables select variable randomly conflict minimization select variable deterministically select variable randomly set conflicting variables conflict minimization certain periods search select variable deterministically randomly select variable randomly conflict minimization certain periods search select variable deterministically randomly algorithms satisfiability sat problem survey set conflicting variables select variable randomly conflict minimization certain periods search select variable deterministically select variable randomly set conflicting variables conflict minimization 
partial random variable selection heuristics sat problem variable may selected unsatisfied clauses random partially alternating partially periodic partially interleaving order 
partial pre random variable selection heuristics implemented sat algorithm solve large size queen problems 
similar heuristic partial random variable selection random walk developed selman kautz cohen independently 
performance 
random partial variable selection heuristics introduced design sat qs qs qs algorithms 
overcome weakness greedy local search algorithms 
compared greedy local search offer orders magnitude performance improvements terms computing time solving hard large satisfiability problems csp problems multi variables seconds 
design sat sat sat algorithms 
selman developed applied number random variable selection heuristics improve performance greedy gsat algorithm 

trap handling heuristics 
search process combating local minima 
search process approaching final search stage trap handling heuristics needed cope local minima traps see sections 
tunneling heuristic change value variable change value objective function 
tunneling heuristic sat problem flip truth value variable change value objective function see section 
local tracking heuristics 
local tracking heuristics track break local loops periodic occurrence set local minima 
frequently heuristics include track local loop falling trap give low priority flip variables local minimum loop give high priority flip variables lead new descending direction lock release trapping variables periodically adaptively statistically move gently trap handle fine local structures move strongly trap handle coarse local structures jump trap walking inside sufficiently long 
jun gu paul purdom john franco benjamin wah multiphase search heuristics 
multiphase heuristics part multispace search heuristics 
developed adapt different phases search process perform poor initial search serious local search conflict minimization perform initial search serious local search conflict minimization perform initial search rough local search serious local search conflict minimization perform initial search rough local search serious local search alternatively conflict minimization perform rough initial search coarse local search fine local search conflict minimization 
multispace search heuristics 
structural multispace operations developed empower search process information flux derived sequence stepwise structural transformations see section 
include multispace scrambling transition search space smoothing multiphase search local global passage tabu search perturbations 
disturb environment forming local minima facilitate efficient local search local minima 
performance 
trap handling heuristics significantly improved search efficiency sat algorithm see section 
multiphase multispace search heuristics applied variety practical applications effective 

boolean local relaxation 
boolean local relaxation may viewed deterministic local search 
early inconsistency relaxation technique developed solving constraint satisfaction satisfiability problems 
variable having values boolean labels indicate variables instantiation particular boolean values 
conflicts produced assignment coded set boolean objective functions label 
objective function ith variable kth label defined constraint labels note right hand side eq 
cnf formula extended literals 
boolean relaxation local conflict minimization process 
iteration algorithm checks variable label iteratively minimizes objective functions flipping bits truth values assigned labels objective function change keep objective function reduced keep best update label report inconsistency status 
iteration terminate inconsistency signal turns 
boolean local relaxation algorithm suitable vlsi implementation 
parallel algorithms architectures dra dra dra implemented speed csp sat computations objective function defined label directly 
algorithms satisfiability sat problem survey procedure dra boolean inconsistency inconsistency true inconsistency true inconsistency false variable label evaluate objective function local conflict minimization continue update label value inconsistency true 
dra local relaxation algorithm 

furthermore combined backtracking search csp sat applications 
iterative local conflict minimization direct applications sat csp boolean local search predecessor early local search algorithms csp sat problems 

constraint satisfaction simulated annealing complexity study 
early constraint satisfaction simulated annealing complexity theory contributed significantly original development local search algorithms sat problem 
notable early developments sat algorithms queen models algorithms scheduling applications simulated annealing algorithm sat algorithm 

sat algorithms 
objective functions dra algorithms defined boolean labels 
late eighties gu observed conflicts boolean objective functions formulated objective function global minimum objective function correspond conflict free solution csp problem 
accordingly iterative local minimization procedure boolean relaxation local search procedure minimize objective function 
idea led directly early design sat algorithms objective function defined number unsatisfied clauses variables 
global minimum objective function corresponds solution sat problem 
gu developed jun gu paul purdom john franco benjamin wah number randomized local search algorithms sat problem 
furthermore efficient heuristics section developed improve performance local search algorithms 
due important industrial applications time effectiveness sat algorithms tested csp benchmarks sat problem queen problems 
important industrial application sat vlsi engineering 
sat algorithm family local search algorithm sat developed theoretical study vlsi applications 
late eighties little progress theoretical analysis sat algorithms 
sat algorithm applied vlsi circuit testing synthesis 
problems formulated instances sat max sat problems 
sat algorithm efficient vlsi design problems 
important application area sat problem industrial scheduling 
late eighties ibm nasa working number important scheduling projects 
applications involved solving large size scheduling task assignment problems critical timing spatial resource constraints 
scheduling task assignment problems known satisfiability problem 
sat formulas characterize problems precisely 
significant local search solutions scheduling task assignment problems derived sat algorithm family 
due cnf formulation sat problem able provide descriptive geometric model able demonstrate scheduling task assignment operations expressively 

queen scheduling models qs algorithms 
queen problem benchmark constraint satisfaction problem 
middle late eighties gu worked various queen problem models combinatorial optimization 
remarkable coincidence queen model represents significant model scheduling task assignment problems 
underlying structure queen problem represented complete constraint graph gives relational model fully specified constraints multiple objects 
variations dimension objects relative positions weights constraints led hyper queen problem model consists simple basic models ffl queen problem base model 
queens indistinguishable constraints queens specified binary values 
ffl queen problem weighted queen model 
queens distinguishable associated cost constraints queens specified weights 
ffl queen problem queens placed dimensional theta theta rectangular cuboid 
special case nm queen place queens rectangle 
ffl queen problem queens allowed placed row column 
queen hyper queen problem model objects tasks performance criteria timing spatial resource constraints wide range scheduling task assignment problems 
queen problem algorithms satisfiability sat problem survey general model industrial scheduling task assignment problems 
remarkable coincidence models difficult scheduling projects time queen hyper queen problems 
required efficient solutions queen hyper queen problems 
scheduling problems modeled various hyper queen models specific performance criteria known np hard 
scheduling computational tasks multiprocessors example hyper queen model weighted queens placed rectangle 
denote execution time number processors execution time ith task ij communication time ith task jth task goal place task queens board minimize longest execution path topological constraints 
hyper queen models freed original queen problem puzzle game background 
practical applications queen hyper queen models real world problems 
include task scheduling real time system task assignment computer resource management vlsi circuit design air traffic control communication system design 
polynomial time analytical solutions queen problem exist solve general search problems practice 
local conflict minimization qs algorithm developed late implemented early 
local search algorithm developed queen problem 
improved local search algorithms queen problem developed 
qs near linear time local search algorithm efficient random variable selection strategy 
qs near linear time local search algorithm efficient pre random variable selection assignment 
qs linear time local search algorithm efficient partial random variable selection assignment techniques 
compared local search algorithm partial random variable selection assignment heuristics significantly improved search efficiency orders magnitude 
qs example able solve queens seconds 
years releasing qs algorithm minton independently reported similar local search algorithm queen problem 
major difference minton algorithms sosic gu algorithms minton algorithm dimensional local search random heuristics 
early local search solutions scheduling applications developed late eighties 
industrial companies worldwide developed software systems various scheduling applications 

simulated annealing algorithm max sat 
motivated method simulated annealing hansen jaumard proposed steepest ascent descent algorithm maximum satisfiability max sat problem 
approach hansen jaumard focused local change defined objective function switching variable related clauses 
objective function maximizes local compensation jun gu paul purdom john franco benjamin wah variable solving max sat problem 
objective function sat problem objective function global minimum corresponds solution sat problem 
furthermore hansen jaumard local optima checking handle local optimum providing additional guidance search direction 

theoretical study sat sat 
early nineties researchers started theoretical analysis local search algorithms csp sat problems 
theoretical studies focused sat problem reported 
gu gu took algorithms sat sat sat sat algorithm family average time complexity study sat problem 
study complexity certain natural generalization sat papadimitriou gave randomized algorithm sat problem 
furthermore papadimitriou showed randomized algorithm finds assignments sat instances steps probability approaching number variables 
extensions theory algorithm applied solve random sat problems 
early local search method large size queen scheduling problem attracted great attention ai area 
due close relationship csp sat sat problem special case csp 
queen problem hand typical benchmark problem csp 
find efficient non analytical search algorithm queen problem algorithm directly translated efficient algorithm sat problem 
analytical solutions exist queen problem greater equal 
consist restricted subset solutions 
formulates queen problem csp backtracking search general solution 
practice backtracking search slow solve queen problem larger 
local search algorithms solving large size queen problems breakthrough point direction 
solving large scale queen problems selman levesque mitchell reported empirical results gsat greedy local search algorithm solving sat :10.1.1.34.6853
selman acknowledged local search solutions large size queen problems original impetus development gsat algorithm :10.1.1.34.6853

randomized local search 
section describe basic structure major components randomized local search algorithms sat problem 
model 
discrete local search procedures developed discrete unconstrained optimization model sat model 
model truth values assigned variables defined ae variable value true gamma variable value false algorithms satisfiability sat problem survey procedure sat initialization get sat instance select random initial point evaluate objective function search variable flip increase test flip perform flip evaluate objective function random flips local local handler 
sat randomized local search procedure sat problem 
random flips introduced disorder sequence variables selected local optimization perturb local search randomized downhill tunneling uphill moves 
objective function sat model counts number unsatisfied clauses objective value 
cnf true takes global minimum value corresponding basic local search 
sat algorithm sat problem shown 
consists initialization stage search stage 
search sat formula generated 
initial random solution chosen 
number unsatisfiable clauses computed assigned value objective function 
iteration function test swap performs test see objective function increase 
test flip returns true flip operation performed procedure perform flip 
function evaluate objective function updates objective function 
procedure terminates objective function reduced zero solution sat instance 
practice objective function reduces zero procedure may stuck local minima 
sat algorithm simple local handler performing random flips 
combined greedy local descent reducing objective function random uphill moves increasing objective function improving jun gu paul purdom john franco benjamin wah procedure local handler random select variable perform flip evaluate objective function 
simple local handler sat algorithms 
random flips new random solution applied algorithm sat algorithm sat algorithm sat algorithm sat algorithm 
sat convergence performance effectively 
sat algorithm family local handlers implemented 
algorithms difficulty proceed algorithms call local handlers heuristics see section improve algorithms convergence performance 
random flips sat algorithms order selecting variable local examination loop trivial 
essentially select variable randomly examination phase local search 
random flips noise 
local search procedure stuck local minimum progress may achieved noise perturbation change location search space 
effectiveness local minima handled significantly affects performance local search algorithm 
researchers proposed number techniques jumping climbing annealing indexing handle local minima 
simulated annealing search process occasionally moves search space large uphill moves small ones 
probability large uphill moves gradually reduced search progresses 
variety local handlers designed local search algorithms 
sat uses local handler may randomly negate truth values variables new solution point 
basic idea generate random exchanges current solution points search stuck local minimum 
search accepts modified point new current solution value objective function better worse traditional local search gsat greedy local descent restart :10.1.1.34.6853
simple local handler effectively improved convergence performance sat algorithm 
tunneling heuristic 
local handler activating condition significant effect performance running time average running time local search algorithm sat problem 
conditions activating local handlers differ algorithm algorithm see 
sat algorithm algorithms satisfiability sat problem survey 
tunneling local handler called objective function zero aggressive strategy 
sat algorithm local handler called objective function increase 
sat algorithm local handler called objective function increase objective function greater zero iterations 
algorithms condition objective function increase means objective value reduced local descent remained unchanged tunneling heuristic 
making random swing vertical direction search space local minimum encountered tunnel rugged terrain structure horizontal direction moving local basin local basin attempt locate better locally optimal solution 
tunnel see thought short cut passing mountain separating points equal elevation 
local minimum encountered tunnel mountain neighboring basin long change increase objective function 
tunneling search region local minima effectively 
behavior local search tunneling illustrates fact seemingly innocuous changes optimization routine surprisingly large effect performance 
tunneling implemented sat algorithm late eighties 
proven effective solving sat problems 
parallel local search 
parallel algorithms vlsi architectures developed accelerate csp sat problems 
depending implementations ways grouping variables clauses parallel evaluated simultaneously 
sat algorithms frequently part computation function evaluate objective function 
takes ml time update objective function 
execution evaluate objective function done simple bit parallel manner time sequential computer 
computer word bits dec alpha machine 
number literals clause practical cnf formulas 
local search algorithm pack literals clause bits computer word evaluate literals clause parallel 
clauses ml take procedure evaluate objective function jun gu paul purdom john franco benjamin wah time evaluate update objective function 
occasionally clause may literals packed computer words evaluated simultaneously 
general bit parallel evaluation method implemented sat algorithm 
complete local search 
local search algorithms incomplete find solutions certain cnf formulas give answer cnf formula satisfiable 
overcome problem researchers developed complete local search algorithms test satisfiability unsatisfiability 
basic idea sat sat algorithms combine local search systematic search procedure keeping local search efficiency maintaining search completeness systematic search method 
node search tree solution point unsatisfiable algorithm backtracks continues searching solution unsatisfiability proven 
sat sat algorithms early experiments complete local search algorithms 
probe order backtracking simplified version complete local search 
crawford studied complete local search algorithm 
weights assigned clauses help choose branch variables 
variables occurring heavily weighted clauses precedence 

randomized local search trap handling 
early observation trap phenomenon development level search space model section gu developed sat algorithm trap handling ability 
sat algorithm monitor break local minimum loops handle multiple traps search 
current version sat algorithm contains advanced data structures complicated trap detection handling methods 
sake simplicity gives brief outline algorithm 
sat starts initial random solution set limiting parameters 
max time example specifies maximum number times allowed restart new search 
number unsatisfiable clauses computed assigned value objective function 
loop limited max time 
procedure complete flip flips variables reduce value objective function 
evaluate objective function updates objective function 
second loop randomized local search trap tracking handling 
trap detection facilities installed places loop record trap statistics 
essential trap height width parameters subsequent decision making 
trap may contain global minimum solution searched reasonable effort 
leaving trap early late result losing solutions wasting computing time 
time jump trap determined parameter max trapping times 
search algorithm jumps trap alternatives pursue 
start new search 
loop randomized local search procedures deploying random value random variable heuristics see section grouped partial random selection heuristics 
select variable randomized local search objective function may increase search 
algorithms satisfiability sat problem survey procedure sat initialization get sat instance select random initial point evaluate objective function search restart times restart times max time open search flip variables reduce complete flip evaluate objective function parameters trap tracking clean trap records times peak search randomized local search times max times randomly select var randomized local search select var flip randomized local search evaluate objective function trap search trap detected times random flip vars conflicting clauses strong flip evaluate objective function random flip percent pct variables gentle flip pct evaluate objective function random flip small set variables weak flip set evaluate objective function initialization new trap clean trap records restart new random point restart times 
sat randomized local search procedure trap handling 
jun gu paul purdom john franco benjamin wah trap detected number strategies conduct trap search 
approach proposed gu sequence random flip operations performed see 
intensity flip operations evolves strong weak tailored coarse fine structures trap 
variable flipped unsat clause force value true procedure strong flip followed random flip percent variables procedure gentle flip random flip small number variables procedure weak flip 
additional facilities hill climbing tabu search variable locking unlocking developed 
sat algorithm walk rugged surface trap adaptively 
real execution performance sat algorithm section suggests presently fastest local search algorithms sat problem 

greedy local search 
traditional local search proceeds feasible solution point reduces value objective function 
neighboring solution points local search evaluate neighbors relative performance respect objective function 
greedy algorithm selects best neighbor yields minimum value objective function takes best neighbor direction descent direction objective function 
real search space continuous optimization algorithms find best neighbor solution efficiently 
unconstrained local global optimization algorithms developed solving sat problem see section 
discrete search space greedy local search algorithm searches best neighbor solution 
requires iteration algorithm examine possible moves select maximum descent 
greedy local search special case coordinate descent real space 
selman proposed greedy local search procedure gsat sat problem :10.1.1.34.6853
search step algorithm evaluates moves procedure gsat max tries randomly generated truth assignment max flips satisfies ff return propositional variable change truth assignment gives largest increase total number clauses ff satisfied truth assignment reversed return satisfying assignment 
gsat greedy local search procedure sat problem :10.1.1.34.6853
max flips max tries constants ff set clauses 
search step gsat takes best neighbor gives objective function 
algorithms satisfiability sat problem survey selects best move gives greatest decrease total number unsatisfied clauses 
algorithm stuck local minimum gsat uses side walk form tunneling heuristic move aside 
gsat procedure parameters max tries max flips control algorithm maximum running state 
late eighties vlsi researchers experimented large number practical sat formulas greedy local search greedy local search stuck local minima easily 
accordingly gu proposed method combining local descent random multiphase search trap handling heuristics see section section 
ideas subsequent sat algorithm family design 
selman bad variable heuristic partial random variable selection heuristics section random walk heuristic :10.1.1.21.2207
random heuristics random flips selecting variable unsat clause partial random variable selection improved performance gsat algorithm significantly 

tabu local search 
proposed tabu search algorithm satisfiability problem 
basic idea avoid randomness local search algorithm design 
systematic tabu list variables order avoid recurrent flips escape local minima 
tabu list updated time flip 
keeps fixed length chronologically ordered fifo list flipped variables prevents variables list flipped amount time 
study optimal length tabu list crucial algorithm performance 
showed random sat instances optimal length tabu list furthermore noted slight departure optimal length leads corresponding graceful degradation performance 
important distance optimal length leads dramatic performance degradation 

local search dnf formulas 
known laws obtain unconstrained optimization model sat model dnf formulas sat cnf formula transformed dnf formula transformed formula objective determine exists assignment clauses falsified 
solve 
number local search algorithms developed dnf formulas 
different definition evaluation schemes objective function similar structures cnf local search algorithms 
sat early dnf local search algorithms objective function defined number satisfiable dnf terms 
goal reduce objective function zero 
experimental results indicate dnf local search algorithms faster cnf local search algorithms 
jun gu paul purdom john franco benjamin wah 
historical note 
early constraint satisfaction simulated annealing complexity study contributed development local search algorithms sat problem see sections 
sat qs minton qs gsat operations research csp dra sat sat 
early development local search algorithms sat problem 
major approaches randomized local search sat greedy local search gsat 
sat local search algorithm developed vlsi engineering scheduling applications 
gsat algorithm derived early local search algorithms queen problem 
special event queen debate acm sigart bulletin 
early sat algorithms applied solve vlsi circuit design problems 
addition gu implemented local search method queen scheduling problems 
published short papers sigart bulletin 
accident papers triggered debate 
major discussions centered questions raised sigart readers 
jack mostow mentioned steve minton time published hill climbing algorithm similar gu queen problem aaai 
interested know original source local search algorithm queen problem 
lewis johnson reviewed original local search results queen problem clear queens problem solved problem fact solved years 
second question local search 
sigart bulletin vol 
bo showed analytical solutions queen problem published 
jun gu reply entitled general framework large scale constrained optimization explained analytical solutions queen problem offer restricted set solutions solve general search problem local search algorithm queen solve general constraint satisfaction problems 
discussion continued number sigart issues 
august showed analytical solutions queen problem tower hanoi problem 
readers agreed analytical solutions restricted believed local search solve problems queen 
satisfiability problem core np complete problems 
gu wrote short article efficient local search large scale satisfiability problem discussed sat algorithms general example local search 
algorithms satisfiability sat problem survey year period researchers including jack mostow steve minton bart selman dennis kibler participated various discussions 

global optimization local search proceeds solution point decreases value objective function solution point 
may neighboring solution points local search take account neighbors relative performance objective function local search may get stuck local minimum basin 
escape local minima global search strategies need developed 
strategy tunneling heuristic discussed section 
strategy select best neighboring point yields minimum value objective function 
neighboring point lead decrease objective function direction picked minimize increase objective function 
global optimization concerned characterization computation global minima maxima unconstrained nonlinear functions constrained nonlinear problems 
global optimization problems belong class np hard problems 
concept optimization rooted principle underlying analysis complex decision problems 
deals complex decision problem involving selection values number interrelated variables focus single objective objectives designed qualify performance measure quality decision 
core optimization process minimize maximize objective function subject constraints imposed values decision variables instance 
optimization algorithms designed iterative refinement process 
typically seeking vector solves optimization problem search algorithm selects initial vector generates improved vector process repeated find better solution continuing fashion sequence improving points approaches solution point possible find neighboring points improve strategies applied help escape local minima 
aspects designing global search strategies solve sat ffl problem formulations transformations 
discussed section alternative formulations instance sat global search strategies may need tailored formulation 
section unisat model transforms sat formula represented instance discrete constrained decision problem boolean space continuous optimization problem 
section strategies discrete lagrange multipliers transform sat formula instance discrete constrained optimization problem 
general transformations section 
ffl strategies select direction move 
search trajectory lacks global information search space strategies select direction move steepest descent hill climbing 
steepest descent approach chooses direction maximum gradient 
hill climbing approach hand chooses point neighborhood current point reduces objective function 
large formulas hill climbing jun gu paul purdom john franco benjamin wah methods faster steepest descent descend direction best direction leads improvement 
ffl strategies help escape local minima 
possible strategies studied past 
include local handlers combination restarts backtracking random swaps see section morris break strategy wah shang discrete lagrangian method dlm glover hansen tabu list stochastic methods simulated annealing sa genetic algorithms ga :10.1.1.26.7748:10.1.1.123.7607
section examine effects strategies 

unisat universal sat input models 
unisat models extend discrete search space real space solution point objective function characterized quantitatively 
furthermore encoding solution sat formula objective function direct correspondence solutions sat formula global minimum points objective function established 
subsequently sat formula transformed instance unconstrained global optimization problem unisat models universal laws boolean connectives cnf formulas transformed theta ordinary addition multiplication operations respectively 
true value cnf formula converted value objective function 
cnf formula clauses cm define real function transforms sat unconstrained global optimization problem min clause function product literal functions unisat model jy gamma literal clause jy literal clause unisat model gamma clause clause correspondence defined follows gamma undefined algorithms satisfiability sat problem survey clearly value true iff corresponding gamma unisat model real space direct extension discrete sat model boolean space 
model similar unisat proposed independently neural network area 
significant difference neural network model unisat efficiency practical applicability 
neural network model handled traditional nonlinear programming methods extremely slow unisat easily solved conjunction local search approach simple discrete accounting techniques 
unisat models transform sat discrete constrained decision problem unconstrained global optimization problem 
property transformation unisat models establish correspondence global objective function solutions original sat formula 
cnf value true takes global minimum value corresponding solution formulation unisat unisat models cnf translated jy gamma jjy jy jjy gamma jjy gamma gamma gamma gamma respectively 
solution sat formula corresponds set global minimum points objective function 
finding true value equivalent finding false value 
translation sat formulas nonlinear programs quite different integer programming approach described section 
integer programming approach views sat formula instance integer programming problem tries solving linear programming relaxation 
solution non integer rounds values nearest integers checks solution corresponds solution original formula 
rounded values correspond solution computes solution linear programming problem 

global optimization algorithm solving sat 
families unconstrained global optimization algorithms unisat problem developed 
sat basic global optimization algorithm shown 
start procedure obtain sat instance initializes generated sat instance 
objective function formulated unisat model 
sat formula minimization problem objective function 
procedure select initial solution selects initial starting point corresponding value objective function evaluated function evaluate object function 
optimization process iterative minimization objective function 
function test min tests value objective function minimized 
true minimization operation performed procedure perform min jun gu paul purdom john franco benjamin wah procedure sat initialization obtain sat instance select initial solution evaluate object function search solution testing yk minimizer test min yk perform min yk evaluate object function close solution approximate yk local handler local local handler 
sat general global optimization algorithm satisfiability problem 
followed evaluate object function updates value objective function 
procedures test min perform min evaluate object function usually performed distinction 
depending global optimization strategy objective function minimized dimensions 
methods capable optimizing dimension include line search coordinate descent coordinate newton methods 
methods optimize dimensions include steepest descent methods multi dimensional newton methods 
iterative improvement progresses global minimum point may approached gradually 
closeness solution point global minimum solution point tested solution point testing objective value testing 
procedure close solution performs closeness testing 
solution point sufficiently close global minimum point procedure approximate performs round operation converts solution point real space solution point boolean space may solution original sat formula 
procedure solution testing takes solution generated procedure approximate substitutes cnf formula verify correctness 
practice search process stuck locally optimum point 
improve convergence performance algorithm local handlers algorithms satisfiability sat problem survey procedure sat initialization initial vector local search limit bn log search local limit old search search minimizer minimize respect local handler old search log initial vector search local local round enumerate 
sat global optimization algorithm unisat problem 
may added 
effective local handler sat negate truth values variables 
existing unconstrained global optimization methods solve unisat problems see textbooks literature 
far global optimization algorithms developed 
include basic algorithms steepest descent methods modified steepest descent methods newton methods quasi newton methods descent methods cutting plane methods conjugate direction methods ellipsoid methods homotopy methods linear programming methods 
algorithm family different approaches heuristics design objective functions select initial points scramble search space formulate higher order local handlers descent directions utilize parallelism implement hardware architectures speed computations 

discrete global optimization algorithm 
nonlinear problems intrinsically difficult solve unconstrained optimization problem conceptually simple easy handle 
powerful solution techniques developed solve unconstrained optimization problems primarily calculus simple accounting algebra pivoting simplex method 
coordinate descent method gu simple algorithm sat algorithm unisat problem see 
kernel sat discrete minimizer minimizes objective function discrete coordinate descent method 
function sat algorithm initially chooses vector minimize function respect variables jun gu paul purdom john franco benjamin wah minimizer 
variable appears clause function function expressed jy gamma jy local gain factors independent computed ln time 
takes minimum value respect point gamma 
minimizer optimizes function follows set equal set equal gamma 
practice algorithm stuck local minimum point 
overcome problem simple local handler added 
local handler simply generates new initial vector start independent search 
sat algorithm objective function longer reduced log constant see iterations loop local handler called 

continuous global optimization algorithm 
continuous coordinate descent method gu huang du developed sat algorithm solving unisat problems 
objective function described unisat input model variable selected optimization gamma constants computed ml time 
minimized gamma 
complete global optimization algorithms 
sat sat sat algorithms incomplete algorithms 
order achieve high computing efficiency complete algorithms combine sat sat global optimization algorithms backtracking resolution procedures 
algorithms able verify satisfiability unsatisfiability 
gives typical backtracking global optimization algorithm 
small medium size problems backtracking able verify unsatisfiability quickly certain classes formulas slow comes verifying satisfiability possible resolutions need tried concluding inference relation holds input formula satisfiable 
experience combined global optimization algorithm backtracking resolution procedures perform certain classes satisfiable unsatisfiable formulas 
researchers investigated number solutions sat formulas 
extending dubois gave combinatorial formula computing number solutions set clauses 
carlier studied mathematical expectation number solutions probabilistic model 
incomplete sat algorithm number solutions strong effect computing efficiency 
complete sat algorithm number search levels plays crucial role 
sat sat algorithms satisfiability sat problem survey procedure sat initialization get sat instance select initial point evaluate object function backtracking global optimization backtracking procedure backtracking global optimization assigns global optimization gamma fvg append variable partial path path path broken backtracking solution return backtracking 
sat complete global optimization algorithm backtracking 
algorithms number solutions important strategy interplay global optimization backtracking resolution procedures 

continuous lagrangian constrained optimization algorithms 
previous subsections discussed unconstrained discrete continuous formulations sat problems optimizing single unconstrained objective function 
avoid getting trapped local minima algorithms solving problems strategies escape local minima 
strategies random restarts tunneling move search new starting point start 
process doing vital information obtained descent current local minimum may lost 
strategies may rely internal external force bring search trajectory local minimum 
continuous problems may difficulty dealing sat problems objective values integers 
way bring search local minimum formulate sat problem constrained optimization problem shown 
force provided violated constraints search trajectory brought local minimum 
way implement idea compute sum constraints weighted penalties update penalties continuously search 
difficulties approach lies choice proper penalties 
systematic approach lagrangian formulation 
subsections show lagrangian formulations sat problems continuous space discrete space 
jun gu paul purdom john franco benjamin wah indicated sat problem transformed continuous constrained optimization problem 
min subject mg defined repeated follows 
gamma scalar differentiable function takes norm argument iff advantages reformulating original discrete unconstrained problem continuous constrained problem 
continuous objective function may smooth local minima discrete space allowing global local search methods bypass local minima continuous space 
second continuous objective value indicate close constraints satisfied providing additional guidance leading satisfiable assignment 
third search stuck local minimum constraints violated violated constraints provide force lead search local minimum 
effective restarting new starting point local information observed search preserved 
active research past decades produced variety methods finding global solutions nonconvex nonlinear optimization problems 
general transformational non transformational methods approaches solving problems 
non transformational approaches include discarding methods back methods enumerative methods 
discarding methods drop solutions infeasible back feasible region methods attempt maintain feasibility reflecting moves boundaries moves went current feasible region 
methods combined global search involve transformation relax constraints 
enumerative methods generally expensive apply problems linear objectives constraints bilinear programming problems 
transformational approaches hand convert problem form solving 
known methods include penalty barrier lagrange multiplier methods 
penalty methods incorporate constraints part objective function require tuning penalty coefficients search 
barrier methods similar barriers set avoid solutions going feasible regions 
methods difficulties start infeasible region feasible solutions hard find 
combined methods improve solution quality 
algorithms satisfiability sat problem survey lagrangian methods lagrange variables introduced gradually resolve constraints iterative updates 
exact methods optimize objective lagrange multipliers meet kuhn tucker conditions 
eq 
reformulated lagrange multipliers unconstrained problem 
lagrangian function jjc jj augmented lagrangian function transpose set lagrange multipliers 
augmented lagrangian formulation preferred provides better numerical stability 
classical optimization theory extrema local global roots sets equations 
conditions necessary guarantee local optimality solution 
search methods solving classified local global algorithms 
local minimization algorithms gradient descent newton methods find local minima efficiently best uni modal problems 
global methods contrast employ heuristic strategies look global minima finding local minimum 
note gradients hessians local global methods 
local search methods solve forming lagrangian dynamic system includes set dynamic equations seek equilibrium points gradient path 
equilibrium points called saddle points correspond constrained minima 
lagrangian dynamic system equations follows 
dy dt gamma dt optimal solutions continuous formulation governed saddle point theorem states local minimum original problem defined exists constitutes saddle point associated lagrangian function 
saddle point lagrangian function defined satisfies condition 
sufficiently close 
advantages lagrangian formulation solve constrained optimization problems 
ffl saddle points local gradient descent ascent methods defined 
equation minus sign optimizes original variables descending path second equation optimizes ascending path 
alternatively considered global search algorithm local search component descent algorithm original variable space 
search reaches local minimum search brought local minimum weights imposed lagrange multipliers 
mechanism allows search continue trajectory breaks 
jun gu paul purdom john franco benjamin wah ffl lagrangian search similar penalty methods sense lagrange variables increased penalties constraints violated 
general penalty methods increase lagrange variable self adjusting governed amount corresponding constraint violated 
ffl search modeled started starting point continue saddle point 
ffl assignments constraints satisfied assignments minimize objective saddle points solving correspond satisfiable assignments original sat problem 
important note lagrangian search modeled incomplete find solution finite amount time prove original sat problem satisfiable 
infinite time required prove unsatisfiability 
unfortunately continuous gradient local search methods solving time consuming 
experience indicates continuous descent methods orders magnitude complex discrete descent methods 
instance takes hour cpu time sun ss workstation solve problem variables constraints 
consequently continuous formulations promising solving large sat problems 
subsection extend continuous lagrangian methods discrete lagrangian methods 
surprisingly discrete methods better solve benchmark problems solved local global search algorithms 

discrete lagrangian constrained optimization algorithms 
overcome computational complexity continuous lagrangian methods preserving benefits show subsection discrete constrained formulation sat problem solution discrete lagrangian method 
discrete lagrangian method extended theory continuous lagrangian methods 
recall section discrete constrained formulation sat problem 
min subject mg going details continuous lagrangian method extended discrete problems 
discrete lagrangian function defined follows 
um transpose denotes lagrange multipliers 
note continuous variables 
definition similar saddle point defined satisfies condition 
algorithms satisfiability sat problem survey 
set initial randomly fixed random seed 
set initial zero 
solution 
update gamma gamma delta xl 
condition updating satisfied 
update gamma theta 


generic discrete lagrangian algorithm solving sat problems 
sufficiently close hamming distance 
similar discrete lagrangian method dlm solving sat problems defined set difference equations gamma delta delta discrete gradient operator respect delta ffi ffi delta delta delta ffi gamma jffi gamma delta informally delta represents neighboring points 
implementation basic discrete lagrangian algorithm 
shows pseudo code generic discrete lagrangian algorithm implementing 
performs original variable space lagrange multiplier space discrete space delta place gradient function continuous space 
call iteration pass loop 
describe considerations implementing dlm 
initial points restarts lines 
dlm started origin random initial point generated calling fixed random seed 
set zero 
fixed initial points allow results reproducible easily 
descent ascent strategies line 
ways calculate delta greedy hill climbing involving search range hamming distance current assignments variable flipped current assignment 
greedy strategy assignment leading maximum decrease lagrangian function value selected update current assignment 
assignments vicinity need searched time leading computation complexity number variables sat problem 
hill climbing assignment leading decrease lagrangian function value selected update current assignment 
depending order search number assignments improved hill climbing strategies generally computationally expensive greedy strategies 
comparison strategies show hill climbing orders magnitude faster results solutions comparable quality 
jun gu paul purdom john franco benjamin wah conditions updating line 
frequency updated affects performance search 
considerations different continuous problems 
discrete problem discrete gradients usually small changes update variable changes 
updated iteration search avoid biasing search lagrange multiplier space original variable space experimental results show updated delta 
point local minimum original variable space reached search escape updating strategy amounts pure original variable space holding constant local minimum reached 
note strategy similar morris break strategy selman kautz gsat applies adaptive penalties escape local minima :10.1.1.21.2207
problem overlooked strategies growth penalty terms 
solving difficult sat problem penalty terms may grow large search progresses causing large swings objective function delaying convergence search 
solutions issue discussed 
amount update line 
parameter controls magnitude changes general vector real numbers allowing non uniform updates different dimensions possibly time 
simplicity benchmarks tested 
larger difficult problems smaller result shorter search time 
update rule line results nondecreasing true clause satisfied corresponding increased clause satisfied corresponding changed 
contrast applying lagrangian methods solve continuous problems equality constraints lagrange multiplier constraint increases decreases 
mechanism reduce lagrange multipliers grow bound causing large swings lagrangian function value making search terrain rugged 
strategy worsen search time benchmark problems tested values large time goes difficult problems requiring millions iterations 
happens search difficulty identifying appropriate direction move 
situation illustrated graphs show behavior dlm applied solve difficult dimacs sat benchmark problems 
search stuck sub optimal basin space objective function number unsatisfied clauses fluctuates 
search terrain modeled rugged lagrange multipliers increase search difficulty escape region 
overcome problem reduced periodically 
instance graphs scaled factor iterations 
strategy combined strategies discussed restricts grown lagrange multipliers leading solution difficult benchmark problems 
algorithms satisfiability sat problem survey iter lagrangian value 
unsat clauses iter min ave max tabu list flat moves periodic scaling iter lagrangian value 
unsat clauses iter min ave max tabu list size flat moves limit periodic scaling iter lagrangian value 
unsat clauses iter min ave max tabu list flat moves limit periodic scaling factor iterations 
execution profiles difficult dimacs benchmark problem 
figures plot lagrangian function values number unsatisfied clauses versus number iterations 
figures plot minimum average maximum values lagrange multipliers 
jun gu paul purdom john franco benjamin wah plateaus search space 
binary problems sat search may find small subset variables lead degradation objective function 
flipping variables small subset successively may lead cycle search space 
avoid undesirable situation variables flipped past stored tabu list flipped list :10.1.1.26.7748
large sat problems formulated discrete optimization problems search may encounter large flat suboptimal basins 
gradients directions search may wander forever 
discrete gradient operator delta may difficulties basins plateaus examines adjacent points differ dimension 
may able distinguish plateau local minimum 
way escape allow uphill moves 
instance gsat random walk strategy uphill walks allowed probability chance getting sequence uphill moves get deep basin small walk independent 
effective strategies allow plateau searched 
flat move strategy 
need determine time change search reaches plateau 
indicated earlier updating search plateau changes surface plateau may difficult search find local minimum inside plateau 
avoid situation strategy called flat move employed 
allows search continue time plateau changing search traverse states lagrangian function value 
long flat moves allowed heuristic possibly problem dependent 
note strategy similar selman move strategy 
tabu list 
search strategy aims avoid revisiting set states plateau 
general impractical remember state search visits plateau due large storage computational overheads 
tabu list kept maintain set variables flipped past avoid flipping variable tabu list :10.1.1.26.7748
graphs illustrate performance dlm search maintains tabu list size allowed stay basin moves flat move limit lagrange multipliers periodically scaled 
graphs show significant reduction growth lagrangian function values lagrange multipliers 
strategies dlm solve successfully hard problems dimacs benchmark suite 
results section 

convergence property average time complexity 
gu gu du analyzed convergence ratios basic methods steepest descent method newton method coordinate descent method objective function defined unisat input model 
prove subject certain conditions steepest descent method linear convergence ratio gamma newton method convergence ratio order coordinate descent method convergence ratio gamma gamma largest smallest eigenvalues hessian matrix respectively 
algorithms satisfiability sat problem survey convergence properties gu gu du roughly estimate subject certain conditions unisat problem solved log iterations steepest descent method solved log iterations coordinate descent method assumption algorithm stuck local minimum point 
gu gu preliminary analysis typical time complexity global optimization sat algorithms 
shows sat algorithm probability gamma gamman finds solution logn iterations loop randomly generated satisfiable cnf formula ff ff constant 
fact run time procedure enumerate typical time complexity sat algorithm gamma gamman log lmn gamman ln log clearly sat algorithm give answer unsatisfiable cnf formula time 

integer programming method section give integer program ip formulation sat 
describe traditional techniques integer programming approach solve sat 

integer programming formulation sat 
order represent sat inputs framework mathematical programming identify logic value true integer false gamma 
similar unisat models section boolean connectives transformed theta ordinary addition multiplication operations respectively 
standard transformation ith clause transformed linear inequality gamma jc literal clause gammaw literal clause jth integer variable 
restrict sigma requires extra constraints added insure closed interval gamma gamma formulation example cnf translated gamma gammaw gamma jun gu paul purdom john franco benjamin wah integer programming formulation obtained sat finding sigma gamma gamma gamma gamma gamma gamma gamma gamma simplex method effective solving linear programs lp single technique fast solving integer programs 
approaches developed try solve integer program integer linear program ilp 
solution non integer rounds values nearest integers checks corresponds solution original input 
rounded values correspond solution adds new constraint computes solution modified linear program 
far methods developed solve integer programs sat indirectly corresponding integer linear programs 
researchers observed optimal integer programming solution usually obtained rounding linear programming solution possible certain cases see section 
closest point optimal may feasible 
cases nearest feasible integer point linear program solution far removed optimal integer point 
integer linear program solve integer program sat sufficient simply round linear programming solutions 
sections describe existing integer programming methods solve sat 

linear program relaxation 
basic method solve integer program linear program relaxation 
approach lp relaxation achieved replacing 
lp relaxation solved efficiently sophisticated implementations dantzig simplex method minos variations karmarkar interior point method 
hooker early reported solving linear programming sat frequently produces integer solution 
kamath minos solve linear programming relaxation 
tried small sat inputs simplex method failed find integral solutions linear programming relaxations majority instances tested 

branch bound method 
branch bound essentially strategy divide conquer 
straightforward successful way solve integer programming problem 
idea systematically partition linear programming feasible region manageable subdivisions assessments integer programming problem subdivisions 
moving region subdivisions add constraint satisfied optimal linear programming solution parent region 
integer linear program ilp linear program constrained integrality restrictions 
algorithms satisfiability sat problem survey lp lp lp lp lp lp 
example branch bound tree 
linear programs corresponding subdivisions solved efficiently 
general number ways divide feasible region consequence number branch bound algorithms 
show basic procedures branch bound simple example shown 
method starts fractional solution corresponding lp relaxation 
variable fractional solution selected 
example variable set additional constant branch constraint 
resolve lp relaxation augmented constraint 
produces non integer solution branch non integer variable say constraint resolve lp extra constraint 
process continues solving augmented lp yields integer solution incumbent solution need branch node 
know optimal backtracking procedure required search extra constraints resolve augmented lp continue process integer solution obtained 
process produces binary tree shown 
way implicitly exhaust possibilities conclude optimal solution 
note time obtain incumbent solution get new upper bound minimum value objective function 
node lp yields objective function value exceeds best upper bound obtained far node solution obtained successors worse 

cutting plane method 
partitioning feasible region subdivisions branch bound approaches cutting plane algorithm solves integer programs modifying linear programming solutions integer solution obtained 
works single linear program refines adding new constraints 
new constraints successively reduce feasible region integer optimal solution 
idea cutting plane method illustrated simple geometric interpretation 
feasible region integer program integer polytope consists integer lattice points satisfying constraints 
cut inequality satisfied feasible solutions integer program 
jun gu paul purdom john franco benjamin wah related polytope integer polytope cut 
illustration cutting plane method 
cutting plane hyperplane defined inequality conflicts solution linear programming relaxation 
cutting plane passes integer polytope cuts part relaxed polytope containing optimal linear programming solution excluding feasible integer points 
cut resulting linear program solved 
optimal values decision variables linear program integer optimal new cut derived new optimal linear programming tableau appended constraints 
practice branch bound procedures outperform cutting plane algorithm 
algorithm important evolution integer programming 
historically algorithm developed integer programming proven converge finite number steps 
addition algorithm generally considered inefficient provided insights integer programming led efficient algorithms 

interior point method 
important advance linear programming solution techniques introduced karmarkar 
shown compared simplex method jumps corner point corner point lp polytope optimal solution karmarkar algorithm constructs ellipsoid inside polytope uses nonlinear transformations project better solution guesses interior polytope 
simplex method approaches optimal solution step step searching exponential worst case complexity karmarkar algorithm proven polynomial time algorithm 
apply karmarkar algorithm integer programming integer program transformed sigma integer program 
potential function obviously optimal integer solution original ip problem algorithms satisfiability sat problem survey projection polytope optimal solution objective function simplex iterations 
basic ideas simplex method karmarkar method 
point potential function achieves maximum 
karmarkar algorithm integer programming may get stuck local minimum guarantee find optimal solution projection 
incomplete algorithm 

improved interior point method 
expected sequence interior points ff generated potential function karmarkar algorithm minimized 
crucial determine descent direction potential function step size ff 
original karmarkar algorithm step size ff assumed 
ff experiments solve sat inputs 
potential function represented quadratic approximation point move newton direction appropriate values certain parameters reach minimum recall step size chosen reaches minimum objective function line descent direction 
reason restrict ff 
suggests necessity line search choose optimal step size 
idea shi improved interior point algorithm 
algorithm step size ff determined search 
experiments show significant improvements karmarkar algorithm 

special subclasses sat certain subclasses sat known solved polynomial time identified explored 
reasons discussing subclasses section 
formula preprocessed examined determine member polynomial time solvable subclass sat 
jun gu paul purdom john franco benjamin wah special fast algorithm brought bear formula 
second portion formula may member subclass solution may solving formula easier 
third study subclasses reveals part nature easy sat formulas 
hand reported section studies random formulas indicate known classes contain small fraction formulas solved rapidly 
consider notable polynomial time subclasses 
say apply unit resolution mean apply unit clause rule exhaustion 

sat 
cnf formula containing clauses literals solved linear time applying unit resolution 

horn extended horn formulas 
cnf formula horn clause positive literal 
class widely studied part close association logic programming 
horn formulas solved linear time unit resolution 
class extended horn formulas introduced hooker looking conditions linear programming relaxation find solutions propositional formulas 
theorem chandrasekaran characterizes sets linear inequalities solutions exists rounding real solution obtained lp relaxation 
extended horn formulas expressed linear inequalities belong family problems 
graph theoretic characterization taken simpler lp characterization 
clause constructed variable set rooted directed tree root directed tree edges directed away edges uniquely labeled variables extended horn positive literals label possibly empty dipath set negative literals label edge disjoint union dipaths exactly conditions satisfied 
start root 
gamma say start root start vertex empty start vertex 
clause simple extended horn extended horn condition satisfied 
cnf formula simple extended horn clauses simple extended horn formula simple extended horn simple extended horn rooted directed tree tree horn formula star root leaves edge variable formula 
class extended horn formulas generalization class horn formulas 
hooker showed unit resolution determine extended horn formula satisfiable 
satisfying truth assignment satisfiable formula may applying unit resolution setting values unassigned variables unit clauses remain rounding result matrix multiplication 
algorithm reliably applied known formula extended horn 
unfortunately problem recognizing extended horn formulas known solved polynomial time 
algorithms satisfiability sat problem survey 
formulas balanced sigma matrices 
class formulas balanced sigma matrices call balanced formulas studied researchers see detailed account balanced matrices description balanced formulas 
motivation class question sat linear programming relaxations integer solutions 
express cnf formula clauses variables theta sigma matrix rows indexed clauses columns indexed variables cell value clause variable unnegated literal value gamma clause variable negated literal value clause variable negated unnegated literal 
cnf formula balanced formula submatrix exactly nonzero entries row column sum entries multiple 
cnf formula cast standard fashion linear programming problem form fx mx gamma column vector components number negated literals clauses rows corresponding components 
balanced submatrix solution fx ax gamma integral 
follows balanced formulas may solved polynomial time linear programming 
balanced formulas property clause contains literal variable satisfying truth assignments set true set false 
simple lineartime algorithm finding solutions known balanced formulas 
apply unit resolution formula 
clause falsified formula unsatisfiable 
repeat long possible choose variable set value true apply unit resolution 
clause falsified formula unsatisfiable clauses satisfied assignment resulting variable choices unit resolution 
extended horn formulas balanced formulas known recognized polynomial time 

single lookahead unit resolution 
class developed generalization classes including horn extended horn simple extended horn balanced formulas 
peculiar defined algorithm properties formulas 
algorithm called slur selects variables sequentially arbitrarily considers possible values selected variable 
value assigned variable unit resolution result clause falsified assignment permanent variable selection continues 
clauses satisfied value assigned variable unit resolution applied algorithm returns satisfying assignment 
unit resolution applied formula sub formulas created assigning values selected variable iteration results clause falsified algorithm reports formula unsatisfiable 
unit resolution results falsified clauses consequence assignments values selected variable iteration algorithm reports 
jun gu paul purdom john franco benjamin wah formula class slur possible sequences selected variables slur give formula 
slur takes linear time modification due unit resolution applied simultaneously branches selected variable abandoning branch finishes falsifying clause 
note due definition class question class recognition avoided 
horn extended horn balanced formulas class slur 
important outcome results slur observation special preprocessing testing needed variety special subclasses sat reasonable variant dpl algorithm 
limitation classes represent interesting unsatisfiable formulas 
possible extensions slur improve situation 
add sat solver unit resolution step 
extension able handle sat formulas slur 
extension elegantly incorporated slur due observation slur completes sequence unit resolutions time remaining clauses subset original clauses clauses literals effectively slur algorithm start 
fixing variable values leads empty clause formula proved unsatisfiable 
need augment slur sat algorithm sat algorithm version exactly modified slur 
extension slur allow polynomial number backtracks giving branch dpl tree terminate leaf clause falsified 
unsatisfiable formulas short dpl trees solved 
formulas uncommon 

horn formulas 
class propositional formulas developed hammer saks sun 
choose characterize class horn formulas special case monotone decomposition matrices 
case balanced sigma matrices express cnf formula clauses variables theta sigma matrix rows indexed clauses columns indexed variables cell value clause variable unnegated literal value gamma clause variable negated literal value clause variable negated unnegated literal 
monotone decomposition columns scaled gamma rows columns partitioned submatrices follows gamma delta submatrix entry row submatrix contains gamma entries submatrix restrictions values gamma entry submatrix entries 
monotone decomposition nonzero entries row formula represented horn 
result find monotone decomposition matrix associated horn formula linear time 
horn formula decomposed form solved linear time follows 
treat algorithms satisfiability sat problem survey submatrix horn formula solve linear time method returns minimum unique truth assignment formula respect true 
horn formula unsatisfiable horn formula unsatisfiable 
returned assignment satisfies rows set true variables truth assignment satisfying contains set variables true returned minimum unique truth assignment 
elements gamma truth assignment satisfying satisfy rows satisfied minimum unique truth assignment 
way satisfied minus rows collinear satisfied minimum unique truth assignment satisfied 
represents sat formula subset sat solved linear time 
answer unsatisfiable horn formula unsatisfiable answer satisfiable satisfying assignment plus minimum unique truth assignment returned earlier solution horn formula 
developers class horn offer linear time solution formulas class 
main result horn formula recognized linear time 
see linear time algorithm solving horn formulas 
formulas class horn thought close regarded largest easily definable class polynomially solvable propositional formulas result due hammer saks 
fv vng set boolean variables subsets ng kth clause cnf formula pk nk construct system inequalities pk ff nk gamma ff ff constraints satisfied formula horn 
hand class formulas minimum required satisfy constraints ffl fixed ffl np complete 
information subject horn formulas appear 

renamable formulas 
suppose clauses cnf formula constructed set variables ae define switch formula obtained follows reverse unnegated occurrences negated occurrences negated occurrences unnegated occurrences 
formula exists ae switch horn extended horn formula said renamable horn extended horn respectively 
algorithms formula renamable formula class apply 
additional classic horn 
interesting note exist formulas class slur formulas members renamable extended horn formulas balanced formulas 
jun gu paul purdom john franco benjamin wah 
formula hierarchies 
sets clauses falling polynomially solvable classes defined may reduced equivalent formulas members classes 
reductions efficient sets solved polynomial time 
reductions take place stages stage represents class polynomially solved formulas lower stages represent classes lower time complexity classes represented higher stages 
lowest stage polynomially solved base class classes 
example hierarchy 
base class stage horn 
consider stage formula horn 
definition hierarchy variable set true leaves set non satisfied clauses non falsified literals horn 
horn formula satisfiable conclude original formula setting false leaves set clauses stage formula empty formulas considered belong stage 
process repeated stage formulas exhaustion 
takes linear time solve horn formulas worst case linear number horn systems considered process solving formulas stage quadratic complexity 
concept expanded higher stages form hierarchy stage setting true sub formula stage gamma setting false sub formula stage solutions stage formulas carried recursively leading time complexity bounded alternative way solve formulas stage hierarchy resolution resolution applied clause literals 
remaining question determine formula stage formula 
done bottom approach described 
information hierarchies see example 

pure implication formulas 
pure implication formulas defined recursively follows 
variable pure implication formula 

pure implication formulas pure implication formula 
eliminating parentheses right left associativity pure implication formula written variable 
call variable formula right variable 
satisfiability problem trivial pure implication formula problem np complete variables right variable occur twice formula 
furthermore complexity determining increase exponentially number occurrences right variable yields hierarchy classes starting lineartime solvability going np completeness 
possibly due fact expressive power pure implication formulas lower levels hierarchy extremely limited 
despite lack expressibility lower levels hierarchy incomparable special polynomialtime solvable classes sat slur 
concrete define class cnf formulas related pure implication formulas call 
algorithms satisfiability sat problem survey formula class consists kinds clause groups number type groups fixed variable occurs twice formula 
question pure implication formula right variable occurring times identical satisfiability question formula class 
totally negated clauses removed formula complete set partial truth assignments extended satisfying truth assignments constructed linear time 
doing totally negated clause results sets partial truth assignments 
multiplying sets find consistent assignments spanning sets determine formula satisfiable 
accomplished time matching complexity pure implication formulas 
result shows reduced time 
problem determining satisfiability formulas union classes np complete 
class fixed incomparable polynomially solved classes discussed 
example slur cnf formulas represented formulas vice versa particularly unsatisfiable formulas slur cnf formulas 
easy construct formula renamable horn horn set horn 
interesting fixed contains formulas polynomial time solvable classes severe lack expressibility formulas may exploited assist complexity investigations class hierarchies 
particular hierarchies discussed jf complexity complexity jf say inconsistent developed theory 
may useful answering question 

non linear formulations 
optimization problem variables reduced constrained nonlinear program 
programs expressed follows max subject ik ik nk ng jun gu paul purdom john franco benjamin wah ik nik ik problems propositional logic originating example graph theory expressed way associating false true gamma delta methods solving formulation proposed 
restricted cases methods polynomial time complexity 
rich literature subject carried domain propositional satisfiability provide low complexity algorithms sat corresponding conditions 
notable example involves functions occurrence graph partial tree 
dnf formulation expressed equations form equations 
dnf function 
occurrence graph vertex set corresponding variables fx xng edge variables occur simultaneously product term 
simple undirected graph tree ordering fx vertices gamma subgraph induced vertices fx vertex degree neighbors induce complete subgraph partial tree graph obtained deleting edges tree 
cooccurrence graph partial tree solved linear time 
maximization problem dnf formulas minimization problem cnf formulas gamma literal literal cnf formulas solved linear time corresponding occurrence graph partial tree 
example linear time algorithm determining sat formula exactly solution uniquely solvable 
question determining unique solvability tough general hard determine linear time algorithms exist special subclasses sat sat framework pseudo boolean functions form 
mention result polynomial time algorithm producing parametric representation solutions sat formula 

nested extended nested satisfiability 
complexity nested satisfiability studied 
study inspired lichtenstein theorem planar satisfiability 
index variables cnf formula 
clause straddles clause index literal strictly indices literals clauses overlap straddle 
formula nested clauses overlap 
problem determining satisfiability nested formulas clauses ordered clause straddle clause solved linear time 
extension nested satisfiability proposed 
prefer skip details just mention extension recognized solved linear time 
details reader referred 
linear algorithm unique horn sat obtained berman improved linear time algorithm slight modification due minoux developed quadratic time algorithm algorithms satisfiability sat problem survey 
advanced techniques section describe number advanced optimization techniques satisfiability testing 
practical engineering applications proven effective certain classes sat 

general boolean representations 
practice problems integrated circuit design logic verification test pattern generation asynchronous circuit design logic optimization sequential machine reduction symbolic simulation expressed boolean satisfiability problems arbitrary boolean functions 
representation corresponding algorithms satisfiability testing 
boolean representation affects performance boolean manipulation methods accordingly 
efficient representation manipulation boolean functions crucial practical applications 
different representations proposed manipulating boolean functions 
boolean functions derived practical circuit design problems suffer exponential size representations making satisfiability testing infeasible 
sat algorithms conjunctive normal form cnf formulas input formulas expressed product sums literals 
cnf formula canonical formula analytical studies efficient representation practical application problems 
real engineering design problems non clausal representations cnf formula 
algorithms category may regarded non clausal inference algorithms satisfiability testing 
compared cnf formulas non clausal general boolean representation compact efficient transformation arbitrary non clausal expression cnf done polynomial time introducing new variables 
result clause form representation substantially larger sizes 
critical complexity theory serious impact solving practical application problems 
practice sat algorithm efficient works directly problems represented compact number general boolean formulas large collection cnf clauses 
non clausal sat algorithm evaluation arbitrarily large complex boolean functions key efficiency 
subsections describe sequential parallel boolean representation manipulation methods 

binary decision diagram bdd 
ordered binary decision diagrams obdds efficient representation manipulation method arbitrary boolean functions 
representation defined imposing restrictions binary decision diagram bdd representation introduced lee akers resulting form canonical 
obdd representation manipulation method extremely powerful technique various practical applications 
particularly useful formulas needs consider solution cases search optimal solutions 
obdd representation function may size exponential number variables useful functions compact representations practice 
bdd gives graphical representation boolean functions 
directed acyclic graph types leaf nodes 
non leaf node labeled boolean variable going edges labeled left edge jun gu paul purdom john franco benjamin wah 
simple bdd example delta 
right edge 
bdd utilized determine output value function examining input values 
path bdd unique path contains nodes variables 
means arbitrarily trace path function node leaf node automatically value assignment function variables function regardless values variables 
simple example boolean function delta bdd function constructed determine binary value binary values variables root node bdd value variable finished 
look finished 
look value value complete bdd function shown paths root function node leaf node highlighted 
highlighted path yields satisfiable assignment 
satisfiable assignments gamma gamma gamma denotes don care assignment 
known bdd size function depends variable order chosen function fa cg 
early bdds extensions proposed reduce bdd sizes practical applications 
ordered bdd input variables ordered path root node leaf node visits input variables ascending order 
practice simple topological ordering heuristic yields small size bdds practical boolean instances 
reduced ordered bdd ordered bdd node represents unique logic function 
bryant showed reduced ordered bdd boolean function defined canonical representation function functions equivalent reduced ordered bdds isomorphic 
efficient search optimal solutions arbitrarily complicated boolean expressions 
vlsi circuit design practical problems require enumeration possible assignments boolean formula 
best assignment yields minimum cost minimal circuit structure minimum chip area maximum circuit speed selected possible assignments 
algorithms satisfiability testing designed finding algorithms satisfiability sat problem survey truth assignment impractical selecting optimal assignment 
bdds useful situations simple incremental enumeration possible paths root node leaf node yields truth assignments 
bdd boolean function constructed straightforward enumerate assignments find optimal solution 
bdd method effectively handle small medium size formulas 
larger size formulas partitioning set smaller sub formulas applying bdd algorithms suggested 
approach works asynchronous computer circuit design problems 

unison algorithms 
total differential boolean function unison algorithm capable evaluating arbitrarily large complex boolean functions 
unison algorithm built network multiple universal boolean elements 
topology unison network specifies structure boolean functions 
dynamically reconfiguring functionality unison adaptable evaluate general boolean functions representing sat csp problems 
total differential df boolean function represents difference function value due difference input values 
boolean function variables total differential calculated differences input dx dy df dx phi dy phi xy dx dy phi exclusive operation 
boolean function dependent variables 
total differential df df dg phi dh phi xy dg dh observed value df depends total differentials dg dh function values 
recursively applying dg dh dependent variables total differential df evaluated total differentials independent variables see 
unison algorithm works phases initialization evaluation 
initialization phase computes partial derivatives determine function evaluated evaluation phase 
partial derivatives constant evaluation phase 
evaluation phase reads input values computes final results 
calculation performed bottom fashion starting independent variables 
computer word evaluate boolean operation code calculate df produce result 
computer word computer able perform bitwise bitwise exclusive operations instruction 
unison algorithm implementation take advantage machine feature increase execution speed reduce memory space 
implementations sun workstations unison algorithm uses bits computer word pack boolean operations 
ith bit operand initialized represent ith boolean operation ith bit df result ith boolean operation 
bitwise operations independent 
unison algorithm jun gu paul purdom john franco benjamin wah dg dh df dx dy dx dy 
relation total differentials 
simultaneously evaluates boolean operations machine instruction 
parallel implementation unison algorithm straightforward implemented programming language supports bitwise boolean operations 
data structures implementation details unison algorithm discussed 
unison architecture built network multiple universal boolean elements 
connection topology unison network specifies structure boolean function evaluated unison 
structure boolean functions specifies connectivity boolean expressions variables 
accomplishes variable simple boolean function unison 
outputs inputs 
enables construction network capable evaluating arbitrarily large complex boolean functions 
dynamically reconfiguring functionality unison adaptable evaluation different boolean functions representing sat csp problems 
unison architectures essentially limit number bits implement 
put chip possible long hardware resource permits 
detailed implementations unison architecture network structure structures cmos hardware implementations described detail 
combined parallel evaluation partial evaluation incremental evaluation techniques unison incorporated variety search optimization algorithms satisfiability testing 
especially important real time applications hardware processing different boolean functions required 
provides efficient approach fast non clausal processing sat inputs 

multispace search 
search optimization methods developed combinatorial optimization operations research artificial intelligence neural networks genetic algorithms evolution programming 
optimization algorithm seeks value assignment variables constraints satisfied performance objective optimized 
algorithm operates changing values variables value space 
value changing algorithms satisfiability sat problem survey value space variable space objective space space parameter space constraint space 
value space traditional search process dashed line pass wall high cost search states hatched region 
fails reach final solution state multispace search process solid lines different search spaces 
bypass wall search spaces 
affect formula structure search space difficult value search algorithm handle pathological behavior local minima 
multispace search new optimization approach developed years 
idea multispace search derived principles non equilibrium thermodynamic evolution structural changes fundamental quantitative changes evolution depends growth new structure biological system just information transmission 
search process resembles evolution process structural operations important improve performance traditional value search methods 
multispace search active component related input structure manipulated formulated independent search space 
optimization problem variables values constraints objective functions key parameters affect input structure define variable space value space traditional search space constraint space objective function space parameter space search spaces respectively 
totality search spaces constitutes multispace 
basic idea multispace search simple 
restricted value space multispace taken search space 
multispace components value manipulated optimized 
search multispace search algorithm alters values value space shown walks variable space active spaces changes dynamically input structure terms variables parameters jun gu paul purdom john franco benjamin wah components constructs systematically sequence structured intermediate instances 
intermediate instance solved optimization algorithm solution initial solution intermediate instance 
value optimization structured operations multispace search incrementally constructs final solution search instance sequence structured intermediate instances 
moment search reconstructed instance structure approaches original instance structure final value assignment represents solution search input 
multispace search algorithm combines traditional optimization algorithms structural multispace operations 
search step multispace search performs fundamental operations traditional value search structural reconfiguration intermediate instance individual search phase 
active event scrambling schedule search process enters specified search space performs structural operations intermediate instance structures followed traditional value search optimizes constructed intermediate instance 
resulting intermediate solution initial instance phase multispace search 
major structural operations multispace search include multispace scrambling transition air bridge real dimension extra dimension search space smoothing multiphase search local global passage tabu search perturbations jumping tunneling climbing annealing 
subsections describe preprocessing methods satisfiability testing multispace search partitioning input size partitioning variable domain 

partitioning reduce input size 
due excessive computing time large size np hard problem difficult solve 
partitioning large input set smaller sub instances may permit efficient solution input 
partitioning methods consisting partitioning conquer integration procedure 
constructive partitioning divide conquer partitioning conquer integration procedures defined easy implement 
destructive partitioning difficult design partitioning integration procedures 
give industrial case study requires sat solver 
sat solver uses efficient input size partitioning preprocessing step 
problem arises asynchronous circuit design 
asynchronous circuits indispensable low power high performance digital computer systems 
due important applications mobile portable military communication systems great interest automated design synthesis asynchronous circuits 
design asynchronous control interface circuits proven extremely complex error prone task 
core problem asynchronous circuit synthesis formulated instance sat satisfy complete state coding csc constraints sat circuit problem 
practical application problem optimal solution minimal circuit layout area sought 
incomplete sat solver local search unfortunately algorithms satisfiability sat problem survey guarantee optimal solution applicable 
previous researchers efficient resolution branch bound procedures handle sat circuit problem 
asynchronous circuit design problems unfortunately able find optimal solution difficult asynchronous circuit design problems locate solution 
gu puri developed partitioning technique satisfiability testing applied asynchronous circuit design 
partitioning preprocessor decomposes large size sat formula represent asynchronous circuit design number smaller disjoint sat formulas 
small size sat formula solved efficiently 
eventually results sub formulas integrated contribute solution original formula 
preprocessor avoids problem solving large sat formulas guarantees finding best solution practice 
partitioning preprocessing destructive search extra variables introduced resolve critical csc constraints 
furthermore built complete incremental sat solver binary decision diagrams bdd 
system able find optimal solution asynchronous circuit design problem efficiently 

partitioning variable domains 
variable domain contains values assigned variables 
size variable domain number variables determine computational complexity optimization algorithm 
theoretical point view small reduction variable domain result significant improvements computing efficiency 
difficult variable domain reduction techniques solving optimization problems 
wang studied mobile cellular network structures developed novel variable domain reduction technique channel assignment networks 
rapid growth mobile cellular communication services created direct conflict limited frequency spectrum 
channel assignment important technique efficient utilization frequency resource mobile cellular communications 
channel assignment problems fixed channel assignment fca essential design operation cellular radio networks 
fca algorithm assigns frequency channels calls frequency separation constraints satisfied total bandwidth required system minimized 
encoding constraints clauses problem instance sat 
cellular communication system numerous ways assign channel call request 
optimal channel assignment decision significantly improve cellular system capacity requiring extra cost 
fixed mobile cellular system capacity cellular system mainly determined performance channel assignment algorithms 
wang channel assignment algorithm developed structure cellular frequency reuse patterns 
variable domain partitioning technique partition mobile cellular network larger variable domain networks minimum network fixed small variable domain due known frequency reuse patterns difference network smaller variable domain 
channels assigned separately minimum network difference network superposition assignments constitutes assignment original network 
jun gu paul purdom john franco benjamin wah variable domain partitioning approach decomposes instance channel assignment problem large number assignments separate channel assignment sub instances considerably smaller numbers assignments dramatically reduces computational complexity computing efficiency solving inputs addition significantly improved solution results 
novel partitioning technique applied solve channel assignment problem existing channel assignment algorithms 
numerous channel assignment experiments algorithm outperformed available algorithms solving practical channel assignment problem benchmarks 
experimental evidence suggests partitioning approach efficient effective 

parallel sat algorithms architectures 
parallel sat csp algorithms developed 
survey parallel algorithms solving sat discussed 
parallel dp algorithms 
parallel discrete relaxation chips 
parallel backtracking architecture 
parallel local search algorithm 
parallel interior point method 
parallel differential non clausal inference 
parallel fffi relaxation 
parallel global optimization 
neural network approach 
multiprocessor local search ideas techniques described 
reasons algorithms running loosely coupled multiprocessor parallel computers offer limited performance improvements solving sat 
worst case sat algorithm may suffer exponential growth computing time 
order solve sat formulas effectively need computer larger speedup available today 
computer require integration processors tightly coupled manner 
infeasible current computer system integration technology 
second processor gets faster communication overhead processors parallel machine bottleneck may take total computing time 
ideally expect speedup parallel computer increase linearly increasing number processors 
due serious processor communication delays certain saturation point adding processors increase speedup loosely coupled parallel machine 
processor communication delay process creation process synchronization remote memory access expensive loosely coupled multiprocessor system 
reason speedup multiprocessor normally number processors 
simple sat algorithms speedup greater number processors 
variable settings similar known lead solution lead solution 
obvious methods parallelizing simple sat algorithms break tendency search similar settings time 
experience tightly coupled parallel computing effectively reduces processor communication delays key parallel processing algorithms satisfiability sat problem survey sat formulas 
order tightly coupled parallel architecture sat computation map computing structure input structure reduce total number sequential computing steps large number symmetrical interactions simple processors 
different approaches special purpose parallel vlsi architectures bit parallel programming sequential machines tight programming parallel computer systems promising alternatives direction 
approaches capable providing tight mapping formula structure computing structure resulting faster computation 
computational power approaches orders magnitude greater standard sequential algorithms running uniprocessor machines parallel algorithms running loosely coupled multiprocessors 
parallel processing change worst case complexity sat algorithm exponential number processors 
parallel processing delay effect exponential growth computing time allowing solve larger size instance sat 

multi sat algorithm 
problem structures real world practical applications vary significantly making difficult develop efficient sat algorithm solve wider range practical application problems 
efficient algorithms developed sat problem 
solve class problem instances efficiently 
backtracking algorithms handle small size hard problem instances providing complete solutions 
local search handle fairly large size satisfiable problem instances quickly 
bdd sat solver able solve practical problem instances performance criteria 
global search method provide solutions wide range sat problem instances 
problem size domain partitioning techniques enhance existing sat algorithms solve larger size practical problem instances 
combine niches efficient algorithms may handle wider range sat problem instances efficiently 
school concern multi sat algorithm comes existing challenge sat algorithm design testing 
local search algorithm consists basic components 
components sensitive algorithm parameter setting algorithm running environment input size problem structure initial starting points 
select various min conflicts heuristics random value assignment heuristics random variable selection heuristics partial random variable selection heuristics multiphase search heuristics multispace search heuristics 
combined hundreds problem instances initial starting points process design implementation experimentation algorithm time consuming 
multi sat algorithm relieve load task facilitating quick design testing algorithm 
algorithm integration approaches hybrid algorithm algorithm clustering proposed algorithm integration 
hybrid algorithm approach algorithms different classes integrated single algorithm 
algorithm different algorithmic niches decision procedures 
early examples approach include combining local search backtracking combining global optimization backtracking 
effectiveness hybrid algorithm may limited due overheads decision making algorithmic context switching 
jun gu paul purdom john franco benjamin wah algorithm kit dpl dlm csat sat sat bdd problem instances random models benchmarks variables clauses literals ii job running job running job running job running job running job running bf ssa result job dispatch bdd dpl dlm sat sat csat 
software system multi sat algorithm 
algorithm clustering approach algorithms different classes optimized individually achieve best performance 
algorithm executed computer 
cluster computers execute algorithms selected different classes 
individual results algorithms executions integrated producing final result 
algorithm clustering approach suffer performance degradation due direct algorithm integration 
computer hardware prices continue decrease cluster computers built cost effective way pc purchased 
requirement clustering computation multi tasking integration software 
implementation multi sat algorithm select efficient sat algorithms 
include examples dpl csat backtracking algorithm sat gsat sat local search algorithm bdd sat solver binary decision diagram algorithm dlm global search method 
combining problem size domain partitioning techniques support effective satisfiability testing problem instances uncertain structures stones shoot bird 
changing parameters initial starting points multi sat track algorithm structure allow detailed study entire problem spectrum provide cost effective tool kit practical satisfiability testing 
basic software system multi sat shown 
algorithm tool kit collecting candidate algorithms different algorithm classes problem instance database user select problem instances distributed system software job dispatcher remote job execution control execution result collection network computers executing selected algorithms 
software system run pc platform unix platform interactive graphical interface 
algorithms satisfiability sat problem survey 
probabilistic average case analysis probabilistic average case analysis give useful insight question sat algorithms effective certain circumstances 
structural properties shared collection formulas may exploited solve formulas efficiently structural properties force class algorithms require super polynomial time 
properties may identified probabilistic analysis may hope argue properties common particular class formulas performance algorithm class algorithms predicted formulas class 
main drawbacks approach distribution input formulas assumed chosen distributions may represent reality results usually sensitive choice distribution results obtained randomized algorithms state analytical tools distributions yielding analysis typically symmetric independent components algorithms yielded analysis 
despite drawbacks probabilistic results useful supplement worst case results overly pessimistic especially np complete problems understanding algorithmic behavior 
section reviews notable probabilistic average case results certain sat algorithms 
results mainly distributions sat distribution average sat distribution see section partly widely 
distributions cnf formulas 
character results different distributions devote subsection 

average sat model 
parameters distribution number clauses number variables clauses constructed probability unnegated variable negated variable appears clause see section details 
variables placed clauses independently possible null clauses clauses complementary literals tautological clauses unit clauses exist random formula 
reality 
mathematics associated analyses average sat models usually tractable 
straightforward tedious modify average sat calculations account clauses length results unknown 
addition tautological clauses exist high probability part parameter space 
results asymptotic apply 
satisfiable unsatisfiable formulas 
results highlight regions parameter space random formulas unsatisfiable satisfiable high probability 
easy see average number literals clause pn average number times variable appears random formula pm 
pn ln random truth assignment satisfies random formula probability pn ln lim gammac gammaffl ffl random formula satisfiable probability 
pn ln random formula contains empty clause unsatisfiable probability 
region parameter jun gu paul purdom john franco benjamin wah space random formulas may difficult probabilistic sense defined pn ln lim gammac gammaffl ffl 
polynomial time solvable classes 
special polynomial time solvable classes discussed section identified regions parameter space 
give examples taken mainly 
pn ffl ffl random formula horn formula probability 
non empty clauses horn clauses 
pn gammaffl ffl lim random formula extended horn probability 
pn ffl ffl random formula extended horn probability 
implies pn empty clauses probability parameter subspace random formulas usually extended horn sharply defined 
surprisingly simple extended horn formulas abundant relatively small subspace parameter space 
pn ffl ffl random formula simple extended horn formula probability pn gammaffl ffl random formula simple extended horn probability 
random formulas balanced probability pn gammaffl ffl 
lim balanced formulas generated abundance region parameter space larger subspace random formulas extended horn probability 
statement believed hold lim 
weakening slur chooses expand true path selected variable possible parameter subspace random formulas solved slur probability large regions pn ln lim lim pn ln 
clauses containing negated pure negative clause unnegated variables pure positive clause random formula probability region see exploitable properties random formulas extended horn pure positive negative clauses probability region random formulas contain empty clauses probability region 
summary slur class modified dominates nearly entire parameter space balanced extended horn formulas frequently generated average number occurrences variable formula tends random formulas tend large number empty clauses horn formulas simple extended horn formulas commonly generated small portion parameter space 
exploitable properties 
random formula special poly nomial time solvable subclasses sat discussed earlier dealt efficiently 
true random formula certain exploitable properties 
described taken 
clause pure contains negated variables unnegated variables 
call formula pure clauses non formula 
satisfying truth assignment non formula obtained linear time 
pn 
ffl ln ffl random formula non formula probability 
clause tautology variable clause 
clauses may removed formula affecting boolean function expresses 
tautological clauses exist formula relatively easy algorithms satisfiability sat problem survey solve 

ffl ln ffl clauses random formula tautological probability 
clauses formula contain log literals formula satisfiable 
random formula property probability pn log 
average case results 
results show random formulas efficiently solved probability nearly parameter space average sat model imply polynomial average time algorithms exist significant portion parameter space 
example set formulas gamma formulas solved algorithm time formula requires time set solved polynomial time probability average complexity set exponential assuming formulas equally 
get stuck set formulas finds solution random formula linear time 
consideration motivated average case analysis algorithms average sat model 
results say exploiting properties individually insure polynomial time average complexity exploiting certain properties collectively nearly entire parameter space covered collection algorithms polynomial average time complexity 
give examples 
determining unsatisfiability existence empty clause formula strong give polynomial average time pn ln probability empty clause exists random formula tend fast 
empty clause check combined methods achieve polynomial average time complexity 
example preprocess formula making unit resolutions resolutions involving variables occur formula exactly twice backtracking empty clause check find solutions processed formula 
polynomial average time achieved 
pn 
ffl gamma gamma ffi ln ffl ffl ffl ffi ffl gamma gamma ffi 
gamma gamma fie gamma pn fin fi constant 
pn 
gammaffl gammaffi ln ffl ffl ffl ffi gammaffl gammaffi 
pn ln gammaffl ffl ffl 
subspace includes nearly half plane pn ln region empty clauses exist probability 
algorithm finds solutions formula 
variant dpl algorithm called probe order backtracking works half plane pn ln exploits preponderance non formulas results generating formulas region 
formula empty clause exists output unsatisfiable 
clause containing unnegated variables output satisfiable 
select clause containing unnegated variables fv set jun gu paul purdom john franco benjamin wah true set gamma false recursively apply probe order backtracking 
output satisfiable invocations output satisfiable 
probe order backtracking runs polynomial average time pn ln 
interesting results 
average number solutions 
average sat model average number solutions formula approximately exp ln ln gamma pn exponent negative formulas solutions exponent positive formulas solutions average 
ln average number sub formulas generated simple backtracking average number solutions 
ln small values pn lead sub formulas large values lead huge number sub formulas intermediate range values average number solutions near zero average number nodes exponential function 
average time analysis backtracking done version algorithm finds solutions 
wants just solution need algorithm solve second sub formula cases sub formula solution 
far analysis shown just time saved stopping early 
stopping early effect formulas solutions analysis shows considerable range pn values simple backtracking takes exponential average time algorithm stops solution 
additional commentary 
average sat analysis unit clause backtracking shows conditions fast slow similar conditions simple backtracking fast slow 
analyzed version algorithm finds solutions 
moderate values range pn values simple backtracking takes exponential time unit clause backtracking takes polynomial time 
small values unit clause backtracking significant advantage number solutions controls running time large values little advantage interesting formulas occur large pn values unit clauses rare 
average sat analysis probe order backtracking shows addition fast conditions simple backtracking fast fast various conditions 
fast pn 
small typical sat formula variables 
formulas solution exponential number solutions setting unused variables 
simple backtracking takes advantage variables appear formula clause order backtracking 
clause order backtracking fast pn large compared ln ln large setting just variables random setting tends satisfy clauses 
clause order backtracking notices simple backtracking 
algorithms satisfiability sat problem survey average sat analysis done shortest clause backtracking 
see partial analysis sat case 
clearly advantages unit clause backtracking faster pn large hard know just faster 
prize winning entries sat competition shortest clause backtracking refinements decide various variables shortest clause select 
fifth prize winning entry form hypergraph searching 
pure literal rule algorithm average time computed 
essence pure literal rule dp procedure removing features analyzable algorithm obtained 
algorithm practice simple algorithms better rapidly solves wide class formulas polynomial average time find solutions 
played important role early history average time analysis sat algorithms analysis simple cases fast different simple backtracking simple analyze sat algorithm 
pure literal algorithm extends idea noting occurrences literal assigning value literal false leads sub formula subset sub formula obtained setting literal true 
formula contains clause occurrence literal solutions false sub formula solutions true sub formula false values remaining literals special clause 
case resolution increase input size variable positive negative occurrence 
franco idea plus pure literal rule develop algorithm fast small long large 
algorithm small probe order backtracking large leads algorithm fast times logarithm factors 
clever algorithms ideas combined better analyses probably lead algorithm fast smaller constant times 
sat model 
parameters distribution number clauses number variables clauses constructed number variables clause 
clauses constructed independently 
clause uniformly set distinct variables negated independently probability 
possible null clauses clauses complementary literals exist random formula 
probabilistic analysis sat algorithms sat model difficult average sat model 
difference associated structure sub formulas generated result assigning value variable iteration particular algorithm 
sub formulas distributed model original formula analysis proceed easily 
case sat model statistical dependence clauses iteration prevents 
notable exception analysis variants unit clause rule 
reason relative success analysis average sat model algorithms unworkable sat model effective average sat model 
notable example probe order backtracking jun gu paul purdom john franco benjamin wah algorithm previous section 
average sat model pn ln purely negative positive clauses rare probe order backtracking works 
case sat model negative clauses positive clauses fixed percentage input clauses probe order backtracking ineffective case 
follows refer sat assume specifically stated example sat 
satisfiable unsatisfiable formulas 
easy show random sat formulas unsatisfiable probability gamma log gamma gammal 
shown random sat formula satisfiable probability 
implies random sat formulas satisfiable probability 
gap gamma log gamma gammal intrigued number researchers 
question function large random sat formulas satisfiable probability random sat formulas unsatisfiable probability 
results gap question open 
sat case 
sat case known random sat formulas unsatisfiable probability 
improved 
known random sat formulas satisfiable probability maxf 
result comes algorithm sat explained algorithms finds solution polynomial time 
sat improved algorithm explained algorithms 
polynomial time solvable classes 
sat formulas members certain polynomial time solvable classes generated frequently interesting ratios assist determining satisfiability 
situation average sat model 
illustrate examples 
probability clause horn probability random sat formula horn tends fixed formula hidden horn set variables switch set literals reversed yield horn formula 
regardless switch set ways negation patterns random clause horn 
expected number successful switch sets tends gamma log 
random sat formulas hidden horn probability gamma log 
associated horn formula see section partition clauses partition variables clause variable clause variables taken probability particular pairwise partition property computed 
multiplying number pairwise partitions gives expected number partitions upper bound probability exists 
find partitions exist jv 
jv jv probability log gamma gamma log gamma 
coupled hidden horn result sat formulas remarkable result random sat formulas horn probability gamma log algorithms satisfiability sat problem survey 
bound reduced considerably point large simple algorithm effective probabilistic sense random sat formulas looking horn formulas randomly remove literals clause solve resulting sat formula satisfiable return satisfying truth assignment give 
algorithms 
mention best positive results date negative result 
algorithm called sc short clause iteratively selects variable assigns value solution gives reached dead 
assignment may satisfy clauses falsify literals 
backtracking sc 
variables selected follows clause non falsified literal choose variable value satisfies clause clause non falsified literals choose variables value satisfies clause choose variable arbitrarily 
algorithm restricted version generalized unit clause chooses variable value satisfies clause fewest number non falsified literals 
analysis sc 
result sc give probability 
adding limited amount backtracking frieze suen get algorithm sat called finds satisfying assignment probability 
backtracking managed follows 
consider sequence variable selections assignment iteration execution 
sequence represented list pairs suppose false true clauses contain non falsified literal truth assignment satisfy 
set false update clauses accordingly satisfied clauses falsified literals continue iteratively selecting variables assigning values 
mention important result resolution proofs exponentially large probability random unsatisfiable sat formulas generated fixed 
log gamma gammal fixed resolution requires exponential time probability 
course implies dpl trees exponential size log gamma gammal 
non backtracking heuristics algorithms sc mentioned repeatedly choose variable value satisfying assignment clause falsified case algorithm gives 
heuristic select variable value strongly associated algorithm succeeds 
reasonable heuristic choice maximizes number assignments satisfying formula remains selected value assigned selected variable 
alternatively selected variable value maximize expected number satisfying assignments 
expectation approximated follows 
suppose formula clauses literals distinct variables 
clauses statistically independent clauses literals equally average number satisfying assignments 
may choose variable value maximize number 
equivalently choice may maximize log number log log gamma log jun gu paul purdom john franco benjamin wah approximately 
removing unimportant leaves johnson heuristic described 
heuristic analyzed sat model experiments shown quite effective conjunction unit resolution 

performance evaluation important measure sat algorithm performance remains practical problem solving ability 
inputs requiring solution complete algorithms incomplete algorithms applicable 
inputs requiring solutions optimal solution complete algorithms 
past decades seen proliferation different algorithms solving sat resolution local search global optimization bdd sat solver multispace search 
previous experience indicates techniques complement exclude effective particular instances sat 
section summarize experimental performance typical sat algorithms random instances dimacs benchmarks structured instances practical industrial benchmarks 
fuller version sat algorithms benchmarking results appear forthcoming algorithms satisfiability sat problem benchmarking authors 

experiments random formulas 
section give experimental results sat algorithms solving random sat formulas random average sat formulas 
sat sequential cnf local search algorithm 

sat parallel cnf local search algorithm 

sat complete cnf local search algorithm 

sat sequential dnf local search algorithm 

sat parallel dnf local search algorithm 

sat complete dnf local search algorithm 

sat optimized discrete global optimization algorithm 

sat complete global optimization algorithm 

sat continuous global optimization 

sat complete continuous global optimization 

dpl davis putnam algorithm loveland form 

gsat sequential greedy local search algorithm :10.1.1.34.6853

ip parallel interior point zero integer programming algorithm 
real execution times 
table give real execution times local search global optimization algorithms solving sat instances 
results run sun sparc workstation 
number clauses number variables number literals clause columns 
symbol column stands number times algorithms hit global local minimum points 
results observe terms global convergence local convergent rate local search global optimization algorithms exhibit desirable convergent properties fast computing speed instances table 
algorithms satisfiability sat problem survey table 
real execution performance averaged runs local global optimization algorithms sun sparc workstation 
time units seconds 
symbol stands number times algorithms hit global local minimum points 
problems execution time sat sat sat sat sat sat optimization algorithms parallel cnf local search sat algorithm faster sequential local search sat algorithm 
sat algorithm comparable computing performance dnf parallel jun gu paul purdom john franco benjamin wah table 
performance comparison averaged runs dpl optimization algorithms sun sparc workstation solving sat problem instances 
time units seconds 
symbol column stands dpl success failure give answer time limit theta seconds symbol stands number times remaining sat optimization algorithms hit global local minimum points 
problems execution time dpl sat sat sat sat sat local search sat algorithm 
discrete global optimization sat algorithm slightly slower parallel local search algorithms 
complete local search sat algorithm complete global optimization sat algorithm due systematic bookkeeping slightly slower parallel local search significantly faster sequential local search algorithm 
discussed certain range hardness example computing time optimization algorithms started increase 
experimental results shown table collected early reports 
local global optimization algorithms faster previous versions 
performance comparison dp algorithm 
execution results dpl algorithm optimization algorithms solving sat instances table 
executed algorithm times report average execution times 
dpl slow large size instances set maximum execution time theta seconds time limit execution 
symbol column stands dpl success failure giving answer time limit 
dpl average execution time include maximum execution time limit executions successful average execution time taken maximum execution time limit executions failed 
symbol column stands number times remaining sat optimization algorithms hit global local minimum points 
algorithms satisfiability sat problem survey table 
performance comparison optimization algorithms running sun sparc workstation gsat algorithm running mips computer comparable computing power sat problem instances 
time units seconds 
problems execution time gsat sat sat sat sat sat numerous algorithm executions observe random sat instances listed table dpl slower rest sat optimization algorithms 
input size increases number failures increased quickly 
slightly large inputs algorithm executions failed reasonably long time limit 
due average run time complexity fairly easy instances dpl took excessive amount time find solution 
comparison local search global optimization algorithms successful executions 
able find solution instances efficiently 
table suggests dpl may suitable candidate large size random sat instances 
observation generalized application cases 
applications observed dpl performed 
performance comparison gsat table compares performance local search global optimization algorithms running sun sparc workstation gsat running mips computer comparable computing power :10.1.1.34.6853
gsat essentially version sequential local search sat algorithm solving sat instances generated input model local search global optimization algorithms performed approximately tens hundreds times faster gsat parallel dnf local search sat algorithm complete global optimization sat best 
performance comparison interior point zero integer programming algorithm 
kamath interior point zero integer programming algorithm solve sat 
implemented algorithm fortran languages ran algorithm parallel vector computer instances generated average sat input jun gu paul purdom john franco benjamin wah table 
performance comparison optimization algorithms running sun sparc workstation interior point zero integer programming algorithm running parallel vector computer solving average sat problem instances 
time units seconds 
symbol stands number times ip hits global local minimum points symbol stands number times remaining sat algorithms hit global local minimum points 
problems execution time ip sat sat sat sat sat model 
parallel computer operates scalar mode approximately mflops mflops full vector concurrent mode 
execution results columns table 
ran local search global optimization algorithms instances listed sun sparc workstation 
results table 
apparently compared interior point zero integer programming algorithm running parallel computer addition improved global convergence local search global optimization algorithms simpler achieved orders magnitude performance improvements terms computing time 

experiments hard random formulas 
compare performance local search algorithms tabu search algorithm hard random sat problem instances generated generator 
programs written table give real execution performance wsat gsat random walk sgi challenge mhz mips processor :10.1.1.21.2207
tables show experimental results wsat tabu search sat programs written linux pc 
machine compared gsat efficient cases 
addition able solve problem instances compared gsat 
testing large size example terminated entering hard region random sat instances 
algorithms satisfiability sat problem survey table 
wsat gsat random walk real execution performance hard random sat problem instances sgi challenge mhz mips processor 
time unit seconds 
problems gsat walk time flips time flips theta theta theta theta theta table 
wsat gsat random walk real execution performance hard random sat problem instances pc 
time unit seconds 
inst 
time flips solved ratio table 
real execution performance hard random sat problem instances pc 
time unit seconds 
inst 
time flips solved ratio performance sat algorithm section shown table 
hard problem instances transition region sat solve large size sat problem instances efficiently 
took wsat average seconds solve instances sgi challenge mhz mips processor 
sun sparc workstation sat algorithm able solve problem instance seconds jun gu paul purdom john franco benjamin wah table 
real execution performance sat algorithm hard random sat problem instances sun sparc workstation 
problem random instances tested 
minimum min maximum max average mean execution times recorded 
indicates number success cases finding solutions time limit limit 
time unit second 
tmin tmax limit average 
hard large size sat problem instances sat algorithm able handle problems comfortably 

experiments structured instances 
take look performance sat algorithms structured instances 
algorithms satisfiability sat problem survey table 
performance sat sun sparc workstation 
time units seconds 
problems trials execution time name global sat min mean max ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat instances generated queens problem 
assess performance local search global optimization algorithms non binary instances tested sat instances generated instances queens problem 
compares performance dp optimization algorithms 
compares performance dp sat complete continuous global optimization algorithm 
due expensive floating point computations execution time sat higher discrete local search global optimization algorithms 
dimacs instances 
sat formulas generated instances boolean inference problem performance sat parallel local search algorithm simple backtracking algorithm shown tables respectively 
algorithm may effective type input 
results suggest efficient different types algorithms handle inputs simultaneously 
table compare wsat gsat davis putnam algorithm solving circuit diagnosis benchmark problems 
average execution times average number iterations published average jun gu paul purdom john franco benjamin wah cpu time sec number clauses sat algorithm sat algorithm dp algorithm cpu time sec number clauses sat algorithm sat algorithm dp algorithm cpu time sec number clauses dp algorithm sat algorithm 
comparison dp sat sat sat sat sat solving sat instances generated csp instances algorithms satisfiability sat problem survey table 
performance simple backtracking algorithm sun sparc workstation 
time units seconds 
name sat time name sat time ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat ii sat table 
comparison execution times seconds averaged runs respect published results circuit diagnosis problems dimacs archive including best known results obtained wsat gsat algorithm 
problem wsat gsat dp id ss sgi iter 
ssa ssa ssa ssa ffl sun sparcstation mhz sgi challenge mips ffl gsat wsat dp sgi challenge mhz mips 
table 
comparison execution times seconds averaged runs published results circuit synthesis problems dimacs archive including best known results obtained gsat integer programming simulated annealing 
problem gsat integer sa id ss sgi iter 
prog 
ii ii ii ii ii ffl sun sparcstation mhz sgi challenge mips ffl gsat sa sgi challenge mhz mips ffl integer programming vax 
jun gu paul purdom john franco benjamin wah table 
comparison dlm execution times seconds averaged runs best known results obtained gsat circuit synthesis parity learning artificially generated sat instances graph coloring problems dimacs archive 
problem gsat identification ss success time success ratio ratio aim aim aim aim gsat ii ii ii ii par par gsat ffl sun sparcstation ffl gsat sgi challenge model unknown execution times wsat gsat davis putnam method 
attempt reproduce reported results gsat wsat results may depend initial conditions seeds random number generator program parameters 
ran sgi challenge timing results compared gsat wsat 
results show approximately order magnitude faster wsat 
table compare published results gsat integer programming simulated annealing circuit synthesis problems 
results show performs times faster gsat 
table compare performance versions dlm best known results gsat circuit synthesis parity learning artificially generated sat hard graph coloring problems 
results gsat better published results 
results show dlm consistently faster gsat ii par inputs order magnitude faster gsat aim inputs 
single cpu mhz sgi challenge mips university illinois national center supercomputing applications estimate empirically slower sun sparcstation executing solve sat benchmark problems 
evaluate speed difference mhz sgi challenge mhz sgi challenge gsat wsat run 
algorithms satisfiability sat problem survey table 
execution times cpu seconds runs solve difficult dimacs benchmark problems 
prob 
succ 
sun ss seconds id ratio avg 
min 
max 
par par par par par par par par par par par par par par par hanoi program parameters flat region limit reset interval operation 
problem group par test par problems hanoi tabu length increment designing new strategies improve performance 
tables shows preliminary promising results difficult satisfiable dimacs benchmark inputs 

experiments practical industrial benchmarks 
performance sat circuit solver partitioning preprocessing 
compare table gu puri sat solver having partitioning preprocessing existing algorithms solving industrial asynchronous circuit design benchmarks including hp philips benchmarks 
table initial number states initial number signals respectively 
correspondingly final number states final number signals 
symbol indicates level implementation area 
experimental results indicate compared previous methods sat circuit solver partitioning preprocessing achieves orders magnitude performance improvement terms computing time addition reduced implementation area 
example large circuit sat circuit took seconds solve problem yielded level implementation area literals 
contrast lavagno algorithm took seconds area literals 
example algorithm yield solution seconds aborted due literal standard unit measuring layout area 
jun gu paul purdom john franco benjamin wah table 
experimental results comparing sat circuit solver sat formula partitioning preprocessing algorithm lavagno algorithm practical circuit benchmarks sun sparc workstation 
time unit seconds 
circuit specifications preprocessing lavagno name cpu cpu cpu backtrack limit backtrack limit mmu backtrack limit state error mmu backtrack limit ram write nak pa pe rcv ifc fc ram read alex non free choice send pkt send ctl pa state error alloc outbound fifo read ctl ex ser done ex backtracking limit 
benchmark circuit mmu sat circuit solved seconds compared pre aborted seconds approach 
performance bdd sat solver partitioning preprocessing 
bdd sat circuit solver implemented language 
case gu puri tested bdd sat circuit solver ability find solutions optimal solution large number industrial asynchronous circuit benchmarks including hp philips benchmarks 
compared performance bdd sat circuit solver known lavagno asynchronous circuit design technique 
results experiments table table 
table compares execution time bdd sat solver execution time simple backtracking sat algorithm 
experimental results sat instances generated gu puri sat formula partitioning preprocessor 
bdd sat circuit solver yielded solutions normalized execution time backtracking algorithm truth assignment 
experimental results table show bdd sat solver outperforms backtracking sat algorithms satisfiability sat problem survey table 
experimental results comparing bdd solver backtracking sat algorithm sat formula partitioning preprocessing practical asynchronous circuit benchmarks sun sparc workstation 
time unit second 
stg bdd backtracking stg bdd backtracking benchmark sat satisfiability benchmark sat satisfiability name solver testing name solver testing mmu pa fifo technique practical sat instances representing asynchronous circuit design 
calculated implementation area designed circuits 
table compares bdd sat solver known lavagno asynchronous circuit design technique 
bdd sat circuit solver yielded reduced circuit implementation area lavagno algorithm circuits benchmark set 
lavagno method yields total area literals seconds 
comparison benchmarks bdd sat solver achieved area literals seconds 
addition lavagno method unable solve benchmark circuits pa results show compared existing techniques bdd sat solver capable achieving average reduction implementation area benchmarks 
critical industrial evaluations bdd sat solver offers practical solution complex industrial asynchronous circuit design problems 

applications practical application problems driving forces sat research 
provide ultimate benchmarks test sat algorithms techniques 
effective sat algorithm application problem shed light solving problems application areas 
sat problem direct applications mathematical logic artificial intelligence vlsi engineering computing theory 
indirect applications transferable problems constraint satisfaction problems constrained optimization problems 
due unisat models application problems real space related sat 
list applications formulated solved instances sat 
jun gu paul purdom john franco benjamin wah table 
comparison implementation area design time bdd sat circuit solver sat formula partitioning preprocessing lavagno technique practical asynchronous circuit benchmarks sun sparc workstation 
time unit second 
benchmark bdd sat solver lavagno moon benchmark initial initial final circuit cpu final circuit cpu name 


area time 
area time states signals signal literals sec 
signal literals sec 
mmu pa internal state error fifo non free choice stg ffl mathematics finding ary relations transitive closure detecting graph subgraph isomorphisms graph coloring problem mathematical cryptology automata homomorphism problem finding spanning trees euler tours graph solving traveling salesman problem logical arithmetic 
ffl computer science artificial intelligence constraint satisfaction problem queens problem extended inference logical programming abductive inference synthesizing composite hypotheses semantic information processing puzzles truth maintenance production system soma cube instant problem theorem proving neural network computing 
ffl machine vision image matching problem line edge labeling problems stereopsis scene analysis algorithms satisfiability sat problem survey semantics region growing shape object matching problem syntactic shape analysis shape shading problem image restoration 
ffl robotics related vision problem packing problem trajectory task planning problems 
ffl computer aided manufacturing task planning design solid modeling configuring task design cellular manufacturing system scheduling dimensional object recognition 
ffl database systems operations objects database consistency maintenance query answering redundancy checking query optimization concurrency control distributed database systems truth belief maintenance relational homomorphism problem knowledge organization recognition system 
ffl text processing optical character recognition character constraint graph model printed text recognition handwritten text recognition automatic correction errors text 
ffl computer graphics construction dimensional pictures dimensional graphical objects constraints reasoning geometrical features dimensional objects 
ffl integrated circuit design automation circuit modeling logic minimization state assignment state minimization asynchronous circuit synthesis encoding sequential machines power dissipation estimation logic partitioning circuit layout placement scheduling high level synthesis pin assignment interconnection analysis routing compaction performance optimization testing test generation verification 
please see jun gu satisfiability problems vlsi engineering 
ffl computer architecture design instruction set optimization computer controller optimization arithmetic logic circuit design compiler system optimization scheduling fault tolerant computing task partitioning assignment load balancing real time systems data flow consistency analysis data module assignment memory system parallel distributed processing 
ffl high speed networking contact authors 
ffl communications contact authors 
ffl security contact authors 
areas industrial chemical transportation construction nuclear engineering management medical research social sciences numerous sat csp applications 
jun gu paul purdom john franco benjamin wah 
number research directions satisfiability problem discussed 
emphasized dimacs satisfiability workshop 
general boolean expressions evaluation 
practical application problems expressed boolean satisfiability problems compact set general boolean functions 
transformation general boolean expression cnf done polynomial time result substantially larger clause form representation 
may critical complexity theory serious impact time solve problems 
efficient representation manipulation general boolean functions crucial solving practical application problems 
theoretical issues 
research sat brought interesting theoretical problems average time complexity analysis determining satisfiable unsatisfiable boundary global convergence local convergence rate structure hardness input models 
problems average time complexity analysis extremely difficult 
far preliminary efforts simplified assumptions 
efforts solve sat formulas find subclasses problem solvable polynomial time 
direction aims building hierarchies formulae classes analyzing properties hierarchies qualitative evaluation hierarchies 
sat algorithm development 
development new algorithms improved techniques satisfiability testing long term effort research community industry 
computation efficiency point view specific data structures implementation details sat algorithms crucial 
algorithm space shows number asymmetrical irregular places implying opportunity new sat algorithm development 
experimental point view difficult find super algorithm performs wide range sat instances 
existing sat algorithms complement exclude effective particular problem instances 
directions continue development algorithm integrating different algorithms cluster computers section 
computer hardware memory space increasingly inexpensive 
trade hardware improved performance show promising approach fact trading memory space speed basic design philosophy risc computer architectures 
important practical applications may significant problem domain information 
efficient sat algorithms may developed exploring input application specific structures section 
specialized algorithms tailored particular applications hand provide key insights general satisfiability testing 
algorithms satisfiability sat problem survey practical application case study 
recognized sat researchers practical application problems driving forces sat research ultimate benchmarks test sat algorithms 
direction addressed nsf advisory committee organizing committee dimacs satisfiability workshop 
strong relationship theory algorithms applications sat 
major step bring theorists practitioners working sat industrial applications involving sat enhancing interaction research groups 
beneficial research community industry apply theoretical algorithmic results sat practical problems practical problems theoretical algorithmic study 
addition theoretical algorithmic study concentrate significant industrial case studies sat practical applications sat algorithms practical industrial sat benchmarks 
parallel algorithms architectures 
implementing algorithm vlsi hardware architectures common practice speed algorithm execution 
offer faster execution speed certain sequential portions algorithm may implemented hardware architectures parallel form 
sat se certain granularity search tree level clause level variable level lend parallel processing 
number parallel algorithms architectures solving sat developed perform different levels granularity 
basic approaches taken direction implementing parallel sat inference algorithms special purpose vlsi chips implementing tightly coupled parallel sat algorithms existing sequential computer machines 
algorithm engineering approach 
aho johnson karp kosaraju mcgeoch papadimitriou pevzner proposed algorithm engineering approach experimental testing algorithms 
believe theoretical computer science algorithms usually studied highly simplified models computation evaluated metrics asymptotic worst case running time competitive ratio 
metrics indicative algorithms perform practice sufficiently accurate predict actual performance 
situation improved models take account details system architecture factors data movement interprocessor communication considerable experimentation fine tuning typically required get theoretical idea 
efforts ensure promising algorithms discovered theory community implemented tested refined point usefully applied practice 

sat problem core class np complete problems practical applications 
years optimization methods parallel jun gu paul purdom john franco benjamin wah algorithms practical techniques developed solving sat problem 
past decades seen proliferation sat algorithms resolution local search global optimization bdd sat solver multispace search 
existing methods complement exclude effective particular instances sat 
survey general algorithm space integrates existing sat algorithms unified perspective 
describe major classes sat algorithms emphasis introducing advances sat algorithms 
gave performance evaluation existing sat algorithms 
survey provides set practical applications sat 
area sat research rich land developed theory methods 
apply theoretical algorithmic results practical problems ultimate way test benchmark sat algorithms 
results endeavor major scientific industrial impact process push optimization technology limit 
acknowledgments authors grateful people help preparing article 
moshe vardi suggested survey written dimacs satisfiability workshop 
bob johnson steve cook david johnson christos papadimitriou provided valuable comments article 
ding zhu du panos pardalos mauricio resende craig urquhart andy sage vaughan pratt banerji lewis johnson endre peter hammer lee david plaisted wang stearns sandeep shukla daniel rosenkrantz harry hunt iii ming li deng frank hsu marathe dennis kibler vladimir leonid khachiyan murty stephen vavasis david yau scott kirkpatrick fred glover pierre hansen allen van gelder john schlipf randy bryant bart selman david mitchell henry kautz john mitchell hsiang li wen gao wei li anthony rina dechter james crawford vipin kumar gu wei wang puri bin du peter ewald kazuo giorgio gallo olivier dubois oliver ingo henri morel hans philip jackson max bohm peter theo ian gent toby roberto battiti marco arne chen guo liang insightful comments various early versions survey 
algorithms satisfiability sat problem survey abel 
order connections automatic wire routing 
ieee trans 
computers pages nov 
abramson yung 
divide conquer global constraints solution queens problem 
journal parallel distributed computing 
leonard adleman molecular computation solutions combinatorial problems science 

optimization survey 
ieee trans 
computers oct 
aho hopcroft ullman 
design analysis computer algorithms 
addison wesley reading 
aho hopcroft ullman 
data structures algorithms 
addisonwesley reading 
aho sethi ullman 
compilers 
addison wesley reading 
aho johnson karp kosaraju mcgeoch papadimitriou pevzner theory computing goals directions march 
akers 
binary decision diagrams 
ieee transactions computers jun 

mathematische und german 
teubner publishing leipzig 
akers 
linear assignment algorithm module placement 
proc 
th acm ieee design automation conference pages 
aloimonos 
visual shape computation 
proceedings ieee aug 
anderson hinton 
models information processing brain 
hinton anderson editors parallel models associative memory chapter pages 
lawrence erlbaum associates publishers hillsdale new jersey 
anderson rosenfeld editors 
neurocomputing foundations research 
mit press cambridge 
arora lund motwani sudan szegedy 
proof verification hardness approximation problems 
proceedings rd ieee symposium foundations computer science pages 
arrow hurwicz 
gradient method concave programming local results 
arrow editors studies linear nonlinear programming 
stanford university press stanford ca 
ghosh devadas 
boolean satisfiability equivalence checking general binary decision diagrams 
integration vlsi journal 
tarjan 
linear time algorithm testing truth certain quantified boolean formulas 
information processing letters mar 

recognizing disguised nr instances satisfiability problem 
journal algorithms pages 
bagchi shi 
fault tolerance massively parallel computers 
rd international symposium ai mathematics jan 
baird 
anatomy versatile page reader 
proceedings ieee jul 
ballard brown 
computer vision 
prentice hall englewood cliffs new jersey 
banerjee jones sargent 
parallel simulated annealing algorithms cell placement hypercube multiprocessors 
ieee trans 
parallel distributed systems jan 

solutions minimization problem fault tolerant logic circuits 
ieee trans 
computers apr 
ben davis chor goldreich luby 
theory average case complexity 
computer systems sciences 
ben tal 
global minimization reducing duality gap 
mathematical programming 

improved method prime class derivation state reduction sequential networks 
ieee trans 
computers feb 
jun gu paul purdom john franco benjamin wah hoos metzger wei 
gsat versus simulated annealing 
proceedings ecai pages 
berman franco schlipf 
unique satisfiability horn sets solved nearly linear time 
proc 
seventh advanced research institute discrete applied mathematics new brunswick new jersey may 
discrete applied mathematics 

explicit solutions queens problems acm sigart bulletin apr acm press 
hadzilacos goodman 
concurrency control recovery database systems 
addison wesley publication 
wolfgang bibel 
automated theorem proving 
vieweg 
biswas 
state minimization incompletely specified sequential machines 
ieee trans 
computers jan 
reingold 
backtrack programming techniques 
comm 
acm nov 
blair jeroslow lowe 
results experiments programming techniques propositional logic 
computers operations research 
blanks 
near optimal placement quadratic objective function 
proc 
th acm ieee design automation conference pages 

scheduling dependent tasks different arrival times meet deadlines 
proc 
international workshop modeling performance evaluation computer systems pages 
bohm :10.1.1.40.9517
fast parallel sat solver efficient workload balancing 
rd international symposium ai mathematics jan 
appear annals mathematics artificial intelligence 

partitioning problems parallel pipelined distributed computing ieee trans 
computers jan 

job assignment parallel system processor sharing queues 
ieee trans 
computers july 
hammer kogan 
computational experiments exact sat solver 
rd international symposium ai mathematics jan 
hammer 
polynomial time inference valid implications horn related formulae 
annals mathematics artificial intelligence pages 
hammer sun 
recognition horn formulae linear time 
discrete applied mathematics pages 
hammer saks 
complexity index satisfiability problems 
siam journal computing pages 
brady 
approach topological pin assignment 
ieee trans 
cad vol 
pp 
july 
brady hollerbach johnson lozano perez mason editors 
robot motion planning control 
mit press cambridge 
breuer 
min cut placement 
design automation fault tolerant computing 
brewer gajski 
system constraint driven behavioral synthesis 
ieee trans 
cad july 
broder frieze upfal 
satisfiability maximum satisfiability random cnf formulas 
proceedings fourth annual acm siam symposium discrete algorithms pages 
brooks horn 
shape source shading 
proc 
ijcai pages aug 
brown purdom 
backtrack searching presence symmetry 
th international conference algebraic algorithms error correcting codes lecture notes computer science vol 
pp 

brown purdom 
backtrack searching presence symmetry 
nordic journal computing appear 
brown purdom 
average time analysis backtracking 
siam computing aug 
algorithms satisfiability sat problem survey brown purdom 
empirical comparison backtracking algorithms 
ieee trans 
pattern analysis machine intelligence pami may 
bruderlin 
constructing dimensional geometric objects defined constraints 
proceedings acm siggraph workshop interactive graphics 
bruynooghe 
solving combinatorial search problems intelligent backtracking 
information processing letters 
bruynooghe 
graph coloring constraint satisfaction 
technical report cw dept computer science katholieke universiteit leuven dec 
bruynooghe pereira 
deduction revision intelligent backtracking pages 
ellis horwood limited 
bryant 
graph algorithms boolean function manipulation 
ieee trans 
computers aug 
bryant 
symbolic boolean manipulation ordered binary decision diagrams 
acm computing surveys sept 
bryant 
binary decision diagrams applied sat related problems 
dimacs workshop satisfiability problem theory applications 
march 

generalized horn formulas resolution 
theoretical computer science pages 

und algorithmen 
teubner stuttgart 
english version appear 
purdom 
clause order backtracking 
technical report 
brown 
average case analysis satisfiability model problems 
information sciences 
pan purdom 
exponential average time pure literal rule 
siam computing 
bundy editor 
catalogue artificial intelligence tools 
springer verlag berlin 
burns newton 
efficient constraint generation hierarchical compaction 
proc 
int conf 
computer design pages 
ieee computer society oct 
buro 
report sat competition 
technical report fb mathematik informatik universitat paderborn nov 
buro 
report sat competition 
bulletin european association theoretical computer science feb 
burstein 
hierarchical channel router 
proc 
th acm ieee design automation conference pages jun 
butler 
computing permutation matrix groups ii backtrack algorithm 
math 
comp 

butler lam 
general backtracking algorithm isomorphism problem combinatorial objects 
symbolic computation 

approach traveling salesman problem efficient simulation algorithm 
journal optimization theory applications 
agrawal bushnell 
neural net boolean satisfiability model logic circuits 
ieee design test computers pages oct 
chakravarty 
generalized line junction labeling scheme applications scene analysis 
ieee trans 
pattern analysis machine intelligence pami apr 
chan thomborson 
delay optimization carry skip adders block carry lookahead adders multidimensional dynamic programming 
ieee trans 
computers aug 
chandra merlin 
optimal implementation conjunctive queries relational databases 
proceedings th acm symposium theory computing pages 
hooker 
extended horn sets propositional logic 
acm pages 
chang wah 
lagrangian techniques solving class zero integer linear programs 
proc 
computer software applications conf 
jun gu paul purdom john franco benjamin wah 
chang wah 
lagrangian techniques solving class zero integer linear programs 
proc 
computer software applications conference pages dallas tx august 
ieee 
chao franco 
probabilistic analysis heuristics satisfiability problem 
siam computing 
chao franco 
probabilistic analysis generalization unit clause literal selection heuristics satisfiable problem 
information sciences 
chandrasekaran 
integer programming problems simple rounding type algorithm works 
pulleyblank ed 
progress combinatorial optimization 
academic press canada toronto ontario canada pages 
plato 
efficient partitioning components 
proc 
th annual design automation workshop pages 
chv atal szemer edi 
hard examples resolution 
acm 
chen liu 
parallel approach theorem proving propositional logic 
inform 
sci 
chin dyer 
model recognition robot vision 
acm computing surveys mar 
tam anh chu 
synthesis self timed vlsi circuits graph theoretic specifications 
phd thesis dept electrical engineering computer science mit june 
chu editor 
special section chinese text data processing 
ieee computer volume number 
ieee computer society press 
chv atal reed 
mick gets odds side 
proceedings foundations computer science 
cichocki unbehauen 
switched capacitor artificial neural networks nonlinear optimization constraints 
proc 
ieee int symposium circuits systems pages 
cleary 
logical arithmetic 
computing systems 
clocksin mellish 
programming prolog nd edition 
springer verlag berlin 
clowes 
seeing things 
artificial intelligence 
cohen editor 
special section logic programming 
comm 
acm volume number 

cohoon paris 
genetic placement 
digest int conf 
computeraided design pages 
colmerauer 
opening prolog iii universe 
byte magazine pages aug 

parallel execution logic programs 
kluwer academic publishers boston 
kapoor rao 
balanced matrices 
mathematical programming state art 
birge murty eds 
braun united states 
produced association th int symposium mathematical programming university michigan 
cook 
complexity theorem 
proceedings third acm symposium theory computing pages 
cook 
find hard instances satisfiability problem 
dimacs workshop satisfiability problem theory applications 
march 
cooper swain 
parallelism domain dependence constraint satisfaction 
technical report tr dept computer science univ rochester dec 
cormen leiserson rivest 
algorithms 
mit press cambridge 
corneil kirkpatrick 
theoretical analysis various heuristics graph isomorphism problem 
siam computing 
hammer jaumard 
product form parametric representation solutions quadratic boolean equation 
recherche op operations research 
hansen jaumard 
basic algorithm pseudo boolean programming revisited 
discrete applied mathematics 
algorithms satisfiability sat problem survey crawford auton 
experimental results crossover point satisfiability problem 
proc 
aaai pages aug 
crawford auton 
experimental results crossover point satisfiability problems 
rd international symposium ai mathematics jan 
crawford 
solving satisfiability problems combination systematic local search 
submitted dimacs challenge ii workshop 

effects problem partitioning allocation granularity performance multiple processor systems 
ieee trans 
computers apr 
dai kuh 
hierarchical building block layout 
digest int conf 
computer aided design pages 
dalal etherington 
hierarchy tractable satisfiability problems 
information processing letters pages 
das banerji 
control memory minimization digital computers 
ieee trans 
computers sept 
davis 
shape matching relaxation techniques 
ieee trans 
pattern analysis machine intelligence pami jan 
davis henderson 
hierarchical constraint processes shape analysis 
ieee trans 
pattern analysis machine intelligence pami may 
davis logemann loveland 
machine program theorem proving 
communications acm 
davis putnam 
computing procedure quantification theory 
acm 
de kleer 
assumption tms 
artificial intelligence 
de kleer 
problems atms 
artificial intelligence 
de kleer 
comparison atms csp techniques 
proceedings th ijcai pages 
de kleer 
exploiting locality tms 
proceedings aaai pages 
dechter 
learning searching constraint satisfaction problems 
proceedings aaai 
dechter 
constraint network approach truth maintenance 
technical report computer science dept ucla los angeles 
dechter 
enhancement schemes constraint processing backjumping learning cutset decomposition 
artificial intelligence 
dechter 
directional resolution davis putnam procedure revisited 
rd international symposium ai mathematics jan 
dechter dechter 
belief maintenance dynamic constraint networks 
proceedings aaai 
dechter pearl 
network heuristics constraint satisfaction problems 
artificial intelligence 
denker editor 
neural networks computing volume aip snowbird utah conference proceedings 
american institute physics new york 
dershowitz hsiang josephson plaisted 
associative commutative rewriting 
proceedings ijcai pages 
deutsch 
channel router 
proc 
th acm ieee design automation conference pages jun 
deutsch 
compacted channel routing 
digest int conf 
computer aided design pages nov 
deutsch 
short cut certain combinational problems 
british joint comput 
conference 
devadas 
optimal layout boolean satisfiability 
proceedings iccad pages nov 
devadas white 
estimation power dissipation cmos combinational circuits boolean function manipulation 
ieee transactions cad mar 
jun gu paul purdom john franco benjamin wah devadas ma newton vincentelli 
synthesis optimization procedure fully easily testable sequential machines 
ieee trans 
cad oct 
liu 
real time 
operations research feb 
dhar crocker 
problem solver tms architecture general constraint satisfaction problems 
technical report dept information systems new york university 
dincbas simonis hentenryck 
solving cutting stock problem constraint logic programming 
proceedings th international conference logic programming 
lengauer 
algorithm aspects dimensional layout 
ieee trans 
cad cad 
donath 
placement average interconnection lengths computer logic 
ieee trans 
circuits systems cas apr 
donath 
wire length distribution placements computer logic 
ibm research development may 
donath hoffman 
algorithms partitioning graphs computer logic eigenvectors connection matrices 
ibm technical disclosure bulletin pages 
dowling gallier 
linear time algorithms testing satisfiability propositional horn formulae 
journal logic programming pages 
doyle 
truth maintenance system 
artificial intelligence 
du gu 
sequential circuit test generation boolean satisfiability 
appear 
du gu pardalos editors 
satisfiability sat problem 
dimacs volume series discrete mathematics theoretical computer science american mathematical society 
dubois 
counting number solutions instances satisfiability 
theoretical computer science 
dubois carlier 
probabilistic approach satisfiability problem 
theoretical computer science 
dubois 
analysis space solutions random instances satisfiability problem 
proceedings fourth international symposium artificial intelligence mathematics ft lauderdale florida 
dubois andre carlier 
sat versus unsat 
dimacs series volume clique graph coloring satisfiability second dimacs implementation challenge 
editors johnson trick american mathematical society 
eastman 
preliminary report system general space planning 
comm 
acm feb 
eiter mannila 
remarks renaming satisfiability hierarchies 
summary rd international symposium ai mathematics jan 
eswaran gray lorie traiger 
notion consistency predicate look database system 
comm 
acm nov 
itai shamir 
complexity timetable multi commodity flow problems 
siam computing 

schmitz 
note queens problem 
information processing letters vol 
july 
fang chen 
vectorization generalized procedure theorem proving propositional logic vector computers 
ieee trans 
knowledge data engineering oct 
faugeras price 
semantic description aerial images stochastic labeling 
ieee trans 
pattern analysis machine intelligence pami nov 
faugeras editor 
fundamentals computer vision 
cambridge university press london 
feldman 
decision theory artificial intelligence region analyzer 
artificial intelligence 
algorithms satisfiability sat problem survey findler 
associative networks representation knowledge computers 
academic press new york 
floudas pardalos 
collection test problems constrained global optimization algorithms 
springer verlag new york 
floudas pardalos editors 
advances global optimization 
princeton university press new york 
fox 
constraint directed search case study job shop scheduling 
pitman london 
franco 
probabilistic performance algorithms satisfiability problem 
information processing letters 
franco 
elimination infrequent variables improves average case performance satisfiability algorithms 
siam computing 
franco ho 
probabilistic performance heuristic satisfiability problem 
discrete applied mathematics 
franco 
probabilistic analysis davis putnam procedure solving satisfiability problem 
discrete applied mathematics 
franco 

occurrence null clauses random instances satisfiability 
discrete applied mathematics pp 

franco swaminathan 
algorithm determining unsatisfiability propositional formulas 

franco swaminathan 

average case results satisfiability algorithms random clause width model 
appear annals mathematics artificial intelligence 
franco goldsmith schlipf swaminathan 

algorithm class pure implicational formulas 
proceedings workshop satisfiability siena italy 
chellappa 
method enforcing integrability shape shading algorithms 
ieee trans 
pattern analysis machine intelligence pami jul 
mittal 
constraints expert system configuration tasks 
computational mechanics publications nadel 
freeman 
improvements davis putnam procedure satisfiability 
jan 
freuder 
sufficient condition backtrack free search 
acm jan 
freuder 
sufficient condition backtrack bounded search 
acm oct 
freuder quinn 
advantage stable sets variables constraint satisfaction problems 
proceedings th ijcai pages 
frieze suen 

analysis simple heuristics random instances sat 

constraint kernels constraints dependencies geometric modeling system 
master thesis dept computer science univ utah aug 
galil 
complexity regular resolution davis putnam procedure 
theoretical computer science pages 
gallo 
polynomially solvable satisfiability problems 
information processing letters pages 
gallo 
algorithms testing satisfiability propositional formulae 
logic programming 
gallo 
hierarchies polynomially solvable sat problems 
rd international symposium ai mathematics jan 
garcia molina 
semantic knowledge transaction processing distributed database 
acm trans 
database systems jun 
garey johnson 
complexity results multiprocessor scheduling resource constraints 
siam comput 
garey johnson 
processors scheduling start times deadlines 
siam computing 
garey johnson 
computers intractability guide theory np completeness 
freeman san francisco 
jun gu paul purdom john franco benjamin wah gaschnig 
constraint satisfaction method inference making 
proceedings th annual allerton conf 
circuit system theory 
gaschnig 
general backtrack algorithm eliminates redundant tests 
proceedings th ijcai page 
gaschnig 
performance measurements analysis certain search algorithms 
phd thesis carnegie mellon university dept computer science may 
gelder 
satisfiability tester non clausal propositional calculus 
information computation oct 
geman geman 
stochastic relaxation gibbs distributions bayesian restoration images 
ieee trans 
pattern analysis machine intelligence pami nov 
geman 
hwang 
diffusions global optimization 
brown university 
genesereth nilsson 
logical foundations artificial intelligence 
morgan kaufmann publishers los altos california 
gent walsh 
hardest random sat problems 
proceedings ki 
gilmore 
proof method quantification theory 
ibm res 
develop 

algebraic theory automata 
academic press new york 
glover 
tabu search part orsa journal computing summer 


threshold unsatisfiability 
proceedings th annual symposium mathematical foundations computer science prague czechoslovakia 
goldberg 
average case complexity satisfiability problem 
proc 
fourth workshop automated deduction pages 
goldberg 
complexity satisfiability problem 
technical report courant computer science new york university 
goldberg purdom brown 
average time analysis simplified procedures 
information processing letters sept printer errors corrected information processing letters 

method minimizing number internal states incompletely specified sequential networks 
ieee trans 
computers ec june 
montanari 
minimization read memories digital computers 
ieee trans 
computers nov 
gu 
parallel algorithms architectures fast search 
ph thesis 
technical report uucs tr july 
gu 
solve large scale satisfiability problems 
technical report uucs tr technical report tr 
gu 
fffi relaxation global optimization 
technical report tr apr 
gu 
efficient local search large scale satisfiability problem 
sigart bulletin jan acm press 
gu 
optimizing search problem 
editor artificial intelligence methods applications vol 
chapter pages 
world scientific publishers new jersey jan 
gu 
unisat problem models appendix 
ieee trans 
pattern analysis machine intelligence aug 
gu 
local search satisfiability sat problem 
ieee trans 
systems man cybernetics jul apr 
gu 
global optimization satisfiability sat problem 
ieee trans 
knowledge data engineering jun feb 
gu 
optimization algorithms satisfiability sat problem 
advances optimization approximation 
ding zhu du ed pages 
kluwer academic publishers 
gu 
parallel algorithms satisfiability sat problem 
dimacs volume series discrete mathematics theoretical computer science vol 
pages american mathematical society 
algorithms satisfiability sat problem survey gu puri 
asynchronous circuit synthesis boolean satisfiability 
ieee transactions cad integrated circuits systems aug 
gu 
satisfiability problems vlsi engineering 
annual conference institute operations research management science oct dimacs workshop satisfiability problem mar 
appear discrete applied mathematics 
gu gu 
du 
convergence properties optimization algorithms satisfiability sat problem 
ieee trans 
computers feb 
gu efficient implementation sat algorithm 
technical report sept 
gu 
multi sat algorithm 
siena sat workshop workshop semidefinite interior point methods may 
appear discrete applied mathematics 
gu gu 
average time complexities local search algorithms satisfiability sat problem 
technical report tr 
lecture notes computer science vol 
pp 
appear ieee trans 
knowledge data engineering 
gu 
optimization multispace search 
technical report tr jan 
gu 
multispace search new optimization approach summary 
lecture notes computer science vol 
pages 

see multispace search satisfiability np hard problems 
gu 
optimization multispace search 
kluwer academic publishers 
gu huang 
local search search space smoothing case study traveling salesman problem tsp 
technical report tr aug 
ieee trans 
systems man cybernetics may 
gu wang henderson 
parallel architecture discrete relaxation algorithm 
ieee trans 
pattern analysis machine intelligence pami nov 
gu wang 
novel discrete relaxation architecture 
ieee trans 
pattern analysis machine intelligence aug 
gu 
constraint search 
cambridge university press new york 
gurevich 
average case completeness 
computer systems sciences 
guzman 
computer recognition dimensional objects visual scene 
phd thesis mit 
ha lee 
compile time scheduling assignment data flow program graphs data dependent iteration 
ieee trans 
computers nov 
haken 
intractability resolution 
theoretical computer science 
ousterhout 
router obstacle avoidance 
proc 
st acm ieee design automation conference pages jun 
hanan wolff 
experimental results placement techniques 
design automation fault tolerant computing may 
hammer 
boolean methods operations research related areas 
springer verlag new york 
hansen jaumard 
uniquely solvable quadratic boolean equations 
discrete applied mathematics 
hansen jaumard 
constrained nonlinear programming 
orsa journal computing 
hansen jaumard plateau 
extension nested satisfiability 
les cahiers du 
hansen jaumard 
algorithms maximum satisfiability problem 
computing 
hansen 
global optimization interval analysis 
dekker new york 
haralick elliot 
increasing tree search efficiency constraint satisfaction problems 
artificial intelligence 
haralick shapiro 
consistent labeling problem part 
ieee trans 
pattern analysis machine intelligence pami apr 
harary 
graph theory 
addison wesley reading 

theory schema labeling 
computational intelligence 
jun gu paul purdom john franco benjamin wah hedges dawson cho 
bitmap graph build algorithm compaction 
digest int conf 
computer aided design pages sep 
henderson davis 
hierarchical models analysis shape 
pattern recognition 
henderson samal 
multi constraint shape analysis 
image vision computing may 
hentenryck 
constraint satisfaction logic programming 
mit press cambridge 

complexity problem pure implicational formulas 
proc 
th int symposium mathematical foundations computer science mfcs hajek eds prague czech republic 
lecture notes computer science lncs springer verlag berlin pages 
hinton anderson editors 
parallel models associative memory 
lawrence erlbaum associates publishers hillsdale new jersey 
hinton sejnowski 
learning relearning boltzmann machine 
rumelhart mcclelland editors parallel distributed processing explorations microstructure cognition 
vol 
foundations volume chapter pages 
mit press cambridge 
hoffman moore 
constructions solution queens problem 
mathematics magazine pages 
holland 
adaption natural adaptive systems 
university michigan press ann arbor 
hong 
absolute minimization switching functions 
ieee trans 
computers jan 
hood grover 
designing real time systems ada 
technical report waltham jan 
hooker vinay 
empirical study branching rules satisfiability 
rd international symposium ai mathematics jan 
hooker 
generalized resolution cutting planes 
annals operations research 
hooker 
quantitative approach logical inference 
decision support systems 
hooker 
resolution vs cutting plane solution inference problems computational experience 
operations research letter 
hooker 
branch cut solution inference problems propositional logic 
technical report carnegie mellon university aug 
hopkins highly reliable fault tolerant multiprocessor aircraft 
proceedings ieee pages oct 
horn 
obtaining shape shading information psychology computer vision winston editor pages 
mcgraw hill new york 
horn 
understanding image intensity 
artificial intelligence 
horn brooks editors 
shape shading 
mit press cambridge 
horn brooks 
variational approach shape shading 
computer vision graphics image processing 
horowitz sahni 
fundamentals computer algorithms 
computer science press rockville 
horst tuy 
global optimization deterministic approaches 
springer verlag berlin 
hsiang 
theorem proving term rewriting systems 
artificial intelligence pages 
hu tang lee 
average case analysis resolution principle algorithm proving 
annals mathematics artificial intelligence 
huang gu wu 
constrained approach multi font character recognition 
ieee transactions pattern analysis machine intelligence aug 
algorithms satisfiability sat problem survey huffman 
impossible objects nonsense sentences 
meltzer michie eds machine intelligence pages 
edinburgh university press edinburgh scotland 
hummel zucker 
foundations relaxation labeling processes 
ieee trans 
pattern analysis machine intelligence pami may 
ikeuchi 
model interpretation range imagery 
proc 
image understanding workshop pages 
darpa feb 
ikeuchi horn 
numerical shape shading occluding boundaries 
artificial intelligence 
impagliazzo levin luby 
pseudo random number generation way function 
proceedings third acm symposium theory computing pages 
indurkhya stone xi cheng 
optimal partitioning randomly generated distributed programs 
ieee trans 
software engineering se mar 

adaptive simulated annealing asa 
lester research 
ishida 
parallel rule firing production systems 
ieee trans 
knowledge data engineering mar 
itai 
complexity herbrand theorem 
working department computer science israel institute technology 
kinoshita 
test pattern generation circuits tri state modules algorithm 
ieee trans 
cad dec 

cnf satisfiability test counting polynomial average time 
siam computing pages 
jahanian mok 
safety analysis timing properties real time systems 
ieee trans 
software engineering se sept 
basu 
approach organizing minimizes width control store words 
ieee trans 
computers may 
jeroslow wang 
solving propositional satisfiability problems 
annals mathematics ai 
jeroslow 
computation oriented reductions predicate propositional logic 
decision support systems 
johnson 
approximation algorithms combinatorial problems 
computer systems sciences 
johnson 
approaches traveling salesman guide 
nature 
johnson 
local optimization traveling salesman problem 
paterson editor lecture notes computer science vol 
automata languages programming pages 
springer verlag berlin 
johnson 
private communications 
johnson trick editors 
clique graph coloring satisfiability second dimacs implementation challenge 
dimacs series vol 

american mathematical society 
johnson 
neural network approach satisfiability problem 
parallel distributed computing 
johnston 
scheduling neural networks case hubble space telescope 
nasa memo 
johnson 
critical issues computer architecture design 
private communication 
johnson 
computer aided discovery fast algorithm 
nrl memorandum report may 
lewis johnson 
letter editor 
sigart bulletin april acm press 
lewis johnson 
letter editor 
sigart bulletin oct acm press 
josephson chandrasekaran smith jr tanner 
mechanism forming composite explanatory hypotheses 
ieee trans 
systems man cybernetics smc may june 
jackson jr heuristic search algorithms satisfiability problem 
submitted third ieee tai conference jul 
jun gu paul purdom john franco benjamin wah jones forbes 
adaptive simulated annealing algorithm global optimization continuous variables 
journal optimization theory applications 
ju rao 
consistency checking optimization macro models 
ieee trans 
cad aug 
kamath karmarkar ramakrishnan resende 
computational experience interior point algorithm satisfiability problem 
annals operations research 
kamath karmarkar ramakrishnan resende 
continuous approach inductive inference 
mathematical programming 
kamath karmarkar ramakrishnan resende 
computational experience interior point algorithm satisfiability problem 
mathematical sciences research center bell laboratories oct 
kamath motwani spirakis 

tail bounds occupancy satisfiability threshold conjecture 
random structures algorithms pp 

karmarkar 
new polynomial time algorithm linear programming 
combinatorica 
kedem watanabe 
graph optimization techniques ic layout compaction 
ieee trans 
cad cad 

state minimization incompletely specified sequential machines 
ieee trans 
computers april 
kirkpatrick vecchi :10.1.1.123.7607
optimization simulated annealing 
science 
kirkpatrick tishby 
statistical mechanics satisfaction 
proceedings neural information processing systems nov 
papadimitriou 
complexity recognizing polyhedral scenes 
computer system sciences 
kranakis 
better upper bound unsatisfiability threshold 
dimacs series discrete mathematics theoretical computer science 
kittler 
relaxation labeling algorithms review 
image vision computing pages 
knuth 
estimating efficiency backtracking programs 
mathematics computation jan 
knuth 
nested satisfiability 
acta informatica 
mcgrath 
compare program verifying vlsi layouts 
ieee design test computers 
kowalski 
proof procedure connection graphs 
acm oct 
kramer van leeuwen 
complexity wire routing finding minimum area layouts arbitrary vlsi circuits volume chapter vlsi theory pages 
jai press greenwich ct 
krishna shin 
processor tradeoffs distributed real time systems 
ieee trans 
computers sept 

ku 
dra chip implementation report 
project report dept computer science univ utah mar 
oliver systematic approach sat decision yielding sat decision steps 
theoretical computer science appear 
kumar 
algorithms constraint satisfaction problems survey 
technical report tr dept computer science univ minnesota 
kumar 
algorithms constraint satisfaction problems survey 
ai magazine 
kumar lin 
data dependency intelligent backtracking scheme prolog 
logic programming june 

noncommutative algorithm multiplying theta matrices multiplications 
bull 
amer 
math 
soc 
thomas 
architectural partitioning system level synthesis integrated circuits 
ieee trans 
cad july 
algorithms satisfiability sat problem survey varadarajan 
wire length minimization algorithm circuit layout compaction 
proc 
iscas pages may 
russo 
pin versus block relationship partitions logic graphs 
ieee trans 
computers dec 

test pattern generation boolean satisfiability 
ieee trans 
computeraided design jan 
lassez 
constraint logic programming 
byte magazine pages aug 
lavagno sangiovanni 
algorithms synthesis asynchronous circuits 
proc 
th dac pages 
lavagno moon brayton sangiovanni vincentelli 
solving state assignment problem signal transition graphs 
proc 
th dac pages 
lawler lenstra rinnooy kan shmoys editors 
traveling salesman problem 
john wiley sons new york 
lawler wood 
bound methods survey 
operations research jul aug 
lee 
representation switching circuits binary decision programs 
bell systems technical journal july 
lee 
algorithm path connections applications 
ieee trans 
electronic computers vec sept 
lee 
consistency dataflow graphs 
ieee trans 
parallel distributed systems apr 
lee 
private communications 
lehoczky sha 
performance real time bus scheduling algorithms 
acm performance evaluation review may 
special issue 
lewis 
renaming set clauses horn set 
journal association computing machinery pages 
li wah 
cope anomalies parallel approximate branch algorithms 
proc 
national conf 
artificial intelligence aaai pages aug 

li 
parallel processing combinatorial search problems 
phd thesis school electrical engineering purdue university west lafayette dec 
li wah 
parallel ordered depth searches 
proc 
int conf 
parallel processing pages university park pa august 
pennsylvania state univ press 
li wah 
computational efficiency combinatorial tree searches 
trans 
software engineering january 

li wah 
parallel iterative refining efficient search scheme solving combinatorial optimization problems 
proc 
int conf 
parallel processing pages university park pa august 
pennsylvania state univ press 
li chen 
compiling communication efficient programs massively parallel machines 
ieee trans 
parallel distributed systems july 

liao wong 
algorithm compact vlsi symbolic layout mixed constraints 
ieee trans 
cad cad 
lichtenstein 
planar formulae uses 
siam journal computing 
lieberherr specker 
complexity partial satisfaction 
acm 
lin keller 
gradient model load balancing method 
ieee trans 
software engineering se jan 
lin lin 
automatic synthesis asynchronous circuits 
proc 
th dac pages 
lin 
computer solutions traveling salesman problem 
bell sys 
tech 
journal dec 
lin kumar 
parallel architectures discrete relaxation algorithm 
aaai workshop parallel algorithms ai detroit aug 

lin 
parallel implementation logic programs 
phd thesis univ texas austin dept computer science may 
jun gu paul purdom john franco benjamin wah lippmann 
computing neural net 
ieee assp magazine april 
richard lipton dna solution hard computational problems science 
locke 
best effort decision making real time scheduling 
phd thesis university may 
loveland 
automated theorem proving logical basis 
north holland 

extending definition prime compatibility classes states incompletely specified sequential machine reduction 
ieee trans 
computers jun 
luenberger 
linear nonlinear programming 
addison wesley reading 
lynch 
multi level atomicity new correctness criterion database concurrency control 
acm trans 
database systems dec 
mackworth 
consistency networks relations 
artificial intelligence 
major lapalme 
combination symbolic numerical computation dimensional modeling rna 
sciences 
malik wang brayton sangiovanni vincentelli 
logic verification binary decision diagrams logic synthesis environment 
proc 
acm ieee international conference cad 
malik maydan 
recovering dimensional shape single image curved objects 
ieee trans 
pattern analysis machine intelligence pami jun 

average case complexity sat symmetric distribution 
logic computation feb 
gamal 
area delay optimization programmable logic arrays 
technical report stanford university sept 
marsland campbell 
parallel search strongly ordered game trees 
acm computing surveys dec 
marsland schaeffer 
computers chess cognition 
springer verlag new york 
marble 
graph coloring algorithms 
graph theory computing 
read editor pages 
academic press new york 

tabu search sat 
proceedings cp workshop solving really hard problems pages 
mcallester 
truth maintenance 
proceedings aaai pages 
mccall gray haralick 
parallel computer architectures problem solving strategies consistent labeling problem 
ieee trans 
computers nov 
mcgregor 
relational consistency algorithms application finding subgraph graph isomorphisms 
information sciences 
mclean dyer 
analog relaxation processor 
proceedings th international conference pattern recognition pages 
mehlhorn 
data structures algorithms graph algorithms np completeness 
springer verlag berlin 

morel 
variational method analyzing unit clause search 
siam computing michalewicz 
genetic algorithms data structure evolution programs 
springerverlag 
minoux unique horn satisfiability problem quadratic boolean equations annals mathematics artificial intelligence special issue connections combinatorics logic franco dunn wheeler eds 

minton johnston philips laird 
solving large scale constraint satisfaction scheduling problems heuristic repair method 
proceedings aaai pages aug 
minton johnston philips laird 
heuristic repair method constraint satisfaction scheduling problems 
artificial intelligence 
algorithms satisfiability sat problem survey miranker 
treat new efficient match algorithm ai production systems 
pitman london 
miranker 
organization performance treat production system compiler 
ieee trans 
knowledge data engineering mar 
mitchell selman levesque 
hard easy distributions sat problems 
proceedings aaai pages jul 
mohr henderson 
arc path consistency revisited 
artificial intelligence 
monien 
solving satisfiability steps 
discrete applied mathematics 
monien 
superlinear speedup parallel backtracking 
mori suen yamamoto 
historical review ocr research development 
proceedings ieee jul 
morris 
breakout method escaping local minima 
proc 
th national conf 
artificial intelligence pages washington dc 
murtagh saunders 
minos user guide 
technical report sol dept operations research stanford university stanford ca 
nadel 
constraint satisfaction algorithms 
computational intelligence 
nadel lin 
automobile transmission design constraint satisfaction problem collaborative research project ford motor technical report wayne state university 

exploration innovation design 
springer verlag sadeh 
marks 
layout planning consistent labeling optimization problem 
proceedings th international symposium robotics ai construction 
newell simon 
human problem solving 
prentice hall englewood cliffs new jersey 
ni xu gendreau 
distributed drafting algorithm load balancing 
ieee trans 
software engineering se oct 
wilf 
combinatorial algorithms 
academic press new york 
nilsson 
principles artificial intelligence 
tioga publishing palo alto california 

partitioning logic units 
fujitsu scientific technical journal jun 
pager 
efficient algorithm graph isomorphism 
acm jan 
papadimitriou steiglitz 
complexity local search traveling salesman problem 
siam computing 
papadimitriou steiglitz 
combinatorial optimization algorithms complexity 
prentice hall englewood cliffs 
papadimitriou 
selecting satisfying truth assignment 
proceedings nd annual symposium foundations computer science pages 
koutsoupias papadimitriou 

greedy algorithm satisfiability 
information processing letters pp 

papadimitriou private communications 
pardalos rosen 
constrained global optimization algorithms applications 
springer verlag new york 
pardalos 
complexity numerical optimization 
world scientific river edge 
patel korn 
hierarchical vlsi routing approximate routing procedure 
ieee trans 
cad cad apr 
patterson 
mathematical cryptology 
new jersey 
paulin knight 
force directed scheduling behavioral synthesis asic 
ieee trans 
cad june 
pearl 
heuristics 
addison wesley reading 
jun gu paul purdom john franco benjamin wah 
sat problem instances algorithms 
private communications stanford university 
penna shape form shading analysis single perspective image polyhedron 
ieee trans 
pattern analysis machine intelligence pami jun 
pereira porto 
selective backtracking pages 
academic press 
petrie 
revised dependency directed backtracking default reasoning 
proceedings aaai pages 
fast algorithm convert boolean expressions cnf ibm computer science rc watson new york 
urquhart 
complexity os calculus 
siam disc 
math 
plotkin rosenthal franco 
correction probabilistic analysis procedure solving satisfiability problem 
discrete applied mathematics 
la director 
mason global approach vlsi design 
ieee trans 
cad cad oct 
pradhan editor 
fault tolerant computing theory practice 
prentice hall englewood cliffs 
prawitz 
improved proof procedure 
theoria 

linear time algorithm unique horn satisfiability 
information processing letters 

efficiency stability hypergraph sat algorithms 
dimacs series volume clique graph coloring satisfiability second dimacs implementation challenge 
editors johnson trick american mathematical society 
purdom 
survey average time sat performance 
rd international symposium ai mathematics jan 
purdom 
tree size partial backtracking 
siam computing nov 
purdom 
search rearrangement backtracking polynomial average time 
artificial intelligence 
purdom 
solving satisfiability searching 
ieee trans 
pattern analysis machine intelligence 
purdom 
survey average time analyses satisfiability algorithms 
information processing 
purdom 
average time full pure literal rule 
information sciences 
purdom brown 
analysis backtracking search rearrangement 
siam computing nov 
purdom brown 
pure literal rule polynomial average time 
siam computing 
purdom brown 
polynomial average time satisfiability problems information science 
purdom brown robertson 
backtracking multi level dynamic search rearrangement 
acta informatica 
purdom haven 
backtracking probing 
technical report dept computer science indiana university aug 
purdom haven 
probe order backtracking 
accepted siam computing appear 
puri gu 
efficient algorithm search minimal closed covers sequential machines 
ieee transactions cad integrated circuits systems jun 
puri gu 
efficient algorithm computer length minimization 
ieee transactions cad integrated circuits systems oct 
puri gu 
area efficient synthesis asynchronous interface circuits 
proc 
ieee international conference computer design 
algorithms satisfiability sat problem survey puri gu 
divide conquer approach asynchronous circuit design 
proceedings th ieee international symposium high level synthesis pages may 
puri gu 
bdd sat solver satisfiability testing 
annals mathematics artificial intelligence vol 
pp 

rao biswas 
minimization control memory digital computer 
ieee trans 
computers sept 
rao biswas 
minimization incompletely specified sequential machines 
ieee trans 
computers nov 
read corneil 
graph isomorphism disease 
graph theory 
reed roscoe 
timed model communicating sequential processes 
proc 
icalp pages 
springer lncs 
reed sangiovanni vincentelli 
new symbolic channel router yacr 
ieee trans 
cad cad july 

simplified solution queens problem 
information processing letters vol 
june 
resende feo 
grasp max sat 
rd international symposium ai mathematics jan 
rivest 
cryptography 
handbook theoretical computer science 
leeuwen editor chapter pages 
mit press cambridge 
rivest fiduccia 
greedy channel router 
proc 
th acm ieee design automation conference pages jun 
robinson 
machine oriented logic resolution principle 
journal acm pages 
rosenfeld 
computer vision basic principles 
proceedings ieee aug 
rosenfeld hummel zucker 
scene labeling relaxation operations 
ieee trans 
systems man cybernetics smc june 
bruynooghe 
empirical study constraint satisfaction problems 
proceedings north holland sept 
wolff 
analytical power timing optimization technique digital system 
proc 
th acm ieee design automation conference pages jun 
russell norvig 
artificial intelligence modern approach 
prentice hall englewood cliffs 
russo 
tradeoff logic circuit pin ratio lsi 
ieee trans 
computers 
russo oden wolff 
heuristic procedure partitioning mapping computer logic graphs 
ieee trans 
computers dec 
saab rao 
combinatorial optimization stochastic evolution 
ieee transactions cad cad apr 
villa brayton sangiovanni vincentelli 
framework satisfying input output encoding constraints 
proceedings acm ieee design automation conference pages 
samal 
parallel split level relaxation 
phd thesis dept computer science univ utah aug 
samal henderson 
performance arc consistency algorithms cray 
technical report uucs tr dept computer science univ utah july 
samal henderson 
parallel consistent labeling algorithms 
international journal parallel programming 
schaefer 
complexity satisfiability problems 
proceedings th acm symposium theory computing pages 
schiele 
improved compaction minimized length wires 
proc 
th acm ieee design automation conference pages 
jun gu paul purdom john franco benjamin wah 
solving satisfiability steps 
lecture notes computer science pages 

pure literal lookahead satisfiability algorithm 
proc 
workshop satisfiability universit studi siena italy pages 
schlipf franco swaminathan 
finding solutions extended horn formulas 
information processing letters pages 

statistical mechanics algorithm monte carlo optimization 
physics today 
schwarz spector 
synchronizing shared types 
acm trans 
computer systems aug 

note dowling gallier top algorithm propositional horn satisfiability 
journal logic programming pages 
sangiovanni vincentelli 
placement routing package 
proc 
custom integrated circuit conf may 
selman 
private communications aug 
selman levesque mitchell :10.1.1.34.6853
new method solving hard satisfiability problems 
proceedings aaai pages jul 
selman kautz 
domain independent extensions gsat solving large structured satisfiability problems 
proc 
th int joint conf 
artificial intelligence pages 
selman kautz cohen 
local search strategies satisfiability testing 
dimacs series volume clique graph coloring satisfiability second dimacs implementation challenge 
american mathematical society pp 

selman kautz cohen 
noise strategies improving local search 
proc 
th national conf 
artificial intelligence pages seattle july 
selman private communication 
singh lavagno moon stephan brayton sangiovanni vincentelli 
sis system sequential circuit synthesis 
technical report ucb erl dept eecs univ california berkeley may 

computational structure propositional calculus 
proceedings ijcai pages 

shi 
karmarkar integer programming 
coal bulletin mathematical programming society 
shin sangiovanni vincentelli sequin 
dimensional compaction zero refining 
proc 
rd acm ieee design automation conference pages jun 
shin 
chen 
number acceptable task assignments distributed computing systems 
ieee trans 
computers jan 
siegel 
representation utilization de la en calcul 
phd thesis university aix marseille ii 
simon 
line cursive word recognition 
proceedings ieee jul 
sosic gu 
quick queen search vax machines 
cs ai course project winter quarter feb 
sosic gu 
search queens 
technical report uucs tr dept computer science univ utah feb 
sosic gu 
polynomial time algorithm queens problem 
sigart bulletin aug acm press 
sosic gu 
fast search algorithms queens problem 
ieee trans 
systems man cybernetics smc nov dec 
sosic gu 
queens minute 
sigart bulletin apr acm press 
sosic gu 
parallel local search algorithm satisfiability sat problem 
submitted publication 
sosic gu 
parallel local search algorithm queen problem 
submitted publication 
algorithms satisfiability sat problem survey sosic gu 
efficient local search conflict minimization 
ieee trans 
knowledge data engineering oct 
sosic gu johnson 
unison algorithm fast evaluation boolean expressions 
accepted publication communications acm 
acm transactions design automation electronic systems oct 
sosic gu johnson 
universal boolean evaluator 
ieee trans 
computers accepted publication 

circuit layout 
proceedings ieee pages oct 

personal communication 

stallman sussman 
forward reasoning dependency directed backtracking 
artificial intelligence 
stankovic ramamritham cheng 
evaluation bidding algorithm hard real time distributed systems 
ieee trans 
computers dec 
stankovic 
real time computing systems generation 
manuscript 
feb 
sterling shapiro 
art prolog advanced programming techniques 
mit press cambridge massachusetts 
stone 
average complexity depth search backtracking cutoff 
ibm res 
develop may 
stone stone 
efficient search techniques empirical study queens problem 
ibm res 
develop july 
suen mori 
automatic recognition hand printed characters state art 
proceedings ieee apr 
rosen 
analytical approach floorplan design optimization 
ieee trans 
cad june 
swaminathan wagner 
arborescence realization problem 
discrete applied mathematics pages 
chiba yoshida 
programs verifying circuit connectivity mos vlsi artwork 
proc 
th acm ieee design automation conference pages 
boolean differential calculus application switching theory ieee trans 
computers 
tokuda wang 
implementation time driven scheduler realtime operating systems 
proc 
real time systems symposium dec 
torn 
global optimization 
springer verlag 
ruiz ortega 
solution switching equations tabular algebra 
ieee trans 
computers may 

alpha balanced graphs matrices gf representability matroids 
journal combinatorial theory pages 

monotone decomposition matrices 
technical report university texas dallas 


polynomial algorithms problems systems 
rd international symposium ai mathematics jan 

preparation expected 
effective logic computation 
tseitin 
complexity derivations propositional calculus 
structures constructive mathematics mathematical logic part ii ed pages 

turner 
computer perception curved objects television camera 
phd thesis univ edinburgh 
tygar 
efficient netlist comparison hierarchy randomization 
proc 
nd acm ieee design automation conference pages 
tyler 
parallel computer architectures problem solving strategies consistent labeling problem 
master thesis dept elec 
engg virginia 
inst 
state univ blacksburg virginia oct 
ullman 
principles database systems 
computer science press rockville 
ullman 
algorithm subgraph isomorphism 
acm jan 
ullman 
binary gram technique automatic correction substitution deletion insertion reversal errors words 
computer journal feb 
jun gu paul purdom john franco benjamin wah urban delcambre 
constraint analysis design process specifying operations objects 
ieee trans 
knowledge data engineering dec 
urquhart 
hard examples resolution 
acm 
urquhart 
complexity gentzen systems propositional logic 
theoretical computer science 
urquhart 
relative complexity resolution cut free gentzen systems 
annals mathematics artificial intelligence 
urquhart 
complexity propositional proofs 
bulletin symbolic logic 

response explicit solutions queens problem 
sigart bulletin aug acm press 
van der 
compaction hierarchical cells minimum maximum compaction constraints 
proc 
int symposium circuits systems pages 
goossens de man optimized synthesis asynchronous control circuits graph theoretic specifications 
ieee trans 
cad nov 
lin goossens de man generalized state assignment theory transformations signal transition graphs 
proc 
iccad pages 
lin goossens de man generalized state assignment theory transformations signal transition graphs 
vlsi signal processing 
press 
wah li yu 
multiprocessing combinatorial search problems 
ieee computer june 
tutorial computers artificial intelligence applications ed 
wah ieee computer society pp 

wah li 
computers artificial intelligence applications 
ieee computer society press washington 
wah editor 
new computers artificial intelligence processing 
ieee computer volume number 
ieee computer society press 
wah 
li 
computers symbolic processing 
proceedings ieee apr 
wah li yu 
multiprocessing combinatorial search problems 
kanal kumar gopalakrishnan editors parallel algorithms machine intelligence pattern recognition pages 
springer verlag new york ny 
wah 
chu 
combinatorial search algorithms meta control modeling implementations 
int artificial intelligence tools september 
wah shang 
comparison class ida search algorithms 
int artificial intelligence tools october 
wah shang 
discrete lagrangian global search method solving satisfiability problems 
ding zhu du jun gu panos pardalos editors proc 
dimacs workshop satisfiability problem theory applications 
american mathematical society march 
wah yu 
stochastic modeling branch bound algorithms search 
trans 
software engineering se september 
wah 
chang 
trace methods solving nonlinear global optimization satisfiability problems 
global optimization 
submitted july accepted appear 
waltz 
descriptions drawings scenes shadows 
technical report ai mit nov 
waltz 
understanding line drawings scenes shadows 
winston psychology computer vision chapter pages 
mcgraw hill book new york 
wang gu henderson 
pipelined architecture parallel image relaxation operations 
ieee trans 
circuits systems cas nov 
algorithms satisfiability sat problem survey wang gu smith 
regular layout concurrent discrete relaxation computation 
proceedings ieee international cas symposium pages may 
wang 
adaptive local search algorithm channel assignment problem 
ieee trans 
vehicular technology vol 
pp 
aug 
wang 
structured partitioning channel assignment problem 
ieee trans 
vehicular technology 
wells 
elements combinatorial computing 
pergamon press oxford 
williams 
linear integer programming applied propositional calculus 
systems research information sciences 
winston 
artificial intelligence 
addison wesley reading 
chamberlain franklin 
parallel simulated annealing speculative computation 
ieee trans 
parallel distributed systems oct 
wos robinson carson 
efficiency completeness set support strategy 
journal acm 
wu tang 
solving satisfiability problem randomized approach 
information processing letters 
young fu editors 
handbook pattern recognition image processing 
academic press orlando 
yu 
efficient combinatorial search algorithm 
phd thesis school electrical engineering purdue university west lafayette dec 
yu wah 
stochastic modeling branch bound algorithms search 
ieee trans 
software engineering sept 
yu wah 
efficient branch bound algorithms level memory system 
ieee trans 
software engineering sept 
zabih mcallester 
rearrangement search strategy determining propositional satisfiability 
proceedings aaai pages 

graph isomorphism problem 
soviet mathematics 
zhang 
lagrange programming neural networks 
ieee transactions circuits systems ii analog digital signal processing 
zhou 
trace driven simulation study dynamic load balancing 
ieee trans 
software engineering se sept 
zucker hummel rosenfeld 
application relaxation labeling line curve enhancement 
ieee trans 
computers 
dept electrical computer engineering univ calgary calgary alberta canada mail address gu ucalgary ca dimacs rutgers edu dept computer science indiana university bloomington indiana mail address cs indiana edu computer science department university cincinnati cincinnati oh mail address john franco uc edu dept electrical computer engineering univ illinois urbanachampaign urbana il mail address wah uiuc edu 
