constructive lattice theory roland backhouse department mathematics computing science eindhoven university technology box mb eindhoven netherlands 
win tue nl october notion simulation datatype defined constructive preorder 
calculus datatype simulation developed formulating constructive versions fixed point theorems lattice theory 
calculus applied construction isomorphisms classes datatypes 
particular constructive adaptations theorems lattice theory closure operators shown yield simulations isomorphisms monad structures constructive adaptations theorems regular algebra shown yield isomorphisms list structures 
question respectable theory datatypes provide immediate answers datatypes isomorphic entirely equivalent modulo implementation details 
subsidiary question datatype simulates 
second question interest right important answering question isomorphism frequently reduced mutual simulation 
formulates number algebraic laws construction simulations isomorphisms datatypes applies laws construction isomorphisms 
isomorphisms construct monad simulation theorem monad decomposition theorem 
general theorems construct isomorphisms monads 
specific isomorphisms construct list decomposition list leapfrog 
list decomposition expresses elementary isomorphism list structures instance solution called lines problem 
list leapfrog similar elementary interpretation 
surprisingly unable find mention monad decomposition theorem literature articles texts category theory lattice theory theorem known central importance properly recognised 
theorems invented process studied theorems lattice theory fixed points closure operators view theorems adapted constructive theorems map relators monads theory 
confidence prove fruitful process came idea category theory equals constructive lattice theory 
idea new 
lambek began article sentence classical results lattices provide fruitful source inspiration discoveries categories view fact partially ordered set may regarded category map objects 
scott clear progression lattice theory category theory smyth plotkin acknowledge known analogy partial orders categories basis generalisation solution fixed point equations construction initial fixed points 
textbook rydeheard burstall hand idea category theory constructive explicit theme link lattice theory 
pratt observed relationship curry howard isomorphism propositions types known focal point constructive type theory residuated lattices 
outline view datatypes specifically relators calculus constructively monotonic functions 
simulation relation constructive preorder datatypes constructively reflexive constructively transitive constructively monotonic respect function composition 
constructive mean order show datatype simulates necessary exhibit witness simulation program allows computations defined datatype replaced computations 
note simulation relation anti symmetric datatypes simulate mean isomorphic witnesses inverse case 
witnesses simulations natural transformations sense category theory 
calculate significant number non trivial isomorphisms classes datatypes order substantiate ideas 
original inspiration examples discuss came regular algebra algebra regular languages 
principal idea analogy curry howard isomorphism propositions types isomorphism regular algebra theory lists 
example possible augment regular algebra proof identity theta theta construction bijection maps pair consisting list single value type elements list pair consisting single value list case non empty list returned value element list returned list list element removed value appended list 
pair example mapped pair 
construction programs lists witness identities regular algebra difficult task 
challenge develop theory clearly links activities proof regular algebra construction programs lists 
step meet challenge develop novel theory datatypes purposefully designed expedite program calculation 
called spec calculus forms basis demonstrated calculations follow 
design programs developed spec calculus typically compact programs written conventional programming languages 
emphasis spec calculus recognition concepts programming constructs relevant broad class problems involving non trivial datatypes 
consequence programs derived spec calculus directly translated programs existing programming language 
fortunately possible transform spec calculus expressions derive equal expressions implementable unfortunately process involves long arduous calculations 
purpose go problems depth discuss issue section monad decomposition convince reader constructing real programs 
current entirely self contained 
summary main elements spec calculus section suffice wishing check detail proofs 
may various articles published date calculus comprehensive 
exploit theory developed 
begins properly section motivating definitions notions simulation isomorphism constructive preorders presenting specific definitions spec calculus 
followed brief summary fixed point theorems lattice theory 
part discussed detail part 
theorems constructive applications 
reading constructive calculations reader advised take stated theorems develop non constructive proof lattice theoretic laws 
calculations initially designed helps considerably understand structure proofs 
spec calculus relators spec calculus point free incomplete axiomatisation calculus relations augmented axioms asserting existence unit type disjoint sum operator non categorical cartesian product operator theta 
words spec calculus algebra model class binary relations universe non empty closed tagging operators inl inject left inr inject right pair formation 
specific details calculus essential current discussion follows 
lots inessential current discussion details omitted seen complete summary calculus 
carrier set calculus forms complete universally distributive lattice ordered relation objects carrier set called specs abbreviation specifications 
supremum operator lattice denoted infimum operator top element lattice denoted 
bottom element 
prefer symbols conventional hand written documents easily confused letter carrier set includes distinguished element different 

interpretations 
relational model universal relation relation holding pairs empty relation identity relation respectively 
specs closed unary operator written postfix argument binary operator ffi interpretation relational converse operator interpretation ffi relational composition 
set specs forms monoid ffi unit element 
composition distributes universally supremum operator 
self inverse lattice isomorphism respects distributes contravariantly ffi operators ffi related rule called dedekind rule modular identity freyd scedrov 
axiomatise disjoint sum specs 
postulated 
interpretations polymorphic tagging functions inject left inject right respectively 
binary operators defined equations ffi ffi 
ffi ffi 
ffi ffi ffi ffi properties axiomatised laws ffi ffi ffi ffi ffi category theory texts written 
standard notation aware dual disjoint sum cartesian product axiomatised postulating existence specs ae 
interpretations projection functions mapping pair left component right component respectively 
binary operators theta defined equations ffi ae ffi ffi ffi ae theta ffi ffi ae ffi ffi ae properties axiomatised laws ffi ae ffi ae ffi ffi ffi ffi ffi ae standard notation category theory texts analogous operation viz 
hr si far know standard notation unary relator definition function specs specs satisfying properties interpretation mean interpretation relational model ffi ffi relators higher arity binary ternary obey similar laws obtained replacing constants variables vectors appropriate arity lifting operators elementwise operate vectors 
spec called monotype 
freyd scedrov term 
spec called imp ffi imp imp bijection imp imp 
freyd scedrov term simple imp isomorphism bijection 
frequently property ffi monotypes easy show relators preserve monotypes imps imps bijections 
monotypes may interpreted sets imps imps partial functions functions 
interpret imps functions imps functions depends choose view input relation left right component pair 
monotype constant function 
relator 
disjoint sum cartesian product theta relators 
identity function trivially relator 
fixing argument ary relator monotype yields ary relator functional composition relators yields relator 
fixed point unary relator monotype phi relator function 

phi ary relator ranges ary vectors specs specs 
fixed points exist specs assumed form complete lattice 
derived operators play fundamental role calculus left right domain operators denoted postfix symbols respectively 
characterising properties ffi 
ffi 
left domain operator corresponds freyd scedrov dom operator 
monotypes 

confused 
important property domain operators commute relators 
relators specs axioms derived properties 
programming constructs play fundamental role calculus socalled catamorphisms anamorphisms spec defined solution equation ffi bd ce defined solution equation ffi function 
total function specs specs 
range set catamorphisms 
function 
bd ce total function specs specs range set anamorphisms 
relation bd ce variety programming applications catamorphisms anamorphisms setting calculus total functions reader referred 
brief summary notational conventions necessary 
general rule prefix postfix operators highest operator precedence 
function application denoted infix dot function composition raised infix dot delta metalanguage predicate calculus standard notational conventions 
operators predicate calculus lower precedence operators spec calculus 
composition operator spec calculus lower precedence binary relators precedence 
example ffi parsed ffi 
effort put spacing terms formulae eye sees intended syntactic structure 
brevity square brackets denote abstraction respect spec valued variables formula 
example write theta denote relator 
theta 
enclosed formula contains free variable square bracket notation denotes abstraction alphabetic order 
thetas denotes binary relator 

thetas different thetar denotes relator 

thetar 
notation introduced brevity calculations functions relators take outward appearance calculations elements regular algebra 
simulation constructive preorder lattice theory theory preorders 
want view simulations constructive preorders datatypes obeying coherent composition rules 
datatypes simulates program fl henceforth called witness enables transform computations involving structures computations involving structures 
furthermore simulates relation constructively reflexive transitive monotonic 
constructively reflexive just means datatype simulate 
constructively transitive means datatype simulates datatype datatype simulates datatype simulate witness formed composition witnesses 
constructively monotonic means datatype simulates datatype datatype simulates datatype delta simulate delta delta denotes composition functions 
witness formed composition witnesses 
ways composing witnesses borrowing terminology category theory call horizontal vertical composition witnesses 
final condition demand simulations different ways composing coherent 
boils requirements witness reflexivity unit horizontal composition horizontal vertical composition associative horizontal vertical composition witnesses satisfy called interchange law 
terms interchange law coherent borrowed category theory 
see 
explain second requirements suppose simulations transitivity ways arrive 
compose simulations compose result third compose simulations compose result simulation 
associativity horizontal composition guarantees order irrelevant 
similar argument holds vertical composition 
suppose simulations monotonicity ways arrive delta delta delta delta involves arguing delta delta delta delta delta delta delta delta 
note 
coherence requirement vertical composition witnesses associative guarantees witnesses equal 
interchange law horizontal vertical composition demanded requirement composition witnesses simulations form witness simulation delta delta independent order composition 
coherence requirements imply unicity witnesses 
guarantee design choice construction witnesses intrinsic particular datatypes involved dependent order application basic composition primitives 
adopting view theory datatypes means theory subsumes lattice theory particular case witnesses unique interest 
importantly means lattice theory lambek words source inspiration discoveries simulations datatypes 
possibilities notion simulation spec calculus 
concreteness assume definition 
definition natural simulation relators fl spec 
say fl witnesses fact simulates write fl iff fl ffi fl fl ffi fl note immediate fl ffi fl fl note stipulate fl imp imp 
cases easy determine spec imp imp adding clause definition little value 
definition natural isomorphism relators fl spec 
say fl witnesses fact isomorphic write fl iff fl fl fl bijection 
shall say isomorphic fl exists fl note definition isomorphism implies equivalent mutual simulation simulation required constructively anti symmetric 
theorem relations constructive relators 
specifically constructively reflexive relators constructively transitive specs fl ffi relators fl ffi fl ffi ffi composition relators constructively monotonic arguments respect relations specs fl ffi relators fl ffi fl ffi ffi delta delta proof theorem straightforward omitted 
proof hints adjective constructively omitted 
relation relators allows useful decomposition proof obligations reasoning simulations isomorphisms 
relation important spite constructive preorder composition witnesses relation general coherent 
composition simulations isomorphisms illustration sort argument needed verify claim suppose simulations isomorphisms ff fi fl combine different ways form witness delta delta ff fi fl transitivity ff ffi fi fl monotonicity ff ffi fi ffi fl delta delta second ff fi fl monotonicity reflexivity ff ffi delta delta fi ffi delta delta fl transitivity monotonicity ff ffi ffi fi ffi delta delta ffi fl delta delta transitivity ff ffi ffi fi ffi ffi ffi fl delta delta witnesses equal verified simple calculation 
ff ffi ffi fi ffi ffi ffi fl associativity composition ff ffi ffi fi ffi ffi ffi fl ffl fi associativity composition ff ffi fi ffi ffi ffi ffi fl properties monotypes relators ff ffi fi ffi ffi fl relator ffl fl ffi fl fl ff ffi fi ffi fl definitions simulates isomorphic stated form appropriate unary relators usual practice intend definitions apply relators higher arity 
fact definitions need unary relators higher order relators reduce notions conjunction conditions stated terms unary relators 
illustrate definition isomorphism binary relators 
definition phi omega binary relators fl spec 
say fl witnesses fact phi isomorphic omega write fl phi omega iff fl phi omega fl phii omega general pair ary relators take pairs unary relators formed fixing argument witness simultaneously witness isomorphism pairs 
easy verify fl phi omega equivalent conditions phis ffi fl fl ffi omega fl phii fl omega conclude section useful property disjoint sum 
fact property instance constructive galois connection order focus discussion constructive fixed point theorems shall amplify 
theorem ff fi fl specs relators 
fl ffi 
fl ffi fl ff fi ff fi fixed point theorems section contains short review lattice theoretic fixed point theorems intend adapt constructive fixed point theorems 
helpful reader fully conversant theorems constructive forms complex easy understand 
topic constructive theorems summary brief 
section includes list properties catamorphisms anamorphisms corollaries fixed point theorems stated proof 
reader familiar theorems may find instructive undertake exercise proving selection 
small calculus undoubtedly important fixed point theorem due knaster tarski 
theorem states monotonic complete lattice fixed point denoted characterised properties 
starting knaster tarski theorem develop quite rich fixed point calculus 
rules calculus particularly important 
rolling rule states monotonic functions delta delta course domain equal range vice versa domains form complete lattices 
details omitted summary 
fusion law states monotonic functions universally junctive functions functions having upper galois adjoint delta delta diagonal rule states monotonic binary operators phi 
phix 

phiy known existence fixed points guaranteed weaker context cpo complete lattice 
fusion law remains valid requirement weakened strict continuous 
known admit having ignorant fact computing texts usually required functions continuous monotonicity sufficient 
see discussion constructive fusion law state rule form 
fusion law remains valid occurrences replaced current version law 
applications catamorphisms anamorphisms exercises laws occur forthcoming calculations 
recall definition 
ffi bd ce relators specs instance rolling rule catamorphism rolling rule delta delta instances fusion law 
examples relators specs bd ce 
ffi relators specs bd ce fact converse universally junctive 
ffi bd ce 
ffi ffi fact ffi universally junctive 
binary relators phi 
phi phii relator 
relators specs ffi ffi binary relators phi specs phi ffi phi phii phi ffi phii corollary 
binary relators phi specs monotypes phi ffi phi phii phi example diagonal rule combination binary relators phi specs phi phi phix recall brackets denote abstraction respect free variables formula 
binary operators suppose phi omega monotonic binary operators lattice element 
sections phi omega monotonic functions course rules stated subsection instantiated functions replacing function variables 
example instantiating fusion law phi omega respectively obtain universally junctive functions phi omega phi omega lost instantiation recovered follows functions define binary operators phi omega phiy omega instantiate definitions 
laws formally equivalent 
turns constructive formulations laws equivalent 
full generality constructive case obtained going step 
specifically law generalise obtained instantiating function section ffx ff monotonic binary function 
assuming ffx universally junctive phi omega ffx phi omega ffx true knaster tarski theorem 
adapting adapt equivalent phi phix closure operators closure operators form significant class monotonic endofunctions 
monotonic complete lattice closure operator denoted defined 
denotes supremum operator lattice 
properties closure operators single closure decomposition rule monotonic endofunctions ftg delta delta special attention 
constructive closure operators monads called triples 
section show relator defines monad prove monad simulation theorem expressing minimality property monads 
discuss detail monad decomposition theorem relationship spec calculus witnesses programs written functional programming language witness decomposition 
constructive fixed point theorems ready constructive fixed point theorems 
section constructive version 
special cases consider constructive form 
subsequently formulate prove constructive form 
special cases rule 
consider rolling diagonal rules 
unnecessary formulate constructive versions rules spec calculus explain versions necessary systems 
constructive knaster tarski theorem assume phi binary relator 
function defined 
phix relator 
see 
constructive knaster tarski theorem gives condition simulation relator constructed 
theorem constructive knaster tarski specs fl relators binary relators phi phi fl 
phis fl phi note 
phis denotes unary relator 

phis 
see discussion notational convention 
relator phi occasionally denoted ii phi ii denoting identity relator 
prove theorem check conditions naturality phi fl totality phi 
naturality property property independently theorem stated lemma 
lemma specs fl binary relators phi phi fl 
phix fl proof phi fl 
phix definition ffi phi fl phi fl ffi 
phix map fusion 
phix phi phii ffi phi fl phi fl ffi phii catamorphism fusion ffi fl fl ffi phii ffi phi relator ffi fl fl ffi definition fl note lemma constructive knaster tarski theorem constructive preorder compare lemma omitting witnesses phi fl fl 
lemma specs fl phi fl phi fl ii phi proof phi fl phi totality catamorphisms fl phi fl calculus fl phi fl definition fl ii phi combining lemmas definition simulation obtain constructive knaster tarski theorem phi fl 
phis definition simulation phi fl 
phis phi fl 
phis lemmas phi constructive knaster tarski theorem applied functions arbitrary specs instance reynolds abstraction theorem 
fixed point constructions general categorical framework considered ad amek schmidt plotkin 
added information predicted reynolds theorem naturality construction called theorem free wadler 
fact definition catamorphism extended relational framework theorem remains valid framework author workshop main inspiration development spec calculus 
return matter concluding section 
constructive fusion law establish constructive form 
lemma deem call theorem expect widely applicable just theorem follows 
theorem relators specs fl phi fl phi fl ii fl phi reductive 
proof assume fl ii fl bijection assumption catamorphism construction preserves bijections follows phi fl bijection 
constructive knaster tarski theorem theorem suffices prove phi fl surjective 
phi fl fl imp phi fl ffi phi fl phi fl ffi phi fl solves equation fl ffi phix ffi fl fl phi reductive 
fl ffi phi ffi fl fl ii true theorem constructive fusion suppose phi omega binary relators 
suppose ff binary relator ffi universally junctive 
phi fl 
omega ff 
phis fl omega ffr phi proof assume fl omega ffr phi noting fl omega ffr phi binary relators definition fl omega ffi phi fl omega ffr phi definition fl ffi delta omega phi delta ffi fl omega ffr phi try find candidate isomorphism theorem 
specs fi phi fl 
omega ff 
phis theorem fi 
omega ff phi 
omega ff fi phi reductive phi fl phi fi proof splits parts 
construct isomorphism fi required type 
verify fi phi reductive 
verify phi fl phi fi 
brevity introduce notation 
omega 
requirement translates construction fi fi ii phi achieved restricting left domain fl iffi specifically iffi ffi fl ii phi proof straightforward 
verify conditions iffi ffi fl iffi ffi fl fl ffi phi iffi ffi fl phi ffi left reader 
second part show iffi ffi fl phi reductive 
prove slightly general result universally junctive relators specs ffi relators ffi delta omega delta ffi ffi reductive 
consequence translation theorem fact omega reductive 
substitution omega statement theorem 
combining initial observation specifically fl omega ffr phi fl ffi delta omega phi delta ffi substitutions ffi phi obtain iffi ffi fl phi reductive required 
third final step verify phi fl phi ff ffi fl follows phi fl phi ff ffi fl domain trading ff fl ffi phi ff fl ffi delta omega phi delta ffi ff omega ffi ffi fl omega domains true corollary suppose universally junctive relator 
phi fl 
omega 
phis fl omega phi proof define binary relator ff relator obvious 
obvious ffi universally junctive 
remains instantiate theorem definition ff 
identity relator trivially universally junctive 
special case corollary corollary phi fl 
omega 
phis fl omega phi true versus isomorphic fixed points spec calculus fixed points true fixed points isomorphism case formal systems category theory equivalents 
major advantages economy calculation advantages exploit extensively 
main advantage lattice theoretic fixed point rules necessary give constructive forms just laws calculus fixed point equation rolling rule diagonal rule remain equations rewritten isomorphisms 
systems said case 
working category formal systems may find necessary identify prove constructive forms 
shouldn difficult 
simple example helps illustrate 
consider datatype cons list 
spec calculus defined relator 
thetax application rolling rule instantiated function theta instantiated function theta 
theta 
equality spec calculus isomorphism conventional programming languages 
programming language ml gofer haskell encode datatypes aid datatype follows data nill cons data nils id data pair relator 

theta corresponds datatype relator corresponds datatype datatypes 
theta unequal freely interchanged program 
necessary languages mentioned write functions mapping values type values type specifically follows tot pair nill nils cons id tot pair nils nill id uncurry cons note functions swap labels specifically replaced pair vice versa nill replaced nils vice versa cons id vice versa 
identity repeatedly 
similar identities isomorphisms conventional programming languages reader may experience problems implementing complex isomorphisms derive 
bear mind appeal fixed point equation rolling rule diagonal rule additional bijection constructed 
aside shortly preparation draft july lambert meertens erik meijer filled gaps category theory formalisms 
meertens considered rolling rule 
outline gives construction 
functors gf respectively fg fg initial gf algebra respectively initial fg algebra 
juxtaposition locally denote composition functors 
gf initial fg algebra fg gf isomorphism gf fg fg fg algebra ffi gf unique fg algebra morphism gf particular fg ffi gf fg inverse fg gf general construction exemplified functions tot 
meijer states rolling rule diagonal rule fusion context cpo case diagonal rule state construct witness 
constructive fusion rule appears stronger stated demands combination strictness continuity demanded universal 
difference positively finite 
give applications fusion rule unable discover applications additional strength rule needed 
aside 
monads illustration constructive fixed point theorems discuss section number theorems monads 
properties lists discussed coming sections calculations simpler 
sets applications independent reader wishing skip section may problem 
constructive closure operators category theory closure operators cited instances monads 
want take opposite view monads constructive closure operators 
definition closure operator monotonic preorder reflexive idempotent 
stab definition monad relator constructively reflexive constructively idempotent 
monad relator exist specs unit mul unit ii mul delta category theory symbols unit mul 
cause confusion fixed point operator 
requirements add coherence conditions motivated follows 
note combination postulates monotonicity composition means monad simulates definition ii delta 
example calculation delta delta transitivity delta delta delta delta monotonicity delta delta lifted construction simulation follows ff delta delta ffl ff fi ffi fl fi delta fl delta delta delta ffl fl ffi ffi fi delta ffi delta assuming mul ffi mul ffi delta delta simplifying mul ffi ffi mul mul ffi mul mul ffi mul delta delta way construct witness 
second step delta delta parsed delta delta order apply monotonicity rule 
parsed delta delta deduced mul ffi mul delta delta similarly obvious ways constructing simulation 
witnesses simulation 
second ii delta mul ffi unit witnesses simulation 
third delta ii mul ffi unit witnesses simulation 
order guarantee unicity simulations coherence conditions called associative unit laws added definition 
full definition monad definition monad monad triple unit mul relator unit mul specs unit ii mul delta mul ffi mul mul ffi mul mul ffi unit mul ffi unit property called associative law unit law 
having identified class relators test undergo closed natural isomorphisms 
monads theorem suppose unit mul monad fl bijection fl fl fl ffi unit fl ffi mul ffi fl ffi fl monad fl fl ffi ffi fl proof definition fl fl fl fl fl fl construction unit straightforward application transitivity 
construction multiplier obtained adding witnesses calculation fl fl delta fl transitivity monotonicity fl delta fl transitivity fl delta fl leads witness fl ffi mul ffi fl ffi fl fl equal fl ffi mul ffi fl ffi fl verification tedious straightforward 
class monads central theorem theory closure operators complete lattice complete lattice monotonic endofunctions complete lattice closure operators ordering functions usual pointwise extension ordering elements function defined 
total surjective function 
lower galois adjoint function embedding elements fact 
notation introduced author denote function order link kleene star sections 
point closure star properties common kleene star 
beware properties kleene star enjoyed closure star 
instance case general delta delta particular closure star satisfies decomposition property ftg delta delta section define function relators analogy definition monotonic functions 
show monad simulation theorem relators monad 
furthermore subsection establish constructive closure decomposition theorem monad decomposition theorem 
arbitrary relator 
define unary relator 
define addition specs 
ffi 
ffi ffi examples relators defined way discussed combination examples monad decomposition theorem subsection 
goal section establish relator furnished unit multiplier observe witness simulations ii delta appropriate choice unit 
see construct multiplier apply constructive knaster tarski theorem order observe general monad simulation theorem define binary relator abbreviate theorem monad simulation relators specs delta delta proof delta delta 

constructive knaster tarski phi defined phix 
definition delta 
complete proof establish 
follows 

ffi 

ffi ffl delta definition aid monad simulation theorem construct multiplier verify monad 
theorem triple monad 
proof construct witness simulation delta ff delta monad simulation ffl ff fi fi delta ffl fi fl theorem fl delta fl verify coherence conditions 
show verify associative law order demonstrate technique leave unit law reader 
ffi map fusion ffi sum fusion ffi ffi ffi ffi catamorphism fusion ffi ffi sum fusion sum cancellation ffi ffi ffi ffi domain catamorphisms computation rules true monotype monotype referred free algebra generated 
initial algebra isomorphic 
compare 
lattice theory 
decomposition theorem position prove constructive closure decomposition theorem words monad decomposition theorem 
section give examples 
fact monad decomposition theorem straightforward proof spec calculus demonstrate 
unfortunately proof rejected functional programmers reasons explained proof 
section outline complicated proof theorem acceptable users conventional programming languages 
theorem monad decomposition relators delta delta proof observe equality delta delta 
specs 
delta delta function composition definition 
delta rolling rule 

definition 

diagonal rule 
proof decomposition theorem straightforward application theorem 
denote isomorphism ternary relators ffi mentioned theorem domain trading 
delta delta inverse 
delta delta alternative implementation proof just monad decomposition theorem completely equational concise leads concise program witness isomorphism inverse 
unfortunately existing functional programming language accept witness typing grounds 
certainly inverse rejected grounds 
alternative calculation lead witnesses acceptable conventional compilers construct simulations type delta delta type delta delta show inverses 
construction simulations difficult instructive basic tool monad simulation theorem straightforward exercise familiar regular algebra trained computing scientists 
proving witnesses inverses arduous non trivial task 
see details 
wish carry exercise program solution favourite programming language solution 
brevity define relator delta notations defined relator 
witness simulation type delta delta ffi ffi inverse type delta delta defined ffi ffi 
ffi ffi examples section give examples free monads application monad decomposition theorem 
simplest examples obtained constant relator 
suppose monotype denote relator 
ii delta ii delta delta ii 
particular ii 
ii 
isomorphic ii follows identity relator monad expected 
unit 
multiplier wadler defines monads terms unit multiplier relator terms unit function called bind 
function explained wadler easily defined terms unit multiplier 
specifically arbitrary monad bind mul ffi particular bind ffi example illustrate monad decomposition theorem 
monad decomposition delta delta delta delta ii delta ii example known specific form appear known instance decomposition theorem 
specific form take squaring relator 
define thetar take unit type 
denote theorem says 
equivalent theorem lattice level transitive closure om om om om om element type relation denotes identity relation denotes union operator reflexive transitive closure relation wadler considers example instantiated exception aware relevance monad decomposition 
second example monad decomposition theorem follows 
suppose define datatypes follows data om data data data oq dutch names 
terms spec calculus sq cube cube sq delta cube thetar thetar sq thetar monad decomposition theorem delta element type depicted fig 
corresponding element type delta shown fig 
construction tree straightforward replace constructor om oq constructor constructor applications lists section consider applications constructive fixed point theorems specific lists 
classes isomorphisms list isomorphisms special cases discussed subsequent sections 
oq oq oq oq oq element type ffl lists defined various isomorphic ways 
examples follow cons lists 
assume relator defined 
thetax unfolding fixed point operator theta 
ffi ffi theta letting nil denote 
ffi cons denote ffi theta nil cons words datatype list constructors nil cons 
category systems equality isomorphism 
constructors polymorphic sense nil cons theta applications knowledge need polynomial relators thetai theta universally junctive isomorphism obey usual arithmetic laws 
specifically assume existence natural isomorphisms thetar theta proass thetas thetat theta thetat rdist thetat thetat thetat theta thetar thetas existence isomorphisms course known 
details construct spec calculus see 
note calculations assume theta commutative 
regular algebra case order properly model theory lists vital 
note addition idempotent case regular algebra 
identities regular algebra rely property constructively true 
example operator idempotent regular algebra case datatype list lists isomorphic datatype list example chosen simplicity fundamental examples 
subsequent examples employ notation witnesses isomorphisms included hints marked bullet ffl 
specifically proof step form ffl ff hint short ff hint theorem list fusion theta 
thetax proof construct witness ff follows ff theta 
thetax definition ff 
thetax theta 
thetax constructive fusion theorem ffl ff 
thetax fi relators phi omega ff theorem instantiated ternary relators viewed binary relators argument pair specs 
specifically substitute omega thetax phix thetax xff thetas fi thetax thetas theta thetas arithmetic fi rdist ffi proass constructed 
thetax rdist ffi proass theta 
thetax second example consider problem constructing function joins appends cons lists 
formulated terms simulations problem show datatype list simulates datatype pair lists 
theorem list append theta proof list fusion monotonicity bd 
thetax proass ffi rdist ce 
thetax theta transitivity suffices construct witness simulation 
thetax achieved applying constructive knaster tarski theorem 
ff 
thetax constructive knaster tarski theorem ffl ff 
thetax fi fi theta disjoint sum theorem ffl fi fl ffi fl ffi theta reflexivity lists fl ffi cons constructed 
thetax cons 
thetax composing witnesses obtain 
thetax cons ffi bd 
thetax proass ffi rdist ce theta combination illustrated catamorphism anamorphism occurs frequently dubbed hylomorphism anamorphism builds element intermediate datatype 
thetax broken catamorphism 
programmer formulated list append solution recursive equation cons ffi thetax ffi proass ffi rdist form elements intermediate datatype explicitly constructed 
reason dubbed virtual datatype 
example chosen relative difficulty practical relevance 
instance called lines problem sequence types characters delimiters non delimiters write program divide sequence possibly empty lines non delimiters separated single delimiters 
construct addition inverse program 
expressed isomorphism datatypes problem boils showing star decomposition theorem regular constructively valid 
theorem list decomposition theta theta proof theta theta definition theta 
theta thetax ffl theta 
theta theta proass corollary theta 
theta theta rolling rule 
theta thetax ffl 

thetax thetay 
thetai thetay rdist ffi proass list fusion corollary 

thetax thetay diagonal rule 
thetax thetax ffl 
thetax ffi rdist corollary 
thetax definition conclude theta 
theta theta proass ffi 

thetax thetay 
thetai thetay rdist ffi proass ffi 
thetax ffi rdist theta theta completely equational calculation direct transcription proof regular algebra identity difference addition witnesses steps isomorphism claimed 
witness complicated lead inefficient implementation 
seen failing spec calculus 
ways prove decomposition law just calculus constrains freedom constructing proofs undesirable 
important calculus embodies rules allow transform programs efficient forms 
witness list decomposition theorem simplified considerably fixed point laws calculus 
simplify middle term witness 
fusion law fuse catamorphisms 
way obtains witness 
thetax rdist ffi proass ffi proass ffi ffi rdist recursive equation corresponding catamorphism corresponds closely program programmer construct simple type arguments 
game leapfrog leapfrog rule regular algebra takes form theta thetax thetay theta 
related rule theta theta 
rule cited special case leapfrog rule obtained instantiating 
section explore general constructive leapfrog rule list leapfrog rule specific instance 
rule obtained replacing operator theta binary relator ff appropriately defining unary relator take place operator 
roughly speaking rule states leapfrog properties preserved fixed point construction 
somewhat surprisingly generalisation established recourse unit multiplication 
theorems 
subsequently prove leapfrog preservation theorem apply construction class pairs isomorphic relators pair cons list snoc list instance 
theorem suppose relator ff binary relator ffi universally junctive 
define relator 
suppose leapf ff ff bd 
ff leapf ce ff ff proof ff definition ff 
rolling rule 
ff bd 
ff leapf ce ff ff calculation definition bd 
ff leapf ce 
ff 
ff converse dual theorem phis ff omega leapf ff ff theorem unbounded number instances straightforward obviously 
content just program implementing snoc operation cons lists 
corollary theta theta proof 
thetas substitute ff theta theorem 
obtain bd 
theta fl ce theta theta fl theta thetar thetas thetar fl ffi ffi proass ffi rdist constructed isomorphism 
specifically bd 
theta ffi ffi proass ffi rdist ce theorem leapfrog preservation suppose relator ff binary relator ffi universally junctive 
define relator 
suppose ass fft rff leapf ff ff ff ff proof construct witness follows ff definition ff 
ffx ffl iff 
iff ass corollary constructive monotonicity ff 
sff rolling rule 
ff ff ff ff ffl ff ff 
iff ass ffi fi calculation constructive transitivity fi 
ff ff definition fi 
ff 
ffx ff ffl fi bd 
ff fl ce converse dual constructive fusion theorem theorem relators phi omega ff theorem instantiated ternary relators viewed binary relators 
specifically substitute phix ffx omega ff xff fl ff sff ffx ff ffl fl ff ass ffi ffi ffi ass ff constructive monotonicity transitivity ffi ff ffr ff assumption ffi leapf summarising isomorphism constructed iff 
iff ass ffi bd 
ff ff ass ffi leapf ffi ass ff ce note equal rolling rule 
ff ff ass ffi bd 
ff ff ass ffi leapf ffi ass ff ce turn solution equation ff ass ffi ffi ass ffi leapf ffi ass ff equivalent equation programmer construct type considerations 
corollary list leapfrog theta thetar thetas theta proof proof theorem substitutions ff theta leapf ffi ffi proass ffi rdist added substitution ass proass theorems case iff universally junctive 
definition relator course 
interesting case ffi iff universally junctive relators defined terms relator enjoy leapfrog property 
relationship relators 
isomorphic course 
theorem suppose relator ff binary relator ffi iff universally junctive 
suppose leapf ff ff define relators 

proof occasion obliged resort proof mutual simulation 
near hope developed theory sufficiently enable direct theorem 
note theorem isomorphism ff ff specifically bd 
ff leapf ce dually iff assumed universally junctive theorem isomorphism ff ff specifically bd 
ff leapf ce isomorphisms construct simulations show construction 
ff constructive knaster tarski theorem ff ff ffl ff fi ffi constructive monotonicity transitivity fi ff ff constructive reflexivity fi trading eliminate domain restriction obtain 
dually 
xffi show inverses 
rolling rule definition bd 
leapf ce similarly bd 
xffi leapf ce 
xffi 
calculation bd ce bd 
xffi 
leapf ce 
bd 
xffi leapf ce fokkinga theorem leapf ff ff xffi assumption naturality relators true corollary cons snoc list isomorphism defining cons lists equation clist 
thetax snoc lists equation slist 
thetar clist slist proof instantiate theorem proof corollary omitting assignment ass unnecessary 
way take opportunity expand remarks earlier sections point directions 
examples chosen appeal theoreticians programmers 
essence shown theory lists isomorphic constructive regular algebra sense familiar isomorphism propositions types 
examples chosen 
argued case central role leapfrog decomposition properties algorithm development isomorphisms simulations ones view ordinary programmer trained recognise exploit 
known equality regular expressions decidable 
effectively shown axioms regular algebra constructively true exception axiom 
axiom constructively true isomorphism replacing equality clearly false element set placed bijection element set 
raises question isomorphism datatypes defined aid unit type sum product list type decidable 
strong possibility traditional algorithm deciding equality regular expressions adapted algorithm constructing isomorphisms 
may case isomorphism tests classes context free datatypes may constructed suitable adaptation known decision procedures equality context free languages 
intentionally omitted discussion relationship properties currying functions properties residuated lattices order keep length bounds 
general discussion relationship galois connections adjunctions omitted reason 
unfortunate point view completeness readers grasped essential ideas position necessary links 
idea extending proofs lattice theory constructions category theory due lambek remarked 
process chance success predicted part reynolds abstraction theorem 
constructive knaster tarski theorem example expresses polymorphism catamorphism construction 
observation inspiration development spec calculus 
standard example applications abstraction theorem 
relationship theorems example constructive fusion theorem abstraction theorem unclear role coherence properties adequately explored 
clarification theorems lattice theory constructive undoubtedly challenging question raised 
go participated dutch specification transformation programs project members mathematics program construction group enduring teamwork 
particular go henk suggesting theorem harold help producing figures constructing program texts 
document prepared editing system 
am grateful implementors richard olaf weber creating pleasant interface 
aarts backhouse hoogendijk van der 
relational theory datatypes 
available anonymous ftp ftp win tue nl directory pub math prog construction september 
jir ad amek 
fixed point functor 
comp 
syst 
scs 
backhouse 
making formality 
eatcs bulletin june 
backhouse 
monad decomposition 
available anonymous ftp ftp win tue nl directory pub math prog construction november 
backhouse de bruin hoogendijk malcolm van der 
polynomial relators 
nivat rattray rus scollo editors proceedings nd conference algebraic methodology software technology amast pages 
springer verlag workshops computing 
backhouse de bruin malcolm van der 
relational catamorphisms 
moller editor proceedings ifip tc wg working conference constructing programs pages 
elsevier science publishers 
backhouse carr 
regular algebra applied path finding problems 
journal institute mathematics applications 
backhouse 
induction recursion datatypes 
department computing science eindhoven university technology 
available anonymous ftp ftp win tue nl directory pub math prog construction 
backhouse hoogendijk 
commuting relators 
available anonymous ftp ftp win tue nl directory pub math prog construction september 
backhouse hoogendijk 
elements relational theory datatypes 
appear 
ifip working group state art summer school island brazil january 
roland backhouse van 
calculating path algorithm 
bird morgan woodcock editors mathematics program construction 
nd international conference june july volume lecture notes computer science pages 
springer verlag 
barr wells 
toposes triples theories 
springer verlag 
bird wadler 
functional programming 
prentice hall 
conway 
regular algebra finite machines 
chapman hall london 
freyd scedrov 
categories allegories 
north holland 
hoogendijk 
relational programming laws boom hierarchy types 
bird morgan woodcock editors mathematics program construction 
nd international conference june july volume lecture notes computer science pages 
springer verlag 
extended version appear science computer programming 
hutton 
making functionality general 
functional programming glasgow workshops computing 
springer verlag 
kleene 
representation events nerve nets finite automata 
shannon mccarthy editors automata studies pages 
princeton univ press 
lambek 
fixpoint theorem complete categories 
mathematische zeitschrift 
maclane 
categories working mathematician 
springer verlag new york 
meijer fokkinga paterson 
functional programming bananas lenses envelopes barbed wire 
fpca functional programming languages computer architecture volume lncs pages 
springer verlag 
de moor swierstra 
virtual data structures 
appear 
ifip working group state art summer school island brazil january 
vaughan pratt 
action logic pure induction 
van eijck editor proc 
logics ai european workshop jelia volume pages 
springer verlag lecture notes computer science 
reynolds 
types abstraction parametric polymorphism 
mason editor ifip pages 
elsevier science publishers 

relations de galois 
bulletin de la soci math ematique de france 
rydeheard burstall 
computational category theory 
prentice hall international 
dana scott 
data types lattices 
siam computing september 
smyth plotkin 
category theoretic solution recursive domain equations 
siam journal computing 

pers types inductive types types laws 
phoenix seminar workshop declarative programming workshops computing 
springer verlag 
ed jaap van der 
relational perspective types laws 
informal workshop categories relations computer science oxford july 
wadler 
theorems free 
th symposium functional programming languages computer architecture acm london september 
wadler 
church state taming effects functional languages 
marktoberdorf summer school 

