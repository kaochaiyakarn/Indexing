trampolining architectures steven ganz indiana university trampolining architecture special case extension monad implementing multiprogramming 
trampolining architectures operating range trampolining translations 
ects architectures cumulative 
increase breadth multiprogramming facilities provided 
demonstrate potential cient implementation 
demonstrate applicability languages higherorder functions 
ganz friedman wand formalized trampolining technique multiprogramming implemented directly program transformations language rst class continuations 
trampolined style way writing programs single scheduler loop manages transfers control 
computations executed discrete steps 
performs remaining returned scheduler 
programs converted trampolined style trampolining translation similar moggi monadic translation inserts bounce forms abstractions procedure calls :10.1.1.41.840
transformed programs scheduler called trampoline 
abstractions interrupt computation preserving state 
non primitive applications delayed take place scheduler loop 
trampolined parameterized choice bounce trampoline procedures monadic operators unit extension 
nal component kleisli triple object component supported part science foundation cda 
author address department science indiana university bloomington indiana 
cs indiana edu 
supported part science foundation ccr 
author address department science indiana university bloomington indiana 
cs indiana edu 
weuse filinski notation monads :10.1.1.43.8213
daniel friedman indiana university serves type constructor thread records state computation returning value type appropriate de nitions operators type constructor comprise trampolining architecture extension special case monads 
formally de ne appropriate includes satisfaction standard monadic laws aswell preservation liveness invariant :10.1.1.43.8213
properly translated programs return control scheduler bounded amount 
way possible innite loop include loop 
creation trampolining allows creation additional operators 
trampolining architectures prior variations simple trampolining resumption monad additional architecture combination resumption list monads 
allowed implementation breakpoints engines multi thread system having computation thread performed 
allowed dynamic thread creation termination spawn die operators 
accomplished having computation yield list threads added thread 
goal show techniques generally applicable demonstrating additional architectures provide functionality expected multiprogramming system basis cient implementation 
section fully review trampolining translation previously trampolining dynamic thread creation termination 
formal trampolining translation give general previous 
sections architecture purpose adding functionality demonstrating potential improved ciency 
architectures allow synchronous communication threads recycling thread records killing thread avoidance closure 
requires revised trampolining translation lows trampolining language higher order functions 
scheme programming language conform rs 
freely square brackets place parentheses readability 
code examples self contained record system 
familiarity withthe monads functional programming useful assume category theory :10.1.1.100.9674
trampolined style trampolining transformation lambda set 
lambda set 
source language grammar possibly subscripted metavariables expressions complex expressions simple expressions variables constants respectively 
rst syntactic categories de ned grammar 
presents trampolining transformation mutually recursive translations 
original program calls user de ned procedures wrapped bounce lambda simple values tail position wrapped unit 
complex expressions occur position 
form inserted complex expression forming right hand context expression substituted hole forming body 
takes expression tail position auxiliary transformation simple expressions head position 
translation nondeterministic 
deterministic selecting order evaluation applications 
program resulting applying wrapped trampoline lambda properly executed 
call cc operator treated primitive 
derived forms letrec cond cases speci ed 
comments regarding translation provided original presentation 
unit unit lambda unit lambda set 
unit set 
set 
set 
unit bounce lambda lambda lambda set 
set 
trampolining transformation factorial example simple trampolined procedure de nition define fact lambda cond zero 
unit pred result bounce lambda fact sub unit pred result dynamic thread creation termination trampolining architecture dynamic thread creation termination expression generated evaluate list threads 
list represents computations continue result current execution including remainder result current computation appended 
way expressions spawn new threads 
convenient terminate thread just return empty list 
notion multitasking mechanism child value returned directly parent 
possible threads shared variables 
protocol completely protects threads entries thread queue currently running directly affected 
architecture de ne type constructor 
list 
unit bounce procedures correspond list injections types 
list 
list 
list respectively 
record facility 
record types done doing correspond variants threads 
record type done represents complete computation holds result value type 
record type doing represents incomplete computation holds thunk performs 
dynamic thread creation define record done value define record doing thunk unit operator packages result value instruct scheduler terminate 
similarly bounce packages remaining computation resumed 
procedures yield control thread queue returning current thread sole element alist 
procedure unit creates done thread 
argument result computation 
dynamic thread creation define unit lambda value list done value tothe unit type avoid confusion monadic operator 
procedure bounce creates doing thread 
argument delayed computation modeled procedure arguments 
dynamic thread creation define bounce lambda thunk list doing thunk de ne sequential composition operator 
curried operator extension takes trampolined procedure argument thread 
completes execution thread feeds procedure 
initial computation terminates intermediate thread record dropped scheduler remaining computation including call extension ensure execution 
termination value computation passed extension longer involved 
subcomputations spawned initial computation feed result procedure 
type extension 
list list 
list 
dynamic thread creation define extension lambda lambda threads apply append map lambda thread record case thread done value value doing thunk bounce lambda extension thunk threads de nitions allow place extension 
sugar define syntax syntax rules var rhs body extension lambda var body rhs define syntax syntax rules exp exp dummy exp exp scheduler called trampoline allows number computations interleaved 
computation completed trampoline terminates maintains current state selects computation resume 
terminate empty thread queue 
terms type trampoline 
list 
dynamic thread creation define trampoline lambda thunk tramp list doing thunk define tramp lambda thread queue pair 
thread queue record case car thread queue done value value doing thunk tramp append cdr thread queue thunk thread returned value unit bounce return lists threads trampoline directly append result applying thunk 
version tramp thread list behaves round robin queue 
translated programs evaluate singleton lists threads 
initial thread queue contains element trampoline simply invokes element yielding singleton thread queue 
returning list threads trampoline gives added exibility lists zero threads 
potential exercised die spawn 
die simply return empty list identity operation append 
computations added list threads terminates 

list 
dynamic thread creation define die lambda extend protocol enable new threads added queue 
spawn operator may applied translated expressions order fork computation 
result dynamically create arbitrarily long threads 
tail position expression evaluates arbitrarily long list threads 
procedure spawn appends lists 
type list 
list 
list 
dynamic thread creation define spawn lambda threads threads append threads threads demonstrate operators running endless factorial computation terminating 
computation trampoline lambda spawn fact fact dropped unnecessary bounces inthe example 
rst computation terminate second computation causes trampoline terminate 
possible replacement ofthe separate loops fact computation single loop trampoline 
fibonacci function provides example state communication threads 
spawn creates subcomputation recursive call 
algorithm relies fact value fibonacci function equal number times base case reached standard recursive de nition provable inductive argument 
spawn anew thread recursive call 
base case accumulator incremented thread terminated 
interaction threads asynchronous sense rely order threads update accumulator fact eventually 
stretches calls bounce guaranteed atomic 
desired synchronization provided programmer 
asynchronous inter thread communication define fib lambda cond set 
acc add acc die spawn bounce lambda fib bounce lambda fib define acc trampoline fib acc synchronous communication implement powerful threads 
spawned parent receives thread record 
point parent request result child computation record 
computation completed parent receives result 
parent put sleep result available 
notion inter thread communication related futures 
communication functional rely explicit side ects user code threads earlier side ects available 
futures doing thread hold list threads waiting result 
completing computation thread awakens waiting threads returning thread queue 
simplicity waiting threads wait 
move new architecture fundamental di erences 
value eld done value box value value box appears doing threads aswell 
having value life thread allow awaiting thread check appearance value 
second expressions returning list thread records return procedure expecting thread record currently running computation returning list thread records 
thread need access thread record order create new thread record value box 
introduce done flag initial value stored value box 
synchronous communication define record done value box define record doing value box thunk define done flag gensym unit procedure returns avalue placing value box 
synchronous communication define unit lambda value lambda doing bx doing value box doing set box 
bx value list done bx synchronous communication define bounce lambda thunk lambda doing list doing doing value box doing thunk modify extension considerably 
right computation argument takes form procedure expecting thread 
result computation provided current thread apply procedure current thread yielding list thread records converted thread remembers perform 
synchronous communication define extension lambda lambda lambda doing map lambda thread record case thread done value box value unbox value box set box 
value box done flag doing value box lambda value doing value box thunk doing value box lambda extension thunk doing implement synchronous communication dynamic thread creation termination having procedure thread record cumulative 
modify scheduler trampoline provide boxed initial value unbox value 
synchronous communication define trampoline lambda thunk tramp list doing box done flag thunk define tramp lambda thread queue pair 
thread queue record case car thread queue done value box unbox value box doing value box thunk tramp append cdr thread queue thunk car thread queue thread returned value rede ne dynamic thread creation termination operators new architecture 
operators synchronous communication define die lambda lambda doing define spawn lambda lambda doing append doing doing spawn creates new records value box branch see de nition bounce 
proceed operators synchronous communication 
need threads tohave ability values 
need threads emit single value lifetimes combine emit die obtain emit die 
emit procedure general case 
di erence emit die unit unit causes trampoline terminate 
synchronous communication define emit lambda value lambda doing set box 
doing value box doing value list doing define emit die lambda value lambda doing die car emit value doing need enhanced version spawn operator call 
treats argument body parent rhs child 
variable bx var bound box hold result child computation 
parent may touch box triggering busy wait value provided 
spawn uses new value box additional thread 
ect ultimately spawns threads touched result threads waiting thread 
thread creates child thread touched result child thread release waiting thread 
keeping symmetric nature spawn asymmetric nature 
synchronous communication define syntax syntax rules bx var rhs body bx var box done flag lambda doing append body doing list doing bx var lambda rhs define touch lambda bx value unbox bx eq 
value done flag bounce lambda touch bx unit value form simply immediately touches value 
synchronous communication define syntax syntax rules var rhs body var rhs var touch var body demonstrate new examples 
rst revised version fibonacci function making interaction touch 
second function making interaction spawn touch 
touch define fib lambda bounce lambda fib unit define fib lambda emit die pred thread fib sub pred thread fib sub sub pred result touch pred thread pred result touch pred thread emit die pred result pred result htree search spawn touch define search num lambda tree cond pair 
tree spawn bounce lambda search num car tree bounce lambda search num cdr tree null 
tree die number 
tree unit tree symbol 
tree printf tree die trampoline lambda search num unit recycling thread records ine cient continually allocate deallocate thread records 
current thread available computation easy computation reuse 
record system ability update record elds 
included reuse ability type tags records 
type changes direction doing done increase knowledge regarding 
recycling thread records define unit lambda value lambda thread set box 
doing value box thread value set type 
thread done list thread recycling thread records define bounce lambda thunk lambda doing doing set thunk 
doing thunk list doing ed extension clauses done value box set type 
thread doing value unbox value box set box 
value box done flag doing set thunk 
thread lambda value thread doing value box thunk doing set thunk 
thread lambda extension thunk thread trampoline operator unchanged 
subsequent sections procedures new version provided assumed unchanged new architecture 
revised versions earlier operators recycling thread records 
spawn explicitly create new thread record reuse value box 
operators recycling thread records define spawn lambda lambda doing append doing list doing doing value box doing lambda modify touch entire thread bound just value box 
allow place value doing thread 
spawn creates new box child thread 
hsc operators recycling thread records define syntax syntax rules var rhs body var doing box done flag lambda rhs lambda thread append body thread list var define touch lambda thread record case thread done value box unit unbox value box doing value box thunk value unbox value box eq 
value done flag bounce lambda touch thread unit value killing threads thread records remain xed locations convenient extend architecture allow removing 
kill operator take thread killed representing 
approach straightforward 
variant kill representing directive remove particular thread queue 
thread killed held target thread eld 
remainder eld 
necessary maintain value box records larger doing records 
choose set aside space doing records allow recycling thread records identifying threads generated identi cation numbers 
approaches thread directly modify queue conceivable 
recycled kill records doing records appear frequently 
keep doing eld kill record hold current doing record 
killing threads synchronous communication define record kill target thread doing killing threads define kill lambda target thread lambda doing list kill target thread doing record current remainder computation initial computation procedure extension yields new remainder computation 
extension clause killing threads kill target thread doing kill set 
thread extension thread thread records type kill trampoline performs kill action restores thread queue doing record 
trampoline clause killing threads kill target thread doing doing set thunk 
doing lambda tramp append target thread cdr thread queue list doing demonstrate kill start threads repeatedly printing rst counting killing rst thread counting 
hthread killing example define print char lambda char display char bounce lambda print char char define countdown lambda display zero 
unit void bounce lambda countdown sub trampoline lambda print char countdown kill countdown kill descendents thread killed 
implemented placing parent eld thread records 
trampoline kill thread target thread reachable 
avoiding closures section show toavoid closures transformed programs 
avoidance closure addition demonstrating improved ciency eliminates requirement closures host language order perform trampolining 
trampolining architecture assumes modi ed translation style 
modelling stack architecture transformed programs 
thunks representing computational states replaced including code pointer local stack frame pointer register register free values register 
code pointer represented procedure accepting local stack contents registers free variables 
frame pointer register indicates base topmost frame stack resolve bound variable 
stack pointer register indicates unused stack location 
free values register resolve free variable due existing closures 
ed record closure avoidance define record doing value box code ptr stack fp sp fv define stack size normally unit bounce update elds done doing records respectively 
stack refers state need stored 
closure avoidance define bounce lambda code ptr fp sp fv lambda doing doing set code ptr 
doing code ptr doing set fp 
doing fp doing set sp 
doing sp doing set fv 
doing fv list doing extension operator modify code ptr thunk 
ed extension clauses closure avoidance done value box set type 
thread doing value unbox value box set box 
value box done flag doing set code ptr 
thread lambda stack fp sp fv value thread doing value box code ptr stack fp sp fv doing set code ptr 
thread lambda stack fp sp fv extension code ptr stack fp sp fv thread trampoline operator create doing record correct format 
closure avoidance define trampoline lambda code ptr tramp list doing box done flag code ptr vector stack size vector doing threads trampoline simply applies code ptr thunk 
kill threads trampoline old doing record letting ptr yield 
record placed thread queue target thread removed 
ed tramp clauses closure avoidance doing value box code ptr stack fp sp fv tramp append cdr thread queue code ptr stack fp sp fv kill target thread doing doing set code ptr 
doing lambda stack fp sp fv tramp append target thread cdr thread queue list doing spawn copy stack 
preferable existing stack start new branches 
operators closure avoidance define spawn lambda lambda doing record case doing doing value box code ptr stack fp sp fv append doing list doing value box lambda stack fp sp fv vector copy stack fp sp fv hsc operators closure define syntax syntax rules var rhs body var doing box done flag lambda stack fp sp fv rhs vector copy stack fp sp fv lambda doing append body doing list var hsc operators closure avoidance define touch lambda thread record case thread done value box unit unbox value box doing value box code ptr stack fp sp fv value unbox value box eq 
value done flag bounce lambda stack fp sp fv touch thread fp sp fv unit value translation revised follows 
variable replaced frame closure closure exists 
arguments procedures explicitly placed current frame tail calls new frame calls 
wished eliminate need stack architecture host system explicitly pass return address stack convert program tail form goal 
tail calls arguments loaded positions indexed fp fp remains unchanged 
reloading arguments necessary case recursive calls unchanged arguments 
care taken overwrite values needed arguments 
calls arguments written locations indexed sp sp new fp 
arguments loaded including case recursive calls unchanged arguments danger overwriting 
case sp set rst position argument 
representation existing closures changes closure created evaluating lambda 
exp represented result evaluating fv vector triv exp lambda stack fp sp modified exp triv exp describes free variable exp terms context lambda form modi ed exp result translating exp treatment variables requires techniques familiar deal compilation functional languages 
representation closures procedural 
closures remain fv appear free transformed lambda form original lambda form free variable 
case lambda form free variables form pass empty vector bounce fv 
trampolined program additional closures 
case original program closures 
remove define orig lambda ls cond null 
ls ls eq 
car ls cdr ls cons car ls cdr ls remove example define tramp lambda stack fp sp cond null 
vector ref stack fp unit vector ref stack fp eq 
car vector ref stack fp vector ref stack fp bounce lambda stack fp sp fv vector set 
stack fp cdr vector ref stack fp tramp stack fp fp fp sp fv tail result bounce lambda stack fp sp fv vector set 
stack sp vector ref stack fp vector set 
stack sp cdr vector ref stack fp tramp stack sp sp fp sp vector unit cons car vector ref stack fp tail result trampoline lambda stack fp sp fv vector set 
stack vector set 
stack tramp stack fp fp reviewed re ned trampolining architecture dynamic thread creation termination trampolining translation proceeded trampolining architectures operating revised translation 
additional architectures demonstrated approach concurrency implementation realistic systems 
facilities demonstrate potential cient implementation wide variety languages 
architectures sections differ section making state implementations 
user programs relying onthe operators architectures may fewer explicit side ects compare de nitions multiple threads 
history trampolining surveyed 
approach similar queinnec de roure implemented multiprocessing primitives program transformations 
related concurrency facilities monads done haskell 
hudak jones implement channels haskell 
scholz discusses synchronous interaction streams 
claessen de nes concurrency monad transformer 
trampolining architectures allow seamless integration synchronous asynchronous forms thread communication 
deal forms threads ciency implementation 
concerned variations scheduler algorithm shed little insight trampolining architectures 
require schedulers fair notion fairness coincide ramanujam 
luca cardelli 
compiling functional language 
conference record acm symposium lisp functional programming pages 
acm acm press august 
koen claessen 
poor man concurrency monad 
journal functional programming may 
andrzej filinski :10.1.1.43.8213
representing monads 
conference record popl st acm sigplan sigact symposium principles programming languages pages new york january 
acm press 
steven ganz daniel friedman mitchell wand 
trampolined style 
international conference programming pages paris september 
acm press 
halstead 
multilisp language concurrent symbolic computation 
acm transactions programming languages systems 
mark jones paul hudak 
implicit explicit parallel programming haskell 
technical report yaleu dcs rr department computer science yale university august 
richard kelsey william clinger jonathan rees editors 
revised report algorithmic language scheme 
acm sigplan notices 
september eugenio moggi :10.1.1.41.840
notions computation monads 
information computation july 
christian queinnec david de roure 
design concurrent distributed language 
robert halstead jr ito editors parallel symbolic computing languages systems applications japan workshop proceedings volume lncs pages boston massachussetts usa october 
ramanujam 
proving fairness schedulers 
rohit parikh editor proceedings conference volume lncs pages brooklyn ny june 
springer 
scholz 
imperative streams monadic combinator library synchronous programming 
international conference functional programming pages 
acm press 
philip wadler :10.1.1.100.9674
essence functional programming 
principles programming languages january 
