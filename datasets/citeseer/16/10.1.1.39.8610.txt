checking mergeable priority queues jonathan bright gregory sullivan computer science department johns hopkins university charles street baltimore md efficient algorithm check answers fundamental data types priority queues mergeable priority queues 
linear time checker mergeable priority queues 
data types widely routing scheduling simulation computational geometry algorithmic domains 
implemented answer checker performed experiments comparing speed checker benchmarked priority queue mergeable priority queue implementations checker substantially faster best implementations 
concerns fundamental data types priority queues pqs mergeable priority queues 
data types recognized centrally important early days computer algorithm design 
appear seminal algorithm texts knuth aho hopcroft ullman 
data structure implementations data types continue proliferate currently include binomial queues avl trees leftist trees skew heaps pairing heaps fibonacci heaps trees trees 
priority queues model situation number tasks different priorities dynamically generated need processed server rule highest priority task gets processed 
priority queues answer questions document gets departmental copy machine process allowed run operating system task performed event set simulation routine 
possible model situation number servers changes dynamically 
reasonable approach maintain separate priority queue server allow servers created destroyed 
new task generated server selected task added appropriate priority queue 
mergeable priority queues server destroyed tasks corresponding priority queue added merged tasks priority queue server functioning 
designed implementation mergeable priority queue allows merging step performed efficiently important number tasks quite large 
mergeable priority queues place restrictions servers created destroyed servers allowed time 
algorithm designed check answers generated priority queues mergeable priority queues 
evaluate sequence priority queue operations requires omega gamma log time 
lower bound uses decision tree model research supported nsf darpa ccr 
computation 
generalized versions priority queues require omega gamma log time evaluate operations 
designed time algorithm checks answers data types 
linear time answer checker known mpq data type 
previous linear time algorithm checking answers pqs 
mpq algorithm new efficient linear time checker pqs 
techniques similar developed possible design linear time checker splittable priority queues 
contains experimental evaluation mpq checker check pqs 
order evaluate relative speed effectiveness mpq checker obtained code different pq mpq implementations tested article appeared application experience section journal algorithmica 
study extensive evaluation different pq mpq implementations 
results show checker substantially faster fastest implementations pqs wide variety operation sequences 
checkers designed potential applications error monitoring software debugging data structures certification trails briefly discuss 
desirability software monitor computation attempt determine executing properly long recognized fault tolerance community 
example general approach designated algorithm fault tolerance uses software additional data attempt detect errors 
approach particularly valuable detecting errors fundamental operations matrix multiplication fft 
checkers provide error detection capability fundamental operations viz pq mpq operations 
program checkers studied approach slightly different approach 
checkers acceptance tests recovery block approach software fault tolerance 
error detected methods recovery possible 
example data contents data type extracted placed new data type alternative implementation strategy 
alternatively old data contents abandoned previous datatype operations replayed new implementation 
third method data structure discussed 
note checkers sequence answers just individual answer 
incorrect answer appears sequence may detected immediately 
guaranteed incorrect answer detected point processing entire sequence 
allowing latency detection able design efficient checkers 
section algorithm implementation discuss methods reducing latency 
vivid example value checkers software development debugging process provided performed experimental timing studies 
conduct experiments searched pre existing pq mpq implementations 
author graciously provided copies extensively benchmarked tested implementations studies 
generated random sequences operations mpq checker check implementations provided 
methodology allowed discover bug implementation binomial queues 
general believe checkers complement software development process aiding detection bugs 
checkers appear allow superior exploitation design diversity utilize different algorithms may contain coincident errors reimplementation data type tested 
checkers significantly faster code checked speedy checkers allow perform tests large corpus data 
possible application checkers occurs conjunction data structure allows repair automatically attempt detect faults 
suppose pq mpq data type implemented data structure 
checkers detect errors answers generated data type 
error detected repair data structure attempted 
cases recovery continued execution possible 
mention checkers generate certification trails 
notion certification trail introduced general method utilizing checkers type generate certification trails described 
example application mpq checker build certification trail solution constructing optimal alphabetic search trees 
see method building optimal alphabetic search trees 
resulting certifier program run time size search tree constructed 
result better previously best known checker optimal alphabetic search trees ran time certain special cases 
definitions describe operations consider 
basic operand type pair val 
positive integer called item number pair 
item numbers referring pairs pairs distinct item numbers 
val arbitrary real number called item value pair 
item values determine relative order pairs 
case pairs item value item names pairs break ties 
total ordering val 
val iff val val val val 
occasion refer pairs elements 
sets referred set name assumed positive integer 

makeset create set initialize empty 
previously sequence 

insert val insert pair val set set exist item number previously 

delete delete pair item number set currently 
pair item number set 

min return pair smallest value set set exist may empty 

deletemin return pair smallest value set delete set set exist may empty 

merge combine contents sets form set set set exist set may previously sequence 
operation sets destroyed 
note minimum value set unique item numbers pairs secondary comparisons 
operations return pairs assumed return value nil 
requirement set names item numbers reused solely ease describing algorithms 
cases easy modify algorithms item numbers set names reused 
data structure supports operations makeset insert delete min deletemin call priority queue 
data structure supports priority queue operations addition supports merge operation call mergeable priority queue 
abbreviate deletemin operations dmin 
checking mergeable priority queues sequence mpq operations 
sequence form val min deletemin operation nil 
wish determine contains correct answers min deletemin operations theoretically optimal checker section algorithm check correctness sequence mpq operations 
algorithm processes operations sequence 
makeset min deletemin merge operations constructs forest weighted trees 
tree edges maintained set treeedges 
tree forest root kept track function curroot abbreviation current root 
stage algorithm correspondence active sets sets created destroyed trees forest 
correspondence maintained curroot execution algorithm maintains set called 
set contains edges interconnect nodes trees 
placement edges carefully elements inserted deleted 
edges allow algorithm check answer min operation truly minimum element set allow similar checks 
final phase algorithm single weighted tree created edges treeedges connecting roots forest single new root 
graph constructed edges treeedges 
tree minimum weighted spanning tree graph answers operations correct answers incorrect 
note needs 
require generalized definition minimum spanning trees 
typically definition msts requires addition operator defined weights edges 
possible define msts addition operation 
important assume elements mergeable priority queue total ordering defined insist addition operation defined elements 
definition generalization standard minimum spanning tree definition see 
graph vertices edges weight function defined spanning tree say minimum weight spanning tree mst iff gamma weight greater equal weight edge unique simple path see example 
edges treeedges black edges dashed 
abbreviations ins del dmin makeset insert delete deletemin respectively 
simplify presentation example omitted item numbers elements 
delete operations item value indicate element deleted 
actuality item number element 
top part represents forest constructed mpq example 
mk mk mk mk mk mk merge merge merge merge del del annotated trees mst check problem ins ins ins dmin ins ins ins dmin merge ins min min ins ins ins ins ins dmin dmin merge min ins min ins ins merge dmin min del dmin merge del treeedges operation processed final stage 
leaf node label mk corresponding makeset operation created 
leaf internal nodes labeled corresponding insert operations sets 
internal nodes labeled merge del corresponding merge delete operations 
edges labeled corresponding min deletemin operations 
bottom part final mst check problem 
unlabeled edges assumed weight gamma 
symbols gamma refer pairs strictly smaller respectively larger pairs appearing input output 
procedure set set names appearing set item numbers appearing universe item values 
gamma set graph nodes 
subset gamma theta gamma initially empty 
treeedges subset gamma theta gamma initially empty 
weight function treeedges theta curroot function gamma fnil 
whereins function gamma fnil 
value function initialize curroot nil 
initialize whereins nil 
input sequence operations supposed answers error routine error called answers correct routine ok called 
execute appropriate case depending main loop makeset curroot nil error 
unused node gamma set curroot insert val curroot nil curroot destroyed whereins nil error 
set whereins curroot value val delete whereins nil whereins done error 
set contains pair item number 
whereins curroot 
add edge set weight value 
set whereins done 
min val supposed answer 
whereins nil whereins done error 
value val error 
curroot nil curroot destroyed error 
set contain val error 
unused node gamma add curroot treeedges weight curroot val 
set curroot deletemin val supposed answer 
whereins nil whereins done error 
value val error 
curroot nil curroot destroyed error 
set contain val error 
unused node gamma add curroot treeedges weight curroot val 
set curroot whereins 
add edge set weight val 
set whereins done 
merge curroot nil curroot destroyed error 
curroot nil curroot destroyed error 
curroot nil error 
unused node gamma add edges curroot curroot treeedges 
weight curroot gamma weight curroot gamma set curroot set curroot curroot equal destroyed 
final stage unused node gamma set curroot nil curroot destroyed add curroot treeedges set weight curroot gamma set pairs value whereins nil whereins done 
pair value add edge whereins set weight whereins value 
gamma refer nodes algorithm 
graph formed gamma edges treeedges 
tree formed treeedges minimum weight spanning tree ok error 
performs simple checks 
example checks set name item number reused 
checks argument delete operation set delete operation performed 
checks key value associated item number element inserted deleted 
wish discuss relatively simple types checks separately difficult checks performs 
introduce notion partial correctness sequence operations answers 
sequence operations supposed answers mergeable priority queue 
say partially correct answers operations correct operations min deletemin redefined follows min returns arbitrary pair set deletemin returns arbitrary pair set deletes 
difficult design program check partial correctness 
code contains necessary checks determine sequence operations supposed answers partially correct 
see implementation details 
hard show sequence operations answers partially correct indicate error 
indicates error main loop sequence partially correct 
lemma algorithm correct 
proof difficult show behaves correctly sequences partially correct 
assume input sequences partially correct 
means algorithm main loop call error execute final stage 
simple induction number executions main loop prove loop invariants 
whereins nil item inserted 
whereins done item inserted deleted 
item inserted deleted 
curroot nil set created makeset 
curroot destroyed set created makeset destroyed merge 
created makeset destroyed 
call set active 
gamma refer nodes algorithm point execution 
gamma gamma iteration main loop 
invariants easily proven 
iteration main loop edge set treeedges vertex set gamma form forest 
convention isolated node tree forest 
correspondence individual trees forest active sets 
correspondence function curroot curroot node call root corresponding tree 
pair val set whereins equals node tree root curroot 
main proof different induction 
assume behavior correct sequences length gamma attempt show correct sequences length base case induction trivially true 
treeedges gamma value treeedges algorithm completes execution gamma operations answers input 
treeedges value treeedges algorithm completes execution operations answers input 
similarly subscripts gamma sets functions meaning 
refer graph vertices gamma edges treeedges gamma refer graph vertices gamma gamma edges treeedges gamma gamma recall assuming operations answers partially correct final phase executed 
behaves correctly sequences length gamma know examination final test performed code gamma operations answers correct iff treeedges gamma mst graph gamma complete proof show operations answers correct iff treeedges mst graph show perform case analysis possible kth operation 
case suppose kth operation min supposed answer val 
note treeedges gamma treeedges nearly identical 
treeedges additional edge curroot curroot gamma weight val 
addition edge curroot gamma replaced edge curroot 
weight gamma remains 
sets gamma identical 
suppose treeedges mst generalized mst definition observations immediately may conclude treeedges gamma mst gamma means gamma operations answers correct 
note pair val edge whereins weight val note edge curroot curroot gamma weight val simple path whereins treeedges pair val generalized mst definition follows val val val 
sequence partially correct val gamma definition min operation conclude operations answers correct 
suppose treeedges mst generalized mst definition hard see treeedges gamma mst gamma exists edge form whereins weight val val 
val val case sequence operations answers incorrect 
completes case 
case suppose kth operation deletemin supposed answer val 
note treeedges gamma treeedges nearly identical 
treeedges additional edge curroot curroot gamma weight val 
addition edge curroot gamma replaced edge curroot 
weight gamma remains 
sets gamma nearly identical 
edge whereins gamma replaced whereins gamma curroot 
weight edge val unchanged 
suppose treeedges mst generalized mst definition observations immediately may conclude treeedges gamma mst gamma means gamma operations answers correct 
note pair val edge whereins weight val generalized mst definition follows val val val 
sequence partially correct val gamma definition deletemin operation conclude operations answers correct 
suppose treeedges mst generalized mst definition hard see treeedges gamma mst gamma exists edge form whereins weight val val 
val val case sequence operations answers incorrect 
completes case 
remaining cases suppose kth operation insert makeset delete merge 
operations returns value 
assuming sequences partially correct follows sequence operations answers correct iff sequence gamma operations answers correct 
hard show operations treeedges mst iff treeedges gamma mst gamma induction holds cases 
giving time complexity analysis state simple assumption 
algorithm assume memory maintain arrays indexed item numbers pairs encountered second indexed set names sets encountered 
note assumption item values just item numbers 
arrays allow constant time find sets pairs referenced operation 
assumption satisfied applications pqs seen necessary compress name space 
suppose set names item numbers bounded polynomial length sequence checking 
linear time radix sort efficiently compress set names item numbers maximum size set name item number linear length sequence checked 
running times algorithms expressed function number operations considered 
discuss implementation procedure 
consider operations min deletemin 
algorithm check supposed answer operations say val set checks postponed main loop simple depth search dfs procedure check ancestor relationships tree treeedges 
allows checks performed linear time 
consider delete operations 
algorithm requires name set element deleted 
postpone processing delete operations final stage 
linear time line union find algorithm process operations 
delete operations create check edges check edges final stage behavior algorithm altered delaying processing 
technique applies part deletemin responsible creating check edge 
dixon show correctness mst checked linear time 
note result works generalized definition minimum spanning trees 
lemma lemma sequence mpq operations sequence supposed answers operations 
correctness answers determined time 
practical variant theoretically efficient version checker performs practice 
discuss notion computing functions paths trees 
consider operations allow forest trees incrementally constructed query operations performed 
create create new tree containing node 
link weight combine trees roots single tree making parent assign edge label weight 
eval find root tree containing say return maximum labels path eval returns gamma 
tarjan shows perform create operations eval link operations time inverse ackermann function 
program simpler implementation basic technique path compression 
worst case asymptotic behavior implementation log algorithm performs better practice 
byproduct implementation eval operation performed root tree contained computed 
makeset merge min deletemin operations algorithm constructs forest weighted trees operations create link min deletemin operation creates edge label supposed answer operation merge operation creates edges default label gamma 
correspondence roots trees sets function curroot pair val inserted set associated current root association function whereins 
invariant maintained course algorithm 
val pair currently set labels edges finite weight path whereins curroot 
labels correspond precisely supposed answers min deletemin operations acting sets val member 
val smaller labels error occurred earlier sequence val smaller pair reported answer 
eval operations determine possibility occurs 
algorithm 
omit checks sequence answers partially correct theoretical algorithm 
brevity omit code deletemin simulated performing min operation followed delete 
procedure set set names appearing set item numbers appearing universe item values 
gamma set graph nodes 
curroot function gamma fnil 
whereins function gamma fnil 
value function initialize curroot nil 
initialize whereins nil 
input sequence operations supposed answers error routine error called answers correct routine ok called 
execute appropriate case depending main loop makeset unused node gamma execute create set curroot insert val set whereins curroot value val delete set tmp eval whereins 
value tmp error 
set whereins done 
min val supposed answer 
set tmp eval whereins root tree containing whereins 
curroot error 
val tmp error 
unused node gamma execute create perform link val 
set curroot merge unused node gamma perform link curroot gamma link curroot gamma 
set curroot set curroot curroot equal destroyed 
final stage unused node gamma 
set curroot nil curroot destroyed perform link curroot gamma 
whereins nil whereins done check eval whereins value 
checks succeed ok error 
lemma algorithm correct 
proof show execution final stage forest constructed create link operations consist exactly tree tree isomorphic including weights edges tree implied set treeedges algorithm terminates 
consider eval operations performed delete operations 
eval operation performed corresponds weighted dashed edge created delete execution 
shown edges path eval operation correspond precisely edges endpoints dashed edge created delete check eval operation succeed check weighted dashed edge succeeds 
similarly correspondence eval operations final stage weighted dashed edges created final stage 
checks eval operations succeed checks dashed edges succeed 
ignoring min queries see accepts sequence sequence 
consider eval operation performed processing min query supposed answer val 
consider eval operation performed pair val delete operation final stage 
eval operations argument whereins 
cases result eval compared val clear eval min query fails eval operation fail 
edges examined eval min query subset edges examined eval operation 
eval operations performed handling min queries allow prompt detection errors final determination correctness input sequence affected checks 
time required procedure dominated time takes perform create link eval operations 
mentioned done na time length sequence 
lemma sequence mpq operations sequence supposed answers operations 
checks correctness answers na time 
proof correctness demonstrates close relationship 
important differences regard errors detected 
completely line algorithm meaning errors detected execution final stage 
exception pair val reported supposed answer query form min dmin set error reported immediately 
due implementation details able detect val set final stage 
hand processes query form min dmin supposed answer val checks immediately val contained addition checks val supposed answer previous min dmin query 
errors sequence supposed answers detected execution final stage 
latency detection errors desired periodically execute operations final stage resume execution main loop 
example anticipated mpq operations going performed total operations eval computations checks performed pairs active 
checks succeed errors occurred point 
provided total number pairs need check execution code final stage doesn grow large example say total computational cost grow significantly 
executing steps final stage tree forest collapsed single node speeding eval operations 
compression trees nodes side effect providing superior space utilization 
variations strategy reduce latency possible 
timing results section describe performed timing experiments comparing speed mpq implementations practical version mpq checker 
timing experiments performed sun elc megabytes main memory 
programs compiled sun pascal compiler highest optimization level enabled 
compiler initializes static arrays zero explicit initialization required checker driver mpq implementations 
checker mpq implementations replaced calls pascal allocation function new allocation routine preallocated required records outside main timing loop 
tested checker variety parameter values number priority queues relative probabilities performing insert deletemin merge operations 
fixed set parameters generated random sequences averaged timings 
variance runs small despite fact run different randomly generated sequence 
performed extensive timing delete min operations anticipate results similar 
data sets timed check php shp fhp table priority queue insert followed deletemin operations check php shp fhp table priority queue insert insert deletemin deletemin different pq mpq implementations 
tables php pairing heap shp skew heap binomial queue leftist tree fhp fibonacci heap 
set test cases consisted sequence operations priority queue 
insert operations followed deletemin operations different values see table results 
data check average time milliseconds checker required run 
data php shp fhp times longer respective implementation took run data sets 
second set test cases consisted sequence operations priority queue 
phase insert operations performed 
second phase consisted operations operation insert probability deletemin probability 
third phase deletemin operations performed priority queue empty expect final phase consist approximately deletemin operations 
see table results 
third set test cases parameters number operations number priority queues target size priority queue expected number merge operations performed 
fix number priority queues active time merge operation create new priority queue 
operation chance merge operation 
merge arguments merge chosen randomly probability particular priority queue chosen proportional size size number pairs currently intuitively small priority queue argument merge large priority queue 
operation randomly chosen merge randomly select priority queue probability particular priority queue chosen proportional jt gamma size intuitively priority queue significantly fewer elements target size chosen priority queue close target size 
priority queue chosen perform insert deletemin operation pqs chk php shp fhp table operations expected merges pqs chk php shp fhp table operations expected merges depending priority queue smaller larger target size 
see tables results 
probability distributions bias merge operation operate small priority queues insert operations act small priority queues deletemin operations operate larger priority queues 
effect keeping priority queue sizes relatively balanced near target size 
randomly choosing priority queues operations regard size tends result priority queues containing vast majority elements rest having relatively elements 
equivalence checking msts sequences mpq operations previous sections showed possible linear time reduce instance checking correctness sequence mergeable priority queue operations instance checking tree minimum spanning tree graph 
section show converse true 
possible linear time reduce instance checking tree minimum spanning tree graph instance checking correctness sequence mergeable priority queue operations 
spanning tree graph edge weight pick arbitrary node root simplicity assume node exactly children 
easy modify algorithm case 
replace non tree edge ancestor create create insert insert create insert dmin insert dmin merge create insert insert dmin insert dmin insert dmin merge delete delete insert create insert insert merge delete insert dmin insert dmin merge delete delete dmin reduction mst check mpq operation sequence check 
descendant edges nearest common ancestor rooted weight 
assign node unique positive integer identifier 
assign edge unique positive integer identifier 
notational convention edge write 
initialize seq sequence mpq operations initially empty 
sequence contained seq procedure terminates mpq sequence mst check problem reduced 
perform depth search starting visit nodes post order fashion 
visit node leaf append operation create seq 
addition visiting leaf node non tree edge append operation insert seq 
assume currently visiting internal node children traversing post order fashion append operations seq insert dmin insert dmin merge 
non tree edge descendant append operation delete seq 
non tree edge ancestor append operation insert seq 
see example 
wish check solid edges form minimum spanning tree graph 
vertices tree labeled unique positive integers post order traversal tree 
notice edge weight split separate edges 
clarity numbering edges generated procedure omitted addition omit item numbers elements output sequence 
operation delete weight element deleted item number 
operation sequence generated columns operations column come operations second column come operations third column 
sequence mpq operations correct theorem see mst correct 
lemma spanning tree mst sequence generated procedure answers correct 
proof sketch prove mst sequence generated correct 
way contradiction assume sequence generated incorrect 
consider operation sequence form dmin incorrect 
operation produced visiting interval node children recursing operations output followed delete insert operations insert dmin insert dmin merge 
case 
cases essentially consider case 
see 
correct answer dmin pair holds 
call insert operations sequence immediately followed dmin operation type inserts insert operations type inserts 
dmin incorrect operation case originally inserted type insert 
non tree edge associated ancestor 
clearly delete operation issued node visited 
prove ancestor descendant 
violates definition minimum spanning tree non tree edge weight weight edge path case edge 
prove sequence correct mst way contradiction assume mst consider tree edge traversed call non tree edge path assume parent ancestor prove pair weight edge contained processing begins 
operation dmin incorrect contradiction 
note existence linear time algorithm checking mst property tree implies trivial solution problem 
specifically seq insert insert dmin seq insert insert dmin 
clearly seq correct seq incorrect 
tree graph linear time algorithm determine mst output seq corresponding mpq check problem output seq corresponding mpq check problem 
ask reduction trivial reduction linear time mst checker 
reason reduction shows close relationship checking sequences mergeable priority queues operations checking minimum spanning trees 
feel reduction gives added insight problems 
directions algorithms designed check answers generated fundamental data types priority queues mergeable priority queues 
data types requires omega gamma log time evaluate sequence operations 
checkers operate time 
addition proving asymptotic results performed timing experiments show checker priority queues mergeable priority queues performs practice 
checkers potential applications error monitoring software debugging data structures certification trails 
avenue exploring concerns new types checkers 
new checkers necessary modify implementations data types output answer additional data 
additional data designed simplify checking allow prompt detection errors 
developed checker mergeable priority queues paradigm allows line detection errors 
currently investigating practical efficiency approach 
avenues additional research open 
attempt design checkers common data types 
note checkers designed serial parallel distributed computations 
fact designed checker data type splittable priority queues 
applications mentioned pursued analytically experimentally 
bibliography aho hopcroft ullman design analysis computer algorithms addison wesley reading ma pp 

anderson lee fault tolerance principles practices prentice hall englewood cliffs nj 
blum kannan designing programs check proc 
acm symp 
theory computing pp 

cheriton tarjan finding minimum spanning trees siam comput 
dixon rauch tarjan verification sensitivity analysis minimum spanning trees linear time siam comput 
fredman pairing heap new form self adjusting heap algorithmica 
fredman tarjan fibonacci heaps uses improved network optimization algorithms journal acm 
gabow tarjan linear time algorithm special case disjoint set union comput 
system sci 
huang abraham algorithm fault tolerance matrix operations ieee trans 
computers pp 
vol 
june 
knuth art computer programming vol 
nd edn addison wesley reading ma 
knuth art computer programming vol 
nd edn addison wesley reading ma 
liao priority queue applications revisited algorithmica 
testing optimality alphabetic trees theoretical computer science vol 
pp 
february 
randell system structure software fault tolerance ieee trans 
software engineering vol 
pp 
june 
sleator tarjan self adjusting heaps siam comput 
sullivan masson certification trails achieve software fault tolerance dig 
ieee fault tol 
comput 
symp pp 

sullivan masson certification trails data structures dig 
ieee fault tol 
comput 
symp pp 

tarjan applications path compression balanced trees assoc 
comput 
mach 
pp 

taylor error models robust data structures dig 
th annual int 
symp 
fault tolerant comput pp 
june 
vuillemin data structure manipulating priority queues comm 
acm 

