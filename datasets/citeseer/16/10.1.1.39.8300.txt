appear proceedings tacas translation validation pnueli siegel weizmann institute science rehovot israel 
notion translation validation new approach verification translators compilers code generators 
proving advance compiler produces target code correctly implements source code compiler verification individual translation run compiler followed validation phase verifies target code produced run correctly implements submitted source program 
ingredients necessary set fully automatic translation validation process 
common semantic framework representation source code generated target code 

formalization notion correct implementation refinement relation 

syntactic simulation proof method allows automatically verify model semantic framework representing produced target code correctly implements model represents source 
ingredients elaborated illustrate new approach challenging case 
consider translation compilation synchronous multi clock data flow language signal asynchronous sequential code 
notion translation validation new approach verification translators compilers code generators 
idea translation validation proving advance compiler produces target code correctly implements source code compiler verification individual translation run compiler research done part european community project ep supported part minerva foundation infrastructure israeli ministry sciences art 
current address computer science laboratory sri international menlo park california 
followed validation phase verifies target code produced run correctly implements submitted source code 
compiler verification extremely complex task change compiler minor revisions requires redoing proof compiler verification tends freezes compiler design discourages improvements revisions 
drawback avoided translation validation approach compares input output compiler individual run independently output generated input 
concept translation validation depicted fig 

bad proof script fault indication counter example rudimentary proof checker compiler analyzer source target fig 

concept translation validation source target programs fed inputs analyzer analyzer finds generated target program correctly implements source program generates detailed proof script 
analyzer fails establish correct correspondence source target produces counter example 
counter example consists scenario generated code behaves differently source code 
counterexample provides evidence compiler faulty needs fixed 
ingredients necessary set fully automatic translation validation process 
common semantic framework representation source code generated target code 

formalization notion correct implementation refinement relation common semantic framework 

proof method allows prove model semantic framework representing produced target code correctly implements model represents source 

automation proof method carried analyzer successful generate proof script 
rudimentary proof checker examines proof script produced analyzer provides confirmation correctness translation 
ingredients elaborated illustrate new approach challenging case 
consider translation compilation synchronous multi clock data flow language signal asynchronous sequential code 
part esprit supported project safety critical embedded systems proposed translation validation tool described expected provide repeated validation run translator 
increase confidence correctness validation tool structured analyzer produces proof script rudimentary proof checker decomposition enables proof checker responsible providing seal approval simple verifiable inspection 
structured follows 
section introduces basic notions small representative signal mux give generated code mux explain correctly implements source code 
turn formal side 
section introduce synchronous transition system sts computational model 
formalism common semantic base description synchronous source asynchronous target programs signal resp example section formalizes notion correct implementation means refinement relation 
generalization refinement mapping simulation method advocated proof method refinement relation 
automation proof method syntactic representation appropriate proof rule topic section concluding remarks appear section 
detailed discussion proof checker decision procedures saved full version 
related similar direction reported cimatti 
due similarity source target languages translation considered straightforward verified simpler technique develop 
related proof carrying code mechanism necula lee cf 
nl 
believe translation validation approach may advantages proof carrying code 
translation validation framework general due computational model refinement notions proof carrying code method enjoy 
important advantage translation validation fully automatic proof carrying code crucial part correctness proof verification condition generated manually 
illustrative example section illustrate details compilation process means example explain principles underly translation validation process 
signal synchronous programming language design implementation reactive systems 
statements signal intended relate clocks frequencies values various internal external signal flows involved reactive system 
variables signals signal case synchronous languages volatile hold values specific time instances computation 
put differently variables absent computation 
consider signal program process mux integer fb integer fb default zn zn fb zn integer zn init program uses integer variable fb input integer variable output local variable zn 
body mux composed statements executed concurrently follows 
input fb read copied greater successively decremented referring zn holds previous value denote previous value operator new input value fb accepted zn case previous non positive input value fb equal 
achieved fb zn read clock fb zn allows fb zn 
possible computation program fb zn fb zn fb zn fb zn fb zn denotes absence signal 
note signal programs expected terminate 
consider code obtained compiling signal program 
main program consists basically functions initialization function called provide initial values program variables 
iteration function called repeatedly infinite loop 
function body calculates effect synchronous step program essential part concrete code 
iteration function obtained compiling mux 
logical true zn read fb fb zn write zn return true 
labels generated compiler added 
code introduces explicit boolean variables represent clocks signal variables events 
variable clock zn clock fb 
program works follows 
clock fb value true new value fb read assigned variable false gets value zn gamma 
cases updated value output copied zn step computation program 
skip intermediate states notation denote variable arbitrary value 
fb zn pc fb zn pc fb zn pc fb zn pc fb zn pc fb zn pc fb zn pc fb zn pc fb zn pc fb zn pc note variable pc program counter pointing location statement executed 
comparing computation computation signal program finds location particular interest location values concrete variables fb zn absence presence determined variables coincide values corresponding variables 
account clock zn clock fb accurate state correspondence computation signal program computation code restrict observations subsequent visits location fb zn pc fb zn pc fb zn pc fb zn pc fb zn pc central observation exists designated control location code example variables concrete target system correspond source counterparts 
general pattern programs generated compiler 
intuitively generated correctly implements original signal program sequence states obtained designated control location corresponds possible sequence states system 
rest show approach put formal grounds yield fully automatic translation validation process 
computational model section synchronous transition systems sts computational model process translation validation 
assume vocabulary typed variables variables identified persistent identified volatile volatile variables intended represent signals sense language signal 
domains volatile variables contain designated element indicate absence respective signal 
state type consistent interpretation assigning variable value domain 
denote sigma set states definition 
components define synchronous transition system sts theta ae cf 
ps finite set system variables 
theta initial condition satisfiable assertion characterizing initial states system ae transition relation assertion ae relates state sigma possible successors sigma referring unprimed primed versions system variables 
unprimed version system variable refers value primed version variable refers value ae say state ae successor state set externally observable variables define computation sts 
definition 
theta ae sts 
infinite sequence oe sigma computation satisfies requirements initiation theta ae denote kak set computations sts sts representation signal program signal program mux represented sts theta ae ffb zn ng theta fb zn ae fb fb zn zn gamma zn zn fb fb zn ffb points require explanation maintaining variables occurring signal program volatile variables sts encoding signal programs introduces persistent memorization variables variables occurring expressions 
example memorization variable second disjunct ae guarantees stutter robustness step system may choose take stutter idling step signals set memorization variables retain previous values 
sts representation program representation code straightforward signal program 
sts follow detailed explanations 
code described sts 
predicate pres presentation expresses variables set remain unchanged current transition cf 
mp 
theta ae ffb zn pcg theta fb zn pc ae pc true pc pres fpc pc zn pc pres fpc pc pc pres pc pc pres pc fb pc pres fpc fbg pc pc pres pc pc pres pc fb pc pres fpc ng pc zn gamma pc pres fpc ng pc pc pres fpc ng pc zn pc pres fpc ffb remarks order 
input fb location allow fb take arbitrary value corresponds new input fb environment 
false proceed directly value fb remains unchanged stated pres clause 
output explicit writing location program removed memorization introduced 
observation point explained entering location means mux iterate function cumulatively computed transition system 
values persistent variables fb zn considered location respective clock expressions value true 
apparent define refinement mapping sts sts persistent variables considered internal 
memorization generated code memorization variables encode memorization means scheduling 
order match memorization variables augment sts encoding generated program memorization variables name counterparts 
general pattern memorization variables memorized system memorized concrete system directly entering observation location location state correspondence established 
example value copied memorization variable location just observation location correct implementation refinement section consider notion correct implementation relation hold source code correct translation 
suggest appropriate relation refinement adapted special circumstances involve translation synchronous language signal asynchronous language general consider refinement system concrete system system viewed specification high level description application wish construct description closer final implementation 
elaborate development process may progress refinement steps making representation concrete 
cases system described declarative style concrete system operational imperative style 
order implementation refinement relation maximally effective liberal possible provided essential features system preserved 
refinement systems consider systems theta ae theta ae refer concrete systems respectively 
assume observable variables subset concrete observable variables 
fa cg denote sigma set states set states obtained assigning values variables denote sigma set states assign values variables state sigma denote restriction subset observable variables restriction lifted point wise computation oe ktk denoted oe complete set computations ktk denoted ktk systems define interface mapping function sigma 
sigma mapping concrete state sigma observable state sigma interface mapping said clocked mapping observable variable belongs concrete state sigma 
effect mapping variable observable systems preserve value declare absent current state 
point wise lift interface mapping concrete computation oe kck denoted oe complete set concrete computations kck denoted kck 
definition 
systems ea ec clocked interface mapping say refines relative kck kak refines relative applying mapping concrete computation oe kck obtain computation restricted observable variables definition 
systems say refines exists clocked interface mapping refines relative write denote fact system refines system section investigate proof method allows establish holds sts 
proving refinement method refinement mapping simulation proof method refinement notion introduced employ generalization established concept simulation refinement mapping 
refinement mappings define correspondence variables concrete system variables system observations preserved 
refinement mappings generally simulation techniques see jon lv means inductively prove semantically defined notion containment observable behaviors 
note employed notion clocked interface mapping definition refinement requiring mapping concrete states observable part state general refinement mapping expected yield mapping concrete state full state 
refinement mapping viewed possible extensions interface mapping 
define refinement mapping function sigma gamma 
sigma mapping concrete states 
refinement mapping called clocked refinement mapping satisfies sigma restrict attention clocked refinement mappings preserve observables stuttering 
proposed proof method refinement finding inductive refinement mapping defined 
definition denote sigma set reachable states system states appearing computation definition 
clocked refinement mapping sigma gamma 
sigma called inductive satisfies requirements initiation theta implies theta sigma propagation ae implies ae sigma inductive refinement mapping proof method stated theorem 
theorem 
sigma gamma 
sigma inductive clocked refinement mapping automating translation validation process proof method previous section inductive refinement mapping formulated semantic terms 
things assumed available characterization set reachable concrete states sigma difficult compute simplest systems 
quest automating process section syntactical representation notions refinement mapping associated proof method 
follow ideas lam kmp adapt deal particular notion refinement needed case 
describe main components proof computed translation validation process carried fully automatically 
syntactic representation proof rules consider stss ea ec refer concrete system respectively 
ff va gamma 
vc substitution replaces variable va expression concrete variables vc substitution ff induces mapping states denoted gamma 
ff state sigma refer concrete state 
state def gamma 
ff corresponding substitution ff assigns variable va value expression evaluated way refinement mappings syntactically defined means appropriate substitution ff 
show syntactically formulate requirements initiation propagation preservation observation requirement gamma 
ff clocked refinement mapping state function gamma 
ff expression state formula va define formula resp 
expression ff vc obtained replacing occurrence va case contains primed variable variable replaced obtained replacing occurrences variables vc primed versions 
concrete state substitution ff value evaluated gamma 
ff value ff evaluated holds cases evaluated va value gamma 
ff value evaluated particular state formula va gamma 
ff iff ff 
equivalence allows write proof obligations definition stated syntactical proof rule ref proving refinement sts systems 
definition imposed requirement respect reachable states 
difficult characterize precisely rule ref stronger requirement mapping inductive respect states satisfying invariant inv 
inv invariant reachable states satisfy inv inv states clearly implies reachable states 
assertion inv substitution ff va gamma 
vc theta inv inv holds initially inv ae inv inv propagated theta theta ff initiation inv ae ae ff propagation inv 
ff ff ea rule ref proving refinement existential quantifications hidden rule find invariant inv substitution ff 
generally finding inv ff left ingenuity verifier 
order rule ref useful fully automatic translation validation process appropriate invariant concrete system suitable substitution generated automatically 
generating inv ff general chance developing algorithm arbitrary systems automatically construct needed invariant inv refinement substitution ff automatically verify validity premises rule ref 
reason possible case translation validation applied language signal rely strong assumptions connections fact produced result translation system code generator specific structure mode operation 
general structure main loop code illustrated 



zn fb zn 
calculate outputs write outputs update past dependent variables read inputs read fb write obs zn true calculate clock expressions see body infinitely repeated loop consists stages 
calculation clock expressions stage assigns values boolean auxiliary variables variables associated observable variable represent existence absence 

reading inputs stage reads inputs program conditioned values appropriate clock variables 

calculating outputs 
stage calculates value output variables 

writing outputs 
stage write external files channels computed values output variables 

update previous expressions stage updates values usually local variables defined expressions containing previous operator 
special structure construction invariant inv substitution ff 
start noting program counter variable pc member vc refinement substitution ff follows 
memorization variable va include ff substitution gamma 

variable va include ff substitution gamma 
pc obs clk clk clock expression indicating new value assigned current iteration 
detailed algorithm computing clock expressions accumulative invariant inv omitted lack space described full version 
construction viewing main loop code procedure mux iterate example cyclic directed graph obs nodes edge labeled guard fl action read input variable write output variable assignment local output variable 
edge labeled action take guard true 
clock expression clk computed considering guards paths leading assignments mux example clock expressions obtained clk fb clk true clk zn true identification observation point general skeleton ff obtain refinement substitution ff fb zn gamma 
pc fb pc pc zn invariant inv computed initial values variables adding cumulative effect actions executed paths 
mux example obtain proposal invariant inv fb zn pc fl pc fl pc fl zn pc fl fb pc fl zn gamma pc pc pc pc zn gamma delta pc verified premises rule ref proof system ps 
script files omitted lack space appear full version 
introduced new approach translation validation described main components construction underline theory illustrative example method validating compilation synchronous language asynchronous 
concept translation validation general interest obviously limited translations signal believe main ideas serve basis translation validation large family source target languages 
intuition 
sts computational model general model synchronous asynchronous languages 
second existence designated control location sts computations source target programs serve observation point comparing values set externally observable variables input output variables example reasonable thing expect 
sense say target program correctly implements submitted source code 
notion refinement interface mapping associated proof method syntactic representation refinement mapping general kind 
approach described cases source target programs consist repeated execution single loop body correspondence executions single loop iteration source corresponds single iteration target 
characteristic code generators synchronous languages esterel bg lustre statecharts languages unity cmb 
clear translation validation tool set tailored particular translator compiler involved 
construction carried modifying guidelines framework 
cases may useful augment translator easier identify observation points 
suspect cases construction turn simpler called example 
difficulties faced due fact signal synchronous language asynchronous abadi lamport 
existence refinement mappings 
theoretical computer science 
bg berry gonthier 
synchronous programming language esterel design semantics implementation 
technical report inria 
le guernic 
synchronous programming event relations signal language semantics 
science computer programming 
cimatti giunchiglia pietra romano traverso yu 
provably correct embedded verifier certification safety critical software 
grumberg editor proc 
th intl 
conference computer aided verification cav lect 
notes comp 
sci vol 
pages 
springer verlag 
caspi halbwachs pilaud plaice 
lustre declarative language programming synchronous systems 
popl acm press pages 
cmb chandy misra 
parallel program design 
addison wesley 
harel 
statecharts visual formalism complex systems 
science computer programming pages 
jon jonsson 
simulations specifications distributed systems 
baeten groote editors concur volume lncs 
kmp kesten manna pnueli 
temporal verification simulation refinement 
de bakker 
de roever rozenberg editors decade concurrency volume lect 
notes comp 
sci 
springer verlag 
lam lamport 
temporal logic actions 
technical report dec systems research center december 
appear transactions programming languages systems 
lv lynch vaandrager 
forward backward simulations timing systems 
real time theory practice volume lncs 
mp manna pnueli 
temporal logic reactive concurrent systems 
springer verlag 
mp manna pnueli 
temporal verification reactive systems safety 
springer verlag new york 
necula 
proof carrying code 
popl acm press pages 
nl necula lee 
safe kernel extensions run time checking 
second symposium operating systems design implementations usenix 
ps pnueli shahar 
platform combining deductive algorithmic verification 
alur henzinger editors proc 
th intl 
conference computer aided verification cav lect 
notes comp 
sci pages 
springer verlag 
ps pnueli 
fair synchronous transition systems liveness proofs 
technical report weizmann institute science 
report 

