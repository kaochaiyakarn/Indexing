dynamic extent control operator partial continuations popl pp 
christian queinnec bernard ecole polytechnique inria rocquencourt partial continuation prefix computation remains done 
propose new operator precisely controls prefix abstracted partial continuation 
operator strongly related notion dynamic extent denotationally characterize 
programming examples commented show express previously proposed control operators 
suggested implementation eventually discussed 
keywords continuation partial continuation dynamic indefinite extent escape feature 
continuations introduced denotational semantics express rest computation cases constructs language alter 
non local exits jumps goto exception handling failure semantics prolog languages usually described continuations stoy schmidt 
scheme language rees clinger offers procedural class continuations indefinite extent 
functions lexical closures environment variables active defined continuations rest computation remains done defined 
continuations proved valuable tools scheme program non local exits haynes friedman partially funded gdr programmation 
lix ecole polytechnique palaiseau cedex france email address queinnec poly polytechnique fr inria rocquencourt domaine de voluceau le chesnay cedex france email address inria fr multitasking wand engines haynes friedman problem continuations powerful haynes friedman reify friedman wand rest computation 
call means losing control return 
partial continuation johnson prefix computation remains done 
partial continuation function returns caller partial continuations composable regular functions 
full continuations useful allow imperative transfer control 
programming languages widely differ offer continuations 
continuations class procedural accessed different namespace regular lexical variable environment 
continuations dynamic indefinite extent behave lexically dynamically 
main uses continuations recognized 
continuations non local exit facility met common lisp block return catch throw modula try raise setjmp longjmp 
constructs allow escape computation return previous control point 
handle exceptional situations 
continuations dynamic extent implementation efficient 
second continuations particular scheme closely related indefinite extent 
computation may reified frozen continuation passed normal value 
allows easily implement non preemptive multitasking facility wand 
intriguing feature differ threads lightweight processes continuations immutable objects may resumed 
naive implementation side reifying continuation roughly corresponds save current evaluation stack resuming continuation straightforward heap implementation page saved stack overwriting current stack 
evaluation stack represents mentioned rest computation copy back saved stack implies continuations composable means return overwritten stack 
partial continuations usually couple features marks continuations abstracted feature reifies 
models partial continuations exist mainly felleisen wand friedman duba run control danvy filinski reset shift 
constructs permit easily pair related control operators precisely specify context partial continuations reified 
presents framework scheme new control operator named splitter cf 
section creates pairs associated control operators non local exit facility whilst reifies partial continuations upto point splitter called 
various splitter compared section typed 
splitter construct reconciles previously recognized uses continuations dynamic extent full continuations indefinite extent partial continuations 
basic idea classical evaluation stack list linked activation records may marked order split parts lower part mark represents rest computation escaped 
upper part mark may abstracted partial continuation multiply applied stored partial continuation abstracts part control mark point reified 
partial continuations taken upto mark exist dynamic extent splitter cf 
section 
eventually suggests implementation technique inspired danvy hieb dybvig bruggeman avoids copying activation records back stack cf 
section 
partial continuation freezes associated activation records 
popping frames stack non destructive pointer translation 
conversely pushing new frames may overwrite frozen frames 
extra pointer free stack exists possible push new frames 
push frames regular zone done usual relatively regular stack pointer conversely push frames frozen zone done relatively free stack necessary explicit control links 
technique allows allocating mutable locations stack locations duplicated 
evaluation stack linked list activation records usually involves copy stack implementation clinger hieb dybvig bruggeman 
semantical framework section presents semantics scheme language formalizes conception dynamic extent see steele chapter 
term extent refers period time lifetime entity entity scheme indefinite extent entities exist forever 
languages scheme applications dynamic extent 
extent application function arguments time computed body function includes time taken computation appear body 
sense dynamic extents nested disjoint 
language offers non local exits dynamic extent application interrupted natural function returns value continuation 
finish dynamic extent forces inner nested dynamic extents 
dynamic extent strongly related height evaluation stack governs possibility stack allocating various entities lexical environments 
common compiling optimization determine conservatively approximate exact extent entities allocate accordingly 
prog set forms id set identifiers ae env id loc ff loc set locations oe store loc val val fun pair num fun val theta store theta ext theta cont pans cont store theta val theta ext pans ext loc bool prog env theta store theta ext theta cont pans prog env theta store theta ext theta cont pans domains scheme explicit dynamic extent continuations indefinite extent scheme possible expression multiply return results 
case concept applications having dynamic extent precisely defined 
propose denotational semantics scheme formally expressing notion dynamic extent 
main question concerning entity extent alive add domain ext standard denotation scheme rees clinger mapping active locations boolean true see 
initially location active 
store map passed functions continuations 
locations chosen compared distinguished 
pans domain second class objects form entities 
page domain partial answers yielded regular splitter free computations 
domain describing semantics splitter 
pans stands domain final answers ext denotations fairly standard pose problems see 
splitter operator scheme philosophy tries reduce number special forms introducing special functions call cc sticks single namespace nearly concepts class citizens 
le fin du fin represent new concepts procedurally 
express solution respect tenets single function named splitter necessary splitter lambda abort call pc expression abort lambda call pc lambda expression splitter invoked evaluation stack marked 
argument splitter binary function applied new synthesized functions tied mark 
functions safely invoked dynamic extent splitter provoke run time error 
abort call pc splitter returns returns argument 
splitter lambda abort call pc foo foo function abort takes single argument thunk invokes continuation splitter continuation 
allows abandon computation return level mark set splitter 
instance multiply elements list numbers exit zero may written define splitter lambda abort call pc define mult pair 
car abort lambda car mult cdr mult abort invoked waiting computations upto splitter discarded thunk lambda invoked replaces original splitter form 
second function call pc takes unary function call pc stands call partial continuation 
single argument 
reifies partial continuation upto parent splitter invokes argument 
reified partial continuation left place current continuation 
instance splitter lambda abort call pc cons call pc lambda cons cons form returns 

regular objects abort call pc indefinite extent remove reify partial continuation upto associated parent splitter invoked dynamic extent splitter safe behavior dynamic extent 
contrarily reified partial continuation indefinite extent behavior created forever cdr splitter returns partial cont lambda abort call pc cons splitter lambda abort call pc cons call pc lambda cons cons abort lambda 
partial continuations indefinite extent behavior splitter simulate call cc operator scheme 
toplevel expression regular scheme equivalent splitter lambda abort call pc call cc lambda call pc lambda lambda abort lambda expression restriction expression arbitrarily invokes call cc splitter interference 
slight difference exist uses toplevel loop new call cc synthesized cycle 
page oe oe ae oe ae oe ae oe endif ae oe set 
oe oe ae ae oe allocate store theta num theta store theta loc allocates num locations store 
lambda oe allocate oe oe ff ae ff oe ff oe oe oe oe ae oe ae oe oe oe oe ae oe ae oe oe ae init wrong undefined variable oe init ff wrong unknown location ff semantics main scheme special forms splitter function separates effects reifying partial continuation removing current continuation 
abort function kind tail takes thunk invokes tail position respect associated splitter 
abort clearly involves side effect control 
closely corresponds exceptions handled erroneous computations escaped appropriate handler invoked level handler bound exception 
hand call pc affect control 
express formal semantics splitter see define pans domain partial answers pans cont ans ans domain final answers cont domain sequences continuations 
computation form regular full continuation 
splitter operator extends set active objects fresh location yielding creates abort call pc invokes argument 
new continuation return simulation splitter written regular scheme appears appendix 
pushed value sent return return consider current sequence continuations send value 
abort function just invokes argument level splitter resets set active objects continuation splitter 
contrarily call pc affect set active objects 
observe access tail models count contexts head 
generators splitter operator put wellknown fringe problem 
binary trees compared fringe returns true similar fringe sequence leaves 
classical solutions involve trees explicitly interleaves coroutines enumerating sequentially leaves trees 
non classical solutions example gabriel 
solution satisfies goals handles arbitrary number trees ii independent tree walked 
visiting leafs tree prefix order done page init ff false splitter oei allocate oe oe ff ff true oe oe oe endif oe ff oe return wrong obsolete escape endif oe ff 
oe return oe 
oe wrong extent endif 
oe return 
return oe oe returns elements returns elements semantics splitter define visit tree fn pair 
tree visit car tree fn visit cdr tree fn fn tree tree walk 
tree comparing process receive leaf partial continuation expressing rest visit rest computation 
equal comparison goes aborted 
wrap visit new function allows return time leaf rest visit 
define tree walker visit lambda tree splitter lambda exit grab visit tree lambda leaf grab lambda exit lambda cons leaf lambda splitter lambda set 
grab set 
exit leaf pair leaf partial continuation returned 
splitter controlling partial continuation longer valid reused 
partial continuation returned wrapped inside new invocation splitter new grab exit functions updated respect new splitter 
possible partial continuation restarted partial continuation 
simply compare fringes sequences pairs leaf continuation enumerated particular tree walker define compare fringes walk trees list sentinel define 
leaf eq 
leaf define loop leafs define leaf 
leaf eq 
car leaf leafs trees finished 


leafs trees finished 


leafs page 
leaf 
cdr leafs leaves equal 
loop mapcar lambda leaf cdr leaf leafs loop mapcar walk trees fringe just define fringe trees compare fringes tree walker visit trees observe modularity solution 
visit function expressed direct style varied instance visit leaf numeric leaves 
visit function know particular bear burden interleaving various visits different trees 
similarly compare fringe handles multiplicity trees compares leaves resumes visiting processes concerned details tree walking 
burden borne tree walker computations progress step step 
example shows splitter ability construct complex generators restricted simple reduced internal state held variables 
complex generators compute arbitrary things saved current state computation resumed 
note computations generators restricted partial continuations 
variants imagined splitter investigate put scheme languages 
tempting create new type represent marks evaluation stack 
interface splitter splitter lambda mark marks new functions know handle marks abort call pc abort mark lambda call pc mark lambda partial continuation functional mark class non procedural object asked alive third specialized function alive mark 
mark variant leads simple type equations mark type marks created context splitter yield value 
splitter mark abort mark theta unit call pc mark theta obviously gain little power possible explicitly test mark alive neat interest dressing object allocated mark synthesized functions abort call pc 
hand interface complex type specialized functions added scheme 
variant consider marks class objects accessed la common lisp ad hoc special forms 
splitter label body abort label new body call pc label lambda expression introduces new namespace space labels associates names marks 
space lexically managed label body splitter special form binding 
restrict power variant abort call pc special form referencing label closed lambda abstraction exported outside 
solution simpler compiler recognize places optimizations performed validity mark static computation partial continuations abortion 
compiler complex introduces new special forms 
depending natural inclination embedding language splitter facility provided multiple forms 
class marks specialized functions choice 
implementation viewpoint implementor splitter induces problems call cc scheme 
management evaluation stack 
partial continuation represented slice execution stack 
propose implementation scheme partial continuations copied heap copied back execution stack 
technique closely related hieb dybvig bruggeman 
partial continuation reified corresponding stack slice considered frozen overwritten garbage collector 
simple exercise write structured lexical nonlocal exit facilities common lisp see steele block return variant splitter 
page consider push pop operations evaluation stack 
push allocates new activation records increments stack pointer sp pop just decrements 
observe pop non destructive 
forbid pushing sp frozen zone 
suppose extra pointer free stack fs short frozen zone safe allocate new activation records see 
regular mode sp 
partial continuation created activated fs set sp 
popping activation records done respect sp 
conversely pushing frame depends mode regular mode pushing frame done relatively sp sp frozen slice sp fs pushing done relatively fs 
special frame return address pushed fs save current sp 
sp reset fs plus offset pushing performed usually non frozen zone 
extra done sp higher fs 
returning sp reset old value frozen zone 
oe fs sp stack evaluation zone frozen calling function frozen zone extra stack control stack necessary 
times splitter called continuation pushed control stack 
partial continuation created corresponding slice control stack copied heap see 
partial continuation called current sp pushed control stack saved slice 
sp set top partial continuation 
frame special activation record imposing return control stack specifies 
benefits implementation discipline implicit control linkage ii copying stack slices avoided iii mutable locations directly put stack stack slices duplicated 

technique puts fix cost push instructions check current mode compare fs sp 
stack slice frozen set oe oe continuation partial stack control splitter call pc stack evaluation partial continuation reification ting fs bottom stack frozen 
stack scavenged hieb dybvig bruggeman requires cooperation gc perfect knowledge stack 
probably precludes conservative gcs compact stack may allow frame elimination illustrated saint james hanson 
implementation splitter synthesized functions abort call pc invalidated splitter returns 
hand call pc tail optimal 
inconvenience strictly tail recursive calls possible frozen zone new frame pushed fs 
tail recursion property immediately regained calls performed free zone 
related works felleisen introduced prompts partial continuations series felleisen felleisen wand friedman duba sitaram felleisen 
control operators behave dynamically control control upto run 
easily provide operators run stack set 
run lambda thunk old rs run stack splitter lambda abort call pc define cpc call pc lambda abort lambda set 
run stack cons cpc run stack page thunk set 
run stack old rs set 
control lambda car run stack programmation records call pcs stack order control upto run construct limited latest context possible take partial continuations upto different splitters sitaram felleisen sitaram felleisen introduced hierarchies solve problem correctly pairing runs controls require protocol respected 
solution solves naturally problem 
major point construct dynamic extent continuations useful efficient 
abstracting control danvy filinski introduced special forms acting control operators shift reset 
denotational semantics accompanies 
intuitively program special forms translated regular program explicit continuations written extended continuation passing style 
programs directly typed complex judgements involving natural type expression continuation yielding natural type final result see danvy filinski 
main difference consider embedding contexts head terminology count tail 
change lambda lambda reset deeply affect meaning program 
replace lambda splitter lambda alter 
property eases modularity 
hieb dybvig introduced new construct spawn hieb dybvig 
close fundamental differences 
spawn defined concurrent context allows suspend resume bunches processes 
spawn lambda con trol creates new process controlled control control invoked applies argument monadic function partial continuation spawn 
freezes concurrent subcomputations initiated spawn invocation control subcomputations resumed partial continuation called 
control process suspended 
spawn accurately written splitter 
suspend resume capabilities needless handle concurrency forbid write sequential dynamic binding facility simplify management run stack 
programs calling control inside control simplify spawn sequential version define spawn define mk cpc curr cpc curr abort lambda curr cpc takes current partial continuation lambda cc curr abort aborts lambda lambda splitter lambda na resets root process set 
curr cpc set 
curr abort na cc splitter lambda abort call pc mk cpc call pc abort difference concerns lifetime control reduced dynamic extent spawn 
times partial continuation invoked legal call control 
simulated behavior wrapping partial continuation new splitter 
eases multiply suspend computation upto root see instance fringe example difficult know partial continuation upto point invoked 
assume evaluation order arguments right left consider example partial continuation contains call control spawn lambda cons lambda cons lambda cons value 
reason calling foo partial continuation lambda cons lambda foo new partial continuation reified second lambda cons partial continuation upto spawn lambda cons cons 
effect case simultaneous roots hieb dybvig restrict partial continuation take upto root partial continuation restricted upto calling site analog form splitter splitter lambda abort call pc cons call pc page lambda abort lambda foo call pc lambda abort lambda cons value assuming order evaluation second call call pc reifies upto splitter 
sum construct controls precisely extent offers spawn 
partial continuations new powerful tools 
complex 
able know escapes provoked abort partial continuations created call pc partial continuations nearly useless toy programs 
splitter construct allows appropriately pair moments marking evaluation stack referring lower part evaluation stack mark referring intermediate slice mark mark current control point 
possible write programs simultaneously multiple marks interferences 
showed splitter program generators enumerating leaves trees showed rebuild call cc splitter 
view computation recognizes computations involves structure nested control points 
partial continuation taken upto active control point 
interesting observe view supports concept dynamic extent allows define indefinite extent partial continuations 
matthias felleisen dorai sitaram olivier danvy pierre weis damien doligez help drafting revising discussing 
bibliography clinger william clinger anne implementation strategies continuations proceedings acm lisp functional programming snowbird utah july pp 
danvy olivier danvy memory allocation higher order functions conference pp 
final value strongly depends order evaluation 
partial continuations best unary contexts 
danvy filinski olivier danvy andrzej filinski functional abstraction typed contexts diku report diku university copenhagen denmark august 
danvy filinski olivier danvy andrzej filinski abstracting control acm conference lisp functional programming nice france 
felleisen wand friedman duba matthias felleisen mitchell wand daniel friedman bruce duba continuations mathematical semantics handling full functional jumps acm conference lisp functional programming snowbird utah july 
felleisen matthias felleisen theory practice class prompts acm symposium principles programming languages san diego ca january 
friedman wand daniel friedman mitchell wand reification reflection metaphysics proceedings acm symposium lisp functional programming pp 
gabriel richard gabriel clos concepts prototyping system common lisp object system workshop oopsla october 
hanson chris hanson efficient stack allocation tail recursive languages acm conference lisp functional programming nice france 
haynes friedman christopher haynes daniel friedman abstracting timed preemption engines computer languages volume pp 
haynes friedman christopher haynes daniel friedman embedding continuations procedural objects acm toplas volume october pp 
hieb dybvig bruggeman robert hieb kent dybvig carl bruggeman representing control presence class continuations proceedings acm sigplan conference programming language design implementation white plains ny june 
hieb dybvig robert hieb kent dybvig continuations concurrency second acm sigplan symposium principles practice parallel programming pp 
bibliography page johnson gregory johnson gl denotational testbed continuations partial continuations proceedings sigplan symposium interpreters interpretive techniques saint paul ma june 
johnson duggan gregory johnson dominic duggan stores partial continuations firstclass objects language environment acm sigact sigplan symposium principles programming languages san diego ca january 
rees clinger jonathan rees william clinger revised report algorithmic language scheme acm sigplan notices dec pp 
saint james emmanuel saint james recursion efficient iteration acm symposium lisp functional programming austin texas 
schmidt david schmidt denotational semantics methodology language development allyn bacon newton mass 
sitaram felleisen dorai sitaram matthias felleisen control delimiters hierarchies lisp symbolic computation international journal volume january pp 
steele guy steele jr common lisp language second edition digital press burlington ma 
stoy joseph stoy denotational semantics scott strachey approach programming language theory mit press cambridge mass 
wand mitchell wand continuation multiprocessing conference record lisp conference 
appendix embedding splitter standard scheme sitaram felleisen explained program control run scheme 
idea helps concept partial continuations 
embedding follows designed mimic native implementation 
call call cc thought just copy stack pointer 
push pop operations simulated cons cdr 
allocations heap named prefix 
explicit data necessary implicit closures keep 
define stack marker define splitter marker set 
call cc lambda kk set 
marker cons kk set 
stack marker cons marker stack marker abort marker call pc marker set car 
car stack marker null 
stack marker kk thunk markers downto marker obsolete 
obsolete stack 
marker compute thunk continuation kk 
set 
set car 
car stack marker set 
car stack marker set 
stack marker cdr stack marker cond continuation return null 
cdr partial continuation 
cdr define abort marker lambda thunk null 
car marker wrong obsolete splitter return marker 
car marker thunk define call pc marker lambda null 
car marker wrong extent call cc lambda kj pc kj marker define pc kj marker slice marker prefix stack marker marker lambda bibliography page call cc lambda kc set 
stack marker append slice cons cons kc stack marker kj define marker prefix eq 
car cons cons cdar marker prefix cdr define obsolete stack 
marker eq 
car stack marker marker marker set car 
car stack marker set 
stack marker cdr stack marker obsolete stack 
marker bibliography page 
