appear proceedings fifth acm sigplan sigact symposium principles programming languages san diego california january 
fl acm see notice 
putting pointer analysis rakesh ghiya laurie hendren school computer science mcgill university montr eal qu ebec canada cs mcgill ca addresses problem apply pointer analysis wide variety compiler applications 
presenting new pointer analysis 
focus putting existing pointer analyses points analysis connection analysis 
demonstrate fundamental problem able compare memory locations read written pointer indirections different program points able summarize effect pointer regions program 
straightforward compute read write sets indirections involving stack directed pointers points information 
heap directed pointers show needs introduce notion anchor handles connection analysis express read write sets heap respect anchor handles 
read write sets show extend traditional optimizations common subexpression elimination loop invariant removal removal include pointer 
demonstrate information advanced techniques array dependence testing program understanding 
implemented techniques mccat compiler demonstrate examples applying methods set pointer intensive benchmarks concrete empirical data improvements achieved 
motivation pointer analysis subject active research 
focuses new pointer analysis results exist supported nserc fcar 
copyright fl association computing machinery permission digital hard copies part personal classroom granted fee provided copies distributed profit direct commercial advantage copies bear notice full citation page 
copyrights components owned acm honored 
abstracting credit permitted 
copy republish post servers redistribute lists requires prior specific permission fee 
request permissions publications dept acm fax permissions acm org 
ing pointer analyses wide variety compiler applications 
relationships pointers computed 
put pointer analysis 
variety effective techniques proposed estimate points alias relationships :10.1.1.25.6013:10.1.1.11.3368:10.1.1.22.4648
common feature techniques approximate relationships named objects 
objects stack appropriate variable names dynamically allocated objects handled associating set static names 
approach memory locations named advantages 
firstly analysis pointers stack objects stack directed pointers pointers heap objects heap directed pointers 
secondly names static quite simple information subsequent compiler analyses 
treating heap static set named locations lead significant imprecision substantial improvements accuracy achieved special heap analyses heap directed pointers :10.1.1.152.1240
approaches focused different kinds abstractions order get precise richer descriptions relationships heap directed pointers 
question remains information provided analyses subsequent compiler transformations 
approach handle stack heap problems separately 
resolve pointer relationships stack store points analysis abstracts heap locations single symbolic location called heap :10.1.1.25.6013
pointers reported pointing heap analyzed hierarchy heap analyses connection analysis shape analysis 
focus examine combination points anal simplest solution name called heap accurate solutions variant malloc sites associate malloc site program name 
ysis connection analysis compute information wide range compiler applications 
connection analysis chosen relatively simple type analysis give names heap locations 
demonstrates problems results analysis yields interesting results put properly 
main contributions follows 
computing read write sets pointer analysis computing set locations read written statement program block relatively simple store analysis 
provide brief description section 
analysis connection analysis central problem fairly accurate information program point static names heap locations difficult relate information known program point information known program point 
immediately obvious summarize information program points summarize effect function body 
solution create just names heap objects called anchor handles maintain advantages analysis time information named anchor handles relate different program points summarize effects program points 
implemented connection analysis augmented anchor handles subsequent analysis computes read write sets relative handles 
applications read write sets read write sets demonstrate information wide variety applications including extending standard scalar compiler transformations loop invariant removal location invariant removal common subexpression elimination include pointers providing improved input array dependence testers providing summary information useful program understanding dynamic compilation prefetching pointer data structures 
implementations empirical studies implemented techniques mccat compiler empirical data illustrate costs benefits techniques 
performing source source scalar transformations read write sets demonstrate performance improvement gcc 
array dependence testers show significant improvements pointer read write sets demonstrate read write sets program understanding tool produces output browsed web browsers 
feel demonstrated practical applications pointer analysis 
organized follows 
section necessary background points analysis connection analysis discuss compute read write sets analyses 
section illustrate scalar optimizations discuss applications read write sets 
summarize related section section draw discuss 
foundations main goal identify set locations read written statement program region 
consider small program fragment 
statement straightforward compute read fy zg write fxg 
statements involve indirect simple syntax approach gives read fq qg write fpg read fq yg write qg 
information sufficient correctly identify dependencies 
example read may conflict write indirect potentially access location variable similarly write may conflict read target pointer change statements 
order relate read write sets statements involving indirection statements needs resolve indirect set static locations 
sections outline methods accurately computing read write sets points analysis connection analysis 

example read write sets points analysis read write sets points analysis stored pointer analysis specifically relies fact pointer targets compile time name 
calculates pointer targets terms program point specific points triples form 
triples respectively denote variable definitely possibly contains address location corresponding symbolic names generated pointer targets outside scope current procedure 
heap locations inherently anonymous abstracted symbolic stack location called heap 
detailed description context sensitive interprocedural points analysis :10.1.1.25.6013
simply illustrate small code fragment shown 
program point points triples pta ptb typedef struct point double double struct point point void flip point point gets reflection void sum point point void main point pta ptb int pta ptb sum flip example connection read write sets connect connect snapshots related connection information get respectively mapped entry function sum program point 
note symbolic locations generated represent pta ptb local main inside function sum 
information read write sets statements entire function sum easily computed read fc yg write xg read fc xg write yg read sum fc yg write sum yg information dependencies function sum easily detected 
read write sets function call sum program point computed read write sets function sum giving information read fs pta pta ptb ptb yg write pta yg consider program point points triples heap heap get mapped heap heap entry function flip 
information get conservative read write sets read write read write indicate false dependence obtain sharper read write information heap directed pointers perform heap analysis called connection analysis described 
connection analysis read write sets connection analysis heap pointer analysis explicitly computing potential targets pointer computes connection relationships pointers 
performed points analysis focuses pointers reported heap directed points analysis 
heap directed pointers connected possibly point heap objects belonging data structure 
connected definitely point objects belonging disjoint data structures 
demonstrates snapshot typical stack heap program point snapshot executing statement program point 
snapshots give connection relationships hold point 
consider program point point pointer variables heap directed 
variables point disjoint arrays connected 
variables point various linked list nodes 
case point data structure variables connected 
valid connection set executing statement connected handles previously connected valid connection set note negative information really useful 
example pair set connection relationships operation array distinct operation array similarly access list pointed distinct access list pointed note connection relationships terms program variables actual objects heap names 
nodes lists may allocated static malloc site connection analysis determine lists disjoint 
connection analysis context sensitive interprocedural analysis detailed description 
difficulties computing read write sets connection analysis connection analysis difficult relate connection information different program points 
consider function flip 
call site function flip pointers point disjoint heap objects connected 
consequently entry flip parameters connected remain disconnected entire function body statement connects 
suppose want summarize locations read written relative parameters connection information may deduce sets write fa xg read fb xg conflict point disjoint objects simplistic solutions suffice 
consider function tricky flip 
illustrated figures pointer values stored change 
connected point connected point flow dependence point location point dropping anchors fundamental problem tricky flip example don names heap objects 
programmer defined name may refer different objects different program points 
solution invent new names anchor handles analyses done simply information relative anchor handles 
consider new version tricky flip 
example introduced names tricky flip tricky flip anchor parameters introduced anchor variable program point anchor handles initial values introducing ghost copy statements 
anchors parameters copied function body specific anchors form copied program point shown part program fact anchors ghosts implemented connection analysis actual program modified 
anchor handles serve anchor points analysis body function 
informally compute read write sets respect heap related indirect noting anchor handle read written time pointer connected read written 
example illustrated statement connected anchors tricky flip indicate writing writes anchored locations tricky flip giving fa tricky flip xg 
similarly statement connected anchors tricky flip read reads anchored locations tricky flip giving fa tricky flip xg 
comparing sets detect flow dependence collect heap read write sets respect function parameters terms anchors 
example function tricky flip information tricky flip tricky flip fa tricky flip tricky flip yg function level information determine entry function tricky flip useful prefetch prefetch updates field tricky flip change data structure 
introducing anchor handles connection analysis anchor handles affect efficiency connection analysis 
identifying program points anchor handles need introduced selecting locations anchored important issue 
implementation function program anchor handles generated formal parameter ii heap directed global pointer accessed function iii call site read write heap location iv heap related indirect function body considered heap related entry heap sake clarity include anchors example 
void point point point tmp swap tmp tmp tricky flip program point connect fg program point connect fg tricky example void point point point tmp point anchors ghost ghost ghost swap tmp tmp tricky flip tricky flip tricky flip connect tricky lip tricky lip tricky lip program point tricky flip tricky flip connect tricky lip tricky lip tricky lip program point dropping anchors inserting ghost copy statements points set program point 
types anchor handles introduced compute heap read write sets entire function handles tricky flip tricky flip fall category 
call site anchor handles compare heap read write sets function call statements 
include anchor handles connection analysis ghost copy assignments performed function entry points indirect heap 
note points information indirect function calls access heap enables reduce number anchor handles generated 
extended ssa numbers reduce number anchor handles required 
conceptually requires new anchor handle indirect heap fact anchor handles reused 
example program anchor tricky flip anchor anchor location pointer updated program points handles created 
handle anchor indirect involving definition pointer 
extended ssa numbering associates new primary ssa number variable including pointers potentially updated including indirect updates 
generate anchor handle pointer ptr associate current ssa number handle 
anchor handle ptr ssa number exists generate new reuse existing indirect 
subsection briefly illustrated stack read write sets computed function calls map information points analysis 
heap read write sets function calls computed map information deposited connection analysis context sensitive interprocedural analysis 
generates special symbolic names represent heap pointers invisible callee procedure connection relationships modified 
consider call function flip 
due parameter passing call generates connection relationships 
names visible function flip connection analysis maps special symbolic names generating connection relationships 
ghost copy statements entry flip generate connection pairs flip flip addition pairs flip flip 
heap read write sets function flip terms parameter anchors follows flip fb flip flip xg flip fa flip flip yg connection analysis information mapped ii connected anchor flip iii flip flip set flip 
facts deduces context function main anchored locations written call flip program point similarly pointer deduces locations read call 
implementation generate anchor argument call 
generate just handles rd anchor wrt anchor respectively represent read write anchors express read write sets respect giving sets call flip anchor rd anchor yg anchor wrt anchor yg additionally perform ghost copy assignments function call processed 
due assignments statement function main find connected wrt anchor detect statements conflict 
main idea creating anchor pointer respect function call access heap just create anchors represent needed anchors 
implementation details anchor augmented connection analysis :10.1.1.40.9725
analysis efficiency evaluated efficiency analyses respect set benchmark programs drawn spec splash olden pgm description data structures alvinn spec program arrays water molecular dynamics arrays lists health health care simul 
quadtree lists graphics graphics routines linked lists circuit sparse matrix solver linked lists body simulation octree spec program arrays em arrays lists yacr channel arrays structures ks graph partitioning arrays lists vor voronoi diagrams splay tree lists power power optimization ary tree vector benchmark arrays blocks comput 
biology arrays lists sim comput 
biology arrays lists eigen eigenvalues arrays table benchmark descriptions irvine wisconsin benchmark suites 
brief description benchmarks provided table 
table summarizes principal data structures benchmarks 
array denotes statically allocated array array denotes dynamically allocated array linked list denotes list 
pgm ns sr hr aa pt ct alvinn water health graphics circuit em yacr ks vor power blocks sim eigen table analysis statistics table provide analysis times measured ultrasparc machine seconds 
points connection timings pt ct respectively include additional time spent computing stack heap read write sets 
table provides information program number simple statements ns ii number stack heap related indirect sr hr iii average number anchor handles generated indirect aa 
interesting observation context sensitive pointer analyses quite efficient moderate size benchmarks 
indicates interesting sections larger programs identified linear analyses precise information sections obtained efficiently :10.1.1.11.3368
presently experimenting approach efficiently analyze large programs 
observation average number anchor handles generated indirect benchmarks 
indicates ssa numbers reduce number anchor handles needed 
applications implementation stack heap read write set analyses basis extending standard scalar compiler optimizations loop invariant removal lir global common subexpression elimination cse advanced compiler applications array dependence testing 
built program understanding tool displays summary read write information user web browsers 
sections assume working simple representation program mccat compiler 
scalar optimizations algorithms implement lir cse optimizations 
implementation powerful due improved read write information 
extends optimizations include read pointer expressions globals address exposed variables variables address taken 
included register promoted absence alias information 
implemented optimization call location invariant removal similar spirit scalar replacement technique proposed array 
memory accesses memory location iterations loop considered location invariant 
example pointer access location invariant origin pointer written inside loop 
replace accesses scalar say tr shown 
safely perform location invariant removal check memory loop access location syntactically equivalent location invariant 
example access location performed 
moving pointer loop location invariant removal guard invariant statements loop condition necessary order preserve program semantics example 
implementation details optimizations :10.1.1.40.9725
null tr null tr tr tr location invariants experimental results scalar optimizations subsection study experimental results obtained applying optimizations suite pointer intensive benchmarks programs briefly described table entries 
collected static compile time dynamic runtime statistics 
compile time data indicates applicability optimization program stack heap read write sets section 
examine optimization opportunities due presence heap read write sets section 
provide runtime measurements measure ultimate benefit read write sets decreasing number memory accesses decreasing number instructions executed decreasing running time optimized programs section 
optimizations applied stack heap read write sets experimental results report opportunities arise scalar optimizations run stack heap read write sets available 
purpose data demonstrate types optimizations possible show significant number opportunities arise pointer intensive benchmarks 
table respectively give number times optimizations removal loop location invariant removal loc common subexpression elimination cse applied program 
divided labeled columns give data different types expressions 
denotations labels follows gl global variables ii ae address exposed variables iii addr address calculations form field iv ind indirect field pointer simple array pointer simple component field expr expressions involving computation lhs op scalar lhs scalar op scalar 
note location invariant optimization applicable expressions involving address calculations computation 
benchmarks globals address exposed variables contribute significantly number loop invariants water yacr 
benchmarks number global variables initialized program invariant loops 
algorithm replaces temporaries register allocated 
shows example benchmark global variable substituted temporary temp invar 
significant number loop invariant address calculations benchmarks water health graphics yacr 
typically arise due accesses arrays embedded inside heap allocated structures 
example benchmark shown 
invariant indirect ind column benchmarks pointer intensive 
typically arise nested loops outer loop traversing nodes recursive data structure inner loop operates node 
indirect respect node inner loop provide opportunities invariant detection 
example em shown find indirect respect pointer nodelist invariant inner loop 
find significant number expr invariants 
invariants identified pointer analysis involve scalars 
scalars defined inside loop definitions may involve pointer expressions detected invariant 
find limited applications location invariant removal benchmarks 
prove critical dynamic context 
opportunities location invariant removal arise mainly due summation reduction operations 
typical examples include storing sum node values header node ii inner loop storing sum node values current outer loop node 
shows loop alvinn benchmark location invariant optimization applied 
cse optimization finds numerous applications benchmarks particularly address calculations indirect 
give insight show representative example applications cse different benchmarks 
part shows loop water repeated array address calculations eliminated 
part shows loop health 
loop pointer list loop iteration accesses fields heap object pointed pointer list patient 
cse optimization compute pointer iteration opposed field access original program 
part shows loop benchmark circuit 
pointer expression ch common loop test statement advancing loop pointer ch 
cse optimization compute expression iteration opposed twice 
part shows code fragment loop vor pointer expression calculated parameter passing reused cse function call modify value 
benefits heap read write sets data shown table case stack heap read write sets 
order measure part due heap analyses applied optimizations stack read write sets 
table compare data total number optimizations applied cases 
columns labeled respectively give numbers case stack read write sets stack case case stack heap read write sets heap case 
program lirs cse alvinn water health graphics circuit em yacr ks vor power table total optimizations applied number loop invariants common subexpressions eliminated increases moderately heap case benchmarks alvinn heap 
stack case able detect majority optimization opportunities reasons 
case globals address exposed variables heap read write information bring added advantage 
second loop code fragment involve write heap heap related invariants common subexpressions detected heap analysis 
number location invariants increases water health benchmarks program loop loc cse gl ae addr ind expr gl ae ind gl ae addr ind expr alvinn water health graphics circuit em yacr ks vor power table distribution optimizations applied input lir lir temp un cell subp lir temp temp temp temp temp temp nodelist temp nodelist lir temp nodelist lir temp nodelist lir temp temp coeff temp value value temp nodelist value temp coeff value nodelist value temp temp nodelist nodelist sender guard receiver sender temp temp sender sender sender temp temp temp weight weight weight temp temp temp temp temp temp temp receiver em alvinn examples loop invariants lir location invariants heap related location invariant expressions arise ks 
heap location invariants ks arise loops involve write access heap detected needing heap read write sets 
runtime improvements pointer read write sets noted stack read write sets conservatively estimate heap heap related invariants common subexpressions may detected cases 
likewise possible optimizing compiler conservatively handles pointer detect optimization opportunities analyses detect 
example cse transformations shown performed pointer analysis information fact gcc 
order measure additional benefits analyses state art optimizing compiler compared results gnu compiler gcc version working highest level optimization flag 
transformations source source performed simple intermediate representation performed experiment 
produced sources benchmark program dump simple representation program plain version ii dump simple representation program optimizations applied stack read write sets sopt version iii optimized dump stack heap read write sets hopt version 
simple dumps just simplified programs compiled native compiler 
compile versions gcc compiler optimization flag compare runtime performance opt versions plain version 
note difference performance solely attributed source source transformations 
collected run time statistics ffl total number memory program execution 
important metric main effect applying optimizations pointer expressions globals address exposed variables reduction memory 
ffl total number instructions executed 
reflects instructions eliminated due loop invariant removal 
source optimizations enable compiler conservative produce better code lead reduction number instructions 
ffl run time program measured usr bin time utility ultrasparc machine single user logged 
run time calculated sum system user time reported time utility 
run time averaged runs program 
collected statistics eel qpt tool jim larus instruments program executable give exact counts 
note run time reported qpt instrumented versions executables 
comparison statistics table 
labeled mem refs run time respectively give data regarding number memory number instructions executed run time 
columns labeled sopt hopt labeled decrease respectively give percentage decrease achieved number memory instructions executed sopt hopt versions plain version 
columns labeled abs decr give actual decrease number memory instructions millions achieved hopt version plain version 
run time column labeled base time gives run time seconds plain version 
columns respectively show percentage speedup obtained sopt hopt versions plain version 
main observations table discussed 
optimized versions achieve significant reduction number memory 
highest alvinn benchmarks achieve greater reduction 
alvinn main factor proves location invariant removal shown applies critical inner loops 
pointer array state arises twice rhs critical loop function agc 
write pointer array output 
pointer information gcc able apply cse write brings reduction 
benchmarks invariants common subexpressions spread program contribute 
power benchmark see increase number memory despite numerous applications optimizations table 
happens benchmark pointer expressions remain invariant function 
cse occurence expression substituted temporary 
temporaries having long lifetimes causing register allocator introduce spills perform worse original 
temp coord temp temp temp cse temp temp temp cse temp 
statements deleted list temp list patient temp temp temp 
statements deleted temp temp cse temp temp temp cse temp temp time 
statements deleted list list forward water health temp ch temp temp temp ch col temp ch ch cse temp ch temp temp act temp temp temp temp temp act temp cse circuit vor common subexpression elimination cse examples program mem refs run time decrease abs decrease abs base speedup sopt hopt decr sopt hopt decr time sopt hopt alvinn water health graphics circuit em yacr ks vor power table dynamic improvements gcc observations highlight applicability optimizations pointer expressions particular 
indicate may direct correlation number times optimizations applied actual run time improvements 
benchmarks reduction achieved number instructions executed 
benchmarks see increase 
happens due pulling invariant expressions belong infrequently executed loop infrequently executed path inside loop 
percentage decrease figures equal higher hopt version compared sopt version difference marked health significant graphics circuit em 
benchmarks recursive heap data structures heap read write sets bring added benefits 
see run time speedup alvinn vor water yacr 
speedup figures quite significant context scalar optimizations 
achieved gcc 
reduction memory instructions executed translates speedup speedup obtained direct proportion 
example yacr vor percentage decrease figures health circuit 
reason obtain better speedup source source transformations enable native compiler perform better instruction scheduling due substitution pointer scalars happens benchmarks 
reason instruction memory counts hopt version achieves better speedup sopt version 
studied effects optimizations context parallelized programs multithreaded architecture 
pointer involve remote memory accesses 
applying lir cse results better savings giving upto speedup 
improving array dependence tests scientific applications written arrays principal data structures 
fortran arrays implemented pointers dynamically allocated storage 
arrays passed pointer parameters 
pointer array pose new problems array dependence tester adt 
consider simple example loop variables static integer arrays declared int adt easily identify loop flow dependence loop carried dependences 
variables declared integer pointers point dynamically allocated storage statically allocated arrays situation complex 
adt assume syntactically different array independent 
example point heap object static array loop carried flow dependence pointer analyses easily check possibilities 
loop point different static arrays anchor handles connected situation identical static case 
measured effectiveness pointer analyses precise adt set programs described table 
benchmark collected adt statistics number array pairs tested ii number dependences detected iii number forall loops adt results 
clearly eliminate dependence tests possible test potentially expensive spurious tests may lead spurious dependences 
reducing number dependences beneficial better fine grain parallelism exposing forall loops 
forall loops lead coarse grain parallelism 
data shown table 
columns labeled respectively show numbers adt pointer information points connection information 
see significant reduction array pairs tested dependences detected 
able find forall loops blocks alvinn 
results indicate pointer analyses adt considerably effective 
fact commercial compilers portland group provide pragmas get similar information user indicate certain pointers share storage pointers arrays 
benchmarks array dependences broken fall loops forall loops 
see increase 
program understanding debugging summary read write information program understanding debugging aid 
example consider procedure foo struct list struct tree summary information foo fa foo index foo left foo foo fa foo index foo foo left program pairs deps forall blocks alvinn yacr sim eigen table results array dependence analysis foo 
information interesting observations effect function foo data structures passed 
absence foo set indicates function affect structure list add delete nodes modifies scalar field index nodes list foo index foo 
contrary presence foo left foo right set indicates left right pointer fields modified nodes tree 
imply new nodes added tree nodes deleted nodes simply swapped children 
experience benchmarks useful information negative information fields updated function information link pointer fields specially useful 
due hierarchical nature read write sets information obtained respect program constructs loops conditionals function calls 
nicely display information user developed tool uses web browser 
modified dump utility produce html version program statement decorated hyperlink cgi script passing unique statement id hidden parameter 
produced compressed files containing pointer analysis read write sets information statement id frames browser 
top frame displays kinds information available user click appropriate link see flow information 
sets file containing information current 
left frame displays program 
right frame workspace 
user clicks statement function cgi script written perl invoked statement function id argument 
looks id current displays information associated user friendly form right frame 
information displayed interesting hypertext links clicking field displays definition structure type 
clicking function prototype function call takes function body 
reader tool visiting web page www acaps cs mcgill ca ghiya info html 
summary read write information guide data prefetching recursive heap data structures indicates fields potentially accessed respect pointer inside function loop 
prefetch instructions placed fields function loop entry 
avoid prefetching fields reported reducing prefetch overhead 
similarly read field accesses considered run time constants useful information dynamic compilation context 
direct application connection information identification potential memory leaks 
heap directed pointer updated live pointer connected heap storage accessible inaccessible program 
programmer warned potential memory leak statement 
related summarized considerable amount done problem pointer analysis detailed description :10.1.1.40.9725
section concentrate summarizing methods results pointer analysis 
landi choi proposed approaches computing side effect information read write sets presence pointers 
approaches stack alias analysis 
points representation locations names computing read write sets quite straightforward slight modifications standard transformations needed shown section :10.1.1.25.6013:10.1.1.11.3368:10.1.1.22.4648
assume compilers pointsto analyses similar applications 
directly related methods results heap analysis 
area primarily focused dependence analysis parallelization 
important approaches include techniques path expressions name locations syntax trees name locations extending limited graphs location names dependence testing access paths theorem proving 
approaches attempt perform accurate analysis reason different parts data structure example determining left right possibly refers location right right 
taken general view potential uses heap analysis method coarse grain heap analysis distinguish data structures data structure 
terms improved read write sets pointer analysis analyses transformations relevant related wilson lam shapiro horwitz cooper lu :10.1.1.52.5364:10.1.1.22.4648
wilson lam pointer analysis results loop parallelization 
shapiro horwitz study effects various flow insensitive pointer analyses efficiency precision analyses live variable analysis gmod analysis actual program transformations 
cooper lu study benefits pointer analysis context register promotion 
focuses promoting address exposed global variables registers inside loops possible 
describe technique similar location invariant removal pointer array 
empirical results indicate significant decrease memory programs significant speedup 
considered subset study focus loops precise heap analysis malloc site naming approach provide real runtime speedups state art optimizing compiler comparing number operations executed collected simulator 
focused put pointer analysis 
demonstrated fundamental component computing read write sets 
briefly summarized computation read sets pointsto analysis store analysis focuses stack directed pointers 
importantly provided new method computing read write sets connection analysis heap analysis 
order achieve introduced notion anchor handles read write sets anchor handles 
stack heap read write sets demonstrated wide variety applications 
provided description scalar optimizations include optimizations computations pointers 
provided extensive static dynamic measurements including measuring runtime improvement due scalar optimizations 
examined effect accurate read write sets array dependence testers outlined uses read write sets including program understanding tool interfaces web browsers 
believe results show pointer analysis important part optimizing compiler achieve significant benefits analysis 
major directions 
firstly plan study effect stack heap read write sets fine grain parallelism instruction scheduling 
secondly compare benefit context sensitive flow sensitive analyses vs flow insensitive analyses 
plan continue develop new transformations pointer intensive programs 
aho sethi ullman 
compilers principles techniques tools 
addison wesley pub 
reading mass corrected edition 
auslander philipose chambers eggers bershad 
fast effective dynamic compilation 
proc 
acm sigplan conf 
programming language design implementation pages philadelphia penn may 
austin breach sohi 
efficient detection pointer array access errors 
proc 
acm sigplan conf 
programming language design implementation pages orlando flor june 
callahan carr kennedy 
improving register allocation subscripted variables 
proc 
sigplan conf 
programming language design implementation pages white plains june 
chase wegman zadeck 
analysis pointers structures 
proc 
sigplan conf 
programming language design implementation pages white plains june 

choi burke carini 
efficient flow sensitive interprocedural computation aliases side effects 
conf 
rec 
twentieth ann 
acm sigplan sigact symp 
principles programming languages pages charleston south carolina jan 
cooper lu 
register promotion programs 
proc 
acm sigplan conf 
programming language design implementation pages las vegas nev jun 
deutsch 
model aliasing abstractions finite representations right regular equivalence relations 
proc 
intl 
conf 
computer languages pages oakland calif apr 
deutsch 
interprocedural may alias analysis pointers limiting 
proc 
acm sigplan conf 
programming language design implementation pages orlando flor june 
emami ghiya hendren :10.1.1.25.6013
contextsensitive interprocedural points analysis presence function pointers 
proc 
acm sigplan conf 
programming language design implementation pages orlando flor june 
ghiya :10.1.1.40.9725
putting pointer analysis 
phd thesis school computer science mcgill university november 
preparation 
ghiya hendren 
connection analysis practical interprocedural heap analysis intl 
parallel programming pages 
ghiya hendren 
tree dag cyclic graph 
shape analysis heap directed pointers conf 
rec 
rd acm symp 
principles programming languages pages st petersburg flor jan 
jr technique analyzing pointer structure parallel restructuring compilers 
proc 
intl 
conf 
parallel processing volume ii pages st charles ill aug 
hendren emami gao sridharan 
designing mccat compiler family structured intermediate representations 
proc 
th intl 

languages compilers parallel computing number lec 
notes comp 
sci pages new haven conn aug 
springer verlag 
publ 

hendren nicolau 
parallelizing programs recursive data structures 
ieee trans 
parallel distrib 
systems jan 
horwitz pfeiffer reps dependence analysis pointer variables 
proc 
sigplan conf 
programming language design implementation pages portland ore jun 
hummel hendren nicolau 
general data dependence test dynamic pointer data structures 
proceedings acm sigplan conference programming language design implementation pages orlando flor june 
landi ryder 
safe approximate algorithm interprocedural pointer aliasing 
proc 
acm sigplan conf 
programming language design implementation pages san francisco calif jun 
landi ryder zhang 
interprocedural modification side effect analysis pointer aliasing 
proc 
acm sigplan conf 
programming language design implementation pages albuquerque mex jun 
hendren 
extended ssa numbering introducing ssa properties languages multi level pointers 
proceedings cascon toronto ontario nov 
larus hilfinger 
detecting conflicts structure accesses 
proc 
sigplan conf 
programming language design implementation pages atlanta georgia jun 
larus schnarr 
eel machineindependent executable editing 
proc 
acm sigplan conf 
programming language design implementation pages la jolla calif jun 

luk mowry 
compiler prefetching recursive data structures 
proc 
seventh intl 
conf 
architectural support programming languages operating systems pages cambridge mass oct 
rogers carlisle reppy hendren 
supporting dynamic data structures distributed memory machines 
acm trans 
programming languages systems mar 
ruf 
context insensitive alias analysis reconsidered 
proc 
acm sigplan conf 
programming language design implementation pages la jolla calif jun 
sagiv reps wilhelm 
solving problems languages destructive updating 
conf 
rec 
rd acm symp 
principles programming languages pages st petersburg flor jan 
shapiro horwitz :10.1.1.52.5364
effects precision pointer analysis 
proceedings static analysis symposium paris france sep 
shapiro horwitz 
fast accurate points analysis 
conf 
rec 
th acm sigplan sigact symp 
principles programming languages pages paris france jan 
stallman 
porting gnu cc 
cambridge mass jun 
available anonymous ftp prep ai mit edu 
steensgaard 
points analysis linear time 
conf 
rec 
rd acm symp 
principles programming languages pages st petersburg flor jan 
tang ghiya hendren gao 
heap analysis optimizations threaded programs 
proc 
conf 
parallel architectures compilation techniques pact san francisco calif nov 
wilson lam :10.1.1.22.4648
efficient context sensitive pointer analysis programs 
proc 
acm sigplan conf 
programming language design implementation pages la jolla calif jun 
woo gupta 
splash programs characterization methodological considerations 
proc 
nd ann 
intl 
symp 
computer architecture pages santa margherita ligure italy jun 
zhang ryder landi 
program decomposition pointer aliasing step practical analyses 
proceedings th symposium foundations software engineering october 
