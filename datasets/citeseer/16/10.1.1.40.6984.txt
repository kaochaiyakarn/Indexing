mining association rules sets items large databases rakesh agrawal tomasz imielinski arun swami ibm almaden research center harry road san jose ca large database customer transactions 
transaction consists items purchased customer visit 
efficient algorithm generates significant association rules items database 
algorithm incorporates buffer management novel estimation pruning techniques 
results applying algorithm sales data obtained large shows effectiveness algorithm 
consider supermarket large collection items 
typical business decisions management supermarket include put sale design coupons place merchandise shelves order maximize profit analysis past transaction data commonly approach order improve quality decisions 
global data cumulative sales time period day week month available computer 
progress bar code technology possible store called basket data stores items purchased transaction basis 
basket data type transactions necessarily consist items bought point time 
may consist items bought customer period time 
examples include monthly purchases members book club music club 
current address computer science department rutgers university new brunswick nj permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission association computing machinery 
copy republish requires fee special permission 
proceedings acm sigmod conference washington dc usa may organizations collected massive amounts data 
data sets usually stored tertiary storage slowly migrating database systems 
main reasons limited success database systems area current database systems provide necessary functionality user interested advantage information 
introduces problem mining large collection basket data type transactions association rules sets items minimum specified confidence presents efficient algorithm purpose 
example association rule statement transactions purchase bread butter purchase milk 
antecedent rule consists bread butter consequent consists milk 
number confidence factor rule 
reported viewed step enhancing databases functionalities process queries omitted confidence factor specification ffl find rules diet coke consequent 
rules may help plan store boost sale diet coke 
ffl find rules antecedent 
rules may help determine products may impacted store selling 
ffl find rules sausage antecedent consequent 
query phrased alternatively request additional items sold sausage order highly sold 
ffl find rules relating items located shelves store 
rules may help shelf planning determining sale items shelf related sale items shelf ffl find best rules consequent 
best formulated terms confidence factors rules terms support fraction transactions satisfying rule 
organization rest follows 
section give formal statement problem 
section algorithm mining association rules 
section performance results showing effectiveness algorithm applying algorithm data large 
section discuss related 
particular put context rule discovery ai 
conclude summary section 
formal model 
set binary attributes called items 
database transactions 
transaction represented binary vector bought item 
tuple database transaction 
set items say transaction satisfies items 
association rule mean implication form set items single item rule satisfied set transactions confidence factor iff transactions satisfy satisfy notation specify rule confidence factor set transactions interested generating rules satisfy certain additional constraints different forms 
syntactic constraints constraints involve restrictions items appear rule 
example may interested rules specific item appearing consequent rules specific item appearing antecedent 
combinations constraints possible may request rules items predefined itemset appearing consequent items itemset appearing antecedent 

support constraints constraints concern number transactions support rule 
support rule defined fraction transactions satisfy union items consequent antecedent rule 
support confused confidence 
confidence measure rule strength support corresponds statistical significance 
statistical significance motivation support constraints comes fact usually interested rules support minimum threshold business reasons 
support large means rule worth consideration simply preferred may considered 
formulation problem rule mining decomposed subproblems 
generate combinations items fractional transaction support certain threshold called minsupport 
call combinations large itemsets combinations meet threshold small itemsets 
syntactic constraints constrain admissible combinations 
example rules involving item antecedent interest sufficient generate combinations contain 
large itemset 
generate rules rules items set 
antecedent rules subset gamma items consequent item gamma generate rule 
gamma 
take support divide support ratio greater rule satisfied confidence factor 
note itemset large subset large available support counts result solution subproblem 
rules derived satisfy support constraint satisfies support constraint union items consequent antecedent rule 
having determined large itemsets solution second subproblem straightforward 
section focus subproblem 
develop algorithm generates subsets set items satisfy transactional support requirement 
task efficiently estimation tools pruning techniques 
discovering large itemsets shows template algorithm finding large itemsets 
set items itemset items said extension itemset 
parameter total number tuples database 
algorithm multiple passes database 
frontier set pass consists itemsets extended pass 
pass support certain itemsets measured 
itemsets called candidate itemsets derived tuples database itemsets contained frontier set 
associated itemset counter stores number transactions corresponding itemset appeared 
counter initialized zero itemset created 
procedure large set frontier set gamma gamma pass database candidate set forall database tuples forall itemsets contains candidate itemsets extensions contained gamma gamma see section forall itemsets count count count gamma gamma consolidate forall itemsets count minsupport frontier gamma gamma see section pass template algorithm initially frontier set consists element empty set 
pass support candidate itemset compared minsupport determine large itemset 
time determined itemset added frontier set pass 
algorithm terminates frontier set empty 
support count itemset preserved itemset added large frontier set 
specify template algorithm candidate itemsets measured pass candidate itemsets frontier pass 
topics covered 
number passes versus measurement wastage straightforward version algorithm itemset tuples measured pass terminating algorithm pass 
worst case approach require setting counters corresponding subsets set items number items course infeasible easily supermarket setting unnecessary 
large itemsets containing items small 
lot combinations turn small anyway 
better approach measure kth pass itemsets contain exactly items 
having measured itemsets kth pass need measure th pass itemsets extensions itemset extended exactly item large itemsets kth pass 
itemset small extension going small 
frontier set pass set candidate itemsets determined large current pass extensions frontier itemset generated measured pass 
alternative represents extreme passes database 
extreme approaches illustrate tradeoff number passes wasted effort due measuring itemsets turn small 
certain measurement wastage unavoidable itemset large measure ab determine large small 
having determined ab small unnecessary measure abc abd abcd aside practical feasibility measure large number candidate itemsets pass may turn small generalization approach measure extensions frontier itemsets pass 
frontier set pass consist large candidate itemsets precisely extensions 
generalization reduces number passes may result itemsets unnecessarily measured 
wasted effort 
hand measure small number candidates turn large need pass may necessary 
need careful estimation deciding candidate itemset measured pass 
determination candidate itemsets may think measure current pass extensions frontier itemsets expected large 
case data behaved expectations itemsets expected large turn large need pass database determine support extensions large itemsets 
avoid situation addition extensions frontier itemsets expected large measure extensions expected small expected large contains frontier itemset 
measure extensions itemsets 
rationale choice predictions correct turns small superset measured 
additional pass needed data behave expectation turns large 
reason measuring expected small mistake data agrees predictions extra pass database necessary 
expected support itemset statistical independence assumption estimate support itemset 
suppose candidate itemset extension frontier itemset 
suppose itemset appears total tuples 
know value measured previous pass taken empty frontier itemset 
suppose considered candidate itemset time tuples containing processed current pass 
denoting relative frequency item database expected support itemset theta theta 
theta theta gamma note gamma actual support remaining portion database 
statistical independence assumption expected support product support individual relative frequencies items minsupport say expected small expected large 
candidate itemset generation procedure itemset tuples database candidate measurement 
read tuple time database check frontier sets contained tuple read 
candidate itemsets generated frontier itemset extending recursively items tuple 
itemset expected small extended 
order replicate different ways constructing itemset items ordered itemset tried extension items ordering members shows candidate itemsets generated frontier itemset database tuple 
procedure extend itemset tuple item forall items tuple output xi xi expected large extend xi extension frontier itemset example fa fg assume items ordered alphabetic order 
assume frontier set contains itemset ab 
database tuple candidate itemsets generated abc expected large continue extending abcd expected small extend expected large extended abd expected small extend abf expected large extended extension considered abcd expected small 
similarly considered abd expected small 
itemsets abf expected large extended item greater extensions abce abe considered item determination frontier set deciding itemsets put frontier set turns somewhat tricky 
may think sufficient select just maximal terms set inclusion large itemsets 
choice incorrect may result algorithm missing large itemsets example illustrates suppose extended frontier set ab shown example previous subsection 
abd abcd turned large pass 
abd non maximal large itemset frontier mistake consider large lose completeness 
include frontier set pass candidate itemsets expected small turned large current pass 
see itemsets need include frontier set state lemma lemma 
candidate itemset expected small current pass database extension candidate itemset pass 
lemma holds due candidate itemset generation procedure 
consequently know extensions itemsets including frontier set considered current pass 
itemsets large may produce extensions large 
itemsets included frontier set pass 
lead redundancy extensions measured far 
additionally complete 
candidate itemset large expected small frontier set pass way algorithm defined extensions itemset considered pass 
candidate itemset small included frontier set support extension itemset support itemset 
memory management discuss enhancements handle fact may memory store frontier candidate itemsets pass 
large itemsets need memory pass database disk resident 
assume memory store itemset extensions 
tuple frontier itemset generate candidate itemsets extending 
may happen run memory ready generate extension create space memory extension 
procedure gamma gamma obtain memory frontier set memory reclaimed itemset frontier set extension generated move disk break memory reclaimed return gamma gamma obtain memory deleting gamma gamma candidate itemsets find candidate itemset having maximum number items discard siblings parent frontier set move disk disable extensions pass memory reclamation algorithm shows memory reclamation algorithm 
said parent generated extending frontier set extensions itemset called siblings 
attempt room new itemset writing disk frontier itemsets extended 
failing attempt discard candidate itemset having maximum number items 
siblings discarded 
reason parent itemset included frontier set pass 
siblings anyway generated pass 
may avoid building counts pass elaborate book keeping required expensive 
reason disable extensions parent itemset pass 
parent candidate itemset continues measured 
hand parent frontier itemset written disk creating memory space 
possible current itemset caused memory shortage having maximum number items 
case candidate itemset needs deleted current itemset siblings ones deleted 
candidate itemset items itemset siblings deleted 
cases memory reclamation algorithm succeeds releasing sufficient memory 
addition candidate itemsets expected small turn large frontier set pass additionally includes ffl disk resident frontier itemsets extended current pass ffl itemsets candidate frontier children deleted reclaim memory 
frontier set large fit memory start pass putting frontiers fit memory fraction 
shown memory store frontier itemset measure extensions pass guaranteed forward progress algorithm terminate 
pruning count remaining tuples pass possible pass determine candidate itemset eventually turn large discard early 
pruning saves memory measurement effort 
refer pruning remaining tuples optimization 
suppose candidate itemset extension frontier itemset itemset appears total tuples discussed section known 
suppose cth tuple containing time processing tuple count tuples including tuple containing means left gamma tuples may appear 
compare gamma minsupport theta 
smaller bound small pruned right away 
remaining tuples optimization applied soon new candidate itemset generated may result immediate pruning itemsets 
possible candidate itemset initially pruned may satisfy pruning condition tuples processed 
prune old candidate itemsets apply pruning test tuple containing itemset processed increment support count itemset 
pruning synthesized pruning functions consider technique prune candidate itemset soon generated 
refer pruning pruning function optimization 
pruning function optimization motivated possible pruning functions total transaction price 
total transaction price cumulative function associated set items sum prices individual items set 
know minsupport fraction transactions bought dollars worth items immediately eliminate sets items total price exceeds itemsets measured included set candidate itemsets 
general know pruning functions 
synthesize pruning functions available data 
pruning functions synthesize form 
wm jm binary valued weights selected follows 
order individual items decreasing order frequency occurrence database 
weight ith item order gamma ffl ffl small real number 
shown certain mild assumptions pruning function weights optimal pruning value prune largest number candidate itemsets 
separate pruning function synthesized frontier itemset 
functions differ values transaction support item xy support itemset pruning function associated frontier set determine expansion added candidate itemset pruned right away 
represent value expression 
wm jm tuple frontier itemset need procedure establishing count tuple contains minsupport 
having determined frontier itemsets pass want separate pass data just determine pruning functions 
collect item pair frequency frequency itemset comprising items holds frequency frequency 
information determining itemset candidate itemset measured anticipation may frontier itemset pass 
fortunately know candidate itemsets expected small ones frontier set 
need collect information itemsets candidate itemsets 
straightforward procedure determining itemset maintain minsupport number largest values tuples containing information collected time support count measured pass 
procedure require memory maintaining minsupport number values candidate itemset expected small 
possible save memory cost losing precision establishing somewhat larger value 
implementation uses memory saving technique discuss due space constraints 
recall discussed section memory limited candidate itemset children deleted current pass frontier itemset 
general children candidate itemset deleted middle pass collecting information itemset 
itemsets inherit value parents frontier 
experiments experimented rule mining algorithm sales data obtained large 
total customer transactions data 
transaction contains department numbers customer bought item visit 
total departments 
algorithm finds association departments customer purchasing behavior 
rules minimum support minimum confidence 
rules written form ij confidence support expressed percentage 
tires automotive services auto accessories tires automotive services auto accessories automotive services automotive services auto accessories home laundry appliances maintenance agreement sales children infants children wear men furnishing men worst case problem exponential problem 
consider database items item appears transaction 
case large itemsets 
give idea running time algorithm actual data give timings ibm rs workstation finding rules real user sys conducted experiments asses effectiveness estimation pruning techniques sales data 
report results experiments 
effectiveness estimation procedure measure pass itemsets expected large 
addition measure itemsets expected small large 
rely estimation procedure section determine itemsets 
estimation procedure itemsets expected large small turn large small 
define accuracy estimation procedure large small itemsets ratio number itemsets turn large small number itemsets estimated large small 
estimation accuracy close 
small values estimation accuracy large itemsets indicate measuring unnecessary itemsets pass wasted measurement effort 
small values estimation accuracy small itemsets indicate stopping early candidate generation procedure measuring itemsets pass possible extra passes data 
shows estimation accuracy large small itemsets different values minsupport 
experiment turned remaining tuple pruning function optimizations isolate effect estimation procedure 
graph shows estimation procedure works quite algorithm measures little pass 
note accuracy estimation procedure higher data behaves expectation statistical independence 
words data boring itemsets expected small turn large algorithm terminate passes 
hand surprising data lower estimation accuracy passes take algorithm terminate 
behavior quite reasonable waiting longer pays form unexpected new rules 
repeated experiment remaining tuple pruning function optimizations turned 
accuracy figures somewhat better closely tracked curves 
minimum support database estimation accuracy small large accuracy estimation procedure minimum support database pruning efficiency remaining tuple new remaining tuple old pruning function efficiency pruning techniques effectiveness pruning optimizations define efficiency pruning technique fraction itemsets prunes 
stated section remaining tuple optimization applied new candidate itemsets soon generated 
unpruned candidate itemsets added candidate set 
remaining tuple optimization applied older candidate itemsets increment support count 
shows efficiency remaining tuple optimization technique types itemsets 
new itemsets pruning efficiency ratio new itemsets pruned total number new itemsets generated 
old itemsets pruning efficiency ratio old candidate itemsets pruned total number candidate itemsets added candidate set 
experiment run pruning function optimization turned 
clearly remaining tuple optimization prunes large fraction itemsets new old 
pruning efficiency increases increase minsupport itemset needs larger number transactions eventually large set 
candidate set contains itemsets expected large expected small 
remaining tuple optimization prunes old candidate itemsets expected small bears candidate itemsets expected large turn large 
initially large increase fraction itemsets expected small candidate set minsupport increases 
reason initially large jump pruning efficiency old candidate itemsets minsupport increases 
shows efficiency pruning function optimization remaining tuple optimization turned 
plots fraction new itemsets pruned due optimization 
effectiveness optimization increases increase minsupport smaller value note technique quite effective pruning new candidate itemset 
measured pruning efficiencies new old itemsets remaining tuple pruning function optimizations turned 
curves combined pruning tracked closely curves remaining tuple optimization 
pruning function optimization prune old candidate itemsets 
high pruning efficiency obtained new itemsets just remaining tuple optimization surprising slight additional improvement pruning function turned 
noted remaining tuple optimization cheaper optimization 
related discovering rules data topic active research ai 
rule discovery programs categorized find quantitative rules find qualitative laws 
purpose quantitative rule discovery programs automate discovery numeric laws type commonly scientific data boyle law pv problem stated follows variables 
xm groups observational data 
set values variable find formula 
xm best fits data symbolically reveals relationship variables 
formulas fit data domain knowledge generally provide bias formulas appropriate domain 
examples known systems category include abacus bacon 
business databases reflect uncontrolled real world different causes overlap patterns exist 
rules data uncertainty 
qualitative rule discovery programs targeted business data generally little domain knowledge 
considerable discovering classification rules examples belong prespecified classes discover rules classifying 
classic area include 
algorithm propose targeted discovering qualitative rules 
rules discover classification rules 
pre specified classes 
find rules describe association sets items 
algorithm called kid algorithm discover kind association rules considered 
kid algorithm fairly straightforward 
attributes restricted binary algorithm 
find rules comprising antecedent specific value attribute pass data transaction record hashed values hash cell keeps running summary values attributes tuples identical value 
summary derive rules implied pass 
find rules different fields algorithm run field 
means interested finding rules passes data number combinations attributes antecedent exponentially large 
algorithm linear number transactions database 
valiant deals learning boolean formulae 
rules viewed boolean implications 
learnability theory deals mainly worst case bounds possible probabilistic distribution 
hand interested developing efficient solution actual performance results problem clearly exponential worst case behavior number itemsets 
database community inferring functional dependencies data efficient inference algorithms 
functional dependencies specific predicate rules rules propositional nature 
contrary framework algorithms consider strict satisfaction rules 
due strict satisfaction algorithms take advantage implications rules consider rules logically implied rules discovered 
having inferred dependency dependency form considered redundant generated 
summary introduced problem mining association rules sets items large database customer transactions 
transaction consists items purchased customer visit 
interested finding rules ffl minimum transactional support union items consequent antecedent rule minimum transactions database 
ffl minimum confidence transactions database satisfy antecedent rule satisfy consequent rule 
rules discover item consequent union number items antecedent 
solve problem decomposing subproblems 
finding itemsets called large itemsets transactions 

generating large itemset rules items large itemset 
having obtained large itemsets transactional support count solution second subproblem straightforward 
simple solution subproblem form itemsets obtain support pass data 
solution computationally infeasible items database possible itemsets easily 
algorithm propose features ffl uses carefully tuned estimation procedure determine itemsets measured pass 
procedure strikes balance number passes data number itemsets measured pass 
measure large number itemsets pass turn small wasted measurement effort 
conversely measure small number itemsets pass turn large may unnecessary passes 
ffl uses pruning techniques avoid measuring certain itemsets guaranteeing completeness 
itemsets algorithm prove turn large 
pruning techniques 
called remaining tuple optimization uses current scan position counts prune itemsets soon generated 
technique establishes pass progress itemsets measured eventually turn large prunes 
technique called pruning function optimization synthesizes pruning functions pass pass 
pruning functions prune itemsets soon generated 
ffl incorporates buffer management handle fact itemsets need measured pass may fit memory pruning 
memory fills certain itemsets deleted measured pass way completeness maintained redundancy sense itemset completely measured guaranteed progress algorithm terminates 
tested effectiveness algorithm applying sales data obtained large 
data set algorithm exhibited excellent performance 
estimation procedure exhibited high accuracy pruning techniques able prune large fraction itemsets measuring 
reported done context quest project ibm almaden research center 
quest exploring various aspects database mining problem 
problem discovering association rules problems looked include enhancement database capability classification queries queries large sequences 
believe database mining important new application area databases combining commercial interest intriguing research questions 
acknowledgments 
mike help obtaining data performance experiments 
cochrane bill cody christos faloutsos joe halpern comments earlier version 
rakesh agrawal tomasz imielinski arun swami database mining performance perspective ieee transactions knowledge data engineering special issue learning discovery knowledge databases appear rakesh agrawal ghosh tomasz imielinski bala iyer arun swami interval classifier database mining applications vldb vancouver british columbia 
dina bitton bridging gap database theory practice cadre technologies menlo park 
breiman friedman olshen stone classification regression trees wadsworth belmont 
falkenhainer michalski integrating quantitative qualitative discovery abacus system machine learning 
discovering functional formulas changing representation base proceedings fifth national conference artificial intelligence 
langley simon bradshaw zytkow scientific discovery computational explorations creative process mit press cambridge mass 
heikki mannila kari dependency inference vldb brighton england 
ross quinlan induction decision trees machine learning 
piatetsky shapiro discovery analysis presentation strong rules 
piatetsky shapiro editor knowledge discovery databases aaai mit press 
valiant theory learnable cacm 
valiant learning disjunctions conjunctions ijcai los angeles 
yi hua wu wang discovering functional relationships observational data 

