proceedings acm sigplan conferenceon design implementation san francisco california june pages 
copyright fl acm see notice 
abstractions recursive pointer data structures improving analysis transformation imperative programs copyright fl association computing machinery permission digital hard copies part personal classroom granted fee provided copies distributed profit direct commercial advantage copies bear notice full citation page 
copyrights components owned acm honored 
abstracting credit permitted 
copy republish post servers redistribute lists requires prior specific permission fee 
request permissions publications dept acm fax permissions acm org 
laurie hendren school computer science mcgill university joseph hummel alexandru nicolau dept information computer science uc irvine impressive progress area optimizing parallelizing programs arrays application similar techniques programs pointer data structures remained difficult 
introduce new approach leads improved analysis transformation programs recursively defined pointer data structures 
approach mechanism description data structures adds explicit important properties dimensionality pointer data structures 
numerous examples demonstrate adds definitions natural specify flexible describe complex cyclic pointer data structures 
discuss data structure description improve program analysis presenting analysis approach combines alias analysis technique path matrix analysis information available adds declaration 
improved alias analysis technique provide concrete example applying software pipelining transformation loops involving pointer data structures 
motivation key problems facing optimizing parallelizing compilers imperative programming languages alias analysis detecting supported part fcar nserc mcgill faculty graduate studies research 
direct correspondence author ics uci edu 
supported part nsf ccr onr 
distinct memory accesses may refer physical memory location 
alias analysis critical component compilers effectiveness compiler analysis techniques code improving transformations rely accurate alias analysis 
current trend vector risc superscalar architectures optimizing compilers important efficient execution need accurate analysis grow 
scientific codes target optimizing parallelizing compilers 
codes typically arrays storing data loops regular indexing properties manipulate arrays 
deal done area analysis transformation presence arrays loops result numerous techniques developed example invariant code motion induction variable elimination loop unrolling vectorization lov dh pw ak asu zc various instruction scheduling strategies software pipelining rg lam en 
unfortunately codes utilize dynamically allocated pointer data structures difficult analyze progress area 
problematic numerous data structures imperative programs trees example typically built recursively defined pointer data structures 
furthermore data structures symbolic processing classes scientific codes computational geometry sam called tree codes app bh 
goal investigate analysis pointer data structures difficult analysis array suggest new mechanism describing pointer data structures show better descriptions data structures lead improved analysis transformation imperative programs 
problem motivate problem consider code fragments shown upper code fragment adds element element array arrays property refer different locations compiler immediately determine code fragment iteration different location arrays usually statically allocated straightforward determine arrays different objects 
refer location implying loop invariant 
observations allow compiler perform number transformations including loading register loop begins transforming loop unrolling applying software pipelining 

null data data data arrays versus linked lists 
consider lower code fragment operates linked list 
code traverses list step adds value data node currently visited 
case properties structure obvious code fragment 
example guarantee list acyclic safely determine iteration loop refers different node application loop transformations difficult 
secondly nodes dynamically allocated difficult determine refer node 
compiler unable detect data loop invariant 
result code fragment performs similar function array version traditional optimizing parallelizing compilers unable apply similar transformations 
previous currently approaches dealing problem alias analysis presence pointer data structures assume conservative case pointers nodes potential aliases analyze parts program attempt treat local variables arrays size pointers 
automatically discover underlying properties data structures relationship pointers nodes require code annotations 
approach far common backup significant approach 
class solutions development advanced alias analysis techniques called structure estimation techniques attempt statically approximate data structures abstraction 
commonly abstraction limited graphs jm variations limited graphs lh lh hpr cwz 
major disadvantage techniques approximation introduces cycles abstraction list tree data structures distinguished data structures truly contain cycles 
chase cwz addressed problem degree method fails find accurate structure estimates presence general recursion 
serious drawback programs recursively defined data structures recursion 
method path matrix analysis designed specifically deal distinguishing tree data structures dag shared graph cyclic structures hn hen 
analysis uses special properties exhibited structures provide accurate analysis list tree structures presence recursion 
disadvantage handle cyclic structures cyclic nature hamper optimizing parallelizing transformations 
related approaches include traditional dependence analysis assumes structures cycles interpretation techniques harrison har presents technique designed list structures commonly scheme programs developing uniform mechanism handling symbolic data arrays notion generalized iteration space har 
general methods certain classes pointer data structures fail presence general possibly cyclic structures recursion 
code annotations represent compromise programmer specify compiler determine 
code annotations difficult due varied kinds information conveyed compiler 
example programmer may need specify data dependencies lar transformation apply con distinctness data kkk 
compiler typically takes annotations blind faith unable warn programmer coding change invalidates annotation true lar con kkk suggested system perform dynamic checks provided programmer uniquely tags node 
annotations repeated program maximize performance 
approach past experience developing alias analysis techniques tree structures failure techniques find accurate information general structures believe lack appropriate data structure descriptions serious impediment improvement analysis techniques 
studying wide range imperative pointer data structures developed approach describing feel important properties structures important sense enabling numerous optimizing parallelizing transformations 
current imperative programming languages provide mechanisms expressing kind information approach called adds provides programmer mechanism description data structures 
adds minor addition imperative programming languages designed ffl simple programmer ffl minimize localize program annotation ffl describe complex pointer data structures ffl enable powerful transformations 
properties expressed data structure descriptions increase accuracy effectiveness existing analysis techniques 
allows application powerful optimizing parallelizing transformations may lead development new pointer specific transformations 
asking programmer specify properties data structures considered radical change way thinking programming imperative programming languages 
pointer data structures domain programmers convey quite bit implicit information data structures 
example consider recursive type declarations type bintree int data bintree left bintree right type int data prev noted larus lar discussed similar approach lisp approach required code type annotations described acyclic structures code fragments modify structure 
type declarations appear identical compiler declares record fields integer recursive pointers naming conventions imply different structures readers program 
addition structure nice properties compiler exploit 
binary tree naturally subdivides disjoint subtrees operated parallel 
twoway linked list property traversal forward direction field visits node twice likewise traversals prev field property visiting node twice enables parallelization node processing list 
idea adds simply implicit information explicit compiler 
positive side effects may increased human understanding programs compiler ability generate run time checks ensure proper dynamic data structures 
note fortran taken similar stance treatment pointers variables 
variables accessible pointers explicitly declared pointers targets 
simple declaration greatly improves accuracy alias analysis presence pointers 
note presence description mechanism adds 
side effects imperative programs rearrange components data structure causing temporary intentional invalidation properties wish exploit 
application optimizing parallelizing transformations rely properties time incorrect intolerable 
form data structure validation analysis alias analysis necessary ensure correctness enhance debugging 
remainder viewpoint 
recursive pointer data structures regardless complexity typically contain substructures exhibit regular properties exploited purpose program analysis transformation 
ability express properties explicitly important step long term goal accurate efficient program analysis presence cyclic pointer data structures 
organization follows 
sections address problem expressing regular properties recursive pointer data structures 
section adds series intuitive increasingly complex examples section define properties adds data structures formally 
section discuss information provided adds improve analysis transformation programs particular demonstrate adds enables application software pipelining list traversal loop 
section 
adds description data structures transformation codes involving data structures requires knowledge properties exhibited structure shape size method element access 
arrays properties readily identifiable 
shape array fixed declared compile time size known time creation compile time locations referenced integer indices 
example statement form compiler guaranteed refers different elements execution contrast user defined pointer data structures properties explicit 
array example simple traversal statement prevent compiler determining denotes different element execution element 
section shall mechanism adds describing feel important properties recursive pointer data structures shape sense direction 
intuitive summary properties demonstrate series increasingly complex examples properties captured adds 
postpone formal definition adds section 
dimensions directions pointer data structures suppose recursive pointer data structure wish describe shape 
consider structure general form select node origin doesn matter node choose choices sense root tree versus leaf 
think structure having dimensions different paths emanating origin typically dimension path 
select node origin recursive pointer field decide dimension traverses direction 
forward direction implies traversing moves unit away origin backward implies traversing moves unit back origin 
field limited traversing dimension direction restriction overcome difficulty 
default structure dimension assumed recursive pointer fields traverse unknown direction 
idea override default provide specific information 
example specify singly linked list dimension recursive pointer field traverses forward direction 
illustrated way linked list best described having single dimension traversing forward prev traversing backward prev differentiate list general list introduce notion field traversing uniquely forward implies node node points syntactically adds declaration way linked list look type int data uniquely forward prev backward binary tree thought having dimensions left right reasons soon apparent shall consider binary tree having dimension 
important property binary tree trees general node subtrees disjoint 
information expressed saying left right fields combined traverse uniquely forward manner 
formally left right exhibit property left right points node 
motivation choosing dimension describe binary tree support notion parent pointers field refers left right child back parent 
pictorially view binary tree parent pointers adds declaration type int data left right uniquely forward parent backward note declaring left right expressing notion combined traversal 
flexibility adds illustrated exotic recursive pointer data structures 
typically structures exhibit multiple dimensions dimensions independent disjoint dependent 
example orthogonal list sta implement sparse matrices dependent dimensions dimensional array represents back say dependent traversal traversal may lead common node substructure 
example traversing may lead node 
dimensions dependent notice orthogonal lists possess regular properties 
example traversing forward forward guaranteed visit node twice 
row disjoint parallel traversals different rows visit node likewise columns dimension 
properties captured adds declaration declaring fields uniquely forward type int data uniquely forward back backward uniquely forward backward note stated dimensions case considered dependent 
conservative nature intentional 
similar data structure independent dimensions list lists 
consider illustrates list lists including back pointers dimension back note node may accessed forward traversal dimension dimension identical situation binary trees 
considered independent conveyed adds declaration type int data uniquely forward back backward uniquely forward backward interesting dimensional structure dependent independent dimensions dimensional range tree sam answer queries find points interval find points bounding rectangle 
illustrated binary tree binary trees leaves tree linked form way linked list leaves sub dimensions leaves dependent leaf node reached forward traversal dimension leaves dimension 
observe sub independent leaves 
node accessed forward traversal sub accessed forward traversal leaves 
leads declaration type sub leaves sub sub leaves int data left right uniquely forward subtree uniquely forward sub uniquely forward leaves prev backward leaves note union variant record save space overlaying storage left right prev 
done loss expressive power 
lastly consider common cyclic data structure circular linked list type structure problematic single field essentially purposes traversing uniquely forward circling 
declaration type cirl int data cirl unknown equivalent saying default unknown nature prevents compiler performing possible optimizing parallelizing transformations statement compiler conservatively assume aliases 
solution provide explicit declaration accurately reflects properties circular list type cirl int data int union cirl uniquely forward cirl unknown un obviously may require clumsy coding practices 
second solution extend adds type direction circular declare traversing direction type cirl int data cirl circular solution desirable declaration require change coding program 
needs know length list order perform accurate alias analysis generally unavailable compile time 
implies information collected maintained runtime considered 
speculative cases data structure declared adds required speculatively traversable hg 
property allows traverse past data structure causing run time error 
automatically supported compiler places additional burden programmer programming practices name null arbitrary integer 
property analogous computing array index outside bounds array 
useful applying various optimizing parallelizing transformations 
summary adds summary adds technique abstractly describing important properties large class useful data structures 
known properties exploited compiler analysis transformation purposes 
default structure dimension recursive pointer fields traverse unknown fashion 
programmer may refine describing additional dimensions interaction dimensions various fields traverse dimensions 
illustrated examples choice dimensions directions quite intuitive adds place heavy burden programmer 
noted programming language compilers directly support data structures predefined data types see gro tool generates context free grammar description adts graph structures sol implementation parallelizable lists 
quick survey literature data structures text sta reveal wide variety important pointer data structures 
implementations structures differ widely 
trying predefine common types pointer data structures constrain implementation chose opposite approach develop technique allows programmer define implement data structures 
believe adds flexible describe important properties nearly pointer data structures providing com piler information necessary enable powerful optimizing parallelizing transformations 
formal properties adds section overview formal properties adds data structures 
definitions crucial understanding ideas show adds approach properties 
definition summarize importance property defined 
reader comfortable intuitive definitions section section safely skipped 
data structure declaration recursive pointer fields 
number programmer specified dimensions dimensions denoted recursive pointer fields denoted fn recursive pointer field may traverse dimension directions forward backward unknown 
pn denotes dynamically allocated node type pn null denotes dynamically allocated node type reached traversing pointer stored field pn traversing series non null fields denoted regular expression notation ffl pn denotes node pn ffl pn denotes nodes pn pn ffl pn denotes nodes pn pn pn pn pn pn pn regular expression denotes list nodes may may contain duplicates 
list run time finite fields exists node pn denoted pn null duplicates 
denotes run time infinite list nodes case duplicates 
nodes pn thought forming single data structure pds type pds considered wellbehaved abstraction defined valid 
cases pds behaved pds modification abstraction ignored points program definitions assume behaved data structure 
def speculatively traversable fields nodes pn pn null pn valid traversal yields null 
treat null denoting typeless node system startup 
problem validation discussed section 
implication legal traverse past normally thought structure 
def traverses forward direction nodes pn list nodes denoted pn run time finite 
implication acyclic traversing visits node twice 
def traverses uniquely forward direction def holds distinct nodes pn pn 
pn pn null 
pn pn implication acyclic list traversing different nodes visits node 
def traverses unknown direction may exist node pn list nodes denoted pn run time infinite 
implication potentially cyclic traversing unpredictable visit node twice 
def field traverses backward direction exists field traverses forward direction 
def traverses uniquely forward direction traverses backward direction nodes pn 
pn null 
pn null 
pn pn implication traversing forms cycle null 
def traverse combined uniquely forward direction def holds def holds distinct nodes pn pn 
pn pn pn pn null 
pn pn pn pn null 
implication tree separate structure disjoint substructures 
def fields traverse combined uniquely forward direction def holds implication generalization def fields separate structure disjoint substructures 
def dimensions 
independent field traversing forward direction field traversing forward direction distinct nodes pn pn 
pn pn pn pn null 
pn pn pn pn null 
field uf traversing uniquely forward direction field traversing backward direction 
pn uf null 
pn list denoted pn uf pn pn pn null 
implication separate structure disjoint substructures uniquely forward backward cycles hold independent dimension 
def dimensions 
independent dependent def hold implication traversal lead node substructure 
analysis transformation adds principal goal adds improve analysis codes utilizing pointer data structures 
discussed section existing analysis approaches exhibit various limitations faced structures 
approach information available adds declarations guide analysis 
synergy data structure descriptions analysis technique provides general accurate approach 
example information dimensionality direction field traversals abstraction approximations freed estimating needless cycles formed forward backward directions dimension avoid making needless conservative approximations 
idea concrete 
analysis approaches initial assumptions properties important estimate tailor approximation domain analysis rules appropriately 
example choosing limited graphs approximation domain forced conservatively approximate non cyclic structures cycles implies approximation distinguish tree structures cyclic ones 
illustrate choice analysis depends type data structure consideration consider data types bintree type bintree int data bintree left bintree right type int data prev additional information types appear identical compiler sort analysis applied 
clearly analyses appropriate structure binary trees exhibit different properties way linked lists 
case way linked lists appropriate approximation paths nodes number links addition analysis rules traversing links lengthen paths analysis rules traversing prev links prev shorten paths 
approximation domain appropriate rules traversals easily inferred adds declaration says dimension field traverses uniquely forward field prev traverses backward 
consider binary trees 
case appropriate approximation paths going left right conservative approximation going left right 
traversing left right fields paths field traversal shortens path 
information expressed adds declaration states left right traverse uniquely forward dimension 
turn build appropriate approximation domain set analysis rules binary trees 
problem initial assumptions bias program analysis 
analysis starts weak assumptions resulting analysis overly conservative current situation structure estimation techniques 
initial assumptions valid class data structures applying analysis classes lead inaccurate conservative analysis case applying ordinary path matrix analysis cyclic structures 
appears crucial order perform accurate analysis presence wide variety data structures accurate information structure 
essence adds approach 
section show properties adds data structures improve accuracy program analysis enable application powerful optimizing parallelizing transformations 
particular section new approach combining adds existing analysis technique 
section demonstrate new application software pipelining possible approach 
program analysis discussed earlier presence description mechanism adds en able optimizing parallelizing transformations presence pointer data structures 
imperative programs routinely rearrange components structure points program abstraction parts thereof ignored compiler 
transformations may applied invalid assumptions causing incorrect code generation 
form abstraction validation analysis required enable transformation addition traditional alias analysis needed ensure transformation safely applied 
approach analysis problem combined safe analysis techniques conjunction adds declarations 
particular developing approach static analysis adds data structures extension path matrix analysis hn hen called general path matrix analysis 
path matrix analysis originally designed automatically discover exploit properties acyclic data structures 
help adds general path matrix analysis capable handling cyclic data structures 
general path matrix analysis computes program point path matrix pm estimates relationship pair live pointer variables pm function current path matrix program statement analysis 
entry pm denotes explicit path alias node pointed node pointed analysis attempt express possible paths nodes cyclic data structures soon overwhelm matrix 
paths explicitly traversed program captured pm remaining paths aliases deduced current state path matrix adds declarations 
abstraction validation analysis order validate adds declaration effect certain pointer statements path matrix compared original adds declaration 
particular statements form may change shape data structure 
turn may result violation declared abstraction 
generally error imperative program treated 
note abstraction invalid point program perform transformations rely validity necessary adds properties actual process validation scope idea follows 
adds course violation fact error 
warning programmer providing compiler switch enable warnings useful debugging tool 
declaration encoded series relationships various pointer fields node 
analysis path matrix denotes relationship fields illegal part abstraction deemed invalid entry added path matrix encoding violation 
program statement fixes relationship fields entry removed abstraction considered valid 
common example temporary break abstraction moving subtree node binary tree 
possible code fragment dest left src left src left null analysis statement obvious src dest share common subtree violates disjointness property binary tree 
violation immediately corrected usually case 
alias analysis alias analysis best explained example 
consider code fragment pointer variable hd denotes head way linked list nodes 
node represents point space contains coordinates 
code shifts origin hd subtracting point remaining points hd 
null hd hd hd 

alias matrix am compiler fails discover traverses list forward direction def holds analysis code overly conservative compiler assume cyclic hd values potential aliases node 
effect conservative alias analysis summarized alias matrix form entries denote aliasing loop definite aliases indicated possible aliases indicated 
observe entries denote form aliasing 
particular entry am hd indicates hd possible alias iterative values discussed section prevents number useful loop transformations 
suppose programmer declared linked list adds declaration please note just convenient way expressing aliases result path matrix analysis 
section 
assuming general path matrix analysis determines structure abstraction behaved valid start code fragment compiler acyclic nature field def infer statement visits node twice 
result general path matrix analysis produce path matrices denote top bottom just loop iteration loop analysis reached fixed point 
important difference path matrices previous alias matrix am replacement 
accurate information paths 
hd hd hd hd hd hd entry path matrix indicates path links paths explicitly encoded entry implicitly encoded entries adds declarations 
aliases explicitly encoded empty entry guarantees pointers aliases 
see adds declaration general path matrix analysis captured desired property pm necessary performing numerous optimizing parallelizing transformations hd aliases 
transformations optimizing parallelizing transformations come forms including ffl fine grain transformations improved instruction scheduling ffl loop transformations loop unrolling software pipelining ffl coarse grain transformations parallel execution code blocks 
application transformations typically requires accurate alias analysis 
shown previous subsection adds general path matrix analysis provide accuracy 
clearly aid fine grain transformations dependency analysis crucial 
transforming code operates data structure loop transformations typically require structure exhibit list properties coarse grain transformations typically require tree properties 
properties expressible adds 
earlier hg shown applicability loop unrolling dh scalar architectures 
example simple loop initialize node linkedlist showed speedup mips architecture list size unrolling see hg details timings 
section example powerful loop transformation software pipelining rg lam en 
current trend machines supporting higher degrees parallelism vliw superscalar type optimization offers larger speedups 
consider code fragment discussed previous subsection manipulates twoway linked list points 
equivalent loop body written pseudo assembly code null goto done load load hd sub store load goto saw earlier compiler analysis overly conservative compiler incorrectly assume hd values potential aliases node 
case data dependency graph shown constructed false dependencies 
result loop appears exhibit little parallelism iterations 
discussed data structure declared general path matrix analysis able determine fact hd iterative values aliases 
eliminate false dependencies loop appears sequence nearly independent parallelizable iterations 
exploit parallelism apply software pipelining 
need minimize effect loop carried dependence 
renaming move calling replace copy statement 
result semantically equivalent loop null goto done load load load hd sub store move goto iteration loop soon current iteration completes allowing dependency graph pseudo code 
loop bodies nearly overlap execution 
addition list speculatively traversable def safe swap increasing amount available parallelism 
hd aliases deduce hd loop invariant 
moved outside loop 
code incorporates mentioned transformations producing semantically equivalent loop load hd load null goto done load sub store move goto loop pipelined follows columns denote different iterations rows denote statements executing parallel boxed statement represents new parallel pipelined body loop 
result code exhibits theoretical speedup 
note copy statement removed part pipelining process enhanced copy propagation 
general software pipelining lead larger speedups depending characteristics loop body 
obviously actual speedup depends heavily target machine architecture 
shown numerous examples recursively defined pointer data structures exhibit important properties compilers exploit optimization parallelization purposes 
properties known programmer conveyed implicitly appropriate identifiers unavailable compiler 
lack information hinders accuracy alias analysis restricts transformations applied codes pointer data structures 
proposed description technique adds allows programmer state properties explicitly 
description recursive pointer data structure adds quite intuitive place excessive burden programmer 
combining adds general path matrix analysis demonstrated resulting approach enables accurate general alias analysis application powerful optimizing parallelizing transformations 
seen software pipelining transformation 
adds represents important step longterm goal efficient compiler analysis codes involving cyclic pointer data structures 
adds simple extension imperative programming language lead analysis transformations possible traditional methods 
increasing languages support pointers recursively defined pointer data structures importance approach doubt increase 
ak randy allen ken kennedy 
automatic translation fortran programs vector form 
acm transactions programming languages systems october 
aiken nicolau 
optimal loop parallelization 
proceedings sigplan conference programming language design implementation pages june 
aiken nicolau 
perfect pipelining new loop parallelization technique 
proceedings european symposium programming 
springer verlag lecture notes computer science march 
app andrew appel 
efficient program body simulation 
siam sci 
stat 
comput 

asu alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley 
bh josh barnes hut 
hierarchical nlogn force calculation algorithm 
nature december 
code obtained prof barnes university hawaii 
con convex computer 
convex fortran language manuals 

cwz chase wegman 
analysis pointers structures 
proceedings sigplan conference programming language design implementation pages 
dh dongarra 
unrolling loops fortran 
software practice experience 
en kemal ebcioglu nakatani 
new compilation technique parallelizing loops loops unpredictable branches vliw architecture 
proceedings second workshop programming languages compilers parallel computing research monographs parallel distributed computing 
mit press 
gro josef 
tool support data structures 
structured programming january 
vincent jr technique analyzing pointer structure parallel restructuring compilers 
proceedings international conference parallel processing volume pages 
har harrison iii 
interprocedural analysis automatic parallelization scheme programs 
lisp symbolic computation 
har harrison iii 
generalized iteration space parallelization symbolic programs 
ian foster evan tick editors proceedings workshop computation symbolic languages parallel computers 
argonne national laboratory october 
anl 
hen laurie hendren 
parallelizing programs recursive data structures 
phd thesis cornell university april 
tr 
hg laurie hendren guang gao 
designing programming languages analyzability fresh look pointer data structures 
proceedings th ieee international conference computer languages appear available acaps technical memo mcgill university april 
hn laurie hendren alexandru nicolau 
parallelizing programs recursive data structures 
ieee trans 
parallel distributed computing january 
hpr susan horwitz phil pfeiffer thomas reps dependence analysis pointer variables 
proceedings sigplan conference programming language design implementation pages june 
jm jones muchnick 
program flow analysis theory applications chapter flow analysis optimization lisp structures pages 
prentice hall 
kkk david kang 
refined update 
david gelernter alexandru nicolau david padua editors languages compilers parallel computing pages 
mit press 
kuck 
structure computers computations volume wiley 
lam monica lam 
software pipelining effective scheduling technique vliw machines 
proceedings sigplan conference programming language design implementation pages june 
lar james larus 
restructuring symbolic programs concurrent execution multiprocessors 
phd thesis university california berkeley 
lh james larus paul hilfinger 
detecting conflicts structure accesses 
proceedings sigplan conference programming language design implementation pages june 
lh james larus paul hilfinger 
restructuring lisp programs concurrent execution 
proceedings acm sigplan parallel programming experience applications languages systems pages july 
lov 
program improvement source transformation 
journal acm january 
michael john reid 
fortran explained 
oxford university press 
nicolau wang 
register allocation renaming impact finegrain parallelism 
proceedings fourth workshop languages compilers parallel computing august 
pw david padua michael wolfe 
advanced compiler optimization supercomputers 
communications acm december 
rg rau 
efficient code generation horizontal architectures compiler techniques architectural support 
proceedings th symposium computer architecture april 
sam hanan samet 
design analysis spatial data structures 
addison wesley 
sol jon 
project interim report 
david gelernter alexandru nicolau david padua editors languages compilers parallel computing pages 
mit press 
sta thomas standish 
data structure techniques 
addison wesley 
zc hans zima barbara chapman 
supercompilers parallel vector computers 
acm press 

