mob parallel heuristic graph embedding john savage markus wloka technical report 
cs january brown university box providence ri motorola md el elliot road tempe az mob parallel heuristic graph embedding john savage markus wloka brown university motorola department computer science box md el elliot road providence rhode island tempe az phone fax phone fax email jes cs brown edu email wloka tempe sps mot com january supported part national science foundation cda office naval research contract arpa order nos 
contract arpa order 
short report appears th siam conference parallel processing scientific computing mar pp 

report revision experimental portion report cs extended mob heuristic graph partitioning grid hypercube embedding efficiently implemented new heuristic cm connection machine 
conducted extensive series experiments show exploits parallelism fast gives low embedding costs 
example processor cm runs minutes random graphs edges shows impressive reductions edge costs 
due excessive run times heuristics reported literature construct graph embeddings graphs times smaller experiments 
introduce report mob heuristic embedding graphs grids hypercubes 
heuristic extension mob heuristic graph partitioning 
heuristics exploit parallelism give results effective serial counterparts problems designed partitioning embedding low degree random graphs handle problems hundreds thousands times larger 
graph embedding ge graph partitioning gp np complete problems 
heuristics ge map vertices graph vertices grid hypercube minimize sum lengths embedded edges 
heuristics gp separate vertices graph sets number edges connecting sets small 
graph embedding finds application vlsi placement minimization data movement parallel computers 
vlsi placement problem minimize area chip occupied wires cells modeled embedding graph grid 
task assignment problem assign tasks parallel processors connected network minimize cost communication communication tasks represented weighted edges graph 
communication networks hypercubes grids task assignment problem modeled grid hypercube embeddings 
mob heuristic graph partitioning basis heuristics reported 
identifies swaps equal sized collections promising vertices sets partition 
heuristic begins large mob size vertices decreases mob size time swap causes number edges joining sets increase 
mob size decreased monotonically increasing number steps cycle 
generalized technique grid hypercube embedding defining large number partitions selecting random running variant graph partitioning mob heuristic 
implemented algorithm cm connection machine 
gives partitions large graphs little time 
graph partitioning important np complete problem effort devoted developing heuristics 
see example johnson 
mob heuristic effective graph partitioning simulated annealing sa kernighan lin kl heuristic best serial heuristics gp exhibits high degree parallelism gives bisection widths heuristics 
show new mob heuristics effective hypercube grid embedding effective serial heuristics problems 
define graph embedding problems give overview related simulated annealing plays important role 
section define mob heuristic give intuitive explanation operation 
sections experimental results embedding random graphs random geometric graphs grid hypercube respectively 
section draw discuss research 
graph embedding problem definition graphs embedding pair mappings ffl 
maps vertices ffl maps edges paths numbers source vertices mapping target vertex constrained 
set graph embeddings source graph target graph cost function 
assigns cost embedding graph embedding problem find graph embedding small cost 
graph partitioning special case graph embedding target graph consists just nodes half source nodes mapped 
goal graph partitioning problem embed undirected graph number edges nodes bisection width minimized 
grid embedding graph embedding grids regular dimensional arrays elements edges adjacent vertices 
figures show node random graph average degree embedded theta theta grids application new mob heuristics respectively 
sixteen vertices source graph embedded grid vertex source vertex embedded grid vertex 
hypercube embedding graph embedding hypercubes 
vertices hypercube represented binary tuples tuple vertex vertices binary tuples differ component adjacent 
goal grid hypercube embedding minimize sum lengths edges target graph 
captured perimeter cost functions defined 
measures capture congestion embeddings number wires messages passing edge target graph provide heuristics initial assignment tasks processors components sites 
definition 
gamma theta gamma embedding theta vertex grid 
cost embedded edges perimeter cost function defined perimeter perimeter ja gamma ja gamma half perimeter box enclosing grid nodes coordinates respectively 
necessary number source vertices jv increased adding unconnected vertices insure condition satisfied 
grid embedding random graph jv jv randomly generated solution 
solution generated mob heuristic 
grid embedding random graph jv jv randomly generated solution 
solution generated mob heuristic 
definition 
gamma embedding vertex hypercube 
cost embedded edges cost function hamming distance number bit positions vertices differ represented binary tuples 
previous experimental early gives heuristic embed communication graphs theta grid connections horizontal vertical diagonal neighbors 
cost function number adjacent source vertices mapped adjacent target vertices 
goal maximize cost function 
initial embedding heuristic swaps vertex vertex produces largest change cost 
cost new embedding computed increases accepted 
random pairs vertices swapped process repeated 
experiments conducted thirteen graphs edges embedded square grids vertices side 
respectable increases value cost function obtained 
give parallel version sa vlsi placement 
non interacting moves considered acceptance number possible parallel moves tends small 
strategy accepting certain moves introduces artifacts degrade convergence behavior 
parallel sa heuristics vlsi circuit placement studied sangiovanni vincentelli cm wong cm connection machine grid multiprocessors 
processor cm circuit cells nets hypergraph edges pins 
iteration sa algorithm took seconds 
wong circuits cells cells cm achieved factor speedup vax 
demonstrated speedup parallel sa heuristic embed theta grid simulating virtual processors 
chen examine running time performance twelve hypercube embedding algorithms 
compare embedding random graphs geometrical random graphs trees hypercubes hypercubes randomly selected missing edges node hypercube 
algorithms considered include sa sa restricted moves hyperplanes sac kernighan lin applied partitions cube hyperplanes rmb greedy heuristics steepest descent local search heuristics neighborhoods possible pairs vertices ls pairs vertices adjacent hyperplane lsc 
conclude sa performs better communication source graph random greedy heuristics perform better communication graph approaches hypercube 
sa flexible giving best embeddings random random geometric graphs trees running times times best heuristic problems respectively 
dreyfus propose parallel implementation sa mimd multiprocessor 
processor evaluates move accepted moves chosen random master processor 
processors update data structures incorporate executed move 
show equivalence serial sa degree parallelism small technique serial bottleneck high temperatures 
banerjee implemented sa intel hypercube version consistent serial sa 
consequence large benefits solution quality obtained time spend maintain serial consistency great 
parallel simulated annealing applied dahl reduce communication costs measured metric cm connection machine hypercube network 
multiple source vertices mapped target hypercube vertex assigned hypercube dimension 
dimension chosen random 
sa applied independently edge dimension source vertices assigned determines pairs sources vertices swap 
energy function computed ignoring possibility vertices may swap 
approach works mappings jv jv log jv serializes mappings jv jv mappings jv ae jv graph partitioning jv 
mob heuristic graph partitioning mob heuristic graph partitioning described basis new mob heuristics grid hypercube embedding 
describing detail 
mob heuristic initial partition vertices graph equal sized sets identifies equal sized subsets promising vertices swaps 
promising vertices high gain cause largest reduction bisection width swapped 
swapped mob computes bisection width new partition 
bisection width decreases new size formed swapped 
increases mob size reduced predetermined schedule new size formed swapped 
swapped bisection width computed appropriate action taken process repeated mob size reaches minimum value 
cycle may repeated times 
mob chosen sets partition computing vertex set gain decrease bisection width caused moving side partition 
array ms called mob schedule advance sth mob size ms 
initial mob size ms jv mob set size ms formed pm set vertices gain partition ra rb random variables ms integer valued mob schedule mob mob nr ms ra rb bw bw return generic mob heuristic largest gain pm ms vertices 
pm set formed way 
formed quickly parallel machines broadcasting gain threshold processors holding vertex gain counting number vertices gain larger bisection correct gain value 
binary search value value assigned selects smallest size ms 
tth mob size ms formed pm pm choosing ms vertices random uniform random variable ra rb interval 
vertices ordered counted 
number pm pm vertices multiplied ra rb rounded added modulo ms index vertex 
index set ms gamma members mob 
steps implemented efficiently parallel machine 
mob selection algorithm implemented procedure mob nr ms ra rb shown part complete algorithm generic mob heuristic 
procedure returns new partition neighborhood starting partition time limit placed procedure polynomial size jv problem 
bisection width bw mob size remains unchanged 
mob size selected 
mob heuristic elements common simulated annealing sa kernighan lin heuristic kl 
sa explores neighborhoods picking pair vertices highest gain half partition computing effect bisection width swapped 
bisection width decrease swap 
swap probability decreases exponentially temp change bisection width temp temperature parameter non increasing function time kl starts partition examines partitions obtained swapping freezing pairs vertices order decreasing gain vertices swapped 
moves partition partition sequence smallest bisection width 
process repeated improvement possible 
mob heuristic randomizing element sa explores large neighborhood kl 
intuitive explanation mob heuristic effective initial random partitions typically vertices swapped cause large reduction bisection width 
especially true graphs question low degree candidates swap edges common swapping group effect bisection width swapping individually 
bisection width graph decreases fewer vertices cause large reduction bisection width swapping large collection cause bisection width increase decrease 
reason mob size adaptively decreased 
analogy drawn movement rolling ball solution space goal find global minimum 
space structured properly large ball rolling downhill quickly find region containing global minimum due large size find global minimum 
replacing ball ball smaller size allows algorithm get closer global minimum 
mob heuristic graph embedding vertices source graphs embedded grid hypercube target graphs exist ways choose vertex sets swapping 
don restrict types swap computation time iteration embedding heuristics large 
hand swapping regime permit movement mixing embedded vertices may difficult find embeddings 
embedding heuristics need balance cost iteration number iterations 
heuristics need insure mixing time possible pairs vertices swapped 
argues probabilistic embedding heuristic 
embedding source graph target graph initial embedding partition vertices set partitions target graph mob mob heuristic partition embedding polynomial number vertices choose randomly mob mob heuristic grid hypercube embedding mob heuristic graph partitioning randomizing element 
vertices mob chosen selecting randomly vertices 
graphs embedded grid hypercube mixing needed 
mob heuristic graph embedding proven parallel heuristic goal combine appropriate partition selection mechanism provide mixing heuristic run efficiently parallel machines 
shown pseudo code mob heuristic grid hypercube embedding 
heuristic mob initial embedding source graph target graph partition vertices chosen random set partitions 
produces new embedding loops polynomial number steps 
mob identical mob graph partitioning vertices paired swapping described 
partition selection graph embedding efficiency reasons pair vertices swapping 
defined natural partitions grid hypercube vertices chosen insure mixing 
definitions assume source graph vertex mapped grid hypercube vertex 
case source vertex mapped target vertex discussed 
theta grid consists vertices coordinates gamma 
definition ith partition gamma vertex hypercube defined jg ith bit binary representation candidates swapping partition vertices differ ith bit 
partitions theta grid defined directions gamma 
partition defined dc mod ig 
candidates swapping indices ju gamma gamma indices ju mod gamma gamma 
candidates swapping direction defined similarly 
swap gains defined sum gains vertex pairs candidates swapping 
vertex gains computed perimeter cost functions grids hypercubes respectively 
source vertex mapped target vertex way select source vertex pairs swapping 
effective match source vertices largest gain match remaining vertices arbitrarily 
procedure saves time provides convergence behavior 
section discuss practical details associated implementation algorithms connection machine 
implementation mob connection machine describe key aspects implementation mob heuristics cm 
cm connection machine massively parallel computer consisting moderately slow bit processors organized dimensional hypercube sixteen nodes corner hypercube 
edge vertex data structures support exchange vertices computation gains costs minimal communication overhead 
edge data structure described blelloch implemented graph partitioning mob heuristic 
connection machine supports concept virtual processor 
implementation assigns virtual processor record vertex edge data structure 
edge data structure edge data structure constructed records representing edges undirected source graph edge appears twice pairs 
records sorted pointers introduced instances edge 
set pairs component say constitute edges adjacent vertex pair sublist double duty represents edge vertex fields introduced record leading record sublist record data source vertices 
vertex data structure grid hypercube heuristics map number source vertices target vertex 
unfortunately edge data structure lend rapid identification vertices mapped target vertex rapid pairing swapping vertices 
experimentation effective way handle issues add vertex data structure linear array records source vertex 
record contains pointer edge record edge data structure representing source vertex 
vertex data structure source vertices mapped target node adjacent laid memory easy determine location target vertices map swap 
swapping records efficient vertex data structure allows efficiently supported communication patterns cm 
vertex data structure needed mob heuristic graph partitioning set vertex falls identified single bit source records need move 
cost gain computations cost embedded edge computed pointers edges edge data structure 
scan operations data structure sum edge costs divided determine cost embedding partition edge twin 
partition gain vertex computed summing contributions edge incident vertex segmented additive scan reverse order edge data structure summing edge gains vertex gain 
segments defined edges incident vertex 
selecting exchanging procedure selecting described 
vertex data structure identify vertices half partition 
information transmitted edge data structure rank vertices half partition 
information select mob 
vertex told move edge records associated vertices active communicate new positions adjacent edges segmented copy scan 
edges notify twin edges new positions send operations records vertex data structure move new positions 
scan operation vector 
returns vector 
gamma phi phi associative operation 
segmented scan operations scan operations performed contiguous segments full vector 
segment begins ith position gamma phi scans segmented scans implemented efficiently parallel machines 
experimental results random graphs performance mob hypercube grid embedding algorithms evaluated conducting experiments cm 
mappings source target graphs studied 
random source graphs experiments times larger previously studied literature 
serial algorithms sa kl prohibitive running times large graphs 
measured solution quality convergence function time running times different numbers processors compared mob algorithms 
mob embedding heuristics source graphs produce excellent solutions converge quickly run time empirically log jej jej processors matched cm hardware 
conducted experiments randomly generated graphs vertices edges 
random graphs generated selecting pairs vertices random connecting edge removing multiple edges self loops 
probability selecting vertex chosen provide graphs integral average degree standard approach generating edges flipping coin appropriate probability potential edges graph number trials far large 
degrees considered range degrees typical vlsi processor mapping problems 
number edges vertices average degree random graphs experiments table 
graphs average degree graphs average degree study effect increasing graph size solution quality running time 
performed experiments graphs vertices average degrees ranging examine effect graph degree behavior mob algorithms 
data shown tables averaged runs 
mob schedule graph embedding mob schedule specifies element pairs swap iteration 
determines rate convergence heuristics quality results 
jej number edges graph 
experimentation characteristics mob schedules effective random source graphs embeddings grids hypercubes ffl maximum mob size jej 
ffl decrementing mob size uniform steps cycle 
ffl doubling number steps subsequent cycle 
ffl terminating computation steps 
size corresponds vertex pairs hypercube node mappings shows preference specially selected vertices maximum gain hypercube node moves vertices 
schedule combines initial rapid convergence results stages algorithm possible improvements get smaller 
schedule works mappings grid hypercube embeddings 
solution quality mob quality solutions produced mob shown tables embeddings hypercubes grids 
columns labeled dim give dimension hypercube graph embedded 
grid embeddings dim dimension hypercube containing theta grid 
columns labeled give average edge length produced random embedding labeled mob give average edge length embedding produced mob normalized number edges jej nd graph average degree graph 
columns labeled mob give ratio improvement produced mob random solution 
mob heuristic offers impressive reductions embedding costs 
experiments show ffl fixed degree mob largely independent graph size 
ffl mappings give slightly better mob ratios mappings 
ffl grid embedding mob heuristic achieves lower mob ratios hypercube mob heuristic 
ffl ratio mob rises increasing average graph degree shown 
differences grid hypercube embeddings embeddings smaller increasing degree 
rates convergence mob tables report convergence mob increasing number iterations 
columns labeled iterations shows average embedding cost percentages best embedding cost best solution run mob produced iterations mob respectively 
shown number iterations needed reach fixed percentage best embedding cost approximately independent graph size graphs fixed average degree 
important observation holds hypercube grid embeddings mappings 
fact mob rate convergence random graphs independent graph size observed graph partitioning see 
mob degree degree cube cube grid grid theta theta theta theta theta theta theta theta theta theta current best iterations convergence cube cube grid grid theta theta theta theta theta theta theta theta theta theta theta ratios best mob embedding cost random embedding cost random graphs plotted function graph degree 
mob convergence behavior number iterations expressed mob bisection width percentage best solution obtained 
iterations columns tables show reductions embedding costs decrease rapidly total number iterations increases 
rate convergence shown mappings mob grid hypercube embedding algorithms 
solution produced rapidly improvements obtained computation time available 
number iterations achieve percentage decreases degree increases 
fewer iterations needed high degree graphs 
computation time edge data structure larger vertex data structure requires jej virtual processors 
scan operations complex operations iteration mob 
iteration mob estimated run time log jej 
tested experiments cm graphs different sizes number real processors varied number virtual simulated processors ranged 
results experiments reported table hypercube embeddings table grid embeddings 
give evidence time iteration normalized number virtual processors grows logarithmically cm 
graph size handled cm bounded memory required virtual processor real processors memory added execution times keep decreasing embeddings increasingly larger graphs computable 
observed total number iterations required mob reach fixed percentage best embedding cost appears approximately constant 
follows empirical parallel running time mob heuristic sparse random graphs log jej jej processors 
tables indicate iteration mob grid embedding heuristic took approximately time corresponding iteration mob heuristic 
explained fact perimeter cost gain functions require arithmetic operations equivalents 
embeddings execute slightly slower mappings mob select vertex maximum gain target vertex move head vertex list described section 
absolute speed embedding produced mob remarkable shows mob implemented efficiently simd style machine 
cm takes approximately seconds minutes find embedding vertex edge graph dimensional hypercube approximately seconds minutes embed graph dimensional hypercube 
takes approximately seconds minutes find embedding vertex edge graph theta grid approximately seconds minutes embed graph theta grid 
embeddings percent best 
comparison graph partitioning algorithms calibrate results obtained graph partitioning computed bisection width graphs embedded grids hypercubes 
bisection widths hypercube embeddings hyperplanes grid embeddings partitions dividing grid half vertically horizontally gave best partitions 
table shows mob hypercube grid embedding algorithms perform algorithms 
data random graphs performance mob algorithm kl graph partitioning algorithm taken study local search graph partitioning heuristics 
cost graph embeddings table percentage edges cross cut grid hypercube embeddings mob heuristics produced bisection widths comparable mob heuristic 
kl graph partitioning algorithm ran graphs fewer vertices due running time considerations significantly outperformed mob embedding algorithms 
kl gave slightly worse embeddings mob grid embedding algorithm slightly better embeddings mob hypercube embedding algorithm 
performance mob embedding algorithms interpreted graph partitioning algorithms remarkable considering mob optimizing wrong cost function 
data table show conclusively mob embedding algorithms existence better graph embedding algorithm imply existence better graph partitioning algorithm 
comparison simulated annealing chen evaluated performance hypercube embedding heuristics 
graphs examined random graphs random geometric graphs random trees hypercubes hypercubes randomly added deleted edges 
graphs vertices embedded dimensional hypercube 
algorithms tested simulated annealing move set limited swapping vertex pairs hypercube edges produced best solutions 
obtained random graphs chen generated random graphs 
graph runs performed results averaged runs 
run mob limited iterations schedule described 
chen report random graphs average degree reduction cost random embedding achieved 
average solution produced mob chen graphs graphs 
mob performance equal performance tuned version sa 
experimental results geometric graphs performed experiments random geometric graphs structure random graphs 
cost ratio minimum embedding random embedding tends smaller random graphs 
desirable find embedding suggests embedding harder find 
random geometric graph vertices average degree generated randomly selecting points unit square theta 
geometric graph contains edge endpoints distance apart measured distance metric 
obtain graphs degree distance parameter set value shows random geometric graph shows grid embedding graph computed placing vertex neighboring grid point 
metrics literature ffl manhattan metric jx gamma jy gamma random geometric graph jv unit plane 
grid embedding geometric graph jv obtained placing vertex neighboring grid node 
ffl euclidean metric jx gamma jy gamma ffl infinity metric max jx gamma jy gamma experiments manhattan metric matches cost function grid embeddings 
graph partitioning experiments johnson performed random geometric graphs generated euclidean metric 
chen random geometric graphs generated infinity metric test algorithms 
efficient construction random geometric graphs address problem efficiently generating geometric graphs 
naive method computing distance vertex pair unit square leads time algorithm 
approach perfectly adequate small graphs 
sophisticated method required graphs vertices 
approach divide unit square theta cells 
follows vertices distance apart located cell neighboring cells 
holds metrics 
vertex computes cell belongs vertices sorted cell value linear vertex array 
vertices cell adjacent vertex array 
indirection table constructed contains cell address vertex array vertex cell value gamma cell empty facilitates finding contents neighboring cells 
vertices distributed randomly unit square number cells unit square theta manhattan metric 
cells contain average vertices 
average total nd distance computations done generate nd edges total computational log nd 
realistic assumption sorting vertices cell value takes time log processors algorithm easily parallelized run time log parallel processors 
experiments show constants small 
note search structure works points distributed randomly plane 
sophisticated algorithms quad trees voronoi diagrams trapezoidal decompositions developed field computational geometry deal nearest neighbor problems 
considerable implementation complexity usually log storage space requirements algorithms inappropriate special case generating geometric graphs simpler algorithm described exists 
analysis cost embedding geometric graphs assume graphs embedded nc theta ne grid 
estimate min minimum cost grid embedding assuming vertices unit square grid vertices computing sum manhattan lengths edges multiplying sum average distance adjacent vertices unit square easily shown giving estimated total edge cost min nd hand average cost random embedding nc theta ne grid embedded unit square estimated nd nc ne average length edge endpoints randomly chosen nc theta ne grid nc ne gamma nc gamma ne 
column labeled table exact analysis total cost edge averaged ensemble geometric graphs vertices average degree shows computed average total length random embedding normalized number edges match perfect 
fold nc theta ne grid hypercube dimension log estimate min holds min minimum cost hypercube embedding min nd average cost random hypercube embedding estimated nd log average length edge arbitrary endpoints log 
seen table exact match column labeled estimates indicate geometric graphs increasing size ratio minimum cost embeddings random embeddings decreases asymptotically 
bisection width random geometric graph degree estimated considering average number edges cross vertical line cutting grid approximately equal sections 
manhattan metric points adjacent point fall diamond shaped region side edge points cuts line intersects 
follows straightforward analysis average probability pair vertices adjacent incident edge crosses line 
gamma pairs follows min average number edges crossing vertical line satisfies min gamma random embedding random graph half edges cross cut average bisection width random graph nd estimates normalized number edges evaluate quality experimental data 
columns labeled slice tables show results slice heuristic introduced close estimates 
results tables expressed average edge lengths multiplied number edges nd give total embedding costs 
slice heuristic intuitively randomly generated vertex unit square shifted small distance point occupied unique grid location resulting grid embedding quite certainly better randomly generated mapping vertices grid 
heuristic serve starting solution mob heuristic point observe mob convergence random solution 
slice heuristic divide conquer algorithm find unique vertex grid mappings slightly displacing vertices unit square 
slice heuristic closely related slicing structure tree introduced otten vlsi floorplan design 
vertices sorted dimension 
sorted vertices divided sets mapped different halves grid 
set sorted dimension 
procedure sorting alternating dimensions halving sets repeated sets size 
point vertex unique grid node assigned 
johnson similar approach designing line heuristic partitioning geometric graphs unit square cut half obtain graph partition 
report local search algorithms converge quickly geometric graphs local search algorithms need considerable running time equal performance line line followed local search produced best results 
coordinates usually part input graph embedding problem slice definitely practical graph embedding heuristic 
results believe produces solutions close optimal embedding allowing evaluate performance mob heuristic 
knowledge graph random geometric graph helpful 
heuristic required construct approximate coordinates vertices unit square 
unfortunately best candidate doing grid embedding heuristic 
experiments large geometric graphs evaluated performance mob hypercube grid embedding algorithms geometric graphs vertices edges conducting experiments cm 
mappings studied 
exact number edges vertices average degree random graphs experiments table 
generated graphs average degree graphs average degree study effect increasing graph size solution quality running time 
performed experiments graphs vertices average degrees ranging examine effect graph degree behavior mob algorithms 
runs performed embedding 
mob schedule random graph size grid embedding 
degree slice min graph size grid embedding 
degree slice min comparison min slice degree degree geometric graphs embedded grids 
graphs section 
mob stopped iterations 
computation time needed iteration mob random graphs tables apply geometric graphs 
shall see mob constant number iterations produce embeddings close optimal reduction average edge lengths larger random graphs 
solution quality mob quality solutions produced mob shown tables embeddings 
table gives results hypercube embeddings table gives results grid embeddings 
columns labeled dim give dimension hypercube graph embedded 
grid embeddings dim dimension hypercube containing theta grid 
columns labeled give average edge length produced random embedding labeled slice give average edge length produced slice heuristic labeled mob give average edge length embedding produced mob initial random embedding normalized number edges nd graph average degree graph 
columns labeled slice mob give ratio improvement produced slice mob random solution 
shown figures ratios min min degree random geometric graphs compared ratio slice experiments show graph size hypercube embedding 
degree slice min graph size hypercube embedding 
degree slice min comparison min slice degree degree geometric graphs embedded hypercubes 
ffl slice heuristic produces comparable slightly better results mob hypercube embeddings considerably better results mob grid embeddings 
ffl fixed degree mob changes slowly graph size slice decreases mildly increasing graph size hypercubes strongly grids 
gap slice mob widens graphs larger 
ffl mappings give better mob ratios mappings 
ffl grid embedding mob heuristic achieves significantly lower mob ratios hypercube mob heuristic 
ffl ratio mob rises increasing average graph degree 
differences grid hypercube embeddings embeddings smaller increasing graph degree 
ffl ratio mob smaller geometric graphs random graphs 
compare tables tables 
grid embeddings hypercube embeddings mob times smaller 
hypercube embeddings ratio mob geometric graphs ratio mob random graphs 
mob constant number iterations produce embeddings close optimal reduction average edge lengths larger random graphs 
rates convergence mob tables report convergence mob increasing number iterations 
columns labeled iterations show average embedding cost percentages embedding cost produced iterations mob respectively 
experiments geometric graphs indicate mob converges rapidly solution compared best solution produced mob 
inferred iterations columns cost ratio mob solution divided solution produced slice generally increases increasing graph size 
comparison graph partitioning algorithms calibrate results measured graph partitions produced hypercube grid embeddings described section 
table shows mob hypercube grid embedding algorithms behaved graph partitioning algorithms compared mob kl graph partitioning algorithms 
cost graph embeddings table bisection width normalized number edges nd 
mob graph partitioning heuristic produced better results hypercube grid embedding algorithms approach partitions produced slice 
constant number iterations mob heuristics produce embeddings average bisection width function graph size constant decreases slowly normalized bisection width produced slice function graph size approximately proportional normalized value estimate min see equation embedding algorithms grid embedding algorithm produced graph partitions larger factor roughly mob graph partitioning algorithm 
kl graph partitioning algorithm ran graphs fewer vertices due running time considerations produced results noticeably worse graph embeddings 
hypercube embeddings larger factor roughly 
comparison simulated annealing analogous experiments random graphs compared performance mob cube embedding heuristic geometric graphs results reported simulated annealing chen 
duplicate experiments generated random geometric graphs generator 
graph vertices 
distance parameter infinity metric set obtain graphs degree 
runs performed graph infinity metric results averaged runs 
run mob limited iterations schedule described 
results expressed percent reduction edge lengths random embedding table 
chen report random geometric graphs average degree reduction achieved sac version sa move set limited hypercube edges 
average reduction produced mob graphs 
slice heuristic produced solutions reductions 
best solutions obtained solutions produced slice improved mob 
developed new mob heuristic exploits parallelism gives high quality embeddings low degree graphs grids hypercubes 
closely related kernighan lin simulated annealing heuristics 
implemented mob heuristic cm connection machine demonstrate fast handle large graphs 
speed mob heuristic adequate optimized placement large gates vlsi circuits 
applied optimization problems local search heuristics successful 
interesting see mob heuristic industrial production system vlsi gate array placement full custom logic placement 
mob speed ability handle unusually large problem sizes reduce design time orders magnitude allow creation new tools handle larger problem instances return higher quality solutions 
mob heuristic run internet cm facility supported darpa 
staff thinking machines especially denny dahl david ray jim fast knowledgeable help 
kae chen matthias supplying graphs performance hypercube embedding heuristic compared 
bibliography connection machine model cm technical summary thinking machines tmc technical report ha 
banerjee jones sargent parallel simulated annealing algorithms cell placement hypercube multiprocessors ieee transactions parallel distributed systems pds january 
blelloch scans primitive parallel operations ieee transactions computers 
mapping problem ieee transactions computers mar 
sangiovanni vincentelli placement standard cells simulated annealing connection machine iccad nov 

chen hypercube embedding heuristics evaluation international journal parallel programming 

chen local search variants hypercube embedding proceedings th distributed memory computer conference 
dahl mapping compiled communication connection machine proceedings th distributed memory computer conference 
kirkpatrick norton parallel algorithms chip placement simulated annealing ibm journal research development may 
ramanujam sadayappan task allocation hypercube recursive mincut bipartitioning journal parallel distributed computing 
garey johnson computers intractability guide theory np completeness freeman new york 
hillis connection machine mit press 
johnson aragon mcgeoch schevon optimization simulated annealing experimental evaluation part operations research nov dec 
kernighan lin efficient heuristic procedure partitioning graphs bell labs 
tech 
feb 
kirkpatrick gelatt vecchi optimization simulated annealing science may 
multiprocessor placement simulated annealing rd ieee design automation conf 

otten automatic floorplan design proc 
th ieee design automation conf 

dreyfus problem independent parallel implementation simulated annealing models experiments ieee trans 
computer aided design aug 
savage wloka parallelizing graph partitioning heuristics proceedings icalp july 
savage wloka parallel graph embedding heuristics th siam conference parallel processing scientific computing mar 
savage wloka parallelism graph partitioning journal parallel distributed computing nov 
wong simulated annealing circuit placement connection machine proceedings international conference computer design oct 
table large random graphs small degree 
graph vertices edges degree degree degree variable degree table hypercube embedding results large random graphs 
costs mob hypercube embedding algorithm expressed average edge length compared hypercube embedding chosen random 
convergence measured expressing mob cost number iterations percentage best solution obtained 
mappings degree iterations iterations graph dim mob mob dim mob mob degree degree variable degree table grid embedding results large random graphs 
costs mob algorithm expressed average edge length compared grid embedding chosen random 
convergence measured expressing mob cost number iterations percentage best solution obtained 
mappings mappings iterations iterations graph dim mob mob dim mob mob degree 



degree 
variable degree table hypercube timing results 
execution times measured mob iteration cm 
mappings mappings degree graph dim dim degree variable degree table grid embedding timing results 
execution times measured mob iteration cm 
mappings mappings degree graph dim dim degree variable degree table graph partitions random graphs generated cutting hypercube grid embeddings hyperplane 
bisection widths normalized number edges 
mob hypercube grid heuristic produce bisection widths better kl heuristic 
graph mob partition kl partition cube cube grid grid degree degree variable degree table large random geometric graphs small degree 
graph vertices edges degree degree degree variable degree table hypercube embedding results large geometric graphs 
cost slice mob hypercube embedding algorithms expressed average edge length compared hypercube embedding chosen random 
convergence measured expressing mob cost number iterations percentage best solution obtained 
mappings iterations graph dim slice slice mob mob degree degree variable degree mappings iterations graph dim slice slice mob mob degree degree variable degree table grid embedding results large geometric graphs 
costs slice mob grid embedding algorithms expressed average edge length compared grid embedding chosen random 
convergence measured expressing mob cost number iterations percentage best solution obtained 
mappings iterations graph dim slice slice mob mob degree degree variable degree mappings iterations graph dim slice slice mob mob degree degree variable degree table graph partitions geometric graphs generated cutting hypercube grid embeddings hyperplane 
bisection widths normalized number edges 
mob hypercube grid heuristic produce bisection widths comparable mob graph partitioning heuristic better kl heuristic 
graph slice mob partition kl partition cube cube grid grid degree degree variable degree table hypercube embeddings vertex degree geometric graphs 
comparison mob sa 
heuristic min average cost average 
edge length random mob slice mob slice random sac pushed 
