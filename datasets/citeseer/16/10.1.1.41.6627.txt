logic language parametric inheritance hasan jamil department computer science mississippi state university usa jamil cs edu www cs edu jamil overriding single default mode inheritance adequate knowledge bases large class applications naturally requires inheritance modes types 
propose linguistic extensions logical object oriented languages support multiple inheritance modes types give usual default overriding semantics object oriented systems 
declarative semantics generalized parametric language inheritance object oriented 
specifically identify discuss inheritance modes overriding inflating inheritance types value code null 
parameterization consider language clause level 
approach generalizes languages similar 
formal account language giving novel proof theory 
hint model theory fixpoint theory claim equivalence 
full logical characterization modes types single framework knowledge unprecedented 
show languages default overriding semantics classical horn clause language special cases 
discuss modeling modes types computable functions extension 
connotations different inheritance way numerous systems applications different forms 
possible kinds proposed inheritance overriding appreciated widely 
overriding difficult issue address logic related negation belief theory revision non monotonic reasoning 
approaches appealing modeling overriding knowledge representation knowledge bases 
solutions computationally expensive heavily dependent user capturing intended semantics inheritance hand coded program 
case logic little capturing spirit overriding error prone 
currently varied frameworks computing declarative overriding 
inheritance object oriented logic interest area object oriented knowledge bases comprehensive surveys may :10.1.1.115.3586
interest sparked primarily need model new generation knowledge applications bio informatics gis cad cam office automation web databases time series expert systems require complex abstractions necessitate software engineering concepts 
applications inheritance overriding predominant choice 
inheritance significant applications areas including multi level secure databases data warehousing data mining overriding played pivotal role representing knowledge systems 
logic monotonic additive inflation inheritance needed model structure signature inheritance overriding instrumental capturing method inheritance :10.1.1.115.3586
modeling difficult logic proof procedure method inheritance overriding possible 
main reason logic general languages free cumbersome syntax hardwiring inheritance programs 
succeeded capturing inheritance overriding proof theory restricting logic devising special syntax keeping logic purely declarative 
differs logic significant way 
captured notion code clause inheritance late binding defined definition logic simulate model declarative sense 
words logic capable value inheritance results computations facts simulates code inheritance machinery value inheritance 
type inheritance multi level secure knowledge bases called null inheritance model called conservative view belief remove ambiguity classified knowledge bases 
light preceding discussion envisage unifying generalized language model inheritance imperative knowledge representation burdened cumbersome larger sets application modeling 
section example demonstrate extensions natural intuitive interesting 
discussion ensue call overriding inflation modes inheritance value code null types inheritance 
contention incorporating modes types easier represent knowledge object oriented logics hierarchy classes objects methods 
possible consider modes types inheritance believe sufficient modeling applications 
interesting example discussed demonstrates need multiple modes types inheritance single knowledge representation application 
motivating example highlight necessity multiple inheritance modes types university database example data model schema clarity simplicity omitting details model order succinct focused 
intuitively object class object identity set properties 
properties exhibit behavior objects instances classes 
behaviors called methods may defined statically values dynamically codes compute values corresponding property run time 
behaviors defined class objects called default behaviors 
default behaviors may inherited subclass lower hierarchy instance subclass instance overrides re defining behavior 
static values defined class level defaults called state values object oriented parlance 
faculty teaching asstt grad stud asstt prof salary degrees income income consulting income salary consulting salary ms degrees phd university database schema extended notations showing inheritance modes types 
inheriting behaviors class hierarchies significant distinction identified resulting different meanings behavioral inheritance 
property statically defined alternatively called static property statically inherited value inherited 
form inheritance called value inheritance 
dynamic properties methods defined codes inherited distinct forms code computed class property defined computed value inherited similar spirit value inheritance discussed earlier alternatively ii code inherited computed context object interest 
form inheritance termed code reuse code inheritance similar idea dynamic self binding late binding object oriented languages 
conceptually forms inheritances quite different significant influence semantics program demonstrated shortly 
faculty asstt prof grad stud teaching asstt class objects asstt prof teaching asstt subclasses faculty 
teaching asstt subclass grad stud 
attributes classes shown ellipses name attributes shown horizontal line values shown 
example degrees attribute faculty class default value ms faculty instances 
note income attribute class asstt prof virtual attribute methods shown dotted ellipse 
income asstt prof defined sum total salary consulting attribute values 
thick upward arrow lines show relationships class objects 
unique properties underlying data model language 
consider attribute degrees faculty asstt prof naturally expect qualifications asstt profs superset qualifications additive 
call inflating opposed overriding 
contrast method income asstt prof specialized definition income definition faculty overridden 
modes inheritance shown different attribute notations 
attributes methods override generalized definition horizontal bar top ellipse inflating attributes shown bar 
type property method hand illustrated follows dotted line connecting entity rectangle property ellipse denoting code inheritance solid line represents value inheritance 
horizontal bar property ellipse symbolizes non inheritable property 
grad stud property 
consequently example expect asstt profs income equivalent salary value inherited faculty 
asstt profs degrees fms 
clear overriding default underlying semantics way force degrees assume values fms asstt profs defining value degrees attribute 
problem attribute defined program code say faculty forced copy piece code faculty say asstt prof duplicating codes raises issue code maintenance potential inconsistency 
major software engineering concern avoid possible 
goals contributions goal develop logical framework parametric inheritance knowledge base systems develop query language 
develop query language steps 
discuss syntax language devise resolution sequent style goal directed proof procedure take proof theoretic approach assigning semantics programs 
step develop companion notion satisfaction language herbrand interpretation structures define model theory 
develop constructive way computing models programs defining fixpoint theory 
furthermore show characterizations language equivalent prove proof theory develop sound complete 
completeness proof theory significant result immense theoretical importance 
preliminary results hand may draft technical report 
shown classical horn clause logic logics overriding special cases language 
form parameterization consider similar approach followed van emden lakshmanan sadri 
consider rules form define method object mode type addition rules form depending mode clause override clause defining predicate superclass unioned superclass clause mode captures relationship clauses defined object clauses defined higher hierarchy 
depending type value code clause inherited subclass instance 
type null inherited 
observe type relates subclasses instances respect form inheritance clause 
note clause subclass instance depends modes defines predicates corresponding method 
organization section parametric language giving syntax discussing informal semantics example section 
example introduce salient features language functionalities 
section goal directed sequent style proof procedure language 
results form properties language discussed section 
section discusses research similar lines compares language representative frameworks languages 
conclude section 
parametric language section syntax language syntax extension standard horn clause logic maintain compatibility take relational approach modeling concept methods object oriented paradigm functional approach logic 
alphabet language tuple hp infinite set predicate symbols ii infinite set object symbols including distinguished object symbols global iii infinite set function symbols ary function symbols serve role constants iv infinite set variables finite set symbols inheritance mode vi finite set symbols inheritance types inheritance type allowed language 
symbols assumed pairwise disjoint 
take sets code respectively 
set terms defined usual manner intuitively set terms represents possible object identifiers values alphabet includes usual logical connectives quantifiers punctuation symbols 
strings starting uppercase letters variables lowercase letters constants 
bold lowercase letters denote arbitrary terms 
atomic complex formulas language consists basic types atoms terms predicate atom ii object identifiers respectively subclass instance transitive atoms object id atom iii global global atom atom iv message goal atom local atom atom 
notation pred denote predicate symbol arity form global 
notation places distinctions unimportant 
formulas defined usual 
standard practice logic programming consider definite horn clause fragment language 
clause form bm called head atom called body literals 
atom atom atom 
empty clause head atom non atom empty 
query clause head 
clause form called clause clause atom respectively clause 
clauses define properties attributes methods class instance objects 
clause called context method pred defined clause notation denote predicate arity 

clause cl atom context cl context captures respectively context clause atom 
definition programs queries program triple pi qi set possibly empty clauses pi set possibly empty clauses set possibly empty queries 
program stratified clause depends properties defined objects program body literals clauses contain atoms clause contains distinguished object remainder consider programs 
informal semantics parametric inheritance point beneficial discuss aspects language proof theory intuitive grounds better understand intricacies interplay various features 
exemplify ideas parametric inheritance simple university example 
proceed certain points need clarification 
identify types clauses programs local inherited clauses 
intuitively clause local object defined inherited defined intermediate superclass inclusive defines clause property overriding mode 
notions precise definitions 
definition locality program jpj ground closure cl pi context cl cl local object cl holds 
say cl belongs program 
objects distinguished object part program universe definition inherited clauses program jpj ground closure cl pi context cl cl inherited hold null hold cl pi cl override pred pred context cl 
cl inherited including essentially implying local definition pred overrides cl code say cl code inherited value cl value inherited code inherits cl holds holds hand value inherits cl holds holds note clause cl inherited null 
effect inflation somewhat built definition intermediate object defines clause pred mode overriding affect effectively capturing notion inflation 
definitions essential prerequisites explain functionalities language example 
example consider program corresponding schematic representation easy mention immediate subclass instance clauses specified users 
transitive relationships may easily computed set axioms added program 
users implicitly assume locality clauses definitions expect system take care inheritance specifications contained program 
grad stud faculty asstt prof teaching asstt maria sue max alex john degrees ms salary income salary degrees phd consulting abs income income salary consulting income salary class instance subclass isa instance isa property avg income faculty schematic representation university database 
example class object faculty locally defines methods properties degrees salary income clauses 
properties available inheritance classes asstt prof teaching asstt defined subclasses faculty clauses 
asstt prof defines new properties consulting clauses redefines income degrees clauses 
degrees redefined inflating mode prof inherit value consequent clause faculty notice expect max degrees set fms notice scheme program adaptation scheme 
clause defined value inheritable query 
max closest ancestor asstt prof class redefines degrees inflating mode values specified asstt prof added inherited values class object faculty 
definition income overrides clause faculty clause defined overriding mode 
clause applicable asstt prof hand alex instance asstt prof clause having defined local definition income inherits clause 
time inherits code income salary consulting effect income holds query alex salary alex overrides class property salary clause 
similar idea dynamic self late binding object oriented systems 
notice max salary query 
similar analysis easy see john salary 
similar remarks apply sue maria respect incomes 
consider clause clause defined asstt prof class 
clause code inherited subclass instance asstt prof turn uses defined faculty clause expect query alex max query computed faculty inclusive class object values faculty teaching asstt asstt prof 
note value inherit asstt prof instances faculty 
code inherited different different levels object hierarchy computed level different 
proof theory section develop proof procedure order assign operational semantics programs language 
goal directed sequent style proof system similar miller module language contextual logic programming proof system defined set properties proof predicate 
proof system goals proven context pair objects called initial context current context generally called context context pair 
purpose contextualizing provability clear discuss proof system particular discuss example proof clause 
case really matter fact methods defined rules difference see 
fi fi fi fi fi fi fi fi fi fi fi fi fi asstt prof faculty teaching asstt faculty teaching asstt grad stud john faculty max asstt prof alex asstt prof sue teaching asstt maria grad stud fi fi fi fi fi fi fi fi fi fi fi max degrees max income alex income income asstt prof faculty pi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi faculty degrees ms 
override value faculty salary 
override value faculty income salary override code faculty income faculty avg 

override value asstt prof degrees phd 
inf late value asstt prof consulting override value asstt prof income salary consulting override code asstt prof income abs gamma override code grad stud 
override value teaching asstt income override code teaching asstt override value alex salary 
override value university database 
empty hp oi ffl hp oi hp oi oe hp oi oe message ho oi ak hp oi ak top ho global ho oe hp oi oe atom mgu deduction ho oe ho oe mgu self hp pi oe oe hp pi oeoe mgu mgu oe mgu 
ak code sharing hp pi oe oe hp oi oeoe mgu mgu code oe mgu 
ak value sharing ho oi oe oe hp oi oeoe mgu mgu value oe mgu 
ak inheritance hp oi oe hp ri oe hp oi oe mgu oe pred pred override proof rules 
section 
intuitively contexts memorize objects started proving goal mainly property goals object currently attempting proof style memory stack 
combination contexts gives capability develop robust proof procedure intricate inheritance modes types complex interplay 
similar simpler context proof procedure define provability logic programs encapsulation 
similar read proof rules bottom 
notation hp oi represent fact goal derivable program initial context current context substitution hp oi 
note application proof rule contingent satisfaction conditions specified right hand side rule 
oe oe represent general unifiers ffl represent empty substitution 
denotes empty goal true context 
usual proof tree called proof tree rooted internal nodes instances rules top leaf nodes labeled empty 
height proof maximum number nodes branches proof tree size proof number nodes proof tree 
contrast substitutions proof rules uniformly applied initial current contexts correctly capture intended operational semantics 
proof hp oi hp oi means hp oi system 
set proof rules language shown 
rules empty message top basic ones 
interpretation provability relation simple immediate 
explain rules clarify idea 
consider rule top 
rule says prove goal program prove letting initial current contexts called context pair recall special object part program universe 
rule initiates proof contextual manner 
proof top rule fired root labeled top rule applied proof 
intuitively rule provides default object authors substitutions contexts contextual logic programming 
context pair proving global context outside object 
goal conjunctive proven individually unspecified order splitting goal rule respect identical context pair 
empty rule says empty goal provable empty substitution context pair time 
goal proven deduction rule 
notice atom appears body clause including queries 
fire rule message goal goal unify head clause atoms appear consequents making rule non ambiguous 
fire message rule goals 
notice message goals goals proven outside object global context application deduction justified 
consider proving predicate representing property object object 
send message object evaluate predicate goals form 
prove goal apply message rule initialize context pair ho oi indicating prove context initial context started initial context meant capture entry point object hierarchy 
basically distinct ways prove current context context pair hp oi 
clause initial context prove goal self rule 
allow proving goal local clause independent mode type 
ii local definition initial context go level hierarchy firing rule inheritance holds try prove goal context hp ri 
note find clause able copy code clause code inheritable rule code sharing step 
initial context memorized 
value inherit clause way context important note fire inheritance clause overriding mode 
essentially captures overriding inflation inherit clause overriding allowed inflate 
continue climb hierarchy fail find clause prove goal 
climb level hierarchy notice initially contexts identical 
ffl empty fy kg salary self oe fy kg prof asstt ffl empty asstt fz kg consulting oe value sharing oe fz kg fz kg consulting oe inheritance fy kg salary consulting asstt fy kg income code sharing fy kg income inheritance ho fy kg alex income message fy kg alex income top proof tree goal alex income object local definition iii value sharing iv code sharing rule fired depending type clause 
rule value sharing fired definition value sharing evaluate body clause context current context 
initialize context pair oi 
initialize hp pi fired code sharing clause body proven initial context essentially copying body clause initial context 
inside context able prove global predicate goals 
rule global helps return global context 
reenter context need prove message goal 
notice goals form global technicality 
specialized syntax way simple intuitive way distinguishing global predicate object property come context object resulting failed proof prove predicate defined object name expect clear discussion modes types affect provability goal 
essentially modes affect inheritance firing rule inheritance depends mode clauses object type affects evaluation clause initialization context pair dictates code evaluated 
notice null inheritance product rules self code inheritance value inheritance way applied 
example example proof consider example section 
proof tree shows sample proof alex income proof rules section 
note show want space branch corresponding oe alex application inheritance rule succeeds binding fr asstt subsequent application deduction clause 
recall section anticipated exactly value income alex returned proof procedure 
properties language operational semantics proof theory previous section interesting properties 
section highlight properties expository reasons simultaneously avoiding extensive elaborations 
exact details may companion 
consider adding additional clause grad stud salary 
override value program example 
case proof rules possible prove sue salary sue salary 
teaching asstt subclass faculty grad stud salary inheritable grad stud faculty definition application inheritance rules proof system 
exactly desired 
meaningful proof system finds exactly proofs 
sue salary sue salary fail 
consequence allowing multiple inheritance 
logic procedural languages disallow multiple inheritance avoid just situations serious issue potential inheritance conflict 
solution problem disallow programs incorporate type ambiguity 
allow larger set programs maintain uniqueness proofs 
definitions theorems help achieving goal 
definition stratified program jpj ground closure 
conflict free objects jpj property inheritable class unique 
theorem conflict free program message goal 
proof unique 
proof sketch follows immediately definition fact object hierarchy essentially behaves forest respect method object 
show horn fragment predicate logic special case language proof goal predicate logic rules empty deduction top 
easily prove theorem 
theorem horn program predicate logic corresponding provability relation 
conflict free program pi 
goal 
proof sketch showing proof trees identical fact top additional rule applied height height possible define satisfaction interpretation structures model theory 
show model exists conflict free program 
furthermore fixpoint operator defined construct model fixpoint operator showing fixpoint operator monotonic 
completeness proof system proven equivalence models fixpoint provability theorems 
theorem program mp model 
mp lfp tp tp theorem equivalence program mp model ground goal 
ffl mp comparison related research critical observation immediate transitive relations need treated differently 
observation enabled define notions local inherited clauses successfully utilized capture inheritance sound complete proof theory natural elegant way 
language distinction consequently suffers drawbacks 
result proposals take simpler approach inheritance modeling adopting value inheritance avoiding complicated issue code re :10.1.1.115.3586
attempted address issue code re limited way capture value inheritance 
similar remarks apply captured code re value inheritance 
logic takes value inheritance approach code re simulated higher order features language limited way appears unnatural 
consider program pi adapted sigma 
declaring meaningless stable semantics assigns meaning program 
logic assigns minimal model 
fp fp fp fo dg 
contrast semantics program allowed assign model 
fp fp fp fo dg 
reason striking difference views intermediate object distinction immediate transitive 
contrast view distinct immediate superclasses difference 
logic hand value inherited overrides inheritance respect 
fi fi fi fi fi fi pi fi fi fi fi 
override code 
override code observe virtual sub subclass definitions notice stratified program 
consequence definition local inherited clauses adapted 
rules captured naturally language issue distinctions immediate transitive 
inherit treats situation inheritance conflict 
language recognize inheritance conflicts behaves similarly 
logic hand settles multiple minimal models event inheritance conflicts 
consider program fi fi fi fi pi fi fi fi fi fi fi fi fi fi fi 
override code override code 
inf late value 
override code 
override code observe clause defines inflating mode inherits clause corresponding clause override 
furthermore derived value inheriting clause derives code inheriting clause derive particular 
note instance inheriting definition ways inheritance type code value 
possible language 
seen example inheritance withdrawal possible language possible 
instance salary consulting values inherited sue asstt prof faculty classes instance 
may desired applications 
particular sue salary provable binding probably intended possible anyway due unwanted inheritance 
observe defining salary null type faculty really help asstt prof class instances inherit salary faculty 
sense appears handle conflicts better language regard 
confess language captures inheritance parametric way language consider horn fragment language 
logic general provides foundation object oriented languages 
fact current inspired logic attempt capture semantics inheritance sound complete proof theory missing logic 
believe successfully exploited restricted setting language capture modes types single logical framework class citizens knowledge time 
able capture logic notion non inheritable methods null types 
advantage language simulate known inheritance modes types language 
sake brevity included detailed comparison approach inheritance modeling realm artificial intelligence 
artificial intelligence approaches deal overriding exception handling 
discussion differences approaches artificial intelligence object oriented communities may 
considered simple intuitive object oriented logic developed elegant resolution sequent style goal directed proof procedure definite clause fragment captured semantics parametric inheritance multiple modes types dynamic subclassing declarative way 
proof theory contextual provability sound complete respect model theoretic semantics 
impose restriction class programs 
require pre processing programs capturing provability goals programs 
novelty proof system captures definition inherited clauses meanings modes types declaratively 
predicate oriented method implementation gives classical order logic flavor easier understand logic understood syntax partly semantics 
fact language dual classical order language object oriented language captured theorem 
query optimization techniques developed datalog tailored apply framework 
language directly account functional methods logic utilize constraints model limited way 
consider extensions proposed language 
note fixed ahead set allowed modes types language 
may relaxed capturing modes types computable consider conflict free definition horn programs really restriction expressibility 
semantic restriction avoid ambiguity meanings programs 
functions 
approach users supply modes types define meanings part programs 
system define semantics logic program computing meanings modes types accordingly 
modal semantics language developed understand logical foundations incorporate encapsulation 
demonstrate feasibility language implemented variant language called datalog unix nt machines xsb 
web version datalog demo may www cs edu jamil 
acknowledgments research supported part department computer science mississippi state university college engineering mississippi state university research initiation program 
author meer wright state university usa giving helpful comments improve presentation initial version 
abiteboul lausen waller 
methods rules 
acm sigmod conference management data pages 
ait kaci nasr 
login logic programming language built inheritance 
journal logic programming 
ait kaci podelski 
meaning life 
technical report digital paris research labs 
jack naish 
object oriented programming prolog rationale case study 
technical report department electrical electronics engineering university paderborn paderborn germany 

declarative view inheritance logic programming 
apt editor proc 
joint int 
conference symposium logic programming pages 
mit press 
jamil 
logic encapsulation object oriented languages 
hermenegildo editors proceedings th international symposium programming language implementation logic programming plilp pages madrid spain 
springer verlag 
lncs 
jamil 
stable model semantics behavioral inheritance deductive object oriented languages 
gottlob vardi editors proceedings th international conference database theory icdt pages prague czech republic 
springer verlag 
lncs 

logical objects 
kowalski bowen editors proc 
th int 
conference logic programming pages 
mit press 
andrew davidson 
survey logic programming object oriented languages 
addison wesley 

object oriented database programming language extended deductive capabilities 
karagiannis editor proc 
th intl 
dexa conf pages athens greece 
springer verlag 
lncs 
dimopoulos kakas 
logic programming negation failure 
john lloyd editor proceedings th international logic programming symposium pages portland oregon december 
mit press 
topor 
model sets multiple inheritance deductive objectoriented systems 
proc 
rd intl 
dood conf pages december 
fukunaga hirose 
experience prolog object oriented language 
oopsla pages portland oregon september 
gallaire 
merging object logic programming relational semantics 
aaai pages philadelphia pa 
jiawei han fu raymond ng 
cooperative query answering multiple layered databases 
proceedings nd international conference cooperative information systems coopis pages toronto canada 
jagadish laks lakshmanan divesh srivastava 
hierarchies data warehouses 
proc 
vldb conference pages 
jamil 
logical framework parametric inheritance 
technical report department computer science mississippi state university usa january 
preparation 
jamil lakshmanan 
logic semantic object oriented models 
proc 
st int 
conference knowledge information management pages 
jamil lakshmanan 
declarative semantics behavioral inheritance conflict resolution 
john lloyd editor proceedings th international logic programming symposium pages portland oregon december 
mit press 
hasan jamil 
belief reasoning mls deductive databases 
alex christos faloutsos ghandeharizadeh editors proceedings acm sigmod international conference management data philadephia pennsylvania pages 
acm press 
kifer lausen wu :10.1.1.115.3586
logical foundations object oriented frame languages 
journal association computing machinery july 
vermeir 
fixpoint semantics ordered logic 
journal logic computation 
lakshmanan sadri 
probabilistic deductive databases 
proc 
international logic programming symposium pages ithaca ny november 
mit press 
lakshmanan 
declarative frameworks inheritance 
jan chomicki gunter saake editors logics databases information systems pages 
kluwer academic publishers 
lou ozsoyoglu 
object oriented deductive language methods method inheritance 
clifford king editors proceedings acm sigmod intl 
conf 
management data pages denver colorado 
mccabe 
logic objects 
prentice hall international london 
miller 
logical analysis modules logic programming 
journal logic programming january march 
monteiro porto 
contextual logic programming 
th alp intl 
conf 
logic programming 
monteiro porto 
transformational view inheritance logic programming 
warren szeredi editors proc 
th int 
conference logic programming pages 
mit press 
keefe 
algebra constructing logic programs 
ieee symposium logic programming 
przymusinski 
perfect model semantics 
kowalski bowen editors proc 
th int 
conference logic programming pages 
mit press 
prasad rao sagonas swift david scott warren freire 
xsb system computing wfs 
proceedings intl 
conference logic programming non monotonic pages 
sagonas swift david scott warren 
xsb efficient deductive database engine 
richard snodgrass marianne winslett editors proceedings acm sigmod international conference management data minneapolis minnesota pages 
acm press 
shaw garcia wood zaniolo 
improving data quality ldl 
workshop deductive databases jicslp pages 
touretzky 
mathematics inheritance systems 
morgan kaufmann los altos ca 
ullman 
principles database knowledge base systems 
computer science press 
van emden 
quantitative deduction fixpoint theory 
journal logic programming 
ghosh yuan goebel 
introspective framework paraconsistent logic programs 
john lloyd editor proceedings th international logic programming symposium pages portland oregon december 
mit press 
zaniolo 
object oriented programming prolog 
international symposium logic programming pages atlantic city february 
zaniolo 
object identity inheritance deductive databases evolutionary approach 
kim 
nicolas nishio editors proc 
st dood conference pages kyoto japan 
north holland 
