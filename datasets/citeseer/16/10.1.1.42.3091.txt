type inference polymorphic recursion fritz henglein diku university copenhagen copenhagen east denmark internet henglein diku dk june revised december damas milner calculus typed calculus underlying type system ml strongly typed polymorphic functional languages miranda haskell 
mycroft extended problematic monomorphic typing rule recursive definitions polymorphic typing rule 
proved resulting type system call milner mycroft calculus sound respect milner semantics showed preserves principal typing property damas milner calculus 
extension practical significance typed logic programming languages generally language mutually recursive definitions 
show type inference problem milner mycroft calculus log space equivalent semi unification problem solving subsumption inequations order terms 
result proved independently kfoury tiuryn urzyczyn 
connection established undecidability semi unification implies typability milner mycroft calculus undecidable 
reasons type inference polymorphic recursion appears practical despite undecidability 
sheds light observed practicality ml face theoretical intractability results 
exhibit semi unification algorithm flexible practical implementable type inference algorithm damas milner milner mycroft typing 
polymorphic recursion designed languages standard ml mth try combine safety compile time type checking flexibility declaration programming inferring type information program insisting extensive declarations 
ml type appear acm transactions programming languages systems toplas 
research performed new york university courant institute mathematical sciences support onr contract numbers 
miranda tm trademark research software limited 
system call damas milner calculus allows definition parametric polymorphic functions functions operate uniformly arguments may range variety types 
peculiarity damas milner calculus occurrences recursively defined function inside body definition occurrences identically typed arguments results typed identically occurrences outside body polymorphically arguments different types 
reason mycroft myc independently meertens suggested polymorphic typing rule recursive definitions allows polymorphic occurrences defined function body 
mycroft shown resulting type system termed milner mycroft calculus sound respect milner semantics mil principal typing property damas milner calculus preserved 
standard unification type inference algorithm complete polymorphic recursion 
motivation studying mycroft extension ml typing discipline may esoteric purely theoretical interest stems practical considerations 
ml typing problems attributable monomorphic recursive definition constraint avoided appropriately nesting function definitions inside scopes previous definitions 
ml provides polymorphically typed definitions giving rise term polymorphism nesting definitions workable scheme cases 
languages provide nested scoping top level function procedure definitions abc gmp setl prolog ss 
consequently top level definitions combined considered single generally mutually recursive definition 
adopting ml monomorphic typing rule recursive definitions languages precludes polymorphic usage defined function inside definition 
particular logic programs observed mo viewed massive mutually recursive definitions ml style type system eliminate polymorphism strongly typed logic programming languages completely 
mycroft extension hand permits polymorphic usage language setting 
cases possible investigate dependency graph call graph mutually recursive definitions process maximal strong components topological order treat implicitly polymorphically typed nested definitions 
undesirable reasons 
resulting typing discipline explained syntax directed fashion reminiscent data flow oriented reasoning 
runs contrary structured programming program understanding 
particular finding source typing errors program text difficult problematic attribution type errors source code ml languages jw wan 

topological processing completely capture polymorphic typing rule 
mycroft reports mutually recursive definition encountered real life programming project typed ml typed polymorphic typing rule recursive definitions myc section 
similar cases reported 
ml mailing list 
example consider joint definition functions map standard ml taken myc 
fun map null nil hd map tl map fn int 
written simultaneous definition map definition map 
ml type checker produces types map int int int list int list int list int list due ml monomorphic recursion rule expect sequential recursive definitions map yield type map map ff fi ff fi theta ff list fi list map argument type different int list get type error 
outline section review formal definition milner mycroft calculus damas milner calculus typing system functional core ml 
section contains semi unification problem solving equations subsumption inequations order terms 
section constitutes technical core type inference formally connected show typability milner mycroft calculus semi unification log space equivalent 
reduction milner mycroft typability semi unification steps 
formulate syntax directed type inference systems equivalent canonical type inference system calculus 
order version show extract possibly untypable input program system equations inequations unquantified type expressions characterizes typability generally typings program 
converse reduction semi unification milner mycroft typability factored steps 
introduce pairs milner mycroft calculus demonstrate term equations encoded typing constraints monomorphic fragment calculus 
show finite set term inequations represented typing constraints single recursive definition milner mycroft calculus 
section simple flexible rewriting system semi unification initial system term equations inequations rewritten reaches normal form runs error condition 
possible computation terminate know due extended occurs check known natural cases occurs 
sketch flexible graph theoretic version algorithm supports structure sharing optimizations practical importance 
generic semi unification algorithm basis practically efficient generic type checker works batch oriented interactive programming environments ml languages polymorphic recursion 
section show sense type inference difficult type checking explicitly typed programs presence polymorphic recursion prove type inference damas milner calculus milner mycroft calculus complexity theoretically tractable argue reasonable restriction type expressions super polynomially bigger underlying untyped programs 
offer tentative explanation observed practicality ml type inference 
reasoning applies milner mycroft typing expect find type inference polymorphic recursion equally practical 
section concludes short summary main results brief remarks possible research 
predicative polymorphic type inference systems purpose studying polymorphic type inference isolation concerns shall restrict notationally minimal programming language extended calculus bar 
typing disciplines defined inference systems typing assertions expressions 
exposition relevance type theory programming language design see cardelli wegner cw 
barendregt bar hindley seldin hs indepth calculus 
mitchell mit date overview semantics simply typed calculus 
extended lambda calculus notational conventions fairly standard see dm myc 
programming language extended calculus abstraction application nonrecursive recursive definitions 
theory developed pure calculus constants constants viewed variables binding global environment 
set expressions expressions defined syntax 
fix ranges countably infinite set variables 
expression 
may written denotes sequence 
generally vector notation refer sequences sets objects ffl stands empty sequence 
operational semantics expressions defined reduction reflexive transitive compatible closure notion reduction see bar chapter defined note adopt descriptive view sense programs defined independently types typings describe properties programs 
prescriptive view programs defined types typings typings prescribe constitutes typed program place 
views referred curry church respectively may ascribed formulations curry church typing calculus 
purposes type inference difference 
relation compatible closed contexts implies context surrounding respectively fix fix denotes expression resulting substituting occurrences untyped calculus fix expressions encoded abstractions applications 
encodings generally typable typing disciplines shall study forms introduced language primitives 
types typings type expressions formed productions ff oe ff oe ff ranges infinite set tv type variables disjoint type variable binding operator 
type expressions derived called simple types larger set type expressions derived oe types schemes 
fv oe denotes free type variables oe 
milner mil call bound type variables type scheme generic free variables nongeneric 
convention ranges types oe type schemes 
note quantifiers type schemes appear prefixes type expressions critical difference impredicative second order calculus gir rey mit glt 
type environment mapping finite subset variables type expressions 
type environment define afx oeg oe value afx oeg oe value identical say type variable ff occurs free occurs free domain write fv set free type variables typings formed formulae judgments type systems 
typing consists parts type environment expression type expression oe written oe 
read type environment expression type oe 
course typings acceptable 
acceptability defined statically derivability specified inference system 
damas milner calculus damas milner calculus logical form type inference system investigated damas milner mil dm dam basis earlier curry cf cur morris mor hindley hin 
encodes polymorphism results ability languages ml mth miranda tur haskell hw give bound variable type scheme automatically implicitly instantiated possibly different types applied occurrences range type environments variables type variables expressions types oe oe type schemes 
name axiom rule taut afx oeg oe inst oe oe gen oe free oe appl ee abs afx oe afx oeg oe oe fix afx fix damas milner type inference system dm fix afx oeg oe fix oe polymorphic recursion typing rule milner mycroft type inference system mm canonical type inference system dm damas milner calculus dm 
note rule fix type expression associated recursively defined type type scheme 
implies occurrences type milner mycroft calculus milner mycroft calculus investigated mycroft myc lei lei lei kfoury tiuryn urzyczyn ktu ktu author hen hen differs damas milner calculus general rule recursive definitions 
models languages hope bms miranda abc gmp permit recursively defined functions parameterized type schemes instantiated arbitrary types inside scope definition 
hope miranda admit polymorphically typed recursive definitions top level require explicit type declarations functions 
abc permits nesting scopes place require explicit type declarations 
milner mycroft calculus restrictions requires explicit declarations permits nested polymorphically typed recursive definitions 
canonical type inference system mm milner mycroft calculus myc identical dm presentation damas milner calculus 
rule fix supplies polymorphic recursion rule fix permits recursively defined polymorphic 
fundamental properties type variables type schemes range types type schemes type systems called predicative mit 
expression typable typed calculus milner mycroft calculus typing oe derivable dm mm respectively 
milner mycroft calculus preserves desirable properties damas milner calculus 
particular mm principal typing property myc states typable expression unique general type cf hin dm 
furthermore subject reduction property due curry cf chs original form combinatory logic states typings preserved reduction section 
sound respect milner semantic characterization typing mil myc expression generates type error run time typable 
damas milner typability decidable specifically typability curry hindley calculus free fragment damas milner calculus deterministic polynomial time complete folk theorem typability full damas milner calculus deterministic exponential time complete km mai ktu kmm 
milner mycroft typability semi unification log space equivalent see section semi unification shown recursively undecidable ktu 
semi unification semi unification generalization unification matching applications proof theory term rewriting systems pur polymorphic type inference hen ktu lei natural language processing dr 
fundamental nature expected find applications 
section review basic definitions properties semi unification 
detailed account hen chapters 
basic definitions ranked alphabet finite set function symbols arity function maps element natural number possibly zero 
function symbol arity called constant 
monadic function symbols arity polyadic 
set variables denumerable infinite set disjoint terms constitute set consisting strings generated grammar 
function symbol arity indicated superscript constant variable set variables occurring denoted fv 
terms equal written identical strings 
distinction monadic polyadic alphabets crucial terms monadic alphabet variable terms polyadic alphabet contain number variables 
substitution mapping identity finite subset set variables identity domain substitution naturally extended defining 

substitution specifies simultaneous replacement set variables specific terms 
write substitution finite mapping domain understanding acts identity variables outside domain 
example fx 

vg 
write sj restricted substitution defined sj ktu refutes earlier claim ktu decidability milner mycroft typability authors 
sequence terms sequence variables equal length denotes substitution maps variable term corresponding position variables 
case write result application term term subsumes matches written substitution subsumes fx 

zg equality holds 
matches exactly domain contained set variables occurring call quotient substitution denote systems equations inequations semi unifiers set inequations fm 
substitution semi unifier inequalities 
hold exist substitutions 
equalities 
hold 
semi unifiable semi unifier 
shall call system inequations si 
systems equations inequations sei form fm 


substitution semi unifier sei 

hold 
note systems equations notions semi coincide 
notational convenience may drop set brackets sei 
convenience shall tupled inequations sei 
may write 



arbitrary ary context 
semi unifier single substitution 

known finite set equations represented single equation tupling 
case inequations 
proposition connection semi unification unification precise particular shows equations encoded inequations 
proposition substitution unifier equation semi unifier 
proof identity substitution id id id 
conversely substitution follows immediately 
similar way shown unifiable fm mg semi unifiable 
semi unifier necessarily unifier 
definition follows hue ede dual definition lmm 
ary context term holes place subterms 
note exists ary context long underlying alphabet polyadic 
known solvable system equations general unifier unique modulo equivalence relation substitutions ede lmm 
similar result obtained systems equations inequations 
phrase result algebraic terms 
subset phi phi set substitutions defined phi phi 
phi induces equivalence relation phi substitutions defining phi phi phi partial ordering phi equivalence classes compatible phi theorem system inequations polyadic alphabet set solutions denoted phi subset contains variables occurring equivalence classes induced phi adjoined maximum element omega form complete lattice gamma phi infinite 
full proof theorem scope 
hen 
corollary semi unifiable system inequations substitution general semi unifier 
semi unifier 
semi unifier substitution variables occurring second property corollary replaced ffi contrast unification substitution form ffi general semi unifier theorem yields reduction typability semi unification section alternative proof principal typing property calculus type system reduced semi unification similar fashion damas milner calculus hen 
semi unification refers general problem process solving sei polyadic alphabets general semi unifiers specific problem deciding semi unifiers exist semi rely context disambiguation 
semi unification long believed decidable kfoury tiuryn urzyczyn elegant reduction boundedness problem deterministic turing machines semi unification ktu 
adapting proof similar problem attributed hooper hoo show boundedness undecidable implies undecidability semi unification 
special cases semi unification shown decidable uniform solving single term inequation hen semi unification variables lei left linear semi unification ktu hen quasi monadic semi unification lh 
finite number term inequations effectively reduced inequations semi unification restricted inequations remains undecidable 
equivalence milner mycroft typing semi unification section show milner mycroft typability semi log space equivalent 
notably type quantification milner mycroft calculus completely characterized semi unification quantifier free concept 
note different notions equivalence literature see lmm excellent survey unification 
particular show semi unification reduced milner mycroft typability expressions contain operator occurrence polymorphic recursion operator fix 
implies difficulty type inference completely subsumed single polymorphically typed recursive definition 
polymorphic bindings nested fix bindings add problem 
contradicts meertens expectations nested declarations higher order functions type inference harder abc mycroft suggestion prohibit nested polymorphic recursive definitions due exponential cost analysing nested fix definitions myc 
connection undecidability semi unification implies milner mycroft typing undecidable restricted single recursive definition 
semi unification reduced type inference abc hen type checking abc programs undecidable 
practical benefit reduction milner mycroft typability semi unification shows generic semi unification algorithm basis flexible type inference algorithm polymorphically typed languages polymorphic recursion 
detailed section 
obtain product explicit log space reductions unification typability curry hindley calculus free fragment damas milner calculus 
yields proof apparently long known folk theorem curry hindley typing complete log space reductions 
damas milner typability characterized polymorphic unification km kmm acyclic semi unification ktu 
characterization milner mycroft typability semi unification independently kfoury ktu fact kfoury tiuryn extended include second order calculus limited rank derivations kt 
characterizations type inference inequality constraints involving quantified types second order calculus mit 
reduction milner mycroft typability semi unification section converse reduction section 
reduction typability semi unification reduction milner mycroft typability semi unification originally reported hen 
broken follows 
syntax directed version calculus uses type schemes type environments section 
show type schemes encoded equivalent type inference system uses simple types section 
typability type inference system characterized systems equations inequations types section 
syntax directed presentation milner mycroft calculus type inference system syntax directed 
means structure typing derivation expression directly correspond syntactic structure 
solely due rules inst gen see section proof steps involving rules change expression typing 
syntax directed system derivation expression essentially tree structure syntax tree advantage syntax directed inference system think derivation attribution syntax tree 
syntax directed presentation milner mycroft calculus called mm 
write mm derivable 
note contains inst range type environments variables expressions ff sequences type variables types sequences types ff denotes type occurrence type variable ff replaced corresponding type type inference axiom rule schemes syntax directed type inference system 
name axiom rule taut afx ff ff abs afx appl ee afx ff ff fv gamma fv fix afx ff ff fv gamma fv fix ff syntax directed milner mycroft type inference system mm gen 
instantiation type schemes types restricted variable occurrences incorporated new axiom taut 
generalization types type schemes restricted fix expressions incorporated new typing rules fix 
typings exclusively form type type scheme 
step direction eliminating constraints involving quantified types note type schemes occur type environments 
shall prove mm weaker stronger original system 
need technical proposition stating quantified type variables renamed 
proposition type environment expression type expressions oe oe type variables ff ff 
ff fi fi 
fi 
ff oe fi oe fi ff 
afx ff oeg oe afx fi oe fi ff oe justified proposition shall assume henceforth bound type variables occurring type scheme oe occur outside oe 
theorem type environment expression type variables ff ff 
ff free type mm ff mm corollary typable mm typable mm 
theorem extension theorem damas milner type inference system dm milner mycroft calculus essentially identical proposition ktu 
theorem immediate consequence technical strengthening 
lemma type environment expression type variables ff ff 
ff free type mm ff mm ff proof proceed structural induction derivations milner mycroft calculus section 
cases similar 
taut trivial derivation involving taut afx ff ff taut mm immediately afx ff ff 
fix assume fix ff derivable milner mycroft calculus fix rule afx ff ff fixx ff proposition may assume ff free afx ff induction hypothesis know afx ff derivable mm consequently get afx ff ff free fixx ff rule fix 
sufficient show mm mm shall prove axiom rule scheme syntax directed milner mycroft calculus derivable ordinary milner mycroft calculus 
cases 
taut afx ff ff derivable taut mm typing derivation milner mycroft calculus afx ff ff taut afx ff ff inst inst denotes fold application rule inst 
fix derivation syntax directed milner mycroft calculus application fix rule afx ff ff free fixx ff construct corresponding derivation milner mycroft calculus follows 
afx ff ff free afx ff ff gen fixx ff fix fixx ff inst similar results normalizing typing derivations mit car 
order presentation milner mycroft calculus mm type schemes occur type environments 
shall modify mm syntax directed version milner mycroft calculus uses exclusively types type schemes 
main question addressed represent difference generic nongeneric type variables type environment explicit quantification 
difference generic nongeneric variables crucial taut rule ff type occurrence variable substitution instance type generic type variables instantiated 
eliminate explicit quantification replace losing crucial distinction generic nongeneric type variables 
answer question key observation implicit milner original presentation mil called damas milner calculus fix bound variable type environment afx treat type variable ff generic occurs type bound variable see rules fix 
bound type variable nongeneric see rule abstr 
milner solution distinguishing generic nongeneric type variables explicit quantification sequences bindings form fix place type environments type variables occurring bindings nongeneric generic 
shall different solution suits purposes somewhat better 
say underlying simple type type scheme oe oe ff type variables ff 
extension underlying simple type environment general type undefined underlying type 
underlying simple type environment sequence types represents written fv gamma fv fv 
intuitively types simply types bound variables encountered processing expression 
generic type variables determined exactly occur representations type environments constructed easily proved proposition 
proposition ff fv gamma fv 
afx fx 
afx fx ff replacing type environments underlying simple type assignments types bound variables type environment possible give order presentation milner mycroft calculus 
furthermore restriction substitution generic variables rule taut formulated single subsumption inequality types 
recall fx ff derivable syntax directed presentation milner mycroft calculus substitution fi fi fi fv fx ff 
afx fx ff equivalent tupling notation section 
consequently possible replace taut rule taut afx rules easily adapted 
resulting type system mm displayed 
write mm derivable mm 
derivable typings type system faithfully describe typings mm syntax directed presentation calculus expressed theorem 
theorem mm mm range simple type environments variables expressions types sequences types 
type inference axiom rule schemes order milner mycroft type inference system 
name axiom rule taut afx abs afx appl ee afx fix afx fix order presentation mm milner mycroft calculus fg ffl 
ff ff fx ff ff 
ff ff fx ff ff ff fx ff ff ff yy ff fx ff ff ff ff fx ff ff ff ff fflffl fflffl ssg fflffl typing derivation template yy ff ff ff ff ff ff ff ff iiii iii iii iiii iii fflffl jj jj jj jj fflffl tt tt tt tt tt tt fflffl syntax tree attributed unique type variables left right implication proved induction typing derivations mm reverse implication induction typing derivations mm 
main technical insight necessary proof justification encoding rule taut rule taut eliminates explicit distinction generic nongeneric variables 
corollary underlying simple type environment ff fv 
mm ff characterization equations inequations reduction milner mycroft typing semi unification complete 
assume 
associate unique type variable ff occurrence expression variable unique derivation template ff disregarding side conditions types set right rules 
consider example expression yy 
typing derivation template depicted 
template isomorphic syntax tree underlying expression node attributed unique type variable see 
substitution mapping type variables types maps template valid typing derivation satisfies side conditions required typing rules 
sei ff case ff ff ff ff ff fresh type variable fff ff ff ff ff ff fresh type variables ff sei afx ff ff ff fff ff ff ff ff fresh type variable ff sei ff ff sei ff fff ff ff ff ff ff ff fresh type variables ff sei ff ff sei afx ff ff fix fff ff ff ff ff ff ff ff ff fresh type variables ff sei afx ff case 
definition sei ff side conditions ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff notice side conditions expression form system equations inequations alphabet 
contains function symbol 
follows fact syntactic construct exactly typing rule applicable side conditions types satisfied type meta variable occurs antecedent 
formally simple type environment sequence type variables ff expression define system equations inequations type variable ff ff sei ff procedure sei 
bound variables generate equational constraint ff ff ff ff ff guaranteed contain ff equivalent ff see proposition section 
theorem ff sei ff 
ff mm ff left right implication proved induction typing derivations mm converse implication proved induction details proof self evident omitted 
corollary expression milner mycroft typable ff system equations inequations generated sei ff semi unifiable 
damas milner typing analogously reduced semi unification 
equational constraints fewer inequality constraints comparison milner mycroft typing 
change constraint generated fix expression inequation ff ff ff ff replaced equality ff ff curry hindley calculus extracted constraints equational resulting problem unification solved efficiently number unification algorithms hue pw mm 
additional inequational constraints damas milner calculus innocuous sight long believed damas milner typability equally efficient lei mh refuted kanellakis mairson mitchell km mai kmm kfoury tiuryn urzyczyn ktu 
concludes reduction typability canonical milner mycroft type inference system semi unification 
left ascertain reductions implemented logarithmic auxiliary space 
theorem milner mycroft typability log space reducible semi 
proof syntactically formed expression fully parenthesized notation type environment equivalent sei constructed composition log space reductions 
generation underlying simple type environment free type variables ff 
generation system equations inequations returned sei ff 
accomplish generation equations inequations logarithmic space procedure literally implicitly uses stack passes list type variables ff argument 
values ff relevant subexpression occurring determined logarithmic space input location need stored explicitly 
furthermore call structure sei follows syntactic structure storing stack explicitly necessary 
possible implement sei ff logarithmic space 
corollaries generated sei semi unifiable milner mycroft typable 
note checking syntactic correctness part reduction assumed syntactically correct representation correct syntax tree 
range type environments types 
typing rules pairs projections follows 
pair fst snd typing rules pairs projections reduction semi unification milner mycroft typability reduction semi unification milner mycroft typability proceeds stages 
introduce pairs pair types milner mycroft calculus section 
identify order terms certain representations section define encodings term equations section 
coincidentally produces log space reduction unification curry hindley type inference 
encode systems inequations fix expressions section 
believe pairing conspicuous presentation reduction 
somewhat different reductions hen ktu 
milner mycroft calculus pairing convenient expressions pairs corresponding component projections 
standard encoding pairs 
free correspondingly define notation easy check rules pairs projections derivable mm 
fact typing pairs projections instance rules 
note equal type result component projection expression 
particular variable simple type type correct case stronger typing condition expect pairs language primitives 
illustrate problem consider expression 
disregarding subscripts expect type ff fi ff fi 
ff fi 
usual type ff fi fl ff ff fi fl fi 
projections components expression type ff ff ff ff 
ff ff ff 
expression typable 
problem motivated mairson mai representation pairs typing rules faithfully reflect component types pairs independent 
necessary case encounter situation 
mairson representation reduce typing pairs typing pairs 
alternatively keep standard representation pairs check steps subsections correct 
simply write pairs projections pair types rules subscripts language primitives milner mycroft calculus enriched pairs 
representation terms shown semi polyadic monadic alphabet reduced semi alphabet contains single binary function symbol hen 
name function symbol irrelevant simply write term identify terms expressions built variables pairing 
extend simple type environment mapping terms types follows lemmas needed encodings equations inequations 
imply different domain range may treat substitution terms 
lemma simple type environments terms types mm lemma simple type environment terms 

unifiable 

semi unifiable 
encoding equations write expression ye ye occur freely theorem terms fv fv 
equation unifiable curry hindley typable 
proof principal type treated principal relative application pair 
faithfully encode operational semantics pairing projections 
unifier arbitrary simple type environment domain contains variables occurring 
define domain lemma 
unifier types equal consequently typable type environment simple typable 
typable simple type environment type lemma lemma unifiable 
corollary curry hindley typability unification log space equivalent particular curry hindley typability complete 
proof follows completeness unification dkm 
encoding inequations gain intuition encoding systems inequations consider single inequation inequations arise particular typing fix bound variables type inference system mm 
note types equal welltyped expression form fix force type term hide sense affect type encoding bound type typing rules fix type occurrence substitution instance type type substitution instance type generally contain free variables little bit careful 
sure different occurrences free variable type corresponds semi unifier uniformly applying substitution occurrences variable variables bound place case encodings equations reason way 
bindings variables go outside expression fix mean fix binding scope bindings essentially type variable type instantiated 
consequently place bindings go just fix binding fix turn complicates encoding equation 
details 
theorem semi unification log space reducible milner mycroft typability specifically system inequations log space computable expression form fix fix free semi unifiable milner mycroft typable 
proof loss generality may assume show reduce system inequations fm sufficient result 
alternatively proof easily generalized number equations inequations 
consider expression fix fv fv fv fv clearly expression constructed logarithmic space sei 
analysis mm find milner mycroft typable types ff 
ffl ff 
ffl derivable mm ffl denotes empty sequence 
denote lemma furthermore rule taut mm typings derivable uniquely determined quotient substitution inequalities typable type environment lemma means milner mycroft typable fm semi unifiable 
corollary problems log space equivalent 
milner mycroft typability 
semi 
milner mycroft typability restricted expressions containing single top level fix operator expression 
proof steps proved theorems respectively trivial 
semi unification algorithms section shown semi unification heart polymorphic type inference milner mycroft calculus 
section address problem computing general semi unifiers 
computing general semi unifier system equations inequations sei corresponds directly computing principal typing expression equations inequations generated 
basic question asked point interested consider algorithms semi unification semi unification type inference polymorphic recursion undecidable 
defer discussion question section 
suffice say point expect type inference polymorphic recursion just practical ml type inference 
algorithms computing general semi unifier sei chapter 
sei rewriting system partial correctness follows soundness completeness theorem shows class solutions invariant rewritings section 
second algorithm graph theoretic version sei rewriting algorithm 
permitting structure sharing arrow graphs term graphs additional structure expect algorithm yield practically efficient implementations 
helpful analyzing termination properties complexity restricted problems hen lh section 
third functional algorithm hen 
algorithms viewed manifestations implementations single algorithm 
discussion flexible implementation strategy section type checkers polymorphic languages generic semi unification algorithm concludes section 
sei rewriting algorithm section basic implementable rewriting system computing general 
natural straightforward extension rewriting system general unifiers reportedly goes back herbrand martelli montanari starting point development efficient unification algorithms mm 
novel extended occurs check catches practice cases type inference algorithms meertens algorithm aa mycroft myc relaxation algorithm chou cho enter infinite loop 
similar rewriting system occurs check clause similar lei lei 
sei rewriting system 
preserves semi unifiers sense shall precise 
definition reduction relation systems equations inequations fv set variables occurring sei 
relation sound semi unifier semi unifier sj 
relation complete semi unifier semi unifier sj fact know explicitly constructed semi unification instance rewriting system terminate 
note instances exist ktu 
sei inequations initially tag inequality symbols distinct colors 
indicate inequation belong 
done superscripts inequality symbol nondeterministically choose equation inequation take rewriting action depending form 



replace equations 



distinct function symbols replace current sei function symbol clash 


replace 
mm 


occurs 
replace current sei occurs check 

occur occurs equation inequation replace equations inequations 

delete 



replace inequations 

delete inequations add equation 

variables 
inequations current sei gamma exists occurs replace current sei extended occurs check 


sequence variables 
inequations current sei gamma occurs add equation 

fresh variables occurring current sei 
special symbol denotes unsolvable sei 
sei rewriting specification informally speaking soundness expresses reduction step add semi unifiers completeness means semi unifiers lost reduction step 
proposition reduction relation defined sei rewriting system sound complete 
proof induction number rewriting steps 
sei normal form respect reduction relation sei normal form respect sei rewriting system easy extract general semi unifier 
proposition system equations inequations normal form respect reduction relation defined sei rewriting system 
fx 

substitution fx 


general idempotent semi unifier sei semi unifiable sei rewriting system terminate proper normal form sei equal read general semi unifier result proposition substitutions sj fv general semi unifiers semi unifiable rewriting system stops improper sei terminate 
main reason nontermination rule introduces new variables time executed 
replacing pleasing rule pur 
add equation 

eliminates nontermination problem rewriting derivations correctness 
see consider example system consisting single inequation 
derivation lead claim incorrectly semi unifiers 
consider system ff yg easy see unsolvable 
caught extended occurs check rule 
arrow graph rewriting system fast unification algorithms hue pw mm asu term graphs data structure supports sharing subexpressions eliminate potentially exponential cost copying terms applying substitutions 
arrow graphs term graphs additional structure represent equations inequations terms translate sei rewriting system arrow graph rewriting system 
arrow graphs term graph graph represents sets terms alphabet set variables consists set nodes subset labeled function symbols rest labeled variables function symbol arity node labeled exactly ordered children directed term edges originating labeled numbers variable labeled nodes children variable node labeled term edges contain cycles say term graph acyclic 
node acyclic term graph interpreted term example node labeled function symbol children 
order representing terms 
represents term 

note set terms easily constructed generally non unique term graph term represented 
arrow graph term graph equivalence relation nodes representing equations additional directed edges called arrows 
arrows directed edges labeled natural numbers indicate inequation system equations inequations arrow derived 
call labels arrows colors write colored arrow pointing arrow graph representation system equations inequations fm 
term graph necessarily distinct nodes 

representing terms arrows representing representing pairwise distinct colors nontrivial equivalence summarize terms represented nodes underlying term graph equations equivalence relation inequations directed labeled edges called colored arrows 
algorithm algorithm 
operates follows 
set closure conditions arrow graphs depicted interpreted rewrite rules 
repeatedly rewrites arrow graph nondeterministically choosing applicable rewrite rule rewrite rule applicable 
final normalized arrow graph node interpreted unique term 
algorithm correct arrow graph rewriting steps correspond directly rewriting steps sei rewriting system 
implementing type inference algorithm flexible practical basis implementing type inferencer language polymorphic recursion 
particular easily adapted highly interactive programming environment 
tied syntax peculiarities programming language may serve generic basis languages 
envisage polymorphic type inferencer main components conceptually execute concurrently constraint extraction module semi unification module 
constraint extraction module generates equations inequations syntax tree symbol table front input processor feeds semi unification module parts arrow graph representations semi unification module normalizes algorithm 
batch oriented programming environment typing constraints complete program generated fed semi unification module 
interactive environment constraints single function definition arrow graph 
apply steps depicted convergence 
exist nodes labeled function symbol children respectively merge equivalence classes 
exist nodes labeled function symbol children respectively place arrows 
exist nodes merge equivalence classes place arrow 
extended occurs check path consisting arrows color arrow path reachable zero term edges reduce improper arrow graph 
extended occurs check applicable exist nodes labeled function symbol children equivalent function symbol labeled node arrow create new nodes initially equivalence class label function symbol label new variables respectively children merge equivalence classes algorithm closure rules passed semi unifier incremental type checking 
case typing constraints semi unifier soon available input processor type checker runs essentially completely synchronously input processing displaying high degree interactivity 
scheme simple works interactively long typing constraints added removed input processing 
facilitate flexible program development type inferencer support incremental type checking constraints eliminated due editing changes underlying program may come detection type error interactive program development session 
implemented functional semi unification algorithm described henglein hen setl experiment semi unification proved helpful stages type inference semi unification 
currently implementations type realistic languages integrate ideas 
size bounded typing view undecidability type inference languages polymorphic recursion appear hopeless futile 
interestingly polymorphic recursion type inference theoretically intractable ml typing dexptime complete km mai kmm ktu 
remarkable contrast positive practical experience actual languages ml typing rules 
section offer general considerations suggest observed practicality polymorphic type inference merely coincidental section briefly formalize considerations 
statements results section taken grain salt 
reflect concern explaining reconciling apparent contradictions theory staggering lower bounds practice acceptable performance actual implementations hoped provide fruitful insights leading substantial question 
theoretical intractability practical utility polymorphic type inference practical experience suggests complexity theoretic cost polymorphic type inference damas milner milner mycroft type systems pessimistic 
consider points 
possible typings expression represented principal typing 
second due principal typing property relatively simple type inference algorithms necessitate backtracking complicated control mechanisms 
third languages ml miranda abc years type systems reasonably efficient actual 
fact observed efficiency helped myth ml type checking theoretically efficient believed years worst case polynomial running time low degree 
sole reason cost type inference milner mycroft calculus calculus get hand type inferencer manipulate type expressions sizes bigger underlying untyped program 
conventional remedy eliminating problems type inference mandate explicit fully typed declarations variables parameters basic syntactic units 
applying sort remedy milner mycroft calculus ml highlights type checking explicit type information embedded program practical type inference optional type information program constructible fit page theoretically typed writing principal types require number atoms universe 
writing explicitly typed version program manifestly impossible start 
say case type inference faster type checking implemented type inferencer infer types faster programmer write 
formalization type inference combinatorial problem inference system damas milner milner mycroft calculus take intensional character types typings account 
semantic world types typings generally viewed abstractions behavior programs parts 
argue reflected syntactic world type expressions thought syntactic abstractions syntactic parts programs 
size type expression stands reasonable relation size underlying program text say exponentially bigger unreasonable consider type expression abstraction program text 
interpreted saying program reasonable type description behavior typing discipline considered type incorrect 
rationale decision formulated programs small types 
similar argument suggested boehm boe observations ml programs km consistent explanation 
suggest imposing bound sizes types type system definitional requirement type systems small size bound property type system 
remains seen type system defined logically robust fashion 
possibility require type declarations bindings 
example hope mandates explicit type declarations recursive definitions 
hope type inference harder ml type inference 
additionally type declarations mandatory nonrecursive definitions type inference harder unification 
type inference programs small types typed expression expression binding decorated type fix binding decorated type scheme typed typing derivation milner mycroft calculus particular type assumptions variables 
say unique untyped version typed version typed call typed version clearly typed typable 
say untyped expression size small typing typed version size fixed polynomial theorem milner mycroft typability small types polynomial time decidable 
proof size typed version big size normalized arrow graph representation equations inequations constructed see reflects view types class objects programming language 
bad programs fail small types 
section 
arrow graph representation monotonically grows polynomial number rewriting steps polynomial number rewriting steps executed algorithm terminates arrow graph representation bigger 
consider type system typed version untyped program witness fact typed typing problem witnesses required small polynomial sized np long type checking explicitly typed programs done polynomial time 
type checking damas milner milner mycroft higher order typed calculi 
type checking presence overloading done polynomial time 
associated type inference problems intractable mai ktu hm asu exercise 
note type inference small types damas milner milner mycroft systems type inference overload resolution remains np complete 
conjecture higherorder typability small types np complete 
lends technical expression intuition overload resolution harder polymorphic type inference 
summary outlook milner mycroft calculus type system permits polymorphic usage recursively defined functions inside definitions 
extension away need carefully craft set function definitions list nested definitions order satisfy type checking constraints inherent ml style type systems 
shown type inference problem milner mycroft calculus log space equivalent semi unification 
semi unification algorithm generic basis batch oriented interactive type checker inferencer 
semi unification shown undecidable argued practice programs small types typed milner mycroft type inference small types tractable 
think provides insight ml type checking usable practice despite theoretical intractability 
utility polymorphic recursion polymorphic function arguments remain evaluated concrete language setting 
special attention interaction polymorphic type inference data types coercions inheritance overloading 
wish ed schonberg bob paige support valuable interaction algorithmic aspects type inference 
am especially thankful harry mairson great interest suggesting improvements exposition 
benefited greatly hans lei insights semi unification special cases 
asu aho sethi ullman 
compilers principles techniques tools 
addison wesley 
addison wesley reprinted corrections march 
bar barendregt 
lambda calculus syntax semantics volume studies logic foundations mathematics 
north holland 
bms burstall macqueen sannella 
hope experimental applicative language 
stanford lisp conference pages 
boe boehm 
type inference presence type abstraction 
proc 
sigplan conf 
programming language design implementation pages 
acm acm press june 
car cardelli 
semantics multiple inheritance 
information computation information control 
clement despeyroux despeyroux kahn 
simple applicative language mini ml 
inria centre sophia antipolis rr may 
cf curry feys 
combinatory logic volume north holland 
cho chou 
relaxation processes theory case studies applications 
master thesis ucla february 
technical report csd 
chs curry hindley seldin 
combinatory logic volume ii studies logic foundations mathematics 
north holland 
cur curry 
modified basic functionality combinatory logic 
dialectica 
cw cardelli wegner 
understanding types data abstraction polymorphism 
acm computing surveys dec 
dam damas 
type assignment programming languages 
phd thesis university edinburgh 
technical report cst 
dkm dwork kanellakis mitchell 
sequential nature unification 
logic programming 
dm damas milner 
principal type schemes functional programs 
proc 
th annual acm symp 
principles programming languages pages jan 
dr rounds 
subsumption feature algebras 
proc 
ieee symp 
logic computer science lics pages 
ieee computer society press july 
ede eder 
properties substitutions unifications 
symbolic computation 
gir girard 
une extension de interpretation de godel analyse son application elimination des coupures dans analyse la theorie des types 
nd scandinavian logic symp pages 
glt girard lafont taylor 
proofs types volume cambridge tracts theoretical computer science 
cambridge university press 
gmp meertens pemberton 
abc programmer handbook 
prentice hall new york 
giannini ronchi della rocca 
characterization typings polymorphic type discipline 
proc 
symp 
logic computer pages 
ieee computer society computer society press june 
hen henglein 
type inference semi unification 
proc 
acm conf 
lisp functional programming lfp snowbird utah pages 
acm press july 
hen henglein 
polymorphic type inference semi unification 
phd thesis rutgers university april 
available nyu technical report may new york university courant institute mathematical sciences department computer science mercer st new york usa 
hen henglein 
fast left linear semi unification 
proc 
int 
conf 
computing information pages 
springer may 
lecture notes computer science vol 

herbrand 
recherches sur la theorie de la demonstration 
logiques de jacques herbrand 
puf paris 
th ese de doctorat etat universit de paris 
hin hindley 
principal type scheme object combinatory logic 
trans 
amer 
math 
soc dec 
hm henglein mairson 
complexity type inference higher order typed lambda calculi 
proc 
th acm symp 
principles programming languages popl orlando florida pages 
acm press jan 
hoo hooper 
undecidability turing machine problem 
phd thesis harvard university june 
computation laboratory report bl journal symbolic logic 
hs hindley seldin 
combinators calculus volume london mathematical society student texts 
cambridge university press 
hue huet 
esolution equations dans des langages ordre 
omega th ese de doctorat etat 
phd thesis univ paris vii sept 
hue huet 
confluent reductions properties applications term rewriting systems 
assoc 
comput 
mach oct 
hw hudak 
editors wadler 
report programming language haskell april 
jw johnson walz 
maximum flow approach anomaly isolation unification incremental type inference 
proc 
th annual acm symp 
principles programming languages pages 
acm jan 
km kanellakis mitchell 
polymorphic unification ml typing extended proc 
th annual acm symp 
principles programming languages 
acm january 
kmm kanellakis mairson mitchell 
unification ml type reconstruction 

lassez plotkin editors computational logic essays honor alan robinson 
mit press 
kapur musser narendran stillman 
semi unification 
theoretical computer science april 
conf 
foundations software technology computer science fst tcs dec springer lecture notes computer science vol 

kt kfoury tiuryn 
type reconstruction finite rank fragments polymorphic calculus 
proc 
th annual ieee symp 
logic computer science lics philadelphia pennsylvania pages 
ieee computer society press june 
ktu kfoury tiuryn urzyczyn 
proper extension ml effective type assignment 
proc 
th annual acm symp 
principles programming languages pages 
acm acm press jan 
ktu kfoury tiuryn urzyczyn 
computational consequences partial solutions generalized unification problem 
proc 
th ieee symposium logic computer science lics june 
ktu kfoury tiuryn urzyczyn 
ml typability dexptime complete 
proc 
th coll 
trees algebra programming caap copenhagen denmark pages 
springer may 
lecture notes computer science vol 

ktu kfoury tiuryn urzyczyn 
undecidability semi unification problem 
proc 
nd annual acm symp 
theory computation stoc baltimore maryland pages may 
lei leivant 
polymorphic type inference 
proc 
th acm symp 
principles programming languages pages 
acm jan 
lei lei 
type inference object oriented programming languages 
proc 
st workshop computer science logic 
springer verlag lecture notes computer science vol oct 
lei lei 
decidability semi unification variables 
technical report inf ase siemens munich germany july 
lei lei 
semi unification type inference polymorphic recursion 
technical report inf ase siemens munich germany 
lh lei henglein 
decidable case semi unification problem 
proc 
th int symp 
mathematical foundations computer science mfcs poland 
springer sept 
lecture notes computer science vol 

lmm lassez maher marriott 
unification revisited 
minker editor foundations deductive databases logic programming 
morgan kauffman 
mai mairson 
deciding ml typability complete deterministic exponential time 
proc 
th acm symp 
principles programming languages popl 
acm jan 
meertens 
incremental polymorphic type checking proc 
th acm symp 
principles programming languages popl pages 
mh mitchell harper 
essence ml 
proc 
th acm symp 
principles programming languages popl 
acm jan 
mil milner 
theory type polymorphism programming 
computer system sciences 
mit mitchell 
polymorphic type inference containment 
information control 
mit mitchell 
type systems programming languages 
van leeuwen editor handbook theoretical computer science 
north holland 
mm martelli montanari 
efficient unification algorithm 
acm transactions programming languages systems apr 
mo mycroft keefe 
polymorphic type system prolog 
artificial intelligence 
mor morris 
lambda calculus models programming languages 
phd thesis mit 
mth milner tofte harper 
definition standard ml 
mit press 
myc mycroft 
polymorphic type schemes recursive definitions 
proc 
th int 
conf 
programming lncs 
ak 
unification problem related kreisel conjecture 
mathematicae 
pur purdom 
detecting looping simplifications 
proc 
nd conf 
rewrite rule theory applications rta pages 
springer verlag may 
pw paterson wegman 
linear unification 
computer system sciences 
rey reynolds 
theory type structure 
proc 
programming symposium volume lncs pages 
springer verlag 
schwartz schonberg 
programming sets setl 
springer verlag 
ss sterling shapiro 
art prolog 
mit press 
tur turner 
overview miranda 
sigplan notices dec 
wan wand 
finding source type errors 
proc 
ieee symp 
logic computer science pages 
ieee june 

