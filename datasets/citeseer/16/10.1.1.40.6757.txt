fast algorithms mining association rules rakesh agrawal ramakrishnan srikant ibm almaden research center harry road san jose ca consider problem discovering association rules items large database sales transactions 
new algorithms solving problem fundamentally different known algorithms 
empirical evaluation shows algorithms outperform known algorithms factors ranging small problems order magnitude large problems 
show best features proposed algorithms combined hybrid algorithm called apriorihybrid 
scale experiments show apriorihybrid scales linearly number transactions 
apriorihybrid excellent scale properties respect transaction size number items database 
progress bar code technology possible retail organizations collect store massive amounts sales data referred basket data 
record data typically consists transaction date items bought transaction 
successful organizations view databases important pieces marketing infrastructure 
interested information driven marketing processes managed database technology enable marketers develop implement customized marketing programs strategies 
problem mining association rules basket data introduced 
example rule customers purchase visiting department computer science university wisconsin madison 
permission copy fee part material granted provided copies distributed direct commercial advantage vldb copyright notice title publication date appear notice copying permission large data base endowment 
copy republish requires fee special permission endowment 
proceedings th vldb conference santiago chile tires auto accessories get automotive services done 
finding rules valuable attached mailing applications 
applications include catalog design add sales store layout customer segmentation buying patterns 
databases involved applications large 
imperative fast algorithms task 
formal statement problem fi 
set literals called items 
set transactions transaction set items associated transaction unique identifier called tid 
say transaction contains set items association rule implication form ae ae 
rule holds transaction set confidence transactions contain contain rule support transaction set transactions contain rules somewhat general allow consequent item 
set transactions problem mining association rules generate association rules support confidence greater user specified minimum support called minsup minimum confidence called minconf respectively 
discussion neutral respect representation example data file relational table result relational expression 
algorithm finding association rules henceforth referred ais algorithm 
algorithm task called setm algorithm proposed 
new algorithms apriori aprioritid differ fundamentally algorithms 
experimental results showing proposed algorithms outperform earlier algorithms 
performance gap shown increase problem size ranges factor small problems order magnitude large problems 
discuss best features apriori aprioritid combined hybrid algorithm called apriorihybrid 
experiments show apriorihybrid excellent scale properties opening feasibility mining association rules large databases 
problem finding association rules falls purview database mining called knowledge discovery databases 
related directly applicable includes induction classification rules discovery causal rules learning logical definitions fitting functions data clustering :10.1.1.35.951
closest machine learning literature kid algorithm 
finding association rules algorithm passes data number combinations items antecedent exponentially large 
related database literature inferring functional dependencies data 
functional dependencies rules requiring strict satisfaction 
consequently having determined dependency algorithms consider dependency form redundant generate 
association rules consider probabilistic nature 
presence rule necessarily mean holds may 
similarly presence rules necessarily mean holds may minimum confidence 
quantifying usefulness interestingness rule 
useful interesting application dependent 
need human loop providing tools allow human guidance rule discovery process articulated example 
discuss issues point necessary features rule discovery system may algorithms engine discovery process 
problem decomposition organization problem discovering association rules decomposed subproblems 
find sets items itemsets transaction support minimum support 
support itemset number transactions contain itemset 
itemsets minimum support called large itemsets small itemsets 
section give new algorithms apriori aprioritid solving problem 

large itemsets generate desired rules 
straightforward algorithm task 
large itemset find non empty subsets subset output rule form gamma ratio support support minconf 
need consider subsets generate rules multiple consequents 
due lack space discuss subproblem refer reader fast algorithm 
section show relative performance proposed apriori aprioritid algorithms ais setm algorithms 
self contained include overview ais setm algorithms section 
describe apriori aprioritid algorithms combined hybrid algorithm apriorihybrid demonstrate scaleup properties algorithm 
conclude pointing related open problems section 
discovering large itemsets algorithms discovering large itemsets multiple passes data 
pass count support individual items determine large 
subsequent pass start seed set itemsets large previous pass 
seed set generating new potentially large itemsets called candidate itemsets count actual support candidate itemsets pass data 
pass determine candidate itemsets large seed pass 
process continues new large itemsets 
apriori aprioritid algorithms propose differ fundamentally ais setm algorithms terms candidate itemsets counted pass way candidates generated 
ais setm algorithms candidate itemsets generated fly pass data read 
specifically reading transaction determined itemsets large previous pass transaction 
new candidate itemsets generated extending large itemsets items transaction 
see disadvantage results unnecessarily generating counting candidate itemsets turn small 
apriori aprioritid algorithms generate candidate itemsets counted pass itemsets large previous pass considering transactions database 
basic intuition subset large itemset large 
candidate itemsets having items generated joining large itemsets having gamma items deleting contain subset large 
procedure results generation smaller number candidate itemsets 
aprioritid algorithm additional property database counting support candidate itemsets pass 
encoding candidate itemsets previous pass employed purpose 
passes size encoding smaller database saving reading effort 
explain points detail describe algorithms 
notation assume items transaction kept sorted lexicographic order 
straightforward adapt algorithms case database kept normalized database record tid item 
pair tid identifier corresponding transaction 
call number items itemset size call itemset size itemset 
items itemset kept lexicographic order 
notation delta delta :10.1.1.45.9405
delta represent itemset consisting items :10.1.1.45.9405

delta itemset call extension associated itemset count field store support itemset 
count field initialized zero itemset created 
summarize table notation algorithms 
set aprioritid discussed describe algorithm 
algorithm apriori gives apriori algorithm 
pass algorithm simply counts item occurrences determine large itemsets 
subsequent pass say pass consists phases 
large itemsets gamma gamma th pass generate candidate itemsets function described section 
database scanned support candidates counted 
fast counting need efficiently determine candidates contained table notation itemset itemset having items 
set large itemsets lk minimum support 
member set fields itemset ii support count 
set candidate itemsets ck potentially large itemsets 
member set fields itemset ii support count 
set candidate itemsets tids generating transactions kept associated candidates 
transaction section describes subset function purpose 
see discussion buffer management 
lk gamma ck apriori gen lk gamma new candidates forall transactions subset ck candidates contained forall candidates count lk fc ck count answer lk algorithm apriori apriori candidate generation apriori gen function takes argument gamma set large gamma itemsets 
returns superset set large itemsets 
function works follows 
join step join gamma gamma insert ck select item item gamma gamma lk gamma lk gamma item item gamma gamma gamma gamma prune step delete itemsets gamma subset gamma concurrent step candidate generation procedure proposed fx jx gamma jx gamma fx jx contains members gamma steps similar join prune steps respectively :10.1.1.40.2201
general step produce superset candidates produced join step 
forall itemsets ck forall gamma subsets lk gamma delete ck example ff gg 
join step ff prune step delete itemset itemset left contrast candidate generation ais setm algorithms 
pass algorithms database transaction read determined large itemsets gamma large itemsets extended large items occur lexicographic ordering items continuing previous example consider transaction 
fourth pass ais setm generate candidates extending large itemset 
similarly additional candidate itemsets generated extending large itemsets leading total candidates consideration fourth pass 
apriori hand generates counts itemset concludes priori combinations possibly minimum support 
correctness need show clearly subset large itemset minimum support 
extended itemset gamma possible items deleted gamma subsets gamma left superset itemsets join equivalent extending gamma item database deleting itemsets gamma itemset obtained deleting gamma th item gamma condition item gamma item gamma simply ensures duplicates generated 
join step similar reasoning prune step delete itemsets gamma subsets gamma delete itemset variation counting candidates multiple sizes pass counting candidates size kth pass count candidates generated note generated variation pay passes cost counting keeping memory additional gamma candidates cost scanning database 
subset function candidate itemsets stored hash tree 
node hash tree contains list itemsets leaf node hash table interior node 
interior node bucket hash table points node 
root hash tree defined depth 
interior node depth points nodes depth 
itemsets stored leaves 
add itemset start root go tree reach leaf 
interior node depth decide branch follow applying hash function dth item itemset 
nodes initially created leaf nodes 
number itemsets leaf node exceeds specified threshold leaf node converted interior node 
starting root node subset function finds candidates contained transaction follows 
leaf find itemsets leaf contained add answer set 
interior node reached hashing item hash item comes recursively apply procedure node corresponding bucket 
root node hash item see subset function returns desired set consider happens root node 
itemset contained transaction item root hashing item ensure ignore itemsets start item similar arguments apply lower depths 
additional factor items itemset ordered reach current node hashing item need consider items occur algorithm aprioritid aprioritid algorithm shown uses apriori gen function section determine candidate itemsets pass begins 
interesting feature algorithm database counting support pass 
set purpose 
member set form id fx potentially large itemset transaction identifier tid 
corresponds database conceptually item replaced itemset fig 
generated algorithm step 
member corresponding transaction id fc jc contained tg 
transaction contain candidate itemset entry transaction 
number entries may smaller number transactions database especially large values addition large values entry may smaller corresponding transaction candidates may contained transaction 
small values entry may larger corresponding transaction entry includes candidate itemsets contained transaction 
section give data structures implement algorithm 
see proof correctness discussion buffer management 
database lk gamma ck apriori gen lk gamma new candidates forall entries gamma determine candidate itemsets ck contained transaction identifier tid fc ck gamma set itemsets gamma gamma set forall candidates count tid lk fc ck count answer lk algorithm aprioritid example consider database assume minimum support transactions 
calling apriori gen step gives candidate itemsets steps count support candidates iterating entries generate entry corresponding transaction 
step corresponding entry member members set itemsets 
calling apriori gen gives making pass data generates note entry transactions tids contain itemsets candidate turns large member generate turns empty terminate 
database tid items tid set itemsets itemset support itemset support tid set itemsets itemset support itemset support tid set itemsets itemset support example data structures assign candidate itemset unique number called id set candidate itemsets kept array indexed ids itemsets member form tid 
stored sequential structure 
apriori gen function generates candidate itemset joining large gamma itemsets 
maintain additional fields candidate itemset generators ii extensions 
generators field candidate itemset stores ids large gamma itemsets join generated extensions field itemset stores ids candidates extensions candidate generated joining gamma gamma save ids gamma gamma generators field time id added extensions field gamma describe step implemented data structures 
recall set itemsets field entry gamma gives ids gamma candidates contained transaction tid 
candidate gamma extensions field gives set ids candidate itemsets extensions gamma generators field gives ids itemsets generated itemsets entry set itemsets conclude transaction tid add performance assess relative performance algorithms discovering large sets performed experiments ibm rs workstation cpu clock rate mhz mb main memory running aix 
data resided aix file system stored gb scsi drive measured sequential throughput mb second 
give overview ais setm algorithms compare performance apriori aprioritid algorithms 
describe synthetic datasets performance evaluation show performance results 
describe best performance features apriori aprioritid combined apriorihybrid algorithm demonstrate scale properties 
ais algorithm candidate itemsets generated counted onthe fly database scanned 
reading transaction determined itemsets large previous pass contained transaction 
new candidate itemsets generated extending large itemsets items transaction 
large itemset extended items large occur lexicographic ordering items items candidates generated transaction added set candidate itemsets maintained pass counts corresponding entries increased created earlier transaction 
see details ais algorithm 
setm algorithm setm algorithm motivated desire sql compute large itemsets 
ais setm algorithm generates candidates onthe fly transactions read database 
generates counts candidate itemset ais algorithm generates 
standard sql join operation candidate generation setm separates candidate generation counting 
saves copy candidate itemset tid generating transaction sequential structure 
pass support count candidate itemsets determined sorting aggregating sequential structure 
setm remembers tids generating transactions candidate itemsets 
avoid needing subset operation uses information determine large itemsets contained transaction read 
obtained deleting candidates minimum support 
assuming database sorted tid order setm easily find large itemsets contained transaction pass sorting tid 
fact needs visit member tid order candidate generation performed relational merge join operation 
disadvantage approach mainly due size candidate sets candidate itemset candidate set entries number transactions candidate itemset 
ready count support candidate itemsets pass wrong order needs sorted itemsets 
counting pruning small candidate itemsets minimum support resulting set needs sort tid generating candidates pass 
generation synthetic data generated synthetic transactions evaluate performance algorithms large range data characteristics 
transactions mimic transactions environment 
model real world people tend buy sets items 
set potentially maximal large itemset 
example set sheets pillow case 
people may buy items set 
instance people buy sheets pillow case sheets 
transaction may contain large itemset 
example customer place order dress jacket ordering sheets pillow cases dress jacket form large itemset 
transaction sizes typically clustered mean transactions items 
typical sizes large itemsets clustered mean large itemsets having large number items 
create dataset synthetic data generation program takes parameters shown table 
table parameters jdj number transactions jt average size transactions jij average size maximal potentially large itemsets jlj number maximal potentially large itemsets number items determine size transaction 
size picked poisson distribution mean equal jt note item chosen probability items expected number items transaction binomial distribution parameters approximated poisson distribution mean np 
assign items transaction 
transaction assigned series potentially large itemsets 
large itemset hand fit transaction itemset put transaction anyway half cases itemset moved transaction rest cases 
large itemsets chosen set itemsets 
number itemsets set jlj 
inverse relationship jlj average support potentially large itemsets 
itemset generated picking size itemset poisson distribution mean equal jij 
items itemset chosen randomly 
model phenomenon large itemsets common items fraction items subsequent itemsets chosen previous itemset generated 
exponentially distributed random variable mean equal correlation level decide fraction itemset 
remaining items picked random 
datasets experiments correlation level set 
ran experiments correlation level set find difference nature performance results 
itemset weight associated corresponds probability itemset picked 
weight picked exponential distribution unit mean normalized sum weights itemsets 
itemset put transaction chosen tossing jlj sided weighted coin weight side probability picking associated itemset 
model phenomenon items large itemset bought assign itemset corruption level adding itemset transaction keep dropping item itemset long uniformly distributed random number itemset size add items transaction gamma time gamma items gamma time gamma items gamma time corruption level itemset fixed obtained normal distribution mean variance 
generated datasets setting jlj 
chose values jt 
chose values jij 
number transactions set see section setm run larger values 
scale experiments generated datasets transactions mb 
table summarizes dataset parameter settings 
jt jdj values size datasets megabytes roughly equal different values jij 
table parameter settings name jt jij jdj size megabytes relative performance shows execution times synthetic datasets table decreasing values 
decreases execution times algorithms increase increases total number candidate large itemsets 
setm plotted execution times dataset 
execution times setm datasets average transaction size table 
plot execution times table corresponding graphs large compared execution times algorithms 
datasets transaction sizes setm took long execute aborted runs trends clear 
clearly apriori beats setm order magnitude large datasets 
time sec minimum support setm ais aprioritid apriori time sec minimum support ais aprioritid apriori time sec minimum support ais aprioritid apriori time sec minimum support ais aprioritid apriori time sec minimum support ais aprioritid apriori time sec minimum support ais aprioritid apriori execution times table execution times seconds setm algorithm minimum support dataset setm apriori dataset setm apriori apriori beats ais problem sizes factors ranging high minimum support order magnitude low levels support 
ais considerably better setm 
small problems aprioritid apriori performance degraded twice slow large problems 
explanation relative performance explain performance trends show sizes large candidate sets different passes dataset minimum support 
note axis graph log scale 
number itemsets pass number setm aprioritid ais setm apriori aprioritid sizes large candidate sets minsup fundamental problem setm algorithm size sets 
recall size set candidate itemsets support count sets roughly times bigger corresponding sets average support count candidate itemsets 
problem size small sets written disk externally sorted twice causing setm algorithm perform poorly 
explains jump time setm table going support support datasets transaction size 
largest dataset scaleup experiments setm small fit memory encounter jump execution time 
note minimum support support count candidate itemsets increases linearly number transactions 
increase number transactions values jt jij size change size goes linearly 
datasets transactions performance gap setm algorithms larger 
problem ais generates candidates turn small causing waste effort 
apriori counts small sets second pass recall really cross product 
wastage decreases dramatically third pass onward 
note example pass candidate itemset counted apriori turns large set 
aprioritid problem setm tends large 
apriori candidate generation aprioritid generates significantly fewer candidates transaction candidate generation setm 
result aprioritid fewer entries setm 
aprioritid able single word id store candidate requiring words number items candidate 
addition setm aprioritid sort aprioritid suffer setm maintaining aprioritid nice feature replaces pass original dataset pass set aprioritid effective passes size small compared cost external sorting setm reduced somewhat follows 
writing entries disk sort itemsets internal sorting procedure write sorted runs 
sorted runs merged obtain support counts 
poor performance setm expect optimization affect algorithm choice 
setm ids maintain additional memory data structures hash table find candidate generated previously mapping ids candidates 
destroy set oriented nature algorithm 
hash table gives ids candidates count time avoid external sorts 
variant setm better setm performed worse apriori aprioritid 
size database 
find aprioritid beats apriori sets fit memory distribution large itemsets long tail 
doesn fit memory jump execution time aprioritid going datasets transaction size 
region apriori starts beating aprioritid 
algorithm apriorihybrid necessary algorithm passes data 
shows execution times apriori aprioritid different passes dataset 
earlier passes apriori better aprioritid 
aprioritid beats apriori passes 
observed similar relative behavior datasets reason follows 
apriori aprioritid candidate generation procedure count itemsets 
passes number candidate itemsets reduces see size apriori aprioritid 
apriori examines transaction database 
hand scanning database aprioritid scans obtaining support counts size smaller size database 
sets fit memory incur cost writing disk 
time sec pass apriori aprioritid pass execution times apriori aprioritid minsup observations design hybrid algorithm call apriorihybrid uses apriori initial passes switches aprioritid expects set pass fit memory 
heuristic estimate fit memory pass 
current pass counts candidates estimate size generated 
size words candidates support number transactions 
pass small fit memory fewer large candidates current pass previous pass switch aprioritid 
condition added avoid switching current pass fits memory pass may 
switching apriori aprioritid involve cost 
assume decide switch apriori aprioritid kth pass 
th pass finding candidate itemsets contained transaction add ids see description aprioritid section 
extra cost incurred pass relative just running apriori 
th pass start running aprioritid 
large itemsets candidates incur cost switching getting savings aprioritid 
shows performance apriorihybrid relative apriori aprioritid datasets 
apriorihybrid performs better apriori cases 
support apriorihybrid little worse apriori pass switch occurred pass apriorihybrid incurred cost switching realizing benefits 
general advantage apriorihybrid apriori depends size set decline passes 
remains large nearly abrupt drop gain apriorihybrid aprioritid short period time switch 
happened dataset 
hand gradual decline size aprioritid switch significant improvement obtained execution time 
scale experiment shows apriorihybrid scales number transactions increased transactions 
combinations average sizes transactions itemsets respectively 
parameters data table 
sizes datasets transactions mb mb mb respectively 
minimum support level set 
execution times normalized respect times transaction datasets time sec minimum support aprioritid apriori apriorihybrid time sec minimum support aprioritid apriori apriorihybrid time sec minimum support aprioritid apriori apriorihybrid execution times apriorihybrid graph respect transaction dataset second 
shown execution times scale quite linearly 
relative time number transactions relative time number transactions millions number transactions scale examined apriorihybrid scaled number items 
increased number items parameter settings 
parameters data table 
ran experiments minimum support obtained results shown 
execution times decreased little average support item decreased increased number items 
resulted fewer large itemsets faster execution times 
investigated scale increased average transaction size 
aim experiment see data structures scaled transaction size independent factors physical database size number large itemsets 
kept physical size time sec number items number items scale database roughly constant keeping product average transaction size number transactions constant 
number transactions ranged database average transaction size database average transaction size 
fixing minimum support percentage led large increases number large itemsets transaction size increased probability itemset transaction roughly proportional transaction size 
fixed minimum support level terms number transactions 
results shown 
numbers key refer minimum support 
shown execution times increase transaction size gradually 
main reason increase spite setting minimum support terms number transactions number large itemsets increased increasing transaction length 
secondary reason finding candidates transaction took little longer time 
new algorithms apriori aprioritid discovering significant association rules items large database transactions 
compared algorithms previously known algorithms ais setm algorithms 
experimental results showing proposed algorithms outperform ais setm 
performance gap increased problem size ranged factor small problems order magnitude large problems 
showed best features pro time sec transaction size transaction size scale posed algorithms combined hybrid algorithm called apriorihybrid algorithm choice problem 
scale experiments showed apriorihybrid scales linearly number transactions 
addition execution time decreases little number items database increases 
average transaction size increases keeping database size constant execution time increases gradually 
experiments demonstrate feasibility apriorihybrid real applications involving large databases 
algorithms implemented data repositories including aix file system db mvs db 
tested algorithms real customer data details 
plan extend dimensions ffl multiple taxonomies hierarchies items available 
example hierarchy dish kitchen appliance heavy electric appliance able find association rules hierarchies 
ffl consider quantities items bought transaction useful applications 
finding rules needs 
reported done context quest project ibm almaden research center 
quest exploring various aspects database mining problem 
problem discovering association rules problems looked include enhancement database capability classification queries similarity queries time sequences :10.1.1.45.9405
believe database mining important new application area databases combining commercial interest intriguing research questions 
acknowledgment wish mike carey insightful comments suggestions 
agrawal faloutsos swami :10.1.1.45.9405
efficient similarity search sequence databases 
proc 
fourth international conference foundations data organization algorithms chicago october 
agrawal ghosh imielinski iyer swami 
interval classifier database mining applications 
proc 
vldb conference pages vancouver british columbia canada 
agrawal imielinski swami 
database mining performance perspective 
ieee transactions knowledge data engineering december 
special issue learning discovery knowledgebased databases 
agrawal imielinski swami 
mining association rules sets items large databases 
proc 
acm sigmod conference management data washington may 
agrawal srikant 
fast algorithms mining association rules large databases 
research report rj ibm almaden research center san jose california june 
associates 
new direct marketing 
business irwin illinois 
brachman integrated support data 
aaai workshop knowledge discovery databases july 
breiman friedman olshen stone 
classification regression trees 
wadsworth belmont 
cheeseman autoclass bayesian classification system 
th int conf 
machine learning 
morgan kaufman june 
fisher 
knowledge acquisition incremental conceptual clustering 
machine learning 
han cai cercone 
knowledge discovery databases attribute oriented approach 
proc 
vldb conference pages vancouver british columbia canada 
siebes 
data mining search knowledge databases 
technical report cs cwi netherlands 
swami 
set oriented mining association rules 
research report rj ibm almaden research center san jose california october 
krishnamurthy imielinski 
practitioner problems need database research research directions knowledge discovery 
sigmod record september 
langley simon bradshaw zytkow 
scientific discovery computational explorations creative process 
mit press 
mannila 

dependency inference 
proc 
vldb conference pages brighton england 
mannila toivonen verkamo :10.1.1.40.2201
efficient algorithms discovering association rules 
kdd aaai workshop knowledge discovery databases july 
muggleton feng :10.1.1.35.951
efficient induction logic programs 
muggleton editor inductive logic programming 
academic press 
pearl 
probabilistic reasoning intelligent systems networks plausible inference 
shapiro 
discovery analysis presentation strong rules 
shapiro editor knowledge discovery databases 
aaai mit press 
shapiro editor 
knowledge discovery databases 
aaai mit press 
quinlan 
programs machine learning 
morgan kaufman 

