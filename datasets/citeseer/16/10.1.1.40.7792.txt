hewlett packard laboratories palo alto ca hpl hp com computer systems laboratory stanford university mendel cs stanford edu despite fact large scale shared memory multiprocessors commercially available years system software fully utilizes features available due complexity cost making required changes operating system 
proposed approach called disco substantially reduces development cost virtual machine monitor leverages existing operating system technology 
system called cellular disco extends disco provide advantages hardware partitioning scalable operating system approaches 
argue cellular disco achieve benefits small fraction development cost modifying operating system 
cellular disco effectively turns large scale shared memory multiprocessor virtual cluster supports fault containment heterogeneity avoiding operating system scalability bottlenecks 
time cellular disco preserves benefits shared memory multiprocessor implementing dynamic fine grained resource sharing allowing users resources processors memory 
hybrid approach requires scalable resource manager local decisions limited information providing global performance fault containment 
describe experience cellular disco prototype processor sgi origin system 
show execution time penalty approach low typically best available commercial operating system workloads manage cpu memory resources machine significantly better hardware partitioning approach 
shared memory multiprocessor systems processors commercially available past years 
unfortunately due development cost complexity required changes operating systems unable effectively utilize large machines 
poor scalability restricts size machines supported current commercial operating systems dozen processors 
memory allocation algorithms aware large difference local versus remote memory access latencies numa nonuniform memory access time systems lead suboptimal application performance 
resource management policies designed handle large number resources lead contention inefficient usage 
inability operating system survive hardware system software failure results loss applications running system requiring entire machine rebooted 
solutions proposed date hardware partitioning require developing new operating systems improved scalability fault containment characteristics 
unfortunately approaches suffer serious drawbacks 
hardware partitioning limits flexibility allocation sharing resources large system adapted dynamically changing load requirements 
partitioning effectively turns system cluster smaller machines applications requiring large number resources perform 
new operating system designs provide excellent performance require considerable investment development effort time reaching commercial maturity 
proposed alternative approach called disco uses virtual machine monitor run unmodified commodity operating systems scalable multiprocessors 
low implementation cost small run time virtualization overhead disco shows virtual machine monitor address scalability numa awareness issues 
running multiple copies shelf operating system disco approach able leverage existing operating system technology form system software scalable machines 
disco demonstrated feasibility new approach left unanswered questions 
particular disco prototype lacked major features difficult compare disco approaches 
example approaches hardware partitioning support hardware fault containment disco prototype lacked support 
addition disco prototype lacked resource management mechanisms policies required cellular disco resource management virtual clusters shared memory multiprocessors dan huang mendel rosenblum permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
sosp kiawah island sc acm th acm symposium operating systems principles sosp published operating systems review dec competitive compared customized operating system approach 
system called cellular disco extends basic disco approach supporting hardware fault containment aggressive global resource management running actual scalable hardware 
system effectively turns large scale shared memory machine virtual cluster combining scalability fault containment benefits clusters resource allocation flexibility shared memory systems 
experience cellular disco shows 
hardware fault containment added virtual machine monitor low run time overheads implementation costs 
negligible performance penalty existing virtualization overheads fault containment provided monitor small fraction development effort needed adding support operating system 

virtual cluster approach quickly efficiently correct resource allocation imbalances scalable systems 
capability allows cellular disco manage resources scalable multiprocessor significantly better hardware partitioning scheme highly tuned operating system centric approach 
virtual clusters suffer resource allocation constraints actual hardware clusters large applications allowed resources system confined single partition 

small scale simulation results disco appear match experience running workloads real scalable hardware 
built cellular disco prototype runs processor sgi origin able host multiple instances sgi irix operating system running complex workloads 
system shown cellular disco provides features mentioned keeping run time overhead virtualization workloads 
focuses experience mechanisms policies implemented cellular disco dealing interrelated challenges hardware fault containment global resource management fault containment virtual machine monitor automatically provides software fault containment failure operating system instance harm software running virtual machines large potential size scalable shared memory multiprocessors requires ability contain hardware faults 
cellular disco internally structured number semi independent cells fault containment units 
design allows impact hardware failures confined single cell behavior similar clusters failures remain limited single node 
cellular disco organized cellular structure similar hive operating system providing fault containment cellular disco required fraction development effort needed hive impact performance virtualization cost factored 
key design decision reduced cost compared hive assume code cellular disco correct 
assumption warranted fact size virtual machine monitor lines assembly small thoroughly tested 
resource management order support better resource management hardware clusters cellular disco allows virtual machines actual physical resources system 
offers increased degree flexibility allowing cellular disco dynamically adjust fraction system resources assigned virtual machine 
approach lead significantly better utilization system assuming resource requirement peaks occur simultaneously 
cellular disco multiplexes physical processors virtual machines supports memory paging addition mechanism may provided hosted operating system 
features carefully implemented avoid inefficiencies plagued virtual machine monitors past 
example cellular disco tracks operating system memory usage paging disk eliminate double paging overheads 
cellular disco manage physical resources system satisfying conflicting constraints providing fault containment scalable resource load balancing 
virtual machine vulnerable faults cell starts resources cell fault containment effective resources virtual machine allocated small number cells 
naive policy may resources due load imbalance 
resource load balancing required achieve efficient resource utilization large systems 
cellular disco implementation cpu memory load balancing designed preserve fault containment avoid contention scale hundreds nodes 
process virtualizing hardware cellular disco numa specific resource management decisions operating system 
physical memory manager virtual machine monitor implements touch allocation dynamic migration replication hot memory pages 
features coupled physical cpu scheduler aware memory locality issues 
virtualizing underlying hardware cellular disco provides additional level indirection offers easier effective alternative changing operating system 
instance added support allows large applications running multiple virtual machines interact directly shared memory registering shared memory regions directly virtual machine monitor 
support allows efficient interaction standard distributed system protocols provided transparently hosted operating system 
structured follows 
start describing cellular disco architecture section 
section describes prototype implementation basic virtualization fault containment overheads 
discuss resource management mechanisms policies cpu management section memory management section 
section discusses hardware fault recovery 
conclude comparing hardware operating system centric approaches discussing related 
cellular disco architecture compared previous virtual machine monitors cellular disco introduces number novel features support hardware fault containment scalable resource management mechanisms policies aware fault containment constraints support large applications 
completeness high level overview hardware virtualization parallels descriptions 
discuss distinguishing new features cellular disco turn 
overview hardware virtualization cellular disco virtual machine monitor execute multiple instances operating system running instance inside virtual machine see 
virtual machines export interface similar underlying hardware operating system instances need aware running top cellular disco 
newly created virtual machine user specifies amount resources visible virtual machine indicating number virtual cpus amount memory number type devices 
resources visible virtual machine called physical resources 
cellular disco allocates actual machine resources virtual machine required node node node node node node node node interconnect os os operating system application app app app 
cellular disco architecture 
multiple instances shelf operating system run inside virtual machines top virtual machine monitor instance booted resources handle 
origin node contains cpus portion system memory shown 
cellular disco virtual machine monitor vm vm virtual machine dynamic needs priority virtual machine similar way operating system schedules physical resources needs priority user applications 
able virtualize hardware virtual machine monitor needs intercept privileged operations performed virtual machine 
implemented efficiently privilege levels processor 
complexity virtual machine monitor depends underlying hardware complex architectures intel successfully virtualized 
mips processor architecture supported cellular disco privilege levels user mode privileged memory accesses mapped supervisor mode semi privileged allows mapped accesses supervisor user space kernel mode privileged allows mapped unmapped accesses location allows execution privileged instructions 
virtualization operating system runs kernel level applications execute user mode supervisor mode 
cellular disco virtual machine monitor allowed run kernel level direct access machine resources system 
operating system instance running inside virtual machine permitted supervisor user levels 
virtualized operating system kernel executes privileged instruction processor trap cellular disco instruction emulated 
supervisor mode memory accesses mapped additional level indirection available map physical resources actual machine resources 
operating system executing inside virtual machine access privilege perform operations 
attempting access device cpu trap virtual machine monitor checks validity request forwards real device performs necessary actions case devices virtual paging disk see section 
memory managed similar way 
operating system inside virtual machine allocates physical memory satisfy needs applications cellular disco allocates machine memory needed back physical memory requirements virtual machine 
pmap data structure similar mach virtual machine monitor map physical addresses actual machine addresses 
addition pmap cellular disco needs maintain structure allows translate back machine physical pages structure dynamic page migration replication fault recovery see section 
performing physical machine translation pmap software reload mips tlb lead high overheads 
cellular disco reduces overhead maintaining vcpu entry translation cache called second level software tlb tlb 
entries tlb correspond complete virtual translations servicing tlb tlb faster generating virtual exception handled operating system inside virtual machine 
support hardware fault containment size shared memory machines increases reliability key concern reasons 
expect see increase failure rate large systems technology fails year small workstation corresponds failure rate days processor system 
second failure usually bring entire system cause substantially state loss small machine 
fault tolerance necessarily offer satisfactory answer users due system cost increase fact prevent operating system crashes bringing entire machine 
support software fault containment faults occurring operating systems running inside virtual machines straightforward benefit virtual machine monitor monitor easily restrict resources visible virtual machine 
operating system running inside virtual machine crashes impact virtual machines 
address reliability concerns large machines designed cellular disco support hardware fault containment technique limit impact faults small portion system 
fault small fraction machine lost applications running part system rest system continue executing unaffected 
behavior similar exhibited traditional cluster hardware system software failures tend stay localized node occurred 
support hardware fault containment cellular disco internally structured set semi independent cells shown 
cell contains complete copy monitor text manages machine memory pages belonging nodes 
failure cell bring virtual machines resources cell virtual machines executing cellular disco node node node node node node node node vm vm virtual machine 
cellular structure cellular disco allows impact hardware fault contained boundary cell fault occurred 
cell boundaries interconnect able continue unaffected 
designed system favor smaller overhead normal execution higher cost component fails hopefully infrequent occurrence 
details fault recovery algorithm covered section 
basic assumptions designing cellular disco monitor kept small thoroughly tested probability failure extremely low 
cellular disco considered trusted system software layer 
assumption warranted fact size lines monitor complex trusted layers sharedmemory machine cache coherence protocol implementation orders magnitude simpler modern operating systems may contain lines code 
trusted layer decision lead substantially smaller overheads compared design system software layer trusted due complexity case hive operating system 
cells trust expensive distributed protocols communicate update data structures 
substantially efficient directly shared memory 
overheads evident considers case single virtual machine multiple cells need update monitor data structures corresponding virtual machine 
example structure requiring frequent updates pmap address translation table 
cellular disco cells shared memory updating virtual machine specific data structures allowed directly touch data structures cells essential survival cells 
cases monitor needs request operations executed node vcpu carefully designed communication mechanism provided cellular disco offers low latency exactly semantics 
basic communication primitive fast inter processor rpc remote procedure call 
prototype origin implementation measured round trip time rpc carrying cache line sized argument reply bytes simulation results indicate time reduced appropriate support provided node controller case flash multiprocessor 
second communication primitive called message provided executing action machine cpu currently owns virtual cpu 
obviates need locking vcpu operations serialized owner 
cost sending message average rpc 
messages fault tolerant distributed registry locating current owner vcpu id vcpu 
registry completely rebuilt failure change owners migrate system having depend fixed home 
implementation guarantees exactly message semantics presence contention vcpu migration hardware faults 
resource management constraints compared traditional resource management issues additional requirement increases complexity cellular disco fault containment 
mechanisms policies system carefully balance conflicting requirements efficiently scheduling resources maintaining fault containment 
efficient resource usage requires available resource system needed fault containment provided set resources virtual machine confined small number cells 
additionally algorithms designed scale system sizes nodes 
requirements numerous implications cpu memory management 
cpu management operating systems shared memory machines normally global run queue perform load sharing idle cpu looking examines run queue attempt find runnable task 
approach inappropriate cellular disco violates fault containment requirements source contention large systems 
cellular disco machine processor maintains run queue 
proper initial load placement separate run queues lead imbalance processors due variability processor usage lifetime 
load balancing scheme avoid situation portion machine heavily loaded portion idle 
basic load balancing mechanism implemented cellular disco vcpu migration system supports intra node intra cell inter cell migration 
vcpu migration balancing policy module decides vcpu migrate current load system fault containment restrictions 
additional feature provided cellular disco scheduler non idle belonging virtual machine gang scheduled 
operating systems running inside virtual machines internal synchronization gang scheduling necessary avoid wasting precious cycles spinning lock held vcpu 
memory management fault containment requires cellular disco cell manage memory allocation 
lead case cell running memory intensive virtual machine may run memory cells free memory reserves 
static partitioning scheme choice start paging data disk 
avoid inefficient sharedmemory system cellular disco implements memory borrowing mechanism cell may temporarily obtain memory cells 
memory borrowing may limited fault containment requirements support paging fall back mechanism 
important aspect memory balancing policies carefully weigh performance gains obtained allocating borrowed memory versus implications fault containment memory remote cell virtual machine vulnerable failures cell 
support large applications order avoid operating system scalability bottlenecks operating system instance resources handle 
applications need fewer resources allocated virtual machine run normally traditional system 
large applications forced run multiple virtual machines 
solution proposed disco split large applications instances different virtual machines communicate distributed systems protocols run fast shared memory virtual ethernet provided virtual machine monitor 
approach similar way applications run cluster hardware partitioning environment 
unfortunately approach requires shared memory applications rewritten incurs significant overhead introduced communication protocols tcp ip 
cellular disco virtual cluster environment provides efficient sharing mechanism allows large applications bypass operating system register shared memory regions directly virtual machine monitor 
system call intercepted monitor reflected back operating system easy add monitor additional system call functionality mapping global shared memory regions 
applications running different virtual machines communicate shared memory regions extra overhead simply cache coherence mechanisms built hardware 
drawback mechanism requires relinking application different shared memory library possibly small modifications operating system handling misbehaving applications 
operating system instances aware application level memory sharing virtual machine monitor needs provide appropriate paging mechanisms policies cope memory overload conditions 
paging disk cellular disco needs preserve sharing information pages belonging shared memory region 
addition actual page contents cellular disco pager writes list virtual machines page sharing properly restored page faulted back 
cellular disco prototype section start discussing cellular disco prototype implementation runs actual scalable hardware 
describing experimental setup provide evaluations virtualization fault containment overheads 
prototype implementation cellular disco virtual machine monitor designed support shared memory systems mips processor architecture 
prototype implementation consists lines assembly runs processor sgi origin 
main hurdles overcome prototype handling devices 
coping details origin hardware available resources decided leverage device driver functionality sgi irix operating system prototype 
cellular disco implementation runs piggybacked top irix 
run cellular disco prototype boot irix operating system minimal amount memory 
cellular disco implemented multi threaded kernel process spawns thread cpu 
threads pinned designated processors prevent irix scheduler interfering control virtual machine monitor machine cpus 
subsequent actions performed monitor violate irix process abstraction effectively control machine operating system 
saving kernel registers host operating system monitor installs exception handlers takes remaining system memory 
host irix operating system remains dormant reactivated time cellular disco needs device driver 
virtual machines created top cellular disco requests operation request handled procedure illustrated 
request causes trap cellular disco checks access permissions simply forwards request host irix restoring saved kernel registers exception vectors requesting host kernel issue appropriate request 
perspective host operating system looks cellular disco running time just behaved kernel process 
irix initiates request control returns cellular disco puts host kernel back dormant state 
completion hardware raises interrupt handled cellular disco 
requests virtual machine handled host irix device drivers 
step process fully described text 
virtual machine cellular disco host irix hardware forward actual req completion int device drivers req exception vectors overwritten 
allow host drivers properly handle completion monitor dormant irix making look interrupt just posted 
cellular disco posts virtual interrupt virtual machine notify completion request 
drivers require kernel aware time cellular disco forwards timer interrupts addition device interrupts host irix 
piggybacking technique allowed bring system real hardware quickly enabled cellular disco handle hardware device irix supports 
measuring time spent host irix kernel overhead piggybacking approach small total running time benchmarks ran 
main drawback current piggybacking scheme support hardware fault containment monolithic design host operating system 
fault containment experiments described section piggybacking scheme solution running copy host operating system cellular disco cell possible appropriate support host operating system 
experimental setup evaluated cellular disco executing workloads processor sgi origin system configured shown table 
running times benchmarks range minutes noise 
machine ran workloads database pmake raytrace web server 
workloads described detail table chosen stress different parts system representative set applications commercial users run large machines 
virtualization overheads performance penalty paid virtualization largely depends processor architecture virtualized system 
dominant portion overhead cost handling traps generated processor privileged instruction executed kernel 
measure impact virtualization compared performance workloads executing different setups 
ran workloads irix executing component characteristics processors mips mhz node controllers sgi hub mhz memory gb cache size mb disks total capacity gb table 
sgi origin configuration running experiments 
directly top bare hardware 
ran workloads irix executing top cellular disco virtual machine monitor 
different versions irix demonstrate cellular disco leverage offthe shelf operating system limited scalability provide essentially functionality performance operating system specifically designed large scale machines 
irix designed small scale challenge bus multiprocessors irix latest operating system available origin started experimental 
reason different versions irix irix run origin 
scalability fixes irix versions fairly similar uniprocessor numbers section provide estimate virtualization cost 
multiprocessor numbers may distorted scalability limitations irix 
cellular disco virtualization overheads shown 
shown worst case uniprocessor virtualization penalty 
workload bar left shows time normalized needed complete run irix bar right shows relative time complete run irix running top monitor 
execution time broken workload description database decision support workload tpc query suite informix relational database version mb gb database 
measure sum run times non update queries 
pmake intensive parallel compilation sgi irix operating system lines assembly code 
raytrace cpu intensive ray tracer splash parallel benchmark suite 
balls data set varying amounts anti aliasing runs minutes single multi process configurations 
web kernel intensive web server workload 
specweb running apache web server 
workload runs minutes scaled execution times run performs number requests 
table 
workloads 
execution times reported average stable runs initial warm run 
running times range minutes noise 
irix cd database irix cd pmake irix cd raytrace irix cd web normalized execution time idle cellular disco irix kernel user irix cd database irix cd pmake irix cd raytrace irix cd web normalized execution time idle cellular disco irix kernel user 
virtualization overheads 
workload left bar shows execution time separated various modes benchmark running irix top bare hardware 
right bar shows benchmark running irix top cellular disco 
time spent irix device drivers included cellular disco portion right bar 
multiprocessor runs idle time cellular disco increases due virtualization overheads serial parts workload 
reduction user time workloads due better memory placement 
note workloads overheads 
irix cd database irix cd pmake irix cd raytrace irix cd web loaded 
irix cd web unloaded normalized execution time idle cellular disco irix kernel user uniprocessor processors processors time spent idle mode virtual machine monitor portion includes time spent host kernel device drivers operating system kernel user mode 
breakdown measured hardware counters mips processors 
shows virtualization overheads processor systems executing single virtual machine spans processors 
included cases loaded unloaded web workload systems perform differently depending load 
unloaded case limits number server client processes half number processors loaded case starts clients limit number server processes exact value determined web server 
irix uses blocking locks networking code results better performance heavy load irix uses spin locks increases kernel time performs better light load 
database pmake web benchmarks large amount idle time due inability fully exploit available parallelism significant fraction workloads serialized single processor 
note multiprocessor virtual machine virtualization overheads occurring serial part workload magnified increase idle time unused 
circumstances cellular disco introduces overhead worst case 
fault containment overheads order gauge overheads introduced cellular structure cellular disco ran benchmarks top virtual machine monitor configurations 
monitor run single cell spanning processors machine corresponding setup provide fault containment 
second booted cellular disco cell configuration processors cell 
ran workloads inside processor virtual machine completely contained single cell case spanned cells second 
shows running time virtual machines spanning cell boundaries practically executing single cell small differences due scheduling artifacts 
result shows cellular disco hardware fault containment provided practically loss performance virtualization overheads factored 
result stands sharp contrast earlier fault containment 
cpu management section describe processor load balancing mechanisms provided cellular disco 
discuss policies balance system 
discuss implementation gang scheduling 
conclude evaluation performance system comments interesting issues regarding inter cell migration 
cpu balancing mechanisms cellular disco supports different types vcpu database pmake raytrace web normalized execution time idle cellular disco irix kernel user 
overhead fault containment 
left bar normalized shows execution breakdown single cell configuration 
right bar shows execution profile cell system 
cases ran single processor virtual machine spanning entire system 
migration providing different tradeoff performance cost 
simplest vcpu migration case occurs vcpu moved different processor node origin cpus node 
time required update internal monitor data structures real cost paid gradually time due loss cpu cache affinity 
get rough estimate cost assume half byte lines mb second level cache half active lines local half remote 
amount cached information destination cpu requires ms second type migration occurs vcpu moved processor different node cell 
compared cost intra node migration case incurs added cost copying second level software tlb described section kept node vcpu accessed frequently 
cost copying entire tlb kb smaller gradual cost cpu cache 
inter node migration higher longterm cost migrated vcpu access machine memory pages allocated previous node 
cost cache affinity loss paid accessing remote memory continuous penalty incurred time processor misses remote cache line 
cellular disco alleviates penalty dynamically migrating replicating frequently accessed pages node generating cache misses 
third type vcpu migration occurs vcpu moved cell boundary migration costs including time copy tlb 
losing cache node affinity type migration may increase fault vulnerability vcpu 
run destination cell resources migrating new cell vulnerable faults cell 
cellular disco provides mechanism dependencies old cell entirely removed moving data virtual machine new cell process covered detail section 
cpu balancing policies cellular disco employs separate cpu load balancing policies idle balancer periodic balancer 
idle balancer runs processor idle performs balancing 
periodic balancer redistributes handled idle balancer 
processor idle idle balancer runs processor search stolen run queues neighboring processors cell starting closest neighbor 
idle balancer arbitrarily select vcpu remote queues due gang scheduling constraints 
cellular disco schedule vcpu non idle virtual machine runnable 
annotations idle loop kernel inform cellular disco vcpu idle 
idle balancer checks remote queues moved allow virtual machine run 
example consider case shown 
top row currently executing actual machine cpus cpu idle due gang scheduling constraints 
checking remote queues idle balancer running cpu migrate vcpu migration allow run cpus respectively 
migrating vcpu allow start executing right away may cache node affinity cpu cancel gains 
cellular disco tries match benefits cost migration delaying migration vcpu time depending migration distance ms intra node ms inter node 
optimal values testing range ms ms performance varies range 
idle balancer performs fairly loaded system usually idle cycles available balancing decisions due fragmentation caused gang scheduling 
local load information reduce contention idle balancer able take globally optimal decisions 
reason included system periodic balancer uses global load information balance load heavily loaded systems different cells 
querying processor individually impractical systems hundreds processors 
processor periodically updates load tree low contention distributed data structure tracks load entire system 
load tree shown binary tree encompassing entire machine 
leaf tree represents processor stores load processor 
inner node tree contains sum loads children 
periodic balancer idle balancer 
cpu balancing scenario 
numbers inside nodes tree represent cpu load corresponding portion machine 
letter vcpu name specifies virtual machine number designates virtual processor 
top row currently scheduled processors 
vc vc vc vc cpu cpu cpu cpu load tree reduce memory contention tree nodes physically spread machine 
starting corresponding leaf processor updates tree ms timer interrupt 
cellular disco reduces contention higher level nodes reducing number processors update level half level greater 
periodic balancer traverses tree depth checking load disparity children 
disparity larger vcpu balancer try find vcpu loaded side candidate migration 
gang scheduling requires vm scheduled processor requirements candidate loaded side processor vcpu virtual machine 
sides belong different cells migrating vcpu vulnerable faults new cell 
prevent vulnerable faults cells cellular disco keeps track list cells vcpu vulnerable periodic balancer prefers migrating vulnerable faults loaded cell 
executing periodic balancer entire system expensive large machines left tunable parameter currently set ms heavily loaded systems local load imbalances handled idle balancer due lack idle cycles 
cellular disco addresses problem adding local periodic load balancer runs cpu region ms combination schemes results efficient adaptive system 
scheduling policy balancing schemes described previous section ineffective scalable gang scheduler 
gang schedulers space time partitioning schemes require centralized manager scalability bottleneck 
cellular disco scheduler uses distributed algorithm similar irix gang scheduler 
selecting vcpu run processor scheduler picks highest priority gang runnable vcpu waiting longest 
vcpu gang runnable non idle virtual machine running waiting run queues processors executing lower priority virtual machines 
selecting vcpu scheduler sends rpcs processors belonging virtual machine waiting run queue 
receiving rpc processors vcpu running follow scheduling algorithm converge desired virtual machine 
processor decisions ends converging correct choice employing central global manager 
cpu management results tested effectiveness complete cpu management system running part experiment 
ran single virtual machine executing process raytrace leaving processors idle 
ran virtual machines running process raytrace 
ran virtual machines configured way total running raytrace processes 
ideal system run configurations time third case take twice long 
measured increase second case final configuration took times long 
extra time attributed migration overheads cache affinity loss due scheduling load imbalance 
get baseline number third case ran experiment irix irix exhibits higher overhead 
inter cell migration issues migrating cell boundaries raises number interesting issues 
migrate data structure associated entire virtual machine just single vcpu 
size data structure dominated pmap proportional amount physical memory virtual machine allowed 
tlb reduces number accesses pmap desirable place pmap close software reloaded tlb misses satisfied quickly 
migrated cell keeping pmap old cell leaves virtual machine vulnerable faults old cell 
migrate virtual machine wide data structures migrated new cell pmap big want move frequently 
migrate migrated different cell 
carefully designed mechanism avoid blocking run concurrently migration 
operation takes ms copy related data structures pmap copying pmap takes mb physical memory virtual machine allowed 
cellular disco migrates virtual machine data structures moved away cell sufficient remove vulnerability faults occurring old cell 
completely independent old cell data pages virtual machine migrated 
operation takes ms mb memory virtual machine executed blocking 
memory management section focus problem managing machine memory cells 
mechanisms address problem policies uses mechanisms evaluation performance complete system 
section concludes looking issues related paging 
memory balancing mechanism describing cellular disco memory balancing mechanism important discuss memory allocation module 
cell maintains freelist list free pages indexed home node memory page 
initially freelist entries nodes belonging cell empty cell borrowed memory 
page allocation request tagged list nodes supply memory list initialized virtual machine created 
satisfying request higher preference memory local node order reduce memory access latency numa systems touch allocation strategy 
memory balancing mechanism fairly straightforward 
cell wishing borrow memory issues fast rpc cell available memory 
cell allocates memory freelist returns list machine pages result rpc 
borrower adds pages freelist indexed home node 
operation takes borrow mb memory 
memory balancing policies cell starts borrowing memory number free pages reaches low threshold completely running pages 
policy seeks avoid forcing small virtual machines fit single cell remote memory 
example consider case cell virtual machines large memory footprint entirely fits cell 
large virtual machine remote memory avoid paging smaller achieve performance just local memory vulnerable faults cells 
cell carefully decide allocate remote memory local memory available satisfy requirements smaller virtual machine 
depending fault containment requirements users restrict set cells virtual machine borrowed memory 
paging recourse free memory available cells list 
avoid paging possible cell borrow memory cells listed allocation preferences virtual machines executing 
cell keeps track combined allocation preferences virtual machines executing adjusts list virtual machine migrates cell 
policy effective local free memory cell drops mb cell tries maintain mb free memory cell allocation preferences list cell borrows mb cell list mb available 
heuristic biases borrowing policy solicit memory cells actively supply pages virtual machine 
cells agree loan memory long mb available 
thresholds tunable parameters 
default values selected provide hysteresis stability number pages allocated interval consecutive executions policy ms duration cpu allocate kb means typical cell cpus allocate mb ms cpus allocate memory fast possible scenario decided borrow mb time 
cells start borrowing mb left expect resident size small virtual machines mb range 
measured effectiveness policy running processor database workload 
ran benchmark monitor configured single cell case need balancing 
ran cell configuration cpus cell 
second configuration cell executing database virtual machine memory satisfy workload ended borrowing mb memory cells 
borrowing amount memory negligible impact execution time increase 
issues related paging cells running low memory choice page data disk 
addition providing basic paging functionality algorithms solve additional challenges identifying actively pages handling memory pages shared different virtual machines avoiding redundant paging 
cellular disco implements second chance fifo queue approximate lru page replacement similar vms 
virtual machine assigned resident set size dynamically trimmed system running low memory 
lru approximation algorithm find frequently pages separate infrequently pages pages contain active data unallocated pages contain garbage 
cellular disco avoids having write unallocated pages disk monitoring physical pages operating system 
annotations operating system memory allocation deallocation routines provide required information virtual machine monitor 
machine page shared multiple virtual machines page shared memory region described section result cow copy optimization 
sharing information usually kept memory control data structures actual machine page 
information remain page written machine page reused 
order preserve sharing cellular disco writes sharing information disk data 
sharing information stored contiguous sector paged data written disk request avoids penalty additional disk seek 
redundant paging problem plagued early virtual machine implementations 
problem occur separate paging schemes system cellular disco operating systems running virtual machines 
schemes making independent decisions pages may written disk twice read just paged back 
cellular disco avoids inefficiency trapping read write kernel paging disk identified designating virtual machine special disk acts virtual paging disk 
illustrates problem way cellular disco avoids 
cases shown virtual machine kernel wishes write page paging disk cellular disco paged paging disk 
paging disk shown case kernel request appears monitor regular disk write page paged cellular disco paging disk 
cellular disco fault page paging disk issue write kernel paging disk 
case shows optimized version virtual paging disk 
operating system issues write disk monitor notices paged data simply updates internal data structure sectors virtual paging disk point real sectors cellular disco paging disk 
subsequent operating system read paging disk satisfied looking actual sectors indirection table reading cellular disco paging disk 
measured impact paging optimization running micro benchmark called 
allocating large chunk memory writes unique integer page loops pages verifying value reads wrote originally 
ran seconds executing virtual paging disk optimization took seconds optimization improvement 
hardware fault recovery due tight coupling provided shared memory hardware effects single hardware fault multiprocessor quickly ripple entire system 
current commercial shared memory multiprocessors extremely crash occurrence hardware fault 
resume operation remaining resources fault machines require hardware reset reboot operating system 

redundant paging 
disk activity shown bold 
case illustrates problem results disk accesses case shows way cellular disco avoids requiring just disk access 
case virtual paging disk cellular disco disk write os update mapping total disk accesses case virtual paging disk cellular disco disk write os page fault disk write shown possible design multiprocessors limit impact faults small portion machine called hardware fault containment unit 
cellular disco requires underlying hardware able recover recovery mechanism 
detecting hardware fault fault recovery support described diagnoses system determine resources operational reconfigures machine order allow resumption normal operation remaining resources 
important step reconfiguration process determine cache lines lost result failure 
failure cache lines coherent lines affected fault incoherent lines lost fault 
shared memory system unable supply valid data incoherent cache lines cache lines terminated raising exception 
completing hardware recovery hardware informs cellular disco recovery taken place posting interrupt nodes 
interrupt cause cellular disco execute recovery sequence determine set functioning cells decide virtual machines continue execution fault 
recovery process similar done hive design simpler reasons deal operating system data structures shared memory operations cells trust 
simpler design results faster recovery time 
step cellular disco recovery sequence cells agree set functioning nodes forms basis subsequent recovery actions 
cell independently obtain current reading hardware registers possibility multiple hardware recovery rounds resulting back back hardware faults requires standard round agreement protocol guarantee cells operate common 
agreed information second recovery step communication system needs functional subsequent recovery actions 
step pending rpc messages failed cells aborted subsequent attempts communicate failed cell immediately return error 
final recovery step determines virtual machines essential dependencies failed cells terminates virtual machines 
memory dependencies determined scanning machine memory pages checking incoherent cache lines hardware provides mechanism perform check 
data structure bad machine memory pages translated back physical memory pages map virtual machines owning physical pages 
tunable recovery policy parameter determines virtual machine uses bad memory page immediately terminated allowed continue running tries access incoherent cache line 
device dependencies treated similarly memory dependencies 
experimental setup rest testing cellular disco fault recovery support necessary hardware fault containment support required cellular disco implemented origin multiprocessor piggybacking solution section host operating system represents single point failure 
fortunately cellular disco originally designed run flash multiprocessor hardware fault containment support described designed 
running flash cellular disco fully exploit machine hardware fault containment capabilities 
main difference flash origin flash programmable node controller called magic 
hardware fault containment support flash implemented magic firmware 
tested hardware fault recovery support cellular disco simulation setup allowed perform large number fault injection experiments 
flash hardware current flash prototype nodes injecting multiple controlled faults extremely difficult time consuming real hardware 
simos simulators provide detail accurately observe behavior hardware fault containment support system software injecting number common hardware faults simulated flash system 
shows setup fault injection experiments 
simulated node flash system running cellular disco 
size cellular disco cells chosen node flash hardware fault containment units 
ran virtual machines essential dependencies different cells 
virtual machine executed parallel compile subset source files 

experimental setup experiments shown table 
virtual machine essential dependencies cellular disco cells 
fault injection experiments performed detailed simulation flash multiprocessor 
vm vm vm vm vm vm vm vm vm cellular disco interconnect configuration shown performed fault injection experiments described table 
injecting hardware fault allowed flash hardware recovery cellular disco recovery execute ran surviving virtual machines workloads completed 
checked results workloads comparing checksums generated object files ones obtained run 
experiment deemed successful exactly cellular disco cell virtual machines dependencies cell lost fault surviving virtual machines produced correct results 
table shows cellular disco hardware fault recovery support effective experiments covered router interconnect link node magic firmware failures 
order evaluate performance impact fault surviving virtual machines measured recovery times number additional experiments 
shows recovery time varies number nodes system amount memory node 
shows total recovery time small half second tested hardware configurations 
recovery time shows modest increase number nodes system steep increase amount memory node 
large memory configurations time spent places 
determine status cache lines failure hardware fault containment support scan node coherence directories 
second cellular disco uses magic firmware support determine machine memory pages contain inaccessible incoherent cache lines 
operations involve expensive directory scanning operations implemented magic firmware 
cost operations substantially reduced machine hardwired node controller 
comparison approaches previous sections shown cellular disco combines features hardware partitioning traditional shared memory multiprocessors 
section compare performance system hardware partitioning traditional operating system centric approaches 
hardware partitioning approach divides large scale machine set small scale machines separate operating system booted similar simulated hardware fault number experiments success rate node power supply failure router power supply failure link cable connector failure magic firmware failure table 
fault injection experiments shown simulated system recovered produced correct results 
cluster small machines fast interconnect 
approach similar cellular disco inter cell resource sharing 
fact irix run sgi origin evaluated performance approach cellular disco inter cell sharing 
irix representative operating system centric approaches 
small applications fit inside single hardware partition run equally systems small virtualization overheads cellular disco 
large resource intensive applications don fit inside single partition experience significant slowdown running partitioned system due lack resource sharing 
section evaluate systems resource intensive workload demonstrate need resource sharing 
comparison workload consisting mix applications resembles way large scale machines practice combine process database workload process raytrace run 
dividing processor origin system cells processors obtain configuration memory single cell satisfy database cpus cell satisfy raytrace 
hardware partitioning approach automatically balance load explicitly placed applications different partitions 
cases started applications time measured time took finish cpu utilization 
table summarizes results experimental comparison 
expected performance virtual clusters solution close operating system centric approach applications able access resources need 
expected hardware partitioning approach suffers serious performance degradation due lack resource sharing 
hardware partitioning cluster approaches typically avoid serious problems allocating resources partition meet expected peak demand example database partition allocated memory raytrace partition processors 
normal operation time ms total hw 
fault recovery times shown function number nodes system amount memory node 
total time includes hardware cellular disco recovery 
mb time ms total hw number nodes memory node mb node nodes configuration wastes resources prevents efficient resource utilization raytrace workload perform partition configured databases similarly database workload perform partition configured raytrace 
related section compare cellular disco projects similarities virtual machines hardware partitioning operating system approaches fault containment resource load balancing 
virtual machines virtual machines new idea numerous research projects commercial product offerings attest popularity concept 
vax vmm security kernel virtual machines build compatible secure system low development cost 
cellular disco shares fundamental framework techniques virtual machine monitors quite different adapts virtual machine concept address new challenges posed modern scalable shared memory servers 
disco proposed virtual machines provide scalability hide characteristics underlying hardware numa unaware operating systems 
compared disco cellular disco provides complete solution large scale machines extending disco approach novel aspects virtual machine monitor supporting hardware fault containment development numa fault containment aware scalable resource balancing policies development mechanisms support policies 
evaluated approach real hardware long running realistic workloads closely resemble way large machines currently 
hardware centric approaches hardware partitioning proposed way solve system software issues large scale shared memory machines 
systems support partitioning sequent application region manager sun microsystems dynamic system domains cellular approach raytrace database cpu util 
operating system virtual cluster hardware partitioning table 
comparison virtual cluster approach operating system hardware centric approaches combination raytrace database applications 
measured wall clock time application cpu utilization 
multiprocessing cmp architecture 
benefits approach requires small operating system changes provides limited fault isolation partitions 
major drawback partitioning lacks resource sharing effectively turning large expensive machine cluster smaller systems happen share fast network 
shown section lack resource sharing lead serious performance degradation 
alleviate resource sharing problems static partitioning dynamic partitioning schemes proposed allow limited redistribution resources cpus memory partitions 
unfortunately repartitioning usually heavyweight operation requiring extensive hardware operating system support 
additional drawback nodes dynamically reassigned different partition resources node multiplexed fine granularity partitions 
software centric approaches attempts provide support large scale multiprocessors operating system divided strategies tuning existing smp operating system scale tens hundreds processors developing new operating systems better scalability characteristics 
advantage adapting existing operating system backwards compatibility benefit existing sizable code base illustrated sgi irix irix operating systems 
unfortunately usually requires significant software development effort 
furthermore adding support fault containment daunting task practice base operating system inherently vulnerable faults 
new operating system developments proposed address requirements scalability tornado fault containment hive 
approaches tackle problem basic level require significant development time cost reaching commercial maturity 
compared approaches cellular disco orders magnitude simpler providing performance 
fault containment considerable amount done fault tolerance technique attractive large scale shared memory machines due increase cost fact defend operating system failures 
alternative approach proposed fault containment design technique limit impact fault small fraction system 
fault containment support operating system explored hive project necessary hardware firmware support implemented flash multiprocessor 
cellular disco requires presence hardware fault containment support described complementary 
hive cel disco attempts provide fault containment support system software main advantage cellular disco extreme simplicity compared hive 
approach practical demonstration toend hardware fault containment provided realistic cost terms implementation effort 
cellular disco shows basic system software layer trusted fault containment add performance overhead 
load balancing cpu memory load balancing studied extensively context networks workstations single shared memory systems 
traditional approaches process migration require support operating system complex fragile commercial world far 
cellular disco provides simpler approach migration require support operating system offering flexibility migrating granularity individual cpus memory pages 
research projects gms investigated remote memory context clusters machines remote memory fast cache vm pages file system buffers 
cellular disco directly hardware support shared memory allowing substantially flexibility 
size exceeding lines code current commercial operating systems grown large adapt quickly new features introduced hardware 
shelf operating systems currently suffer poor scalability lack fault containment poor resource management large systems 
lack support large scale shared memory multiprocessors stems tremendous difficulty adapting system software new hardware requirements 
modifying operating system approach inserts software layer hardware operating system 
applying old idea new context show virtual machine monitor called cellular disco able supplement functionality provided operating system provide new features 
argue cellular disco viable approach providing scalability scalable resource management fault containment large scale shared memory systems small fraction development cost required changing operating system 
cellular disco effectively turns large machines virtual clusters combining benefits clusters shared memory systems 
prototype implementation cellular disco processor sgi origin system shows virtualization overhead kept practical workloads providing effective resource management fault containment 
cellular disco demonstration fault containment achieved practice reasonable implementation effort 
results virtualizing mips processor architecture running irix operating system approach extended processor architectures operating systems 
straightforward extension cellular disco support simultaneous execution scalable machine operating systems combination windows nt linux unix 
remaining problems left open far include efficient virtualization devices fast network interfaces system management issues checkpointing cloning virtual machines 
acknowledgments sgi kindly providing access processor origin machine experiments irix irix irix source code 
experiments possible invaluable help received john keen simon patience 
flash hive teams built infrastructure needed provided incredibly stimulating environment 
special go disco simos developers enabled development cellular disco fault injection experiments 
study part stanford flash project funded darpa dabt 
james barton 
scalable multiple processor scheduling framework irix 
lecture notes computer science pp 


edouard bugnion scott devine mendel rosenblum 
disco running commodity operating systems scalable multiprocessors 
acm transactions computer systems tocs pp 

november 
john chapin mendel rosenblum scott devine lahiri dan anoop gupta 
hive fault containment shared memory multiprocessors 
proceedings th symposium operating systems principles sosp pp 

december 
compaq computer 
galaxy 
www digital com availability galaxy 
html 
accessed october 

origin vm time sharing system 
ibm res 
develop pp 

michael feeley william morgan frederic anna karlin henry levy thekkath 
implementing global memory management workstation cluster 
proceedings th symposium operating systems principles sosp pp 

december 
mike galles eric williams 
performance optimizations implementation verification sgi challenge multiprocessor 
proceedings th hawaii international conference system sciences volume architecture pp 

january 
ben krieger jonathan michael stumm 
tornado maximizing locality concurrency shared memory multiprocessor operating system 
proceedings rd symposium operating systems design implementation osdi pp 

february 
robert goldberg 
survey virtual machine research 
ieee computer magazine pp 

june 
ibm 
project 
www research 
ibm com index html 
accessed october 
gerry kane joe heinrich 
mips risc architecture 
prentice hall englewood cliffs nj 

paul karger mary douglas andrew mason clifford kahn 
retrospective vax vmm security kernel 
ieee transactions software engineering pp 

november 
jeffrey david mark heinrich john richard simoni kourosh gharachorloo john chapin david joel baxter mark horowitz anoop gupta mendel rosenblum john hennessy 
stanford flash multiprocessor 
proceedings st international symposium computer architecture isca pp 

april 
jim laudon daniel lenoski 
sgi origin ccnuma highly scalable server 
proceedings th international symposium computer architecture isca 
pp 

june 
levy lipman 
virtual memory management vax vms operating system 
ieee computer pp 

march 
nancy lynch 
distributed algorithms 
morgan kaufmann publishers san francisco ca 

milojicic fred douglis yves richard wheeler zhou 
process migration 
tog research institute technical report 
december 
rashid machine independent virtual memory management paged uniprocessor multiprocessor architectures 
ieee transactions computers pp 

august 
mendel rosenblum edouard bugnion scott devine steve herrod 
simos machine simulator study complex computer systems 
acm transactions modelling computer simulations pp 

january 
vm study multiplicity usefulness 
ibm systems journal pp 


sequent computer systems sequent application region manager 
www sequent com agile wp html 
accessed october 
sgi irix 
www sgi com software irix 
accessed october 
standard performance evaluation 
specweb benchmark 
www spec org osg web 
accessed october 
mark heinrich ben verghese kourosh gharachorloo anoop gupta john hennessy 
flexible memory replication migration cache coherent dsm multiprocessors 
proceedings th international symposium computer architecture isca 
pp 

june 
sun microsystems sun enterprise server dynamic system domains 
www sun com servers tour domains html 
accessed october 
dan joel baxter john chapin mendel rosenblum mark horowitz 
hardware fault containment scalable shared memory multiprocessors 
proceedings th international symposium computer architecture isca 
pp 

june 
transaction processing performance council 
tpc benchmark decision support standard specification 
tpc san jose ca 
june 

cellular multiprocessing breakthrough architecture open mainframe 
www marketplace com ent cmp html 
accessed october 
ben verghese scott devine anoop gupta mendel rosenblum 
operating system support improving data locality cc numa compute servers 
proceedings th international conference architectural support programming languages operating systems asplos pp 

october 
vmware 
virtual platform 
www vmware com products html 
accessed october 
steven cameron woo evan pal singh anoop gupta 
splash programs characterization methodological considerations 
proceedings nd annual international symposium computer architecture isca pp 

may 
