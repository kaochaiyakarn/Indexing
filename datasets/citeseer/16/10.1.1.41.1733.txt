originally published proceedings rd symposium operating systems design implementation new orleans louisiana february resource containers new facility resource management server systems gaurav banga peter druschel rice university jeffrey mogul western research laboratory compaq computer information usenix association contact 
phone 
fax 
email office usenix org 
www url www usenix org resource containers new facility resource management server systems gaurav banga peter druschel jeffrey mogul dept computer science western research laboratory rice university compaq computer houston tx palo alto ca cs rice edu mogul pa dec com general purpose operating systems provide inadequate support resource management large scale servers 
applications lack sufficient control scheduling management machine resources difficult enforce priority policies provide robust controlled service 
fundamental mismatch original design assumptions underlying resource management mechanisms current general purpose operating systems behavior modern server applications 
particular operating system notions protection domain resource principal coincide process abstraction 
coincidence prevents process manages large numbers network connections example properly allocating system resources connections 
propose evaluate new operating system abstraction called resource container separates notion protection domain resource principal 
resource containers enable fine grained resource management server systems allow development robust servers simple firm control priority policies 
networked servers important applications large computer systems 
users perceived speed computing governed server performance 
especially interested performance web servers scale thousands millions users 
operating systems researchers system vendors devoted attention improving performance web servers 
improvements operating system performance come reducing data movement costs developing better kernel algorithms protocol control block pcb lookup file descriptor allocation improving stability overload improving server control mechanisms 
application designers attacked performance problems making efficient existing operating systems 
example early web servers process connection servers single process model reduces context switching costs 
cited fruitful generally treated operating system application programming interface api core abstractions constant 
frustrated efforts solve problems server scaling effective control resource consumption 
particular servers may vulnerable denial service attacks malicious client manages consume server resources 
service providers want exert explicit control resource consumption policies order provide differentiated quality service qos clients control resource usage guest servers rent server host :10.1.1.141.3942
existing apis allow applications directly control resource consumption host system 
root problem model resource management current general purpose operating systems 
systems scheduling resource management primitives extend execution significant parts kernel code 
application control consumption system resources kernel consumes behalf application 
explicit resource management mechanisms exist tied assumption process constitutes independent activity processes resource principals entities resources system shared 
modern high performance servers single process perform independent activities 
example web server may manage hundreds thousands simultaneous network connections process 
resource consumption associated connections occurs kernel term independent activity denote unit computation application wishes perform separate resource allocation accounting example processing associated single request 
mode making impossible application control connections priority address resource management monolithic kernels 
microkernels novel systems offer interesting alternative approaches problem monolithic kernels commercially significant especially internet server applications 
describe new model fine grained resource management monolithic kernels 
model new operating system abstraction called resource container 
resource container encompasses system resources server uses perform particular independent activity servicing particular client connection 
user kernel level processing activity charged appropriate resource container scheduled priority container 
model allows fairly arbitrary interrelationships protection domains threads resource containers support wide range resource management scenarios 
evaluate model modification digital unix show effective solving problems described 
typical models high performance servers section describes typical execution models high performance internet server applications provides background discussion sections 
concrete focus servers proxy servers issues apply servers mail file directory servers 
assume unix api discussion valid servers windows nt 
server receives requests clients tcp connections 
requests may sent serially connection 
server listens known port new connection requests 
new connection request arrives system delivers connection server application system call 
server waits client send request data connection parses request returns response connection 
web servers typically obtain response local file system proxies obtain responses servers kinds server may cache speed retrieval 
stevens describes basic operation servers detail 
architecture servers undergone radical changes 
early servers forked new process handle connection classical unix term priority loosely mean current scheduling precedence resource principal defined scheduling policy principal scheduling parameters 
scheduling policy may priority 
master process listen socket pending connections slave processes user level kernel tcp ip connections fig 
process connection server master process 
model 
forking overhead quickly problem subsequent servers ncsa httpd set pre forked processes 
model shown master process accepts new connections passes pre forked worker processes 
server process select listen socket pending connections thread user level kernel tcp ip connections fig 
single process event driven server 
multi process servers suffer interprocess communication ipc overheads servers architecture 
event driven model server uses single thread manage connections server 
event driven servers designed multiprocessors thread processor 
server uses select poll system call simultaneously wait events connections handling 
select delivers events server main loop invokes handlers ready connection 
squid zeus examples event driven servers 
alternatively single process multi threaded model connection assigned unique thread 
user level threads kernel threads 
thread scheduler responsible timesharing cpu various server threads 
server process listen socket pending connections threads user level tcp ip kernel connections fig 
single process multi threaded server 
idle threads accept new connections listening socket 
altavista front uses model 
far assumed static documents resources terms 
supports requests dynamic resources responses created demand client provided arguments 
example query web search engine altavista resolves dynamic resource 
dynamic responses typically created auxiliary third party programs run separate processes provide fault isolation modularity 
simplify construction auxiliary programs standard interfaces cgi fastcgi support communication web servers programs 
earliest interface cgi creates new process request dynamic resource newer fastcgi allows persistent cgi processes 
microsoft netscape defined library interfaces allow construction third party dynamic resource modules reside main server process fault isolation required minimizes overhead 
summary modern high performance servers implemented small set processes 
main server process services requests static documents dynamic responses created library code main server process fault isolation desired auxiliary processes communicating standard interface 
ideal theory overhead switching context protection domains incurred absolutely necessary 
structuring server small set processes poses numerous important problems show section 
shortcomings current resource management models operating system scheduling memory allocation policies attempt provide fairness resource principals graceful behavior system various load conditions 
operating systems treat process thread process schedulable entity 
process entity allocation resources cpu time memory 
basic design premise process centric systems process unit constitutes independent activity 
give process abstraction dual function serves protection domain resource principal 
protection domains processes provide isolation applications 
resource principals processes provide operating system resource management subsystem accountable entities system resources shared 
argue equivalence protection domains resource principals appropriate 
examine scenarios natural boundaries resource principals coincide processes threads 
distinction scheduling entities activities application threads single independent activity application process protection domain resource principal user level fig 
classical application 
kernel classical application uses single process perform independent activity 
applications desired units isolation resource consumption identical process abstraction suffices 
shows user mode application process perform single independent activity 
network intensive application processing done kernel 
process correct unit protection isolation encompass associated resource consumption operating systems kernel generally control properly account resources consumed processing network traffic 
systems protocol processing context software interrupts execution charged unlucky process running time interrupt process 
shows relationship application process resource principal independent activity entities network intensive application 
applications split multiple protection application threads single independent activity application process protection domain resource principal user level kernel application domain really extends kernel activity uncontrolled 
fig 
classical network intensive application 
domains example provide fault isolation different components application 
applications may perform single independent activity desired unit protection process different desired unit resource management processes application 
user mode multiprocess application trying perform single independent activity shown 
application process protection domain resource principal connections independent activities application threads user level kernel application domain extends kernel uncontrolled 
fig 
single process multi threaded server 
scenario application consists single process performing multiple independent activities 
applications single protection domain reduce context switching ipc overheads 
applications correct unit resource management smaller process set resources application accomplish single independent activity 
shows example multi threaded internet server 
real world single process internet servers typically combine scenarios single process usually manages server connections additional processes employed modularity fault isolation necessary see section 
case desired unit resource management includes part activity main server process entire activity application threads single independent activity user level kernel application process protection domain resource principal application process protection domain resource principal fig 
multi process application 
example cgi process 
operating systems solaris threads assume role resource principal 
systems cpu usage charged individual threads parent processes 
allows threads scheduled independently combined cpu usage parent process threads 
process resource principal allocation memory kernel resources sockets protocol buffers 
stress sufficient simply treat threads resource principals 
example processing particular connection activity may involve multiple threads protection domain process 
single thread may multiplexed connections 
integrating network processing resource management described traditional systems provide little control kernel resources consumed applications 
lead inaccurate accounting inaccurate scheduling 
network processing done result interrupt arrivals interrupts strictly higher priority user level code lead starvation livelock 
issues particularly important large scale internet servers 
lazy receiver processing lrp partially solves problem closely model 
lrp network processing integrated system global resource management 
resources spent processing network traffic associated charged application process caused traffic 
incoming network traffic processed scheduling priority process received traffic excess traffic discarded early 
lrp systems exhibit increased fairness stable overload behavior 
lrp extends process centered resource principal kernel leading situation shown fig resource principal application threads single independent activity application process protection domain user level kernel application resource principal extends kernel 
fig 
network intensive application lrp system 
ure 
lrp maintains equivalence resource principal process simply accurate 
lrp solve problems arise process correct unit resource management 
consequences misidentified resource principals fundamental concern allow application explicitly allocate resource consumption independent activities manages 
infeasible operating system view activity differs application system fails account large chunks consumption 
crucial server support accurately differentiated qos clients prevent overload denial service attacks give existing connections priority new ones 
single process server example traditional operating systems see resource principal process 
prevents application controlling consumption kernel cpu time kernel resources various network connections resource principal 
application control order kernel delivers network events systems control receives network events processes 
lack carefully defined concept resource principal independent abstractions process thread precludes application control desire 
new model resource management address problems inadequate control resource consumption propose new model finegrained resource management monolithic kernels 
introduce new abstraction called resource container operating system resource principal 
sections describe resource container model detail 
section discusses internet servers 
resource containers resource container operating system entity logically contains system resources application achieve particular independent activity 
connection managed web server example resources include cpu time devoted connection kernel objects sockets protocol control blocks network buffers connection 
containers attributes provide scheduling parameters resource limits network qos values 
practical implementation require access control model containers attributes space permit discussion issue 
kernel carefully accounts system resources cpu time memory consumed resource container 
system scheduler access usage information control schedules threads associated container discuss scheduling detail section 
application process access usage information example adjust container numeric priority 
current operating systems discussed section implicitly treat processes resource principals ignoring kernel resources consume 
introducing explicit abstraction resource containers clear distinction protection domains resource principals provide fuller accounting kernel resource consumption 
provides flexibility necessary servers handle complex resource management problems 
containers processes threads classical systems fixed association threads resource principals threads processes containing threads 
resource consumption thread charged associated resource principal information system scheduling threads 
resource containers binding thread resource principal dynamic explicit control application call thread resource binding 
kernel charges thread resource consumption container 
multiple threads multiple processes may simultaneously resource bindings set container 
thread starts default resource container binding inherited creator 
application rebind thread container need arises 
example thread time multiplexed connections changes resource binding switches handling connection ensure correct accounting resource consumption 
resource containers cpu scheduling cpu schedulers decisions information desired allocation cpu time history actual usage 
example traditional unix scheduler uses numeric process priorities indicate desired behavior modified measures cpu usage lottery scheduling uses lottery tickets represent allocations :10.1.1.129.159
systems support threads allocation thread may respect threads process process contention scope may respect threads system system contention scope 
resource containers allow application associate scheduling information activity thread process 
allows system scheduler provide resources directly activity matter mapped threads 
container mechanism supports large variety scheduling models including numeric priorities guaranteed cpu shares cpu usage limits 
allocation attributes appropriate scheduling model associated resource container system 
prototype implemented multi level scheduling policy supports fixed share scheduling regular time shared scheduling 
thread normally scheduled scheduling attributes container bound 
thread multiplexed containers may cost reschedule recompute numeric priority decide preempt time resource binding changes 
feedback scheduler current container resource usage calculate multiplexed thread numeric priority may accurately reflect usage 
thread scheduled combined resource allocations usage containers currently handling 
support model defines binding called scheduler binding thread set containers currently multiplexed 
priority scheduler example construct thread scheduling priority combined numeric priorities resource containers scheduler binding possibly account resource consumption set containers 
thread scheduler binding set implicitly operating system system observation thread resource bindings 
thread services container scheduler binding includes just container 
kernel prunes scheduler binding set container periodically removing resource containers thread resource binding 
addition application explicitly reset thread scheduler binding include container currently resource binding 
resources cpu cycles system resources physical memory disk bandwidth socket buffers conveniently controlled resource containers 
resource usage charged correct activity various resource allocation algorithms balance consumption principals depending specific policy goals 
stress resource containers just mechanism conjunction large variety resource management policies 
container mechanism causes resource consumption charged correct principal change charges 
unfortunately policies currently deployed general purpose systems able control consumption resources cpu cycles coarse manner typically static limits total consumption 
development powerful policies control consumption resources focus complimentary research application specific paging file caching disk bandwidth allocation tcp buffer management 
resource container hierarchy resource containers form hierarchy 
resource usage child container constrained scheduling parameters parent container 
example parent container guaranteed system resources child containers collectively guaranteed system resources 
hierarchical resource containers possible control resource consumption entire subsystem constraining understanding subsystem allocates schedules resources various independent activities 
example system administrator may wish restrict total resource usage web server creating parent container server resource containers 
web server create arbitary number child containers manage distribute resources allocated parent container various independent activities different client requests 
hierarchical structure resource containers easy implement fixed share scheduling classes enforce rich set priority policies 
prototype implementation supports hierarchy resource principals supports resource bindings threads leaf containers 
operations resource containers resource container mechanism includes operations containers creating new container process create new resource container time may multiple containers available 
default resource container created new process part thread new process bound container 
containers visible application file descriptors inherited new process 
set container parent process change container parent container set parent 
container release processes release containers descriptors threads resource bindings container destroyed 
parent container destroyed parent set parent sharing containers processes resource containers passed processes analogous transfer descriptors unix processes sending process retains access container 
process receives resource container container resource context threads 
allows application move share computation multiple protection domains regardless container inheritance sequence 
container attributes application set read attributes container 
attributes include scheduling parameters memory allocation limits network qos values 
container usage information application obtain resource usage information charged particular container 
allows thread serves multiple containers execution containers particular scheduling policy 
operations control relationship containers threads sockets files binding thread container process set resource binding thread container time 
subsequent resource usage thread charged resource container 
process obtain current resource binding thread 
reset scheduler binding application reset thread scheduler binding include current resource binding 
binding socket file container process bind descriptor socket file container subsequent kernel resource consumption behalf descriptor charged container 
descriptor may bound container descriptors may bound container 
prototype currently supports binding sockets disk files 
kernel execution model resource containers effective kernel processing behalf process performed resource context appropriate container 
discussed section current systems protocol processing context software interrupt may fail charge costs proper resource principal 
lrp discussed section addresses problem associating arriving packets receiving process early possible allows kernel charge cost received packet processing correct process 
extend lrp approach associating received packet correct resource container process 
kernel uses threads network processing thread handling network event set resource binding resource container non threaded kernel ad hoc mechanism perform accounting 
pending protocol processing multiple containers priority scheduling parameters containers determines order serviced kernel network implementation 
resource containers describe server application resource containers provide robust controlled behavior 
consider example server designs 
consider single process multi threaded web server uses dedicated kernel thread handle connection 
server creates new resource container new connection assigns pool free threads service connection 
application sets thread resource binding container 
subsequent kernel processing connection charged connection resource container 
situation shown 
particular connection example long file transfer consumes lot system resources consumption charged resource container 
result scheduling priority associated thread decay leading preferential scheduling threads handling connections 
consider event driven server uniprocessor single kernel thread handle connections 
server creates new resource container new connection 
server processing connection sets thread resource binding container 
operating system adds container thread scheduler bind application process resource containers protection domain connections application threads user level kernel independent activities fig 
containers multi threaded server 
ing 
depicts situation 
connection consumes lot resources usage charged corresponding container 
server application obtain usage information adjust container numeric priority control subsequently expends resources connection 
kinds servers handling request dynamic cgi document pass connection container cgi process 
may done inheritance traditional cgi child process explicitly persistent cgi server processes 
dynamic processing done module server process application simply binds thread appropriate container 
server may wish assign different priorities requests different sources processing occurs kernel application sees connection 
defend denial service attacks isp provide enhanced class service users paid premium 
support prioritization define new namespace includes filter specifying set foreign addresses addition usual internet address port number 
filters specified tuples consisting template address cidr network mask 
application uses bind system call bind multiple server sockets local address local port tuple different template address cidr mask filter 
system uses filters assign requests particular client set clients socket matching filter 
associating different resource container socket server application assign different priorities different sets clients prior listening accepting new connections sockets 
want able specify complement filters accept connections certain clients 
server resource container associated application process resource containers protection domain connections application thread user level kernel independent activities fig 
containers event driven server 
listening socket set priority accepting new connections relative servicing existing ones 
particular defend denial service attack specific set clients server create socket filter matches set bind resource container numeric priority zero 
requires network infrastructure reject spoofed source addresses problem currently addressed 
server administrator may wish restrict total cpu consumption certain classes requests cgi requests requests certain hosts requests certain resources 
application creating container class setting attributes appropriately limiting total cpu usage class creating resource container individual request child corresponding container 
resource containers enable precise accounting costs activity may useful administrators simply sending accurate bills customers capacity planning 
resource containers ways similar resource management mechanisms developed context multimedia real time operating systems :10.1.1.55.5234
resource containers distinguished mechanism generality direct applicability existing general purpose operating systems 
see section discussion related 
performance performed experiments evaluate resource containers effective way web server control resource consumption provide robust controlled service 
prototype implementation prototype implemented modifications digital unix kernel 
changed cpu scheduler resource management subsystem network subsystem understand resource containers 
modified digital unix cpu scheduler scheduler treat resource containers resource principals 
resource container obtain fixed share guarantee scheduler cpu usage restrictions parent container choose time share cpu resources granted parent container sibling containers 
fixed share guarantees ensured timescales order tens seconds larger 
containers fixed share guarantees child containers time share containers children 
prototype threads bound containers 
changed tcp ip subsystem implement processing treating resource containers resource principals 
process kernel thread perform processing network packets priority order containers 
ensure correct accounting thread sets resource binding appropriately processing packet 
implementing container abstraction added lines new code digital unix kernel 
lines kernel code changed lines code added integrate containers system resource principals implement lrp style network processing 
lines integration code lines changed new concerned cpu scheduler lines changed new network subsystem remainder spread rest kernel 
code changes small server applications considered fairly pervasive application 
experimental environment experiments server digital personal workstation au mhz kb cache kb cache kb level unified cache mb level unified cache specint mb ram running modified version digital unix 
client machines mhz pentium pro pcs mb memory running freebsd 
experiments ran private mbps switched fast ethernet 
server software single process event driven program derived thttpd 
started modified version thttpd numerous performance improvements changed optionally resource containers 
clients client software 
baseline throughput measured throughput server running unmodified kernel 
handling requests small files kbyte filesystem cache server achieved rate requests sec 
connection request requests sec 
persistent connection 
rates saturated cpu corresponding request cpu costs respectively 
costs new primitives measured costs primitive operations resource containers 
new primitive user level program invoked system call times measured total elapsed time divided obtain mean warm cache cost 
results table show operations costs smaller single transaction 
implies resource containers add negligible overhead 
operation cost create resource container destroy resource container change thread resource binding obtain container resource usage set get container attributes move container processes obtain handle existing container table cost resource container primitives 
verified measuring throughput server running modified kernel 
test web server process created new resource container request 
throughput system remained effectively unchanged 
prioritized handling clients experiment tested effectiveness resource containers enabling prioritized handling clients web server 
consider scenario server administrator wants differentiate classes clients example payment 
experiment increasing number clients saturate server single client requests server 
requests static kb file request connection 
measured response time perceived high priority client 
shows results 
axis shows response time seen high priority client high asa function number concurrent low 
dotted curve shows high varies unmodified kernel 
application attempted give preference requests high priority client handling events socket returned select events sockets 
figures shows despite preferential treatment high increases sharply low priority clients saturate server 
happens request processing occurs inside kernel uncontrolled 
throughput requests sec response time ms unmodified system lrp system rc system rc system number concurrent cgi requests fig 
throughput competing cgi requests 
containers new event api containers select containers number concurrent low priority clients fig 
high varies load 
dashed solid curve shows effect resource containers 
server uses containers different numeric priorities assigning high priority requests container low priority requests 
dashed curve labeled containers select shows effect resource containers application select wait events 
high increases original system 
resource containers allow application control resource consumption levels system 
example tcp ip processing performed fifo order classical systems performed priority order 
remaining increase response time due known scalability problems select system call 
problems alleviated smart implementation described inefficiency inherent semantics api 
cpu share cgi processing unmodified system lrp system rc system rc system number concurrent cgi requests fig 
cpu share cgi requests 
problem call specify bitmap complete set descriptors application interested 
kernel check status descriptor set 
causes overhead linear number descriptors handled application 
solid curve labeled containers new event api shows variation high server uses new scalable event api described 
case high increases slightly number clients increases 
remaining slight increase high reflects cost packet arrival interrupts low priority connections 
kernel handle interrupts invoke packet filter determine priority packet 
controlling resource usage cgi processing section described requests dynamic resources typically handled processes main web server process 
system cpu equally processes backend cgi processes may gain excessive share cpu reduces throughput static documents 
constructed experiment show server resource containers explicitly control cpu costs cgi processes 
measured throughput web server cached kb static documents increasing number concurrent requests dynamic cgi resource 
cgi request process consumed seconds cpu time 
results shown curve labeled unmodified system 
number concurrent cgi requests increases cpu shared larger set processes main web server share decreases sharply reduces throughput static documents 
example concurrent cgi requests web server gets cpu static request throughput drops maximum 
main server process gets slightly cpu cgi process network processing 
shown plots total cpu time cgi processes 
figures curves labeled lrp system show performance lrp version digital unix 
lrp fixes main server process shares cpu equally processes 
reduces throughput static documents 
measure resource containers allow finegrained control cgi processes modified server container created cgi request child specific cgi parent container 
cgi parent container restricted maximum fraction cpu recall restriction includes children 
figures curves labeled rc system show performance cgi parent container limited cpu curves labeled rc system correspond limit 
shows cpu limits enforced exactly 
shows effectively forms resource sand box cgi processes throughput static requests remains constant number concurrent cgi requests increases 
note web server additionally impose relative priorities cgi requests adjusting resource limits corresponding container 
immunity syn flooding constructed experiment determine resource containers combined filtering mechanism described section allow server protect denial service attacks syn flooding experiment set malicious clients sent bogus syn packets server port high rate 
measured server throughput requests wellbehaved clients cached kb static document 
shows throughput unmodified system falls drastically syn flood rate increases effectively zero syns sec 
modified kernel notify application drops syn due queue overflow 
modified server isolate misbehaving client low priority listen socket filter mechanism described section 
modifications syns sec useful throughput remains maximum 
slight degradation results interrupt overhead syn flood 
note lrp contrast system protect syn floods filter traffic port source address 
throughput requests sec resource containers unmodified system syn flood rate syns sec fig 
server behavior syn flooding attack 
isolation virtual servers section shows resource containers allow resource sand boxes put cgi processes 
approach applications total resource usage guest servers rent server environment :10.1.1.141.3942:10.1.1.141.3942
current operating systems guest server consist processes appear system numerous resource principals 
number may vary dynamically little relation cpu time server administrator wishes allow guest server 
performed informal experiment show resource containers solve problem 
created top level containers restricted cpu consumption fixed cpu shares 
container root container guest server 
subsequently sets clients placed varying request loads servers requests included cgi resources 
observed total cpu time consumed guest server exactly matched allocation 
resource container hierarchy recursive guest server control allocated resources re divided competing connections 
related mechanisms developed support fine grained research management 
contrast resource container abstraction 
scout operating system path abstraction representing channel tcp connection multi layered system 
path encapsulates specific attributes channel allows access attributes layers 
paths implement fine grained resource management network appliances including web server ap 
resource containers contrast paths allow application treat resources consumed channels part activity 
composition path limited router graph specified kernel build time resource containers encompass arbitrary sets resources run time 
mercer introduced reserve abstraction context real time mach 
reserves insulate programs timing execution characteristics programs 
application reserve system resources system ensures resources available needed threads associated reserve 
resource container reserve provides thread resource context may passed protection domains may bound thread multiple threads 
reserves charge resource principal resources consumed activity distributed protection domains 
resource containers reserves account control kernel mode processing behalf activity rt mach microkernel system network processing done user mode 
resources containers structured hierarchically manage system resources cpu 
activity abstraction similar resource containers 
resource container activity account resource consumption protection domains granularity smaller protection domain 
experimental realtime object oriented operating system designed scratch resource accountability 
contrast scout rt mach aimed developing resource accounting mechanism traditional unix systems minimal disruption existing apis implementations 
migrating threads mach spring allow resource consumption thread shuttle performing particular independent activity charged correct resource management entity thread shuttle moves protection domains 
systems separate concepts thread resource principal correctly handle applications single thread associated multiple independent activities event driven web server 
mach spring microkernel systems raise issue accounting network processing 
reservation domains performance units verghese allow resource consumption group processes considered purpose scheduling 
abstractions allow resource principal encompass number protection domains resource containers abstraction addresses scenarios single process web server natural extent resource principal complicated 
number mainframe operating systems provide resource management granularity process 
systems allow group processes processes owned user treated single resource principal regard similar resource containers 
provisions resource accounting granularity smaller process 
systems account limit resources consumed process group long periods time order hundreds minutes longer 
resource containers hand support policies fine grained short term resource scheduling including real time policies 
resource container hierarchy similar hierarchical structures described scheduling literature :10.1.1.129.159
hierarchical scheduling algorithms complementary resource containers schedule threads resource container hierarchy 
exokernel approach gives application software control possible raw system resources 
functions implemented traditional operating systems provided user mode libraries 
network server built exokernel application controls essentially protocol stack including device drivers storage system similarly exposed 
application directly control resource consumption network file feasible implement resource container abstraction feature exokernel library operating system exokernel delegates resource management user code 
almeida attempted implement qos support modified apache web server running general purpose monolithic operating system 
apache uses process connection mapped qos requirements numeric process priorities experimenting fully user level implementation slightly modified linux kernel scheduler 
able provide differentiated service different qos classes 
effectiveness technique limited inability control resource consumption differentiate existing connections new connection requests 
approach extend event driven servers 
researchers studied problem mode network processing 
mogul ramakrishnan improved overload behavior busy system converting interrupt driven processing explicitly scheduled processing 
lazy receiver processing lrp extended associating received packets early possible receiving process performed subsequent processing process scheduling priority 
resource containers generalize idea separating concept resource principal protection domain 
introduced resource container operating system abstraction explicitly identify resource principal 
resource containers allow explicit fine grained control resource consumption levels system 
performance evaluations demonstrate resource containers allow web server closely control relative priority connections combined cpu usage various classes requests 
new namespace resource containers provide immunity certain types denial service attacks 
experience suggests containers address large variety resource management scenarios servers instance expect container hierarchies effective controlling resource usage multi user systems workstation farms 
acknowledgments grateful deborah wallach carl waldspurger willy zwaenepoel osdi shepherd mike jones anonymous reviewers comments helped improve 
supported part nsf ccr ccr texas 
almeida cao 
providing differentiated quality service web hosting services 
proc 
workshop internet server performance june 
anderson pasquale 
performance container shipping system 
proc 
fifteenth acm symposium operating system principles dec 
apache 
www apache org 
banga druschel 
measuring capacity web server 
proc 
usenix symp 
internet technologies systems dec 
banga druschel mogul 
better operating system features faster network servers 
proc 
workshop internet server performance june 
condensed version appears acm sigmetrics performance evaluation review dec 
banga mogul 
scalable kernel performance internet servers realistic loads 
proc 
usenix technical conference june 
bruno gabber silberschatz 
eclipse operating system providing quality service reservation domains 
proc 
usenix technical conference june 
burrows 
personal communication mar 
cao 
application controlled file caching prefetching 
phd thesis princeton university jan 
common gateway interface 
ncsa uiuc edu cgi 
chankhunthod danzig neerdaels schwartz worrell 
hierarchical internet object cache 
proc 
usenix technical conference jan 
chess 
vm resource limiter 
ibm systems journal 
clark jensen reynolds 
architectural overview alpha real time distributed kernel 
workshop micro kernels kernel architectures apr 
denning 
third generation computer systems 
acm computing surveys dec 
druschel banga 
lazy receiver processing lrp network subsystem architecture server systems 
proc 
nd symp 
operating systems design implementation oct 
open market 
fastcgi specification 
www fastcgi com 
ford lepreau 
evolving mach migrating thread model 
proc 
winter usenix conference jan 
goyal guo vin 
hierarchical cpu scheduler multimedia operating systems 
proc 
nd symp 
operating systems design implementation oct 
hamilton 
spring nucleus microkernel objects 
proc 
summer usenix conference june 
cheriton 
application controlled physical memory external page cache replacement 
proc 
th int conf 
architectural support programming languages operating systems oct 
hu schmidt 
measuring impact event dispatching concurrency models web server performance high speed networks 
proc 
nd global internet conf nov 
jones leach draves bar 
modular real time resource management operating system 
proc 
th workshop hot topics operating systems may 
kaashoek engler ganger hunt mazieres grimm mackenzie 
application performance flexibility exokernel systems 
proc 
th symp 
operating system principles oct 
krueger vahdat anderson 
tools development application specific virtual memory management 
proc 
th annual conf 
object oriented programming systems languages applications oct 
lee yoshida mercer rajkumar 
predictable communication protocol processing real time mach 
proc 
ieee real time technology applications symp june 
mckenney dove 
efficient demultiplexing incoming tcp packets 
proceedings sigcomm conference aug 
mcnamee armstrong 
extending mach external pager interface accomodate user level page replacement policies 
proc 
usenix mach symp oct 
mercer savage tokuda 
processor capacity reserves multimedia operating systems 
proc 
ieee int conf 
multimedia computing systems may 
microsoft overview 
www microsoft com msdn sdk platforms doc sdk internet src htm 
mogul ramakrishnan 
eliminating receive livelock interrupt driven kernel 
acm trans 
computer systems aug 
mosberger peterson 
making paths explicit scout operating system 
proc 
nd symp 
operating systems design implementation oct 
ncsa httpd 
ncsa uiuc edu 
north american network operators group 
mailing list archives thread 
www merit edu mail archives html threads html apr 
netscape server api 
www netscape com std server api html 
pai druschel zwaenepoel 
io lite unified buffering caching system 
proc 
rd symp 
operating systems design implementation feb 
rekhter li 
architecture ip address allocation cidr 
rfc sept 

mvs tuning approach os problem solving 
ibm systems journal 

study effects context switching caching server performance 
www eecs harvard edu stuart html 
semke mathis 
automatic tcp buffer tuning 
proc 
sigcomm conference sept 
spatscheck petersen 
defending denial service attacks scout 
proc 
rd symp 
operating systems design implementation feb 
squid 
squid nlanr net squid 
stevens 
tcp ip illustrated volume 
addison wesley reading ma 
khalidi 
efficient framework unix 
technical report tr sun microsystems laboratories may 
thttpd 
www acme com software thttpd 
vahdat yoshikawa anderson culler dahlin :10.1.1.141.3942
webos operating system services wide area applications 
proc 
seventh symp 
high performance distributed computing july 
verghese gupta rosenblum 
performance isolation sharing isolation shared memory multiprocessors 
proc 
th intl 
conf 
architectural support programming languages operating systems oct 
waldspurger 
lottery stride scheduling flexible proportional share resource 
phd thesis massachusetts institute technology sept 
waldspurger weihl 
lottery scheduling flexible proportional share resource management 
proc 
symp 
operating systems design implementation nov 
zeus 
www zeus uk 
