software process validation quantitatively measuring correspondence process model jonathan cook new mexico state university alexander wolf university colorado great extent usefulness formal model software process lies ability accurately predict behavior executing process 
similarly usefulness executing process lies largely ability fulfill requirements embodied formal model process 
process models process executions diverge significant happening 
developed techniques uncovering measuring discrepancies models executions call process validation 
process validation takes process execution process model measures level correspondence 
metrics tailorable give process engineers control determining severity different types discrepancies 
techniques provide detailed information high level measurement indicates presence problem 
applied process validation methods industrial case study portion described article 
categories subject descriptors software engineering programming environments management computing information systems software management software development software maintenance general terms management additional key words phrases balboa process validation software process tools supported part national science foundation ccr ccr air force materiel command rome laboratory defense advanced research projects agency contract number 
content information necessarily reflect position policy government official endorsement inferred 
authors addresses cook department computer science new mexico state university las cruces nm email cs nmsu edu wolf software engineering research laboratory department computer science university colorado boulder email alw cs colorado edu 
permission digital hard copy part personal classroom granted fee provided copies distributed profit commercial advantage copyright notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
acm acm transactions software engineering methodology vol 
april pages 
cook wolf 
model system created question arises model faithfully captures system 
software process research model typically embedded executed automated software engineering environment garg jazayeri question avoided model process necessarily agreement model process 
applied software process practice approach suffers fundamental flaw 
particular assumes virtually entire process executed context environment 
fact critical aspects process occur computer eye environment sutton wolf rosenblum 
case effective way enforce process approach guarantee mutual consistency process model process execution 
deviations process naturally expected cugola ellis grudin arise basic differences machine world emmerich 
completely enforce process remains issue managing change process lead discrepancy model execution 
fact considerable addresses process evolution conradi 
commensurate historical approach mentioned concerned problem effecting changes process model automation problem uncovering inconsistencies model execution 
developed techniques detecting characterizing differences formal model process actual execution process 
refer activity process validation cook wolf 
techniques neutral respect correctness model model reflect correctness execution follow model 
process engineer ultimate responsibility making appropriate determination problem lies model execution particular inconsistency uncovered 
validation techniques implemented prototype tool part industrial process data analysis case study cook 
process validation serves purposes 
confidence formal process model raised shown process execution consistent behavior described model 
turn raises confidence results analyses performed formal model 
process validation process enforcement tool uncovering differences intended behavior actual behavior 
potentially flexible enforcement tool proposed accommodate unavoidable necessary local perturbations process 
process validation reveal acm transactions software engineering methodology vol 
april 
software process validation process may need evolve accommodate new project requirements activities 
techniques borrow various areas computer science including distributed debugging concurrency analysis pattern recognition 
techniques go simply detecting inconsistency provide measure inconsistency 
believe developing metrics process validation critical highly dynamic exceptional nature software processes means simple answers carry little information significance inconsistency 
managers need understand inconsistency occurs severe inconsistency corrective action 
section presents framework cast 
section states process validation problem outlines approach 
section defines validation metrics section presents example uses metrics 
issue deriving characteristic behavior process model discussed section 
section presents short review industrial case study validation techniques successfully applied 
section summarizes related process validation 
describe implementation validation tool discuss ideas section 
general article focuses theoretical foundations validation techniques practical implementation techniques tool 
focus presentation broad methodology applying process validation process improvement effort basic approach discernable examples 
refer reader detailed treatment methodological issues cook 

event framework process validation foundation process validation rests view processes sequence actions performed agents human automaton possibly working concurrently 
decidedly behavioral view processes interested dynamic activity displayed processes say static roles responsibilities agents static relationships components products 
mean aspects process worthy study just issues chosen investigate having behavior structure 
events wolf rosenblum event model process actions event characterize dynamic behavior process terms identifiable instantaneous actions invoking development tool deciding activity performed 
events characterize behavior widely accepted areas software engineering program acm transactions software engineering methodology vol 
april 
cook wolf tion leblanc robbins concurrent system analysis avrunin cook wolf distributed debugging bates cuny 
instant event relative time granularity needed desired certain activities short duration relative time granularity represented single event 
activity spanning significant period time represented interval events 
example meeting represented meeting event meeting event pair 
similarly module compilation submitted batch queue represented events enter queue compilation compilation purposes maintaining information action events typed attributes attribute time event occurred 
generally event attributes items agents artifacts associated event tangible results action pass fail design review errors errors compilation information gives character specific occurrence type event 
described direct attributes time doing important direction 
attributes recorded data available process engineer event definition mechanisms employed support tools cook wolf 
example possible take slice data set specific event attribute 
overlapping activities process represented sequence events refer event stream 
simplicity assume single event stream represents execution process depending data collection method assumption relaxed 
ability collect events central supporting event data analysis 
fortunately tools environments today provide strong support logging events occur system 
version control system example logs accessing modification documents code 
computer events meetings phone calls logged manually 
email logs project alias starting point collecting communication events 
detailed discussion existing support collecting events previous studies events scope article cook cook wolf cook krishnamurthy rosenblum selby 
relating models events event sites purposes focus behavioral process modeling formalisms 
include models state machines statemate harel petri nets slang nets procedural languages appl sutton rule languages oz ben shaul kaiser 
acm transactions software engineering methodology vol 
april 
fig 

venn diagram event types 
software process validation assume model described formalism induces event streams places behavioral description events recognized 
call places event sites 
state machine example state transitions event sites transition labeled event produces 
petri net naturally transitions event sites firing sequence effect event stream 
rule language rules event sites 
note transitions rules event sites 
may internal behavior model need visible event stream analyses 
event sites typed event site produces specific type event 
event type set event sites process model produce 
event domains distinction process model process execution really universes event types 
universe set event types associated model process set event types associated execution process 
conceptual relationship depicted indicates sets necessarily equivalent 
example consider organization executes particular process 
members organization may informally unilaterally decide perform occasional code inspections formal model process account ad hoc activity 
conversely model adopted organization include subprocess design reviews adopting organization decide perform activity 
third set event types shown includes collected data 
set necessarily subset execution events record occurs viewed window actual process execution 
window show execution may activities event data collected 
reasons occur obvious ones data particular event type considered inconsequential data considered expensive collect 
instance events occur computer acm transactions software engineering methodology vol 
april 
cook wolf staff meetings expensive collect events occur computer simply computer events require manual opposed automated collection techniques 
important note concentrate event types abstractions activities process 
assume model execution agree significant extent set event types activities involved process may agree specific orderings numbers events types 
largely agree basic sets activities clear mean relating process 
modeling data collection closely related sense models frame data collection activity vice versa 
assume particular names event types model collected execution data equivalent 
fortunately simple syntactic issue easily dealt name mapping applied event stream 
fact data analysis framework validation tool implemented provides convenient mechanism regular expressions creating applying mappings execution stream cook wolf 
mechanism additionally allows analyst extract events data map event types arbitrary levels granularity 
particular granularities event types derived data match granularity event types model 

problem statement approach framework process validation executing process produces actual event stream side model induces desired prescribed event stream 
cast validation problem quantitatively measuring close event stream executing process resembles event stream induced model 
call event streams execution event stream model event stream respectively 
depicts process validation framework 
methods performing measurement applicable string distance metric kruskal 
string distance metric counts number token insertions deletions substitutions needed transform string 
applying various mathematical transformations method family metrics 
string distance metrics applications varied dna rna matching waterman substring matching kashyap schneider spelling error correction du chang syntax error correction aho peterson fischer text file differencing acm transactions software engineering methodology vol 
april 
fig 

process validation framework 
software process validation unix tool diff 
general string distance metrics standard method domain requiring symbolic sequence comparison 
methods quantify difference event streams offer versatility string distance metrics 
hamming distance example count number tokens differ method assumes streams length suitably matched padded 
fact string distance metrics subsume method ignoring insertion deletion operations just tallying substitutions 

validation metrics section introduce metrics determining correspondence formal model process execution process 
share characteristic string distance compare event stream produced process execution event stream representing possible behavior predicted process model 
issue second event streams constructed important discussed section 
defer detailed examples applying metrics section 
simple string distance metric metric uses simple direct approach measuring string distance refer simple string distance ssd metric 
method distance strings measured counting minimum number token insertions deletions numeric sequences really representation mathematical function time series stock value different topic altogether 
acm transactions software engineering methodology vol 
april 
cook wolf fig 

example execution model event streams execution stream transformed ssd metric nsd metric calculations 
tions needed transform string 
purposes choose execution event stream operations applied 
choice insertions represent missed activities model predicted execution perform deletions represent extra activities model predict performed case 
example consider execution model event streams shown boxes represent events 
lines drawn streams indicate possible correspondence respective events 
transformation execution stream model stream depicted 
particular delete substitute insert resulting value distance 
happens minimum transformation required 
strengthen metric weights assigned operation types insertion deletion substitution giving relative cost 
minimizing number operations calculate distance goal minimize total cost operations 
operations isomorphic choosing event stream change resulting measurement just reverses senses insertion deletion 
acm transactions software engineering methodology vol 
april 
strings length length minimum total cost operations computed mn time wellknown dynamic program kruskal 
applications method dna rna sequencing text recognition token substitution string distance metric sense 
process validation clear substituted event contribute way measure correspondence 
account set weight substitution greater sum insertion deletion weights substitution applied costly apply deletion insertion pair potential substitution point 
consider substitution article 
ssd metric formulated equation ssd max software process validation weights insertion deletion operations number insertion deletion operations performed execution event stream max maximum length execution event stream 
divisor equation normalizes value size input maximum weight 
weights act tuning parameters metric highlight different properties process 
example argue insertions execution event stream costly deletions inherently represent missed activities process execution 
conversely deletions execution event stream sense represent extra performed perspective predicted formal model extra probably affect correctness process execution 
set reflect property 
values metric intents purposes bounded 
technically value greater appear events deleted inserted 
pick standard statistical correlation rules thumb devore say measurement strong correspondence moderate correspondence greater weak correspondence 
nonlinear string distance metric characteristic ssd metric focused narrowly costs individual string transformation operations operation inversions standard statistical rules thumb effect 
acm transactions software engineering methodology vol 
april 
cook wolf weighted separately 
terms process behavior sequence missed activities example viewed single deviation expected model behavior potentially serious desired execution represented simple count missed activities 
metric accounts 
nonlinear string distance nsd metric enhancement ssd metric notion sequence insertions sequence deletions 
sequence insertions sequence deletions called block 
sequence mean unbroken series transformation operations 
example nsd recognizes consecutive insertions required streams insertion block length 
blocks length 
nsd metric uses block lengths calculate values 
distance equation nsd ni nd wif bj bk max nd numbers insertion deletion blocks particular block length cost function applied block length terms ssd metric 
note weights pulled cost function left outside easily compare nsd ssd metric equations 
definition cost function additional tuning parameter nsd metric 
natural function exponential constant actual tuning parameter 
equation yields block length blocks kept length nsd equation reduces ssd equation expected 
cost function yields exponentially increasing values blocks greater 
notice block length function cause distance value corresponding value ssd metric want 
reason consider value produced nsd metric greater value produced ssd metric blocks length greater 
practical values range larger values blocks small important 
exponential factor extreme larger block sizes 
ssd metric nsd metric unbounded high bounded low 
harder say value represent correspondence model execution acm transactions software engineering methodology vol 
april 
represent bad correspondence 
derive values rules thumb ssd metric cutoff correspondence moderate correspondence 
needed nsd rules thumb notion average block length expected event stream correspondence model 
defined avg derived cutoff correspondence nsd metric follows ek avg software process validation takes ssd correspondence cutoff weights exponential weight average expected block length account tuning parameter example sets avg cutoff value correspondence 
value nicely reduces ssd cutoff value avg 
moderate cutoff value place 
note history applying nsd metric process accumulated actual value avg process known 
event type weighting discussed validation metrics include means differentially weight insertion deletion transformation operations 
represent conceptually different kinds deviations missed extra activities respectively 
finer level granularity useful differentiate relative importance specific types events 
example event representing regression testing activity considered important event representing weekly team training meeting 
possibility weighting event type differently distinguish significance matching kind event process validation 
ssd nsd metrics easily incorporate weighting scheme tools implement functionality 
process engineer override default insertion deletion weights vary operation weights type event involved operation 
having ability tailor weights event type allows engineer distinguish large grained events versus small grained events important events versus unimportant events 
example high insertion weight code inspection event signify important event occur process execution 
practical matter default insertion deletion weights normalization part metric equation 
acm transactions software engineering methodology vol 
april 
cook wolf auxiliary measures metrics provide single value measure correspondence 
measure useful indicate presence potential problem 
deeper understanding deviation needed uncover source problem 
ssd nsd metrics naturally provide auxiliary measures analyst including number events match compared streams number insertion deletion operations calculate metric number size average size blocks operations number matches insertions deletions event type locations execution event stream deviations occur locations model deviations occur 
auxiliary measures enhance usefulness basic metrics 
section show contribute detailed important information understanding deviations industrial case study 

example metrics illustrate validation metrics introduced previous section test unit task process problem kellner 
simple small process fragment give reader feel metrics applied process inform engineer process deviations varying levels detail 
task developer tester involved testing module undergone change 
retrieve test suite configuration control build test executable run specified tests sure code coverage achieved tests 
failure occurs new module error test suite needs updating notify module developers test developers appropriate 
successful completion tests store test results configuration control alert manager new status module 
shows colored petri net model jensen process 
circles denote places rectangles denote transitions 
tokens attributes colored attributes transition predicates deterministically control transition firing 
thick rectangles correspond transitions event sites model labeled event produced site 
thin rectangles correspond internal transitions control model event sites 
keep simple collapse event pairs activity pseudo event type event acm transactions software engineering methodology vol 
april 
software process validation fig 

petri net model test module task 
acm transactions software engineering methodology vol 
april 
cook wolf table example pairs execution model event streams example example example example example exec 
model exec 
model exec 
model exec 
model exec 
model exec exec exec exec exec exec exec exec diff diff diff diff diff diff diff diff exec exec exec exec exec exec exec exec exec diff diff diff diff diff diff diff diff diff diff tcov tcov exec exec exec exec exec exec exec exec ci ci diff diff diff diff diff diff diff mail mail tcov tcov tcov tcov tcov tcov exec exec mail mail ci mail diff diff mail mail ci tcov mail ci mail mail site thought transition sequence producing event second producing event 
familiar unix command names names event types 
table shows example pairs execution model event streams 
blank space execution event stream point model predicted particular event occurred fact event occur 
similarly blank space model event stream point event occurred execution predicted model 
intuitively blanks correspond missed extra activities process execution error model 
example stream execution involves consecutive invocations tool result problem performing build model predicts occurred 
ssd nsd metric calculations require transformation execution event stream corresponding model event stream means insertion deletion operations 
apply insertion operation blank execution event stream apply deletion operation blank model event stream 
table ii shows validation measurements event streams table row contains measurements correspondingly numbered example event stream 
columns give raw number insertions raw number deletions needed transform execution event stream model event stream 
unfamiliar unix command names appearing ci check check commands configuration management tool build tool exec stands running executable test run case tcov test coverage tool diff text differencing tool mail electronic mail tool 
recall chose execution event stream transformation operations applied see section 
acm transactions software engineering methodology vol 
april 
software process validation table ii 
example event stream measurements streams table ssd nsd nsd ssd nsd nsd example ins del cutoff values columns table ii give results parameterized string distance calculations 
vary relative weights ssd nsd metrics vary exponential constant nsd metric 
cases weights equal cases insertion cost weighted heavier highlight missed events execution 
exponential constant nsd metric values show magnitude change unboundedness metric 
row table shows cutoff values correspondence rules thumb metric values column bottom row fall call correspondence model execution event streams 
nsd metric cutoffs average expected block length avg taken 
interesting things see measurements table ii 
observation similarity values columns 
streams block length length different operation combinations measurements differentiate discrepancies 
hand looks measurements columns event streams see effect weighting insertions heavier deletions 
ssd metric measurement changes addition deletes stream remains correspondence range nsd metric 
stream ssd produces measurement correspondence range ssd moderate range 
stream just insertion stream weighting better reflects correspondence execution streams weighting 
cost ratio wi chosen arbitrarily example 
practice process engineers explore various ratios best reflect actual situation analyzing 
acm transactions software engineering methodology vol 
april 
cook wolf event stream insertions block length deletions stream measurements significantly greater event stream 
shows metrics tuned place importance insertions missed events process execution 
event stream shows measurements insertions difference weighting insertions evident comparison event streams 
deriving model event stream section presents process validation metrics assuming existence event streams execution stream model stream 
stream execution stream 
model stream model describes set streams 
perform measurement induce model stream model 
challenge course formal model trivial process leads large infinite number possible event streams 
choose 
measuring correspondence need derive model event stream closely matches execution event stream order get useful measure possible 
closely mean model stream gives minimum distance measurement 
model stream imply greater discrepancy necessary 
important note closeness fixed property relationship execution event stream model depends validation metric applied weightings metric different weights insertion deletion operations event types affect model stream closest 
deriving model stream blind generate test effort 
example execution stream exactly matches model wants choose model stream execution stream 
small differences wants choose model stream execution stream 
model stream derivation problem restated finding smallest changes execution stream valid model stream 
changes exactly insertions deletions contribute distance metrics 
clearly execution stream model derive model stream metric calculation 
background main areas related addressed problem similar model stream derivation problem error correcting parsing behavior searching regular expression matching 
approaches stream model 
review areas place approach context 
acm transactions software engineering methodology vol 
april 
software process validation parsing 
syntax error encountered modern compiler programming language expected report error recover way continue parse rest program 
essence compiler find correction string tokens program model syntax language model continue match rest tokens 
minimal correction desired allow compiler process program possible problem similar face process validation 
compiler research produced methods interest 
aho peterson show cubic algorithm globally performing minimum cost error correction terms token insertion deletion 
expect algorithm high cost 
propose baseline compare methods 
describes error correction method biased insertion symbols arguing little program text skipped deleted possible 
method idea minimum distance correction assumption needs back input stream find correction 
fischer describe method local cost error correction 
biased insertions include deletions 
method uses local search priority queue find local minimum cost fix 
show method fast reasonably implement compiler 
techniques specifically developed programming language parsing grammars domain 
critical assumptions able back input stream necessarily valid software process domain 
general techniques applicable model event stream derivation problem 
demonstrate important points optimal solutions cost prohibitive heuristics effectively employed practice 
behavior searching 
model checking technique efficiently explore finite state space inherent behavioral properties including particular behavior allowed model 
example burch describe model checker binary decision diagrams able check models states previous handled states 
impressive models analyzed pipelined arithmetic logic unit self similar states resulting width bits value 
model checker directly represents regularity state space avoid large extent state explosion 
models acm transactions software engineering methodology vol 
april 
cook wolf regularity state space admit techniques provide leverage 
example technique search behavior constrained expressions framework avrunin dillon 
method model current simulation state model desired event answer question event produced 
model stated system event sequences specified extended regular expressions 
representation desired event event sequence find behavior reduced system inequalities fed integer linear solver 
solver produces binary answer indicating success failure search finds solution parameters 
solver answer heuristics parameters solver produce plausible behavior leads event 
behavior constitutes sequence model events 
unfortunately answer constrained expressions framework help determining correction event stream model state continue analysis rest event stream 
problem process validation needs techniques analyze model continual presence deviations model 
appears techniques constrained expressions framework applicable 
issue leverage system transformations gain speed scalability transformations system inherently 
regular expression matching 
knight myers myers miller describe algorithms approximately matching string regular expression insertion deletion substitution operations 
methods build dynamic programming techniques string string comparison algorithms extend regular expressions 
simple operation symbol weightings equivalent ssd metric algorithms operate mn time 
dealing blocks gaps nsd metric requires complicates matters significantly 
general string tostring comparisons epstein string regular expression comparisons myers miller arbitrary cost functions blocks require cubic time 
better results obtained assumes concave block costs bi difference cost block length nonincreasing increases 
assumption regular expression matching takes mn logm log time takes mn nlog space 
nsd metric general concave block costs 
fact formulation convex costs longer block represents serious deviation process model 
domains block cost function naturally concave 
example dna matching high cost physically breaking sequence means block gets longer cost breaking amortized length block 
results concave cost function 
acm transactions software engineering methodology vol 
april 
software process validation regular expression algorithm takes advantage simplicity modeling paradigm 
general constructs process modeling languages reducible regular expressions 
powerful restricted constructs studied 
example context free languages thought high order polynomial time algorithms solving approximate matching knight myers 
general cubic techniques providing optimal answers impractical 
generally large constants actual running times 
incremental data driven matching survey related approaches leads general model event stream derivation problem known efficient optimal solutions 
fact formulations problem known optimal solutions efficient 
fortunately problem quite bad 
observe execution event stream corresponds places reasonable model process 
true model contrary immediately obviously useless 
second execution event stream help guide search model significantly cutting required search space 
particular traverse execution event stream incrementally derive events model event stream consulting model 
model execution stream match model stream simply mirror execution stream 
match method searches model need employed find minimum cost set inserted deleted events execution stream changed continue match model 
matched inserted deleted events describe exactly model stream induced model metric uses 
resulting approach implies state space search uses heuristics control state explosion 
states space just states process model state space include position event execution stream currently examined operation match insertion deletion led state 
having attributes method calculating state costs means search space tree process model state space 
shows partial view search space matching string fsm 
search states labeled fsm state position string operation match insertion deletion token type created search state 
bold search states represent lowest cost path assuming deletion weighted insertion 
lowest cost path deletes token resulting model string aba closest string abba 
insertion weighted deletion model string closest inserting single cheaper deleting single acm transactions software engineering methodology vol 
april 
cook wolf fig 

state fsm model partial search tree attempting match string abba 
obvious candidate approach best search 
standard depth breadth searches tree states exhaustive single dimension best search heuristic driven search determines search path lowest cost paths state space 
state parent cost estimated cost cost estimate start state goal state 
words total estimated cost known cost getting start state plus new known cost getting parent new state plus estimate cost getting goal state heuristic estimating cost going goal state best search uses priority queue states evaluated evaluates lowest cost state priority queue 
reaches goal state go iteration states sure goal lower cost goal 
method guaranteed find minimum cost solution heuristic estimator proven underestimate true cost rich 
true goal lowest cost goal 
adding estimations cost goal state method referred uniform cost finds lowest cost goal 
unfortunately underestimating true cost includes uniform cost guarantees state lower cost goal inspected 
trying calculate minimum cost distance metrics natural metrics assign actual costs states acm transactions software engineering methodology vol 
april 
software process validation state search 
fact metrics actual costs order guarantee minimizing correct function 
question estimate cost reaching goal remains 
goal state validation defined state matching deleting event execution event stream 
want define goal state state contains termination state process model flexible allow validation incomplete process executions 
ssd nsd metrics normalized respect length event stream position event stream factored cost assigned state 
say estimated total cost reaching goal state just value ssd nsd metric calculated far cost current state 
assumes event stream processed far representative total stream metric calculation greatly change 
heuristic estimator cost metric underestimate goal state cost guaranteed find minimum cost goal 
particular state may continual matches zero cost stream allowing distance metric diminish zero length increases 
trying construct complex estimator tailored identifying anomalous cases counterproductive 
reliable estimator practice seen case minimum cost goal reached 
pruning technique pruning state space proven useful reducing cost finding low cost goal rich 
pruning discards portions state space look unpromising 
pruning guarantee lowest cost goal 
domains game playing smart pruning negligible effects outcome search dramatically reducing search costs 
pruning takes forms vastly different methods heuristics 
heuristic employ discard newly generated state estimated cost higher threshold relative current best looking state 
refer cost pruning 
hypotheses cost pruning estimated costs fairly accurate predictable state actual cost vastly better estimate 
additionally cost pruning assumes set single threshold state space threshold consistently 
initial observations show variability costs assigned states change time especially larger variability 
pruning method set threshold fraction current standard deviation state costs 
lets threshold account variability state space search 
pruning method employ discard state specified distance execution event stream current acm transactions software engineering methodology vol 
april 
cook wolf fig 

search tree position pruning 
farthest state 
refer position pruning heuristic assumes paths lowest cost goal state examined interleaved fashion costs fluctuate widely paths expanded close 
unexamined state far specified position pruning parameter event stream ignored path goal state 
example state th event event stream furthest stream position pruning parameter set unexamined states events previous st event discarded 
shows effect position pruning small search tree 
open searched states leaves furthest state discarded parent states children discarded 
narrows search space resulting direct linear state paths areas state space searched 
experience pruning shown position pruning consistently performs model event stream derivation problem cost pruning highly variable poor performance 
studied pruning methods extensively detailed discussion acm transactions software engineering methodology vol 
april 
software process validation scope article 
refer reader information cook 

validation industrial case study performed case study industrial software process cook 
goal study statistically identify process behaviors correlated successful unsuccessful executions process 
component study involved validation techniques 
section review study example application process validation real world setting 
study focused change request process large telecommunications software system 
process customer reports problem problem assigned developer developer completes tests fix fix sent customer 
successful execution process results fix accepted customer unsuccessful execution results fix rejected 
existing formal model process documentation informal knowledge existed able create 
addition data analysis techniques employed discover possible model fragments data cook wolf 
depicts state machine model process 
able obtain data executions process extracting events historical archives merging form complete execution streams 
archives included source code control system modification request tracking system customer response database loose leaf binders code inspection reports 
streams divided populations success fix accepted streams fix rejected streams 
table iii shows validation metrics calculated case study statistical test significant difference populations wilcoxon rank sum test shown column 
columns values column means standard deviations metric populations 
general process execution highly variable somewhat behavior matching model 
equal insertion deletion weights nsd metric showed statistically significant differences successful accepted fix unsuccessful rejected fix process executions ssd metric 
looking components metrics see insertions significant weakly 
detailed information provided validation techniques event type matched inserted deleted model state operation applied able localize statistical differences populations terms model differences appeared specific type acm transactions software engineering methodology vol 
april 
cook wolf measure fig 

process model case study 
table iii 
validation metrics calculated case study value tailed sig test accept pop 
reject pop 
mean std dev mean std dev ssd nsd matches insertions deletions insertion blocks deletion blocks events 
shaded states locations model 
difference relative amount events matched shaded state inserted deleted statistically significant accepted fix rejected fix populations 
study accepted fix population matches followed process model closely 
analysis study shows power information validation methods provide gross metric nsd acm transactions software engineering methodology vol 
april 
software process validation indicates problem detailed information available lets perform depth analysis directly seeing process breaking 
results led suggestions process adjustments useful 

related related area process improvement uses data characterize processes uses data process validation activity try deduce problems process looking defect data products 
specifically statistically analyze change data effort data determine behavior process 
example see ripple effects interface changes high percentages fix fix changes 
garg employ manual process history analysis context creating validating domain specific process models software toolkits 
rez propose methods evaluating congruence process models 
congruence measure environment accommodate process model tools activities environment 
effort predict specific process fit environment model followed deployed 
cugola define formal framework reasoning inconsistencies deviations process 
approach directed processes controlled process support system enacted model 
goal enable systems allow coordinate resolve deviations model 
respect similar data derived process execution measure deviations 
feel effectively complements approaches process improvement raising confidence correspondence formal models executions processes 
event data compare execution formal model relates distributed debugging history checking 
bates uses event behavioral abstraction characterize behavior programs 
attempts match event data model regular expressions 
marks points data model match attempting provide aggregate measures disparity 
cuny build bates attempting deal large amounts event data providing query mechanisms event acm transactions software engineering methodology vol 
april 
cook wolf fig 

user interface validation tool 
relationships 
assume problem event stream trying locate problem 
describe method tool compare execution history temporal logic specification decide correctness execution respect model 
goal quantify discrepancies take pragmatic approach correctness 
developed metric oriented techniques process validation linear distance measure terms event insertions deletions nonlinear distance measure takes account size discrepancies 
metrics independent specific behavioral process modeling paradigm wide applicability 
process validation techniques implemented part balboa process data analysis framework cook wolf 
current implementation works finite state machine models processes 
user interface selecting execution streams process models viewing results process validation shown 
upper portion window provides quantitative view validation results levels detail counts individual insertions deletions counts blocks insertions deletions acm transactions software engineering methodology vol 
april 
calculated distance measurements 
left results summary parameters control metrics calculations 
lower portion window provides scrollable visual summary detailed differences process executed process predicted 
extra events execution stream highlighted color shown dark gray bands missing events execution stream highlighted color shown light gray bands 
directions process validation take including identifying additional properties process models exploited performing validation example points model fix execution stream ignore previous behavior help reduce search cost large model 
similar concept trace change points eckert nutt 
matching attributes model parameters events important direction vein 
developing improved techniques visualizing results validation example overlaying differences process model model event stream may help process engineer better understand problems process 
investigating analyses process executions process models example time oriented metrics derived area real time analysis schwartz useful extension execution stream analysis 
methods measuring efficiency process useful analysis method 
help optimization process behaviorally validated 
intend explore directions continue improving practicality usefulness process validation techniques experiment application industrial settings 
acknowledgments appreciate helpful comments provided skip ellis dennis heimbigner david rosenblum lawrence votta benjamin zorn 
software process validation aho peterson 
minimum distance error correcting parser context free languages 
siam comput 
dec 
avrunin buy corbett dillon wileden 
automated analysis concurrent systems constrained expression toolset 
ieee trans 
softw 
eng 
nov 
fuggetta ghezzi 
software process model evolution spade environment 
ieee trans 
softw 
eng 
dec 
fuggetta ghezzi 
spade environment software process analysis design enactment 
software process modelling acm transactions software engineering methodology vol 
april 
cook wolf technology finkelstein kramer nuseibeh eds 
research studies press advanced software development series 
research studies press uk 
bates 
debugging heterogeneous distributed systems event models behavior 
sigplan 
jan 
ben shaul kaiser 
paradigm decentralized process modeling realization oz environment 
proceedings th international conference software engineering may 
ieee computer society press los alamitos ca 
halliday brown chillarege 
case study software process improvement development 
ieee trans 
softw 
eng 
dec 
perry votta 
prototyping process monitoring experiment 
ieee trans 
softw 
eng 
oct 
burch clarke mcmillan dill hwang 
symbolic model checking states 
inf 
comput 
june 

evaluating software design processes analyzing change data time 
ieee trans 
softw 
eng 
july 
cook 
process discovery validation event data analysis 
tech 
rep cu cs 
department computer science university colorado boulder boulder cook wolf 
metrics process validation 
proceedings rd international conference software process oct 
ieee computer society press los alamitos ca 
cook wolf 
balboa framework event process data analysis 
proceedings th international conference software process june 
international software process assoc 
cook wolf 
discovering models software processes event data 
acm trans 
softw 
eng 
methodol 
july 
cook wolf 
event detection concurrency 
proceedings th acm sigsoft symposium foundations software engineering nov 
acm press new york ny 
cook votta wolf 
cost effective analysis place software processes 
ieee trans 
softw 
eng 
aug 
cugola di fuggetta ghezzi 
framework formalizing inconsistencies deviations human centered systems 
acm trans 
softw 
eng 
methodol 
july 
cuny forman hough kundu lin snyder stemple 
debugger scalable application event abstraction 
proceedings acm onr workshop parallel distributed debugging san diego ca may miller mcdowell eds 
acm press new york ny 
devore 
probability statistics engineering sciences 
rd ed 
brooks cole publishing pacific grove ca 
dillon avrunin wileden 
constrained expressions broad applicability analysis methods distributed software systems 
acm trans 
program 
lang 
syst 
july 
du chang 
model fast algorithm multiple errors spelling correction 
acta inf 
june 
eckert nutt 
trace extrapolation parallel programs shared memory multiprocessors 
tech 
rep tr cu cs 
department computer science university colorado boulder boulder ellis keddara rozenberg 
dynamic change workflow systems 
proceedings conference organizational computing systems milpitas ca aug ellis eds 
acm press new york ny 
emmerich finkelstein 
world machine critical perspective process technology 
workshop research direction process technology nancy france 
acm transactions software engineering methodology vol 
april 
software process validation eppstein 
sequence comparison mixed convex concave costs 
alg 
mar 

validating real time systems history checking trio specifications 
proceedings th international conference software engineering icse melbourne australia may montgomery ed 
acm press new york ny 
mandrioli 
proving properties real time systems logical specifications petri net models 
ieee trans 
softw 
eng 
feb 
fischer 
simple fast effective ll error repair algorithm 
acta inf 
apr 
garg jazayeri 
process centered software engineering environments grand tour 
software process fuggetta wolf eds 
trends software vol 

john wiley sons chichester uk 
garg jazayeri 
meta process software reuse process discovery evolution 
proceedings th international workshop software reuse nov 
grudin 
groupware cooperative problems prospects 
art human computer interface design laurel ed 
addison wesley reading ma 

evaluation nets 
proceedings nd european workshop software process technology 
lecture notes computer science vol 

springer verlag berlin germany 
harel naamad pnueli sherman 
statemate 
proceedings th international conference software engineering singapore apr nam ed 
ieee computer society press los alamitos ca 
conradi 
techniques process model evolution epos 
ieee trans 
softw 
eng 
dec 
jensen 
coloured petri nets 
petri nets central models properties bad sept brauer reisig rozenberg eds 
lecture notes computer science vol 

springer verlag berlin germany 
kashyap 
noisy substring matching problem 
ieee trans 
softw 
eng 

kellner feiler finkelstein katayama osterweil rombach 
software process modeling example problem 
proceedings th international software process workshop oct 

knight myers 
approximate regular expression pattern matching concave gap penalties 
algorithmica 
krishnamurthy rosenblum 
yeast general purpose event action system 
ieee trans 
softw 
eng 
oct 
kruskal 
overview sequence comparison 
time warps string edits macromolecules theory practice sequence comparison sankoff kruskal eds 
addison wesley reading ma 
leblanc robbins 
event driven monitoring distributed programs 
proceedings th international conference distributed computing systems may 
ieee computer society washington dc 
myers miller 
approximate matching regular expressions 
bull 
math 
bio 

rez el 
system evaluating congruence software process models 
tech 
rep se 
mcgill university montreal canada 
rich 
artificial intelligence 
mcgraw hill new york ny 

methods automatic construction error correcting parsers 
acta inf 

schneider lim 
utilization fuzzy sets recognition imperfect strings 
fuzzy sets syst 
aug 
acm transactions software engineering methodology vol 
april 
cook wolf schwartz melliar smith vogt 
interval logic higher level temporal reasoning 
proceedings nd acm symposium principles distributed computing aug 
acm press new york ny 
selby porter schmidt 
metric driven analysis feedback systems enabling empirically guided software development 
proceedings th international conference software engineering icse austin tx may 
ieee computer society press los alamitos ca 
sutton jr 
manual activities automated process programs 
proceedings th international software process workshop oct 
ieee computer society press los alamitos ca 
sutton jr osterweil heimbigner 
appl language software process programming 
acm trans 
softw 
eng 
methodol 
july 
waterman 
general methods sequence comparison 
bull 
math 
bio 

wolf rosenblum 
study software process data capture analysis 
proceedings nd international conference software process feb mar 
ieee computer society press los alamitos ca 
wolf rosenblum 
process centered environments support environment centered processes 
proceedings th international software process workshop mar 
ieee computer society press los alamitos ca 
received may revised december october accepted december acm transactions software engineering methodology vol 
april 
