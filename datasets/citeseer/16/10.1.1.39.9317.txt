process discovery validation event data analysis jonathan cook software engineering research laboratory department computer science university colorado boulder usa cs colorado edu university colorado department computer science technical report cu cs november fl jonathan cook supported part national science foundation ccr air force material command rome laboratory advanced research projects agency contract number 
content information necessarily reflect position policy government official endorsement inferred 
process discovery validation event data analysis jonathan cook case western reserve university case western reserve university thesis submitted faculty graduate school university colorado partial fulfillment requirements degree doctor philosophy department computer science software process organization goes developing maintaining software system 
methodology employed people machines tools artifacts create product 
applied formal modeling software process hope benefits unambiguous analyzable formalisms 
industry slow adopt formal model technologies 
reasons costly develop formal model developed methods ensure model reflects reality 
thesis develops techniques process event data analysis help solve problems termed process discovery process validation 
process discovery event data captured going process generate formal model process behavior 
results field grammar inference applied new method developed 
methods shown efficient practical interactive tool developed course 
process validation event data measure correspondence existing process models actual process allowing discrepancies exist 
paradigm string distance metrics developed validation metrics paradigm described 
metrics calculated shown tool set doing process validation provided 
implementing methods framework developed called balboa managing process data facilitating construction analysis tools 
framework serves unite variety collection mechanisms tools providing consistent data manipulation management access services assistance tool construction 
techniques developed thesis applied industrial study 
study provides concrete results showing relate quality process prescribed model quality product 
doing shows discovery validation techniques able capture important aspects software process applied real world 
dedication dedicate thesis brown trout south south park rainbow trout fork just springs trout spruce lake rocky mountain national park brook trout lefthand reservoir way near indian peaks 
see tell said 
advisor alexander wolf guiding thesis direction academic professional growth 
mentoring am 
goes family especially wife put odd things stresses go pursuing ph degree 
goes cs students stay university colorado memorable 
especially david johnson early years andr van der hoek years making sure day 
described chapter performed part visiting researcher bell laboratories lucent technologies 
dr larry votta guidance study organization lucent technologies giving access projects data 
david christiansen donna lockwood michael carol ferguson patient requests information 
certainly taxpayers united states america supporting studies national science foundation ccr advanced research projects agency 
hope investment worthwhile 
vii contents basic terminology tour software process research modeling execution improvement measurement process research thesis problem formal process models solutions approaches scope thesis validating results contributions road map framework events relating models events event sites event domains event data collection noisy data big picture motivating scenario process discovery related process problem statement approach grammar inference formal definition ix complexity results practical inference techniques statistical model inference techniques inference neural nets limitations grammar inference methods process discovery rnet ktail markov example discovery methods implementation discovery tools evaluation discovery methods handling concurrency summary discovery process validation discussion background related process related event validation metrics recognition metric simple string distance metric non linear string distance metric example metrics extensions metrics extensions weighting model usability enhancements producing process model event stream related solving model stream generation problem pruning implementing validation methods validation engine implementation validation engine evaluation validation metrics summary process validation system framework process analysis motivation balboa system framework data management interface balboa management message interface specifying event maps data management tools balboa data collection interface client interface balboa messaging interface interface tcl tk interface case study balboa discussion experimental design overview subject process sources data methods analysis comparing executing prescribed processes threats validity results aggregate metrics correspondence metrics summary evaluation summary results evaluation validation discovery methods applications process discovery process validation systems trace data process discovery process validation balboa framework xi chapter software process research relatively young field focussed rightly methods paradigms modeling implementing processes 
serious efforts apply analyze processes process models 
just software construction longer art engineering matured point common practice collect analyze data software products software process follow course research applied necessary collect analyze data software processes 
thesis step direction specifically contributing important analysis methods providing depth statistical study validates methods begins show evidence process affects product developing framework analysis methods developed 
basic terminology software process organization goes developing maintaining software system 
includes people machines resources tools artifacts involved producing software system 
process description sort written description intended predicted behavior process 
process model process description formal language 
formal mean mathematically unambiguous add requirement executable sense model provides rigorous specification dynamic behavior process 
process execution instance doing process time set people machines resources working software system process execution takes place 
sense process organization thinks doing formal model description organization doing execution really doing 
tour software process research order set stage thesis background software process research application 
divide software process research main areas modeling execution improvement measurement describe turn 
modeling modeling research includes formulation languages paradigms formally describing software processes 
paradigms formal process modeling include programming graph control state machines petri nets rulebased planning 
huff gives overview modeling languages 
paradigm strengths weaknesses rule model able easily incorporate exceptions behavior able give process engineer picture model behavior graph model exactly opposite allowing easy human understanding elegantly modeling rigid control flow structures processes 
process models mainly things process execution enactment described formal analyses deadlock detection resource usage conflict detection simulation traditional system analysis goals 
modeling research include definition canonical process models focus formal modeling described 
canonical models tend specific attempt give framework specific activities 
representative examples include waterfall model prototyping risk spiral model cleanroom process model 
canonical models involve specific sub processes analysis design testing 
code inspections design reviews studied formalized sub processes 
vein includes sa sd booch object oriented design regression testing 
execution execution research involved creating process execution environments formal executable process model drives activities take place environment 
area application continuation modeling efforts 
sense closely related workflow try model drive type order activities 
area includes environments process programming rule systems marvel formalism environments petri net spade 
garg jazayeri give overview process centered environments issues 
environments take approach providing developer agenda tasks done giving control task execution developer 
task selected executed completed process engine advances process model program decides new tasks instantiated places corresponding developers agendas 
additionally model reaches state set steps done automatically process execution environments take perform necessary steps 
hope reduces humans lessens chance human error process 
research workflow shown need allow exceptions process process execution environments weakest require strict adherence process model 
problem worse execution requires organization model process front introduces problems model evolves 
improvement improvement efforts classified industry efforts define specific quality measurements group software process define specific goals improving process 
notable efforts sei capability maturity model cmm necessarily specific software includes iso certification quality award 
european initiative centered augmenting iso process 
cmm rates goodness process providing checklist activities processes include provides path maturing process adding activities 
iso certification basically states organization written process follow process 
specify steps process contains 
award focussed quality control methods 
improvement efforts received industry evidenced ibm dec having special issue technical journals process improvement 
organizations especially government related taken keen interest certified certain rating cmm iso evidence leads better products 
new effort humphrey personal software process psp directed improving software engineering process level individual 
centered getting software engineer track analyze defect data give individual understanding personal process affect quality 
unfortunately overlap industry efforts formal modeling execution efforts 
reason improvement efforts offer stepwise approach invest heavily front apply formal model technologies 
measurement measurement efforts begun limited nature 
efforts product measurements infer process qualities defect production change data product measurements 
efforts trying measurements help characterize process example wolf rosenblum collected event data temporal visualization analysis votta perry actual measurements define parameters queueing model process :10.1.1.116.7561
body looked experimental measurement specific process techniques 
example detailed study code inspections votta porter 
experimental setting determine actual effects code inspections quality product 
example shows process exceptions correlate defects product 
special issue ieee software theme measurement process improvement articles dealt questionnaire improvement articles reporting statistical experimental improvement 
articles concerned formal models apply 
process research seen background easily categorized divisions 
unfortunately separation beneficial widespread application process research 
industry example focussed heavily improvement efforts ignoring modeling execution 
measurement efforts taken advantage formal modeling research 
needed combines areas comprehensive process analysis improvement techniques 
example tools process data process models quantitatively qualitatively understand process research applying process modeling technologies industry improvement efforts contribute unifying areas process research 
clear order combine areas methods tools provide feedback path process execution data collection process modeling analysis constructed 
overview process research seen analysis process data conjunction formal models useful addition ongoing process research facilitate migration ideas research industrial domain 
thesis section details specific problems thesis solves approach solutions scope contributions thesis software process research specific computer science general 
problem formal process models shown efforts put forth rigorously model software processes order gain understanding process able analyze model desirable properties 
problems hampered widespread application efforts 
creating process model understanding current process difficult time consuming expensive 

ensuring ongoing process execution follows degree desired process embodied model troublesome best impossible worst 
currently create model process typical approach interview people involved spend time observing process read existing process documentation translate formal model 
method expensive time consuming example organization spent dollars process definition formalized 
presents high cost barrier want need formal model technologies improve control process 
irony project exhibits problems benefit technologies managers may willing able invest resources new methods tools 
providing methods support engineer understanding current process building process model lower barrier spread process technologies 
regarding second problem measure close process model execution agrees attempted today support tools 
common way interview people questionnaires determine process problem data weak partially quantitative passed interpretation step representing people remembered thought different happened 
confidence accuracy practitioners hesitant invest effort defining model critical decisions model 
giving process engineers quantitative assurance model fact reflect reality application formal models analyses software process realm 
solutions solution problems data analysis techniques conjunction formal process models 
specifically target analysis event data describes sequencing activity process execution solve problems 
state thesis parts reflecting problems personal communication industrial process engineer 

understanding process currently happening difficult 
event data process executions discover models software process 
lowers effort needed create formal process models 

people follow formal process model exactly 
methods devised measure correspondence formal process model process execution recorded event data 
methods enable realistic application process modeling 
call process discovery process validation respectively 
process discovery act devising suitable model process execution set executions 
process validation act determining level correspondence executing process process model 
thesis shows methods process discovery validation realized solve real world problems associated software process 
additionally constructed general framework process data analysis tools called balboa discovery validation methods reside 
approaches process discovery cast problem grammar inference apply methods previously developed area process discovery extending implementation theoretically extending implementing scratch 
invented new method process discovery general grammar inference inherently able handle noisy data faster techniques applied 
grammar inference methods assume sequential process discuss results relate concurrent processes extensions able help discover concurrency process execution 
process validation paradigm devised viewing problem string distance measure 
manner devised metrics capture correspondence process execution process model terms functions string distance measures 
computing distance strings process executions straightforward computing distance process execution process model hard problem 
thesis implemented efficient heuristic method calculating distance show output close global optimum distance calculation 
method assume specific modeling formalism extensible modeling formalism plugged 
building discovery validation tools called discovery validation respectively took step back devised framework called balboa provides easy construction process data analysis tools helps manage process data collections 
framework allow rapid construction process analysis tools enable integration multiple data collection methods single environment 
scope thesis event data scope thesis behavioral analysis sense looking sequencing actions process 
look real time issues behavioral realm correctness artifacts actors associated actions 
see analysis techniques applicable behavior validated 
concerned static aspects process consistency relationships artifacts performance roles valid actors 
analyses closely related areas database research studied depth 
validating results undertook extensive industrial study order validate methods thesis 
show methods fact capture important aspects software process process discovery validation real world setting 
addition showed greater process deviations measured validation methods positively correlated product defect metric validation methods show specific areas process model may responsible defect production 
validation methods applied model discovered data results showed discovery methods captured important process patterns 
model validation methods able statistically differentiate processes rest 
contributions summary contributions thesis follows particular ffl applied previously developed discovery techniques domain software process extended techniques ffl invented implemented new promising technique process discovery ffl devised paradigm process validation defined quantitative metrics paradigm ffl proposed implemented efficient method computing process validation metrics ffl verified extensive real world study discovery validation techniques applicable usable real world software process ffl proposed implemented extensible framework manages process data provides uniform platform creating process data analysis tools 
additionally techniques developed thesis applicable broader scope just software process 
areas characterize system execution event data called trace data potentially benefit process discovery techniques system behavior verified representation system process validation methods applied 
example reengineering message system discovery techniques help understanding message protocol modules verifying implementation specification behavior validation techniques measure closely implementation matches specification provide information parts system 
road map thesis organization ffl chapter describes justifies framework thesis constructed 
framework event data capture behavior process executions techniques discover models behavior event data comparing event data model validation 
motivating scenario process discovery validation concludes chapter 
ffl chapter presents process discovery methods 
methods ranging purely statistical neural net purely algorithmic compared 
neural net method prohibitively slow complicated methods prove practical problem process discovery fast interactive visual tool 
performance analysis methods 
ffl chapter presents process validation 
paradigm quantitative validation described 
paradigm views comparing process executions process models string distance problem formulas specific metrics paradigm 
problem computing metrics discussed model generic method implementation described efficiently computing metrics 
performance analysis methods 
ffl chapter describes system built framework process data analysis tools discovery validation tools exist general foundation process analysis tools built 
framework client server architecture analysis tools clients request data meta data server manages data collections 
ffl chapter presents industrial process study discovery validation tools 
study provides strong evidence methods devised thesis applicable real software engineering practices 
study show distinct relationship process product provide evidence formal model technologies improve software process 
ffl chapter concludes closing thoughts look applying techniques domains software process directions take thesis 
chapter framework foundation thesis rests view processes sequence actions performed agents human automaton possibly working concurrently 
decidedly behavioral view processes interested dynamic activity displayed processes say static roles responsibilities agents static relationships components products 
mean aspects process worthy study just issues chosen investigate having behavior structure 
chapter details definitions important terms discusses framework type data thesis analyses built 
events wolf rosenblum event model process actions event characterize dynamic behavior process terms identifiable instantaneous actions invoking development tool deciding activity performed :10.1.1.116.7561
instantaneous relative time granularity needed desired certain activities short duration relative analyses done represented single event 
activity spanning period time represented interval events 
example meeting represented meeting event meeting event pair 
similarly module compilation submitted batch queue represented events enter queue compilation compilation 
purposes maintaining information action events typed attributes attribute time event occurred 
generally event attributes items user artifact associated event result values pass fail code inspection errors errors compilation values give detail specific occurrence event type 
overlapping activities process represented sequence events model events collected events execution events venn diagram event types 
refer event stream 
simplicity assume single event stream represents execution process depending collection method organization assumption may violated 
event data characterize behavior widely accepted areas software engineering program visualization concurrent system analysis distributed debugging 
feel applicable software process 
relating models events event sites thesis focus behavior formalisms process modeling languages 
examples petri net foundation slang state machines statecharts 
viewing process execution part event stream assuming process model way producing event stream executed 
way relate process execution process model events analyses constructed 
reason put dependency modeling formalism able places behavior specific event produced 
call places event sites 
state machine example state transitions event sites transition labeled event produces 
petri net naturally transitions event sites firing sequence mapping event stream 
reality dependency constraining practically speaking modeling languages augmented event sites 
event sites typed produce event specific type event 
event type set event sites process model produce 
event domains distinction process model process execution really universes event types 
universe set event types associated model process set event types associated execution process 
expect high degree overlap sets general equivalent 
relationship depicted 
example consider project executes process performs occasional code inspections part process formal model process account activity 
conversely model adapted project include subprocess design reviews current project may 
third set event types set event types collected data shown 
set necessarily subset execution events record done viewed window actual process execution 
window may show execution activities event data collected 
reasons occur obvious reasons data particular event type considered inconsequential data considered expensive collect 
instance events occur computer expensive collect events occur computer require manual opposed automated collection techniques 
process validation purposes means part model overlaps collected events validated process discovery implies portion potential model inferred 
event data collection techniques process validation discovery clearly depend ability collect data executing process address topic thesis variety methods collecting process execution data devised ffl basili weiss describe method manual forms collection data evaluating comparing software development methods 
methods place creating system manual event data collection 
ffl selby built system amadeus automated collection analysis process metrics 
acts event monitor allowing triggering actions certain events 
simply collect events event stream 
ffl wolf rosenblum hybrid manual automated collection methods collect event data build process :10.1.1.116.7561
ffl provided user menu tool collects sampled task state information 
help ease burden collecting computer manual events 
ffl krishnamurthy rosenblum built system event monitor yeast record events occur computer react events 
provides functionality reporting type computer event 
ffl krishnamurthy describe process enactment system alternatively collect event data 
system watching events matching events contexts current state process 
lacking process model infrastructure simply collect event data 
process enactment systems oz spade easily instrumented collect event data 
process integration components likewise natural focal point instrumentation 
software engineering environments process supply event data relatively easily message systems field provide natural framework collect data system activities 
existing tools developers naturally provide event data collection 
example configuration management systems provide history actions taken artifact control organizations house tools problem tracking systems track development maintenance activity 
existing sources merged provide comprehensive tool event history process 
non system data collection sort manual recording component systems described allow method recording announcing information collector 
example announce mechanism yeast collect data meeting phone communication events 
noisy data address issue data integrity thesis 
assume prior application analyses data necessary clean possible 
say anomalous noise data eliminated possible 
eliminating noise general concern begins collection methods continues possible consistency analyses data 
assume data correct events collected occurred consistent events activity corresponding event methods developed thesis take account presence noise data offer techniques dealing 
big picture framework formulation process discovery process validation shown 
centered event data collected process collection executing process event event event event event event event data validation discovery process model human guidance measurements process model analysis techniques process validation discovery 
execution validation additionally existing process model discovery human guidance form tuning accuracy parameters algorithms model patterns 
framework allows analysis methods devised event data shown 
motivating scenario motivating example methods applied consider development group building large piece software 
system far integration build week including additions changes completed point 
group feels getting errors system integration build looking errors point product specification design causing 
decide detailed look process order 
point relied informal textual document described process 
group decides balboa help examination process engineer coordinate perform examination 
step process engineer instrument site data collection 
engineer uses yeast watch directory structure file modifications output events 
engineer wraps basic commands shell scripts record command event execute command 
process engineer adds email repository account cc communicating project adds simple utility program allow people record phone communication events events meetings inspections reviews 
infrastructure place process engineer collects data week cycle process 
point process engineer data collecting week worth data 
process engineer continue collecting automatically generated data ask group record events 
way know intrusiveness data collection short time 
little processing event data process engineer collected put single event stream common format having fields event type time date generating user receiving user products files involved 
process engineer knows developer works relatively independently discovery experiments engineer tries involve discovering individual processes 
engineer extracts event stream just events generated single person 
process engineer person 
extracted event streams discovery discover model person process 
doing people making minute changes regression testing piece working re start regression testing 
felt causing integration problems 
second view process process engineer extracts event stream just events pertaining single product 
process engineer products process engineer feels central give experimental mix 
discovery see process product goes including checked modified read checked 
analysis seen products checked read checked modified 
read version changes locked version 
group thought rules rcs specified strict lock modifying files reading informal process specification see ambiguity 
problems identified lax regression testing components nonstrict rcs process engineer goes fixing process 
pieces discovery created process engineer refines discovered models complete models validation validate process 
process engineer publishes report discovery process discovery tool 
validation process validation tool 
project group detailing findings recommendations 
group agrees changes enforced 
changes process followed process engineer continues collect automatic data extra computer events central problems process engineer trying fix moment 
week data process engineer uses validation compare new process execution model process engineer desired process 
process engineer finds correspondence detailed look regression testing finds stricter testing process group 
integration build subsequent ones number errors decreased dramatically 
chapter process discovery issues managing improving process developing maintaining software come forefront software engineering research 
response new methods tools supporting various aspects software process devised 
technologies including process automation process analysis process evolution assume existence sort formal model process order technologies applied 
need develop formal model prerequisite new technology daunting prospect managers large going projects 
irony project exhibits problems benefit process technologies managers may willing able invest resources new methods tools 
intend help going projects promoting technologies formal models seriously consider lower entry barriers technologies 
vein explored methods automatically deriving usable formal model process basic event data collected process 
term form data analysis process discovery inherent project process known unknown bad stable erratic process model devised describe 
challenge process discovery data describe process form suitable formal model process technologies form allows engineer understand model process 
general difficult challenge meet 
scope problem somewhat concentrated efforts models behavioral aspects process example models relationships artifacts produced project models roles responsibilities agents process 
complete modeling activity address aspects process 
chapter techniques invented adapted process discovery 
range approach purely algorithmic purely statistical 
methods implemented set tools operating process data sets 
methods automated require guidance knowledgeable software processes somewhat familiar particular process study 
guidance comes form tuning parameters built methods selection application event data 
results produced methods initial models process refined process engineer 
initial models may lead changes data collection uncover greater detail particular aspects process 
discovery methods complement process engineer knowledge providing empirical analysis support experience intuition 
process discovery methods need applied goal creating formal model process 
methods process visualization tools discovering displaying patterns behavior process executions goal simply better understanding currently happening 
chapter proceeds follows 
section discusses related software process 
section gives statement discovery problem outlines approach solving 
section describes depth approach builds 
methods described illustrated simple example section 
methods complex significant example section 
section describes implementation section evaluates performance tools 
section talks problem concurrency 
conclude section summary results 
related process software process domain little deals techniques discovering process models current process execution behavior 
pieces related 
garg describe method explanation learning discover aspects fragments underlying process model process history data rules operations effects 
centers rule base goals derive generalized execution flow specific process history 
having rules showed complete correct process fragment generated execution data 

garg employ process history analysis human centered data validation analysis context meta process creating validating domain specific process software kits 
lines process post mortem analyze discussion changes process undergo cycle 

describe method eliciting process models currently executing processes 
method basically plan person enter development organization understand process describe process formal way 
notion automation tool support way 
discovery problem addressed depth 
techniques developed assisting process engineers discovering building evolving process models 
techniques look different types process data ultimately useful process model event data executing process collection inference event event event event event event process model inference framework 

example area data mining may useful techniques discovering software product relationships :10.1.1.40.6984
problem statement approach goals take trace process execution form event stream deduce partial formal models behavior process 
framework shown 
envision able deduce fully complete correct process models akin automatic programming successful 
aim provide process engineer formal description patterns behavior exist currently executing process seen collected execution event stream 
engineer information basis creating complete process model evolving existing model correcting aspects execution 
mentioned chapter assume event data collected executing process 
collected data viewed window execution 
general window show execution activities event data collected 
just data analysis technique results obtained discovery methods strongly depend content quality data collected 
seek data recurring patterns behavior 
purposes finite state machines fsms provide starting point expressing patterns 
fsms may somewhat deficient prescribing software processes quite convenient sufficiently powerful describing historical patterns actual behavior 
thesis formal description finite state machines 
background long 
term fsm refer nondeterministic transition labeled state machines 
choose expressive representation finite state machines pushdown automata 
reason powerful representation complex discovery problem clear need power 
particular aiming infer structure behavior values controlling structure 
methods discover pattern canonical example demonstrates superior power push automata certainly discover describe sequenced looping structure loop followed loop 
additionally clear migration paths fsms modeling paradigms push automata specialized 
drawback fsms inherent ability model concurrency address issue section 
develop initial set methods cast process discovery problem terms previously investigated fsm discovery problem 
problem discovery grammar regular language example sentences language 
area research historically uses term grammar inference problem 
interprets events tokens event streams sentences language process natural fit areas seen 
important differences discuss section 
techniques state machine inference applied diverse areas dna rna protein understanding speech text recognition scientific sequence data 
historical reason believe techniques applicable software process discovery 
grammar inference section formal definition problem grammar inference theoretical complexities detailed look field applicable process discovery problem 
formal definition grammar inference problem usually informally stated sample sentences language sentences specifically language infer grammar represents desired language 
grammar 
occam razor suggest smallest grammar includes sentences language excludes sentences language best measure complexity 
goal discovering presenting patterns event stream engineer lead say smallest grammar sense easiest engineer 
see definition problematic 
formally define problem terms 
sigma alphabet tokens sigma possible sequences sentences sigma 
define language ae sigma subset sentences sigma grammar formalism class regular context free describes said class languages 
presentation consistent field 
sigma interesting language 
define theta infinite set pairs hs li sigma theta 
theta just sigma tagged sequence belongs 
call sequence hs li positive negative 
pi defined possibly infinite set positive sequences gamma defined possibly infinite set negative sequences 
learning purposes algorithm needs presentation data 
complete presentation just presentation theta positive presentation just presentation pi negative presentation just presentation gamma note sets infinite algorithm presentation eliminate single sequence presentation 
partial presentation finite subset complete positive negative presentation 
grammar inference problem phrased presentation part theta infer grammar describing 
complexity results gold identification limit framework analyzing grammar inference problem 
identifying limit frames problem terms looking complete presentation theta finite presentation pairs theta algorithm guesses correctly change guess presentation continues algorithm said identify limit 
gold showed finding dfa minimum number states presentation theta np hard impossible just positive presentation pi 
problem positive examples algorithm way determine 
early result shows learning best grammar relatively simple classes regular languages difficult learning positive examples strictly weaker learning positive negative examples 
pac model learning concepts examples proposed valiant 
pac stands probably approximately correct may sound rigorous probably defined probability gamma ffi approximately defined gamma ffl correct solution 
polynomial time algorithm constructed learning problem likelihood ffi produces solution close ffl correct domain pac learnable 
classes boolean formulas decision trees geometric algebraic concepts shown pac learnable 
results grammars including dfas negative definite 
pitt reports dfas polynomially approximately predictable probabilistic polynomial time algorithm inverting rsa encryption function factoring blum integers deciding quadratic residues 
sequences infinite theoretical analysis assumes presentation finite sequences 
angluin phrases learning problem terms oracle 
algorithm fixed set queries oracle basic string accepted correct grammar grammar equivalent correct grammar 
active model learning different passive presentations algorithm certain amount control information receives uses just set data 
specifically algorithm ask questions elucidate conflicts grammar 
framework angluin gave polynomial time algorithm learning dfas extended classes languages 
describing computational complexities various learning paradigms classes languages formulas 
survey angluin smith broad look inductive inference learning 
pitt survey starting point understanding theoretical complexities involved learning regular grammars 
theoretical language learning 
angluin smith survey acknowledge gap theoretical results achieved practical application inference methods 
state significant open problem field specific technical question gap concrete results 
unfortunate results concrete results produced little significance narrow domains 
survey research efforts continued produce significant practical results discuss section 
practical inference techniques section survey previous devised practical algorithms grammar inference analysis real world problem domains 
class techniques represents common paradigm learning positive examples 
basic idea class build prefix tree machine input data sentence linear state transition sequence produces 
linear sequence starts start state shares states sequence diverges example sentence 
machine tree root start state state transition point example sentences longer share prefix 
set data covers language examples behavior grammar language shown contained prefix tree machine 
machine merged rules final state machine output learned language 
examples ffl describe prefix tree method states merged previous contexts 
states entered length contexts merged 
ffl angluin merges states prefix tree notion reversibility restricts class languages algorithm infers 
reversible languages inferred near linear time higher values cause algorithm cubic length input 
ffl bierman feldman describe prefix tree method states merged length behaviors 
method directly described prefix tree merging fall class 
ffl carrasco oncina describe statistical method learning stochastic regular languages state merging prefix tree states merged statistical likelihood calculations 
running time maximally claim actual times near linear 
ffl castellanos apply method class learning natural language translators 
class techniques directed iteratively building regular expression sequences translating fsm necessary 
sense algorithms pass sequence find repetitive patterns replace occurrences regular expression start decided done 
examples ffl representative 
able construct fast algorithms learn restricted regular expressions 
restrictions place inferred regular expressions operator nesting limited fixed 
algorithm worst case cubic practice report near linear times 
extended handle noisy strings treating noise edit distance problem currently allow single token edit multi token gaps 
geared analyzing dna rna protein data 
ffl section describes method calls uv algorithm pass looks repetitions substrings chooses best candidate replaces expression pass started reduced string 
method adapted loops problems operator 
survey describes techniques inferring dfas positive samples general practical inference techniques 
statistical model inference techniques statistical models models languages incorporate notion likelihood sequence subsequence occurring language 
discovering statistical model provide user feedback relative probability discovered sequence patterns happening 
example discovering loop process iterate exit important user see 
methods explore thesis initially support statistical models background discuss methods extended direction 
hidden markov models hmms base representation statistical grammars 
hmms finite state machines token labeled transitions transition associated probability occurring source state 
additionally hmms usually defined allowing transitions transitions state produce token 
problem inferring hmms usually literature meant mean finding probabilities model structure 
widely algorithm forwardbackward algorithm known baum welch formula algorithm gradient descent method converges local maxima somewhat slow viterbi algorithm faster approximation 
inferring structure hmm 
usually problem inferring structure cast subproblem inferring probabilities transitions manner start fully connected model infer probabilities input data remove transitions threshold level probability 
practice approach time consuming practical requires assumption number states model 
level hmms stochastic context free grammars scfg 
scfg just cfg production rule associated probability firing 
hmms inferring scfg usually means inferring probabilities production rules 
inside outside algorithm widely algorithm doing 
algorithms mentioned parameter estimation hmms scfgs types expectation maximization algorithms 
gradient descent techniques find local maximum 
initializations important 
algorithms charniak book 
solve structure inference problem statistical models standard algorithmic techniques inferring fsm cfg applied finding structure known algorithms assign correct probabilities transitions production rules 
done pieces 
ffl prefix tree method fsm inference provide input hmm parameter estimation routine 
results show improvement parameter estimation fully connected model 
ffl anchez specific inference mechanism finds loop free automata provide model structure initial transition probabilities forward backward parameter estimation algorithm 
ffl chen describes corpus scfg inference method bayesian probabilities compares ngram models 
ffl provides transformation algorithm takes cfg translates cfg chomsky normal form required parameter estimation inside outside algorithm 
inference neural nets neural network community looked problem grammar inference positive samples 
representative field 
various methods consist defining recurrent network architecture analyzing hidden neuron activity discover states transitions resulting grammar 
difference methods inspect hidden neurons infer state information 
advanced techniques apply clustering neuron activations training help induce better statemachine behavior 
techniques somewhat controversial neural network researchers believe look net try learn concerned input output performance net 
thread research applicable investigations 
limitations grammar inference grammar inference methods look tokens language 
purposes means limited operating event types mapped tokens ignore potential information event attributes 
causal relationships event attributes deduced grammar inference techniques 
limitation methods generally support seeding algorithm pre known portions model grammar 
researcher know process study may able easily formulate portions desired model 
useful techniques take build discovering patterns surrounding portion 
final restriction methods assume single state machine 
typical process generally concurrent activities going produce event stream may non deterministic orderings events 
fact event stream interleaved executions process model separations executions done relating event attributes 
despite restrictions feel methods strong starting point providing techniques assist process engineer developing process model 
discuss problem discovering concurrent behavior section chapter 
methods process discovery section describe inference methods adapted invented process discovery 
methods represent points spectrum algorithmic statistical techniques 
dealing data collected process executions positive simple event stream example 
samples 
methods characterized method examine samples 

rnet method purely statistical neural network approach looks past behavior characterize state 
method extended implementation das 
extensions allow method handle event types theirs restricted enable easier extraction discovered model net 

ktail method purely algorithmic approach looks behavior compute possible current state 
modified theoretical description dependent multiple sequences extended allow handling noisy data 
addition added post analysis steps remove common overly complex constructs basic algorithm tends leave discovered model 
implementation scratch 

markov method hybrid statistical algorithmic approach looks neighboring past behavior define state 
method new method invented implemented solely 
positive samples target language definition discovered model section applied need negative samples determine bounds language 
purposes result discovery method distinctly identifies patterns sequencing selection iterations loops needlessly complicate patterns identified sensibly shares states applicable 
sense saying goodness eye case engineer methods 
purposely pursued methods naturally parameterized amount complexity allow inferred 
explain illustrate methods section simple event stream 
stream sentence token language sample input methods 
methods typically multiple samples refine results simple example just give stream shown 
course different fsms generate sentence 
important methods produce fsm model reflects structure inherent sample loops 
chapter graphical representations automatically generated dot directed graph drawing tool output discovery tools 
input layer hidden layer output layer standard recurrent neural network architectures 
section demonstrate methods complex example exposing relative performance possible strengths weaknesses method 
rnet method describe comes neural network community purely statistical approach inference 
developed method due das mozer 
refer rnet method 
standard feed forward neural network neurons split layers outputs neurons layer feeding forward neurons layer see 
typically layer input neurons layer internal hidden neurons layer output neurons 
input input neurons activation flows forward output neurons activated pattern 
network trained propagating difference actual desired outputs backwards network 
refer difference learning error 
basic architecture das mozer added recurrent connection feeds results hidden layer directly back input layer see 
lets network model fsm providing current state form activation pattern hidden layer input network 
output activity state determined just input current hidden neuron activity 
recurrent network inference mechanism rnet 
training takes form presenting window specified length network having attempt predict token 
learning error back propagated network window 
sliding window forward sample stream token time position stream training 
rnet takes historical view sample stream window focuses attention events precede current event 
network trained fsm representation extracted network 
done presenting different strings network observing activity hidden neurons 
activation patterns closely related clustered state 
transitions recorded noting current activation pattern input token activation pattern 
information collected input patterns represents fsm network inferred 
parameters rnet numerous varied realistic application rnet requires knowledge neural nets expected 
parameters ffl window size controls size locality learning ffl number hidden neurons net controls detailed information fsm net learn ffl weight recurrent connection respect forward connections controls importance history net ffl learning rate momentum control fast algorithm learns important previous direction learning ffl weight clustering method controls strongly net tries cluster similar states ffl number training iterations error threshold 
scope thesis evaluate full dimensions neural net provide meaningful assistance 
neural net practitioners refer art 
experience uses rnet behavior respect parameters learned extent 
experiments started implementation das 
restricted token languages implementation quite limited 
extended implementation allow token types enhanced output net easily extract complex models result having token types 
shows inferred fsm rnet produces example stream 
method successfully produces deterministic fsm incorporates loops 
models behavior stream loop loop 
shows neural network approach known perfect sample input direct produce machine just stream 
advantage rnet method statistical nature potential robust respect input stream noise collection errors abnormal process events 
fsm inferred rnet method example event stream 
disadvantages general slow training time required size net grows rapidly number token types expected size resulting model 
plethora tuning parameters lack guidelines setting drawback 
ktail method purely algorithmic biermann feldman 
original presentation formulated terms sample strings output values fsm strings 
formulation algorithm output values just operating sample strings 
addition method dependent having multiple strings enhanced algorithm reduce number states resulting fsm introduced threshold parameter dealing noisy data 
notion central ktail state defined behaviors occur 
history token string prefix current state reached history determined possible futures occur 
strings share common prefix diverge giving single history multiple futures 
defined tokens parameter algorithm 
different histories behaviors reside equivalence class equivalence classes represent states fsm 
equivalence class called nerode relation prefixes class extension ktail uses limit nerode relation fixed length 
additionally original definition biermann feldman looked length behavior string presumably interested large set short strings output function state machine 
define length behavior point input string independent requirements 
formally ktail defined follows 
set sample strings alphabet tokens strings set prefixes including full strings valid prefix subset strings delta prefix appended token string call tail 
set strings composed length 
equivalence class set prefixes delta 
delta means prefixes set tails length 
prefixes assigned equivalence class 
equivalence classes mapped states resulting fsm 
transitions states defined follows 
state equivalence class token destination states transitions set equivalence classes delta delta equivalence class prefix delta intuitively says define transitions take append calculate equivalence classes new prefixes destination states token state jdj transition exist jdj transition deterministic jdj transition nondeterministic 
transitions annotated token final fsm 
enhancements basic algorithm algorithm biermann feldman define stops 
produces fsm complete correct algorithm certain tendencies produce overly complicated fsm 
shows fsm produced algorithm sample data 
complexity loop data unrolled length unrolling arises algorithm sees change tail loop body exit point loop 
change causes iteration loop placed separate equivalence class 
consider loop 
loop represented path fsm 
iteration loop separate representation path 
similar effect occurs loop 
improve basic algorithm automatically merging states manner 
state transitions states token set output transition tokens states equivalent merge states intuitively procedure assumes transition paths state length transition internal states paths assumed tails length zero occur ends strings 
fsm inferred basic biermann feldman algorithm example event stream 
merged 
states merged states merged merged merged states merged 
improvement implemented ktail results cleaner fsm results basic biermann feldman algorithm 
fsm produced ktail example stream shown 
clearly ktail job discovering underlying loops behavior 
loop completely embodied transition path loop completely embodied path 
note point nondeterminism state occurrence algorithm sees different behaviors tails event sample data 
add ability ignoring noise data ktail method described 
assuming noise low frequency event sequences equivalence class members may interpreted place length futures erroneous 
decide equivalence class represent proper behavior throw away allowing appear state final fsm 
formulation suggests setting threshold size equivalence class terms number members pruning classes size 
pruned equivalence classes show resulting state machine potential fsm inferred ktail method example event stream 
transitions show 
pruning mechanism implemented ktail method 
evaluation ktail thresholds set necessarily produces fsm recognize sample input data 
position set input strings belongs equivalence class mapped state state machine 
equivalence classes share length subsequent behaviors transitions state guaranteed satisfy position set input strings equivalence class 
sequence equivalence classes positions input string production path fsm string 
merge states output behavior terms tokens output transitions accept resulting states transitions go transformation effect correctness resulting fsm 
possibly reduces number spurious states fsm contains 
threshold non zero guarantee correctness resulting fsm respect input data 
ktail controlled accuracy value greater value greater length prefix tails considered differentiation occur states transitions 
note increases algorithm monotonically adds states complexity resulting fsm 
long longest sample string resulting fsm guaranteed deterministic deterministic fsms result smaller values depending structure sample strings 
case interesting informative fsm result large generate deterministic fsm 
contrary points nondeterminism resulting fsm signify important decision points process decision determine path execution 
advantage ktail parameterized simple value complexity resulting fsm controlled straightforward manner 
disadvantage simple thresholding may tunable robust presence input stream noise 
markov third method invented hybrid algorithmic statistical techniques 
method uses concept markov models find probable event sequence productions algorithmically converts probabilities states state transitions 
method new previous similar methods 
example sequence probabilities create fsm recognizers protein sequences markov models predict center point new protein sequences 
discrete order markov model system restricted probabilistic process representation assumes ffl finite number states defined process ffl point time probability process state dependent previous state process markov property ffl state transition probabilities change time ffl initial state process defined probabilistically 
general definition th order markov model state transition probabilities depend states process 
basic idea markov method probabilities event sequences 
particular builds event sequence probability tables tallying occurrences subsequences 
tables produce fsm accepts sequences probabilities non zero generally exceed probability threshold parameter method 
markov proceeds steps 

event sequence probability tables constructed traversing event stream 
word process refer software process generic definition terminology markov models 
current version markov tool second order probability tables constructed 
version tool accept maximum order parameter 
aa ab ac ba bb bc ca cb cc table second order event sequence probability tables example event stream 
table shows second order probability tables event sequence 
instance third row second order table event sequence equally followed followed 
directed graph called event graph constructed probability tables method 
event type assigned vertex 
event sequence exceeds threshold probability uniquely labeled edge created element sequence immediately element sequence 
consider event sequence entry second order table 
threshold edges created vertex vertex vertex vertex 
previous step lead connected vertices imply event sequences illegal 
correct connected vertices split vertices 
consider vertex previous step edges exist sequence permissible connectivity zero probability see row second order table 
vertex split vertices having edge having edge 
avoids illegal sequence 
general definition step works finding disjoint sets input output edges vertex non zero sequence probability splitting vertex vertices sets 

event graph converted dual manner 
edge vertex marked edge unique label 
edge edge pair vertex edge created vertex corresponding edge vertex corresponding edge 
edge labeled event type 
vertex edges constructed edge labeled event graph connects vertex vertex fsm inferred markov method example event stream 
graph constructed step fsm 
fsm reduced techniques implemented markov tool merge nondeterministic transitions 
specifically markov produce states transition state annotated event nondeterminism useful states behaviors non conflicting 
nondeterministic transitions sense resolve conflict way 
nondeterministic transitions state destination states output transitions non conflicting accept disjoint set events states merged set nondeterministic transitions transition 
shows inferred fsm markov produces example stream 
ktail markov infers fsm exactly loops loop path loop path 
difference markov produces deterministic fsm 
notice existence interpreted start state fsm produced markov 
result single sample input begins token bayesian extension markov method markov uses frequencies event sequences directly tables forward probabilities sequences occurring 
argument bayesian probabilities reverse probabilities better 
frequencies directly probabilities affected occurrences events example second event event sequence occurs event stream frequency sequence high chance bayesian calculation account 
process event streams expect certain event types overwhelmingly populate event stream point markov seriously affected suspect forward bayesian probabilities radically different 
bayesian formulation provide better thresholding cutoff effects just forward probabilities 
implemented bayesian transformation markov selectable option 
transformation takes forward probability tables built standard markov method converts place law ajb bja note components right hand side forward probability tables 
bayesian probabilities replace forward probabilities markov looks probability sequence ab example bayesian probability 
intensively explored behavior thresholding seen radically different results regular markov date 
available users feel getting results firmly believe bayesian probabilities better 
evaluation markov thresholds set create fsm recognizes input streams behavior 
consider input stream subsequences length position length position markov order markov algorithm producing algorithm specifically includes production paths sequences length necessarily produced union produced induction proves setting thresholds defeats assurances resulting fsm completely model behavior markov robust presence noise event stream ktail method 
level robustness easily controlled process engineer probability threshold parameters 
parameters control complexity discovered model large amounts data ignoring low probability sequences result noise 
example discovery methods section show methods perform complex process simple example previous section 
example section taken process problem 
describe process fsm kellner statemate solution 
version shown 
idea see methods perform reproducing fsm discovering process 
schedule tasks modify design modify code modify test package test unit start schedule modify design comm ccb order modify design comm modify code schedule modify code comm schedule modify test package modify test plans comm module change complete comm done review design mod design comm design ok comm design ok compile code mod code comm compile ok sanity test comm compile ok comm test ok comm test ok modify unit test package mod test plans mod test case test unit comm tests ready comm tests ok comm tests ok exec test case process 
high level process proceeds follows 
change order change control board ccb triggers start process 
design modification subprocess scheduled performed leading scheduling performing code modification subprocess 
code modification test package modification subprocess scheduled takes place followed directly unit testing subprocess 
unit testing fails process loops back code modification subprocess design modification assumed correct redo previous process steps 
loop continues unit testing succeeds process completes 
stated chapter activity spans time represented interval events 
simplify presentation collapsing activity single event 
transitions fsm labeled events occur process executes 
events communication events indicated comm labels 
modification events indicated mod 
program execution event process labeled exec 
label letter enclosed brackets 
letter denotes token identify corresponding event sample streams fed methods 
figures show fsms produced methods figures tokens identify events reader refer relate token event 
boxes serve pictorially group individual states subprocesses 
labels boxes correspond activity titles problem statement 
figures inferred fsms group states subprocesses order aid explanation results 
boxes solid borders boxes dotted borders emphasize fact placed boxes figures hand methods automatically group states subprocesses 
fsm generate sample event streams methods 
different event streams generated input ktail markov tools 
example 
rnet event stream example 
reason rnet purely statistical nature results small example process vary significantly different sample input streams 
show best obtainable results rnet stream artificially contained balanced proportion different event sequences 
shows fsm discovered rnet neural network method 
example network input neurons hidden neurons output neurons 
event window size 
number input output neurons constrained number event types number hidden neurons allow discretization state space window size comparable algorithms 
looking results rnet see modify design subprocess represented states modify code subprocess represented states evident fsm 
results fairly poor artificially balanced sample 
particular rnet failed differentiate state transitions important event sequences 
example state recurrent edges different events informative 
similar problem arises state 
root problem rnet looks statistical history poorly differentiating loop exits 
seeing exit token example states activates state loop accept state 
real exit loop happen token 
true loops example continues loop 
effect schedule tasks test unit modify test package modify code modify design rnet discovery process 
schedule tasks subprocess hard locate fsm intermediate scheduling states distinct 
shows fsm discovered markov method 
example know data exactly correct contain noise probability threshold set zero non zero transition ignored 
see method produces model close equivalent structure 
subprocesses easily located model loop paths usually having extra state easily distinguished 
extra state loop results fact algorithm creates entry state schedule tasks test unit modify test package modify code modify design markov discovery process 
loop 
markov failed merge states schedule tasks provide entry subprocess modify code 
method provides clean understandable representation process 
shows fsm discovered ktail method 
example value tuning parameter values explored gave cleanest schedule tasks test unit modify test package modify code modify design ktail discovery process 
result 
fsm successfully captures behavior example process 
correct number states schedule tasks subprocess finds loops implements correct machine allows anomalous behavior 
explained section algorithm tool language nc loc rnet ktail markov common ui tcl tk table non commented lines code discovery tools 
consistently loops 
subgraphs feature loops unrolled state case node exit paths produced 
notice modify code subprocess shows distinct execution paths possible loop exit path subgraph 
straightforward merging states consequent merging subgraph identical corresponding subgraph 
contrast markov ktail method correctly produces single state schedule tasks subprocess possible paths modify code showing recognize shared subprocess entirety 
fact fact extra loop states algorithmically removed causes view ktail producing best results methods example 
implementation discovery tools methods described chapter implemented experimented part thesis 
rnet adapted implementation das implemented scratch 
additionally common user interface common code startup graph operations interface balboa framework chapter implemented 
table shows size loc various discovery tools 
discovery methods output discovered fsm format compatible dot graph layout program 
leveraging existing graph layout tool central successful application discovery tools 
provides solution going event data directly visual display discovered process model 
discovery seen process discovery tool balboa 
allows select event streams specify discovery method parameters run methods produce discovered process models 
discovery just specifies source event collection mapping specification discovery method parameters discovery method 
discovery spawns discovery process turn spawns window display results 
time discovery process run new window created 
display discovery tool 
window spawned completely independent discovery multiple methods parameter variations run compared side side large display 
tool allows view fsm specified dot format edit fsm 
features directly specific dealing process models discovery 
previously said intended discovery produce process models need completing human beings 
tool presents discovered process models visually allows modification discovered process model 
operations supports merging nodes creating deleting nodes creating deleting edges naming renaming nodes splitting nodes 
uses dot lay graph automatically loading graph edit operation 
commands moving nodes edges high level operations listed 
feature ktail markov rnet correct model possibly possibly speed sec sec sec params params params usability easiest easy hard robustness noise moderate table comparison discovery methods 
evaluation discovery methods section evaluate compare methods 
defer evaluating usefulness methods real world data chapter depth study just concentrate performance algorithms 
table shows comparison methods respect characteristics 
depth description characteristics follows 
correct model 
ktail markov generate correct model data potentially generate complete correct model data thresholds set ignore low probability event sequences 
thresholds set methods generate complete correct model 
rnet purely statistical configured guarantee generation correct model 
speed 
numbers table approximate intended show relative speeds methods 
taken performance methods example 
ktail markov comparable rnet considerably slower 
slowness due mainly large amount required training 
usability 
characteristics quite related tunable complicated interface 
respect rnet overly tunable takes knowledge neural networks establish reasonable set initial settings 
ktail markov tunable dimensions overly restrictive straightforward 
robustness noise 
markov rnet methods potential inferring models presence collection errors abnormal process events 
ktail ability equivalence class size threshold regard configurable handle noisy data streams 
tables discussion compare ktail markov closely 
rnet comparable performance explore performance space 
dimensions worse 
length markov ktail event stream time size kb time size kb table time space requirements versus event stream lengths 
number markov ktail events time size kb time size kb table time space requirements versus number events 
table shows performance markov ktail different event stream lengths number event types 
show linear time relationship stream length markov coefficient low increase running time negligible ktail shows significant increase running time 
methods show performance 
space usage increase slightly longer stream lengths show drastic space requirements 
table shows performance markov ktail different numbers event types keeping stream length constant events 
markov displays non linear time space relationships number event types processed ktail 
tables ktail affected event stream length markov affected number event types 
expect ktail processes event position stream equivalence class markov process tables probabilities event type sequences 
handling concurrency suppose event stream data represent activity process execution happening concurrently 
process different processes 
hope analyzing data discovering concurrency 
section describes approaches may help 

event receive send event 
processes producing events concurrency manifested interleaved event streams 
concurrency model concurrency event stream consider processes model formulated terms processes events strictly ordered 
concurrency event stream necessarily reflect separation discovered model 
view concurrency randomly definition concurrent interleaved sets event streams 
concurrency manifests noise sense sequencing events contain randomness 
noise strong find 
probabilistic analysis hope algorithmic approach ignore random sequences 
methods discover finite state machines view necessarily unable discover concurrency event stream 
specifically structure resulting state machine describes pattern event sequences imply control model machine 
imagine thread control active state machine time resulting interleaved constrained event sequences described patterns model 
concurrency manifests low probability sequences process switches proper setting thresholds algorithms sequences ignored 
resulting fsm may disjoint consisting separate state machines process 
interprets disjoint machine having thread control algorithm fact discovered concurrent processes input data 
approaches deal avoiding concurrency 
able preprocess event stream separate unrelated events attributes able modify data collection method generate separate event streams different threads 
approach look places event stream point possible concurrent actions 
instance assume causally related happen quickly define quickly window size event stream define pw bja probability occurring window interpreted probability causally related window size suppose events happen concurrently manifested event stream seeing abc times seeing acb 
average looks just event window size bja cja follow half time average 
looking window size gives bja cja occur window 
looking window larger certain event may show deterministic behavior just looking event 
indication location event stream manifesting concurrent behavior 
problem applying idea select window size locations event stream 
simply choosing fixed window event stream capture notion concurrency happening certain points 
best window size event specific event type assuming event type occurrence indicates potential concurrency 
method answer question calculate entropy event stream seen windows entropy calculation maximum value represents complete distribution probabilities 
choices entropy log np number event types specifically number token types mapping events 
entropy calculation tells probabilities distributed 
bja event types behavior perfectly deterministic entropy 
probabilities distributed entropy increases 
calculate ew window sizes max token type pick window size minimizes window size token type build probability tables find event types signal possible concurrent behavior 
event window greater size significant events window get transitions final branching area state machine interpreted fork selection 
method may detect forks detecting joins termination concurrency may difficult 
point discovery methods naturally see single pattern sequence engineer identify correct point concurrent behavior stops 
summary discovery described methods process data analysis produce formal models corresponding actual process executions 
analysis supports process engineer constructing initial process models 
early experience methods conclude ktail markov methods show promise neural network rnet method sufficiently mature practical applications 
course experiments needed fully explore strengths weaknesses methods 
process discovery restricted creating new formal process models 
organization process evolve time process models need evolve 
methods process discovery may give process engineer clues direction process model evolve data currently executing process 
focused techniques generating formal models believe useful simply visualizing data collected process 
engineer may simply interested way better understand current process captured event data discovering patterns behavior represented finite state machine help 
see discovery techniques available tool help process engineers build process models 
believe just technique useful helping process engineers discover build evolve process models 
example area data mining may useful techniques discovering software product relationships 
process discovery ffl implementing experimenting ideas discovering concurrency event streams discussed section 
ffl seeding discovery methods potential models pieces models take advantage engineers existing knowledge process 
ktail markov thought naturally allow just initializing equivalences classes probabilities respectively may translate exactly model pieces seeded 
related issue making methods interactive allowing user dynamically control result 
ffl exploring extension discovery methods models 
inference includes learning grammars naturally fit software process 
petri nets rule bases appropriate extensions domain 
ffl investigating difference behavior bayesian versus forward probabilities markov algorithm 
measure goodness deciding better need devised exploration different data threshold parameters help answer bayesian extension useful 
ffl visualization improvements output discovery methods may help understanding engineer 
example drawing transitions thickness relative probability markov discovered model drawing states shading relative size equivalence class ktail may help user understanding discovered model better 
ffl markov method really discovers hidden markov model probabilities transitions 
integrated method implementation 
ffl better assistance parameter selection methods reduce trial error recursion process engineer go apply discovery methods 
implemented graphical viewer probabilities markov method help guide parameter selection similar tools useful ktail 
chapter process validation anytime formal specification system created question arises specification describes real system regardless formally consistent complete correct presumably formal specification created place 
automatic translation specification system takes place program compiled executable question irrelevant specification goes human interpreted step problem behavior predicted prescribed specification agrees actual behavior system serious 
software process modeling formal domain model specification system process executed people exempt problem shows 
software process researchers historically attacked problem prevention formal model process 
words formal model enforce process execution model process necessarily sync 
enforcement typically done making model executable embedding execution automated software engineering environment project 
approach suffers fundamental flaw 
particular assumes virtually entire process executed context automated environment 
fact critical aspects process occur computer eye environment 
case effective way enforce process approach guarantee mutual consistency process model process execution 
addition workflow community long recognized need allow exceptions prescribed process reality strong need allow deviations model 
completely enforce process remains issue managing change process lead discrepancy model execution 
fact considerable addresses process evolution 
commensurate historical approach mentioned concerned problem effecting changes process model automation problem uncovering inconsistencies model execution 
thesis developed techniques detecting characterizing differences process model agree 
executing process predicted process process validation problem 
formal model process actual execution process 
refer detection characterization differences process validation 
process validation serves purposes 
confidence formal process model raised shown process execution consistent behavior predicted model 
turn raises confidence results analyses performed formal model 
process validation process enforcement tool uncovering differences intended behavior actual behavior 
potentially flexible enforcement tool proposed accommodate unavoidable necessary local perturbations process 
process validation reveal process may need evolve accommodate new project requirements activities 
note process validation techniques neutral respect correctness model model reflect correctness execution follow model 
software process engineer ultimate responsibility making appropriate determination problem lies model execution particular inconsistency uncovered 
chapter describe techniques developed process validation 
techniques borrow areas computer science including distributed debugging concurrency analysis especially pattern recognition 
techniques go simply detecting inconsistency provide measure inconsistency 
believe developing metrics process validation critical highly dynamic exceptional nature software processes means simple answers carry little information significance inconsistency 
managers need understand inconsistency occurs severe inconsistency corrective action 
view metrics step suite useful metrics process validation 
section presents background justification methods 
section describes background related 
section presents definitions validation metrics section presents example uses metrics section discusses possible extensions section describes compute metrics 
section describes implementation validation tools section evaluates 
section summarizes validation metrics 
discussion background framework process validation executing process producing event stream side model produce desired prescribed event stream 
cast validation problem quantitatively measuring close event stream executing process event stream produced model 
call event streams execution event stream model event stream 
solution paradigm shown 
describing paradigm put discussing generate model event stream section 
methods doing measurement widely applied string distance metrics 
string distance method counts number token symbols string swaps insertions deletions needed transform string 
applying various mathematical transformations method family metrics 
methods fields various dna rna matching substring matching spelling correction syntax error correction known unix diff program 
general area sequence comparison 
methods doing measurement offer versatility string distance metrics 
hamming distance example count number tokens differ assumes streams length suitably matched padded 
actuality subsumed string distance methods removing insertion deletion operations just tallying swaps 
generally speaking string distance metrics standard method domain collection executing process event event event event event event event data process model generation event event event event event event event data comparison measurements process validation solution 
symbolic sequence comparison place 
string distance methods generalizable tree graph distance measurements 
methods compare model directly event stream available abstraction away generalizable 
error correcting parsers example techniques add error productions regular grammar production rules catch deviations expected grammar syntax 
instrumented measurements specific grammar formalisms 
avoid specific formalisms possible software process modeling domain different modeling languages tools may drive selection modeling language 
section discusses requirements place modeling language 
related process significant previous uses data characterize processes uses data process validation activity 
particular previous product data metrics guide process changes effort specific problem areas project 
summarize 
numeric sequences really representation function time series stock value different topic altogether 
ffl try deduce problems process looking defect data products 
specifically statistically analyzed change data effort data determine behavior process 
example saw ripple effects interface changes saw high percentages fix fix changes proposed measures process progress required data previous measures 
ffl selby take approach providing automated support empirically guided software development 
system amadeus automatically collect measurement data currently focused primarily product data guide development efforts 
applied amadeus automatically building classification trees describe properties source code module lead faults module 
amadeus generic data collection activity automation system 
ffl basili weiss describe methodology selecting metrics data collection techniques goals desired measurement activity 
focuses product data code modifications change classification 
known gqm goal question metric paradigm 
ffl kellner shows usefulness simulation analyses forecasting schedule outcome specific execution process 
uses deterministic stochastic modeling resource constraints derive schedule effort staffing estimations 
attempt relate real data analyses powerful tools right 
efforts begun look process data purpose process validation 
ffl garg describe method uses explanation learning discover aspects fragments underlying process model process history data rules operations effects 
centers rule base goals derive generalized execution flow specific process history 
ffl garg employ manual process history analysis context meta process creating validating domain specific process models software toolkits 
ffl describe beginnings process monitoring experiment goal model process queuing network actual data time spent agents specific tasks states determine real parameters service times probabilities branch path probabilities queuing network analyzed 
ffl wolf rosenblum demonstrate collect event process data basic statistical visual techniques find interesting relationships data order uncover possible areas process improvement :10.1.1.116.7561
ffl porter constructed experimental setting assess benefits code inspections terms group size meeting gains 
feel thesis effectively complements approaches process improvement raising confidence correspondence formal models executions processes 
related event event data compare execution formal model closely related areas distributed debugging history checking 
ffl bates uses event behavioral abstraction characterize behavior programs 
attempts match event data model regular expressions 
marks points data model match attempting provide aggregate measures disparity 
ffl cuny builds bates attempting deal large amounts event data providing query mechanisms event relationships 
assume problem event stream trying locate problem 
ffl describe method tool compare execution history temporal logic specification decide correctness execution respect model 
immediate goal quantify discrepancies correctness subsumed issue 
fact assume execution event stream incorrect respect model techniques give information 
validation metrics section introduce metrics determining correspondence formal model process execution process 
metrics successively refined surprisingly successively complex 
share characteristic compare event stream produced process execution event stream representing possible behavior predicted process model 
issue second event streams constructed important discussed section 
defer detailed examples applying metrics section 
assumptions formalisms model processes defined behavioral semantics permitting simulation specified behavior 
simulation simply mean ability generate pseudo execution paths specification 
possible identify locations specification simulation produce event specified type 
refer location event site 
possible paths specification possible behaviors specified model represented event streams produced simulation 
formal models suitable analyses describe software processes 
include models state machines statemate petri nets slang nets procedural languages appl 
recognition metric metric straightforward just values true false 
value true event streams exactly match false 
refer metric recognition rec metric imagine implementation measurement operating simple recognition engine style grammar checker terminates returning value false error completing recognition returning value true 
implementation measurement easily point event streams diverge 
example consider event streams shown boxes indicate events 
recognition metric applied streams result shown value false diverge third event 
notice rec information rest event streams correspond 
simple string distance metric second metric view event streams strings event types appear distinct tokens strings 
apply known method calculating distance strings distance metric difference process model process execution 
string distance metrics profitably measures correspondence wide variety domains including parsing dna rna sequencing text recognition 
basic levenshtein distance strings measured counting minimal number token insertions deletions substitutions needed transform string 
shows event streams represented strings possible correspondence events 
purposes computing distance execution model event streams choose execution event stream operations applied 
choice insertions represent missed activities model expected execution perform deletions represent extra activities model call performed case 
shows ssd transform execution stream model stream delete substitute insert resulting distance 
happens minimal transformation required 
strengthen metric weights assigned operation types insertion deletion substitution giving relative cost operation 
minimizing number operations calculate distance goal minimize total cost operations isomorphic choosing event stream change resulting measurement just reverses senses insertion deletion 
rec transform stream ssd transform stream nsd transform stream execution stream model stream event streams possible correspondence events 
operations 
strings length length minimal total cost operations computed nm time known dynamic program 
applications method dna rna sequencing text recognition token substitution string distance metric sense 
process validation clear substituted event contribute way goodness correspondence 
account set weight substitution greater sum insertion deletion weights substitution applied costly apply deletion insertion pair potential substitution point 
consider substitution thesis 
simple string distance ssd metric formulated equation ssd max le wd weights insertion deletion operations nd number insertion deletion operations performed execution event stream max maximum wd le length execution event stream 
divisor equation normalizes value size input maximum weight 
weights wd act tuning parameters metric highlight different properties process 
example argue insertions execution event stream costly deletions inherently represent missed activities process execution 
conversely deletions execution event stream sense represent extra performed perspective predicted formal model extra probably affect correctness process execution 
set ae wd reflect property 
values metric intents purposes bounded technically value greater appear events deleted inserted highly 
pick standard statistical correlation rules thumb say measurement strong correspondence moderate correspondence greater weak correspondence 
inversions standard statistical rules thumb effect 
non linear string distance metric characteristic ssd metric focused narrowly cost individual operations 
non linear string distance nsd metric enhancement ssd metric notion sequence insertions sequence deletions 
sequences represent significant discrepancy model execution indicated simple count insertions deletions 
sequence insertions sequence deletions called block 
sequence mean unbroken series transformation operations 
example nsd recognizes consecutive insertions required streams insertion block length 
blocks length 
nsd metric uses block lengths calculate values 
distance equation nsd pn pn wd max le numbers insert deletion blocks particular block length cost function applied block length terms ssd metric 
note weights wd pulled cost function left outside easily compare nsd ssd metric equations 
definition cost function additional tuning parameter nsd metric 
natural function exponential gamma constant actual tuning parameter 
equation yields block length blocks kept length nsd equation reduces ssd equation expected 
cost function yields exponentially increasing values blocks greater 
notice block length function cause distance value corresponding value ssd metric want 
reason consider value produced nsd metric greater value produced ssd metric blocks length greater 
important question ask nsd measure results short blocks long blocks 
interpret short blocks meaning localized discrepancies model execution long blocks means major differences 
answer question calculations tuning parameter small large view ratio results measure relative number longer shorter blocks contributing distance measurement 
works blocks small difference measurements values small 
ssd metric nsd metric unbounded high bounded low 
harder say value represent correspondence model execution represent bad correspondence 
derive values rules thumb ssd metric cutoff correspondence moderate correspondence 
needed nsd rules thumb notion average block length expected event stream correspondence model 
defined avg derived cutoff correspondence nsd metric gamma avg takes ssd correspondence cutoff weights exponential weight average expected block length account tuning parameter example sets avg cutoff value correspondence 
value nicely reduces ssd cutoff value avg 
moderate cutoff value place 
example metrics illustrate various metrics introduced test unit task process problem 
simple small process fragment give reader example example example example example execution model execution model execution model execution model execution model exec exec exec exec exec exec exec exec diff diff diff diff diff diff diff diff exec exec exec exec exec exec exec exec exec diff diff diff diff diff diff diff diff diff diff tcov tcov exec exec exec exec exec exec exec exec ci ci diff diff diff diff diff diff diff mail mail tcov tcov tcov tcov tcov tcov exec exec mail mail ci mail diff diff mail mail ci tcov mail ci mail mail table example pairs execution model event streams 
feeling metrics applied process 
task developer tester involved testing module undergone change 
retrieve test suite configuration control build test executable run specified tests sure code coverage achieved tests 
failure occurs new module error test suite needs updating notify module developers test developers appropriate 
successful completion tests store test results configuration control alert manager new status module 
shows colored petri net model process 
circles denote places rectangles denote transitions 
tokens attributes colored attributes transition predicates deterministically control transition firing 
thick rectangles correspond transitions event sites model labeled event produced site 
thin rectangles correspond internal transitions control model event sites 
keep simple collapse event pairs activity pseudo event type event site thought transition sequence producing event second producing event 
familiar unix command names names event types 
table shows example pairs execution model event streams 
blank space execution event stream point model predicted particular event occurred fact event occur 
similarly blank space model event unfamiliar unix command names appearing ci check check commands configuration management tool build tool exec stands running executable test run example tcov test coverage tool diff text differencing tool mail electronic mail tool 
ok ok exec test tests tcov test diff ok test ci results mail mail mail tests done diff result test failed test problem module problem done ok coverage percentage test binary ready test case ready fetch test package test binary test case done tests passed test unit petri net model test module task 
rec ssd nsd nsd ssd nsd nsd wi wi wi wi wi wi wd wd wd wd wd wd stream ins del cutoff values table example event stream measurements streams table 
stream point event occurred execution predicted model 
intuitively blanks correspond missed extra activities process execution mis specification model 
example stream execution involves consecutive invocations tool result problem performing build model predicts occurred 
ssd nsd metric calculations require transformation execution event stream corresponding model event stream means insertion deletion operations 
apply insertion operation blank execution event stream apply deletion operation blank model event stream 
table shows various validation measurements event streams table 
row contains measurements correspondingly numbered example event stream 
columns give raw number insertions raw number deletions needed transform execution event stream model event stream 
third column gives results simple rec metric pair streams yields identical 
columns table give results parameterized string distance calculations 
vary relative weights wd ssd nsd metrics vary exponential constant nsd metric 
cases weights equal wd cases insertion cost weighted heavier wd highlight missed events execution 
exponential constant nsd metric values show magnitude change unboundedness metric 
row shows cutoff values correspondence rules thumb metric values column bottom row fall call correspondence model execution event streams 
nsd metric cutoffs average recall chose execution event stream transformation operations applied see section 
cost ratio wi wd chosen arbitrarily example 
practice process engineer explore various ratios best reflect actual situation analyzing 
expected block length avg taken 
interesting things see measurements table 
observation similarity values columns wd streams block length length different operation combinations measurements differentiate errors 
hand looks measurements wd columns event streams see effect weighting insertions heavier ssd metric measurement changes addition deletes stream remains correspondence range nsd metrics 
stream ssd produces measurement correspondence range ssd moderate range 
stream just insertion stream weighting better reflects correspondence execution streams weighting 
event stream insertions block length deletions stream measurements wd significantly greater event stream 
shows metrics tuned place importance insertions missed events process execution 
event stream shows measurements insertions difference weighting insertions evident comparison event streams 
example illustrates metrics defined quantify correspondence process execution process model 
shown parameters distance metrics tune measurements result 
extensions metrics section important extensions metrics described earlier 
extensions enhance usefulness metrics terms practical considerations part implementation methods described section 
extensions weighting model metrics weights separate transformation operations insertion deletion 
operations represent different concepts missed extra activities respectively 
event types represent different things counting event type reflect reality 
example code inspection event may important process organization requires action change accepted mechanism easily detecting happened correctly 
event type weights separate insertions deletions solve problem 
global insertion weight deletion weight specified default weights 
event type override default specific weights operations 
example process engineer specify high insertion weight code inspection event type 
effect transformations take place code inspection event execution event stream order sure event corresponded model event stream simply treat event 
code inspection event far correct place getting inserted measured correspondence low high insertion cost event process engineer see measurement 
previous areas string distance measures need weights 
usability enhancements simple non linear string distance metrics naturally decomposable hierarchical fashion able give information measurement just number process model 
side effect calculations help interpret distance metrics 
easiest calculation show help understanding distance metric simple count number event insertions deletions calculated 
simple count help understanding distance calculation especially weights different 
exponential string distance accompanying histogram block sizes operations useful tool understanding dynamics final measurement 
metric decomposition time graphical representation distance errors event stream show detail areas error long event streams condensed data visualization techniques pixel line event displaying event stream differences vertically screen 
addition simply counting insertion deletion operations blocks operation related event site model 
keeping track operations positions model relate areas model correspondence event stream 
producing process model event stream validation metrics far assume existence event streams execution stream model stream 
really stream process execution stream formal model 
derive event stream formal model 
formal model trivial process leads large infinite number event streams 
measuring correspondence need derive model event stream closely approximates execution event stream order get accurate measure possible 
closely mean model stream produces lowest validation measurement 
addition closeness static depends ssd nsd measurement equations weighted different weights insertion deletion operations event types affect model event stream closest 
fact model streams may different metrics example nsd high block penalty may favor correction disjoint events block events 
general producing model stream measure correspondence hard problem 
areas addressed similar exactly problems discuss section 
related section explore areas computer science dealt similar problems model stream generation problem 
parsing programming language parsing encounters similar problem trying recover syntax errors 
compiling program encountering syntax error compiler things produce reasonable error message locating error recover error continue parse rest program 
research produced methods ffl simplest recovery technique panic mode parser skips forward input token stream finds special set key symbols semicolon 
symbol current parse stack popped symbol accepted 
method assumes language set special symbols attempt minimal recovery deleting symbols recover 
ffl aho peterson show cubic algorithm performing global minimum cost error correction terms token insertion deletion 
augment language grammar error productions modify parse algorithm corrections 
expect algorithm high cost propose baseline methods compare 
ffl describes error correction method biased insertion symbols arguing little program text skipped deleted possible 
method ideas minimum distance corrections assumption needs back input stream find correction 
ffl fischer describe method locally cost error correction 
biased insertions include deletions 
method back current parse stack uses local search priority queue find locally minimum cost fix 
additionally method uses symbol insertion deletion costs correction behavior parser fine tuned input language 
show method fast reasonably implement compiler 
techniques specifically developed programming language parsing grammars domain 
critical assumptions backing input stream looking parse stack hold software process domain fact modeling languages notion parse stack 
general techniques extendible general validation problem demonstrate things optimal solutions cost prohibitive heuristics effectively employed practice 
model checking body research called model checking created methods enable checking large models terms state space inherent properties including behavior allowed model 
example burch describe model checker binary decision diagrams able check models states previous handled states 
impressive models analyzing pipelined alu self similar states width bits value 
model checker directly represents regularity state space avoid large extent state explosion 
models regularity state space admit techniques provide leverage 
example directly concerned matching behavior model constrained expressions 
elegant method model current simulation state model desired event answer question event produced 
model stated system event sequences specified extended regular expressions body ce provides automatic mappings standard modeling languages representations 
representation desired event event sequence find behavior reduced system inequalities fed integer linear solver 
ilp system produces binary answer parameters finds solution 
answer heuristics parameters ilp system produce plausible behavior leads event 
behavior constitutes sequence model events 
unfortunately answer constrained expressions help determining correction event stream model state continue analysis rest event stream 
problem validation needs techniques analyze model continual presence deviations model appears techniques constrained expressions applicable 
problem leverage system transformations gain speed scalability transformations system inherently analysis methods produce binary results 
regular expression matching myers miller knight describe algorithms approximately matching string regular expression insert delete substitute operations 
methods build dynamic programming techniques string string comparison algorithms extend regular expressions 
string length regular expression length copies finite automaton implementing connect correspondence graph allows define dynamic programming recurrence relation 
simple operation symbol weightings equivalent ssd metric algorithms operate mn time 
dealing multi symbol blocks gaps nsd metric requires complicates matters significantly 
general string string comparisons string regular expression comparisons arbitrary cost functions blocks require cubic time 
better results obtained assumes concave block costs gamma gamma gamma difference cost block length non increasing increases 
assumption matching regular expressions take mn logm log time takes mn log space 
nsd metric general concave block costs fact presentation convex costs longer block represents serious deviation process model 
regular expression algorithm takes advantage simplicity modeling paradigm 
general constructs process modeling languages reducible regular expressions 
powerful restricted constructs looked 
context free languages example thought high order polynomial time algorithms solving approximate matching 
general super quadratic cubic solutions providing optimal answers impractical requires optimal solution 
generally large constants actual running times 
solving model stream generation problem survey techniques leads general validation problem known efficient optimal solutions fact formulations problem known optimal solutions efficient 
fortunately problem quite bad 
execution event stream guide derivation model event stream significantly cutting required search 
expect execution stream fact correspond degree model 
particular traverse execution event stream incrementally derive events model event stream consulting model 
distance calculation performed areas block cost function naturally concave 
example dna matching high cost physically breaking sequence means block gets longer breaking cost amortized length block 
results concave cost function 
production model event stream making unnecessary separately produce model event stream feed algorithm find measured distance 
approach implies kind state space search method implies method control state explosion 
ai research provided search methods applicable describe best search search 
standard depth breadth searches tree states exhaustive single dimension best search heuristic driven search determines search path lowest cost path state space 
state parent cost estimated cost start cost estimate goal total estimated cost known cost getting start state start plus new known cost getting parent new state plus estimate cost getting goal goal heuristic comes estimating cost going goal state goal best search uses priority queue states evaluated evaluates lowest cost state priority queue 
reaches goal state go iteration states sure goal lower cost goal 
method guaranteed find minimum cost solution heuristic estimator proven underestimate true cost 
true goal lowest cost goal 
adding estimations cost goal state method called uniform cost find lowest cost goal 
unfortunately methods find lowest cost goals guaranteed inspect state lower cost goal 
algorithm similar best search operates graph states tree states 
property interface priority queue complex new parent existing child lower cost old child cost updated 
need maintain state sequence unique set event stream operations model states produce closest model stream execution stream state space tree states 
best search method applicable solving problem thesis 
trying calculate minimum cost distance metrics natural assign actual costs states state search 
fact metrics actual costs order guarantee minimizing correct function 
question estimate cost reaching goal remains 
general know total length event stream rely knowing proportion event stream seen far 
ssd nsd metrics example real time stream coming currently executing process known length defined 
normalized respect length event stream position event stream factored cost assigned state 
say estimated total cost reaching goal state just value ssd nsd metric calculated far cost current state 
estimation assumes event stream processed far representative total stream metric calculation change 
pruning technique pruning state space proven useful reducing cost finding low cost goal 
pruning act throwing away sections state space look unpromising going back look matter happens outcome 
pruning guarantee lowest cost goal smart pruning domains game playing shown negligible effects outcome search dramatically reducing search costs 
pruning take forms vastly different methods heuristics 
pruning method throw away newly generated state estimated cost higher threshold relative current best looking state 
hypotheses estimated costs fairly accurate predictable state actual cost vastly better estimate 
additionally assumes set single threshold state space consistently 
reality initial observations showed variability costs assigned states changes time especially larger variability 
pruning mechanism set threshold fraction current standard deviation state costs 
lets threshold account variability state space search 
method probably applied periodically old states priority queue 
method prune state new old specified distance execution event stream current farthest state 
heuristic assumes paths lowest cost goal state examined interleaved fashion costs fluctuate widely paths expanded close 
unexamined state far event stream thrown path goal state 
examined pruning techniques validation problem evaluate section 
implementing validation methods scope thesis important understand practical uses proposed validation methods 
implemented described chapter describe 
object state object isa set state object isa state object model isa object isa object isa boolean done false model done model done true model successors foreach state state cost state validation calculation algorithm 
validation engine method pruning best search engine find model stream execution stream calculating metrics time 
shows algorithm validation engine shows data flow algorithm 
algorithm described terms generic object imperative language 
algorithm just pruning best search 
priority queue generated best state successors successors pruned successors priority queue states cost estimator model simulator best state initial state final state algorithm initialization algorithm termination data flow model simulator 
evaluated states maintained lowest cost state top algorithm takes lowest cost state model generate set successor states prunes puts successors priority queue 
finishes state pulls priority queue final state processes event 
pruning takes place state pulled priority queue successors generated 
goals provide mechanism modeling paradigm language abstracted validation method 
created model interface specific modeling paradigm plugged 
requirements 
model specify compact representation state 
state position execution event stream model produce set successor states constructed applying match insert delete event stream 
model state may arbitrarily far final state searching final state may costly 
practice option user control 
model interface model implementation state implementation state interface implementation event stream interface event stream implementation interface implementation priority queue validation engine best search architecture model simulator 
virtually modeling paradigm satisfy requirements controlflow oriented state machines statecharts petri nets easier fit 
question compact representation state complex models petri nets state marking net state stored difference parent 
reality compactness required search algorithm maintain possibly large set outstanding states look current hardware platforms provide hundreds megabytes memory affect compactness strong requirement 
additionally explore needs search engine terms space usage section 
implementation validation engine implemented validation method command line window tool tcl tk 
shows architecture implemented validation engine 
control centralized best search loop built top priority queue states 
main goal architecture flexible replaceable component system 
modeling paradigm represented model state objects particularly important replaceable 
wanted flexibility event stream pruning method cost model 
implementation uses virtual base classes interfaces components 
implementation components subclassed interface instantiated component validation engine 
example interfaces show important ones model state classes 
classes interface modeling paradigm instantiated tool 
state base class implements standard requirements validation engine maintaining parent pointer stream position pointer cost 
subclass state needs implement state information method access event associated state 
model base class general information needed validation engine common models 
interface model simple terms states sets states needs identify initial final states state produce set successor states validation engine 
validation process validation tool balboa 
lets quantitatively qualitatively compare execution collected event stream process model see deviations occur execution stream model expects 
shows snapshot validation 
seen validation gives user quantitative metrics view validation detailed view scrolling areas showing event stream 
metrics view upper portion window levels detail count individual insertions deletions upper middle count blocks insertions deletions lower middle calculated distance measurements right side 
validation available parameters distance calculations left side window user interactively change parameters see change calculations 
lower portion tool shows detailed differences execution process model expects 
execution stream displayed left generated model event stream right 
events need inserted execution stream correspond model colored blue light grey bars need deleted colored red dark grey bars 
order validation validation event stream balboa process model specified user 
validation spawns validation process analyzes model event stream produces model stream corresponds validated event stream 
additionally validation spawn window convenience viewing process model validation exercise 
additionally validation allows user control validation engine selection cost model pruning methods parameters 
validation engine lines non commentary lines source code interface lines non commentary tcl tk source code 
include standard code connect balboa server read local event streams interpret events mapping 
class state public state virtual state standard implemented methods virtual state parent state virtual operation operation op virtual int int virtual cost cost virtual sp virtual operator state virtual operator state virtual operator state model state need implement access event virtual class model es protected state parent state pointer execution event stream position operation op created state int count sequence op cost total cost initial state add modeling specific state data protected private class model public model virtual model methods virtual need instantiated virtual int char filename virtual setof state 
state es virtual setof state 
virtual int state virtual int state virtual state state protected default data base class modeling interface model state base classes 
validation tool 
pruning parameter ssd time size states states method variable metric sec kbyte examined pruned position position position cost cost cost table performance pruning methods event event stream 
evaluation validation metrics section evaluate performance validation methods 
particularly look performance search pruning cost model affect results terms speed space correctness 
look pruning methods proposed section cost position pruning 
cost pruning specified parameter percentage best state cost position pruning specified maximum lookback amount furthest state 
table shows performance validation stream events validated model states shown 
model meant represent specific software process complex large explore performance aspects validation 
defer analysis validation real world process data chapter 
table shows performance validation pruning position pruning position look back cost pruning percent cost thresholds 
ssd metric shows position pruning finds optimal model stream cost pruning performs poorly finding optimal model stream searches amount states pruning 
terms time space performance position pruning cost pruning poorly dimensions 
appears support hypothesis position pruning search paths contain solution states expanded concurrently pruning position event stream effective controlling search finding solution 
experimentation cost pruning shown perform 
pruned state space subtree contains optimal solution gets lost flat areas state space states similar costs pruned 
leads question premise variability state costs similar search 
cost pruning results say setting single threshold effective controlling search finding solutions 
explore behavior intercepts draw trans global view view update view pix view view size pix view intercepts draw drawer global get drawer view draw intercepts view view view pix view view view pixy global set font intercepts draw intercepts global inq gc view view pixy global set color global set font global inq gc intercepts view pix global inq gc global set color global view global view global view view view size pix global fill style global inq gc view pix view pix view pix global set color view global inq gc view global fill style view view update model performance evaluation validation 
position pruning 
expect distance execution event stream model expects harder find optimal model stream algorithm needs model searching 
table shows performance validation position pruning streams successively correspondent model 
seen event pruning ssd time size states states stream parameter metric sec kbyte examined pruned closest medium closest medium furthest closest medium furthest table performance position pruning methods higher deviating event streams 
stream ssd time size states states length metric sec kbyte examined pruned table performance position pruning event stream lengths 
ssd metric position look back find optimal model stream correspondent ones significantly err ssd metric staying best calculations 
pruning position lookback furthest deviating stream contain state explosion failed complete machine tests 
running tests guideline quickly deciding resulting measurement expected close optimal discovered 
blocks deviations model stream execution stream larger just larger look back parameter position pruning may measurement close optimal deviations smaller look back parameter measurement optimal close 
observation points fact position pruning behaved sense looking output sizes deviations understand approximately algorithm performed 
usable cost pruning pruning parameter direct relation result 
table shows performance validation different event stream lengths position pruning 
event streams compared model essentially longer ones just concatenated copies shorter ones 
position pruning shows linear performance different stream lengths expect limits far back look 
conclude evaluation position pruning effective allows validation significantly large inputs performing 
summary process validation summary proposed demonstrated metrics process validation 
metrics range simple exact matching linear distance measure terms event insertions deletions non linear distance measure takes broader view event comparison 
metrics independent specific process modeling paradigm generally applied software process field 
believe truly software process improvement analysis techniques ones implemented needed 
chapter describes industrial study shows usefulness metrics real world setting 
study shows validation metrics proposed fact capture important information process behaving 
computing metrics non trivial task described model independent method computing metrics shown practical accurate 
process validation includes ffl adding control starting states states validation engine 
user may want validate piece behavior starts initial state ends final state 
final state situation currently handled validation engine currently starts initial state specified model 
ffl finding places model event stream pinned help reduce searches large models 
example key event happen specific site previous behavior ignored 
similar concept trace change points 
ffl implementing modeling paradigms petri nets metric calculation engine 
ffl developing techniques better visualizing measurements 
example overlaying differences process model model event stream may help process engineer understanding problems process 
ffl identifying properties process models exploited doing validation calculations 
example points model fix execution stream help reduce search cost 
ffl investigating analyses process executions process models 
time oriented metrics example useful extension execution stream analysis 
real time systems analysis techniques useful 
methods measuring efficiency process useful analysis method 
help optimization process behaviorally validated 
ffl formal models useful detect conflicts consistency violations 
sample behavior exactly match model validated decide desired properties model hold 
important show properties hold deviations model 
chapter system framework process analysis software process engineering advantage disciplines activity takes place computers amenable reducing effort needed process tracking analyses 
past years efforts collect process data analyze improve process 
far seen creation single tools access process data ad hoc manner 
methods collecting process data proposed constructed significant effort propose coherent framework tools methods analysis process data 
framework useful ways 
data access perspective framework isolated tools variety data formats provided consistent access method data reduce effort needed tool widely usable multiple data formats 
providing access methods libraries tools constructed quite easily 
data management perspective framework provided management data eliminate need provide redundant facilities tool data format 
chapter describes framework called balboa supports analysis process executions process models event data 
concentrate event data supports wide variety behavioral temporal analyses 
balboa supports event data ways 
support managing interpreting data collected 
second support building tools fit balboa framework 
chapter organization 
section describes motivation related section gives presentation high level architecture balboa framework platform implementation 
sections describe data management data collection client tool interfaces balboa respectively 
section concludes insights ideas balboa 
motivation gives extensive summary process support measurement support seventeen software engineering environments 
process execution guidance systems little measurement support tend concentrate heavily product measures infer process characteristics aggregate process statistics cumulative personnel effort computer usage time 
systems type data fixed general effort allow extensions data collection analysis methods 
system come closest claiming position framework amadeus 
flexible specification data collect data 
positioned supporting unit process guidance system meant support tools 
essentially system registering process events triggering actions occurrence events 
provide assistance maintaining event collections interpreting events providing event collections multiple tools 
considered framework collecting managing providing event data variety analysis tools 
areas event data application real time concurrent systems analysis tools complete control environment compiler linker instrument system tools analyze data 
example trace format data format tools analyze parallel message passing systems 
needed general framework 
tools software process arena hand deal event data multiple heterogeneous sources varied formats events 
climate framework balboa needed 
balboa framework address issue providing mechanisms collecting event data reasons 
exists variety mechanisms collecting data described chapter 
second mechanisms collecting data site specific flexible allow event data sent balboa various sources 
may case single project different collection mechanisms example combination automated manual collection 
variety heterogeneity framework balboa needed tools consistent access kinds data 
address issue data integrity assume data correct events collected occurred consistent events activity corresponding event 
needed tools built help clean raw event data 
summary seen framework analysis process data useful addition ongoing process research facilitate application ideas research industrial domain 
balboa system framework balboa framework meets requirements providing management executing process balboa server event data event data event meta data event types attributes tokens collection tools balboa interface client tools balboa interface manager tools balboa interface balboa framework 
process data facilitation building analysis tools data 
balboa provides client server foundation tools server provides client tools uniform access interface heterogeneous event data collections 
shows high level view balboa framework 
access channels provided balboa server ffl data collection interface allows site specific collection tools submit collected event data server 
ffl data management interface allows management tools manage event data create meta data describing event data 
ffl client tool interface allows client analysis tools access event data consistent manner 
balboa built unix posix platform balboa server daemon process 
balboa relies tcp sockets communication channel tool interfaces 
uses socket interface communicate ascii string newline terminated messages tools server 
messages sent clients commands server server replies data status messages 
data messages sent server data collection management interfaces 
strings messages removes concern different data type implementations different machine architectures introduce performance concerns 
envision event streams extremely large produced short time megabyte gigabyte traces large parallel programs generate short time minutes hours 
balboa provides support client tools tcl tk programming languages allowing construction robust polished tools fast exploration ideas interpreted prototyping language 
languages perl access socket interface easily integrated balboa framework 
discovery validation tools implement analysis methods thesis balboa client tools 
person currently building third client tool perform time ordering queries event data 
shown client tools normally access raw event data see interpreted data event types attributes values tokens event types mapped integer identifiers 
manner interpretation takes place specified meta data data management tools allow user create 
interpretation frees tools specific format data source lets tool builders concentrate building analysis methods data manipulation 
shows data flow balboa system collecting event data executing process creating meta data describing event data data management tools providing interpreted data client analysis tools 
user side balboa provides tool acts central execution point various manager pieces balboa individual analysis tools 
shows snapshot 
seen tool simple button oriented interface launch various management analysis tools balboa 
extensible analysis tools installed balboa helps manage tools data 
specify balboa server default inherited tools started 
interaction balboa server transparent tools 
data management interface balboa order event data tools users able manage describe data 
balboa provides message interface support tools purpose 
management message interface data management interface balboa supports creating modifying removing event data collection specifications event mapping specifications 
interpreter event streams event types attributes tokens event meta data collection tools executing process event meta data event collections provider client tools gatherer manager tools manager balboa server dataflow balboa framework 
messages implement management interface message description create event data collection remove collection return list event collections return specification collection create event mapping specification return list event maps return event map specification interface basic parts creating controlling event collections creating controlling event mapping specifications 
event maps specifications tell balboa interpret raw event data 
interpretation maps event event type individual attributes values 
tool 
specifying event maps described chapter events collected event stream complex data attributes 
tools want understand event types attribute values just raw events 
event data specify mapping criteria map events specific event types handle attribute matching 
mapping specifications interpreter understand raw event data extract event type attribute values 
assume event streams homogeneous non homogeneous coming variety sources 
mechanism interpret events map event types set attribute values tiered regular expressions attribute values 
event stream ordered set regular expressions specified describing events event stream 
event expected match regular expression 
matches matches matches event interpreted error 
regular expression piecewise bracketed fg braces order recognize attributes matching event 
piece regular expression inside braces represents attribute part regular expression outside braces represents white space attributes 
attributes named naming specification referring 
specify unique event type subset attributes regular expression flagged defining event type 
unique values cross product flagged attribute types determine event types event stream 
example suppose event stream event file write code io 
event mapped providing specification doctype doc user type doctype line specifies simple pattern attributes separated spaces ignoring rest time date second line names attributes doctype doc user respectively third line specifies event type attributes plus doctype 
event file write doctype design different event type shown 
represent event type spaced concatenation flagged attributes event shown event type file write code 
attributes doc user variable event type accessible analysis tool example analyze particular software module 
event mapping supports encoded version event type called token 
token single character integer encoding event type 
encoding reduces large event stream simple small stream characters integers 
accessing stream manner useful tools pattern matching similar need look large amounts data simple form paramount 
tool mapping server provides mapping tool remembers reverse mapping token event type user accomplished understandable event type externally meaningless token 
data management tools order event data tools users able manage describe data 
balboa provides user tools perform functions tool lets specify data source parameters information 
done data considered collection balboa 
tool 
tool lets specify interpret event data 
enables mapping events event types mapping event attributes 
tool lets view data source event mapping raw form 
allows sanity check event mapping simply visually inspect data collection 
shows 
tool provides mechanism user view create modify descriptions collections events 
provides direct manipulation list event collections 
lower part screen field oriented form modifying creating specifications 
modify collection clicking list bring data fields individually modified written back modify button 
create new specification fields filled create button pressed 
note existing collection description template simply selecting list bringing data fields 
new specification created file stored collection data immediately imported balboa 
dialog box appears create button allowing tool 
user specify file import data 
file imported balboa raw event data 
ongoing collection events imported occur executing process appended collection 
shows snapshot 
tool create modify event mapping specifications balboa 
described section event mapping done regular expressions specify event attributes flagged subset event attributes specify event types 
provides user list view event mapping specification 
upper list set regular expressions specified mapping lower list set attributes currently selected regular expression 
shows snapshot 
tool provides simple browser event collections 
constructing event mapping specification simply wanting see raw data times browser indispensable 
tool 
balboa data collection interface data collection interface balboa fairly simple just supports creating adding event data collections 
messages implement server access functions message description create event data collection add events existing ongoing collection signals completion sequence event data messages message parameter collection name 
followed data messages client server message event stored collection 
stream messages terminated message signaling server complete creation addition event collection 
data collection tools assumption way access sockets directly indirectly 
method access provided having tools exec interface execute commands provide access 
balboa provides tcl messaging interface built tcl sockets perl provides raw socket capabilities 
collection tools yeast amadeus provide ability execute scripts external commands event processed 
example consider sending event yeast balboa 
yeast specification watching particular file executes tcl script called named file changes 
shown 
tcl script justs connects proper balboa server appends event appropriate event collection 
simple method providing access scripting language allows extensible collection tools yeast interface balboa framework 
process centered environments oz spade ability invoke communicate external tools enactment process problem connecting balboa 
additionally produced log events periodic job set send log balboa batch mode 
repeat file project src interface changed project file change proj src interface yeast specification tools balboa bin set home projects balboa lib tcl source home projects balboa src balboa tcl set argv set argv set argv set filename argv file stat filename socket send collection socket send filename uid socket send done exit tcl script yeast tcl code register event balboa 
client interface balboa section describe specifics interfaces client analysis tools access data balboa server 
section describes low level message interface followed sections describing higher level tcl tk interfaces 
messaging interface base message interface client tools access data composed set messages shown table 
basically client tool needs specify data collection access appropriate event token access events message description set collection accessing get event specific get event pattern specific get token specific get event attribute map raw event return event pattern return event pattern token set parameters token processing table basic balboa message interface desired mode 
attribute values available message 
managerial messages available client tools uses presenting user selection list valid data collections 
interface interface client uses access event stream balboa server comprised types classes defined balboa header file library linked executable created 
main interface composed event token server classes allow access event collection sequence events event types tokens 
classes defined public methods shown table 
class subclass class offers functionality adding token interface 
separate application need access tokens pay overhead maintaining token event type mapping information 
applications direct access event collections files balboa server repository remote need fastest access possible data balboa interface library provides subclasses classes implement file interface 
client tools written balboa interface dependent balboa server 
shows example minimal client simply connects server prints named event collection selected mode event event type token 
minimal event stream copyright jonathan cook include stdio include event include enum mode int main int argc char argv mode mode event event token token ts char argc fprintf stderr usage host 
port 
collection 
mode argv return strcmp argv pattern mode strcmp argv token mode mode ts new argv atoi argv argv int switch mode case event ts break case event event ts break case token ts token sprintf token event event break default event event break printf event delete ts return simple event stream printer :10.1.1.40.6984
class method event event char attribute token token token token ep int token base int arity token int table basic balboa client interface command description select balboa server location connect tk connect specified location close connection current location select event collection processing tk return list balboa server locations select event map specification needed tk get event specified collection get event event pattern type get event token get specified attribute value current event get values current event get event pattern type specified token table basic tcl tk balboa client interface 
tcl tk interface tcl tk interface composed tcl procedures built top extension tcl interpreter provides tcp socket capabilities 
main procedures interface shown table 
detailed specific commands available application needs get basic connect close interface 
marked tk pop dialog window unmarked just simple tcl commands valid tcl interpreter tk 
shows example minimal tcl client simply connects server prints named event collection selected mode event event type token 
tcl minimal event stream copyright jonathan cook source env lib tcl socket tcl source env src tcl argc puts usage argv location 
collection 
exit set location argv set collection argv argc set mode argv set mode event location puts error balboa server location exit collection puts error collection location exit mode event set event elseif mode pattern set event elseif mode token set event event set event puts error mode mode undefined break event break puts event exit simple tcl event stream printer 
chapter balboa framework consistently managing interpreting serving process event data analysis tools 
advantages gives data collection tool construction decoupled having worry format access method data interpret data managerial aspects handling data 
separation tools data format facilitates construction tools allows access data wider variety sources 
usefulness balboa demonstrated construction process discovery validation tools chapter chapter respectively 
tools integrated balboa framework cost construction reduced utilizing common interface 
number possible enhancements balboa explored ffl event data supports varieties analyses certainly forms valid data 
major direction take balboa incorporate types process product data 
ffl tool authorization mechanism server knowledge allowed connect 
information kept collection detail allowing certain collections public keeping private 
ffl data collection interface probable events may reported right occur 
building balboa knowledge timestamps events allow ensure event stream properly ordered allow time oriented queries client tool 
ffl hierarchical event collections useful example separate subprocesses collected separate collections need view process 
ffl sets event collections related closely hierarchical collections useful analyzing executions single process 
chapter case study balboa significant goal thesis show discovery validation methods proposed applicable real world setting operate just toy problems 
pursued industrial study process event data collected discovery validation tools analyze process execution 
study undertaken software lab guidance dr larry votta researcher bell laboratories 
study broader focus just showing techniques useful provides statistical proof formal model process technologies lead better products 
study important right includes just analysis methods thesis 
chapter study results 
section motivates discusses issues study 
section details experimental design including overview process study 
section presents results analyses 
conclude section evaluation discovery validation methods general observations significance historical data studies 
discussion decade seen effort lot money put creating implementing practices software process 
having process lead product 
process improvements relatively obvious obtained redesigning process vaguely comfortable feeling doing things better 
way measure effect process product 
question process leads product may obvious 
done right product produced similarly done wrong dr votta organization study done lucent technologies part defect introduced product 
framework formal process modeling process improvement process embodied formal specification case necessarily true process model fact lead product 
agreed activities process model may unnecessary structure imposed developers 
worse may create complex set interactions serves completely people shown deming red white beads experiment 
current wisdom possible example achieve high cmm maturity level practices trouble producing quality products 
question remains 
clear process lay mechanisms cause defects introduced product 
mechanisms quite diverse 
simple unavoidable occurrences human error coding mistake caught testing 
institutionalized process organization lax enforcement source code access control 
question process model identifies mechanisms prevents occurring 
process model may useful describing 
key answering question lies collection analysis reliable data 
numerous studies analyzed product data identify patterns defects 
patterns process mechanisms inferred step inference purely speculative backed directly hard data 
taken approach analyzing process data directly aim directly identifying statistically significant process patterns may cause defects 
primary purpose determine relate product process secondary goal identifying sources reliable process data 
particular interested effective process data collected routinely organization purposes 
issue finding ways minimize cost intrusion incurred new process data analyses called 
approach view software process existing repositories data naturally occurring experiment 
looking backwards time know outcome process execution examine data see caused factors correlated observed outcome 
similar kind historical data analysis successfully employed study conducted votta zajac 
chapter study analyzes repetitive process determine process fact lead product 
course performing study take advantage process data previously collected manually automatically part industrial software development effort 
organization study responsible performing customer initiated updates large software product 
readily available data collected organization form basis naturally occurring experiment frame study 
part study simple aggregate metrics number source lines changed elapsed time process examined see identify presence defect producing mechanisms 
process validation methods chapter measure correspondence process executed process prescribed different process models created process discovery methods chapter 
results indicate differences may point mechanisms causing unsuccessful processes unsuccessful 
aggregate metrics correlated defect metric delay appearance customer problem report activity fix developer performed fix 
significant differences successful unsuccessful processes followed prescribed process 
demonstrated study product measurably related process advantage historical data effective means analyzing processes 
experimental design designing experiment answer questions required careful selection suitable organization study collected process data just product data willing invest small amount time 
needed understand process sufficiently detailed level finding organization documented process greatly help getting started experiment 
section describe process followed organization worked method selecting collecting analyzing process data method comparing conception process actual executions process 
consider various threats possible validity experiment 
overview subject process study performed post mortem examination customer initiated software update process large telecommunications software product 
targeted small repetitive process responsible identifying solving customer reported software problems 
prescribed steps process depicted informally high level 
interested instances process involved making actual changes software 
data instances ignored 
problem field causes customer call assistance recorded customer assistance database identified called carod ticket 
reports specifically software problems resolved performing simple process part study supplying customer documentation need solve problem helping confusion configuration system 
number customer reports identified problems software 
exists fix problem released customer software update 
problem assigned specific developer assumes responsibility generating fix 
assignment indicate instance process study 
performing fix involves opening modification request fix employing source code control system gain access code subjecting changed code various levels quality assurance 
source code checked changed checked system test submit system test code inspection process opened assign developer problem carod ticket opened software problem 
fixed 
customer reports problem release update customer basic structure process study 
fix completed released customer software update 
customer applies fix may find fix fact solve original problem 
consider failure process unknown mechanism introduce defect software 
purposes accept reject judgment customer terminates instance process 
course organization act resolve problem rejected fixes eventually corrected accepted 
important study attempt fix problem successful 
sources data mentioned approach taken study analyzing process data previously collected organization 
specify data wanted view process data existed 
danger approach data reflect organization felt important 
parts process data collected invisible analyses 
hand additional data collection costs required organization examine large amounts data non intrusive way 
certainly true processes subject process able find data high quality valid statistical analysis 
event definition carod create customer problem carod closed close carod ticket mark complete carod create create carod ticket customer problem carod promised due date customer solution carod description ticket created carod delivered customer solution delivered carod update problem description carod inhouse problem brought house carod response initial response customer carod solved customer problem solved carod update update carod ticket code checkin source code module check code inspect source code inspection occurred developer accepts assignment system test accepts test build assign due date assign assign priority assign target assign assign developer test build built create create create defer defer feature change integrate integrated build kill rejected system build rejected smit submit system test submit system test test plan test plan written table definitions event types data 
kinds data examine chose look event data neatly characterize dynamic behavior process terms sequencing major activities 
event data come sources 
customer database gives events concerning interaction customer including opening carod ticket customer assistance request update status ticket problem solved fix delivered ticket closed 
source code control system gives check event associated changes individual source files 
process instance tracked modification request number tracking database gives events opening assigning developer accepting developer generating test plan submitting solution system test having accepted system test eventually closing lastly database inspection information gives date code inspection result 
source event data involved automatic collection tools inspection dates results recorded manually 
table defines event types occur data 
merging events particular instance process data sources able create event stream represented sequence activities occurring process execution 
collected event streams 
event streams separated populations customer accepted fix customer rejected fix 
source data directly records presence defects released software update partitioning fixes serve defect metric 
course validity metric assumption rejection fix indicates presence defect 
methods analysis separation populations performed analyses variety metrics order discover process characteristics correlate acceptance rejection fix 
analyses centered performing statistical significance tests metric calculated 
looked simple aggregate metrics including number source code lines changed elapsed time process see readily available metric explain defect metric 
took deeper look prescribed process process validation method discussed chapter measure correspondence process executions process model 
measurements give detailed picture process execution deviates organization prescribed sequence activities 
process validation described section 
analyses performed metrics values numeric 
metrics mann whitney significance test chapter assume underlying distribution data nearly powerful standard significance tests assume distribution 
premise test difference populations data values populations merged sorted population distributed approximately merged ranking 
reason called wilcoxon rank sum test 
metrics valued event event stream matched deleted validated respect model 
metrics produce binomially distributed populations imply test population proportions 
standard significance test gamma pq size proportion population size proportion population 
defined gamma weighted sum proportions inverse 
application wilcoxon rank sum proportional significance tests tailed value calculated 
interpret value strongly signifying populations differ metric value weakly signifying difference 
metrics significantly differentiate populations examined interpreted 
addition presenting values results means standard deviations proportions metrics plot metric distribution 
provide understanding general range makeup data process studied 
comparing executing prescribed processes measuring correspondence process executions prescribed process done validation techniques described chapter 
study discussed uses non interactive batch version validation tools 
addition ssd nsd metrics look event type model state information 
type event check event source code control system record total number matches insertions deletions process execution 
allows calculate event type number events type occurred correctly model matches number missed insertions number extra wrong time deletions 
similarly state model record total number event matches insertions deletions occur state model 
counts combined meaningful metrics follows 

matches matches deletions gives event type proportion event occurrences event stream matched model 
matches matches insertions gives event type proportion events predicted model matched event stream 
matches matches deletions gives state model proportion event occurrences event stream matched model 
matches matches insertions gives state model proportion events predicted model matched event stream 
effect third metrics represent proportion matches perspective event stream second fourth metrics represent proportion matches perspective model 
second metrics provide understanding locality event type third fourth metrics provide locality model 
threats validity experimental study validity concerns explicitly addressed 
discuss threats construct internal external validity results 
definitions validity judd smith 
construct validity concerned metrics study faithfully successfully reflect real world attributes values 
study customer acceptance rejection fix metric success failure process basis separate populations 
imagine reasons customer reject fix necessarily related developer fixed problem understood 
metric closest come direct measure success failure 
important note inability directly measure interest occurs experimental studies 
contrast success failure metric metrics measure attributes directly number source lines elapsed time portions process 
direct measures threatened possibility false inaccurate data 
mentioned data automatically collected inaccuracies 
assembly data interacting providing data indication people engaged purposely falsifying data data particularly study motivation 
remaining set metrics measuring closely process models followed validation metrics discussed 
application metrics date largely untested study part evaluation measure useful 
widely methods measuring differences similar types data reason expect measurements accurate 
internal validity concerned experimental design allows causality constructs study 
causality comes able control experimental setting randomizing independent variable assignments 
historical study examining processes occurred randomize variables conclude causality statistically significant measures obtain 
mean learn results 
external validity concerned study results generalized 
answer question process lead product case mean answer holds cases 
negative side process studied maintenance process development process results may biased maintenance kinds processes 
fairly small software manages large 
positive side real world industrial process repeatable execution 
process ubiquitous industry organizations problem reporting fault fixing process 
results probably generalize processes shed light processes industry today 
results results analyses subject data 
aggregate metrics follow correspondence metrics 
aggregate metrics calculated simple aggregate metrics measured statistical significance separating accepted fix population rejected fix population 
metrics 
ncsl number source lines fix including new changed removed lines 
calculated directly source code control system 
number source files modified fix 
calculated source code control system 
total number events process execution 
represents simplistic count number steps executed particular execution process 
ctime total time days customer ticket open close 
total elapsed time process execution 
total time days open close 
total elapsed time development subprocess 
dtime delay time days customer ticket open open 
interval time problem reported time developer begins fix problem 
developer developer performed fix recorded database 
metrics statistical test performed determine populations significantly different metric 
results metrics shown table 
shows distribution plots aggregate metrics developer 
results developer uses nominal scale shown 
metrics statistically significant separating populations 
examine metrics significant 
significant metric dtime delay time customer reports problem time developer starts working problem 
correlation quite interesting explanations 
explanation developer understanding problem degrades delay developer encounters harder time fixing problem 
takes longer customer support working customer understand problem detail relay developer 
delay due fact problem simply difficult understand fixed correctly 
case result warrant closer examination relationship 
value sig test accept pop reject pop measure tailed mean std dev mean std dev ncsl ctime dtime table aggregate metrics 
significant metric developer developer working fix 
developer calculated ratio rejected fixes total fixes measure developer failure rate 
determine failure rates significantly different estimated standard deviation ratio gamma failure rate total number fixes 
show data error bars 
non overlapping error bars significant level developer clearly significant metric 
possible explanation certain developers fixes rejected fixes assigned developers area expertise matches suspected problem 
developers may working simple peripheral code may internals large subsystem difficult change 
examination event streams shown table event type counted number times occurs process execution 
see event types significantly different average counts populations 
significant carod instance updating description customer problem 
greater value rejected fix population imply takes effort problem 
due problem difficult communication customer breaking requires iterations 
significant carod event types indicate slightly carod records rejected fix population seen mean values event counts 
occurs customer reports problem open fixed 
fix performed customer simple software update fix completed customer reports problem customer carod tickets associated number fix process 
dual association cause customer rejections example fix directed customer quite fix problem reported second customer 
increase rejections happen association erroneous person associated problems fix may wrong 
general data reveal presence defect producing mechanisms mechanisms associated delay fix developer ncsl ncsl developer fixes dev ctime ctime dtime dtime distribution plots aggregate metric data 
performing fix 
results identify mechanisms point organization possible directions look improvements 
correspondence metrics analyze process executions respect prescribed process model 
validation tool discussed section measure correspondence process executions represented event streams organization prescribed process represented finite developer fraction rejected fixes developer 
developers performed fixes shown 
nonoverlapping error bars significant approximately level 
state machine model process 
model shown organization documentation process interviews members organization cursory look data 
faithfully represents idealized view prescribed process 
model event streams calculated ssd nsd metrics weighting insertions deletions equally 
took simple counts number matches insertions deletions events insertion deletion blocks 
table gives results metric calculations accepted fix rejected fix populations shows distribution plots metric 
thing notice number event matches average number events event stream table total events matched model 
evidently model describing actual behavior processes 
reflected ssd nsd metrics quite large values 
notice ssd metric fails differentiate populations nsd metric succeeds 
particular deviation prescribed process significantly greater accept pop 
reject pop 
value sig test std std measure tailed mean dev mean dev carod carod carod create carod carod inhouse carod response carod update carod carod closed smit create carod delivered code checkin assign code inspect defer integrate carod solved test plan table event type counts event stream 
events horizontal line weakly significant 
rejected fix population accepted fix population 
look constituents nsd metric see number deletions significant weakly 
nsd metric focuses attention blocks insertions deletions fact nsd metric detects strongly significant difference populations indicates larger carod smit integrate carod create carod carod inhouse create assign assign code checkin code inspect code checkin test plan test plan approve carod response carod solved carod closed carod delivered carod update carod finite state machine model subject process 
areas deviation process model rejected fix population accepted fix population 
level see model describes half behavior significant difference populations relate model 
see difference depth looking proportions matched events shown event type model state tables respectively see section 
tables event types model states fact significant differences shown 
significant difference check event near state process model 
place model event appears difference significant value sig test accept pop reject pop measure tailed mean std dev mean std dev ssd nsd matches insertions deletions insertion blocks deletion blocks table correspondence metrics model 
accept pop 
reject pop 
event type value sig test events proportion events proportion tailed occurring matched occurring matched code checkin test plan accept pop 
reject pop 
event type value sig test events proportion events proportion tailed predicted matched predicted matched carod closed test plan table event type metrics model 
event types significant measures shown 
tables conclude check occurs regularity rejected fix population may lead erroneous inspections untested pieces code 
significant point difference test plan event near state populations having low match rates rejected fix population significantly lower 
may point problem timely creation test plans test fix affect success fix 
lastly area model states shows significant differences event type model state numbers 
states fewer matches predicted events rejected fix population state fewer matches events occurred 
may point problems controlling system test delivery fix customer 
insertions ins deletions del insert blocks ibl delete blocks dbl matches mat ssd ssd nsd nsd distribution plots correspondence metric data model 
metrics alternative process model model point reflects intended behavior process 
view process date current practice organization 
certainly implied fact seen roughly half predicted events matched actual execution 
alternative model representing process described section basis correspondence metrics accept pop 
reject pop 
model state value sig test events proportion events proportion tailed occurring matched occurring matched accept pop 
reject pop 
model state value sig test events proportion events proportion tailed predicted matched predicted matched table model state metrics model 
model states significant measures shown 
indicative organization activities 
shows alternative 
manuals interviews model generated directly data process discovery methods discussed chapter 
application markov ktail discovery methods applied event streams executions process 
shown model event data highly variable setting thresholds discovery methods recognize highly probable recurring activity patterns data resulting model represents objective view process normalized numerous executions process 
model shown composed patterns discovery methods revealed data amount data difficult produce model discovery tools 
model previous sense shifting source process prescription external mandate emergent organizational behavior 
question remains correlation adherence process quality product 
table gives results basic metric calculations shows distribution plots 
see somewhat better correspondence model executions average execution events matched 
greater previous model average indicates significant amount variation individual executions considering model derived collective data describing executions 
model ssd metric fails differentiate populations nsd metric succeeds rejected fix population showing greater deviation 
carod smit test plan carod response carod create carod carod carod inhouse carod response create assign assign code inspect code checkin code checkin code checkin smit test plan test plan smit smit approve approve integrate carod solved carod closed carod delivered carod update carod carod carod update code inspect code checkin alternative finite state machine model subject process 
case insertions deletions drivers 
looking proportions matched events shown event type model state tables gain interesting significant insights 
check events associated state second process model significantly different populations 
model complex behavior point previous clear root problem may 
result suspicion gained model may problem associated check ins warrants investigation 
stronger difference populations seen near process states table various carod events table 
specifically tables indicate proportion matches rejected fix population half accepted fix population 
difference may suggest accepted fix population carefully follows structured customer delivery mechanism 
summary evaluation summary results summarize experiment analysis data revealed interesting things subject organization process 
ffl documented model process adequately capture members organization successfully carry process 
ffl large variance structure activities individual executions process 
ffl success process highly dependent person responsible making required fix 
ffl long delay fix indication failure process 
ffl missed irregular code check indication failure process 
point specific defect producing mechanisms results organization information focus process improvement efforts 
example better document process order communicate practices potential pitfalls new members establish alarm system monitors delay accepting problem report corrective action managers automatically notified value sig test accept pop reject pop measure tailed mean std dev mean std dev ssd nsd matches insertions deletions insertion blocks deletion blocks table correspondence metrics model 
accept pop 
reject pop 
event type value sig test events proportion events proportion tailed occurring matched occurring matched carod closed carod delivered carod solved accept pop 
reject pop 
event type value sig test events proportion events proportion tailed predicted matched predicted matched carod delivered code checkin carod update carod closed carod response carod solved table event type metrics model 
event types significant measures shown 
delay exceeds significant threshold consider better ways structure access code members organization motivated check mechanism 
fact organization begun improvements study 
evaluation validation discovery methods conclude study provides significant evidence discovery validation methods useful practical real world setting 
validation metrics played central role study statistically analyze process executions resulting outcomes accepted rejected product 
study showed validation metrics capture important information process behavior successful separating populations 
furthermore extensibility metrics shown detailed event type state measurements 
uses show ability validation metrics enable detailed situation specific analyses elucidate processes behavior 
discovery tools playing central part study showed usefulness providing model process data 
prescriptive model matching event data discovery tools allowed create process model descriptive actual behavior process 
model better matched done giving clear understandable visualization real process 
additionally validation tools able statistically distinguish accepted rejected populations 
captured important behavioral aspects process 
large amount data event streams high variability event data insertions ins deletions del insert blocks ibl delete blocks dbl matches mat ssd ssd nsd nsd distribution plots correspondence metric data model 
discovered model matched discovery tools difficult write model captured behavior event streams 
application discovery methods shows need usefulness parameters methods control complexity generated models ignore noise event streams 
accept pop 
reject pop 
model state value sig test events proportion events proportion tailed occurring matched occurring matched accept pop 
reject pop 
model state value sig test events proportion events proportion tailed predicted matched predicted matched table model state metrics model 
model states significant measures shown 
process research assumed organization led product creating prescribed process 
demonstrating critical acceptance process research results industry 
described chapter significant step goal 
results study examining relationship process models executions outcomes real world industrial process 
simple aggregation metrics sophisticated process data analysis tools able show correlations deviations prescribed process presence defects product 
results gained sufficiently detailed level permit recommendations relatively specific places improve process 
question widely results study applied important 
subject process management customer initiated software updates fairly common industry answer come studies 
fortunately study successfully demonstrates major cost performing studies data collection need high expected 
particular showed feasible perform process study historical data readily available collected manually automatically regular course process purposes study hand addition new specific instrumentation 
main disadvantage approach data gathering study effectively naturally occurring experiment subject statistically controlled varied order test hypotheses 
substantive causality limited 
benefits approach 
large amounts data collected disturbing process people involved 
lack intrusion particularly important researchers interested studying real world organizations 
second previously collected readily available data costly instrumenting collect new data 
results study focus subsequent instrumentation providing cost effective path data driven process improvement 
step approach overcomes problem convincing organization implement potentially costly instrumentation process providing solid foundation argue benefits 
study evaluated techniques process discovery validation developed thesis 
shown process validation techniques thesis fact capture important qualities process execution metrics correlated product quality produced process 
demonstrated process discovery techniques significantly reduced effort understanding process executed 
variability event data amount event data difficult find important process patterns help discovery tools 
study gives significant reason believe techniques developed thesis useful real world setting affect software processes importantly products positive manner 
chapter thesis explored problems software process process discovery process validation 
devised implemented methods solve problems validated showing methods real world setting 
process discovery extended implementation neural net inference method enhanced algorithmic method implemented invented implemented probabilistic method 
neural net method rnet prove practical 
algorithmic method ktail probabilistic method markov demonstrated able infer patterns process event data efficient doing 
process validation devised paradigm validation context process models event data string distance measurements specified quantitative metrics paradigm 
showed computing metrics hard heuristic method calculation performs terms speed quality results 
industrial study undertaken determine methods operate real world data 
showed discovery validation methods successfully applied capture important features process 
furthermore showed process statistically related producing product 
implemented extensible framework building process data analysis tools called balboa eases burden managing event data building tools access data 
discovery validation tools built framework tools built 
thesis contributed analysis methods tools body computer science research 
rest chapter describes methods applied outside software process directions lines explored thesis 
applications techniques developed thesis applicable broader scope just software process 
areas characterize system execution event data called trace data potentially benefit process discovery techniques system behavior verified representation system process validation methods applied 
section presents thoughts application techniques outside software process potential domains interest 
process discovery process discovery essentially just provide model patterns occur sequence 
trace system collected process discovery potentially help understand recurring patterns system undergoes 
need understand system widespread application software engineering including debugging especially distributed debugging reengineering existing legacy systems maintenance poorly documented system similar activities 
feel process discovery techniques successfully applied areas 
important role discovery tools play visualization tools 
provide discovery behavior provide visual representation 
explored aspect heavily simply providing pictures behavior system help understanding 
applying discovery methods low threshold parameters show detailed patterns system high threshold parameters allow engineer extract big picture patterns event stream 
effect highlight architecture system 
process validation model essentially specification system 
need answer question 
close behavior match specification process validation methods applied 
areas computer science take advantage techniques especially area formal methods specification design 
checking system adherence requirements specification design document example done validation methods 
glance think adherence reality complex specification design conflicting incorrect simply abstracted parts rare implementation large system exactly agrees specification 
validation help measure agreement highlight areas system diverge specification focussing effort building system points close agreement specifications lacking 
software architecture describes high level structure system accepted low level details implementation may bend rules architecture successfully satisfactorily implement needed functionality 
callbacks client server framework example 
important question closely architecture specification describe real system 
techniques validation help answer behavioral side question 
applying validation life product may help identify architectural drift assist problem 
systems trace data section outline potential domains systems provide trace data speculate methods applied areas 
domains examples data experimented data believe techniques successfully applied 
program traces trace method invocations object oriented program represents pattern communication objects 
call graph show static potential communication actual dynamic behavior substantially different different inputs 
process discovery methods developed visualize understand actual behavior system 
validation applied design specification program needs compared implemented system 
subsystem protocols interface subsystems large software system viewed messaging protocol 
capturing message trace discovering protocol interface useful understanding behavior system 
lead identifying strongly coupled subsystems erroneous connections modules help re architecting old heavily evolved system 
validation side existing model protocol abstraction real world may protocol capture exact implementation 
validation measurements give results show closely real protocol matches model 
message logs large telecommunications product produces large amounts rop log data testing logs informational messages state system event occurrences internal system 
debugging experts system reading rop logs logs try understand wrong system 
due volume data approach likened search needle haystack 
method extensive searching probably wrong paradigm technology 
discovery methods discover patterns rop traces assist engineers understanding trace data 
tools effectively show general common patterns 
reduction model large rop trace useful analyzing data models validation methods highlight areas traces differ general patterns 
read printer 
section directions process discovery validation balboa framework 
process discovery process discovery areas potential including extensions methods enhancements tools implement 
ffl discovering concurrency event streams 
chapter promising techniques identify points event stream concurrent behavior happening 
ffl seeding discovery methods potential models pieces models 
take advantage engineer existing knowledge process 
ktail markov thought naturally allow just initializing equivalences classes probabilities respectively may translate exactly model pieces seeded 
related issue making methods interactive allowing user dynamically control result example seeing model produced far constraining certain portions fixed method continues 
ffl exploring extension discovery methods models 
inference includes grammar learning naturally fit software process 
petri nets rule bases appropriate extensions domain 
ffl investigating difference behavior bayesian versus forward probabilities markov algorithm 
bayesian extension markov better original explored 
measure goodness deciding better need devised exploration different data threshold parameters help answer bayesian extension useful 
ffl integrating hidden markov model information markov method 
markov really discovers hidden markov model probabilities transitions 
integrated method implementation output 
augmenting output probability information provide information user 
ffl improve explore visualization aspect discovery methods 
methods act visualization tools enhancements implementation may help understanding engineer 
example drawing transitions thickness relative probability markov discovered model drawing states shading relative size equivalence class ktail may help user understanding discovered model better 
ffl assist user parameter selection 
better assistance parameter selection methods reduce trial error recursion process engineer go apply discovery methods 
implemented graphical viewer probabilities markov method help guide parameter selection similar tools useful easily implemented ktail 
process validation process validation areas span range enhancements tools theoretical extensions 
ffl adding control starting states states validation engine 
user may want validate piece behavior starts initial state ends final state 
final state situation currently handled validation engine currently starts initial state specified model 
ffl identifying properties process models exploited doing validation calculations 
example places model event stream pinned help reduce searches large models key event happen specific site previous behavior ignored 
idea similar concept trace change points 
ffl implementing modeling paradigms petri nets metric calculation engine 
ffl developing techniques better visualization measurements 
example overlaying differences process model model event stream may help process engineer understanding problems process 
ffl investigating analyses process executions process models 
time oriented metrics example useful extension validation methods 
real time systems analysis techniques useful 
methods measuring efficiency process useful analysis method explored little 
help optimization process behaviorally validated 
ffl identifying formal properties maintained behavior agree model 
formal models useful detect conflicts consistency violations 
questions answered behavior doesn exactly match model validation methods provide leverage help answer 
balboa framework number possible enhancements balboa explored ffl add types data support 
event data supports varieties analyses certainly forms valid data 
major direction take balboa incorporate types process product data 
ffl implement level security 
tool authorization mechanism server knowledge allowed connect help protect sensitive data 
collection detail allowing certain collections public keeping private 
ffl add understanding time 
data collection interface probable events may reported time occur 
building balboa knowledge timestamps events allow ensure event stream properly ordered better support time oriented queries client tool 
ffl allow hierarchies sets collections 
hierarchical event collections useful example separate subprocesses collected separate collections need view process 
sets event collections related closely hierarchical collections useful analyzing executions single process 
agrawal imielinski swami :10.1.1.40.6984
mining association rules sets items large databases 
proceedings acm sigmod international conference managment data pages 
acm press may 
aho peterson 
minimum distance error correcting parser context free languages 
siam journal computing december 
mannila 
grammatical inference applications volume lecture notes artificial intelligence subseries lncs pages 
springer verlag new york 
angluin 
inductive inference formal languages positive data 
information control 
angluin 
inference reversible languages 
journal acm july 
angluin 
learning regular sets queries counter examples 
information computation 
angluin smith 
inductive inference theory methods 
acm computing surveys september 
apostolico atallah 
efficient parallel algorithms string editing related problems 
siam journal computing 
technical journal volume 
march april 
avrunin buy corbett dillon wileden 
automated analysis concurrent systems constrained expression toolset 
ieee transactions software engineering november 
fuggetta ghezzi 
software process model evolution spade 
ieee transactions software engineering december 
fuggetta ghezzi 
spade environment software process analysis design enactment 
finkelstein kramer nuseibeh editors software process modeling technology pages 
wiley 
ghezzi 
multi paradigm petri net approach process description 
proceedings th international software process workshop pages october 
kaiser 
scaling rule development environments 
proceedings third european software engineering conference number lecture notes computer science pages 
springer verlag october 
krishnamurthy 
event contexts matching constraints monitor software processes 
proceedings th international conference software engineering pages 
ieee computer society press april 
basili weiss 
methodology collecting valid software engineering data 
ieee transactions software engineering 
bates 
modelling tool event definition language 
technical report coins university massachusetts amherst 
bates 
shuffle automata formal model behavior recognition distributed systems 
technical report coins university massachusetts amherst 
bates 
debugging heterogenous systems event models behavior 
proceedings workshop parallel distributed debugging pages 
acm press january 
ben shaul kaiser 
paradigm decentralized process modeling realization oz environment 
proceedings th international conference software engineering pages 
ieee computer society press may 
halliday brown chillarege 
case study software process improvement development 
ieee transactions software engineering december 
biermann feldman 
synthesis finite state machines samples behavior 
ieee transactions computers june 
perry votta 
prototyping process monitoring experiment 
ieee transactions software engineering pages october 

algorithmic learning theory volume lecture notes artificial intelligence subseries lncs pages 
springer verlag new york 

algorithmic learning theory volume lecture notes artificial intelligence subseries lncs pages 
springer verlag new york 
gilbert 
approaches automatic discovery patterns 
technical report cs city university london december 
burch clarke mcmillan dill hwang 
symbolic model checking states 
information computation 
carrasco oncina 
grammatical inference applications volume lecture notes artificial intelligence subseries lncs pages 
springer verlag new york 
long 
theory finite automata 
prentice hall englewood cliffs new jersey 

grammatical inference applications volume lecture notes artificial intelligence subseries lncs pages 
springer verlag new york 
castellanos vidal 
grammatical inference applications volume lecture notes artificial intelligence subseries lncs pages 
springer verlag new york 
charniak 
statistical language learning 
mit press cambridge massachusetts 
chen 
bayesian grammar induction language modeling 
technical report tr harvard university center research computing technology january 

evaluating software design process analyzing change data time 
ieee transactions software engineering july 

evaluating software design processes analyzing change data time 
ieee transactions software engineering july 
cook wolf 
metrics process validation 
proceedings third international conference software process pages 
ieee computer society october 
corbett 
tool automatic generation behaviors constrained expression analysis 
technical report february 
cuny forman hough kundu lin snyder stemple 
debugger scalable application event abstraction 
proceedings acm onr workshop parallel distributed debugging pages 
acm press may 
das mozer 
unified gradient descent clustering architecture finite state machine induction 
proceedings conference number advances neural information processing systems pages 
morgan kaufmann 

managing software processes environment 
sigsoft proceedings fourth symposium software development environments pages 
acm sigsoft december 
edwards deming 
crisis 
mit press cambridge ma 
devore 
probability statistics engineering sciences 
brooks cole pacific grove california rd edition 
digital technical journal volume 
digital equipment fall 
dillon avrunin wileden 
constrained expressions broad applicability analysis methods distributed software systems 
acm transactions programming languages systems july 
du chang 
model fast algorithm multiple errors spelling correction 
acta informatica 
eckert nutt 
trace extrapolation parallel programs shared memory multiprocessors 
technical report tr cu cs department computer science university colorado may 
el 
evaluation method 
technical report mcgill se mcgill university 
eppstein 
sequence comparison mixed convex concave costs 
journal algorithms 
fagan 
advances software inspections 
ieee transactions software engineering se july 
mandrioli 
proving properties real time systems logical specifications petri net models 
ieee transactions software engineering february 

validating real time systems history checking trio specifications 
proceedings th international conference software engineering pages 
ieee computer society may 
fischer 
simple fast effective ll error repair algorithm 
acta informatica 
garg jazayeri 
process centered software engineering environments grand tour 
software process trends software pages 
wiley 
garg 
process hindsight 
proceedings th international conference software engineering pages 
ieee computer society press may 
garg 
process programming hindsight 
proceedings th international conference software engineering pages 
ieee computer society may 
garg jazayeri 
meta process software reuse process discovery evolution 
proceedings th international workshop software reuse november 
garg jazayeri 
meta process software reuse process discovery evolution 
proceedings th international workshop software reuse page need pages november 

hp new generation software development tools 
technical report hewlett packard software engineering systems division fort collins colorado november 
gold 
language identification limit 
information control 
gold 
complexity automatic identification data 
information control 
greenwood 
csp system dynamics process engineering tools 
proceedings second european workshop software process technology number lecture notes computer science pages 
springer verlag september 
grudin 
groupware cooperative problems prospects 
editor groupware computer supported cooperative pages 
morgan kaufmann 

evaluation nets 
proceedings second european workshop software process technology number lecture notes computer science pages 
springer verlag september 
harel 
statecharts visual formalism complex systems 
science computer programming 
harel naamad pnueli sherman 
statemate working environment development complex reactive systems 
proceedings th international conference software engineering pages 
ieee computer society april 
heimbigner 
process state server approach process programming 
sigsoft proceedings fifth symposium software development environments pages 
acm sigsoft december 
huff 
software process modelling 
software process trends software pages 
wiley 
huff lesser 
plan intelligent assistant supports software development process 
proc 
rd acm sigsoft sigplan symposium practical software development environments pages 
acm press february 
humphrey 
managing software process 
addison wesley reading massachusetts 
humphrey 
discipline software engineering 
sei series software engineering 
addisonwesley 
hutchinson 
algorithmic learning 
graduate texts computer science 
oxford university press 
ibm systems journal volume 
ibm 
ieee software volume 
ieee press july 
iso guidelines application iso development supply maintenance software 
technical report international standards organization 
inverardi krishnamurthy 
yeast case study practical formal methods 
tapsoft proceedings th international joint conference caap fase number lecture notes computer science pages 
springer verlag april 
conradi 
techniques process model evolution epos 
ieee transactions software engineering december 
jain sharma 
algorithmic learning theory volume lecture notes artificial intelligence subseries lncs pages 
springer verlag new york 
judd smith 
research methods social relations 
holt rinehart winston fort worth sixth edition 
kashyap 
noisy substring matching problem 
ieee transactions software engineering 
kellner 
software process modeling support management planning control 
proceedings international conference software process pages 
ieee computer society october 
kellner feiler finkelstein katayama osterweil rombach 
software process modeling example problem 
proceedings th international software process workshop pages october 
knight myers 
approximate regular expression pattern matching concave gap penalties 
algorithmica 
koutsofios north 
drawing graphs dot 
bell laboratories october 
krishnamurthy rosenblum 
yeast general purpose event action system 
ieee transactions software engineering october 
kruskal 
overview sequence comparison 
sankoff kruskal editors time warps string edits macromolecules theory practice sequence comparison pages 
addison wesley reading massachusetts 
lange 
algorithmic learning theory volume lecture notes artificial intelligence subseries lncs pages 
springer verlag new york 
lange watson 
algorithmic learning theory volume lecture notes artificial intelligence subseries lncs pages 
springer verlag new york 
leblanc robbins 
event driven monitoring distributed programs 
proceedings fifth international conference distributed computing systems pages 
ieee computer society may 

process measurement support sees 
sigsoft software engineering notes october 
lu fu 
error correcting tree automata syntactic pattern recognition 
ieee transactions computers november 

syntactic structural pattern recognition theory applications volume series computer science chapter grammatical inference pages 
world scientific new jersey 

syntactic structural pattern recognition volume nato asi series computer systems sciences pages 
springer verlag new york 
myers miller 
approximate matching regular expressions 
bulletin mathematical biology 
curtis weber 
capability maturity model software version 
technical report cmu sei tr software engineering institute february 
curtis weber 
capability maturity model version 
ieee software july 
schafer 
concepts implementation rule process engine 
proceedings th international conference software engineering pages 
ieee computer society may 
pitt 
analogical inductive inference volume lecture notes artificial intelligence subseries lncs pages 
springer verlag new york 
porter toman votta 
experiment assess cost benefits code inspections large scale software development 
third acm sigsoft symposium foundations software engineering pages 
acm press october 
pressman 
software engineering practitioner approach 
mcgraw hill reading ma third edition 
reiss 
connecting tools message passing field environment 
ieee software pages july 
rich 
artificial intelligence 
mcgraw hill series artificial intelligence 
mcgraw hill 

methods automatic construction error correcting parsers 
acta informatica 
kaneko sakamoto 
method software process modeling description lotos 
proceedings international conference software process pages 
ieee computer society october 
sakakibara 
efficient learning context free grammars positive structural examples 
information computation 
sakakibara 
grammatical inference old new paradigm 
technical report isis rr institute social information science september 
anchez 
grammatical inference applications volume lecture notes artificial intelligence subseries lncs pages 
springer verlag new york 
sankoff kruskal editors 
time warps string edits macromolecules theory practice sequence comparison 
addison wesley reading massachusetts 
schneider lim 
utilization fuzzy sets recognition imperfect strings 
fuzzy sets systems 
schwartz melliar smith vogt 
interval logic higher level temporal reasoning 
proceedings second acm symposium principles distributed computing pages 
association computer machinery august 
selby porter schmidt 
metric driven analysis feedback systems enabling empirically guided software development 
proceedings th international conference software engineering pages 
ieee computer society may 
stolcke 
grammatical inference applications volume lecture notes artificial intelligence subseries lncs pages 
springer verlag new york 
service 
sun microsystems 
sutton jr accommodating manual activities automated process programs 
proceedings th international software process workshop october 
sutton jr heimbigner osterweil 
language constructs managing change process centered environments 
sigsoft proceedings fourth symposium software development environments pages 
acm sigsoft december 
sutton jr heimbigner osterweil 
appl language software process programming 
acm transactions software engineering methodology july 
sutton jr ziv heimbigner osterweil song 
programming software requirements specification process 
proceedings international conference software process pages 
ieee computer society october 
guide software quality management system construction certification en issue 
technical report uk department trade industry british computer society london 
valiant 
theory learnable 
communications acm 
votta zajac 
design process improvement case study process data 
proceedings fifth european software engineering conference esec pages 
springerverlag september 
waterman 
general methods sequence comparison 
bulletin mathematical biology 
wolf rosenblum :10.1.1.116.7561
study software process data capture analysis 
proceedings second international conference software process pages 
ieee computer society february 
wolf rosenblum 
process centered environments support environment centered processes 
proceedings th international software process workshop pages march 

new trace file format 
technical report ornl tm oak ridge national laboratory 
zeng goodman smyth 
learning finite state machines self clustering recurrent networks 
computation 

