evolutionary approach constructing effective software reuse repositories scott henninger university nebraska lincoln repositories software reuse faced interrelated problems acquiring knowledge initially construct repository modifying repository meet evolving dynamic needs software development organizations 
current software repository methods rely heavily classification exacerbates acquisition evolution problems requiring costly classification domain analysis efforts repository effectively 
article outlines approach avoids problems choosing retrieval method utilizes minimal repository structure effectively support process finding software components 
approach demonstrated pair proof prototypes peel tool semiautomatically identify reusable components codefinder retrieval system compensates lack explicit knowledge structures spreading activation retrieval process 
codefinder allows component representations modified users searching information 
mechanism adapts changing nature information repository incrementally improves repository people 
combination techniques holds potential designing software repositories minimize front costs effectively support search process evolve organization changing needs 
categories subject descriptors software engineering tools techniques software libraries user interfaces information storage retrieval information search retrieval query formulation retrieval models general terms design additional key words phrases component repositories information retrieval software reuse 
libraries reusable software components continue grow issue retrieving components software libraries captured attention software reuse community burton devanbu research supported part mda army research institute 
author address department computer science engineering ferguson hall cc university nebraska lincoln lincoln ne email cse unl edu 
permission digital hard copy part personal classroom granted fee provided copies distributed profit commercial advantage copyright notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
acm acm transactions software engineering methodology vol 
april pages 
scott henninger frakes frakes frakes pole maarek prieto az freeman sommerville wood 
especially component reuse approaches developers compose software parts application libraries components necessary achieve software reuse 
component software reuse faces inherent dilemma order approach useful repository contain components support developers examples available finding choosing appropriate ones troublesome 
retrieval techniques diverse enumerated classification booch facets prieto az prieto az freeman frame classification free text indexing frakes relational databases burton formal specifications chen employed address problem finding relevant components 
issues involving effective repositories built populated evolved meet changing needs development organizations received considerably attention 
retrieval algorithms require predefined structure place designers effectively search repository 
minimum components categorized placed repository 
value added approach building software repositories creates barrier real intellectual capital investments organizations overcome biggerstaff richter 
development organizations pressed deliver specific products afford extra required generalize categorize products created individual projects 
methods needed provide adequate retrieval effectiveness minimal indexing structuring efforts allowing organizations take advantage valuable assets accumulated previous development efforts large front investments 
addition costly structures required retrieval static unable adapt dynamic development contexts 
structures created set stone changeable complex procedures involving redesigning entire repository 
significant problem proven exceedingly difficult get structure right time domain constantly evolving pressures changing technology project dynamics fluid nature customer needs 
purpose article twofold describe problems indexing retrieval software repositories set tools designed support incremental refinement component repositories 
scheme initial component representations created minimal structuring efforts allowing repositories built minimal front effort 
retrieval techniques employed compensate minimal retrieval structure help developers find reusable components 
developers repository adaptive indexing techniques employed enhance retrieval structures evolve repository representation ways users reason development problems 
acm transactions software engineering methodology vol 
april 
constructing effective software reuse repositories sections overview current research retrieval methods software components 
evolutionary approach constructing repositories introduced followed sections describing repository seeding retrieval adaptive indexing capabilities peel codefinder experimental prototypes designed investigate issues creating maintaining software repositories 
conclude discussion limited empirical investigations codefinder 

supporting software reuse component repositories basic technologies applied software reuse methodologies composition reuse known parts component reuse generative techniques language reuse biggerstaff richter frakes pole 
composition technologies components self contained entities library routines data structures programs objects 
reusing components accomplished developers finding understanding adapting components new application 
unix pipes code libraries programming languages examples composition techniques 
generative approaches closely related compiler technology pieces parameterized code invoked user selection create customized applications 
library problems exist generative technologies batory problem critical component technologies components exist repository useful 
component repositories structure repository key obtaining retrieval results 
matter intelligent matching algorithm components indexed structured poorly difficult achieve retrieval performance 
intuitive widely held assumption front investments structuring repository result proportional increase ease components reused barnes 
truth assumption retrieval methods created effectively low cost repository structures 
information retrieval techniques decades research salton mcgill retrieval methods software repositories divided categories enumerated classification faceted free text indexing frakes 
hypertext systems form retrieval necessary hypertext effective large repositories halasz thompson croft 
enumerated classification known retrieval method dewey decimal system acm computing reviews classification system 
method information placed categories usually structured hierarchy subcategories unix file system 
acm transactions software engineering methodology vol 
april 
scott henninger appeal classification scheme ability iteratively divide information space smaller pieces reduces amount information needs 
issues involved enumerated classification include inherent inflexibility problems understanding large hierarchies 
tradeoff depth classification hierarchy number category members 
domains lend small classes 
effect users unfamiliar structure lost possible classes halasz 
domains categories necessarily contain members 
case selection class step retrieval process user search large number category members relevant information 
issue hierarchy place gives view repository 
changes view may taxonomy resulting extensive redesign class structures consequences entire contents repository 
enumerated classification requires users understand structure contents repository effectively retrieve information 
thought classification systems library congress shown problematic users 
study classification retrieval system fischer lemke subjects trouble distinguishing class labels proceedings inproceedings database computer science literature foltz kintsch 
led misunderstandings contents classes ineffective retrieval behavior 
part problem information retrieval systems assume information space adequately represented single classification 
classification correct circumstances impossible principle identify possible relevant features large information space furnas 
naturally occurring information spaces biological taxonomies need structure satisfy different information needs researchers biology natural sciences lakoff 
structures evolved years labor intensive nature enumerated classification remains significant barrier creating multiple structures 
faceted classification avoids enumeration component definitions hierarchy defining attribute classes instantiated different terms prieto az freeman 
variation relational model terms grouped fixed number mutually exclusive facets 
users search components specifying term facets 
facet classification techniques help users choose appropriate terms 
similar attribute value structures number frame retrieval techniques artificial intelligence brachman devanbu patel schneider faceted techniques fixed acm transactions software engineering methodology vol 
april 
constructing effective software reuse repositories number facets attributes domain restriction exists attribute value methods frakes pole 
facets flexible enumerated schemes individual facets redesigned impact facets 
usability problems remain 
facets easy synthesize combine terms represent components hard users find right combination terms accurately describe information need especially large complex information spaces frakes 
method requires users know library terms structured understanding significance facet terms facet curtis 
field faceted retrieval systems shown need training people facets effectively extensive training necessary designing faceted information domains prieto az 
free text indexing automatic indexing methods text document indexing 
document text applied list remove frequently occurring words remaining text index document 
users specify query keywords applied indices find matching documents 
classification effort required human indexers augment automatically extracted index terms 
matching criteria range boolean match sophisticated methods vector model statistical measures rank retrieved information salton mcgill 
free text methods simple build retrieve rely regularities linguistic texts need large bodies text statistically accurate 
nonlinguistic nature source code fact clear accurate documentation necessary working code methods attractive software component repositories text documents 
free text methods applicable domains extensive documentation unix man pages frakes pole maarek smadja 
inaccurate characterize source code documented adequately methods 
retrieval effectiveness free text methods questioned text intensive domains law blair maron low cost building repository coupled adequate performance approach popular commercial text retrieval systems world wide web engines yahoo alta vista 
repository structure retrieval effectiveness methods define continuum enumerated classification requires extensive structure faceted classification requiring structure free text indexing requires structure 
classification schemes computationally simple retrieve usability problems exist difficult build 
designers get taxonomy right definition right elusive situation specific acm transactions software engineering methodology vol 
april 
scott henninger dependent needs individuals harter 
faceted classification attribute value methods suffer reduced form problem get attributes right simple matter choosing terms facets 
free text indexing involves little front costs effective large corpus linguistic text available 
strength methods sophisticated information structures people knowledge contained structures lead relevant information 
weakness support possible information structured manner consistent user expectations 
creating specialized information labor intensive costly process resources strained large information spaces concerned 
may true structure crucial retrieval system effectiveness sophisticated information retrieval techniques finesse relationship repository structure retrieval methods 
question relationship structure effective retrieval adequate retrieval effectiveness accomplished minimally structured repositories 
follows middle ground achieved investigating accomplished assumptions existence specialized knowledge effectively utilizing information structures cheaply derived 
retrieval methods employed need little structure yield effective retrieval performance 
structures augmented context 
people find information interaction system traced improve existing structure 
result flexible integration retrieval repository construction methods improve underlying structures repository 

codefinder information access software reuse shows repositories constructed minimal front effort incrementally improved repository 
initial stages constructing repository important populate repository components components explicitly designed reuse basili 
approach repository initially seeded fischer low cost repository construction method semiautomatically indexes components terms phrases 
prototype system described article called peel parse extract emacs lisp extracts components text files indexes combination automatic extraction interactive user support 
resulting repository having created minimal retrieval structures may suffer incomplete inconsistent indexing making difficult keyword matching algorithms retrieve relevant information 
combination soft matching query reformulation techniques employed compensate minimal effort designing repository acm transactions software engineering methodology vol 
april 
constructing effective software reuse repositories fig 

evolutionary construction repositories 
making easier find information 
codefinder system prototype retrieval tool uses combination retrieval techniques help users find reusable software henninger 
effective retrieval tools repository effectiveness directly proportional quality indexing structures retrieval 
relevance feedback adaptive indexing methods improve repository structures reflect mental models developers searching components 
empirical studies shown evolving network structures designed effective time team setting people similar concerns similar vocabulary belew 
addition system adapts changes organization software development environment business needs 
advantage approach costs incurred incrementally needed basis requiring extensive front repository design effort 
initially components required undergo certification process necessary part production system 
subsequent efforts incrementally add value components reused 
techniques adding value components studied extensively literature include methods certification procedures reusability basili various domain analysis methods prieto az simos 
purpose reported build repository infrastructure accommodate techniques incrementally add value purpose finding components meet developer task hand 
useful repository needs supported tools create initial information structures flexible mechanisms search acm transactions software engineering methodology vol 
april 
scott henninger browse repository tools refine adapt information users repository 
combination codefinder peel accomplishes goal methods support semiautomatic extraction source code components query construction techniques adaptive indexing facilities 
shows tools concert support evolution software repositories 
codefinder peel repository codefinder peel designed investigate cost benefit tradeoffs associated building repository support design process 
issues investigated domain emacs lisp customizations gnu emacs text editor cameron rosenblatt stallman 
components emacs lisp functions variables constants define email network news reader applications executed emacs text editor environment 
emacs lisp variant lisp specialized constructs primitives editing displaying text windows 
repository built files downloaded ftp sites newsgroups peel extract components translate codefinder representation henninger 
source code extracted various newsgroups devoted emacs emacs lisp issues including comp 
emacs gnu emacs sources specialized groups gnu emacs 
gnu emacs vm info 
modest effort peel resulted creation repository consisting emacs lisp functions variables macros constants distinct terms 

seeding repository seeding repository matter creating component representations indexing key terms phrases 
components take size form depending needs repository users 
peel reengineering tool translates emacs lisp files individual reusable components frame knowledge representation language named devanbu patel schneider codefinder index components create frame hierarchy retrieval concepts henninger 
peel extracts source code definitions functions variables constants macros source code file 
information extracted components translated objects 
enables expression constraints members defined frame 
frame definitions organized point repository contains source code functions data structures 
codefinder prevents placing types artifacts larger grained components supporting documentation 
desirable support higher level reuse subsystems wirfs brock johnson architectures shaw garlan biggerstaff wiederhold functionality level granularity described characteristic current software reuse repositories designed find reuse functions objects create new programs 
acm transactions software engineering methodology vol 
april 
constructing effective software reuse repositories fig 

highlighting indexing operations 
hierarchically defined restrictions 
part hierarchy emacs lisp repository shown shown 
codefinder henninger devanbu argon patel schneider fischer lemke inferencing capabilities inheritance classification retrieve information representations 
inferencing capabilities described detail devanbu patel schneider 
purposes representations viewed set attribute value slots contain information component 
peel capture information place slots 
knowledge representation system knowledge contains 
automatic extraction certainly cost effective important slots need augmenting terms au description slots 
shown component peel display source code window left hand side allow user edit part representation window right hand side 
users free augment representation terms phrases deemed useful 
nonwords esoteric abbreviations common source code terms especially important retrieving software components 
example mail systems parsed peel uses abbreviation mp message pointer system source code documentation important abbreviation needs captured 
peel uses step procedure process terms similar process extracting components basili software factory basili 
step fully automated 
terms extracted name function strings comments immediately preceding definition 
common list applied extracted terms remove common words little semantic meaning fox 
peel users augment list add terms nonsense word list operations put term word list put term acm transactions software engineering methodology vol 
april 
scott henninger fig 

representation object translated peel 
nonsense word list window shown lower part 
earlier versions peel extracted terms variable function names proved descriptive 
researchers 
second step display terms user 
users remove terms truncate list feature proved useful components name descriptive highlight term source code window show term see pop window lower part 
third step allows users add terms include phrases words separated spaces punctuation 
shows representation component named scribe environment short form source code shown 
information automatically extracted information entered source code file parsed 
include file name frame component belongs word processors frame components extracted file scribe el including scribe environment short form 
rest slots filled extracting information lisp source component 
example lisp syntax allows string parameters programmers description function 
extracted placed description slot edited peel users 
codefinder creates hyperlinks functions called component see function calls attribute 
functions displayed mouse sensitive text codefinder interface see example retrieved items pane 
displaying immediate subsystem component mouse click away 
personal conversation tom landauer lynn streeter bellcore 
reason phenomena may variables closely tied implementation function lose sight function 
descriptive function works function 
designer primary interest functions exist help perform task variable names generally useful descriptors function names comments 
acm transactions software engineering methodology vol 
april 
constructing effective software reuse repositories time peel attempt assess reusability components 
software quality considerations dictate may wish extract components score various measures halstead mccabe indicators basili 
measures advantage automatic suffer assumptions superficial information number operators variables component 
described defines infrastructure accommodate metrics providing tools find components specific functionality 

compensating incomplete inconsistent indexing major issues information retrieval interfaces need address 
nature design problems people process ill defined notion needed go solving problem belkin borgman henninger 
second problem document indexing inconsistent incomplete 
studies shown human indexers disagree terms index documents indexer different terms index document different times salton mcgill 
studies shown people surprisingly diverse set descriptors describe objects furnas 
retrieval systems built assumption quality indexing paramount factor efficacy information retrieval service fall short supporting users 
search process finding exact match biggerstaff richter henninger 
includes finding components provide partial analogous maiden sutcliffe solution problem 
inconsistent indexing exist making necessary retrieval methods algorithms go simplistic keyword matching schemes belkin croft 
traditional matching strategy queries viewed precise specifications user needs document representations precise descriptions repository objects 
alternative realistic strategy assume degree uncertainty document query representations mozer 
codefinder see designed address issues employment intelligent retrieval methods support query construction 
intelligent retrieval provided associative spreading activation retrieval algorithm mozer extends exact match paradigm retrieve items associated query 
query construction supported retrieval reformulation williams technique allows users incrementally construct queries explore information space 
empirical studies indicate combination techniques achieves performance face indexing problems ill defined information needs henninger acm transactions software engineering methodology vol 
april 
scott henninger fig 

codefinder user interface 
interface category hierarchy window displays graphical hierarchy repository 
query pane shows current query 
top part query specifies categories thing mail search 
bottom part specifies key terms related components 
retrieved items pane shows components matching current query order relevance query 
example retrieved items pane shows full entry top matching component component chosen user 
bookmarks pane holds history view viewed objects 
related terms pane shows terms retrieved query 
acm transactions software engineering methodology vol 
april 
constructing effective software reuse repositories fig 

associative network 
codefinder network consists layers nodes terms represented circles components rectangles 
boxed lines connections components terms defined terms field component 
link weights shown link boxes 
effectively minimally structured repository created peel 
retrieval spreading activation repository structure created peel collection component representations frame organization attribute value pairs see 
structure components retrieved matching query terms terms fields repository retrieve components codefinder uses parameters description fields 
codefinder uses representation construct associative network see 
associative spreading activation process connectionist relaxation procedure retrieval mozer applied network retrieve information 
users specify query consisting term component nodes 
query nodes activation value remains set value spreading activation process 
node positive activation value value passed links activation passed 
node computes sum incoming activation values modified link weight 
sum received activation values modulated fan decay parameters 
resulting value fed squashing function keep activation values boundaries asymmetrical values needed encourage flow positive activation mcclelland rumelhart 
example query specifying term remove spread value modified various parameters described component nodes vm quit vm delete message cycle vm quit vm delete message propagate computed activation values nodes connected 
example vm activate message delete 
third cycle previously activated nodes continue propagate values 
note acm transactions software engineering methodology vol 
april 
scott henninger table associative spreading activation parameters symbol definition nd number documents repository nt number distinct terms repository wij strength connection node node idf inverse document frequency document decay rate term decay rate maximum activity level minimum activity level dti number terms document number documents indexed term dt average number terms document collection df average number documents term collection document fan term fan message delete activate mail delete forward kill retrieving components directly indexed terms query 
referred query expansion salton buckley 
note delete identified kind synonym remove 
keywords dynamically related items index compensating inconsistent indexing cooccurrence relationships 
system allowed cycle procedure stabilization reached maximum number cycles reached 
stabilization occurs cycle results small changes node activation values 
spreading activation non boolean retrieval systems unlimited number documents may relevant degree 
activity values quickly dissipate activation passed away query nodes 
computational constraints codefinder allows users choose maximum number cycles henninger 
cycles usually allow partial stabilization occur retrieving associations number items removed initial query 
calculating activation values 
formally spreading activation defined activity levels documents terms discrete time units corresponding cycles 
parameter definitions table activity level document time di di di di di di remain consistent standard information retrieval technology document place component section 
acm transactions software engineering methodology vol 
april 
constructing effective software reuse repositories di previous activation valued reduced document decay rate di di net input document time di dt dti nt zero threshold identity function allow negative activation values propagate 
activity level term unit manner substituting term document parameters tj tj tj tj tj tj tj previous activation valued reduced document decay rate tj tj net input term time tj df nd 
parameters spreading activation algorithm 
activity level node combination previous activation reduced decay factor net input scaled difference previous activation value maximum minimum 
retaining part previous activity reduces wild fluctuations occur activity reaches node different times essentially integrating evidence node cycles process belew 
value fed arctan function keep values maximum minimum 
decay factor causes node lose fixed percentage activation cycle resulting exponential decay activation value time 
nodes receive initial activation lack confirming evidence form positive feedback activated nodes decay time resting value 
prevents inertia acm transactions software engineering methodology vol 
april 
scott henninger non nodes receiving activation retain forever 
terms normally outnumber documents terms serve multiple sources find relevant documents decay rates terms need set higher documents 
decay rates terms documents shown experimentally henninger mozer 
net input modified fan factor prevent nodes large numbers connections receiving unduly large amounts activation 
dividing average number terms document number terms node inflates net input nodes terms average reduces net input 
raising factor fan exponent magnifies effect provides parameter adjusted bias nodes large numbers connections eliminated 
experiments codefinder repository effectively removed fan bias henninger 
link weights 
critical part structure spreading activation systems link weighting nodes associative network 
controls amount information passed cycles 
previous spreading activation systems defined constant link weight nodes mozer 
false conjecture terms equally related item 
example terms reply mail index item vm reply safe say reply descriptive function 
reply better discriminator better describes item retrieve vm reply higher probability mail kind discrimination accomplished associative net varying weight proportion discrimination value term better discriminators having higher weights result spread larger activation values 
term item discrimination difficult define generalized manner difficult apply term component relationship large repository 
fortunately empirical observation tendency frequent terms precise terms recall precision led effective approximations furnas sparck jones 
term low frequency occurs seldom information space discriminator items indexes 
example item indexed terms indexes items indexes quite unique item retrieve high probability 
method called inverse document frequency idf proven quite effective retrieval systems number domains belkin croft salton buckley 
codefinder weight connection document descriptors acm transactions software engineering methodology vol 
april 
ji weights symmetrical ji ij constructing effective software reuse repositories connection idf log nd connected 
log nd modified form standard idf weighting scheme log df sparck jones 
modification dividing standard idf log total number documents normalizes weight values 
note weight term indexes document log log 
scheme gives weight term repository 
better discrimination measure recognize terms better discriminators certain items uniform weight items indexes 
measure term frequency tf frequency term item document salton buckley 
codefinder uses idf measure software source code objects linguistic regularity large text documents tf measures rely 
codefinder achieves individual term document weighting relevance feedback mechanisms see section 
defining relationships content induced structure 
power combination peel codefinder indexing need exhaustive codefinder effectively locate software objects 
minimal indexing peel combined spreading activation browsing tools codefinder adequately supports process locating relevant source code empirically validated user studies fischer lemke foltz kintsch henninger 
associative spreading activation model uses common connections keywords components induce relationships components terms mozer compensating queries improper terminology 
structure repository predefined term component relationships spreading activation uses retrieve information induce relationships components 
particularly salient way demonstrate effect show related keywords retrieved single word queries 
shows query delete retrieve number synonyms 
semantic relationship delete components retrieved programmed system 
structure repository terms delete remove kill cooccur components spreading activation able induce semantic relationship words 
referred structure halasz 
shows term open specified terms related things open operations acm transactions software engineering methodology vol 
april 
scott henninger fig 

capturing word relationships content induced structure 
highest rated terms relevant query related terms pane appearing order highest top lowest bottom activation value semantically related queries shows results query delete specified uses term kill uses open 
server connection host retrieved addition synonyms launch opened note terms normally considered synonyms terms frequently cooccur programming idioms 
screen images shown retrieved directly emacs lisp repository created peel augmentation repository sampling kinds semantic relationships derived spreading activation 
extent adequate associative structure exists kinds relationships 
spreading activation able find semantically related words captures idiosyncratic term usage repository 
example relationship delete kill captures programming idiom term kill refers deleting object 
addition programs view mail kyle jones uses term delete deleting messages kill referring removing files 
shown delete query retrieved terms related messages kill query number words related files 
kind idiosyncratic term usage missed traditional thesaurus methods equivalence classes words important domains generate idiomatic terminology describe complex concepts software development medical fields 
associative spreading activation uses structure repository find idiomatic word relationships additional labor intensive effort predefine word relationships 
computed word relationships displayed related keywords pane see provide cues reformulating query 
acm transactions software engineering methodology vol 
april 
constructing effective software reuse repositories retrieval reformulation soft matching algorithms retrieval systems reduce effects poor repository structure supporting process query construction 
retrieval reformulation method supports incremental query formation building query results williams 
time user specifies query system responds query reformulation cues give users indication repository structured terms index objects 
users incrementally improve query critiquing results previous queries 
supports refinement information needs accumulating knowledge acquired search process narrowing solution 
rabbit williams fischer lemke examples retrieval systems retrieval reformulation paradigm 
codefinder supports retrieval reformulation providing number retrieval cues interface 
important example components appearing example retrieved items pane see 
pane shows full representation component allowing user choose attributes inclusion exclusion query 
retrieval reformulation accomplished mouse action allows users simply point click components included query 
example user wanted add term subject shown terms attribute component vm kill subject simply click left term 
term placed terms field query pane retrieve button command pane displayed bold indicating query changed 
choosing retrieve button retrieve information new query 
codefinder enhances retrieval reformulation paradigm ways 
items automatically placed appropriate part query 
opposed query languages users responsible structure content queries users spared cognitive overhead deciding put attribute category term 
second codefinder imposes ranking criteria retrieval set automatically displaying highest rated item query 
important example provides cues characterize kinds items retrieved query improved 
better example easier converge satisfactory solution 
selecting example addressed previous retrieval reformulation systems 
example organized retrieval set alphabetic order displayed example ordering fischer lemke 
third codefinder displays terms related terms pane step process retrieval take nontrivial amount time large repositories 
users wish multiple changes query wait time change 
retrieve button puts users control potentially time consuming operation takes place 
acm transactions software engineering methodology vol 
april 
scott henninger fig 

situation system models 
shown figures 
terms ranked order relevance query refine query 

supporting incremental refinement component repositories components captured minimal structure necessary evolve structure meet needs development organization 
necessary improve indexing structure repository keep information current knowledge organization evolves henninger 
innovative intelligent retrieval tools repository effectiveness influenced quality indexing 
problem indexing quality relative measure depending retrieval context arising different information needs perspectives differ individuals different information needs different times different users different backgrounds harter 
effective repository structures designed front allowed evolve context 
ultimate goal component repository create indexing scheme similar knowledge structures possessed programmers working application area curtis 
date little research directed characterizing nature knowledge structures 
potentially useful line research studied relationship people model problem solution spaces kintsch 
theory distinguishes situation model designer model application domain specific problem faced system model set resources provided system programming languages environments example 
relationship models shown translation 
initial high level conceptualization users problem needs translated language index desired items 
effectiveness repository improved minimizing mismatch situation system models 
formidable problem demonstrated derived empirical study asked people keywords describe object henninger 
acm transactions software engineering methodology vol 
april 
constructing effective software reuse repositories note users conceptualize retrieval problem terms application goal system terminology refers object implemented 
users unfamiliar implementation model difficulty finding desired functionality 
merely structure place structure user understand supports user model system 
curtis notes empirical studies shown programmers gain experience understanding knowledge particular domain common structure curtis 
empirically shown indexing structures adaptive systems converge common themes groups similar interests belew 
difficult anticipate design needs uses design artifacts advance group users working moderately homogeneous environment tend approach problems similar terminology 
studies shown great deal effort project directed creating mutual understanding problem developers walz 
best opportunity capture typical situations provide means easily modify repository 
provides critical insight designers view domain characteristics situation models 
adapting repository context adaptive techniques improve repository applied recording user actions incrementally changing representations actions 
users interact system system migrate indexing scheme kinds application goals typically encountered users 
goal system gradually build consensual representation user knowledge rose belew change knowledge organization evolves 
bellcore study people choosing terms describe common objects cooking recipes editor commands items revealed probability people choosing keyword objects furnas 
aliases achieve agreement aliases get agreement 
led notion unlimited aliasing term applied user describe object descriptor index term object furnas 
note aliasing different traditional thesaurus methods equivalence classes terms aliasing terms point directly objects terms thesaurus 
problems unlimited aliasing approach potential precision problems 
terms describe objects repository probability system retrieving unwanted objects increases 
studies retrieval systems large numbers aliases shown precision problems severe theory expect gomez 
occurs practice terms acm transactions software engineering methodology vol 
april 
scott henninger object necessarily imply objects term theoretical notion precision ratio irrelevant objects retrieved total retrieval set matters recall ratio relevant objects retrieved total retrieval set interactive retrieval environment 
words long relevant objects retrieved people able find objects matters irrelevant objects retrieved 
method achieve unlimited aliasing unwanted precision problems adaptive indexing furnas 
method collects term usage data interactively process real information seeking sessions adding terms object representation search satisfied document 
codefinder supports unlimited aliasing adaptive indexing tracking term usage retrieval session allowing users associate terms indexing representation selected item 
process constructing query browsing information space user remove number terms query enter terms system lexicon case error message warning deficiency posted 
terms evidence situation model initial way thinking retrieval problem 
may terms current query item current representation 
adding terms chosen item may enhance item guard situations misspellings undesired terms retrieval session 
codefinder addresses issue displaying information user inspection possible modification 
terms user click choose button example retrieved items pane see example matching items pane 
clicking button number semantics placing example editor buffer invoking case tools analyze component fischer 
occurs adaptive indexing session invoked shown 
users option add items current representation chosen example allowed enter terms needed 
repository users modify repository structure part codefinder pull menus shown middle top henninger 
kind modification best handled repository librarian important facility enables evolution repository 
adjusting link weights relevance feedback addition assigning new terms component representation code finder uses relevance feedback adjust term component link weight 
relevance feedback typically reformulate query usually adding document representation query salton buckley 
codefinder accomplishes allowing users click acm transactions software engineering methodology vol 
april 
constructing effective software reuse repositories fig 

adaptive indexing codefinder 
circles right hand side retrieved items pane see 
item chosen placed query see related items portion query pane part spreading activation query 
codefinder uses action indication chosen components relevant terms shown terms portion query pane 
strengthening link weight components terms increase probability similar queries get better retrieval results 
localized reinforcement belew learning technique normally adjusts weights activating input nodes results target vector output strengthen weights 
user feedback codefinder lieu target 
association wish strengthen terms query components chosen relevance feedback 
component chosen relevance feedback indexed terms query weights adjusted learning rule rose belew ij ij ia activation value document node feedback node user binary value codefinder learning rate usually value 
values adjusted arctan squashing function keep values 
knowledge link weights smolensky potentially important contribution effectiveness spreading activation 
unfortunately evaluating effectiveness method runs acm transactions software engineering methodology vol 
april 
scott henninger fig 

codefinder architecture 
credit assignment problem weights responsible results changed improve performance 
empirical studies shown retrieval performance improve time especially groups homogeneous interests belew 

design evaluation codefinder implementation general architecture codefinder shown 
codefinder interface built symbolics lisp machine 
reasons efficiency scaling repository spreading activation calculations implemented routines executed unix machine 
socket interface pass information different operating systems 
peel takes lisp source files inputs produces objects 
create matrix codefinder extracts terms objects creates series tuples form term item term database object 
unix side tuple inserted sparse matrix representation statistics accumulated spreading activation parameters 
acm transactions software engineering methodology vol 
april 
constructing effective software reuse repositories implementation spreading activation straightforward matrix multiplication adjustments algorithm parameters 
connections terms documents represented connection matrix vector containing documents terms 
initial query represented vector length query nodes terms documents set 
vector multiplied matrix resulting vector sums net input nodes connected query 
nodes adjusted algorithm parameters 
resulting vector multiplied connection matrix compute cycle 
matrix multiplication especially large matrices expensive operation 
fortunately associative networks sparsely populate matrix allowing greater computational efficiency sparse matrix multiplication algorithms 
especially true structured associative networks codefinder allow links terms components 
response time second achieved emacs lisp repository decstation rudimentary sparse matrix multiplier 
computational complexity algorithm proportional sparse matrix multiplication algorithm implement spreading activation 
faster hardware better sparse matrix multiplication algorithms easily accommodate repositories tens thousands items acceptable performance 
codefinder allows storage matrix representation unix side matrix creation step omitted 
updates matrix adaptive indexing facilities see section handled sending tuples matrix creation module inserts tuple matrix updates parameters 
new term unique appear repository done 
existing term added component new term item association changes link weight term keep mind weights determined idf measure 
weight adjusted component term associated 
empirical evaluation codefinder experiment conducted assess effectiveness codefinder interface retrieval methods minimal structures structure derived peel benefit adaptive indexing henninger 
subjects tasks involved finding software components functionality 
tasks adapted observations people developing software emacs lisp environment 
codefinder compared software component retrieval systems direct matching retrieval algorithms limited capabilities reformulating queries 
systems assessed ability help subjects solve problems dimensions problem definition defined directed ill defined vocabulary match match mismatch 
results showed differences systems pronounced tasks ill defined vocabulary mismatch acm transactions software engineering methodology vol 
april 
scott henninger categories henninger 
codefinder scored best categories subjects finding items faster 
results indicate subjects problems systems straightforward matching algorithms problems ill defined vocabulary mismatched 
greater degree success codefinder indicates soft matching retrieval algorithms spreading activation coupled query construction techniques necessary adequately support kinds tasks typically encountered developers searching information reusable components 
important underscore fact results consequence codefinder interface just spreading activation algorithm 
experiment designed evaluate interface retrieval algorithms evaluation criteria differed traditional recall precision measures salton mcgill focusing subject ability system features find relevant information 
results agree studies concluding retrieval methods insufficient gain performance advantage frakes pole 
able control effects spreading activation retrieval reformulation henninger hypothesis codefinder better performance due part coupling methods 
studies needed verify results improve understanding observations 

directions described article rooted need software development tools support process finding components reuse 
true perfectly constructed indexed component repositories relevant components easy find reality pragmatic inherent circumstances prevent creation repositories 
ill defined nature design problems problem difficult index components 
problem unfamiliar esoteric vocabulary software design process difficult potential find useful components 
difficult costly anticipate needs component 
perfection achieved fact people diverse vocabulary describe diverse information needs prevent users finding proper components 
addition costly structures required retrieval static unable adapt dynamic development contexts 
structures created set stone changeable complex procedures involve redesigning entire repository 
methods needed provide adequate retrieval effectiveness minimal indexing structuring efforts allowing organizations take advantage valuable assets accumulated previous development efforts large front investment reusability help acm transactions software engineering methodology vol 
april 
constructing effective software reuse repositories repository evolve changing needs people software development organization 
article presents approach supporting kind lifecycle repositories 
repositories initially seeded structure index terms peel tool extracts repository information emacs lisp source code 
codefinder supports retrieval process retrieval reformulation spreading activation help users find components face perfect repository structures indexing 
codefinder find components users opportunity add structure index terms repository improving repository reflect kinds problems repository users typically encounter 
process advantage avoiding costly repository populating efforts capturing information may useful people encountering similar information needs 
empirical studies shown codefinder able adequately support process finding relevant software components minimal structures indexing performed peel henninger 
results study merely provide evidence effectiveness repository tools provided codefinder 
studies needed better understand nature retrieval process context software development 
longitudinal studies context software development organizations needed assess utility limitations adaptive facilities codefinder 
studies nature promise bring better understanding satisfy information needs problem solving contexts repositories evolve effective time 
studies pointed number improvements needed peel codefinder tool set viable tool development organizations 
time attempt assess reusability components capture component metrics 
way apply methods described article larger gain software components code artifacts henninger henninger 
studies needed compare codefinder repository retrieval methods faceted classification prieto az freeman front repository construction costs methods comparisons difficult 
order software reuse methodologies feasible effective methods needed exploit valuable assets exist development organizations form existing code modules developed saved thought reuse 
tools building repository developed extract modules represent repository form amenable specific set retrieval tools 
takes steps addressing issues 
needed refine ideas subject rigorous empirical studies assess effectiveness learn nature component repositories built support software reuse techniques 
acm transactions software engineering methodology vol 
april 
scott henninger acknowledgments members gerhard fischer human computer communication group university colorado especially peter foltz gerhard fischer walter kintsch david redmiles stevens discussions shared ideas discussed article 
generous donations reusable software lemke jonathan gave codefinder initial start 
barnes 
making reuse cost effective 
ieee softw 

batory singhal thomas 
genvoca model software system generators 
ieee softw 

belew 
adaptive information retrieval machine learning associative networks 
ph dissertation tech 
rep univ michigan ann arbor mich belkin croft 
retrieval techniques 
ann 
rev inf 
sci 
tech 

belkin croft 
information filtering information retrieval sides coin 
commun 
acm dec 
belkin oddy brooks 
ask information retrieval part 
doc 

belkin oddy brooks 
ask information retrieval part 
doc 

biggerstaff 
assessment analysis software reuse 
adv 
comput 

biggerstaff richter 
reusability framework assessment directions 
ieee softw 


decision making online searching 
am 
soc 
inf 
sci 

blair maron 
evaluation retrieval effectiveness full text document retrieval system 
commun 
acm apr 
booch 
software components ada 
cummings menlo park calif borgman 
users information retrieval systems created equal exploration individual differences 
inf 
process 
manage 

brachman mcguinness patel schneider resnick borgida 
living classic kl language 
principles semantic networks explorations representation knowledge sowa ed 
morgan kaufmann san mateo calif 
burton aragon bailey koehler 
reusable software library 
ieee softw 

basili 
identifying qualifying reusable software components 
computer 
cameron rosenblatt 
learning gnu emacs 
reilly assoc sebastopol calif chen jarke 
retrieval reusable software components 
advances software reuse proceedings nd international workshop software reusability 
ieee computer society press los alamitos calif 
curtis 
cognitive issues reusing software artifacts 
software reusability 
vol 
applications experience biggerstaff perlis eds 
addison wesley reading mass 
devanbu brachman selfridge ballard 
knowledge software information system 
commun 
acm may 
acm transactions software engineering methodology vol 
april 
constructing effective software reuse repositories fischer lemke 
extending retrieval reformulation paradigm 
human factors computing systems chi conference proceedings 
acm new york 
fischer henninger redmiles 
cognitive tools locating comprehending software objects reuse 
th international conference software engineering 
acm new york 
fischer mccall reeves shipman 
seeding evolutionary growth reseeding supporting incremental development design environments 
proceeding conference computer human interaction chi 
acm new york 
foltz kintsch 
empirical study retrieval reformulation 
tech 
rep inst 
cognitive science univ colorado boulder fox 
lexical analysis 
information retrieval data structures algorithms frakes baeza yates eds 
prentice hall englewood cliffs 
frakes 
representing reusable software 
inf 
softw 
tech 

frakes 
software reuse information retrieval 
th hawaii international conference system sciences 
ieee computer society press los alamitos calif 
frakes pole 
empirical study representation methods reusable software components 
ieee trans 
softw 
eng 

furnas 
experience adaptive indexing scheme 
human factors computing systems chi conference proceedings 
acm new york 
furnas landauer gomez dumais 
vocabulary problem human system communication 
commun 
acm nov 
gomez lochbaum landauer 
right words finding want function richness indexing vocabulary 
am 
soc 
inf 
sci 

halasz 
reflections notecards issues generation hypermedia systems 
commun 
acm july 
harter 
psychological relevance information science 
am 
soc 
inf 
sci 

henninger 
iterative refinement find reusable software 
ieee softw 

henninger 
information access tools software reuse 
syst 
softw 

henninger 
organizational learning approach domain analysis 
th international conference software engineering 
acm press new york 
henninger 
locating relevant examples example software design 
ph dissertation univ colorado boulder kintsch 
understanding solving word arithmetic problems 
psychol 
rev 
lakoff 
women fire dangerous things categories reveal mind 
university chicago press chicago ill maarek smadja 
full text indexing lexical relations application software libraries 
proceedings sigir 
acm new york 
maarek berry kaiser 
information retrieval approach automatically constructing software libraries 
ieee trans 
softw 
eng 

maiden sutcliffe 
exploiting reusable specifications analogy 
commun 
acm apr 
mcclelland rumelhart 
interactive activation model context effects letter perception part account basic findings 
psychol 
rev 
acm transactions software engineering methodology vol 
april 
scott henninger mozer 
inductive information retrieval parallel distributed computation 
ics rep inst 
cognitive science univ california san diego la jolla calif hendler prieto az braun 
computing similarity reuse library system ai approach 
acm trans 
softw 
eng 
methodol 

patel schneider brachman levesque 
argon knowledge representation meets information retrieval 
proceedings st conference artificial intelligence applications 
ieee computer society press los alamitos calif 

reuse metrics return investment model 
advances software reuse 
ieee computer society press los alamitos calif 
prieto az 
software classification scheme 
ph dissertation tech 
rep univ california irvine irvine calif prieto az 
implementing faceted classification software reuse 
commun 
acm may 
prieto az 
domain analysis software systems modeling 
ieee computer society press los alamitos calif prieto az freeman 
classifying software reusability 
ieee softw 

rose belew 
connectionist symbolic hybrid improving legal research 
int 
man mach 
stud 

salton buckley 
term weighting approaches automatic text retrieval 
inf 
process 
manage 

salton buckley 
improving retrieval performance relevance feedback 
am 
soc 
inf 
sci 

salton mcgill 
modern information retrieval 
mcgraw hill new york 
shaw garlan 
software architecture perspectives emerging domain 
prentice hall englewood cliffs simos levine 
organization domain modeling odm guidebook 
stars vc reston va smolensky 
proper treatment connectionism 
behav 
brain sci 

sommerville wood 
software components catalogue 
intelligent information systems progress prospects 
davies ed 
ellis horwood limited chichester 
sparck jones 
statistical interpretation term specificity application retrieval 
doc 

sparck jones 
index term weighting 
inf 
storage 

stallman 
emacs extensible customizable self documenting display editor 
acm 

thompson croft 
support browsing intelligent text retrieval system 
int 
man mach 
stud 

walz curtis 
inside software design team knowledge acquisition sharing integration 
commun 
acm oct 
wiederhold wegner ceri 

commun 
acm nov 
williams 
rabbit run 
int 
man mach 
stud 

wirfs brock johnson 
surveying current research object oriented design 
commun 
acm sept 
received july revised february accepted november acm transactions software engineering methodology vol 
april 
