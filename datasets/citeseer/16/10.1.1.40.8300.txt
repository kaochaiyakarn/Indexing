categorical fixed point calculus roland backhouse marcel rik van jaap van der may number lattice theoretic fixed point rules generalised category theory applied construction isomorphisms list structures 
category theoreticians view preordered set particular sort category arrow pair objects 
view concepts lattice theory instances concepts category theory shown table 
alternative viewpoint advocated lambek lattice theory valuable source inspiration novel results category theory 
view purposes advancing programming methodology category theory may profitably regarded coherently constructive lattice theory 
say arrows objects category may seen witnesses objects 
category theory constructive theory construct witnesses theory solely existence 
category theory coherently constructive theory relations witnesses existence commuting diagrams naturality properties 
adopting view category theory theory contribution programming methodology likened contribution constructive type theory viz 
emphasis program construction product manipulation types 
contribution practical application ideas 
develop number fixed point rules category theory inspired generalises fixed point rule lattice theory 
apply rules construction number elementary fundamental isomorphisms list structures 
number rules derive appear new important department computing science eindhoven university technology netherlands 
remarked say preorder theory lattice theory 
point view computing science category sums products little relevance 
lattice theory source inspiration 
lattice theory instance concept category theory concept preorder category monotonic function functor pointwise ordering natural transformation functions functors supremum colimit initial galois connection adjunction prefix point algebra closure operator monad table lattice theory versus category theory contribution may collected illustrated application equational reasoning list structures 
notation terminology section give brief summary notational conventions 
suppose category 
write denote object category arrow codomain domain identity arrow object denoted id identity endofunctor category denoted id just id clear category intended 
typically composition arrows denoted ffi irrespective category ffi functors denote composition ffl application functor object arrow denoted infix dot category functors category category denoted fun functor category construct functors ffl fun fun ffl fun fun definition ffl follows 
functor fun ffl ffl application ffl natural transformation fun denoted ffl defined pointwise ffl object similarly functor fun ffl ffl application ffl natural transformation fun denoted ffl defined pointwise ffl object standard notation fj jf advantage explicitly denoting composition multiple character identifiers name natural transformations functors 
general convention sans serif identifiers constants denoting specific natural transformations 
application functors takes precedence composition arrows parentheses dictate 
example ffl ffi ffl denotes ffl ffi ffl convention pointwise composition natural transformations denoted usual arrow composition 
assume familiarity algebraic properties expressions 
properties refer hint rules 
shall occasion refer arrow category arr objects arr arrows arrows arr commuting squares 
arr ffi ffi note functors natural transformation functor arr defined arrows fact notions equivalent functor arr natural transformation components 
justifies dot notation ffl introduced composition functors 
malcolm fokkinga denote unique arrow category object initial object banana bracket notation initial arrows objects notion category theory corresponds notion prefix point lattice theory known algebra suppose category endofunctor algebra arrow type object codomain algebra referred carrier algebra 
category called base category algebras organised category alg follows 
objects algebras arrows algebra algebra characterised equation alg cod cod ffi ffi cod denotes codomain functor base category alg alternatively category alg may defined subcategory arr consisting arrows definition give weaker terminological confusion leads having lambek 
standard computing scientists 
see example 
form codomain functor alg suitably restricted component functor arr initial algebra initial object category alg existence initial algebras harder predict existence prefix points 
generalisations category theory knaster tarski theorem considered lambek 
purposes suffice assume initial algebras require exist 
particular assume endofunctor canonical initial algebra denoted muf carrier codomain canonical algebra denoted muf choice notation facilitates comparison categorical fixed point theorems lattice theoretic theorems generalise 
banana bracket notation unique arrow algebra ff initial algebra fi denoted alg ff fi usually abbreviate ff fi absolutely question intended omit argument write ff fi adjunctions defined terms unit counit adjunction terms natural isomorphism hom sets 
case definition useful name components isomorphism terms lower upper denote floor ceiling operators suggested fokkinga adjoint functors lower adjoint dfe similarly inverse isomorphism objects category denoted fixed point calculus section basic fixed point theorems theorems result combining basic theorems 
basic fixed point theorems respectively fusion rule rolling rule abstraction theorem diagonal rule 
fusion rule combines concept initial algebra concept adjunction 
rolling rule generalises property commonly known category theoreticians lambek lemma initial algebras fixed points 
lattice theory generalises property prefix point monotonic function fixed point rolling rule elementary called important right extremely useful combination rules 
instance exchange rule combination rolling rule fusion rule 
exchange rule called states lower adjoints may exchanged construction initial algebras 
second instance rolling rule iterated square theorem 
abstraction theorem combines concept initial algebra concept parameterisation 
basic fixed point rule diagonal rule captures basic principle decomposing construction initial algebra construction succession algebras 
lattice theory fusion rule appears slightly different form cousot cousot abstraction theorem exchange rules novel rolling diagonal rules folklore know credited widely known 
straightforward exercises versed lattice theory know publication stated subset applications 
category theory fusion rule derived independently hermida jacobs abstraction theorem exchange rules novel 
rolling rule form derived lambert meertens unpublished discussion notes 
diagonal rule stated proved categories aware publication stating theorem level generality 
lattice theory abstraction fusion theorem easily combined prove theorem dubbed beautiful dijkstra scholten 
category theory combination abstraction fusion theorems leads similarly beautiful theorem important special instance preserved process constructing initial algebras 
derivation theorem illustration view category theory coherently constructive lattice theory 
categorical fixed point rules previously studied freyd 
freyd defines category algebraically complete endofunctors category initial algebras 
proves product algebraically complete categories algebraically complete observes rolling rule corollary 
intermediate result iterated square theorem mentioned earlier 
theorems included purposes comparison corollaries basic theorems 
freyd blanket assumption algebraic completeness able establish stronger versions freyd theorems 
particular rolling diagonal rules stronger derived freyd theorems 
see section discussion 
space reasons omit proofs rules 
complete proofs 
fusion theorem fusion theorem fact immediate corollary theorem theorem adjunction functors assume swap ffl ffl natural isomorphism 
adjunction categories alg alg specifics unit counit denote unit unit denote lower upper adjunction respectively 
isomorphism swap gives rise isomorphism ffl ffl defined ffl counit ffi swap ffl functor alg alg defined ffi swap cod alg arrow alg lower adjoint upper adjoint functor alg alg defined ffi cod alg arrow alg left adjunction defined arrows alg right defined similarly 
theorem fusion rule assumptions theorem additional assumption alg initial object mug mug ffi swap initial object category alg initial algebra mug ffi swap consequence isomorphism base category specifics isomorphisms mug ffi swap arrow ffi mug mug inverse 
don give proofs fixed point rules details specifics section theorem seen trace proofs isomorphism constructed mutual containment argument arrows witness individual containments component arrows witnesses step proof 
occurrences composition example witness transitivity ordering relation occurrences banana brackets witness minimality algebra 
proof fusion theorem consists constructive proof inclusions followed verification fact witnesses inverses 
subsequent applications fusion theorem need know details witnesses isomorphism need know isomorphisms exist 
abbreviate mug ffi swap fuse swap rule applications assuming conditions fusion theorem satisfied fuse swap rolling square exchange rules theorem rolling rule functors 
suppose mu ffl initial ffl algebra 
mu ffl initial ffl algebra 
initial ffl algebra mu ffl mu ffl mu ffl consequence isomorphism base category ffl ffl specifics isomorphisms mu ffl mu ffl arrow ffl ffl mu ffl ffi mu ffl mu ffl inverse 
letting roll denote mu ffl mu ffl roll ffl ffl substituting find mu ffi mu mu algebra denotes ffl 
freyd observes initial algebra establishing existence initial algebra existence initial algebra 
calls theorem iterated square theorem 
observes existence initial algebra guarantees existence initial algebra provided category products 
corresponding theorems lattice theory prefix point monotonic prefix point prefix point prefix point preorder having infima 
particular precise statement freyd theorem follows 
theorem iterated square endofunctor mu exists 
mu ffi mu mu initial algebra unique arrow algebra alg ffi mu category products initial algebra muf induces initial algebra muf ffi muf final theorem section combines rolling rule fusion theorem 
theorem exchange rule functors lower adjoints adjunctions 
furthermore isomorphism mirror ffl ffl ffl ffl assume initial ffl algebra mu ffl initial ffl algebra mu ffl exist 
ffl ffl specifics isomorphism roll ffi fuse ffl ffl mirror mu ffl witness ffl ffl roll ffi fuse ffl ffl mirror mu ffl inverse 
note exchange rule give isomorphism algebras carriers 
denoting witness isomorphism ffl ffl exch mirror rule exch mirror ffl ffl provided course mirror satisfy conditions exchange rule 
second exchange rule order reversed 
third rule involving functors combines 
exchange rule section 
abstraction theorem standard way constructing functors inductively uses abstraction argument binary functor 
phi thetad binary functor 
phi induces binary functor arbitrary category phi fun fun defining composition phi ffl embedding ffl fun fun thetad diagonal functor 
phig phi ffl ffl phi phi ffl ffl particular object object arrow phig phi phi phi left section phi phi defined phi phi id endofunctor may consider algebras 
assuming existence initial phi algebras fixing mu phi phi phi phi construct initial algebra functor mu phi arr defining mu phi ffi phi mu phi mu phi mu phi mu phi corresponding carrier functor cod ffl mu phi codomain functor initial algebra functor known map functor denote phi objects arrows phi phi phi case cons lists example define list functor phi functor phi maps pair thetax abstraction theorem states map functor initial algebra 
precisely mu phi arr mu phi phi id phi phi follows earlier discussion correspondence functors arrow categories natural transformations initial algebra functor natural transformation mu phi phi id phi phi id phi algebra 
theorem states mu phi initial id phi algebra 
words abstracting parameter initial algebra yields initial algebra 
theorem abstraction theorem phi thetad binary functor written infix operator 
assume existence canonical initial algebra mu phi codomain phi object define initial algebra functor mu phi 
mu phi initial algebra id phi arbitrary mu id phi denotes particular initial id phi algebra having codomain id phi mu id phi mu phi id phi phi specifics isomorphisms mu id phi mu phi carriers mu phi mu id phi arrow phi id phi natural transformation ff defined ff mu id phi mu phi object inverse 
note abstraction theorem generalised replacing functor id functor defining binary infix functor omega omega phi corresponding assumptions omega mu id omega mu phi mu omega phi ffl phi omega 
witness denoted abs phi calculation rule abs phi phi ffl phi 
diagonal rule theorem diagonal rule phi thetac binary functor 
assume object initial object mu phi exists alg phi define functor denote unary functor id phi mu phi initial object alg phi mu phi mu phi phi initial object category alg initial algebra mu mu phi mu phi phi mu conversely mu initial object alg mu ffi mu phi ffi id phi mu initial object category alg phi initial phi algebra mu phi mu ffi mu phi ffi id phi mu mu phi consequence isomorphism base category phi 
phix phiy specifics isomorphisms mu phi mu phi phi mu arrow phi mu ffi mu phi ffi mu phi id mu phi convenience omit subscript inverse 
fusion rolling rules need specific details witnessing isomorphisms 
introducing abbreviation diag phi isomorphism phi rule apply subsequent calculations diag phi 
phiy phix mutual recursion previous sections basic rules categorical fixed point calculus fusion rule rolling rule abstraction theorem diagonal rule 
topic section relationship basic rules particular rolling rule diagonal rule freyd discussion algebraically complete categories 
commencing discussion emphasise diagonal rule parts existence initial phi algebra initial algebra existence initial algebra initial phi algebra isomorphism base category carriers types initial algebra 
adapting freyd terminology preorder algebraically complete monotonic preorder prefix point 
known theorem attributed winskel bekic source product algebraically complete preorders algebraically complete 
specifically suppose algebraically complete preorders thetad thetad decompose binary functions fi thetac omega thetad way omega prefix point 

omega omega shown mutual recursion theorem corollary diagonal rule lattice theoretic iterated square theorem 
proof transformed proof freyd theorem product algebraically complete categories algebraically complete 
see full details 
deriving mutual recursion theorem diagonal rolling rules freyd establishes mutual recursion theorem observes rolling rule special case 
rolling rule weaker demands existence initial ffl algebra initial ffl algebra 
rule assumes existence order guarantee existence 
way deriving rolling role appears texts programming language semantics 
see example 
quite easy see part diagonal rule isomorphism carriers types initial algebra consequence mutual recursion theorem define omega phiy 
mean diagonal rule way weaker mutual recursion theorem 
contrary rule sharper gives sharper conditions existence initial algebras product category freyd blanket assumption algebraic completeness component categories parts diagonal rule aware way deriving parts freyd mutual recursion theorem 
summary rolling diagonal rules give tighter conditions existence initial algebras freyd mutual recursion theorem corollary 
applications lattice theory basic fixed point rules amount effective equational fixed point calculus 
variety examples see 
categorical fixed point rules amount effective equational constructive fixed point calculus 
say isomorphisms type structures obtained product equational arguments lattice theoretic fixed point calculus 
section illustrate method deriving number isomorphisms list structures 
case calculation lattice theory augmented witnesses mechanical way 
calculations natural transformations isomorphisms ary functors play dominant role need notational conventions deal constant arguments 
consider product categories responsible arity associative connector functors construct functors ary codomain 
example functor thetad thetad defined objects arrows 
usual product functors denoted 
natural transformation say ternary functors functor ternary domain ffl natural transformation ffl ffl suitable may change arity 
example functor id denotes constant functor fixes arguments turning unary functor ternary functor similarly id id fixes ffl ffl prefer suggestive notations respectively 
example section natural isomorphism leapf binary functors say psi fi leapf ffl natural transformation psi fi convention leapf ffl id leapf ffl ffl id id leapf ffl ffl id id leapf ffl id leapf ffl id leapf leapfrog rules ways lists defined cons lists elements added consed lisp terminology list snoc lists elements involving equalities opposed proofs equality mutual containment 
added reverse cons list join lists lists joined 
consider cons snoc lists 
cons list functor map functor phi see phiy thetay snoc list functor map functor psi thetax order able consider definitions section consider situation unary functor binary functor omega replacing theta respectively omega omega lower adjoints object define map functors ffl phi ffl phi ffl binary binary functor interchanges coordinates 
cons list functor instantiation choosing omega theta omega theta ffl respectively 
similarly snoc list functor instantiation interchanged choices omega application fixpoint rules states isomorphic functors provided obeys called leapfrog property respect omega reading proofs recommend witnesses ignored time 
ignore marked bullet membership information 
stripped information proof obtained lattice theoretic proof 
theorem suppose id omega omega id lower adjoints natural isomorphism natural parameters leapf omega omega omega omega define map functor phi map functor psi phi ffl omega psi ffl omega ffl 
useful name important properties 
call existence isomorphism leapf theorem leapfrog property parameter side functor proof ff abstraction ffl ff abs id phi ffi fi ffi abs id psi fi id phi id psi id phi ffl ffl id omega id psi ffl ffl omega id fi ffl ffl id omega ffl ffl omega id exchange rule id omega omega id lower adjoints ffl fi exch ffl id omega omega id fl fl omega id ffl ffl ffl id omega id omega ffl ffl ffl omega id omega id ffl ffl ffl id omega ffl id omega omega id id omega ffl ffl ffl omega id id omega ffl omega id see discussion preceding subsection 
fl leapf ffl id abs id phi ffi exch ffl id omega omega id leapf ffl id ffi abs id psi construction repeatedly applied giving application shows process preserves leapfrog property provided omega associative isomorphism 
theorem leapfrog preservation suppose functor omega binary functor omega omega lower adjoints object define map functor ffl omega suppose natural isomorphisms ass omega omega omega omega leapf omega omega omega omega omega omega omega omega proof letting ffl omega omega ffl omega omega omega ffl ffl omega brevity subscripts fuse ff omega omega omega omega definition ff omega ffl omega omega omega ffl omega omega invent intermediate omega ffl ffl omega ffl ff fi ffi fl fi omega ffl omega omega omega ffl ffl omega fl omega ffl omega omega omega ffl ffl omega fusion ffl fi fuse omega fl fuse omega omega ffl ffl omega omega omega ffl ffl omega ffl omega omega ffl ffl omega omega omega ffl ffl omega ffl omega ass omega omega omega ffl omega ass omega ffl omega omega ffl omega ffl omega ffl ffl ass ffi ffi omega ffl ffl ass ffl omega ffl ffl ass omega ffl ffl omega ffl omega omega ffl ffl omega ffl omega definition leapf leapf ffl omega conclude fuse omega omega ffl ffl ass ffi leapf ffl omega ffi omega ffl ffl ass ffi fuse omega omega ffl ffl ass witnesses isomorphism omega omega omega omega note order combine theorems show example isomorphic need show isomorphism constructed theorem natural parameters general impossible task section argue immediately case kleene functors 
lists section prove isomorphisms certain list structures simultaneously construct witnesses 
simple instantiations leapfrog rules subsection 
formally assume base category bicartesian exponential category 
specific details assumption follows 
denoting product thetab sum assumed exist assume objects functors theta thetay functor theta left right argument fixed upper adjoints 
second denoting terminal object base category assume existence isomorphisms 
objects thetaa theta proass thetab thetac theta thetac rdist thetac thetac thetac theta thetab thetac order instantiate fusion theorem suffices know lower adjunction thetay lower adjoint exponentiation upper adjoint operation known currying functional programmers upper uncurrying counit function evaluation 
example defining functor functor clist 
thetay slist 

thetaa functor isomorphism clist slist proof instantiate theorem omega theta ass proass leapf rdist thetab ffi ffi proass ffi thetaa consider cons lists cons list functor denoted asterisk 
assume functor defined map functor phi see phiy thetay contrast normal functor applications omit dot functor applied object 
example theta thetaa thetab thetaa proof instantiate theorem omega theta ass proass leapf rdist thetab ffi ffi proass ffi thetaa note apply leapfrog theorem instantiated provided naturality proven see section 
language theory new obtained equal 
category theory obtain new theorem isomorphic 
leapfrog theorem infinite number applications 
equality language theory boils equality isn constructively valid 
final example chosen relative difficulty practical relevance 
call list decomposition problem 
instance called lines problem sequence types characters delimiters non delimiters write program divide sequence possibly empty lines non delimiters single delimiters 
construct addition inverse program 
calculation employ notation witnesses isomorphisms included hints marked bullet ffl 
specifically proof step form hint ffl ff short ff hint list composition problem expressed isomorphism datatypes boils showing star decomposition theorem regular languages constructively valid 
example list decomposition theta theta proof theta theta definition theta 
theta thetay rules ffl id theta fuse ffl proass theta 
theta thetay rolling rule ffl roll theta denotes functor 
thetay 
theta thetay fusion rule ffl fuse ffl 
thetay diagonal rule ffl diag phi thetay 
thetay thetay fusion rule ffl fuse ffl theta theta ffi ffl rdist 
thetay definition conclude id theta fuse ffl proass ffi roll theta ffi fuse ffl ffi diag phi ffi fuse ffl theta theta ffi ffl rdist theta theta 
thetay thetay theorems free list decomposition example proved isomorphism base category instantiations objects formally shown isomorphism binary functors object parts 
theta theta 
prove constructed isomorphisms natural parameters list leapfrog example 
known naturality wadler dubbed theorem free 
section briefly explain theorem free specifically role abstraction theorem claim 
key note statements bicartesian exponential category lifted statements functor category pointwise parameterisation theorem 
specifically assume bicartesian exponential category coproduct product operators theta discussed preamble abstraction theorem operators lifted theta arbitrary domain categories theta binary operators category fun fact coproduct product fun parameterised limit theorem follows inl inr coproduct inl inl similarly inr way theta binary product functor fun adjoints theta thetaf defined 
category fun bicartesian exponential category instance ffl abstraction theorem admits similar result map functors general 
suppose functor 
define functor phi phiy theta observe ffl definition composition phi abstraction theorem 
id phig id phig phi theta thetag extensionality 
thetag define functor objects 
thetag reformulate observation ffl list decomposition theorem theorem functor category functor replaced dotted version 
list decomposition theorem constructs isomorphism decomp satisfying decomp theta theta abstraction obtain required isomorphism functors collection isomorphisms objects 

theta theta introducing functors exl exr exl exr 
exl theta exr theta exl abstraction ffl exl theta ffl exr theta ffl exl abstraction exl theta exr theta exl theorem ffl decomp exl exr exr exl abstraction 
full details definition decomp exl exr required instantiate witnesses statement way exl exr theta theta simplification yield witness obtained earlier 
grateful referees pointing freyd 
backhouse van van der 
category theory coherently constructive lattice theory 
department mathematics computing science eindhoven university technology 
working document 
available world wide web www win tue nl win cs wp papers 
backhouse 
category theory coherently constructive lattice theory illustration 
technical report department computing science eindhoven university technology 
available world wide web www win tue nl win cs wp papers 
patrick cousot radhia cousot 
systematic design program analysis frameworks 
conference record sixth annual acm symposium principles programming languages pages san antonio texas january 
dijkstra scholten 
predicate calculus program semantics 
springer verlag berlin 
maarten fokkinga 
calculate categorically 
formal aspects computing 
peter freyd 
algebraically complete categories 
rosolini carboni editor category theory proceedings como volume lecture notes mathematics pages 
springer verlag 
freyd scedrov 
categories allegories 
north holland 
claudio hermida bart jacobs 
algebraic view structural induction 
extended may 
lambek 
fixpoint theorem complete categories 
mathematische zeitschrift 
lambek 
fixpoints endofunctors cartesian closed categories 
mathematical structures computer science 
lambek scott 
higher order categorical logic volume studies advanced mathematics 
cambridge university press 
mac lane 
categories working mathematician volume graduate texts mathematics 
springer verlag 
lehman smyth 
algebraic specification data types synthetic approach 
math 
syst 
theory 
malcolm 
algebraic data types program transformation 
phd thesis groningen university 
malcolm 
data structures program transformation 
science computer programming october 
manes arbib 
algebraic approaches program semantics 
texts monographs computer science 
springer verlag berlin 
eindhoven university technology mathematics program construction group 
fixed point calculus 
information processing letters february 
wadler 
theorems free 
th symposium functional programming languages computer architecture acm london september 
winskel 

