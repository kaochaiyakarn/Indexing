dynamic typing statically typed language mart abadi luca cardelli benjamin pierce gordon plotkin statically typed programming languages allow earlier error checking better enforcement disciplined programming styles generation efficient object code languages type consistency checks performed run time 
statically typed languages need deal data type determined compile time 
handle situations safely propose add type dynamic values pairs value type tag type denoted instances dynamic built explicit tagging construct inspected type safe typecase construct 
explores syntax operational semantics denotational semantics simple language including type dynamic 
give examples dynamically typed values programming 
discuss operational semantics language obtain soundness theorem 
formulations denotational semantics language relate operational semantics 
consider implications implementation issues 
statically typed programming languages allow earlier error checking better enforcement disciplined programming styles generation efficient object code languages type consistency checks performed run time 
statically typed languages need deal data type determined compile time 
example full static typechecking programs exchange data programs access persistent data general possible 
certain amount dynamic checking performed order preserve type safety 
extended version sixteenth annual acm symposium principles programming languages january austin texas 
digital equipment systems research center 
school computer science carnegie mellon university 
started dec systems research center 
department computer science university edinburgh 
started stanford center study language information 
consider program reads bitmap file displays screen 
probably simplest way store bitmap externally exact binary image representation memory 
concreteness assume bitmap stored internally pair integers followed rectangular array booleans 
take strong typing seriously unacceptable data file happens integers followed bit string appropriate length result chaos 
safety provided static typing compromised 
better solution widely build explicit procedures reading writing bitmaps storing externally character strings say generating exception contents file legal representation bitmap 
amounts essentially exactly data type external programs requiring types encoded instances single type 
strong typing preserved cost programming 
software systems grow include thousands data types supplied printing reading routines approach attractive 
really needed combination convenience solution safety second 
key solution observation far safety concerned important feature second solution details encoding bitmap string fact possible generate exception string represent bitmap 
amounts run time check type correctness read operation 
insight hand combine solutions contents file include binary representation data object representation type 
language provide single read operation checks type file matches type declared receiving variable 
fact thinking files containing pieces information data object type think containing pair object type 
introduce new data type called dynamic values pairs return view communication external world terms objects single type longer string dynamic 
read routine run time checks simply returns dynamic 
provide language construct dynamic lowercase packaging value type dynamic file typecase construct inspecting type tag dynamic 
typecase example display entire contents directory file may bitmap string foreach filename image read filename typecase image bitmap string history related example generalized making directory dynamic 
entire file system dynamic structures 
dynamic objects values exchanged interprocess communication providing type safe interactions processes 
remote procedure call paradigm uses essentially mechanism 
rpc implementations optimize conversions transport medium dynamic objects may exist principle 
number systems incorporate mechanisms similar described 
far features appeared context full scale language designs seldom precise formal description meaning 
attention formal implications dynamic typing problems proving soundness constructing models languages dynamic 
purpose study type dynamic isolation angles 
section reviews history dynamic typing statically typed languages describes related 
section introduces version dynamic typecase constructs gives examples programs written 
section presents operational semantics language obtains syntactic soundness theorem 
section investigates semantic models language relation operational semantics 
section outlines preliminary extending theory polymorphic lambda calculus dynamic 
section discusses issues involved implementing dynamic efficiently 
history related mid number languages included finite disjoint unions algol tagged variant records pascal 
thought finite versions dynamic allow values different types manipulated uniformly elements tagged variant type restriction set variants fixed advance 
simula subclass structure hand thought infinite disjoint union essentially equivalent dynamic 
simula inspect statement allows program determine run time subclass value belongs clause subclasses program doesn know care 
clu language incorporates idea dynamic typing static context 
type force construct attempts coerce instance type raising exception coercion possible 
cedar mesa provides similar typecase 
features cedar mesa carried directly modula modula 
clu cedar mesa primary motivation including dynamic type support programming idioms lisp 
scheifler gave formal definition denotational semantics clu including type force construct 
semantics relies domain run time values value tagged compile time type 
coercion mapping value known type value type identity function force programming dynamic look value read type 
approach refined distinguishes values types may need examined run time stripped compilation 
semantic definition clu apparently proved sound 
particular claimed run time values occurring evaluation typed program tagged types possess 
proof soundness result clu probably require techniques similar developed 
ml relatives shown resistance incorporation dynamic typing languages algol family 
probably uses dynamic algol languages captured ml polymorphic types 
ml building software systems deal persistent data 
various proposals extending ml dynamic type 
gordon thought ideas extended mycroft 
innovation allowing pattern variables typecase expressions see originate mycroft 
unfortunately proposals published 
versions caml language include features quite similar dynamic typecase constructs 
amber language subtyping includes dynamic type main handling persistent data 
fact amber system depends heavily dynamically typed values 
example module compiled stored file system single dynamic object 
uniform dynamic situations greatly simplifies amber implementation 
dynamically typed values dealing persistent data gaining importance 
amber mechanism pervasively modula programming environment 
structure file program inspected typecase 
dynamically typed objects discussed database literature approach dealing persistent data context statically typed database programming languages 
thatte described quasi static type system described explicit dynamic typecase constructs replaced implicit coercions run time checks 
programming dynamic section introduces notation rest essentially church simply typed lambda calculus call value reduction scheme extended type dynamic dynamic typecase constructs 
number example programs establish notation illustrate expressiveness 
fundamental constructs abstraction application conditionals arithmetic natural numbers 
write show expression evaluates value show expression type example nat nat nat programming dynamic nat nat nat nat nat nat nat nat order able consider evaluation typechecking separately define behavior evaluator terms just typed terms 
compiler language typechecking phase strip away type annotations passing programs interpreter code generator 
simple evaluator just ignores type annotations 
course evaluation arbitrary terms may encounter run time type errors trying apply number function 
result computations distinguished value wrong wrong nat wrong note second example run time error occurs argument evaluate expressions applicative order 
note wrong different 
nontermination 
allows distinguish semantics programs loop forever may perfectly typed programs crash run time type errors 
examples section interesting strings booleans cartesian products recursive expressions omitted formal parts 
strings written double quotes concatenation operator strings 
binary cartesian products written angle brackets fst snd projection functions returning second components pair 
recursive lambda expressions written fixpoint operator rec intend rec denote defined function informally example nat 
nat nat snd nat rec nat nat nat 
show section recursive expressions need primitives language defined dynamic 
values type dynamic built dynamic construct 
result evaluating expression dynamic pair value type tag result evaluating expression dynamic type dynamic type typecase construct examine type tag dynamic value 
example expression dynamic 
typecase nat programming dynamic applied dynamic nat evaluates 
evaluator attempts match type tag pattern nat succeeds binds value component adds returns result 
patterns case branches need fully specify type match may include pattern variables match subexpression type tag selector 
pattern variables listed parentheses guard indicating bound branch 
full syntax typecase typecase sel 
sel expressions variables type expressions lists distinct type variables 
convenient treat set list 
empty enclosing parentheses may omitted 
occurrences type variables binding scope branch type tag typecase selector matches guard matching branch executed 
possible choices 
instance imagine requiring patterns form exclusive exhaustive covering space type expressions type tag matches exactly pattern 
example dynamic values function returns printable string representation dynamic value rec tostring dynamic string dv dynamic 
typecase dv string nat function 
thetay tostring dynamic fst tostring dynamic snd 
dynamic dynamic tostring unknown case pairs illustrates subtle point 
uses pattern match pair calls tostring function recursively convert components 
package new dynamic values tagging types 
possible variables bound run time appropriate types 
programming dynamic type tag part run time representation dynamic value case dynamic probably return string representation tagged value type tag 
straightforward auxiliary function structure tostring 
rec dynamic string dv dynamic 
typecase dv string string nat nat function 
thetay dynamic fst theta dynamic snd dynamic dynamic unknown tostring quite jobs example tostring gets function stops giving information function 
better mechanisms described effective way get function value element domain codomain 
limitation precludes show domain codomain types function argument value just disembodied type 
possible add mechanism language providing way type tag dynamic data structure examined program 
amber cedar mesa feature 
convenient way implement operations type printing may important practice believe theoretical interest dynamic lies interaction statically dynamically checked parts language typecase expression allows 
proposed extension function behave differently depending type tag dynamic value passed parameter type result affected giving static typechecking 
example demonstrating nested typecase expressions function applies argument second argument checking application correctly typed 
arguments passed dynamic values result new dynamic value 
application fails type tag result string value part error 
richer language raise exception case 
df dynamic 
de dynamic 
typecase df typecase de dynamic dynamic error string programming dynamic dynamic error string note guard inner typecase listed bound pattern variable 
intended match type whatsoever domain type retains binding outer pattern making constant far inner typecase concerned 
readers may enjoy exercise defining similar function takes functions dynamic values returns composition dynamic value 
contrast languages features similar dynamic example modula set type tags involved computation computed statically dynamic expressions cause creation new tags run time 
simple example function takes dynamic value returns dynamic value part pair components equal value part original dynamic value dx dynamic 
typecase dx dynamic theta dx easy see type tag dynamic value returned function constructed run time simply chosen finite set tags generated compiler 
application dynamic substantial 
show build fixpoint operator allowing recursive computations expressed language rec construct 
known fixpoint operators expressed ordinary simply typed lambda calculus 
follows strong normalization property 
hiding certain parameter inside dynamic value past type system needed write typed version language 
fixpoint function argument equality sign informal 
fixpoint operator fix function returns fixpoint function applied fix fix call value lambda calculi extensional version property argument fix fix function property call value version standard combinator expressed untyped variant notation fix programming dynamic 
see fix fix function argument calculate follows 
fix 
fix build similar typed language need bit 
single fixpoint function build family functions arrow type 
arrow type define function fix type 
unfortunately way obtain fix just filling suitable type declarations untyped fix 
need build roundabout way 
need expression type 
matter expressions need know type 
define nat string thetau dynamic dynamic nat build family embedding functions type dynamic corresponding projection functions dynamic emb dynamic proj dynamic 
typecase easy see expression type evaluates value proj emb 
ready construct fix abbreviate emb emb dynamic proj proj dynamic dynamic 
proj see typed assume type 
type works dynamic 
fix 

emb type required correct behavior 
operational semantics operational semantics formally define syntax simply typed lambda calculus dynamic give operational rules typechecking evaluation 
notation tvar countable set type variable identifiers 
texp class type expressions defined bnf equation range texp ranges tvar nat dynamic similarly var countable set variables class open expressions defined equation ranges var texp wrong body fun body succ nat test nat zero succ succ dynamic body typecase sel 
recall denotes list distinct type variables list empty enclosing parentheses may omitted 
simpler language examples 
omitted strings booleans cartesian products built recursive expressions 
natural numbers built datatype succ test 
test construct helps reduce low level clutter definitions subsuming usual construct test zero predecessor function boolean datatype single construct 
martin lof elimination rule natural numbers 
operational semantics give special names certain subsets texp 
ftv set free type variables fv set free variables denotes closed expressions exp denotes expressions free type variables possibly free variables typecode denotes closed type expressions 
write just expression mean expression free type variables 
evaluation taken relation expressions expressions expressions domain values 
distinguish set value ae expressions canonical form 
elements value defined inductively wrong canonical form succ succ succ canonical form expression body canonical form closed expression dynamic body canonical form closed body canonical form different wrong 
substitution oe finite function type variables closed type expressions written subst denotes set substitutions 
subst denotes set substitutions domain similar notation substitution canonical expressions free variables expressions 
type environment finite function variables closed type expressions 
denote modification type environment te binding write te empty type environment denoted 
consistently certain variables range particular classes objects 
metavariables range variables language 
actual variables program examples 
metavariable ranges expressions 
similarly range type variables range type expressions 
letter oe ranges substitutions 
te ranges type environments 
range canonical expressions 
definitions conventions summarized figures 
nat numbers var variables tvar type variables texp type expressions typecode ft ftv closed types open expressions fe fv ftv closed expressions exp fe ftv expressions value fe canonical canonical expressions subst tvar fin gamma 
typecode substitutions subst tvar fin gamma 
typecode substitutions domain tenv var fin gamma 
typecode type environments summary basic definitions operational semantics variables expressions canonical expressions values type variables type expressions oe substitutions te type environments summary naming conventions typechecking notation describing typechecking evaluation form structural operational semantics 
typing evaluation functions specified systems inference rules showing expression type reduces value amounts precisely giving proof fact rules 
inference rules similar systems natural deduction logic style description come known natural semantics 
rules closely follow structure expressions incorporate strong notion computation 
compute type fun arg example attempt compute types subterms fun arg successful combine results 
exactly mimics sequence events observe inside typechecker language 
formalism extends fairly easily describing variety programming language features assignment statements exceptions 
breadth coverage operational style notation specifying comparatively rich languages standard ml 
group inria built system directly interpreting formal specifications written similar notation 
rules define situations judgement expression type valid assumptions te written te 
rule says variable identifier type type environment 
unbound type environment rules simply fail derive type 
technically clause dom te premise side condition determines rule applicable 
dom te te te expression arrow type 
argument type explicitly annotation bound variable 
compute result type assume operational semantics bound variable declared type attempt derive type body assumption 
te body te body typed function application consist expression arrow type applied expression type argument type expression 
te fun te arg te fun arg constant type nat 
te nat succ expression type nat body 
te nat nat te succ nat nat test expression type selector type nat arms type type second arm derived environment variable type nat 
te nat nat te zero te nat succ te test nat zero succ succ dynamic expression typed body type claimed 
te body te dynamic body dynamic typecase construct bit complicated 
order expression form typecase sel 
type conditions met selector sel type dynamic 
second possible substitution oe pattern variables body branch type third arm type second premise quantified substitutions oe subst strictly speaking inference rules allow draw quantified infinite set operational semantics proof premise requires infinite number separate derivations 
infinitary derivations theoretical difficulties fact rule system easier reason typechecker naively rules poor performance 
rules replaced finitary system skolem constants derives exactly typing judgements 
te sel dynamic oe subst te oe oe te te typecase sel note expression wrong assigned type 
syntactic form language associated typing rule 
evaluation evaluation rules notation typechecking rules 
define judgement closed expression reduces canonical expression written giving rules syntactic construct language 
general rule normal case plus specifying expression reduces wrong certain conditions 
style semantic description explicit representation nonterminating computation 
standard denotational semantics expression loops forever value 
bottom evaluation rules simply fail derive result whatsoever 
evaluation expression encounters run time error trying apply number function value wrong derived expression value 
evaluation rules preserve wrong 
rule evaluating variable evaluation defined closed expressions 
parameter substitution performed immediately function application 
constant wrong canonical form 
wrong wrong expression canonical form 
body body chosen call value applicative order evaluation strategy evaluate function application expression applied reduced canonical expression argument expression reduced legal value operational semantics computation terminate produce wrong 
computations results wrong application reduces immediately wrong 
argument substituted parameter variable body evaluated binding 
fun body arg wrong body fun arg fun form body fun arg wrong fun body arg wrong fun arg wrong constant canonical form 
succ expression canonical form body canonical number expression form succ canonical number 
evaluated attempting evaluate body canonical value returning wrong result number returning succ applied nat canonical number succ nat succ nat canonical number succ nat wrong test expression evaluated evaluating selector returning wrong result number evaluating arms depending selector zero positive number 
case variable bound inside arm predecessor selector 
nat zero test nat zero succ succ operational semantics nat succ succ test nat zero succ succ nat canonical number test nat zero succ succ wrong dynamic expression evaluated evaluating body 
body reduces wrong dynamic expression 
body wrong dynamic body dynamic body wrong dynamic body wrong typecase expression evaluated evaluating selector returning wrong immediately produces wrong dynamic value trying match type tag selector value guards typecase 
function match job matching run time typecode pattern expression free variables 
substitution oe uoe match oe 
simple type expressions dealing oe unique exists 
match fails 
section discusses implementation match 
branches tried turn match succeeds 
substitution returned match applied body branch 
selector value component substituted parameter variable body resulting expression evaluated 
rule application avoid introducing run time environments immediately substituting bound variable pattern variables body matching branch 
result evaluating body value typecase 
guard matches selector tag body evaluated 
sel dynamic match fails match oe oe typecase sel operational semantics sel dynamic match fails typecase sel form dynamic typecase sel wrong soundness defined sets rules evaluating expressions deriving types 
point reassuring observe systems fit way expect 
show evaluation preserves typing typed expression reduces canonical expression assigned type typing rules 
easy corollary typed program evaluate wrong 
lemma connects form proofs typing rules type environments proofs evaluation rules substitution binding environments 
type environments concerned empty write abbreviation 
lemma substitution preserves typing expressions canonical expressions closed types type environments te variables te te proof argue induction length derivation te case typing rules case show construct derivation te derivation final step application rule question 
give proof representative cases ffl typing rule variables te immediately te te operational semantics ffl body immediately te typing rule expressions apply giving te case te body induction hypothesis te body typing rule te body definition substitution te ffl fun arg typing rule application apply giving te case te fun te arg induction hypothesis te fun te arg typing rule application te fun arg definition substitution te proof 
ready soundness theorem 
theorem soundness expressions canonical expressions types proof induction length derivation case possible syntactic form show representative cases ffl body immediate ffl fun arg typechecking rule application step derivation arg fun step derivation second evaluation rule application fun form body canonical expressions form assigned functional type typing rules assumption contradicts induction hypothesis 
similarly step derivation third evaluation rule application arg wrong 
wrong assigned type whatsoever typing rules contradicting induction hypothesis 
may assume main evaluation rule application step derivation follows fun body arg wrong body induction hypothesis body step derivation typing rule expressions body lemma body induction hypothesis denotational semantics ffl dynamic body body wrong induction hypothesis typing rule dynamic wrong case 
assume body wrong main evaluation rule dynamic step derivation typechecking rule dynamic step derivation dynamic body induction hypothesis typing rule dynamic ffl typecase sel 
assume sel dynamic match oe match fails oe main evaluation rule typecase step derivation 
argument second typecase rule wrong case proceeds previous arguments 
typechecking rule typecase sel dynamic 
induction hypothesis typechecking rule oe oe definition match rewritten oe lemma oe induction hypothesis proof 
wrong assigned type typing rules immediate corollary expressions canonical expressions types wrong denotational semantics way showing rules sound define semantics language show typed expression denotes wrong 
general terms involves constructing domain defining meaning function assigns value ae expression environment ae 
domain contain element wrong wrong ae wrong ae 
properties highly desirable ffl typed expression ae wrong behaved ae 
ffl evaluation sound 
denotational semantics prove suffices map typecode subset containing wrong prove ffl ae ae typechecking sound 
section carry program untyped model suggest approach typed model 
untyped semantics subsection give meaning expressions elements untyped universe subsets appear meaning dynamic simply defined set pairs hv ti 
ranges types including dynamic definition stands circular 
build denotations type expressions carefully 
turn ideal model types macqueen plotkin sethi 
refer reader technical background construction 
denote ideals nonempty subsets closed approximations limits 
denote idl set ideals ideal model features worth 
extent ideal model captures intuition types sets structurally similar values 
second ideal model accounts diverse language constructs including certain kinds polymorphism 
large family recursive type equations guaranteed unique solutions 
exploit feature define meaning dynamic recursive type equation 
choose universe satisfies isomorphism equation flat domain natural numbers type error domain fwg 
usual continuous function space operation represented product space thetaa cpo set defined fhe ai ag 
evident ordering 
obtained limit sequence approximations omit details construction standard 
point universe suitable assigning meaning expressions programming language 
gives full definition denotation function notation ffl belongs summand injection ffl wrong abbreviation denotational semantics exp var ae ae wrong ae wrong body ae wrong wrong body vg fun arg ae fun ae wrong fun ae 
arg ae ae succ nat ae nat ae wrong nat ae test nat zero succ succ ae nat ae wrong nat ae zero ae succ nat ae gamma dynamic body ae body ae wrong wrong body ae ti typecase sel ae sel ae wrong hd ui sel ae match succeeds oe match oe dg ae meaning function expressions ffl vj yields ffl yields true false ffl yields argument 
note definition guarantees body arg ae 
arg ae 
denotation function commutes substitutions evaluation sound respect denotation function lemma expression oe substitution ae ae environments 
assume ae maps variable symbol oe defined xoe ae coincides ae 
eoe ae ae proof proof tedious inductive argument omit 
proof 
denotational semantics theorem expressions 
proof argue induction derivation case evaluation rule 
give typical ones 
ffl function applications assume fun body arg wrong body prove fun arg 
note body ae function ae denote wrong canonical 
fun arg ae body vg arg ae ae 
arg lemma yields fun arg ae body ae hypothesis body immediately leads desired equation 
ffl construction dynamic values assume body wrong prove dynamic body dynamic 
previous case denote wrong dynamic body ae body ae ti dynamic ae ae ti 
desired equation follows body 
ffl typecase operations assume sel dynamic match fails match oe oe prove typecase sel 
usual denote wrong obtain chain equalities arbitrary ae typecase sel ae equals oe dg ae hypotheses definition equals oe ae lemma equals ae hypotheses 
case branch typecase chosen similar simpler 
proof 
meaning program meaning typecode particular prove typechecking sound 
main difficulty course decide meaning dynamic 
define type dynamic values recursive equation 
auxiliary operations needed write equation 
definition set values typecode fc hc ti definitions particular omit certain injections summands corresponding projections summands recovered context 
definition sets values 
ui denotational semantics note ideals 
definitions write equation type dynamic values theta 
theta variable ranges idl set ideals equation follows informal definition type dynamic values set pairs hv ti 
intuitively equation states dynamic value things 
dynamic value tag nat contain natural number 
second hc ui dynamic value hc ui dynamic value hv ti third dynamic value tag dynamic contain dynamic value 
guarantee equation defines meaning dynamic 
macqueen plotkin sethi invoke banach fixed point theorem show equations form idl unique solutions provided contractive sense 
informally rank element appears construction limit 
witness ideals element belongs distance gammar minimum rank witness ideals 
function contractive exists real number delta ng typically guarantees operation contractive expressing terms basic operations theta inspecting structure expression 
case new basic operation addition theta slightly nonstandard 
need prove operations contractive 
theorem operation theta contractive second argument fixed 
operation 
contractive 
proof arguments corresponding ones theorem 
fact proof theta trivial variant corresponding 
give proof 
witness minimum rank say ideal 

witness hf ui analogue proposition max denotes step function returns arguments larger 
fa xg fb xg 
analogue proposition xg 
similarly 
denotational semantics cases 
ha ti witness rank 
hv ti 
hb ui witness rank 
case min proof 
immediately general result existence fixed points yields desired theorem 
theorem equation theta 
theta unique solution idl 
call solution dynamic 
typecode idl nat dynamic dynamic fc meaning function position associate ideal typecode see 
semantics fits original intuition dynamic values lemma shows 
lemma values hv ti dynamic proof proof induction structure nat need check hv dynamic nat 
follows immediately equation natural numbers tagged nat 
similarly dynamic need check hv dynamic dynamic 
follows immediately equation dynamic values tagged dynamic 
need check hv vi dynamic 
induction hypothesis dynamic dynamic 
derive chain equivalences hv vi dynamic dynamic dynamic equation induction hypothesis definition 
proof 
prove soundness typechecking denotational semantics definition environment ae consistent type environment te expression te defined ae te fv 
theorem type environments te expressions environments ae consistent te te ae 
proof argue induction derivation te case typing rule 
give typical ones 
ffl abstractions assume ae te ae consistent te prove ae te ae consistent te consider 
definition need show ae 
may assume 
case trivial wrong contain wrong 
ae vg hypothesis immediately yields value member 
ffl function applications assume fun ae arg ae prove fun arg ae 
definition function types fun ae function arg ae wrong contain wrong 
addition may assume arg ae 
case trivial 
immediately fun arg ae fun ae arg ae definition yields value member 
ffl construction dynamic values assume body ae prove dynamic body ae dynamic 
contain wrong body ae wrong dynamic body ae body ae ti 
desired result follows lemma 
ffl typecase operations assume sel ae dynamic te ae consistent te sel oe ae oe subst te ae consistent te oe oe ae te ae consistent te prove typecase sel ae te ae consistent te typecase sel 
similarly cases sel ae pair value typecode may assume 
typecase sel ae oe dg equal component selector simply ae case lemma guarantees oe hypotheses guarantee oe dg 
case hypotheses guarantee ae 
case derive typecase sel ae 
proof 
follows theorem theorem fact contain typed expression evaluates wrong 
gives new proof corollary 
extensions typed semantics semantics essentially semantics untyped lambda calculus definition type information ignored 
appropriate languages implicit typing type information omitted programs 
explicitly typed language natural look semantics assigns elements domains expressions type idea find domains solve infinite set simultaneous equations nat dynamic similar sums appears mycroft 
extensions section preliminary thoughts extending ideas rest languages implicit explicit polymorphism data types expressive type patterns 
polymorphism section assume explicitly typed polymorphic lambda calculus lines reynolds system 
type abstraction operator written type application written square brackets 
types polymorphic functions 
example type polymorphic identity function simplest case typechecking operational semantics dynamic typecase carry nearly unchanged language described section 
simply redefine match follows substitution oe uoe identical renaming bound type variables match returns substitution 
match fails 
write typecase expressions match polymorphic type tags 
example function checks polymorphic function elements type nat 
instantiates type tag second argument applies result value part second argument 
df dynamic 
de dynamic 
typecase df 
nat typecase de extensions data types similar vein imagine extending language type tags include existentially quantified variables 
mitchell plotkin think dynamic tag existential type module hidden implementation alternatively encapsulated element data type 
notation existential types labeled products follows cardelli wegner 
example rep 
rep nat rep pop rep 
nat theta rep top rep nat empty 
open stk rep stk top stk push stk empty function takes stack package tuple containing hidden representation type rep functions constant value opens package making components accessible body open expression performs trivial computation pushing number empty stack returning top element resulting stack 
function takes dynamic containing stack package hidden representation dynamic type elements stack 
pushes second argument empty stack stack package returns top resulting stack appropriately dynamic value 
ds dynamic 
de dynamic 
typecase ds rep 
rep rep pop rep 
theta rep top rep empty typecase de open stk rep dynamic stk top stk push stk empty order preserve integrity existentially quantified values language dynamic necessary place restrictions types may appear dynamic expressions prevent expose witness type existentially quantified value scope open abstype block 
particular extensions type tag dynamic constructor allowed mention representation types currently open data types ds dynamic 
de dynamic 
typecase ds rep 
rep rep pop rep 
theta rep top rep empty open stk rep wrong dynamic stk empty rep de wrong create dynamic type tag representation type stack assuming type available run time violate abstraction 
unclear generate type tag violate abstraction 
choose forbid situation 
restrictions language explicit polymorphism dynamic possible write programs types passed functions run time dynamic extra cost performing type abstractions applications run time just checking compilation discarding prohibitive 
want consider dynamic construct restricted types need passed execution 
suitable restriction expression dynamic formed closed 
restriction proposed mycroft context extension ml uses implicit explicit polymorphism 
appropriate analogue closed type expressions ml type expressions generic type variables expressions type variables instantiated known type totally undetermined dependent type variable value unknown compile time 
fact languages implicit polymorphism mycroft restriction dynamic required natural way determine type applications performed run time 
dynamics non generic variables break ml type system 
problem analogous updateable refs 
higher order pattern variables enriching language type patterns possible express broader range computations dynamics including interesting ones involving polymorphic functions 
motivating example generalization dynamic application function section 
problem take dynamic values sure function second argument belonging function domain apply extensions function 
want allow argument polymorphic function narrow appropriate monomorphic instance automatically applying supplied parameter 
call polymorphic dynamic application 
express example need extend typecase construct functional pattern variables 
ordinary pattern variables range type expressions functional pattern variables named distinguish ordinary pattern variables range functions type expressions type expressions 
functional pattern variables polymorphic dynamic application expressed follows df dynamic 
de dynamic 
typecase df 

typecase de dynamic dynamic error string dynamic error string instance apply function arguments df dynamic 
de dynamic nat branch outer typecase succeeds binding identity function type expressions 
branch inner typecase succeeds binding nat nat nat 
reduces reduces type nat claimed 
intriguing example polymorphic dynamic composition df dynamic 
dg dynamic 
typecase df 
typecase dg 
dynamic ffi function checks arguments polymorphic functions composition typed returning composition 
implementation issues open issues preliminary treatment polymorphism higher order pattern variables leaves number questions unanswered appropriate specification match operation 
difficult compute 
sensible notion general substitution pattern variables range things functions type expressions type expressions 
pattern variables range functions type expressions type expressions restricted class functions 
implications operational denotational semantics implicit vs explicit polymorphism 
hope examples may stimulate creativity helping answer questions 
implementation issues section discusses issues arise implementations languages dynamic values typecase construct methods efficient transfer dynamic values persistent storage implementation match function representation type tags efficient matching 
persistent storage important purposes dynamic values safe uniform format persistent data 
facility may heavily exploited large software environments important implemented efficiently 
large data structures possibly circularities shared substructures need represented externally quickly rebuilt heap running program 
type tags special difficulties ordinary run time data structures 
fortunately large amount energy devoted problem particularly lisp community 
lisp systems support files store arbitrary heap structures 
see description typical format 
idea goes back 
mechanism pickling heap structures cedar mesa designed implemented maxwell probably 
variant algorithm due lampson heavily modula programming environment dec systems research center 
scheme implemented part labs interface description language 
scheme earlier newcomer dill production quality compiler compiler project cmu 
type matching particular language constructs described implemented various schemes dynamic typing statically typed languages existed time see section 
gives rough classification languages amount involved comparing types presence absence subtyping 
implementation issues subtyping subtyping name equivalence modula clu simula rigid structural equivalence modula cedar structural equivalence amber pattern variables language taxonomy languages dynamic values type matching simplest languages clu modula construct corresponding typecase allows exact matches pattern variables equivalence types name 
modula example type tags dynamic values just unique identifiers type matching check equality 
subtyping involved matching complicated 
example simula uses name equivalence type matching type tags represented atoms 
find object type tag matches arm clause dynamically checks object actual type subclass statically apparent type necessary scan superclasses object actual class 
reasonably efficient subclass hierarchy tends shallow instructions required check level 
possible language structural equivalence type matching simple comparison atoms 
modula example includes type similar dynamic typecase construct allows matching complete type expressions pattern variables notion subtyping 
know language structural equivalence dynamic exact type matching subtyping 
efficient implementation typecase possible modula rules structural matching subtypes rigid subtyping explicit hierarchy 
unique identifier associated equivalence class types simula match check tag subtype typecase guard quickly scanning precompiled list superclasses tag 
amber notion structural subtyping requires sophisticated representation type tags 
subtype hierarchy explicit declarations structural similarities allow type safely expected 
example record type fields subtype just field long type subtype type second 
means set supertypes type precomputed compiler 
dynamic values tagged entire structural representation types representation compiler uses internally typechecking 
fact amber compiler bootstrapped representations exactly 
match function compare structure type tag type pattern 
language described requires structural representation types subtyping pattern variables typecase guards 
order determine substitution type expressions pattern variables pattern equal type tag necessary match structurally filling bindings pattern variables corresponding subterms type tag 
exactly order matching problem 
imagine speeding structural matching type expressions code match unknown expression known expression techniques familiar compilers ml 
box represents open question sensible way combine notion subtyping typecase construct includes pattern variables 
problems quite similar arise combining subtyping polymorphism example difficulties finding principal types 
dynamic typing necessary embedding statically typed language dynamically typed environment preserving strong typing 
explored syntax operational semantics denotational semantics typed lambda calculus type dynamic 
hope long obscure existence dynamic may standard programming language feature 
grateful insightful comments cynthia hibbard jim horning bill kalsow greg nelson ed satterthwaite earlier versions wing clarification clu dynamically typed values 
malcolm atkinson peter buneman 
types persistence database programming languages 
computing surveys june 
malcolm atkinson ronald morrison 
polymorphic names iterations 
draft article september 
barendregt 
lambda calculus 
north holland revised edition 
andrew birrell bruce jay nelson 
implementing remote procedure calls 
acm transactions computer systems february 
graham birtwistle ole johan dahl bjorn nygaard 
simula 
lund sweden bratt institute fuer frg bratt kent england 
clement despeyroux kahn lang 
centaur system 
proceedings third annual symposium software development environments sigsoft boston november 
luca cardelli 
amber 
guy cousineau pierre louis curien bernard robinet editors combinators functional programming languages 
springer verlag 
lecture notes computer science 
luca cardelli james donahue glassman mick jordan bill kalsow greg nelson 
modula report revised 
research report dec systems research center november 
luca cardelli james donahue mick jordan bill kalsow greg nelson 
modula type system 
proceedings sixteenth annual acm symposium principles programming languages pages january 
luca cardelli david macqueen 
persistence type abstraction 
proceedings persistence datatypes workshop august 
proceedings published university st andrews department computational science persistent programming research report 
luca cardelli peter wegner 
understanding types data abstraction polymorphism 
computing surveys december 
church 
formulation simple theory types 
journal symbolic logic 
dominique cl ement despeyroux thierry despeyroux laurent gilles kahn 
natural semantics computer 
technical report rr inria june 
thierry despeyroux 
formalism implement natural semantics 
technical report inria march 
mike gordon 
adding eval ml 
personal communication circa 
robert harper 
standard ml 
technical report ecs lfcs laboratory foundations computer science edinburgh university september 
roger hindley jonathan seldin 
combinators calculus volume london mathematical society student texts 
cambridge university press 
gilles kahn 
natural semantics 
proceedings symposium theoretical aspects computer science passau germany february 
proceedings published springer verlag lecture notes computer science 
available inria report february 
butler lampson 
description cedar language 
technical report csl xerox palo alto research center 
liskov atkinson bloom moss schaffert scheifler snyder 
clu manual 
springer verlag 
david macqueen 
private communication 
david macqueen gordon plotkin ravi sethi 
ideal model recursive polymorphic types 
information control 
martin lof 
intuitionistic type theory 
bibliopolis 
david mcdonald scott fahlman 
internal design cmu common lisp ibm rt pc 
technical report cmu cs carnegie mellon university april 
robin milner mads tofte robert harper 
definition standard ml 
mit press 
john mitchell gordon plotkin 
types existential type 
acm transactions programming languages systems july 
alan mycroft 
dynamic types ml 
draft article 
joseph newcomer 
efficient binary idl objects 
sigplan notices november 
gordon plotkin 
call name call value calculus 
theoretical computer science 
gordon plotkin 
structural approach operational semantics 
technical report daimi fn computer science department aarhus university aarhus denmark 
john reynolds 
approaches type structure 
mathematical foundations software development 
springer verlag 
lecture notes computer science 
paul 
extending modula build large integrated systems 
ieee software november 
justin craig schaffert 
formal definition clu 
master thesis mit january 
mit lcs tr 
robert william scheifler 
denotational semantics clu 
master thesis mit may 
mit lcs tr 
satish thatte 
quasi static typing preliminary report 
proceedings seventeenth acm symposium principles programming languages pages 
mads tofte 
operational semantics polymorphic type inference 
phd thesis computer science department edinburgh university 
cst 
pierre weis mar ia virginia alain michel mauny asc ander su 
caml manual version 
technical report projet inria ens 
things toplas version ffl sure martin luca agree thatte paragraph 
ffl fix really bad page breaks ffl mail referee report manuscript things ffl exists syntax typecase pattern variables 
ffl pages bit smaller ffl add cases bool examples section 
ffl fix citations inria papers really right citation simula 
version standard ml semantics 
things probably ffl look arrow circle ffl subscript font isn typewriter font ffl chance getting come left justified 
just matter going moving bracket 
ffl go rationalize punctuation displayed formulae ffl typewriter font letters come 
