dependent types practical programming hongwei xi september th department mathematical sciences carnegie mellon university pittsburgh pa submitted partial fulfillment requirements degree doctor philosophy thesis committee frank pfenning chair peter andrews robert harper dana scott fl hongwei xi research partially sponsored defense advanced research project agency title fox project advanced development systems software arpa order 

views contained document author interpreted representing official policies expressed implied darpa government 
programming notoriously error prone process great deal evidence practice demonstrated type system programming language effectively detect program errors compile time 
studies indicated types lead significant enhancement program performance run time 
sake practicality type checking type systems developed general purpose programming languages tend simple coarse leaves ample room improvement 
advocate types thesis addresses issue designing type system practical programming notion dependent types available leading accurate capture program invariants types 
contrast developing type theory dependent types designing functional programming language study practical methods extending type systems existing programming languages dependent types 
approach enriching type system ml special form dependent types type index objects restricted constraint domains leading dml language schema 
aim provide specification inference significantly precise type information compared current type system ml facilitating program error detection compiler optimization 
major complication resulting introducing dependent types pure type inference resulting system longer possible show type checking sufficiently annotated program dml reduced constraint satisfaction constraint domain type checking dml practical constraint domains efficient constraint solvers provided 
prove dml conservative extension ml valid ml program valid dml 
exhibit unobtrusiveness approach practical examples 
significant application demonstrate elimination array bound checks real code dependent types 
examples verified prototype implementation type checker dml constraint domain constraints linear inequalities integers 
attempt refining type systems existing programing languages step refinement types freeman pfenning 
parents waiting patiently general moment 
foremost especially advisor frank pfenning suggesting wonderful thesis topic 
sharp criticism earlier versions type checking algorithms dml adoption current bi directional version 
dml attractive 
learned program trusted clearly explained 
importantly developed taste simplicity surely profound influence research 
unusual hospitality patience general 
peter andrews teaching automated theorem proving providing opportunity research assistant tps theorem proving system higherorder classic logic 
really brought lot hand experience writing large programs untyped programming language common lisp strongly motivated research 
kindness general 
feel lucky took robert harper excellent course type theory programming languages 
determined research related promoting types programming 
dependent types array bound check elimination partly motivated question raised thesis proposal 
suggested dependent types typed assembly language highly relevant exciting research direction follow 
encouragement 
am grateful dana scott generous timely help kindness general shall look 
peter lee george necula providing interesting examples 
rowan davies chad brown helpful technical interesting non technical discussions 
feng tang enduring 
parents patient reasonably hoped obtain ph degree retirement 
retired years 
contents introductory examples 
basic overview 
related 
constructive type theory related systems 
computational logic px 
calculus constructions related systems 
software model checking 
extended ml 
refinement types 
shape analysis 
sized types 
indexed types 
cayenne 
research contributions 
thesis outline 
preliminaries untyped calculus pattern matching 
dynamic semantics 
mini ml pattern matching 
static semantics 
dynamic semantics 
soundness 
operational equivalence 
summary 
constraint domains general constraint language 
constraint domain algebraic terms 
constraint domain integers 
constraint solver linear inequalities 
example 
summary 
contents universal dependent types universal dependent types 
static semantics 
dynamic semantics 
elaboration 
external language dml ml pi 
elaboration static semantics 
elaboration constraint generation 
informal explanation constraint generation rules 
example elaboration 
elimination existential variables 
summary 
existential dependent types existential dependent types 
elaboration 
coercion 
elaboration static semantics 
elaboration constraint generation 
summary 
polymorphism extending ml ml 
static semantics 
dynamic semantics 
extending ml pi sigma ml pi sigma 
static semantics 
dynamic semantics 
elaboration 
coercion 
summary 
effects exception mechanism 
static semantics 
dynamic semantics 

static semantics 
dynamic semantics 
value restriction 
extending ml exc ref polymorphism dependent types 
elaboration 
summary 
contents implementation refinement built types 
refinement datatypes 
type annotations 
program transformation 
indeterminacy elaboration 
summary 
applications program error detection 
array bound check elimination 
experiments 
potential applications 
dead code elimination 
loop unrolling 
dependently typed assembly language 
summary 
current status 
language design 
language implementation 
research language design 
modules 
combination different refinements 
constraint domains 
programming languages 
denotational semantics 
implementations 
dml code examples knuth morris pratt string matching 
red black tree 
quicksort arrays 
mergesort lists 
byte copy function 
contents list figures reverse function lists 
quicksort integer lists 
binary search arrays 
call value evaluator simply typed calculus 
call value evaluator simply typed calculus ii 
syntax pat val 
pattern matching rules pat val 
evaluation rules natural semantics pat val 
syntax ml 
pattern matching rules ml 
typing rules ml 
evaluation rules natural semantics ml 
sort formation sorting rules type index objects 
rules satisfiability verification 
signature integer domain 
sample constraints 
syntax ml pi 
type formation rules ml 
typing rules patterns 
typing rules ml pi 
pattern matching rules ml pi 
natural semantics ml pi 
definition erasure function delta 
elaboration rules patterns 
elaboration rules ml pi 
elaboration rules ml pi ii 
constraint generation rules ml pi 
constraint generation rules ml pi ii 
rules eliminating existential variables 
derivation rules coercion 
constraint generation rules coercion 
elaboration rules ml pi sigma 
list figures elaboration rules ml pi sigma ii 
constraint generation rules ml pi sigma 
constraint generation rules ml pi sigma ii 
type formation rules ml 
typing rules pattern matching ml 
typing rules ml 
type formation rules ml pi sigma 
typing rules patterns 
typing rules ml pi sigma 
inference rules datatype constructor status 
natural semantics ml exc 
natural semantics ml exc ii 
natural semantics ml exc ref 
natural semantics ml exc ref ii 
syntax ml pi sigma exc ref 
additional typing rules ml pi sigma exc ref 
additional evaluation rules ml pi sigma exc ref 
elaboration rules exception mechanism 
dependent types built functions 
red black tree data structure 
dot product function 
dec alpha sml nj working version 
sun sparc version 
loop unrolling sumarray 
version dotprod function 
dtal version dotprod function 
chapter types play pivotal role design implementation programming languages 
types catching program errors compile time goes back early days fortran 
compelling reason practice briefly explained quote 
unfortunately pays price languages impose discipline types time taken find bugs mistakenly applies cdr atom lisp finds adding property list integer know symptoms 
robin milner theory type polymorphism programming milner known designed type system ml milner tofte harper effectively enable programmer catch numerous program errors compiletime 
various occasions common program errors caught type system ml 
instance error element empty list caught type system ml distinguish empty lists non empty ones 
types compiler optimization passing types polymorphic function help eliminate boxing tagging objects discovery 
type system ml inadequate direction 
instance desirable express type safe array access operation compiler eliminate run time array bound checks type checking clear current type system ml 
rest chapter concrete examples illustrate advantage enriching type system ml dependent types 
describe context thesis exists outline rest thesis 
introductory examples section introductory examples illustrate expressiveness type system soon formulate study 
suggest reader pay attention examples studying theoretical core thesis 
larger examples appendix notice correct implementation reverse function lists return list length argument 
unfortunately property captured type chapter 
datatype list nil cons list typeref list nat indexing datatype list nat nil list cons nat list 
list fun reverse fun rev nil ys ys rev cons xs ys rev xs cons ys rev nat nat list list 
list rev nil reverse nat list 
list reverse function lists system ml 
inadequacy remedied introduce dependent types 
example written style standard ml annotations explained shortly 
assume working constraint domain natural numbers constants addition operation 
polymorphic datatype list defined represent type lists 
datatype indexed natural number stands length list case 
constructors associated datatype list assigned dependent types ffl nil list states nil list length 
ffl cons nat list 
list states cons yields list length pair consisting element list length note nat means universally quantified natural numbers usually written pin nat 
fun feature standard ml milner tofte harper macqueen allows programmer explicitly control scope type variable 
type reverse nat list 
list states reverse returns list length length way captured information function reverse length preserving 
notice assigned auxiliary function rev dependent type nat nat list list 
list rev returns list length pair lists lengths respectively 
invariant provided order type check entire code 
example implements quicksort function intlist 
datatype intlist represents integer list indexed integer stands sum elements integer list 
type quicksort sum int intlist sum 
intlist sum 
introductory examples states sum elements output intlist function equals sum elements input intlist 
mistakenly writes par left right ys par left right ys error unusual captured enriched type system 
notice error slips current type system ml 
examples exhibit potential dependent types compile time program error detection 
show potential dependent types compiler optimization 
example implements binary search function polymorphic array 
asserted type subscript function sub precisely states returns element type array size integer equal holds 
clearly subscript function sub type called need inserting run time array bound checks checking possible memory violations 
enhances robustness code efficiency illustrating safety efficiency issues complementary 
note programmer provide appropriate type inner function look order code type checked successfully 
come back point 
common feature examples type index objects drawn integer constraint domain 
example shows index datatypes type index objects drawn different constraint domains 
example considerably involved detailed explanation 
datatype simpletype represents simple types simply typed calculus 
datatype type context basically list simple types assigns types free variables expression 
datatype lambdaexp formulating simply typed expressions de bruijn notation de bruijn 
instance xy represented abs abs app shift datatypes closure defined mutually recursively 
environment list closures closure abstraction associated environment binds free variable abstraction closure 
refine datatype types dependent types 
datatype lambdaexp dependent pair ctx stands simple type context ctx 
assign dependent types constructors associated datatype lambdaexp 
instance dependent type app states app yields expression type tb context ctx pair expressions types fun ta tb ta context ctx respectively 
datatype closure dependent index drawn type simpletype stands type closure 
datatype environment dependent index drawn type context list simple types corresponding list closures environment 
assign function type simpletype lambdaexp 
closure states function returns closure type argument type lambdaexp closed expression type simply means chapter 
datatype intlist int intlist typeref intlist int sum intlist nat sum int int intlist sum 
intlist sum fun rs rs ls rs ls rs sm int sn int intlist sm intlist sn 
intlist sm sn fun quicksort quicksort xs fun par left right quicksort left quicksort right par left right ys par left right ys par left right ys par int sp int sq int sr int int intlist sp intlist sq intlist sr 
intlist sp sq sr par xs quicksort sum int intlist sum 
intlist sum quicksort integer lists 
introductory examples datatype answer int assert sub nat int array int 
assert length nat array 
int fun size nat bsearch cmp key arr fun look lo hi hi lo val hi lo div val sub arr case cmp key 
look lo equal 
greater 
look hi look nat int size size int int 
answer look length arr bsearch 
order 
array size 
answer binary search arrays chapter 
datatype simpletype base int fun simpletype simpletype datatype context simpletype context datatype lambdaexp shift lambdaexp abs lambdaexp app lambdaexp lambdaexp typeref lambdaexp simpletype context simpletype ctx context lambdaexp ctx shift ta simpletype tb simpletype ctx context lambdaexp ta ctx 
lambdaexp ta tb ctx abs ta simpletype tb simpletype ctx context lambdaexp tb ta ctx 
lambdaexp fun ta tb ctx app ta simpletype tb simpletype ctx context lambdaexp fun ta tb ctx lambdaexp ta ctx 
lambdaexp tb ctx datatype closure closure lambdaexp environment environment closure environment typeref closure simpletype closure simpletype ctx context lambdaexp ctx environment ctx 
closure environment simpletype context environment simpletype ctx context closure environment ctx 
environment ctx call value evaluator simply typed calculus implementation evaluator pure simply typed call value calculus la curry typing type preserving function 
clearly programmer confidence correctness function code passes type checking 
basic overview outline section historic context thesis developed mention related section 
problem correctness programs programming 
long history research program verification 
assertions specify prove correctness flowchart programs developed independently naur naur floyd floyd 
hoare constructed partial 
basic overview fun fun cbv clo env clo cbv shift clo env cbv env cbv abs env closure abs env cbv app env val closure abs body cbv env val clo cbv env cbv body clo cbv simpletype ctx context lambdaexp ctx environment ctx 
closure cbv simpletype lambdaexp 
closure call value evaluator simply typed calculus ii correctness system hoare brought hoare logic 
dijkstra invented notion weakest preconditions dijkstra explored details examples dijkstra 
generalization weakest precondition approach refinement logics active research area years 
approaches general notoriously difficult expensive put software practice 
small pieces safety critical software afford formally verified approaches 
rapid progress strong reservations daily practical programming benefit approaches 
approaches gaining grounds verification hardware 
functional programming languages find principal styles reasoning equational logical equational reasoning performed program transformation roots church rosser 
burstall darlington transformation system developing recursive programs burstall darlington 
bird meertens calculus derivation functional programs specification bird consists set higher order functions operate lists including map fold scan filter inits tails cross product function composition 
equational reasoning plays fundamental role fp sannella tarlecki 
logical reasoning cast type theory roots church martin lof 
approach emphasizes joint development proofs programs 
systems nuprl constable coq coquand lego pollack alf augustsson coquand nordstrom pvs shankar variants type theory done type free setting shown px hayashi nakano 
generate post hoc proofs proof chapter 
skeletons functional programs specifications parent 
major difficulties associated type theoretic approaches 

languages tend unrealistically small 
pure type systems barendregt formulated concisely elegantly contain language constructs support practical programming 

unwieldy add programming features pure type theories 
attested works allowing unlimited recursion constable smith introducing recursive types mendler incorporating effects honsell mason smith talcott exceptions nakano input output 

type checking usually undecidable systems enriched recursion dependent types 
type checking programs requires certain level theorem proving 
systems nuprl pvs type checking interactive may daunting task programmers 

heuristic best theorem proving tactics type checking requires lot user interactions 
small changes program may mean big change proof changes program development cycle cost effort time user programming setting 
propose enrich type systems existing functional programming language ml 
contrast adjusting programming language features recursion effects exceptions type theory study approaches adjusting type theory programming language features 
refine ml types dependent types introduce restricted form dependent types borrowing ideas type theory 
enables assert additional properties programs types providing significantly information program error detection compiler optimization 
order type checking manageable enriched type system require type dependencies taken restricted constraint domain leading dml language schema 
prove type checking sufficiently annotated program dml reduced constraint satisfaction constraint domain immediate consequence reduction choose relative simple constraint domains practical approaches solving constraints construct practical type checking algorithm dml 
focus case integer constraint domain constraints linear inequalities integers 
related certainly reasonable hope mention moderate part research correctness programs 
simply field 
shall examine efforts close connection concerning type theories applications 
start martin lof constructive type theory 
constructive type theory related systems system constructive type theory primarily martin lof martin lof 
core idea reads propositions types 
system 
related simultaneously logic programming language 
programs developed way behave specifications 
achieved formal proofs written programs 
correctness proofs verified type checkers 
nuprl nuprl proof system developed allow extraction programs proof specifications constable 
logical basis sequent calculus formulation descendant constructive type theory 
similarly lcf features goal oriented proof engine employing tactics formulated ml programming language 
emphasis nuprl logical designed support top construction derivations propositions deduction system 
alf alf logical framework system interactive proof editing environment proof objects mathematical theorems constructed screen 
monomorphic type theory augustsson coquand nordstrom nordstrom 
proof editor keeps theory environment dictionary abbreviations scratch area 
user navigates scratch area build proofs top bottom fashion 
novelty alf lies pattern matching dependent types coquand defining functions 
totality functions defined pattern matching guaranteed restrictions recursive equational definitions 
allows user formulate significantly shorter proofs alf systems 
computational logic px realizability models intuitionistic formal systems allow extraction computations systems 
px system introduced hayashi described detail hayashi nakano 
px logic type free theory computation feferman feferman lisp programs extracted notion realizability px realizability 
hayashi argues requirement theory total restrictive practical programming justification logic system possibly nonterminating computations 
hayashi proposed type system hayashi allows notion refinement types type system ml freeman pfenning plus intersection union refinement types singleton refinement types 
demonstrated singleton union intersection types allow development programs unnecessary coding variant curry howard isomorphism 
exactly give way write types specifications programs unnecessary coding inevitable 
calculus constructions related systems calculus constructions coq calculus constructions cc type system basically enriches girard types dependent terms 
relates martin lof intuitionistic theory types tt respect 
cc originally developed implemented coquand huet coquand huet coquand huet 
coquand proposed extend cc primitive inductive definitions paulin mohring led calculus inductive constructions implementation coq proof assistant consisting proof checker cc facility called mathematical high level chapter 
notation mathematical theories interactive theorem prover tactics written caml dialect ml language 
parent parent proposed reverse process extracting programs constructive proofs coq synthesizing post hoc proofs programs 
approach close connection trying dependent types expressing additional properties programs verified type checker 
relying weak extraction function produces programs annotations parent introduced new language annotated programs proved partial proof terms deterministically retrieved programs language specifications 
showed extraction function invertible deducing algorithm reconstructing proofs programs 
proved validity completeness certain sense approach 
programs usually prohibitively annotations new language preventing user writing sufficiently natural programs 
heuristic algorithm generating partial proof terms proposed implemented coq tactic 
tactic builds partial proof term program specification usual coq tactics called fulfill proof obligations 
ecc lego extended calculus constructions ecc lou unifies ideas martin lof type theory calculus constructions 
lou extension framework datatypes covered general form schemata proposed 
lego system implements ecc inductive definitions pattern matching appealing practical proofs 
software model checking model checking superior general theorem proving aspects 
model checking need invent lemmas devise proof strategies offering full automation 
model checking generate counterexamples check fails 
software specifications intended properties expressed simple relational calculus jackson damon 
claim specification satisfies property relational formula checked automatically enumerating formula interpretations number interpretation finite 
unfortunately software designs state explosion arises data structures single program product control states programs 
result number different interpretations relational formula general vastly great brute force enumerations feasible 
worse quite case formula infinitely interpretations 
jackson damon proposed reduce number cases checker consider eliminating isomorphic interpretations 
strategy successfully tried hardware verification 
great care needs state space system bring reach checker 
assumption bug lies original system cause bug system 
experience suggests enumerating behaviors machine reliable debugging method exploring merely cases original system 
see choose finite domain model checking natural approach solving constraints generated type checking programs dml 

related extended ml sannella tarlecki proposed extended ml sannella tarlecki framework formal development programs pure fragment standard ml 
module system extended ml declare type function axioms satisfies 
leads need theorem proving type checking 
specify check information functions avoids general theorem proving 
hand currently address module level issues believe approach extend naturally signatures functors additional machinery 
refinement types tim freeman frank pfenning proposed refinement types ml freeman pfenning 
user defined ml datatype refined finite lattice subtypes 
extension type inference decidable typed expression principal type 
user free omit type declaration program 
prototype implementation freeman exhibits promising approach enriching type systems ml 
thesis follows paradigm refinement types 
shape analysis jay jay introduced technique array bounds checking notion shape types 
shape checking kind partial evaluation different characteristics source language compared dml consists linear integer equality inequality constraints 
feel design restrictive promising languages iteration schemas general recursion 
sized types hughes pareto sabry hughes pareto sabry introduced notion sized types proving correctness reactive systems 
exist similarities sized types datatype refinement dml domain natural numbers differences substantial 
feel language hughes pareto sabry restrictive general purpose programming type system handle minor variation primitive recursion 
hand sized types correctness proofs reactive systems achieved dml moment 
indexed types far closely related system indexed types developed independently zenger forthcoming ph thesis zenger earlier version described zenger 
works context lazy functional programming 
language clean elegant applications significantly overlap compelling 
general approach require changes haskell program amenable checking indexed types case system ml 
particularly apparent case existential dependent types tied data constructors 
advantage simpler algorithm elaboration type checking program just chapter 
type explicit 
language pure consider value restriction 
cayenne cayenne augustsson haskell language fully dependent types available language expressions type index objects 
steep price undecidable type checking cayenne 
feel cayenne pays greater attention making programs typable assigning programs accurate types 
cayenne printf typable ml typable modules replaced records notion datatype refinement exist 
clearly separates language design cayenne 
research contributions notion dependent types decades applicable practical programming 
major obstacle difficulty designing practical type checking algorithm dependent type systems 
main contribution thesis convincingly demonstrate restricted form dependent types practical programming 
sound practical approach extending type system ml dependent types achieving theoretical actual implementation evaluation 
consists major steps lead claim 

separate type index objects expressions programming language 
precisely require type index objects restricted constraint domains prove type checking sufficiently annotated program setting reduced constraint satisfaction crucial decision language design type checking practical case feasible approaches solving constraints 
prove enriched language conservative extension ml 
program uses features dependent types behaves exactly ml compile run time 

show dependent types cope important programming features polymorphism mutable exceptions 

exhibit unobtrusiveness dependent types practical programming writing programs modifying existing ml code 
programmer provide type annotations cases order successfully type check code amount moderate type annotations usually accounts entire code 
hand type annotations type checked mechanically fully trusted program documentation 

thesis outline 
demonstrate programmer supply type annotations safely remove array bound checks 
leads robust programs significantly efficient code 
larger scale dependent types potential applications provide illustrating examples 

dependent types source code passed lower level languages 
instance process designing dependently typed assembly language dependent types passed source code generate proof asserting memory integrity assembly code 
source language promising act front generating proof carrying code necula 

dependent types facilitate elimination redundant matches pattern matching 
hand lead accurate error warning message reports typechecking 
hand opens exciting avenue dependent type directed partial evaluation shown section 
thesis outline rest thesis organized follows 
chapter start untyped language basically call value calculus extended general pattern matching 
importance language lies operational semantics relate operational semantics typed languages formulated 
introduce typed programing language ml basically mini ml extended general pattern matching 
prove various known properties ml mainly serve guidance development 
study operational equivalence relation pat val needed proof correctness elaboration algorithms chapters 
language enriched dependent types parameterized constraint domain type index objects drawn 
introduce general constraint language chapter constraint domain formulated 
concrete examples constraint domains including integer domain needed array bound check elimination 
chapter introduce notion universal dependent types extend ml form types 
leads programming language ml pi 
prove various important properties ml pi relate operation semantics ml ml pi conservative extension ml order show unobtrusiveness universal dependent types programming formulate external programming language dml ml pi closely resembles mini ml 
elaboration mapping dml ml pi prove correctness 
chapter explain inadequacies ml pi examples introduce notion existential dependent types 
extend ml pi form types obtain programming language ml pi sigma 
external language dml extended accordingly 
initial development chapter parallel previous 
difficult find elaboration mapping dml ml pi sigma directly 
point difficulty suggest methods overcome 
elaboration mapping ml pi sigma chapter 
proven correct 
theoretical core thesis consist chapter 
study combining dependent types polymorphism chapter 
development dependent types largely orthogonal polymorphism practical issues address 
introduce ml language extends ml polymorphism set machinery combining dependent types polymorphism 
lastly phase elaboration algorithm achieving full compatibility ml ml pi sigma language extends ml pi sigma polymorphism 
chapter study interaction dependent types effects mutable exceptions 
spotting problems adopt value restriction approach solves problems cleanly 
conclude formulation typed programing language ml pi sigma exc ref includes features exceptions polymorphism dependent types 
words extended core ml ml module level constructs dependent types 
describe prototype implementation chapter chapter applications dependent types include program error detection array bound check elimination redundant match elimination lastly conclude point directions research 
chapter preliminaries chapter introduce untyped language pat val basically call value calculus extended general pattern matching 
importance language lies operational semantics relate operational semantics typed languages introduced 
introduce explicitly typed language build type system 
call language ml basically mini ml extended pattern matching 
typing rules operational semantics ml prove important properties ml type preservation theorem helpful understanding develop 
lastly study operational equivalence relation pat val prove correctness elaboration algorithms languages ml pi ml pi sigma chapter 
untyped calculus pattern matching crucial point typed programming languages types indifferent program evaluation 
roughly speaking erase type information program evaluate reach result keeping type information evaluation 
matter fact common practice compilers discard type information program type checking 
studies tarditi morrisett cheng stone harper lee morrisett walker crary glew demonstrated convincingly practice may wise type information helpful compiler optimization 
necessary show types alter operational semantics programs various typed languages formulate thesis 
purpose introduce untyped language pat val define operational semantics pat val operational semantics typed languages relate 
syntax pat val 
meta variables object language variables constructors expressions value forms values 
value forms special form values values special form expressions 
patterns emphasize variable occur pattern 
signature list constructors available language 
chapter 
preliminaries patterns hi hp matches ms ms expressions hi case ms lam fix value forms hi hu lam values hi hv lam signatures delta substitutions 
syntax pat val set fv free variables expression defined follows 
fv fxg fv hi fv fv fv fv fv fv ms fv fv ms fv case ms fv fv ms fv lam fv fv fv fv fv fv fv fv fix fv substitutions defined standard way 
write result applying substitution allow substituting expression containing free variables variable emphasize ff conversion performed necessary avoid capturing free variables 
dom domain substitution 
dom 
substitution dom dom fxg empty substitution 
substitution dom fxg substitutions dom dom 
define union substitution dom dom dom dom dom 
similarly ffi composition defined substitution dom dom dom dom dom 

untyped calculus pattern matching substitution called value substitution value dom 
result applying 



proposition value form expression 
value form 
value forms closed substitution 
proof immediately follows structural induction proposition values 
value 
values closed value substitution 
proof immediately follows structural induction ffl variable 
value 

value 
ffl form 

obviously value 
note assume free occurrences cases readily verified 
significant difference value forms values closed substitutions closed value substitutions 
primary reason require value form fix 
requirement rules troublesome expressions fix little practice 
dynamic semantics operational semantics pat val terms natural semantics kahn 
approach supports short clean formulation prevents distinguishing stuck program non terminating 
alternative small step reduction semantics enable distinguish stuck program non terminating setting involved 
feel natural semantics suffices purpose choose reduction semantics 
formulate reduction semantics pat val studying operational equivalence relation pat val pattern value judgement form match means matching value pattern yields substitution variables derived application rules 
notice rule match prod sense share common variables 
natural semantics pat val 
notice presence rule ev var means allow evaluation open code code containing occurrences free variables 
main reason hope theorems prove applicable program transformation manipulation open code necessity 
constants gamma integers nil cons list constructors examples 
chapter 
preliminaries match 
match var match hi hi match unit match match match hp hv match prod match match cons wo match match match cons pattern matching rules pat val 
ev var hi 
hi ev unit 
ev cons wo 

ev cons 


hv ev prod 
match 
case delta delta delta 
ev case lam 
lam ev lam 
lam 



ev app 



ev fix 

fix ev fix evaluation rules natural semantics pat val 
mini ml pattern matching example derivation 

ev cons wo nil 
nil ev cons wo nili 
nili ev prod cons nili 
cons nili derivation 
match 
match var match xs nil xs 
nil match var match hx xsi nili 
xs 
nil match prod match cons nili cons hx xsi 
xs 
nil match cons tail case cons hx xsi xs tail cons nili 
nil derivable follows 
tail 
tail ev lam nil 
nil ev cons wo case cons nili cons hx xsi xs 
nil ev case tail cons nili 
nil ev app notice rule ev case introduces certain amount nondeterminism dynamic semantics pat val specify matching clause chosen applicable 
hand specified ml pattern matching done sequentially chosen matching clause applicable 
difference considerably minor issue theory require matching clauses overlapping theorem 
value pat val proof immediately follows structural induction cases 
ffl hv induction hypothesis 
derivable 
derivation 



ev prod ffl lam 

ev lam cases trivial 
mini ml pattern matching introduce explicitly typed programming language ml basically extends cl ement despeyroux despeyroux kahn general pattern matching 
simply typed version pat val syntax ml 
context gamma omit leading delta context empty assume distinct write dom gamma fx gamma signature declares list constructors associated types 
notice type constructor required form fi fi fi user defined base type constructor argument exactly argument 
chapter 
preliminaries base types fi bool int user defined datatypes types fi patterns hi hp matches ms ms expressions hi case ms lam fix value forms hi hu lam values hi hv lam contexts gamma delta gamma signatures delta fi fi substitutions 
syntax ml pat var hi delta pat unit gamma gamma hp gamma gamma pat prod fi fi delta pat cons wo fi gamma fi gamma pat cons pattern matching rules ml static semantics pattern type derive judgement form gamma rules reads checking pattern type yields context gamma 
examples assume intlist base type nil cons constructors type intlist int intlist intlist respectively 
example derivation cons hx nili intlist int 
cons int intlist intlist int int pat var nil intlist nil intlist delta pat cons wo hx nili int intlist int pat prod cons hx nili intlist int pat cons typing rules ml 
example type inference 
mini ml pattern matching gamma gamma ty var fi gamma fi ty cons wo fi gamma gamma ffi ty cons gamma hi ty unit gamma gamma gamma ty prod gamma gamma gamma gamma ty match gamma gamma ms gamma ms ty matches gamma gamma ms gamma case ms ty cases gamma gamma lam ty lam gamma gamma gamma ty app gamma gamma gamma ty gamma gamma fix ty fix typing rules ml ml example derivation delta lam int cons hx nili int intlist 
cons int intlist intlist int int nil intlist int nil intlist ty cons wo int hx nili int intlist ty prod int cons hx nili intlist ty cons delta lam int cons hx nili int intlist ty lam gamma gamma judgement form gamma gamma derived application rules 
judgement means dom dom gamma gamma gamma derivable dom 
gamma delta subst empty gamma gamma gamma gamma 
gamma subst var chapter 
preliminaries proposition shows judgement gamma gamma intended meaning 
proposition 

gamma gamma derivable dom dom gamma gamma gamma derivable dom 

dom dom rule admissible 
gamma gamma gamma gamma gamma gamma gamma subst subst proof follows structural induction derivation gamma gamma follows structural induction derivation gamma gamma proof 
ffl 
trivial 
ffl 

suppose gamma gamma derivation 
gamma gamma gamma gamma 
gamma subst var induction hypothesis gamma gamma gamma derivable 
leads derivation 
gamma gamma gamma gamma gamma 
gamma gamma subst var 
gamma gamma done 
lemma gamma gamma gamma gamma derivable gamma derivable 
proof proof follows structural induction derivation gamma gamma cases 
gamma gamma gamma dom gamma 
dom dom gamma proposition dom 
implies clearly gamma derivable 
gamma gamma gamma dom dom gamma proposition dom 
implies 
note gamma derivable proposition gamma gamma gamma gamma gamma gamma lam derive gamma gamma gamma gamma induction hypothesis gamma derivable leads derivation 
gamma gamma ty lam 
mini ml pattern matching lam 
lam ev lam 
lam 



ev app fix 

fix ev fix evaluation rules natural semantics ml note dom gamma dom 
gamma gamma fv dom 

cases handled similarly 
value matches pattern match derivable substitution 
lemma shows type type dom fixed 
crucial proving type preservation theorem ml lemma gamma gamma match derivable gamma gamma derivable 
proof structural induction derivation gamma case follows 
match match match hp hv induction hypothesis gamma gamma derivable 
derivation subst subst admissible rule proposition 
gamma gamma gamma gamma gamma gamma gamma subst subst cases trivial 
dynamic semantics natural semantics ml pat val changes formulation rules types carried evaluation 
rules unchanged 
notice types play role formulation evaluation rules 
precise define type erasure function delta follows maps expression ml chapter 
preliminaries pat val jxj jcj jp ej jej ms jej msj case jej ej lam jej je je je je je uj fix juj theorem expression ml 


derivable ml jej 
jvj derivable pat val 
jej 
derivable pat val 
derivable ml jvj proof follow structural induction derivations 
jej 
respectively 
theorem clearly exhibits indifference types evaluation 
great advantage imposing type system language able prove certainly invariant properties evaluation typed expressions 
soundness ready type preservation theorem ml asserts evaluation rules natural semantics ml alter types evaluated expressions 
notice theorem closely related different subject reduction theorem thesis asserts small step reduction semantics ml type preserving 
type preservation theorem fundamental theorem relates static semantics ml expressed form type inference rules dynamic semantics ml expressed form natural semantics 
allow evaluation open code formulation type preservation theorem slightly different standard deals closed code needs variable context keep track free variables code 
theorem type preservation ml 
derivable 
gamma derivable gamma derivable 
proof follows structural induction derivation 
cases 

trivially gamma derivable gamma derivable 

mini ml pattern matching 
match 
case delta delta delta 
derivation form gamma case delta delta delta derivable 
gamma gamma delta delta delta gamma case delta delta delta ty case induction hypothesis gamma derivable 
notice gamma derivable gamma derivable gamma gamma gamma derivable 
lemma gamma gamma derivable 
leads derivation gamma lemma 
induction hypothesis gamma derivable 

lam 



gamma derivable derivation form 
gamma gamma gamma ty app induction hypothesis gamma gamma derivable 
gamma 
derivable lemma 
induction hypothesis gamma derivable 




gamma derivable derivation form 
gamma gamma gamma ty induction hypothesis gamma derivable 
gamma 
derivable lemma 
yields gamma derivable induction hypothesis 
fix 

fix gamma fix derivable derivation form 
gamma gamma fix ty fix gamma 
fix derivable lemma 
cases handled similarly 
notice case derivation gamma 
complex gamma proof succeeded proceeded structural induction derivation gamma chapter 
preliminaries operational equivalence basics operational equivalence section chapter chapter prove correctness elaboration algorithms 
appropriate place mention reduction semantics notion evaluation context introduce follows 
definition definition evaluation contexts general contexts follows 
evaluation contexts ei hv ei case ms match contexts cm cm ms contexts hc ei ci case ms case cm lam fix context expression stands expression formulated replacing hole emphasize replacement variable capturing instance lam lam contexts context formulated replacing hole proposition 

evaluation contexts evaluation context 

evaluation context value 
evaluation context 

evaluation context expression free variables captured hole replaced proof simply follows structural induction cases 
ffl 
evaluation context 
ffl 
evaluation context induction hypothesis 
evaluation context ffl case ms evaluation context induction hypothesis 
case ms evaluation context rest cases handled similarly 
omit proofs structural induction definition define follows redexes reductions left hand right hand sides respectively 
lam 



fix 

fix case delta delta delta 
match derivable 
operational equivalence step reduction relation 
defined follows 

evaluation context redex reduction say evaluates step 
notice relation 
context sensitive general infer 

true proposition evaluation context 

reflexive transitive closure 
reduction semantics pat val states evaluates 
holds 
point redex form case ms may different reductions 
reduction semantics contains certain amount nondeterminism 
clearly proposition implies 

property implicitly presentation 
theorem relates 


proposition 

value 

redex value 

redexes 

value 

proof simply follows definition values 
proceed prove structural induction ffl 
trivial 
ffl value implies value 
form induction hypothesis 
note done 
ffl hv form 
contradicts form hv induction hypothesis concludes case 
rest cases treated similarly 
immediately follow 
clearly proposition implies reduced exist unique evaluation context redex 
may different reductions form case ms theorem expression value pat val 

proof write 
mean evaluates steps 
assume 
prove 
induction structure lexicographically ordered 
case analysis structure chapter 
preliminaries ffl proposition exists 

induction hypothesis derive 

yields 



ev prod ffl 
exists 

form lam 

delta delta delta 
lam 


delta delta delta 
induction hypothesis 
lam 


derivable 
yields 

lam 



ev app ffl fix 

fix 
clearly 


fix ev fix cases treated similarly 
assume 
derivable prove 
structural induction derivation 
cases 



hv induction hypothesis 

yields hv evaluation contexts 

hv 
hv 
match 
case delta delta delta 
induction hypothesis 

leads 
case delta delta delta 
case delta delta delta 


lam 



induction hypothesis 
lam 


leads 

lam 
lam 


cases treated similarly 
elaboration algorithms chapter chapter map program written external language internal language 
show elaboration program preserves operational semantics 
purpose introduce notion operational equivalence pat val 
operational equivalence definition expression pat val operationally equivalent holds 
ffl context 
hi derivable 
hi write operationally equivalent clearly equivalence relation 
aim show operationally equivalent evaluation context containing free occurrences seemingly easy task turns tricky 
explain need definition proof lemma 
definition extended values extended evaluation contexts defined follows 
extended values hi hw lam fix extended evaluation contexts hf ei hw case ms 
redex reduction 
reflexive transitive closure 
clearly difference extended values values expression form fix belongs 
informally speaking allows treat expression form fix value extended evaluation context formulated 
fix regarded value redex formulated 
instance lam fix redex 
evaluation contexts extended evaluation contexts enjoy proposition 
instance ix ix fix lam lam reduced step lam ix fix lam 
proposition states relation values evaluation contexts extended values extended evaluation contexts 
proposition 

extended value 
value 
extended evaluation context expression 
evaluation context determined proof follows structural induction interesting case 
ffl form fix 



value done 
prove structural induction cases 
ffl form 
induction hypothesis 




chapter 
preliminaries ffl form 
induction hypothesis 


cases treated similarly 
relate 

clearly 
implies 
evaluation context extended evaluation context 
direction 
lemma expression value pat val 

proof assume 
proceed induction trivial 
assume 

redex reduction 
induction hypothesis 
note 

proposition 
leads 


operational semantics pat val affected treat expressions form fix values formulating evaluation contexts 
definition fi redex expression form free occurrences fi form fi redex 
write fi reflexive transitive closure fi lemma suppose fi 



fi 
means 




fi proof proceed structural induction ffl form fix 
fix fi note 



fi redex observe 
fi redex exactly case go defined notion extended evaluation context 
observation difficult see fi cases handled similarly 
proceed structural induction ffl 
subcases 

operational equivalence fi fi 
fi 


done 
fi 
fi fi 

fi 


done 
cases treated similarly 
lemma expressions pat val fi 


value 
value fi 

value 
value fi proof assume 
prove induction 

trivial 




proposition exists 
fi induction hypothesis 
value fi assume 
prove induction 

fi straightforward prove 
fi induction 



proposition cases 
ffl 

done 
ffl 
fi induction hypothesis 
value fi hold 
corollary extended evaluation context expression pat val holds occurrences proof notice fi redex 
fi suppose 
hi 

follows proposition hi 
hi 
chapter 
preliminaries suppose 
hi 

follows proposition 
hi 
implies hi value 
definition operational equivalence 
evaluation context extended evaluation context derive operational equivalence evaluation context occurrences equivalence hold extend language effects exceptions longer proof 
lastly list properties proven similarly 
proposition 

lam lam lam 

fix 
fix 



need introducing extended values extended evaluation contexts stems adoption rule ev fix non value fix substituted variable regarded value 
suggest non standard alternatives coping problem 

alternative classify variables categories 
category contains variables regarded values category contains variables regarded values 
variables bound lam category variables bound fix belong second 
avoids substituting non values variables regarded values 

second alternative replace rule ev fix evaluation rules 
readily guarantees values substituted variables 
fix 


fix 
strategy clearly justified proposition 
summary started pat val untyped calculus general pattern matching 
importance pat val lies operational semantics style natural semantics 
introduced ml typed version pat val important observation point types play role program evaluation 
shall see property kept valid typed languages introduce thesis 
emphasize studies tarditi morrisett cheng stone harper lee morrisett walker crary glew convincingly shown types helpful detecting errors compiler writing enhance performance compiled 
summary code 
demonstrate chapter dependent types lead efficient code 
addition studied operation equivalence relation pat val prove correctness type checking algorithms 
ready introduce dependent types ml chapter 
preliminaries chapter constraint domains enriched language parameterized constraint domain type index objects drawn 
typical examples constraints include linear equalities inequalities integers equations algebraic terms called herbrand domain order logic formulas finite domain chapter inspired closely related clp constraint logic programming languages jaffar maher 
general constraint language emphasize general constraint language typed 
order avoid potential confusion call types constraint language index sorts 
base index sorts propositions int integers 
signature sigma declares set function symbols associates function symbol index sort defined 
sigma structure consists set dom assignment functions function symbols sigma 
interpreted function symbols atomic predicates functions sort fl assume constants equality truth values conjunction disjunction interpreted usual 
index sorts fl fl fl fa fl pg index propositions fa fl pg subset index sort elements index sort fl satisfying proposition index proposition 
instance nat abbreviation fa int nat subset index sort int 
index variables formulation 
assume exists predicate sort fl fl index sort fl interpreted equality 
emphasize function symbols declared sigma associated index sorts form fl words constraint language order 
index objects hi hi ji fst snd index contexts oe delta oe fl oe index constraints phi phi phi oe phi fl phi fl phi index substitutions 
satisfiability relation oe phi chapter 
constraint domains index variable declared index context 
domain index context defined follows 
dom delta dom oe fl dom oe fag dom oe dom oe oe fl dom oe fl declared oe 
judgement form oe oe derived rules 
oe delta subst oe oe oe fl oe 
oe fl subst ivar oe oe oe subst prop proposition oe oe derivable dom dom oe oe oe derivable dom 
proof simply follows structural induction derivation oe oe parallel proposition 
sort formation sorting rules type index objects 
explain meanings judgements follows 
judgement form oe means oe valid index context judgement form oe fl means fl valid sort oe judgement form oe fl means sort fl oe 
constraint language explicitly sorted sort checking done straightforwardly sorting rules 
details sort checking involves constraint satisfaction subsection 
certainly allow order logic formula constraint 
practice consider subset formulas closed definition constraints 
class sigma formulas constraints call pair hd li constraint domain sigma structure 
simply constraint domain 
define oe phi follows 
delta phi phi phi phi fl fl phi fl fl phi 
ha oe fa fl pg phi oe fl oe phi oe phi oe oe phi say oe phi satisfiable hd li oe phi true model theoretic sense interpretation oe phi true 
basic rules reasoning satisfiability oe phi follows 
note exist rules induction model checking associated certain special constraint domains 

general constraint language delta empty oe oe fl oe fl ivar oe oe sort base oe oe sort unit oe fl oe fl oe fl fl sort prod oe fl oe fl oe fa fl pg sort subset oe oe fl oe fl index var oe oe hi index unit oe fl oe fl oe hi fl fl index prod oe fl fl oe fst fl index oe fl fl oe snd fl index second oe fa fl pg oe fl index var subset oe fl oe fl oe 
oe fa fl pg index subset sigma oe index cons sigma fl oe fl oe index fun sort formation sorting rules type index objects chapter 
constraint domains oe phi oe phi oe phi phi sat conj oe phi oe oe phi sat impl oe fl phi oe fl phi sat forall oe phi 
oe fl oe fl phi sat exists clearly rules 
able verify derivability satisfiability relation form oe say oe derivable constraint domain hd li oe satisfiable dom 
order verify oe satisfiable may special methods associated model checking finite domains 
readily prove oe phi satisfiable oe phi derivable 
establishes soundness approach solving constraints 
clearly may complete approach 
instance fl phi satisfiable dom may exist index expressible constraint language phi 
satisfiable 
special methods employed verify satisfiability oe may complete 
proposition 

oe oe phi derivable oe phi derivable 

oe fl oe fl phi derivable oe phi 
derivable 

oe oe oe oe phi derivable oe phi derivable 
proof straightforward 
note rule sat exists syntax directed 
serious problem hinders efficiency constraint solver 
subsection introduce procedure eliminates existential variables constraints generated type checking 
prototype implementation simply reject constraint existential quantifiers eliminated 
practical significance decision constraint solving feasible possible typical 
important reason significantly help generate comprehensible error messages experience indicates 
development depends precise form constraint domain constructs order reduce dependent type checking constraint satisfaction 
example implication oe phi necessary express constraints arising pattern matching 
subset sorts fa fl pg strictly required formulation type system crucial making system expressive practical 
constraint domain algebraic terms constraint domain algebraic terms 
signature sigma alg domain declaration form delta delta delta preferred unsorted constraint domain assume base sort term stands sort terms 
interesting example type index objects drawn sigma alg datatype represent pure untyped lambda terms de bruijn notation 

constraint domain algebraic terms dom oe delta oe delta oe delta delta delta delta oe delta oe delta oe delta oe delta oe delta oe oe delta oe oe oe oe oe oe oe oe oe oe oe 
oe 
oe oe oe 
oe 
oe oe oe oe oe oe oe oe delta oe delta oe rules satisfiability verification datatype shift abs app suppose base sort level function symbols declared sigma alg zero level level level enables refine datatype dependent type 
typeref level level shift level 
abs level 
app level 
roughly speaking de bruijn notation term type delta delta delta zero delta delta delta contains occurrences free variables term 
type closed terms zero 
simple constraint domain 
oe rules verify oe satisfiable 
notice oe oe index contexts forms respectively 
say oe satisfiable delta delta oe derivable 
clear sigma alg fixed programmer allowed declare sorts function symbols 
simple reason rules satisfiability verification chapter 
constraint domains domain effected declarations 
sample derivation 
delta level level level level level level delta level level oe delta level level oe delta delta level level oe lastly disequations allowed constraint domain rules satisfiability verification extended straightforwardly 
constraint domain integers integer constraint domain section 
signature domain 
list sample constraints generated type checking binary search program 
unfortunately exist practical constraint solving algorithms constraint domain full generality 
poses serious problem objective design dependent type system general purpose practical programming 
subsection procedure introduced eliminate existential quantifiers constraints generated type checking 
currently simply reject constraint existential quantifiers eliminated 
constraints passed constraint solver consist linear inequalities exist practical solvers 
constraint solver linear inequalities existential variables eliminated subsection resulting constraints collected check linearity 
currently reject non linear constraints postponing hard constraints michaylov planned 
constraints linear negate test unsatisfiability 
technique solving linear constraints mainly fourier motzkin variable elimination dantzig methods available purpose sup inf method shostak known simplex method 
chosen fourier motzkin method mainly simplicity 
briefly explain method 
integer variables integers linear expressions 
set inequalities show unsatisfiable 
fix variable transform linear inequalities forms ax ax 
pair introduce new inequality remove inequalities involving clearly sound incomplete procedure 
real variable elimination complete 
order handle modular arithmetic perform operation rule solutions transform inequality form delta delta delta 
constraint domain integers sigma int abs int int sgn int int succ int int pred int int int int int int int gamma int int int int int int div int int int min int int int max int int int mod int int int int int int int int int int int int int int int signature integer domain int nat size nat size size oe gamma size int nat size nat size size oe gamma gamma int nat size nat size size oe gamma gamma size int nat size nat size size oe gamma int nat size nat size size oe gamma size sample constraints chapter 
constraint domains delta delta delta largest integer greatest common divisor divides type checking optimized byte copy function section 
elimination method extended sound complete remaining practical see example pugh wonnacott pugh wonnacott 
hope sophisticated methods appear practical need context current experiments 
example show constraint solved approach 
int nat size nat size size oe gamma size step negate constraint transform form 
size size size gamma size replace gamma add gamma gamma gamma set linear inequalities 
test unsatisfiability set linear inequalities 
size size size gamma gamma gamma size eliminate variable size yielding set inequalities 
gamma gamma gamma eliminate variable generate set inequalities 
gamma gamma gamma gamma gamma gamma gamma gamma eliminate variable stage inequality gamma produced leads contradiction 
original constraint verified 
fourier variable elimination method expensive practice 
refer reader pugh wonnacott detailed analysis issue 
feel method intuitive facilitate informative type error message report constraints verified 
observed overwhelming majority constraints gathered practice trivial ones solved sound highly efficient incomplete constraint solver simplex method reals 
promising strategy efficient constraint solver filter trivial constraints sound complete relatively slow constraint solver handle rest constraints 

summary summary chapter general constraint language constraint domains constructed 
soon clear dependent type system develop parameterizes constraint domain 
ability find practical constraint solver constraint domain crucial making type checking feasible dependent type system parameterizing 
moment mechanism allow user define constraint solver declared constraint domain 
study formulating mechanism fruhwirth 
great deal study define constraint solvers efficient constraint logic programming community jaffar maher excellent source draw inspiration 
chapter 
constraint domains chapter universal dependent types chapter enrich type system ml universal dependent types yielding language ml pi fixed constraint domain 
typing rules operational semantics ml pi prove crucial properties include type preservation theorem relation operational semantics ml pi ml prove ml pi conservative extension ml order ml pi practical programming language design external language dml ml pi 
address issue unobtrusiveness programming dml elaboration mapping maps program dml ml pi 
prove correctness elaboration 
elaboration process reduces type checking program constraint satisfaction accounts major contribution thesis 
concrete example illustrate elaboration full details considerably involved process 
extension primarily serves core language eventually develop demonstrates cleanly language design approach take making dependent types available practical programming 
universal dependent types ml pi extension ml universal dependent types 
constraint domain syntax ml pi 
ffi base type families ffi hi unindexed type 
type context formation rules listed 
judgement form oe means formed type index context oe judgement form oe gamma ctx means gamma formed context oe 
notice major type type quantifier 
domains gamma oe defined usual 
note substitution thought union substitutions oe gamma dom oe contains index variables dom gamma contains ordinary variables 
specify new type families constructor types declared assume processed form 
implementation provides indexed refinement datatype declarations shown section 
syntax declarations mentioned chapter 
chapter 
universal dependent types families ffi family refined datatypes signature delta ffi fl pia fl pia fl ffi pia fl pia fl ffi major types ffi types pia fl patterns hi hp matches ms ms expressions hi case ms lam fix fl value forms hi hu lam fl values hi hv lam fl contexts gamma delta gamma index contexts oe delta oe fl oe substitutions 

syntax ml pi ffi fl oe fl oe ffi type datatype oe oe oe type match oe oe type unit oe oe oe type prod oe oe oe type fun oe fl oe pia fl type pi oe delta ctx ctx empty oe gamma ctx oe oe gamma ctx ctx var type formation rules ml 
universal dependent types delta pat var hi delta delta pat unit oe gamma oe gamma hp oe oe gamma gamma pat prod pia fl pia fl ffi ffi fl fl delta pat cons wo pia fl pia fl ffi oe gamma ffi fl fl oe gamma pat cons typing rules patterns static semantics start typing rules patterns listed 
judgment oe gamma expresses index ordinary variables pattern types declared oe gamma respectively know type write oe congruent extension oe index objects types determined rules 
oe oe ffi ffi oe oe oe oe oe oe oe fl oe pia fl pia fl proposition oe oe oe oe derivable oe derivable 
proof simply follows structural induction derivation oe application proposition 
typing rules ml pi 
require free occurrences gamma dom gamma rule ty applied 
note premise oe rule ty match enforces index variables declared oe 
rule ty cons wo applies constructor argument 
argument rule ty cons applies 
proposition inversion oe gamma derivable inference rule derivation oe gamma ty eq uniquely determined structure proof inspection typing rules 
proposition frequently structural induction typing derivations allows determinate applied rule derivations 
chapter 
universal dependent types oe gamma oe oe gamma ty eq oe gamma ctx gamma oe gamma ty var pia fl pia fl ffi oe fl delta delta delta oe fl oe gamma ctx oe gamma ffi 
ty cons wo pia fl fl ffi oe fl delta delta delta oe fl oe gamma 
oe gamma ffi 
ty cons oe gamma ctx oe gamma hi ty unit oe gamma oe gamma oe gamma ty prod oe gamma oe oe gamma gamma oe oe gamma ty match oe gamma oe gamma ms oe gamma ms ty matches oe gamma oe gamma ms oe gamma case ms ty case oe fl gamma oe gamma fl pia fl ty oe gamma pia fl oe fl oe gamma 
ty oe gamma oe gamma lam ty lam oe gamma oe gamma oe gamma ty app oe gamma oe gamma oe gamma ty oe gamma oe gamma fix ty fix typing rules ml pi 
universal dependent types match 
match var match hi hi match unit match match match hp match prod match 

match cons wo match match 

match cons pattern matching rules ml pi turn operational semantics 
matching pattern value yields substitution domain includes index ordinary variables written judgment match 
gamma oe gamma oe judgement form oe gamma oe gamma derived application rules 
oe gamma delta delta subst empty oe gamma oe gamma oe gamma oe gamma 
oe gamma subst var oe gamma oe gamma oe fl oe gamma 
oe fl gamma subst ivar oe gamma oe gamma oe oe oe oe gamma oe gamma subst meaning judgement form oe gamma oe gamma proposition 
proposition oe gamma oe gamma derivable dom gamma dom gamma dom oe dom oe oe derivable index proposition declared oe proof directly follows structural induction derivation oe gamma oe gamma 
lemma substitution oe oe gamma gamma oe gamma oe gamma derivable oe gamma derivable 
proof follows structural induction derivation oe oe gamma gamma parallel proof lemma 
cases 
chapter 
universal dependent types oe oe gamma gamma oe oe oe oe gamma gamma induction hypothesis oe gamma derivable 
clearly oe oe oe derivable implies oe oe oe derivable 

oe gamma oe oe oe oe oe gamma oe ty eq definition oe oe 
concludes case 
oe oe gamma gamma oe oe gamma gamma oe oe gamma gamma induction hypothesis oe gamma derivable 
leads derivation 
oe gamma oe gamma oe gamma ty prod done 
cases handled similarly 
lemma assume dom oe occurs pattern oe gamma oe gamma match derivable oe gamma oe gamma derivable 
proof follows structural induction derivation oe gamma parallel proof lemma 
dom oe occurs pattern dom oe dom oe 
interesting case 
match match 

derivation oe gamma form pia fl pia fl ffi oe gamma ffi fl fl oe gamma pat cons ffi oe fl fl oe induction hypothesis oe gamma oe gamma derivable 
suppose derivation oe gamma form pia fl fl ffi oe fl delta delta delta oe fl oe gamma 
oe gamma ffi 
ty cons 
clearly oe 

universal dependent types immediately follows oe gamma oe gamma derivable 
note oe gamma derived follows oe gamma oe oe gamma ty eq ffi oe gamma derived application ty cons 


infer oe oe implies oe leading derivation oe gamma oe gamma 
cases treated similarly 
lemma crucial proving type preservation theorem ml pi formulated theorem 
dynamic semantics natural semantics ml pi rules 
note 
means reduces value semantics 
notice type indices evaluated 
highlights language design decision exist direct interactions indices code execution 
reasoning type indices requires constraint satisfaction done statically type checking 
theorem type preservation ml pi ml pi 
derivable 
oe gamma derivable oe gamma derivable 
proof theorem follows structural induction derivation 
derivation oe gamma lexicographically ordered 
rule derivation oe gamma oe gamma oe oe gamma ty eq induction hypothesis oe gamma derivable 
oe gamma oe oe gamma ty eq allows assume rule derivation oe gamma ty eq rest proof 
cases 

match 
case delta delta delta 
proposition rule derivation oe gamma form 
oe gamma oe gamma delta delta delta oe gamma case delta delta delta ty case chapter 
universal dependent types 
ev var 
ev cons wo 

ev cons hi 
hi ev unit 


hv ev prod 
match 
case delta delta delta 
ev case 
fl 
fl ev 
fl 

ev lam 
lam ev lam 
lam 



ev app 



ev fix 

fix ev fix natural semantics ml pi 
universal dependent types clearly 
oe gamma oe oe gamma gamma oe oe gamma ty match induction hypothesis oe gamma derivable 
oe gamma oe gamma derivable lemma 
implies oe gamma derivable lemma 
induction hypothesis oe gamma derivable 

fl 
fl proposition oe fl gamma derivable pia fl induction hypothesis oe fl gamma derivable yields 
oe fl gamma oe gamma fl pia fl ty 
fl 

proposition derivation form oe gamma pia fl oe fl oe gamma ty 

induction hypothesis oe gamma fl pia fl derivable yields oe fl gamma derivable 
lemma oe gamma 

derivable 
cases handled similarly 
intention construct interpreter compiler natural semantics ml pi 
intend existing compilers ml compile programs written ml pi 
index erasure function delta mainly introduced purpose 
note different type erasure function delta roughly speaking index erasure function erases related type index objects mapping ml pi programs ml ones 
definition index erasure function delta defined 
maps expression ml pi ml order justify index erasure function supposed show index erasure ml pi program behaves properly sense 

ml pi program evaluates natural semantics ml pi verify kek evaluates kvk natural semantics ml 
ml pi program erasure kek evaluates natural semantics ml verify evaluates natural semantics ml pi kvk chapter 
universal dependent types ffi pia fl kk kxk kc kc kek hi ik ke ki kp kpk kek case ms case kek lam lam kk kek ke ke ke fl kek ke kek ke ke uk fix kk kuk delta delta gamma gammak kk delta delta ks ffi fl ksk ffi ks ksk kk 


kek definition erasure function delta proven theorem theorem respectively 
proposition 

kk ke kek 

kuk value form ml value form ml pi 

kvk value ml value ml pi 

oe gamma derivable kpk kk gammak derivable 

match derivable ml pi match kpk kvk derivable ml 
universal dependent types 
ml pi oe gamma oe gamma derivable 
match kpk kvk derivable match derivable 
oe derivable proof omit proofs straightforward 
proven structural induction derivation oe gamma case 
derivation form 
pia fl pia fl ffi oe gamma ffi fl fl oe gamma pat cons induction hypothesis derivation 
ksk kk ffi kpk kk gammak kpk ffi gammak pat cons notice kc kpk ffi fl fl oe gamma gammak done 
follows straightforward structural induction derivation match 
case 
match match 

induction hypothesis match kpk kvk leads 
match kpk kvk match kpk kvk match cons kc kpk kc kvk 

done 
cases treated similarly 
proof proceeds structural induction derivation match kpk kvk parallel 
proven structural induction derivation oe theorem oe gamma derivable ml pi gammak kek kk derivable ml chapter 
universal dependent types proof simply follows structural induction derivation oe gamma say expression ml pi ml typable oe gamma gamma derivable oe gamma ml pi gamma ml 
say untyped expression pat val typable ml pi ml type erasure typable expression ml pi ml 
sense clear theorem expressions pat val typable ml pi typable ml hand great deal research designing type systems strictly expressions pat val typable type systems typable ml instance type system extending ml polymorphism allows expressions pat val typable 
respect significantly different 
roughly speaking objective assign expressions accurate types expressions typable 
theorem 
derivable ml pi kek 
kvk derivable 
proof simply follows structural induction derivation 
cases follows 

match 
case delta delta delta 
induction hypothesis ke 
kv derivable 
proposition match kp kv derivable 
induction hypothesis ke 
kvk derivable ke ke proposition 
leads 
ke 
kv match kv kp ke 
kvk case ke kp ke delta delta delta kp ke 
kvk ev case note delta delta delta case ke kp ke delta delta delta kp ke done 

fl 
fl induction hypothesis ke 
kv derivable 
note fl ke fl kv done 

fl 

induction hypothesis ke 
fl kv derivable 
note ke ke kv 
kv proposition 
done 
rest cases handled similarly 
theorem type indices interact program evaluation 
soundness argument sense proven index erasure sound respect evaluation 
prove index erasure complete respect evaluation formulated theorem 
lemma needed proof 

universal dependent types lemma value ml pi oe delta pia fl derivable form fl value proof follows structural induction derivation oe gamma pia fl 
oe delta oe pia fl oe delta pia fl form pia fl induction hypothesis claimed form 
oe fl delta oe delta fl pia fl fl done 
note applied rule ty var 
value rules applied rule concludes proof 
theorem oe delta derivable ml pi 
kek 
derivable ml exists ml pi 
derivable kvk proof theorem follows structural induction derivation 
derivation oe delta lexicographically ordered 
applied rule derivation oe delta oe delta oe oe delta ty eq induction hypothesis 
derivable kvk allows assume applied rule derivation oe delta ty eq rest proof 
cases 
oe delta oe delta delta delta delta oe delta case delta delta delta derivation 
form 

match 
case delta delta delta 
ev case ke kp ke clearly oe gamma oe oe delta gamma oe oe delta ty match induction hypothesis 
derivable kv oe delta derivable theorem 
proposition match derivable note ke proposition oe delta oe gamma derivable lemma 
yields oe delta derivable lemma 
induction hypothesis 
derivable kvk chapter 
universal dependent types oe fl delta oe delta fl pia fl ka fl ke 
induction hypothesis 
kv 

fl 
fl ev note ka fl kv concludes case 
oe delta pia fl oe fl oe delta 
ke ke 
induction hypothesis 
theorem oe delta pia fl derivable 
notice form fl lemma 
leads 



ev kv 
kv kv done 
cases treated similarly 
completely justified evaluation strategy ml pi typed expression ml pi erase type indices obtain typed expression kek ml evaluate ml theorem theorem yields expected result 
stage report interesting phenomenon ml pi 
example closed expression ml pi type pim nat pin nat intlist intlist kek cons nili evaluates value ml suppose kek cons nili evaluates theorem type intlist type intlist cons nili 
cons nili 
kv kv contradiction list length zero 
mean define function ml pi type pim nat pin nat intlist intlist 
matter fact function type 
nat nat lam intlist case nil nil call expression reader readily verify cons nili evaluates value 
turns kind types significantly complicate constraints generated elaboration process develop section 
main reason lies existential variable elimination approach introduced subsection cope constraints produced types checked 
types little practical intend find syntactic approach disallowing 
research topic 

elaboration straightforward observation typing rules ml pi theorem holds 
theorem ml pi conservative extension ml gamma ml delta gamma 
derivable ml pi gamma 
derivable ml proof part immediately follows inspection typing evaluation rules ml allowed ml pi 
show part 
ml rule ty rule ty applied derivation delta gamma derivation easily lead derivation gamma ml similarly derivation 
readily yield derivation 
novelty approach enriching type system ml dependent types precisely restricted form dependent types type index objects language expressions separated 
prevent reasoning values expressions type system introduce singleton types relate value expression index 
example refine type int infinitely singleton types int gamma gamma contains integer type check expression type int know run time value equal instance allows determine compile time value expression type int certain range 
please see section details issue 
emphasize ml ml pi theorem explicitly typed internal languages simply conclude programmer index types programs programs valid ml pi valid ml obvious reason programmer writes programs external language may fully explicitly typed 
programs needs elaborated corresponding explicitly typed ones internal language 
order guarantee valid programs written external language ml successfully elaborated explicitly typed programs ml pi design phase type checking algorithm chapter achieving full compatibility 
elaboration far explicitly typed language ml pi 
presentation serious drawback programmer point view quickly get overwhelmed types programming setting 
apparent necessary provide external language dml mapping dml internal language ml pi 
mapping called elaboration 
note phrase type checking mean elaboration 
external language dml ml pi syntax dml follows 
chapter 
universal dependent types patterns hi hp matches ms ms expressions hi case ms lam lam fix fl means annotated type type annotations program crucial elaboration 
need fl explained section restricted way 
note syntax dml basically syntax ml types dependent types 
partially attests unobtrusiveness enrichment 
type erasure function delta expressions ml pi defined obvious way 
please note delta different index erasure function delta maps ml pi expression ml 
elaboration static semantics illustrate intuition elaboration rules presenting 
elaboration incorporates type checking defined mutually recursive judgments synthesize type done general way check term type synthesis possible 
synthesizing judgement form oe gamma means elaborates type checking judgement form oe gamma means elaborates type general ms external expressions patterns matches ms internal counterparts 
purpose rules eliminate universal quantifiers 
instance assume code type form pia fl synthesized apply rule elab pi elim remove quantifier type continue doing major type reached form code type correct 
note actual index locally determined existential variable constraint solver 
rule elab pi intro simpler check dependent functional type 
course require free occurrences gamma dom gamma elab pi intro applied 
oe gamma pia fl oe fl oe gamma 
elab pi elim oe fl gamma oe gamma pia fl fl elab pi intro rule lambda abstraction checks lam expression type 
rule fixed point operator similar 
emphasize synthesize types lam fix expressions principal types exist general 
oe gamma oe gamma lam lam elab lam 
elaboration delta elab pat var hi hi delta delta elab pat unit oe gamma oe gamma hp hp oe oe gamma gamma elab pat prod pia fl pia fl ffi ffi fl fl oe gamma elab pat cons wo pia fl pia fl ffi oe gamma ffi fl fl oe gamma elab pat cons elaboration rules patterns rule function application interaction kinds judgments takes place 
synthesizing major type simply check synthesis unnecessary 
oe gamma oe gamma oe gamma elab app maintain invariant shape types variables context determined modulo possible index constraints may need solved 
means rules check normal forms 
term normal form expression case require type annotation illustrated rules expressions 
oe gamma oe gamma oe gamma elab checking type synthesize type function fixpoint type practice writing abbreviates 
rule allows take advantage annotations 
oe gamma oe gamma elab anno result types appearing realistic programs due declarations functions cases polymorphic instantiation 
explained subsection 
presence existential dependent types introduced chapter pure ml type dependencies obtained phase type checking assumed explicit type annotation 
extension truly conservative sense pure ml programs exactly requiring annotations 
elaboration rules patterns particularly simple due constraint nature types constructors 
elaborate pattern type yielding internal pattern chapter 
universal dependent types index context oe ordinary context gamma respectively 
written oe gamma 
judgment rules pattern matching 
generated index context oe assumed index context oe elaborating shown rule elab match 
constraint satisfaction treated hypotheses 
oe gamma oe oe gamma gamma oe oe gamma elab match instance constructor cons type pia nat int intlist intlist 
cons int delta int xs intlist xs delta xs intlist hx xsi int intlist hx xsi delta int xs intlist cons hx xsi intlist cons hx xsi nat int xs intlist lemma oe gamma derivable kp oe gamma derivable 
proof proof proceeds structural induction derivation oe gamma 
cases follows 
oe gamma oe gamma hp hp oe oe gamma gamma induction hypothesis kp oe gamma derivable 
hp ik derive hp oe oe gamma gamma follows 
oe gamma oe gamma hp oe oe gamma gamma elab pat prod concludes case 
pia fl pia fl ffi oe gamma ffi fl fl oe gamma induction hypothesis kp oe gamma derivable 
kc derivable 
pia fl pia fl ffi oe gamma ffi fl fl oe gamma elab pat cons concludes case 
cases straightforward 
complete list elaboration rules ml pi 
correctness rules justified theorem 
certain amount nondeterminism formulation elaboration rules 
instance contention rules elab pi intro elab pi intro applicable 
case choose 

elaboration oe gamma pia fl oe fl oe gamma 
elab pi elim oe fl gamma oe gamma pia fl fl elab pi intro oe fl gamma oe gamma fl pia fl fl elab pi intro gamma oe gamma ctx oe gamma elab var oe gamma oe oe gamma elab var pia fl pia fl ffi oe fl delta delta delta oe fl oe gamma ffi 
elab cons wo oe gamma oe oe gamma elab cons wo pia fl pia fl ffi oe gamma 
oe fl delta delta delta oe fl oe gamma ffi 
elab cons oe gamma oe oe gamma elab cons oe gamma hi hi elab unit oe gamma hi hi elab unit oe gamma oe gamma oe gamma elab prod oe gamma oe gamma oe gamma elab prod elaboration rules ml pi chapter 
universal dependent types oe gamma oe oe gamma gamma oe oe gamma elab match oe gamma oe gamma ms ms oe gamma ms ms elab matches oe gamma oe gamma ms ms oe gamma case ms case ms elab case oe gamma oe gamma lam lam elab lam oe gamma oe gamma oe gamma lam lam elab lam anno oe gamma oe gamma oe gamma elab app oe gamma oe oe gamma elab app oe gamma oe gamma oe gamma elab oe gamma oe gamma oe gamma elab oe gamma oe gamma fix fix elab fix oe gamma oe gamma oe gamma fix fix elab fix oe gamma oe gamma elab anno oe gamma oe oe gamma elab anno elaboration rules ml pi ii 
elaboration notice occurrences major types types pi quantifier elaboration rules 
major types pragmatic strategy aims making elaboration flexible 
introducing existential dependent types chapter introduce coercion function subsection replace strategy 
theorem 

oe gamma derivable oe gamma derivable jej je 
oe gamma derivable oe gamma derivable je jej 
proof follow straightforwardly simultaneous structural induction derivations oe gamma oe gamma cases 
oe gamma pia fl oe fl oe gamma 
induction hypothesis oe gamma pia fl derivable je jej 
leads 
oe gamma pia fl oe fl oe gamma 
ty clearly je je jej 
oe gamma oe oe gamma induction hypothesis oe gamma derivable je 
oe gamma oe oe gamma ty eq oe gamma oe gamma lam lam induction hypothesis oe gamma derivable je jej 
yields 
oe gamma oe gamma lam ty lam note lam je lam jej ej 
done 
oe gamma oe gamma oe gamma lam lam induction hypothesis oe gamma oe gamma derivable je jej je leads 
oe gamma oe gamma oe gamma ty oe gamma lam ty lam chapter 
universal dependent types notice 
lam je je lam je lam je lam jej ej concludes case 
oe gamma oe gamma oe gamma fix fix induction hypothesis oe gamma oe gamma derivable 
leads 
oe gamma oe gamma fix ty fix oe gamma oe gamma fix ty induction hypothesis ju juj je yields 
fix fix ju je fix juj fix juj fix note fix juj fix juj follows corollary 
cases treated similarly 
description type reconstruction static semantics intuitively appealing gap description implementation 
elaboration rules explicitly generate constraints reduce dependent type checking constraint satisfaction 
subject subsection 
elaboration constraint generation objective turn elaboration rules rules generate constraints immediately applied 
purpose extend language type index objects follows 
existential variables index objects delta delta delta existential contexts delta fl existential substitutions 
intuitively speaking existential variables represent unknown type indices elaboration postpone solutions indices information 
list constraint generation rules 
note assume declared expand fl 
assume share common existential variables form context notice occurrence rules constr pi intro constr pi intro 
decorate 
elaboration prevent existential variable declared unifying index free occurrences note oe stand fl fl respectively oe fl fl proposition declared oe label free index variables 
define label oe follows 
label delta label oe label oe dom judgement form oe derived rules 
oe oe delta oe fl label oe oe oe 
oe oe 
fl phi fl fl phi fl fl index context oe existential context form mixed context oe follows 
delta oe delta oe fl oe fl fl fl oe dom 
fl oe fl dom judgements forms oe fl oe derived usual similar judgements forms oe fl 
proposition assume oe derivable 

oe fl derivable oe fl 

oe derivable oe 
oe gamma ctx derivable oe gamma ctx 
proof immediately follows structural induction derivations oe fl oe oe gamma ctx respectively 
judgement form oe gamma phi basically means elaborates expression synthesized type generating constraint phi existential variables declared 
similarly judgement form oe gamma phi means elaborates expression type generating constraint phi existential variables declared 
turned type checking constraint satisfaction 
index context oe constraint formula phi define oe phi follows 
delta phi phi oe fl phi oe fl phi oe phi oe oe phi proposition suppose oe gamma phi oe gamma phi derivable 
oe gamma ctx oe oe phi derivable 
chapter 
universal dependent types oe gamma phi oe fl oe gamma fl phi constr weak oe gamma pia fl phi oe gamma 
fl phi constr pi elim oe fl gamma 
phi oe gamma ctx oe gamma fl pia fl fl phi constr pi intro oe fl gamma phi oe gamma ctx oe gamma pia fl fl phi constr pi intro gamma oe gamma ctx oe gamma 
constr var oe gamma 
oe oe gamma ctx oe gamma constr var pia fl pia fl ffi oe gamma oe gamma ffi 
fl fl 
constr cons wo oe gamma ffi 
oe ffi oe gamma ctx oe gamma ffi ffi ffi constr cons wo pia fl pia fl ffi oe gamma 
fl fl phi oe gamma ffi 
fl fl phi constr cons oe gamma ffi phi oe ffi oe gamma ctx oe gamma ffi phi ffi ffi constr cons oe gamma ctx oe gamma hi 
constr unit oe gamma ctx oe gamma hi 
constr unit oe gamma phi oe gamma phi oe gamma phi phi constr prod oe gamma phi oe gamma phi oe gamma phi phi constr prod constraint generation rules ml pi 
elaboration oe gamma oe oe gamma gamma phi oe oe gamma ctx oe gamma oe phi constr match oe gamma phi oe gamma ms phi oe gamma ms phi phi constr matches oe gamma phi oe gamma ms phi oe gamma case ms phi phi constr case oe gamma phi oe gamma lam phi constr lam oe gamma phi oe gamma phi oe gamma lam phi phi constr lam anno oe gamma phi oe gamma phi oe gamma phi phi constr app oe gamma phi oe oe gamma ctx oe gamma phi constr app oe gamma phi oe gamma phi oe gamma phi phi constr oe gamma phi oe gamma phi oe gamma phi phi constr oe gamma phi oe gamma fix phi constr fix oe gamma phi oe gamma phi oe gamma fix phi phi constr fix oe oe gamma phi oe oe oe gamma phi constr anno oe gamma 
oe oe gamma ctx oe gamma constr anno constraint generation rules ml pi ii chapter 
universal dependent types proof simply follows simultaneous structural induction derivations oe gamma phi oe gamma phi 
theorem relates constraint generation rules elaboration rules justifying correctness constraint generation rules 
theorem 

suppose oe gamma phi derivable 
oe phi provable oe derivable exists oe gamma derivable 

suppose oe gamma phi derivable 
oe phi provable oe derivable exists oe gamma derivable 
proof follows simultaneous structural induction derivations gamma phi oe gamma phi 
cases follows 
oe fl gamma phi oe gamma pia fl fl phi note fl phi fl phi oe derivable 
derivation oe fl phi form 
oe fl phi oe fl phi induction hypothesis oe fl gamma derivable 
leads 
oe fl gamma oe gamma pia fl elab pi intro note pi fl pi fl done 
oe gamma phi oe gamma phi oe gamma phi phi exists oe phi phi derivable 
implies oe phi oe phi derivable 
induction hypothesis oe gamma derivable leads 
oe gamma oe gamma oe gamma elab prod note 
done 
oe gamma phi oe gamma ms phi oe gamma case ms phi phi oe phi phi derivable oe holds 
implies oe phi oe phi derivable 

elaboration induction hypothesis oe gamma oe gamma ms ms derivable ms leads 
oe gamma oe gamma ms ms oe gamma case ms case ms elab case done 
oe gamma phi oe gamma phi oe gamma phi phi oe phi phi derivable oe derivable 
oe phi derivable yields oe gamma derivable induction hypothesis oe gamma derivable oe phi derivable 
yields 
oe gamma oe gamma oe gamma elab app done 
oe gamma phi oe oe gamma ctx oe gamma phi oe phi derivable oe holds 
note phi phi oe phi derivable 
means oe phi derivable oe holds 
implies oe derivable 
induction hypothesis oe gamma derivable oe gamma ctx oe derivable oe oe oe gamma gamma gamma 
oe gamma derivable 
oe gamma phi oe gamma phi oe gamma phi phi oe phi phi derivable oe holds 
clearly phi phi phi phi oe phi oe phi derivable 
induction hypothesis oe gamma oe gamma derivable 
leads 
oe gamma oe gamma oe gamma elab done 
chapter 
universal dependent types oe gamma phi oe oe gamma phi oe phi derivable oe holds 
induction hypothesis oe gamma derivable contain existential variables leads 
oe gamma oe gamma elab anno cases handled similarly 
closed expression external language dml try derive judgement form delta delta phi 
succeed type annotations theorem typable delta phi provable 
way type checking ml pi reduced constraint satisfaction 
indeterminacy constraint generation rules handled implementation 
instance rules constr pi intro constr pi intro applicable decided applied 
explain issues chapter 
informal explanation constraint generation rules explain rule constr weak needed 
note rule oe gamma phi oe gamma phi oe gamma phi phi constr prod premises existential variable declaration 
oe gamma phi oe gamma phi derived different oe oe order obtain oe rule constr weak needs applied 
question replace rule constr prod 
oe gamma phi oe gamma phi oe gamma phi phi unfortunately replacement readily invalidate proposition breaks proof theorem 
example 
suppose try derive phi 
fl ffi ffi hx yi ffi ffi fl fl phi need derive phi fl ffi ffi hx yi fl fl phi impossible find fl fl fl ffi ffi phi fl ffi ffi phi 
elaboration derivable phi phi respectively 
instance fl judgement fl ffi ffi phi ill formed declared 
briefly mention constraint generation rules implemented 
associate function judgements form oe gamma phi triple oe gamma returns triple phi 
similarly associate function judgements form oe gamma phi returns phi oe gamma 
occasions need variant returns pair phi quadruple oe gamma 
instance computing oe gamma need compute oe gamma get pair phi compute oe gamma get phi result oe gamma phi phi actual implementation simply follows constraint generation rules omit details 
example elaboration simple example full details illustrate constraint generation rules applied 
ml type checking involved ml pi strongly recommend reader follow details carefully 
especially helpful reader intends understand type checking performed existential dependent types highly complicated subject chapter 
basically auxiliary tail recursive function body reverse function replaced polymorphic type list monomorphic type intlist 
introduce polymorphic types chapter 
fun rev nil ys ys rev xs ys rev xs ys rev nat nat intlist intlist 
intlist code corresponds expression formal external language dml fix rev pim nat pin nat intlist intlist intlist body body lam pair case pair hnil ysi ys hx xsi ysi rev hxs cons hx ysi sake simplicity omit parts constraint generation rule generate constraints write constraint generation rules presentation 
dml expression 
aim constructing derivation judgement delta delta delta phi phi derivation form delta rev body delta phi delta delta delta phi constr fix chapter 
universal dependent types pim nat pin nat intlist intlist intlist derivation form phi nat nat rev body delta phi nat rev body pin nat delta nat phi constr pi intro delta rev body delta nat nat phi constr pi intro phi nat nat phi intlist intlist intlist 
reach derivation form oe gamma case pair ms intlist delta phi nat nat rev body delta phi constr lam oe nat nat gamma rev pair intlist intlist ms hnil ysi ys hx xsi ysi rev hxs cons hx ysi reach derivation form phi phi phi phi phi oe gamma pair delta phi oe gamma ms intlist delta phi oe gamma case pair ms intlist delta phi phi constr case clearly derivation intlist intlist phi 
gamma pair oe gamma pair delta phi constr var reach derivation form phi phi phi oe gamma ms intlist intlist intlist delta phi phi constr matches derivation oe gamma hnil ysi ys intlist intlist intlist delta phi derivation oe gamma hx xsi ysi ys intlist intlist intlist delta phi clearly form oe gamma hnil ysi oe gamma oe oe gamma gamma ys delta phi oe gamma hnil ysi ys delta phi constr match 
elaboration intlist 
notice derivation hnil ysi oe gamma ys intlist 
nil intlist nil intlist nil delta ys intlist ys delta ys intlist hnil ysi oe gamma derivation phi oe intlist intlist 
gamma ys intlist oe oe gamma gamma ys intlist delta oe oe gamma gamma ys delta intlist intlist constr var oe gamma hnil ysi ys delta phi constr match turn attention clearly form oe gamma hx xsi ysi oe gamma oe oe gamma gamma rev hxs cons hx ysi delta phi oe gamma hx xsi ysi ys delta phi phi oe phi notice derivation cons cons int delta int xs intlist xs delta xs intlist hx xsi hx xsi delta int xs intlist cons hx xsi intlist cons hx xsi nat int xs intlist cons pia nat int intlist intlist 
leads derivation hx xsi ysi oe nat gamma int xs intlist ys intlist 
ys intlist ys delta ys intlist hx xsi ysi oe gamma elab pat prod task construct derivation form oe oe gamma gamma rev phi oe oe gamma gamma hx xsi ysi phi oe oe gamma gamma rev hxs cons hx ysi phi phi 
oe oe gamma gamma rev hxs cons hx ysi delta phi constr app obviously derivation intlist intlist intlist nat nat phi oe oe gamma gamma rev pim nat pin nat intlist intlist intlist delta oe oe gamma gamma rev pin nat intlist intlist intlist nat oe oe gamma gamma rev phi chapter 
universal dependent types need construct derivation form oe oe gamma gamma intlist phi oe oe gamma gamma cons hx ysi intlist phi oe oe gamma gamma hxs cons hx ysi phi phi phi phi phi clearly derivation phi intlist intlist 
gamma xs intlist oe oe gamma gamma xs intlist 
constr var oe oe gamma gamma xs intlist phi constr var derivation gamma int oe oe gamma gamma int nat 
constr var oe oe gamma gamma int nat int int constr var derivation 
gamma ys intlist oe oe gamma gamma ys intlist nat 
constr var oe oe gamma gamma ys intlist nat intlist intlist constr var derivation cons cons oe oe gamma gamma hx ysi int intlist nat phi constr prod oe oe gamma gamma cons hx ysi intlist nat phi constr cons oe oe gamma gamma cons hx ysi intlist phi constr app phi nat 
phi intlist intlist phi int int intlist intlist 
far constructed derivation oe oe gamma gamma rev hxs cons hx ysi phi phi leads phi phi phi intlist intlist 
oe oe gamma gamma rev hxs cons hx ysi phi phi oe oe gamma gamma rev hxs cons hx ysi delta phi constr app finished construction derivation delta delta delta phi phi nat nat phi nat nat phi phi nat nat 
phi phi nat nat 
oe intlist intlist phi phi nat oe phi nat oe nat nat phi phi intlist intlist nat oe nat nat 
phi intlist intlist phi phi phi nat intlist intlist phi intlist intlist phi int int intlist intlist 
elaboration replace ffi ffi remove phi reduced 
nat nat oe nat oe nat nat nat eliminate existential quantifiers phi substituting obtain constraint 
nat nat oe nat oe validity constraint readily verified 
phi derivable implying typed 
elimination existential quantifiers crucial simplifying constraints crucial practicality approach 
address issue subsection 
elimination existential variables shown existential variables eliminated constraint generated example subsection elaborated 
observation indicates case examples experiment 
suggests eliminate existential quantifiers possible constraint passing constraint solver 
rule eliminating existential quantifiers constraints 
judgement form oe fl phi means oe fl derivable oe phi reflected proposition 
theorem oe fl phi oe phi derivable oe fl derivable 
proof simply follows structural induction derivation oe fl phi 
case 
oe fl phi oe fl phi oe fa fl pg 
phi fl phi oe 
phi fl phi derivable oe 
oe phi oe fl phi derivable 
induction hypothesis oe fl oe fl derivable 
leads 
oe fl oe fl oe 
oe fa fl pg index subset cases handled similarly 
solve fl phi phi mean solving phi yields index constraint phi solves phi phi means solving phi existential variables declared generates substitution domain constraint phi phi phi means eliminating existential variables phi yields constraint phi chapter 
universal dependent types proposition 

suppose oe oe solve fl phi phi derivable 
oe oe phi 
derivable oe oe phi 


suppose oe solves phi phi 
oe phi derivable oe phi 

suppose oe phi phi derivable 
oe phi derivable oe phi 
proof follows structural induction derivation oe oe solve fl phi phi follows structural induction derivation oe solves phi phi help 
follows 
established correctness rules eliminating existential variables constraints 
summary language ml pi extends language ml universal dependent types formulated parameterize constraint domain call type system ml pi restricted form dependent type system reason 
view index objects expressions ml pi terms 
view type term depend value terms 
instance type reverse intlist depends alternative view index objects types regard type system ml pi polymorphic type system 
alternative leads serious complications 
instance unclear expressions type index object 
view complicates interpretation subset sorts significantly 
operational semantics ml pi style natural semantics type indices evaluated 
highlights language design decision requires reasoning type indices done statically 
proven ml pi enjoys type preservation property theorem 
emphasize evaluate type indices chooses 
simply need doing 
clearly changed run time type checking necessary currently reject programs pass dependent type checking 
important aspect ml pi untyped expressions typable ml pi ml theorem 
distinguishes study emphasize enriching type system expressions typable 
objective assign expressions accurate types expressions typable 
theorem constitutes major contribution thesis 
yields strong justification methodology adopted developing dependent type systems practical programming 
dependent types usefulness programming noticed decades 
great difficulty designing type checking algorithm dependent type system major obstacle hinders wide dependent types programming 
briefly explain reason follows 
fully dependent type system underlies lf harper honsell plotkin coq coquand huet differentiation type index 
summary oe oe sigma fl oe fl phi oe phi oe fl phi oe fl phi oe hi fl fl phi phi oe fl phi oe fl phi oe fa fl pg 
phi fl phi oe fl phi label oe oe oe solve fl phi oe fl phi label oe oe oe solve fl phi oe oe solve fl phi phi oe oe solve fl oe phi oe phi oe oe fl solve fl phi phi oe oe solve fl fl phi fl phi oe oe solve fl phi phi oe oe solve fl phi phi phi phi oe oe solve fl phi phi oe oe solve fl phi phi phi phi oe solves delta phi phi oe fl solves phi phi oe delta solve fl phi phi oe solves fl phi ffi 
phi 
oe oe phi phi oe phi phi oe phi phi phi phi oe phi phi oe oe phi oe phi oe fl phi phi oe fl phi fl phi oe phi phi oe delta solves phi phi oe phi phi rules eliminating existential variables chapter 
universal dependent types objects expressions system 
words expression type index object 
suppose extend type system ml fully dependent type system 
setting constraint domain programming language theorem offers little benefit constraint satisfaction difficult program verification intractable practical programming 
intuitive argument suggests may attractive idea fully dependent types programming language 
hand choose relatively simple constraint domain practical approaches constraint satisfaction guaranteed theorem elaboration ml pi practical 
instance integer constraint domain chapter falls category 
burden programmer provide sufficient type annotations code experience suggests requirement overwhelming part type annotations usually consist entire code 
type annotations fully trusted program documentation verified mechanically avoiding code comments stay common symptom programming 
effectiveness dependent types program error detection compiler optimization chapter moderate number type annotations needed type checking program feel practicality approach gained solid justification 
chapter existential dependent types chapter enrich type system ml pi existential dependent types yielding language ml pi sigma 
illustrate examples need existential dependent types formulate corresponding typing rules elaboration algorithm 
similar development chapter significantly involved 
existential dependent types need existential dependent types immediate 
example clearly illustrates aspect point 
fun filter pred nil nil filter pred xs pred filter xs filter xs function ilter eliminates elements list satisfy predicate 
predicate list calculate length ilter general know types impossible assign ilter dependent type form pin nat intlist intlist index intuitively able assign ilter type pim nat intlist sigman nat intlist sigman nat intlist roughly means integer list unknown length 
main reason introducing existential dependent types cope existing library code 
instance lib function library non dependent type intlist intlist 
general refine type lib access source code lib 
intuitively able assign function lib type sigman nat intlist 
sigman nat intlist order check code lib called intlist refined 
provides smooth interaction dependent non dependent types 
existential dependent types facilitate array bound check elimination 
example implementation knuth morris pratt string search algorithm computes integer array elements index array assign array chapter 
existential dependent types type sigman nat int array array natural numbers check element array size array index array unnecessary check nonnegative type sigman nat int implies 
refer reader code section details 
experience indicates existential dependent types indispensable practice 
instance examples appendix existential dependent types 
enrich language ml pi existential dependent types call enriched language ml pi sigma 
addition syntax ml pi need 
types sigmaa fl expressions hi ei ha xi value forms hi ui values hi vi formation existential dependent type follows 
oe fl oe sigmaa fl type sig rule needed extending type congruence relation including existential dependent types 
oe fl oe sigmaa fl sigmaa fl typing rules existential dependent types 
note ty sig elim applied free occurrence gamma oe gamma 
oe fl oe gamma hi ei sigmaa fl ty sig intro oe gamma sigmaa fl oe fl gamma oe gamma ha xi ty sig elim addition evaluation rules need rules formulate natural semantics ml pi sigma 

hi ei 
hi vi ev sig intro 
hi 


ha xi 
ev sig elim prove expected properties ml pi sigma 
part development ml pi sigma parallel ml pi 
theorem type preservation ml pi sigma ml pi sigma 
derivable 
oe gamma derivable oe gamma derivable 
proof theorem follows structural induction derivation 
derivation oe gamma lexicographically ordered 
similar proof theorem cases 

existential dependent types 
hi 
hi applied rule derivation oe gamma form 
oe gamma 
oe fl oe gamma hi sigmaa fl ty sig intro induction hypothesis oe gamma 
derivable leads 
oe gamma 
oe fl oe gamma hi sigmaa fl ty sig intro 
hi 


ha xi 
rule derivation oe gamma form oe gamma sigmaa fl oe fl gamma oe gamma ha xi ty sig elim induction hypothesis oe gamma hi sigmaa fl derivable 
implies oe fl oe gamma 
derivable 
oe fl gamma derivable free occurrences gamma proof oe gamma 

constructed 
induction hypothesis oe gamma derivable 
cases treated similarly 
extend definition index erasure function delta follows 
khi eik kek ha xi ke ke theorem theorem theorem corresponding versions ml pi sigma mention briefly follows 
theorem oe gamma derivable ml pi sigma gammak kek kk derivable ml proof simply follows structural induction derivation oe gamma cases 
oe gamma 
oe fl oe gamma hi sigmaa fl induction hypothesis gammak ke 
derivable 

sigmaa fl khi ik ke done 
oe gamma sigmaa fl oe fl gamma oe gamma ha xi induction hypothesis gammak ke sigmaa fl gamma ke derivable 
sigmaa fl gamma gammak leads 
gammak ke gammak ke gammak ke ke ty chapter 
existential dependent types note ha xi ke ke done 
cases treated similarly 
ml pi evaluation ml pi sigma simulated evaluation ml stated theorem 
theorem 
derivable ml pi sigma kek 
kvk derivable ml proof simply follows structural induction derivation 
cases follows 

hi 
hi ke 
kv derivable induction hypothesis 
khi ik ke khi ik kv done 

hi 


ha xi 
induction hypothesis ke 
khi ik ke 


kvk derivable 
note khi ik kv ke 

ke 
kv 
leads 
ke 
kv ke 
kv 
kvk ke ke 
ev ha xi ke ke done 
cases handled similarly 
lemma lemma needed proof theorem 
lemma value ml pi sigma oe delta sigmaa fl derivable form hi value proof follows structural induction derivation oe delta oe sigmaa fl oe delta sigmaa fl form sigmaa fl induction hypothesis claimed form 
oe delta 
oe fl oe delta hi vi sigmaa fl hi vi done 
note applied rule ty var 
value rules applied rule concludes proof 

elaboration theorem oe delta derivable ml pi 
kek 
derivable value ml exists value ml pi sigma 
derivable kvk proof theorem follows structural induction derivation 
derivation oe delta lexicographically ordered 
cases 
oe delta 
oe fl oe delta hi sigmaa fl khi ik ke 
derivable ml induction hypothesis 
derivable ml pi sigma kv yields 

hi 
hi ev sig intro note khi ik kv done 
oe delta sigmaa fl oe fl oe delta ha xi derivation kek 
form ke 
ke 

ke ke 
ev induction hypothesis 
derivable kv theorem oe delta sigmaa fl derivable 
lemma implies form hi follows oe delta 
oe fl derivable 
leads derivation oe delta 

contains free occurrences notice ke 

ke 

induction hypothesis 


derivable kvk done 

hi 


ha xi 
ev sig elim cases handled similarly 
consequence straightforward conclude ml pi sigma ml pi conservative extension ml elaboration order ml pi sigma suitable practical programming language able design satisfactory elaboration algorithm dml ml pi sigma dml basically external language dml section existential dependent types allowed 
turns challenging task 
typical conflict facing order elaboration setting 
assign type pin nat intlist intlist function rev reverses chapter 
existential dependent types integer list 
suppose rev occurs code integer list 
intuitively synthesize rev rev index subject satisfiability index constraints check type intlist 
suppose need synthesize obtaining type sigman nat intlist 
get stuck successfully checked intlist type error reported 
quite natural case elaborate rev ha xi ha rev type sigmaa nat intlist 
justifies intuition reversing list unknown length yields list unknown length crucial step unpack synthesize rev rev 
notice elaboration rev alter operational semantics rev changes structure expression significantly 
example suggest transform rev rev elaboration 
general define variant normal transform moggi sabry felleisen follows transforms expressions dml lam lam lam lam fix fix fix fix hi hi case ms case ms hx proposition shows preserves operational semantics transformed expression proposition jej jej expressions dml 
proof corollary follows structural induction strategy transform elaborating means synthesize types order synthesize type application transformed 
clearly strategy rules style elaboration exist 
instance assume type tempting require reversing list unknown length yield list unknown length 
helpful justify hl rev pair lists length enrich language include effects 
effects achieved hx rev 

elaboration pia fl ffi ffi ffi lam synthesizing type clearly impossible type synthesized follows 
oe gamma pia fl ffi ffi ffi oe gamma ffi ffi ffi oe gamma ffi ffi lam ffi oe gamma ffi lam ffi observed style programming occur occasionally practice 
prompted question transform performed elaboration begins 
clear answer question moment 
hand may require programmer perform transform manually burden 
hand transform performed automatically may lose ability elaborate programs possible 
importantly harder report informative error messages type checking 
issue settled practice desirable separate elaboration issue transforming programs 
address chapter practical issues involving program transform elaboration 
presentation possibly empty sequence index variables fl possibly empty sequence sorts 
fl sequence declarations fl fl fl fl fl sigma fl 
sigma fl sigma fl ei xi abbreviations defined follows 
empty ei xi ei ha eii xi ha xi proposition presents properties related abbreviations 
proposition 

xi je je expressions ml pi sigma 

suppose oe gamma sigma fl oe fl gamma derivable 
variables free occurrences oe gamma xi derivable 
proof simply follows corollary follows induction number index variables declared addition rev example suggests turn rules elab elab forms respectively 
words unpack bound expression synthesized type begins existential quantifiers 
oe gamma sigma fl oe fl gamma oe gamma sigma fl xi chapter 
existential dependent types oe gamma sigma fl oe fl gamma oe gamma xi rule elab case dealt similarly 
issue 
suppose need check expression type variable application synthesize type obtaining type stage need check expression type coerced type strategy elaboration ml pi simply check holds 
strategy highly unsatisfactory ml pi sigma practice 
motivated design effective approach coercion 
coercion types ml pi sigma coercion evaluation context expression type type jej je rules coercion ml pi sigma 
judgement form oe coerce means expression type coerced expression type example show type pia fl ffi ffi coerced type pia fl ffi sigmab fl ffi 
fl fl coerce ffi ffi fl fl coerce ffi ffi fl coerce ffi sigmab fl ffi ha fl coerce ffi ffi ffi sigmab fl ffi lam ffi ha fl coerce ffi sigmab fl ffi lam ffi ha delta coerce fl lam ffi ha ready prove correctness coercion rules stated theorem 
theorem oe gamma oe coerce derivable oe gamma derivable jej je proof follows structural induction derivation oe coerce cases 
oe coerce oe coerce oe coerce case hx induction hypothesis oe gamma oe gamma derivable 
leads derivation oe gamma hx delta oe gamma hx ty match oe gamma case hx ty case 
elaboration oe oe coerce ffi ffi coerce datatype oe oe coerce coerce unit oe coerce oe coerce oe coerce case hx coerce prod oe coerce oe coerce oe coerce lam coerce fun oe coerce 
oe fl oe coerce pia fl coerce pi oe fl coerce oe coerce pia fl fl coerce pi oe fl coerce oe coerce sigma fl ha xi coerce sig oe coerce 
oe fl oe coerce sigma fl hi ei coerce sig derivation rules coercion chapter 
existential dependent types 
oe gamma oe gamma oe gamma ty prod addition je je hx ij hx hx ij type shown jej hx hx ij 
oe coerce oe coerce oe coerce lam induction hypothesis oe gamma derivable 
leads 
oe gamma oe gamma oe gamma ty app induction hypothesis oe gamma derivable yields 
oe gamma oe gamma oe gamma lam ty lam oe gamma lam ty oe gamma derivable 
lam jej lam je jej lam jej proposition jej wraps case 
oe coerce 
oe fl oe coerce pia fl oe gamma pia fl 
oe gamma pia fl oe fl oe gamma 
ty induction hypothesis oe gamma derivable je je note jej je done 
oe fl coerce oe coerce pia fl fl induction hypothesis oe fl gamma derivable jej je free occurrences types variables declared gamma 
oe fl gamma oe fl gamma fl ty ja fl je jej 
done 

elaboration oe fl coerce oe coerce sigma fl ha xi induction hypothesis oe fl gamma derivable 
leads 
oe gamma sigma fl oe fl gamma oe gamma ha xi ty sig elim notice ha xi jej je jej jej done 
oe coerce 
oe fl oe coerce sigma fl hi ei induction hypothesis oe gamma 
derivable jej je leads 
oe gamma 
oe fl oe gamma hi sigmaa fl ty sig intro jhi ij je jej done 
rest cases treated similarly 
usual gap elaboration rules coercion implementation 
bridge gap presenting constraint generation rules coercion 
judgement form oe coerce phi means coercing context oe yields constraint phi existential variables declared 
theorem assume oe coerce phi derivable 
oe phi derivable existential substitution oe holds oe coerce derivable evaluation context proof proof proceeds structural induction derivation oe coerce phi 
cases 
oe coerce phi oe coerce phi oe coerce phi phi oe phi phi derivable implies oe phi oe phi derivable 
induction hypothesis evaluation contexts oe coerce oe coerce derivable 
yields 
oe coerce oe coerce oe coerce case hx chapter 
existential dependent types oe ffi oe ffi oe coerce ffi ffi constr datatype oe oe coerce 
constr unit oe coerce phi oe coerce phi oe coerce phi phi constr prod oe coerce phi oe coerce phi oe coerce phi phi constr fun oe fl coerce 
phi oe coerce pia fl fl phi constr pi oe fl coerce 
phi oe coerce pia fl fl phi constr pi oe fl coerce 
phi oe coerce sigma fl fl phi constr sig oe fl coerce 
phi oe coerce sigma fl fl phi constr sig constraint generation rules coercion 
elaboration oe fl coerce 
phi oe coerce pia fl fl phi oe fl phi derivable 
fl phi fl phi exists oe fl oe phi 

clearly oe oe 
induction hypothesis oe coerce derivable evaluation context note 


leads 
oe coerce 
oe fl oe coerce pia fl constr pi oe fl coerce 
phi oe coerce sigmaa fl fl phi oe pia fl phi derivable oe holds 
notice pia fl phi pia fl phi 
oe fl phi derivable 
induction hypothesis derivable oe fl coerce 
note 


leads 
oe fl coerce 
oe coerce sigmaa fl ha xi constr sig done 
cases handled similarly 
justified correctness constraint generation rules coercion 
indeterminacy rules address chapter 
elaboration static semantics list elaboration rules ml pi sigma 
meaning judgements oe gamma oe gamma basically judgements 
theorem justifies correctness rules 
theorem 

oe gamma derivable oe gamma derivable jej je 
oe gamma derivable oe gamma derivable jej je proof proof parallel theorem 
follow straightforwardly simultaneous structural induction derivations oe gamma oe gamma cases 
chapter 
existential dependent types oe gamma pia fl oe fl oe gamma 
elab pi elim oe fl gamma oe gamma pia fl fl elab pi intro oe fl gamma oe gamma fl pia fl fl elab pi intro oe gamma 
oe fl oe gamma sigmaa fl hi elab sig intro gamma oe gamma ctx oe gamma elab var oe gamma oe coerce oe gamma elab var pia fl pia fl ffi oe fl delta delta delta oe fl oe gamma ffi 
elab cons wo oe gamma ffi oe oe gamma ffi elab cons wo pia fl pia fl ffi oe gamma 
oe fl delta delta delta oe fl oe gamma ffi 
elab cons oe gamma ffi oe oe gamma ffi elab cons oe gamma hi hi elab unit oe gamma hi hi elab unit oe gamma oe gamma oe gamma elab prod oe gamma oe gamma oe gamma elab prod elaboration rules ml pi sigma 
elaboration oe gamma oe oe gamma gamma oe oe gamma elab match oe gamma oe gamma ms ms oe gamma ms ms elab matches oe gamma oe gamma ms ms oe gamma case ms case ms elab case oe gamma oe gamma lam lam elab lam oe oe coerce oe gamma lam lam elab lam anno oe gamma oe gamma oe gamma elab app oe gamma oe coerce oe gamma elab app oe gamma sigma fl oe fl gamma oe gamma sigma fl xi elab oe gamma sigma fl oe fl gamma oe gamma xi elab oe gamma oe gamma fix fix elab fix oe gamma oe coerce oe gamma fix fix elab fix oe gamma oe gamma elab anno oe gamma oe coerce oe gamma elab anno elaboration rules ml pi sigma ii chapter 
existential dependent types oe gamma oe gamma oe gamma induction hypothesis oe gamma oe gamma derivable 
leads 
oe gamma oe gamma oe gamma ty app note je je je je je done 
oe gamma oe coerce oe gamma induction hypothesis oe gamma derivable je je oe coerce holds oe gamma derivable theorem je je je je done 
oe gamma sigma fl oe fl gamma oe gamma sigma fl xi induction hypothesis oe gamma sigma fl oe fl gamma derivable 
oe fl gamma sigma fl derivable applying rule sig intro repeatedly 
proposition derivable 
oe gamma xi sigma fl note 
xi je je je je done 
oe gamma sigma fl oe fl gamma oe gamma xi induction hypothesis oe gamma sigma fl oe fl gamma derivable 
derivable proposition 
oe gamma xi note 
xi je je je je done 
oe gamma oe gamma fix fix induction hypothesis oe gamma derivable 
yields derivation 
oe gamma oe gamma fix ty fix fix ju fix juj uj 
concludes case 
cases handled similar 

elaboration elaboration constraint generation usual gap description elaboration rules ml pi sigma actual implementation 
order bridge gap list constraint generation rules 
correctness constraint generation rules ml pi sigma justified theorem corresponds theorem 
theorem 

suppose gamma phi derivable 
oe phi provable oe derivable exists oe gamma derivable 

suppose oe gamma phi derivable 
oe phi provable oe derivable exists oe gamma derivable 
proof proven simultaneously structural induction derivations gamma phi oe gamma phi 
proof parallel theorem 
cases 
oe gamma phi oe gamma lam phi induction hypothesis oe gamma derivable yields 
oe gamma oe gamma lam lam elab lam note done 
oe gamma phi oe oe delta coerce phi oe gamma phi phi note phi phi phi phi 
existential substitution oe holds oe phi phi derivable oe phi oe phi derivable 
induction hypothesis oe gamma derivable 
oe coerce derivable theorem 
leads 
oe gamma oe coerce oe gamma app note oe oe gamma gamma je je je done 
oe gamma sigma fl phi oe fl gamma 
phi oe gamma sigma fl phi fl phi assumption derivable 
oe phi phi chapter 
existential dependent types oe gamma phi oe fl oe gamma fl phi constr weak oe gamma pia fl phi oe gamma 
fl phi constr pi elim oe fl gamma 
phi oe gamma ctx oe gamma fl pia fl fl phi constr pi intro oe fl gamma phi oe gamma ctx oe gamma pia fl fl phi constr pi intro oe gamma 
fl phi oe gamma sigmaa fl fl phi constr sig intro gamma oe gamma ctx oe gamma 
constr var oe gamma 
oe oe gamma ctx oe delta coerce phi oe gamma phi constr var pi fl ffi oe gamma oe gamma ffi 
fl 
constr cons wo oe gamma ffi 
oe ffi oe gamma ffi ffi ffi constr cons wo pi fl ffi oe gamma 
fl phi oe gamma ffi 
fl phi constr cons oe gamma ffi phi oe ffi oe gamma ctx oe gamma ffi phi ffi ffi constr cons oe gamma ctx oe gamma hi 
constr unit oe gamma ctx oe gamma hi 
constr unit oe gamma phi oe gamma phi oe gamma phi phi constr prod oe gamma phi oe gamma phi oe gamma phi phi constr prod constraint generation rules ml pi sigma 
elaboration oe gamma oe oe gamma gamma phi oe oe gamma ctx oe gamma oe phi constr match oe gamma phi oe gamma ms phi oe gamma ms phi phi constr matches oe gamma phi oe gamma ms phi oe gamma case ms phi phi constr case oe gamma phi oe gamma lam phi constr lam oe gamma phi oe gamma phi oe gamma lam phi phi constr lam anno oe gamma phi oe gamma phi oe gamma phi phi constr app oe gamma phi oe oe gamma ctx oe delta coerce phi oe gamma phi phi constr app oe gamma sigma fl phi oe fl gamma 
phi oe gamma sigma fl phi fl phi constr oe gamma sigma fl phi oe fl gamma 
phi oe gamma phi fl phi constr oe gamma phi oe gamma fix phi constr fix oe gamma phi oe gamma phi oe gamma fix phi phi constr fix oe gamma phi oe gamma phi constr anno oe gamma 
oe oe delta coerce phi oe gamma phi constr anno constraint generation rules ml pi sigma ii chapter 
existential dependent types implies oe phi oe fl phi derivable 
induction hypothesis derivable je je fl fl fl fl fl fl oe gamma sigma fl notice derivability oe fl phi implies oe fl phi 
induction hypothesis derivable je je oe fl gamma 
yields derivation 
oe gamma sigma fl oe fl gamma 
oe gamma sigma fl xi case wraps 
oe gamma phi oe gamma fix phi induction hypothesis oe gamma derivable juj ju leads 
oe gamma oe gamma fix fix elab fix note uj fix juj fix ju done 
cases treated similar manner 
program closed expression dml constraint generation rules derive judgement form delta delta phi phi 
assume process succeeds 
theorem theorem know elaborated expression ml pi sigma jej je delta phi derived 
sense say type checking ml pi sigma reduced constraint satisfaction 
summary section ml pi extended existential dependent types leading language ml pi sigma 
extension indispensable practical programming 
instance existential dependent types examples appendix ml pi ml pi sigma enjoys type preservation property operational semantics simulated ml theorem theorem 
consequently ml pi sigma conservative extension ml ml pi sigma explicitly typed internal programming language practical elaboration external language dml ml pi sigma crucial ml pi sigma intended general purpose programming 
ml pi achieve presenting set elaboration 
summary rules set constraint generation rules 
correctness rules justified theorem theorem respectively 
significant issue involves variant normal transform performed programs ml pi sigma elaboration 
transform enables elaborate common form expressions elaborated prevents elaborating common form expressions 
serious disadvantage performing transform complicate reporting comprehensible error messages elaboration programmer may understand programs transformed 
alternative allow programmer control transform help sugared syntax 
settled practice 
point transform performed current prototype implementation 
chapter justification practicality approach extending programming languages dependent types 
theoretic core thesis consists chapter chapter 
ready study issues extending ml pi sigma effects exception mechanism aiming adding dependent types entire core ml 
chapter 
existential dependent types chapter polymorphism polymorphism ability expressions types 
expressions universally quantified types assume different types universally quantified type variables instantiated differently 
polymorphism provides approach promoting certain form code reuse important issue software engineering 
chapter extend language ml ml ml style polymorphism prove relevant results 
extend language ml pi sigma ml pi sigma combining dependent types polymorphism 
relation ml pi sigma ml established parallel ml pi sigma ml development dependent types largely orthogonal polymorphism noticeably involved combine features 
practical issues showing elaboration concerned addressed carefully 
extending ml ml section extend ml ml style polymorphism yielding polymorphic programming language ml syntax ml enriches ml 
type variables ff type constructors ffi types delta delta delta ff ffi type schemes oe ff oe patterns delta delta delta ff ff expressions delta delta delta ff value forms delta delta delta values delta delta delta ff type var contexts delta delta delta ff signature delta delta delta ffi delta delta delta ff ff ffi substitutions delta delta delta ff 
possibly empty sequence types addition ffi abbreviations ffi respectively 
may write ff oe ff ff oe ff ff ff chapter 
polymorphism ff delta delta ff type var delta fi type base ffi delta delta delta delta delta delta delta delta delta ffi type datatype delta type unit delta delta delta type prod delta delta delta type fun delta ff oe delta ff oe type poly type formation rules ml types ml basically defined ml may contain type variables setting 
type scheme oe form ff delta delta delta ff oe 
notice treatment patterns non standard 
ml type variables occur patterns 
take approach naturally follows adopted handling universal dependent types section 
difference largely cosmetic 
static semantics rules forming legal types ml 
clearly delta oe derivable free type variables oe declared delta 
typing rules pattern matching 
list type inference rules ml 
course require free occurrences ff gamma dom gamma rule ty poly intro introduced 
rules closely resemble ml type variable context delta judgement keep track free type variables 
polymorphism enforced ty rule eliminate ordinary variable context variables types contain quantifiers 
substitution define ff 
ff notice ff length 
undefined 
definition obviates need introducing expressions form non variable expressions occur ml polymorphism allowed 
lemma delta derivable delta ff gamma oe derivable ml delta gamma ff 
ff 
oe ff 
derivable ff ff ff proof simply follows structural induction derivation delta ff gamma oe 

extending ml ml pat var hi delta pat unit gamma gamma hp gamma gamma pat prod ff ff ff ff ffi ff ff ffi delta pat cons wo ff ff 
ff ff ffi ff ff 
gamma ff ff ffi gamma pat cons typing rules pattern matching ml lemma delta gamma oe delta gamma oe oe derivable delta gamma 
oe derivable 
proof simply follows structural induction derivation delta gamma oe oe 
dynamic semantics evaluation rules formulating natural semantics ml ml plus rule ev poly needed evaluation 
ff 
ff ev poly note need rule evaluating expression occur ml usual type preservation theorem holds ml theorem type preservation ml 
delta gamma oe derivable delta gamma oe derivable 
proof proof proceeds structural induction derivation 
parallel theorem 
cases 




derivation 
delta gamma oe delta gamma oe delta gamma ty chapter 
polymorphism delta delta delta delta delta gamma ff delta delta delta ff delta gamma ff ff 
ty poly var ff delta delta delta ff ff ff ffi delta delta delta delta delta delta gamma ffi ty poly cons wo ff delta delta delta ff ffi delta delta delta delta delta delta gamma ff ff 
delta gamma ffi ty poly cons delta gamma hi ty unit delta gamma delta gamma delta gamma ty prod delta gamma delta gamma gamma delta gamma ty match delta gamma delta gamma ms delta gamma ms ty matches delta gamma delta gamma ms delta gamma case ms ty case delta gamma delta gamma lam ty lam delta gamma delta gamma delta gamma ty app delta gamma oe delta gamma oe delta gamma ty delta gamma delta gamma fix ty fix delta ff gamma oe delta gamma ff ff oe ty poly intro typing rules ml 
extending ml pi sigma ml pi sigma induction hypothesis delta gamma oe derivable 
delta gamma 
derivable lemma 
leads derivation delta gamma oe induction hypothesis 

ff 
ff derivation 
delta ff gamma oe delta gamma ff ff oe ty poly intro induction hypothesis delta delta ff gamma oe derivable 
readily leads derivation delta gamma ff ff oe ml types play role program evaluation 
extending definition type erasure function delta follows capture indifference types evaluation ml theorem 
jx jc ff jc ff jej jff ej jej theorem expression ml 


derivable ml jej 
jvj derivable pat val 
delta gamma oe derivable ml jej 
derivable pat val 
derivable ml jvj proof follow structural induction derivations 
jej 
respectively 
finished setting machinery combining dependent types ml style polymorphism 
extending ml pi sigma ml pi sigma language ml pi sigma extended language ml pi sigma follows 
possibly empty sequence type indices 
addition ff abbreviation 
type variables ff types delta delta delta ff type schemes oe ff oe patterns delta delta delta ff ff expressions delta delta delta ff value forms delta delta delta values delta delta delta ff signature delta delta delta ffi delta delta delta fl ff fl ff ffi substitutions delta delta delta ff 
chapter 
polymorphism ff delta oe oe delta ff type var oe oe delta type unit ffi delta delta delta fl oe delta delta delta delta oe delta oe fl oe delta ffi type datatype oe delta oe delta oe delta type prod oe delta oe delta oe delta type fun oe fl delta oe delta pia fl type pi oe fl delta oe delta sigmaa fl type sig delta delta ff oe delta delta ff oe type poly type formation rules ml pi sigma types ml pi sigma basically types defined ml pi sigma may contain type variables setting 
type scheme oe form ff delta delta delta ff oe 
notice disallows quantifiers occur scope pi sigma quantifier 
instance illegal type 
pin nat ff ff list 
ff list restriction necessary phase type checking algorithm introduce shortly 
static semantics rules forming legal types 
need additional rules handling type congruence relation 
oe ff ff oe delta delta delta oe oe oe ffi ffi typing rules pattern matching 
notice rule pat cons type constructor associated datatype constructor ffi form ff ff pia fl pia fl 
ff ff ffi instance allowed sml declare datatype follows 
datatype bottom bottom declaration assigns bottom type ff ff bottom clearly required form ff 
ff bottom 
proposition parallel proposition ml pi 
proposition 

extending ml pi sigma ml pi sigma delta pat var hi delta delta pat unit oe gamma oe gamma hp oe oe gamma gamma pat prod ff ff pia fl pia fl ff ff ffi ff ff ffi fl fl delta pat cons wo ff ff pia fl pia fl 
ff ff ffi ff ff 
oe gamma ff ff ffi fl fl oe gamma pat cons typing rules patterns 
kk ke kek 

kuk value form ml value form ml pi sigma 

kvk value ml value ml pi sigma 

oe gamma derivable 
kpk kk gamma derivable 

match derivable ml pi sigma match kpk kvk derivable ml 
ml pi sigma oe gamma oe gamma derivable 
match kpk kvk derivable match derivable 
oe derivable proof please refer proof proposition 
list type inference rules ml pi sigma 
rules resemble ml pi sigma closely type variable context delta judgement keep track free type variables 
polymorphism enforced ty rule eliminate ordinary variable context variable type begins quantifier 
example example type derivation ml pi sigma 
derivation delta ff ff ff ty poly var delta ff delta ff ff ff ty lam delta delta delta ff ff ff ff ff ty poly intro chapter 
polymorphism oe delta gamma oe oe delta gamma ty eq oe delta delta delta delta oe delta gamma ff delta delta delta ff oe delta gamma ff ff 
ty poly var oe delta delta delta delta oe delta ff delta delta delta ff oe delta gamma delta delta delta ff ff 
ty poly cons oe delta gamma hi ty unit oe delta gamma oe delta gamma oe delta gamma ty prod oe gamma oe oe gamma gamma oe delta gamma ty match oe delta gamma oe delta gamma ms oe delta gamma ms ty matches oe delta gamma oe delta gamma ms oe delta gamma case ms ty case oe fl delta gamma oe delta gamma fl pia fl ty oe delta gamma pia fl oe fl oe delta gamma 
ty oe delta gamma 
oe fl oe delta gamma hi ei sigmaa fl ty sig intro oe delta gamma sigmaa fl oe fl gamma oe delta gamma ha xi ty sig elim oe delta gamma oe delta gamma lam ty lam oe delta gamma oe delta gamma oe delta gamma ty app oe delta gamma oe oe oe delta gamma oe oe oe delta gamma ty oe delta gamma oe delta gamma fix ty fix delta delta ff gamma oe delta delta gamma ff ff oe ty poly intro typing rules ml pi sigma 
extending ml pi sigma ml pi sigma delta delta ff ff ff int delta delta int delta delta ff ff ff int int int ty poly var delta delta ff ff ff int int ty app 
delta delta ff ff ff false bool delta delta bool delta delta ff ff ff bool bool bool ty poly var delta delta ff ff ff bool false bool ty app derivation 
delta delta ff ff ff hf int bool false int bool ty prod delta delta delta ff ff hf int bool false int bool ty lemma oe delta derivable oe delta ff gamma oe derivable oe delta gamma ff 
ff 
oe ff 
derivable ff ff ff proof simply follows structural induction derivation oe delta ff gamma oe 
lemma oe delta gamma oe oe oe delta gamma oe oe derivable oe oe delta gamma 
oe derivable 
proof proof follows structural induction derivation oe oe delta gamma oe oe 
case follows 
oe oe delta delta delta delta oe oe delta oe oe delta gamma ff ff 
oe delta gamma ff derivable form ff oe delta ff gamma derivable inverting rule ty poly intro 
require ff free occurrences types variables declared gamma 
implies oe oe delta ff gamma derivable 
notice ff ff 
lemma oe oe delta gamma ff 
ff 
derivable gamma gamma ff 
cases treated similarly 
dynamic semantics addition evaluation rules ml pi sigma need rule formulate natural semantics ml pi sigma 

ff 
ff ev poly chapter 
polymorphism theorem type preservation ml pi sigma 
oe delta gamma oe derivable oe delta gamma oe derivable 
proof proof parallel theorem structural induction derivation 
derivation oe delta gamma oe lexicographically ordered 
interesting cases follows 




derivation 
oe delta gamma oe oe oe delta gamma oe oe oe delta gamma ty induction hypothesis oe delta gamma oe derivable 
oe oe delta gamma 
lemma 
leads derivation oe oe delta gamma 
ff 
ff derivation 
delta delta ff gamma oe delta delta gamma ff ff oe ty poly intro induction hypothesis delta delta ff gamma oe derivable 
readily leads derivation delta delta gamma ff ff oe rest cases treated similarly 
clearly definition index erasure function delta extended follows 
ff ff oek ff koek kff ek ff kek kx kc kc kek immediate question corresponding versions theorem theorem theorem ml pi sigma 
unsurprisingly answer positive 
relation ml pi sigma ml similar ml pi sigma ml theorem corresponds theorem 
untyped expression pat val typable ml pi sigma typable ml reiterates objective assign programs accurate types programs typable 
theorem oe delta gamma oe derivable ml pi sigma delta gammak kek koek derivable ml proof proof follows structural induction derivation oe delta gamma oe 
extending ml pi sigma ml pi sigma theorem 
derivable ml pi sigma kek 
kv derivable ml proof follows structural induction derivation 
interesting cases 




induction hypothesis ke 
kv ke 

kvk derivable 
readily verified ke 
ke 
kv 
leads derivation 
ke 
kv ke 
kv 
kvk ke ke 
kvk ev 
kvk derivable 

ff 
ff induction hypothesis ke 
kv derivable ml kff ff ke kff ff kv kff 
kff derivable ml theorem oe gamma oe derivable ml pi sigma 
kek 
derivable ml exists ml pi sigma 
derivable kvk proof proof similar theorem omit 
elaboration slightly extend external language dml follows yielding external language dml ml pi sigma 
expressions delta delta delta ff theoretically technical obstacles prevent directly formulating elaboration rules constraint generation rules ml pi sigma done ml pi sigma 
practice serious disadvantages doing briefly explain follows 
chapter example demonstrating refine polymorphic datatype polymorphic dependent type 
datatype list nil cons list typeref list nat indexing datatype list nat nil list cons nat list 
list declaration cons type ff pin nat ff ff list 
ff list chapter 
polymorphism suppose refined type int assigning types int int respectively 
see elaborate expression cons cons nili 
intuitively instantiate type cons int int list 
int list check cons nili int list 
leads instantiation type second cons int int list 
int list check int 
results type error type int 
contrast exists problem elaborating cons cons nil expression type int list ml destroy precious compatibility property expect valid ml program written external language ml treated valid dml program 
fortunately reader readily verify elaboration cons cons nil succeeded started checking type sigmaa int int 
example shows highly questionable directly combine dependent type checking polymorphic type checking 
disadvantage 
main objective designing dependent type system enable programmer capture program errors compile time 
crucial adequately informative type error message issued type checking fails 
greatly complicated errors resulted dependent type checking polymorphic type checking especially difficult report errors polymorphic type checking 
practical issues prompt adopt phase elaboration ml pi sigma 
phase theorem states typed ml pi sigma index erasure kek typed ml program dml successfully elaborated ml pi sigma index erasure kek elaborated ml algorithm polymorphic type checking ml milner check kek typed ml crucial step guaranteeing full compatibility ml pi sigma ml sense program written external language ml accepted ml pi sigma ml parts program dependent types expect phase elaboration highly efficient abundant programmer supplied type annotations available 
practice leads accurate type error message report type checking essentially performed top fashion 
phase phase elaboration perform 
ffl declared function annotated annotate ml type inferred function phase 

extending ml pi sigma ml pi sigma ff ff pos ff pos ff pos ff pos ff neg ff pos ff pos ff ff ff ff neg ff neg ff neg ff neg ff pos ff neg ff neg ff delta delta delta ff ff ffi pos ff delta delta delta ff ff ffi neg inference rules datatype constructor status ffl expression inferred type scheme form ff replace free occurrence appropriate inferred phase elaboration 
notice ml types 
programmer instantiate ff dependent types written program 
instance array subscript function sub type ff ff array int ff need subscript function acts array natural numbers block code declare sub sigmai nat int assures type variable ff type sub instantiated dependent type sigmai nat int type natural numbers 
ffl datatype constructor ffi refined index objects sort fl replace occurrences ffi sigmaa fl ffi 
process performed recursively processing done readily elaborate program way described section 
concludes informal description phase elaboration ml pi sigma 
coercion coercion polymorphic datatypes needs special care 
informal view follows 
assume type coerced type ff occurs positively ff ffi ffi able coerce ffi ff occurs negatively ff ffi ffi able coerce ffi 
order handle general cases introduce notion status follows 
ffi datatype constructor declared ml constructors type ff ff 
ff ff ffi associated ffi status ffi function domain dom mg range fpos 
dual status neg pos say ffi status dom ff derived rules 
chapter 
polymorphism readily extended mutually recursively declared datatype constructors ml 
assume datatype constructor ffi status say ffi coerced ffi coerces pos coerces rest 
currently disallow coercions ffi ffi ffi assigned status 
clearly possible extend range status function containing neutral mixed roughly mean positive negative positive negative respectively 
see extension practical relevance 
summary polymorphism largely orthogonal development dependent types 
chapter ml extended ml polymorphism sets machinery need combining dependent types polymorphism 
language ml pi sigma introduced extends ml pi sigma polymorphism 
relation ml pi sigma ml parallel ml pi sigma ml serious problems show elaboration concerned 
prompts adopt phase elaboration process usual ml type checking phase dependent type checking second phase 
clean practical solution 
ml pi sigma pure call value functional programming language contains imperative features 
natural move extend ml pi sigma imperative features consists topic chapter 
chapter effects far developed type theory dependent types pure functional programming language ml pi sigma lacks imperative features ml 
chapter extend language ml pi sigma accommodate exceptions 
examine potential problems approaches solving 
organization chapter follows 
extend language ml exception mechanism formulate language ml exc proving type preservation theorem ml exc extend 
yields language ml exc ref prove type preservation theorem ml exc ref exhibit problems extend ml pi sigma exception mechanism 
leads adopting value restriction approach wright 
study relation ml exc ref ml pi sigma exc ref 
exception mechanism exception mechanism important feature ml allows programs perform nonlocal jumps flow control setting handler evaluation expression may invoked raising exception 
exceptions value carrying sense pass values exception handlers 
dynamic nature exception handlers required exception values single datatype exc extended programmer 
called extensible datatype 
assume exc distinguished built base type concern constructors datatype created 
static semantics language ml extended language ml exc follows 
answer value uncaught exception 
base types fi delta delta delta exc expressions delta delta delta raise handle ms answers ans delta delta delta raise addition typing rules ml need ones handling newly introduced language constructs 
chapter 
effects 
ev var hi 
hi ev unit 
raise 
raise ev cons 

ev cons 
raise 
raise ev prod 

raise 
raise ev prod 


hv ev prod 
raise case ms 
raise ev case 
match 
ans case delta delta delta 
ans ev case natural semantics ml exc gamma gamma ms exc gamma handle ms ty handle gamma exc gamma raise ty raise dynamic semantics evaluation rules ml exc natural semantics ml exc established 
notice successful evaluation expression result value uncaught exception 
theorem type preservation assume gamma derivable ml exc 
ans answer ans gamma ans derivable 
proof proof parallel proof theorem structural induction derivation 
cases 

raise raise 
raise derivation gamma raise 
exception mechanism 
raise 
raise ev app 
lam 
raise 
raise ev app 
lam 


ans 
ans ev app 
raise 
raise ev 


ans 
ans ev fix 

fix ev fix 
raise raise 
raise ev raise 
raise 
raise ev raise 
raise handle ms 
raise ev handler 
raise match 
ans handle delta delta delta 
ans ev handler 
handle ms 
ev handler natural semantics ml exc ii chapter 
effects form 
gamma exc gamma raise ty raise induction hypothesis gamma raise exc derivable 
derivation gamma exc 
leads 
gamma exc gamma raise ty raise 
raise match 
ans handle delta delta delta 
ans derivation form 
gamma gamma delta delta delta exc gamma handle delta delta delta ty handle induction hypothesis gamma raise derivable 
leads derivation 
gamma exc gamma raise ty raise notice gamma exc derivable exc gamma derivable gamma gamma gamma derivable 
lemma gamma gamma derivable 
leads derivation gamma lemma 
induction hypothesis gamma ans derivable 

handle ms 
derivation form 
gamma gamma ms exc gamma handle ms ty handle induction hypothesis gamma ans derivable 
done 
cases treated similarly 
unique aspect ml types segregate mutable data structures immutable ones 
type type ref stands type cell store value type 
static semantics language ml exc extended language ml exc ref follows 
answer value uncaught exception associated piece memory 
types delta delta delta ref expressions delta delta delta letref memory delta programs prog letref answers ans letref letref raise dom defined follows 
dom delta dom dom fxg dom declared dom memory replaces declaration old old need typing rules handling newly introduced language constructs 
gamma ref ref gamma gamma gamma gamma ty memo gamma gamma gamma gamma gamma letref ty letref gamma ref gamma gamma ty assign gamma ref gamma ty deref note ref abbreviation letref 
example derivation gamma construct derivation gamma ref ref gamma ref gamma ref gamma ref ref gamma letref ref ty letref gamma ref ref ty dynamic semantics natural semantics ml exc ref 
proposition derivable dom dom 
letref 
letref chapter 
effects letref hi 
letref hi ev unit letref 
letref ev cons wo letref 
letref raise letref 
letref raise ev cons letref 
letref letref 
letref ev cons letref 
letref raise letref 
letref raise ev prod letref 
letref letref 
letref raise letref 
letref raise ev prod letref 
letref letref 
letref letref 
letref hv ev prod letref 
letref raise letref case ms 
letref raise ev case letref 
letref match letref 
ans letref case delta delta delta 
ans ev case letref lam 
letref lam ev lam letref 
letref raise letref 
letref raise ev app letref 
letref lam letref 
letref raise letref 
letref raise ev app letref 
letref lam letref 
letref letref 

ans letref 
ans ev app natural semantics ml exc ref 
letref 
letref raise letref 
letref raise ev letref 
letref 

ans letref 
ans ev letref fix 
letref 
fix ev fix letref 
letref raise letref raise 
letref raise ev raise letref 
letref letref raise 
letref raise ev raise letref 
letref raise letref handle ms 
letref raise ev handle letref 
letref raise match letref 
ans letref handle delta delta delta 
ans ev handle letref 
letref letref handle ms 
letref ev handle letref 
ans letref letref 
ans ev extrusion letref 
letref raise letref 
letref raise ev assign letref 
letref letref 
letref raise letref 
letref raise ev assign letref 
letref letref 
letref letref 
letref hi ev assign letref 
letref raise letref 
letref raise ev deref letref 
letref letref 
letref ev deref natural semantics ml exc ref ii chapter 
effects proof simply follows formulation evaluation rules 
note ev extrusion rule expand memory 
theorem type preservation program letref delta 
ans derivable ml exc ref delta ans derivable ml exc ref proof proof proceeds structural induction derivation 
ans 
cases 
letref 
ans letref letref 
ans derivation 
delta gamma gamma gamma gamma gamma gamma letref ty letref delta letref letref ty letref delta gamma gamma gamma derivable delta gamma gamma derivable 
leads 
delta gamma gamma gamma gamma delta letref ty letref induction hypothesis delta ans derivable 
letref 
letref letref 
letref letref 
letref hi derivation form 
delta gamma gamma ref gamma gamma ty assign delta letref ty letref leads 
delta gamma gamma ref delta letref ref ty letref induction hypothesis delta letref ref derivable 
implies delta gamma derivable gamma gamma ref proposition gamma gamma derivation 
delta gamma gamma delta letref ty letref induction hypothesis delta letref derivable 
implies derive delta gamma gamma gamma gamma delta gamma derivable yields 
delta gamma gamma hi delta letref hi ty letref 
value restriction letref 
letref letref 
letref derivation form 
delta gamma gamma ref gamma ty deref delta letref ty letref leads 
delta gamma gamma ref delta letref ref ty letref induction hypothesis delta letref ref derivable 
implies delta gamma derivable gamma gamma ref implies gamma derivable 

delta gamma gamma delta letref ty letref rest cases handled similar manner 
theorem generalizes theorem 
theorem letref 
letref memory values ml exc ref proof simply follows structural induction value restriction mention problems extend ml exc ref dependent types polymorphism 
take look evaluation rules 

fl 
fl ev lam 
lam ev lam 
ff 
ff ev poly clearly evaluation occur lam 
introduce serious problem extend language ml pi sigma effects exceptions 
instance cases arise immediately 

evaluation allowed rule adopted exception may raised evaluation 
raise fl 
raise ev raise may contain free occurrences rule applied 
chapter 
effects 
similarly adopt rule evaluation allowed letref fl 
ans letref fl letref 
ans ev extrusion may contain free occurrences rule applied 

evaluation allowed need rule exception may raised evaluation 
raise ff 
raise ev poly raise problem may contain free occurrences ff 

similarly rule needed 
letref ff 
ans letref ff letref 
ans ev poly extrusion problem may contain free occurrences ff 
cases bound variables unbound evaluation 
clearly addressed extend ml exc ref polymorphism dependent types 
radical solution problems sure evaluate words adopt rules 
fl 
fl ev ff 
ff ev poly clean solution 
unfortunately adoption rules immediately falsifies theorem theorem obvious reason ka fl ek kff ek value kek 
order overcome difficulty require value fl ff occurs expression 
achieved require kek value typing rules applied 
oe fl delta gamma oe delta gamma fl pia fl ty delta delta ff gamma oe delta delta gamma ff ff oe ty poly intro called value restriction 
words formulate rules follows 
oe fl delta gamma oe delta gamma fl pia fl ty delta delta ff gamma oe delta delta gamma ff ff oe ty poly intro assume value restriction imposed stated explicitly 

extending ml exc ref polymorphism dependent types extending ml exc ref polymorphism dependent types section extend ml exc ref polymorphism dependent types leading language ml pi sigma exc ref 
designed language features exception mechanism polymorphism universal existential dependent types 
core ml ml module level constructs basically ml exc ref polymorphism claim practical approach extending core ml dependent types 
regard key contribution thesis 
complete syntax ml pi sigma exc ref 
typing rules ml pi sigma exc ref plus 
natural semantics ml pi sigma exc ref terms evaluation rules listed plus 
lemma substitution 

oe fl oe fl delta gamma derivable oe delta gamma 


derivable 

delta oe delta ff gamma oe derivable oe delta gamma ff 
ff 
oe ff 
derivable 

oe delta gamma oe oe delta gamma oe oe derivable oe delta gamma 
oe derivable 
proof proof standard omitted 
please see proof lemma relevant details 
theorem type preservation ml pi sigma exc ref 
ans oe delta delta delta oe derivable ml pi sigma exc ref delta delta delta ans oe derivable ml pi sigma exc ref 
proof proof follows structural induction derivation 
ans derivation delta delta delta oe lexicographically ordered 
cases 
letref 
letref fl letref 
letref 
derivation form delta delta delta letref oe derivable oe 

delta delta gamma pia fl delta fl delta delta gamma 
ty delta delta delta gamma delta delta delta letref 
ty letref yields derivation 
delta delta gamma pia fl delta delta delta gamma delta delta delta letref pia fl ty letref chapter 
effects families ffi family refined datatypes signatures delta ffi delta delta delta fl ff ff pia fl pia fl ff ff ffi ff ff pia fl pia fl 
ff ff ffi major types ff ff ff ffi types pia fl sigmaa fl type schemes oe ff oe patterns ff ff ff ff hi hp matches ms ms expressions hi case ms lam fix raise handle ms letref fl hi ei ha xi ff value forms hi hu lam fl hi ui values hi hv lam fl hi vi ff memories delta programs prog letref answers ans letref letref raise contexts gamma delta gamma oe type var delta delta delta ff index contexts oe delta oe fl substitutions 

ff 
syntax ml pi sigma exc ref 
extending ml exc ref polymorphism dependent types oe delta gamma oe delta gamma ms exc oe delta gamma handle ms ty handle oe delta oe delta gamma exc oe delta gamma raise ty raise gamma ref ref oe delta gamma gamma oe delta gamma gamma ty memo oe delta gamma gamma oe delta gamma gamma oe delta gamma letref ty letref oe delta gamma ref oe delta gamma oe delta gamma ty assign oe delta gamma ref oe delta gamma ty deref additional typing rules ml pi sigma exc ref letref fl 
letref fl ev letref 
letref raise letref 
letref raise ev letref 
letref fl letref 
letref 
ev letref 
letref raise letref hi ei 
letref raise ev sig intro letref 
letref letref hi ei 
letref hi vi ev sig intro letref 
letref raise letref ha xi 
letref raise ev sig elim letref 
letref hi vi letref 


ans letref ha xi 
letref ans ev sig elim letref ff 
letref ff ev poly additional evaluation rules ml pi sigma exc ref chapter 
effects induction hypothesis delta delta delta letref fl pia fl derivable 
derivation form 
delta delta gamma fl pia fl delta delta delta gamma delta delta delta letref fl pia fl ty letref inversion assume fl delta gamma derivable 
lemma delta delta gamma 

derivable free occurrences gamma leads derivation delta delta delta letref 


delta delta gamma 

delta delta delta gamma delta delta delta letref 

ty letref letref 
letref hi vi letref 


ans letref ha xi 
letref ans derivation form 
delta delta gamma sigmaa fl fl delta gamma oe delta delta gamma ha xi oe ty sig elim delta delta delta gamma delta delta delta letref ha xi oe ty letref yields derivation 
delta delta gamma sigmaa fl delta delta delta gamma delta delta delta letref sigmaa fl ty letref induction hypothesis delta delta delta letref hi vi sigmaa fl derivable 
derivation form 
delta delta gamma 
oe fl delta delta gamma hi vi sigmaa fl ty sig intro delta delta delta gamma delta delta delta letref hi vi sigmaa fl ty letref note delta delta gamma 

oe derivable lemma 
leads 
delta delta gamma 

oe delta delta delta gamma delta delta delta letref 

oe ty letref induction hypothesis ans type oe 
cases dealt similar manner 
ml pi sigma exc ref straightforward form language ml exc ref extends ml exc ref polymorphism 
note value restriction imposed guarantee soundness type system ml exc ref leave details interested reader 

extending ml exc ref polymorphism dependent types extend definition index erasure function follows 
delta delta raise kek handle kek km vk kmk kvk letref kmk kek theorem suppose delta delta delta oe derivable ml pi sigma exc ref 

ans derivable ml pi sigma exc ref kek 
derivable ml exc ref proof follows structural induction derivation 
ans derivation delta delta delta oe lexicographically ordered 
cases 
letref fl 
letref fl notice 
fl letref kmk kvk proposition letref kmk kvk 
letref kmk kvk kvk obviously value 
letref ff 
letref ff notice 
ff letref kmk kvk proposition letref kmk kvk 
letref kmk kvk kvk obviously value 
cases treated done proof theorem 
suppose formulate reduction semantics ml pi sigma exc ref 
legitimate question ask expression form ff fl non value generated reduction program expressions 
answer negative ml pi sigma exc ref call value language 
surprisingly type preservation theorem ml pi sigma exc ref formulated proven reduction semantics 
usually theorem called subject reduction theorem 
leave details interested reader 
theorem suppose delta delta delta oe derivable ml pi sigma exc ref 
kek 
ans derivable ml exc ref 
ans derivable ml pi sigma exc ref ans ans chapter 
effects proof proof proceeds structural induction derivation kek 
ans derivation delta delta delta oe lexicographically ordered 
case 
delta delta delta delta delta delta ms exc delta delta delta handle ms kek handle ke derivation kek 
ans forms 
letref delta ke 
letref raise letref delta handle ke 
letref raise induction hypothesis letref delta 
letref raise derivable kmk kvk leads 
letref delta 
letref raise letref delta handle ms 
letref raise ev handle done 
letref delta ke 
letref raise match kp letref ke 
ans letref delta handle ke delta delta delta 
ans induction hypothesis letref delta 
letref raise derivable kmk kvk theorem delta delta delta oe derivable 
proposition match derivable ke ke 
induction hypothesis letref 
ans ans ans leads 
letref delta 
letref raise match letref 
ans letref delta handle delta delta delta 
ans ev handle concludes subcase 
letref delta ke 
letref letref delta handle ke 
letref induction hypothesis letref delta 
letref derivable kmk kvk leads 
letref delta 
letref letref delta handle ms 
letref ev handle done 

elaboration cases treated similarly 
extended entire core ml dependent types 
comprehensive features core ml really solid justification feasibility approach making dependent types available practical programming 
naturally move enrich module system ml dependent types regard primary research topic 
elaboration briefly explain elaboration ml pi sigma exc ref performed 
concentrate newly introduced language constructs elaboration rules done ml pi sigma simply overwhelming case 
ignore type variables polymorphism large orthogonal dependent types explained chapter 
elaboration rules exception mechanism listed 
omit formulation corresponding constraint generation rules 
routine formulate prove similar version theorem ml pi sigma exc ref justifies correctness elaboration rules 
leave details adequately previous chapters techniques needed fulfilling task 
summary chapter studied interactions dependent types effects exception mechanism 
polymorphism dependent types combined effects directly type system unsound 
clean solution problem adopt value restriction formulating expressions dependent function types 
development straightforward adoption 
problem exhibits inadequate aspect type system ml distinguish functions effects 
interesting see remedied research 
type system ml pi sigma exc ref includes polymorphism effects dependent types reached stage difficult manipulate mechanical assistance 
instance case proof theorem left dozens 
proofs thesis sort structural induction highly relevant investigate interactive theorem prover certain automation features accomplish task fulfilling cases omitted 
interested reader find related research schumann pfenning 
chapter 
effects oe oe gamma exc oe gamma raise raise elab raise oe gamma oe gamma ms exc ms oe gamma handle ms handle ms elab handle oe gamma oe gamma ms exc ms oe gamma handle ms handle ms elab handle oe gamma oe gamma ref ref ref elab ref oe gamma oe gamma ref ref ref elab ref oe gamma ref oe gamma elab deref oe gamma ref oe gamma elab deref oe gamma ref oe gamma oe gamma elab assign oe gamma ref oe gamma oe gamma elab assign elaboration rules exception mechanism chapter implementation finished prototype implementation dependent type inference standard ml new jersey version 
implementation corresponds closely theory developed previous chapters 
examples appendix verified implementation 
chapter account decisions implementation 
chapter meant complete instructions prototype implementation 
syntax expressions recognized implementation similar external language dml ml pi sigma exc ref including polymorphism exception mechanism universal existential dependent types 
record types regarded sugared version product types available moment 
features examples appendix grammar sugared version dml closely resembles standard ml sense dml program sml syntax related type index objects erased 
briefly go syntax related dependent types 
note explanation informal way syntax dml change implementations 
lastly move mention issues implementing elaboration algorithm chapter 
refinement built types refined built types int bool array ml follows 
ffl int refined infinitely singleton types int integer values 
words value type int equal consequence int shorthand sigman int int 
ffl bool refined singleton types bool 
true false assigned types bool 
bool 
respectively 
consequence bool shorthand sigmab bool 
ffl refined infinitely dependent types array stands size array 
chapter 
implementation pim int pin int int int int gamma pim int pin int int int int gamma theta pim int pin int int int int xi pim int pin int int int int div pim int pin int int int int mod pim int pin int int int bool pim int pin int int int bool pim int pin int int int bool pim int pin int int int bool pim int pin int int int bool array ff pin nat ff int 
ff array length ff pin nat ff array int dependent types built functions assigned dependent types built functions integers booleans arrays 
refinement datatypes development various dependent type systems previous chapters implicitly assumed declared polymorphic datatype constructor ffi delta delta delta ml refined dependent datatype constructor ffi delta delta delta fl index sort fl constructor associated ffi type ff delta delta delta ff ffi assigned dependent type form ff ff pia fl pia fl 
ff ff ffi fl delta delta delta fl fl 
example illustrate datatype refinement declaration formulated implementation 
datatype constructor tree follows datatype tree leaf branch tree tree datatype refinement declaration tree 
typeref tree nat leaf tree branch sl nat sr nat tree sl tree sr 
tree sl sr declaration states datatype constructor tree refined dependent datatype constructor tree nat 
associated constructors leaf branch 
type annotations assigned types respectively 
ff ff tree ff nat nat ff ff tree sl ff tree sr 
ff tree sl sr clearly meaning type index ff tree size tree 
index tree height declaration suffices 
typeref tree nat leaf tree branch hl nat hr nat tree sl tree sr 
tree max hl hr index tree size height declaration written follows 
typeref tree nat nat leaf tree branch sl nat sr nat hl nat hr nat tree sl hl tree sr hr 
tree sl sr max hl hr sophisticated datatype refinement declarations examples appendix note datatype refined current implementation sake simplicity 
type annotations constraint generation rules elaboration chapter require programmer supply adequate type annotations 
roughly speaking dependent types declared function determined programmer synthesized elaboration 
main reason ml exists notion principal types ml pi sigma 
type annotation function supplied clause function declaration 
suppose datatype refinement declared 
datatype list nil cons list typeref list nat nil list cons nat list 
list function declaration contains type annotation declared function reverse 
fun reverse nil nil reverse cons xs reverse xs cons nil reverse nat list 
list chapter 
implementation type annotation states reverse function type pin nat ff list 
ff list 
declaration roughly corresponds expression dml 
ff fix reverse pin nat ff list 
ff list lam case nil nil cons hx xsi reverse xs cons hx nili form type annotation shown example slight variant example 
fun nat reverse fun rev nil ys ys rev cons xs ys rev xs cons ys rev nat nat list list 
list rev nil reverse list 
list reverse defined tail recursive style 
notice nat follows fun declaration corresponds expression dml 
ff nat fix reverse ff list 
ff list rev fix rev pim nat pin nat ff list ff list 
ff list lam case hnil ysi ys hx xsi ysi rev hxs cons hx ysi rev hl nili kind type annotation essentially type annotation ml dependent type supplied 
instance type annotation code extracted example section captures relation front 
fun int aligned src srcpos endsrc dest destpos bytes val front case 



nat int 
program transformation list follows common syntax implementation corresponding part ml pi sigma exc ref helping reader understand examples 
implementation ml pi sigma exc ref fa fl fl fl fl fa fl fl pg fl fa fl 
fl fl fl fl fl fl fl fa fl 
program transformation significant issue variant normal transform performed programs elaborated 
advantage doing transform common form expressions able elaborated possible 
transform prevents elaborating common form expressions 
drawback largely remedied define follows 
value 
serious disadvantage performing transform significantly complicate programmer issue understanding error messages reported elaboration may understand programs transformed 
transform performed current prototype implementation 
little attention paid reporting error messages implementation issue addressed implementations 
study feasibility allowing programmer guide transform syntax 
indeterminacy elaboration constraint generation rules coercion contain certain amount indeterminacy 
disallow backtracking elaboration sake practicality imposed precedence application rules rule higher precedence chosen applicable 
coerce pi 
coerce sig 
coerce pi 
coerce sig chapter 
implementation oe derivable strategy guarantees oe delta coerce phi derivable phi oe phi derivable 
programmer language constructs guide coercion 
instance function type pia fl ffi ffi define lam assign type sigmaa fl ffi 
sigmaa fl ffi 
type checks 
notice succeeded precedence coerced directly 
similarly rule constr pi intro chosen constr pi intro applicable 
issue 
suppose synthesized type expression pia fl clearly rule constr pi elim applicable 
apply rule 
implementation apply rule occurs subexpression case ms pretty summarizes indeterminacy elaboration dealt prototype implementation 
summary finished prototype implementation features datatype declarations high order functions polymorphism exception mechanism universal existential dependent types 
missing main feature core ml records regarded variant product 
implementation sticks tightly theory developed previous chapters 
implementation elaboration described section cope indeterminacy constraint generation rules elaboration coercion 
important decision adopt disallow backtracking type checking 
main reason decision backtracking significantly slow type checking impossible report type error messages acceptable manner 
ready harvest fruit hard labor mentioning interesting applications dependent types chapter 
chapter applications chapter concrete examples demonstrate various applications dependent types practical programming 
examples section section verified prototype implementation 
ones section research 
program error detection original motivation dependent types capture programming errors compile time 
report common errors captured dependent type system developed thesis 
notice errors slip type system ml 
significantly beneficial programmer able verify certain properties lengths lists programs 
instance implementation quicksort algorithm lists 
fun quicksort cmp quicksort cmp xs par cmp xs quicksort nat 
bool 
list 
list par cmp left right xs case xs 
quicksort cmp left quicksort cmp right ys 
cmp par cmp left right ys par cmp left right ys par nat nat nat 
bool 
list list list 
list line case replaced 
quicksort cmp left quicksort cmp right chapter 
applications datatype dict empty considered black black entry dict dict red entry dict dict typeref dict bool nat empty dict true black cl bool cr bool bh nat entry dict cl bh dict cr bh 
dict true bh red bh nat entry dict true bh dict true bh 
dict false bh red black tree data structure programmer forgot include result returned function par function type 
nat nat nat 
bool 
list list list 
list matter fact function par type replacement 
nat nat nat 
bool 
list list list 
list error caught compile time type checking performed 
realistic example 
red black tree balanced binary tree satisfies conditions 

leaves marked black nodes marked red black 

node tree number black nodes path connecting node leaf 
number called black height node 

sons red node black 
define polymorphic datatype dict essentially binary tree colored nodes 
refine datatype type index objects bh drawn sort bool nat bh color black height root binary tree 
node black true 
properties red black tree naturally captured datatype refinement 
enables programmer catch program errors lead violations properties implementing insertion deletion operation red black trees 
encountered errors caught way practice 
notice refinement different declared section suited implementation 

array bound check elimination array bound check elimination array bounds checking refers determining value expression bounds array index array 
bounds violations notorious errors common programming errors 
ffl pascal ada sml java programming languages require bounds violations captured 
ffl 
run time array bounds checking expensive 
instance observed written sml buhler suffers loss throughput due checksum operation largely composed run time array bound checks 
spin kernel written modula bershad savage pardyak sirer becker fiuczynski chambers eggers suffers significant performance losses run time array bounds checking 
traditional ad hoc approaches eliminating run time array bound checks flow analysis gupta wolfe 
significant advantage approaches fully automatic requiring programmer supplied annotations 
hand approaches general limited power 
instance eliminate array bound checks involved array index value monotonic execution 
rely program analysis having fundamental difficulty crossing module boundaries 
serious criticism approaches general provide programmer feedback array bound checks eliminated left flow analysis 
words approaches may enhances performance programs lead robust programs 
offer virtually software engineering benefits 
section show dependent types facilitate elimination run time array bound checks 
approach requires programmer supply type annotations code 
return powerful traditional approaches 
instance show completely eliminate array bound checks binary search function reach practical approach flow analysis 
addition approach provide programmer feedback certain array bound checks eliminated 
enhances performance programs robustness 
approach offers software engineering benefits 
approach orthogonal traditional ones straightforward adopt approach type checking stage flow analysis code generation stage combining benefits dependent types flow analysis 
standard basis refined types common functions integers addition subtraction multiplication division modulo operation 
please refer chapter details 
order eliminate array bound checks compile time assume array operations sub update assigned types 
sub nat nat array int 
update nat nat array int 
unit chapter 
applications fun size nat dotprod fun loop sum sum loop sum sub sub loop nat size int int size int 
int loop length dotprod int array size int array size 
int dot product function clearly sure array accesses sub update result array bound violations need inserting array bound checks compile code 
similarly assign nth type nth list nonnegative integer returns ith element list 
sub nat nat list int 
eliminate list tag checks implementation nth 
code implementation dot product function 
fn explicit universal quantifier dependent function type constructor 
conditions may attached describe certain forms subset types fn nat ng types sub update 
clauses code type checking purposes giving dependent type local tail recursive function loop function dotprod 
simple example approaches flow analysis index code increasing 
see example challenging approaches flow analysis 
code implementation binary search array 
listed sample constraints generated type checking code 
solved easily 
note program binary search array bound check hoisted loops algorithm gupta increasing decreasing terms definition 
hand method eliminate array bound check synthesizing induction hypothesis similar annotated type look 
unfortunately synthesizing induction hypotheses prohibitively expensive practice 
plan investigate extensions type checker infer certain classes generalizations relieving programmer need certain kinds obvious annotations 
experiments performed experiments small set programs 
note bcopy binary search quicksort written just annotated providing evidence 
array bound check elimination constraints type annotations program number sml nj total number total lines code size bcopy lines binary search lines bubble sort lines matrix mult lines queen lines quick sort lines hanoi towers lines list access lines table constraint generation solution time secs natural ml programming style amenable type refinements 
set experiments done dec alpha sml new jersey version 
second set experiments done sun sparc version 
sources programs xi 
table summarizes characteristics programs 
show number constraints generated type checking time taken generating solving sml new jersey 
indicate number total type annotations code number lines occupy code size 
note type annotations non dependent form ml depending programming style module interface code 
brief description programs 
bcopy optimized implementation byte copy function fox project 
function copy bytes data times byte byte style 
binary search usual binary search function integer array 
function look randomly generated numbers randomly generated array size bubble sort usual bubble sort function integer array 
function sort randomly generated array size matrix mult direct implementation matrix multiplication function dimensional integer arrays 
applied function randomly generated arrays size theta 
queen variant known queens problem requires positioning queens theta chessboard captured 
chessboard size theta experiment 
quick sort implementation quick sort algorithm arrays copied sml new jersey library 
sorted randomly generated integer array size hanoi towers variant original problem requires moving disks pole stacking larger disk smaller availability third pole 
disks experiments 
chapter 
applications program checks checks gain checks eliminated bcopy binary search bubble sort matrix mult queen quick sort hanoi towers list access table dec alpha sml nj working version time unit sec 
program checks checks gain checks eliminated bcopy binary search bubble sort matrix mult queen quick sort hanoi towers list access table sun sparc version time unit sec 
list access accessed sixteen elements randomly generated list total times 
standard safe versions sub update array access compiling programs code array bound checks 
versions perform run time array bound checks semantics standard ml 
unsafe versions sub update array access generating code containing array bound checks 
functions structure unsafe array sml new jersey internal value 
unsafe version nth function cast list access tag checking 
notice unsafe versions sub update nth implementation assigned corresponding types mentioned previously 
table table effects eliminating array bound checks list tag checks 
note difference number eliminated array bound checks table table reflects difference randomly generated arrays experiments 
diagrams 
height bar stands time spent experiment 
gray ones experiments array bound checks eliminated compile time dark ones 
clear gain significant cases rewarding writing type annotations 
addition type annotations helpful finding fixing certain program errors 
potential applications bcopy binary search bubble sort matrix mult queen quicksort hanoi towers list access light color run time bounds checking dark color run time bounds checking dec alpha sml nj working version maintaining software system provide user informative documentation 
feel factors yield strong justification approach 
potential applications section potential applications dependent types implemented 
outline approaches realizing applications 
refer reader xi details regarding subject dead code elimination 
dead code elimination function zip zips lists 
clause zip raise missing ml compiler issue warning message stating zip may result match exception raised 
instance happens arguments zip different lengths 
exception fun zip nil nil nil zip cons xs cons ys cons zip xs ys zip raise function meant zip lists equal length 
declare zip dependent type nat list list 
list chapter 
applications bcopy binary search bubble sort matrix mult queen quicksort hanoi towers list access light color run time bounds checking dark color run time bounds checking sun sparc version clause zip raise definition zip reached safely removed 
words declare function zip follows 
fun zip nil nil nil zip cons xs cons ys cons zip xs ys nat list list 
list leads compact possibly efficient code 
instance checked argument zip nil return result nil immediately redundant check second argument nil 
prove lemma provides key eliminating redundant matching clauses 
lemma pattern type ml pi sigma oe gamma derivable 
delta delta match derivable oe satisfiable 
words oe derivable closed value type match pattern proof oe satisfiable oe 
holds constraint domain readily verified counterexample oe 
dom oe 
oe derivable oe satisfiable definition 
closed value type matches pattern oe derivable 

potential applications call index variable context oe inconsistent oe satisfiable 
lemma simply implies closed value type match pattern checking yields inconsistent index variable context 
rule applied elaboration oe gamma oe oe gamma gamma phi oe oe gamma ctx oe gamma oe phi constr match verify oe oe derivable 
matching clause reached 
issue warning message point safely remove matching clause 
serious issue dealt apply strategy pattern matching ml 
operational semantics ml requires pattern matching done sequentially 
instance third clause zip declaration zip chosen evaluate zip match pattern nil nil cons xs cons ys 
matches pattern cons xs nil nil cons ys 
type ff list fi list clearly impossible 
example suggests transform overlapped matching clauses disjoint ones detecting redundant 
case amounts transforming declaration zip 
exception fun zip nil nil nil zip cons xs cons ys cons zip xs ys zip nil cons ys raise zip cons xs nil raise assign zip type ff fi pin nat ff list fi list 
ff fi list 
notice nil cons ys ff list fi list nat fi ys fi list nat nat derivable third clause redundant lemma 
similarly fourth clause unreachable 
approach straightforward lead code size explosion applied certain examples 
search better solution detecting unreachable matching clauses 
loop unrolling subsection potential application dependent types observation subsection 
declared function sumarray sums elements integer array 
fun nat sumarray arr chapter 
applications fun loop loop sub arr loop nat int int int 
int loop length arr sumarray int array 
int note loop sub arr variant case statement 
case true 
false 
loop sub arr declare function sumarray follows sumarray applied integer array size 
fun sumarray arr sumarray arr sumarray int array 
int reasonable expand declaration partial evaluation 
give informal explanation 
fun sumarray arr sub arr sub arr sub arr sub arr sub arr sub arr sub arr sub arr sumarray int array 
int arr type int array length arr type int length type ff pin nat ff array int 
expanding loop length arr length arr loop call value language type int 
expand loop case true false loop sub arr notice type bool type 
pim int pin int int int bool reasoning section matching clause true unreachable 
allows simplification case statement loop sub arr 
repeating process times reach expanded declaration sumarray 
lead efficient code sacrificing clarity 
size integer array arr large natural number may advantageous expand sumarray arr result unexpected instruction cache behavior slow code execution 
propose possible solution follows 
significant problem currently available programming languages exist approaches improving efficiency code entire code 
help partial evaluation situation somewhat ameliorated follows 
assume programmer decides write function replace sumarray sake efficiency 
involved example sumarray expect loop times specialize function partial evaluation 

potential applications fun nat arr fun loop loop sub arr loop nat int int 
int fun loop times loop loop times nat mod int int 
int val length arr loop loop times int array 
int loop unrolling sumarray fun loop times loop times sub arr sub arr sub arr sub arr sub arr sub arr sub arr loop times nat mod int int 
int roughly corresponds loop unrolling known technique compiler optimization 
shown loop unrolling done preserve operational semantics think straightforward matter 
reasonable gain performance expanding arr arr large known size 
interested reader referred draves realistic interesting examples may handled way 
combining dependent types partial evaluation hope find approach improving efficiency existing code moderate amount modification 
currently exciting highly speculative research direction 
dependently typed assembly language studies types compilation highly active 
instance morrisett tarditi morrisett cheng stone harper lee tolmach oliva morrisett walker crary glew demonstrated convincing evidence support typed intermediate assembly languages various purposes data chapter 
applications int dotprod int int int int sum sum sum return sum version dotprod function layout tag free garbage collection compiler error detection immediately indicates beneficial pass dependent types lower level languages compilation 
compiler optimizations involving code motion may benefit dependent types 
array bound check elimination dependent types section solid support argument 
started formulate dependently typed assembly language mainly inspired morrisett walker crary glew 
theory language developed 
example informally ideas research 
code implementation dot product function written way directly compared code implementation dot product function dtal dependently typed assembly language 
note starts line comment 
dtal label associated type 
instance label dotprod associated type 
nat int array int array int roughly speaking type means execution code reaches label dotprod registers point integer arrays size natural number stores integer equal dtal code type checked prototype implementation 
notice type system guarantees memory violation command load executed value natural number size array points 
code downloaded untrusted source type checked locally run time checks needed preventing possible memory violations 
opens exciting avenue eliminating array bound checks programming languages java run networks 
examples dtal code xi 
summary far applications dependent types 
uses dependent types program error detection array bound check elimination put practice 
relatively straightforward dependent types eliminating unreachable matching clauses issuing accurate warning messages pattern matching implemented 
speculated beneficial combine partial 
summary dotprod nat universally quantified int array int array int point integer arrays size respectively stored mov set mov set jmp loop start loop loop nat int universally quantified int array int array int int int cmp compare equal load load load load mul add add increase jmp loop repeat loop equal jmp finish done endif finish int stores result integer halt dtal version dotprod function chapter 
applications evaluation dependent types demonstrating informally loop unrolling may controlled programmer dependent types 
promising highly desirable spot concrete opportunities compiler optimization benefit dependent types 
chapter dependent type inference developed thesis demonstrated convincing signs viable system practical 
compared ml types dependent types accurately capture program invariants lead detecting program errors compile time 
dependent types array bound check elimination encouraging enhance robustness efficiency programs 
programming language dml weak points 
weak points result trade offs ensure practicality dependent type inference remedied experiment research 
chapter summarize current research status incorporating dependent types ml point directions pursue dml better programming language 
current status briefly mention current status dml terms language design language implementation 
language design far finished extending core ml notion dependent types combining dependent types language features datatype declarations higher order functions polymorphism exception mechanism 
extended language name dml dependent ml 
strictly speaking dml really language parameterized constraint domain denoted dml 
may omit writing constraint domain presentation mean omitted integer constraint domain section simply irrelevant 
proven soundness enriched type system constructed practical type checking algorithm 
furthermore correctness type checking algorithm established 
placed solid theoretical foundation 
dml conservative extension ml sense dml program uses dependent types simply valid ml program 
order dml fully compatible core ml designed phase type checking algorithm dml 
guarantees ml program written external language ml pass type checking dml chapter 
passes type checking ml 
programmer sparingly features related dependent types writing large programs 
language implementation finished prototype implementation type checker substantial part dml integer constraint domain section 
part roughly corresponds language ml pi sigma exc ref introduced section including features core ml higher order functions datatypes polymorphism exception mechanism 
records implemented 
straightforward include records implementation simply variant products 
examples chapter verified implementation 
constraint solver integer domain variant fourier motzkin variable elimination approach dantzig 
intuitive clean approach think promising sup inf simplex method report comprehensible accurate type error warning messages unsatisfiable constraints vital component type checking dml 
weak aspect approach promising handle large contraints simplex method issue needs investigated 
research language design section research directions improving dml 
modules finished adding dependent types core ml ml module level constructs move naturally study interaction module system ml dependent types 
intricate issues answered practice 
immediate question export dependent types signature 
notion principal types dml function assigned dependent types coerces 
instance declared function tail assigned types ff sigman nat ff list sigman nat ff list ff pin nat ff list 
ff list respectively 
fun tail cons xs second type coerced function type applied list function second type applied non empty list 
length list inferred static type checking assigned type need type check tail 
inferred empty compile time second type lead potentially efficient code explained section 
moment contemplate introducing notion top level conjunction types dml 
case assign tail conjunction types ff sigman nat ff list sigman nat ff list ff pin nat ff list 
ff list 
research language design programmer allowed choose type needed occurrence tail 
details filled experience gained issue 
combination different refinements currently require datatype refined 
cases datatype may need different refinements different purposes 
instance encountered case needed refine datatype ff list list pair index objects represent length list lists sum lengths lists list lists 
clear refinement done datatype ff list refined index stands length list 
declared datatype refined substituted ff list list 
datatype nil cons list typeref nat nat nil cons nat nat nat list 
resulted substituting il cons nil cons places program respectively 
details example merge sort section 
research topic study combine different refinements datatype 
constraint domains general constraint language section allows programmer declare constraint domain language dml parameterized 
theorem typechecking dml reduced constraint satisfaction unfortunately method available enable programmer supply constraint solver highly desirable provide programmer language constraint solver written 
programmer supplied constraint solver constraint domain combined elaboration type checking dml performed 
programming languages research direction apply language design approach thesis strongly typed programming languages haskell hudak peyton jones wadler java sun microsystems 
array bound check elimination java requires special care explain 
program java compiled java virtual machine language jvml code shipped networks 
jvml code downloaded local host trust source code evidence attached code order convince local host safe eliminate array bound checks code 
approach necula code carry proof certain properties code verified local host leading notion proof carrying code 
practice proof carried code may tend difficult construct large compared size code 
approach morrisett walker crary glew compiled code explicitly typed dependent types code properties chapter 
verified local host equipped type checker dependent types 
leads notion dependently typed assembly language 
denotational semantics interested constructing categorical model language ml pi sigma 
various denotational models notion locally closed cartesian categories constructed calculi fully dependent type systems underlies lf harper honsell plotkin 
ml pi sigma essentially different calculi separation type index objects language expressions 
expect model tailored ml pi sigma yield semantic explanation index erasure simply exist fully dependent type setting 
implementations prototype implementation exhibits aspects immediate improvement 
instance observed large percentage constraints solved immediately generation 
currently collect constraints generated elaboration constraint store call constraint solver 
practice leads inflating number constraints significantly stage constraints transformed standard form 
promising elaboration done efficiently constraint generation constraint solution 
observation overwhelming majority integer constraints generated elaboration trivial solved constraint solver highly efficient incomplete constraint solver simplex method real numbers 
filtering trivial constraints complete constraint solver mentioned pugh wonnacott solve rest constraints 
similar strategy adopted constraint logic programming community efficiently solving constraints 
certifying compiler safe programming language similar constructs part necula lee 
stage compiler largely relies synthesizing loop invariants code order verify certain properties memory integrity 
approach difficult cope large programs 
hand type system dml strong allowing programmer supply loop invariants type annotations 
gives dml significant advantage scalability issue concerned 
natural consider certifying compiler dml implemented 
appendix dml code examples knuth morris pratt string matching implementation knuth morris pratt string matching algorithm dependent types eliminate array bound checks 
structure kmp struct assert length nat array 
int sub sub requires bound checking size int int size array size int 
requires bound checking array int 
notice existential types type int int assert size nat int size 
array size requires bound checking size int int size array size int 
requires bound checking array int 
requires bound checking size int int size array size int 
unit appendix dml code examples generates prefix function table pattern pat fun pat val length pat val fun loop calculate prefix array sub pat 
pat loop loop loop loop nat int 
unit loop nat int array 
array fun str pat val strlen length str length pat val pat fun loop strlen sub str sub pat loop loop loop loop nat nat int int 
int loop nat nat int array int array 
int 
red black tree red black tree example shows insert operation maps balanced red black tree balanced 
increases size tree note inserted key may existed tree 
type annotations occupying lines 
structure struct type key int type answer key option type entry int datatype order equal greater datatype dict empty considered black black entry dict dict red entry dict dict refine datatype dict index type nat nat nat nat 
meaning numbers color black height red height size 
balanced tree node sons black height 
red height tree means exist consecutive red nodes 
typeref dict nat nat nat nat empty dict black cl nat cr nat bh nat sl nat sr nat entry dict cl bh sl dict cr bh sr 
dict bh sl sr red cl nat cr nat bh nat nat nat sl nat sr nat entry dict cl bh sl dict cr bh sr 
dict bh cl cr sl sr note root tree black tree balanced appendix dml code examples fun compare int int greater equal compare int int 
order fun lookup dict key fun lk empty lk red tree lk tree lk black tree lk tree lk dict 
answer lk key datum left right case compare key key equal 
key 
lk left greater 
lk right lk entry dict dict 
answer lk dict lookup dict 
key 
answer fun red lt red rt red red black lt black rt re color red lt red rt red red black lt black rt re color empty red re red rle rll rr black rle red rll red re rr black red re red rle rll rr black deep rotate black rle red rll red re rr empty red re rl rr red black re red rl rr black red re rl rr red black shallow rotate black re red rl rr red empty empty black 
red black tree red black black black red black tree black black red black tree cl nat cr nat bh nat nat sl nat sr nat entry dict cl bh sl dict cr bh sr 
nat dict bh sl sr fun red lt red red rt red black lt black rt re color red lt red red rt red black lt black rt re color red le ll red lr empty black le ll red lr red le ll red lr black black shallow rotate black le ll red lr red le ll red lre empty black lre red le ll red red le ll red lre black black deep rotate black lre red le ll red red empty empty black red black black black red black tree black black red black tree cl nat cr nat bh nat nat sl nat sr nat entry dict cl bh sl dict cr bh sr 
nat dict bh sl sr appendix dml code examples exception fun insert dict entry key datum val ins dict 
dict inserts entry ins red may violate color invariant root having red height ins black ins empty red black ins preserves black height fun ins empty red entry empty empty ins red entry key datum left right case compare key key equal 
raise 
red entry ins left right greater 
red entry left ins right ins black entry key datum left right case compare key key equal 
raise 
entry ins left right greater 
entry left ins right ins nat bh nat nat dict bh 
nc nat nat nc nc dict nc bh val dict ins dict case dict red red 
black re color red red 
black re color red black black 
dict red empty empty 
dict black 
dict handle 
dict insert nat bh nat nat dict bh entry 
nc nat nat ns nat 
quicksort arrays bh bh ns ns dict nc ns quicksort arrays example shows array bounds checking required implementation place quicksort algorithm arrays 
code copied sml nj lib modification 
type annotations occupying lines 
structure struct datatype order equal greater assert sub nat nat array int 
update nat nat array int 
unit length nat array 
int fun size nat arr start cmp fun item sub arr item nat size int 
fun swap val tmp item update arr item update arr tmp swap nat nat size size int int 
unit fun swap nat nat nat size size int int int 
unit called appendix dml code examples elements sorted fun start val limit start fun outer limit fun inner start outer val case cmp item item greater 
swap inner 
outer inner nat size int 
unit inner outer nat int 
unit outer start start nat nat start size int start int 
unit calculate median fun med val item val item val item case cmp cmp 

case cmp 

greater 

case cmp 

case med 
quicksort arrays nat nat nat size size size int int int 
nat size int generate pivot splitting elements fun div val val pm div val pn med pm pn val div val med val pm med pm pm pm val pn med pn pn pn med pm pn nat nat size int int 
nat size int fun quicksort arg bottom defined higher order function sml nj library fun bottom limit arg pa pb pb limit arg case cmp item pb item greater 
arg 
bottom limit pa pb 
swap arg bottom limit pa pb bottom nat ppa nat nat size ppa int int ppa int 
pa nat pb nat ppa pa pb appendix dml code examples int pa int pb top defined higher order function sml nj library fun top limit arg pc pd limit pc arg case cmp item pc item 
arg greater 
top limit pc pd 
swap arg top limit pc pd top nat ppc nat ppd nat ppc ppc ppd size int int ppc int ppd 
pc nat pd nat pc pc pd ppd int pc int pd fun split pa pb pc pd val pa pb bottom pc pa pb val pc pd top pb pc pd pb pc pa pb pc pd swap pb pc split pa pb pc pd split ppa nat nat ppc nat ppd nat ppa ppc ppc ppd size int ppa int int ppc int ppd 
pa nat pb nat pc nat pd nat ppa pa pb pc pc pd ppd int pa int pb int pc int pd val pm arg swap pm pa pc pa pb pc pd split pa pa pc pc pn val min pa pb pa val pb 
quicksort arrays val min pd pc pn pd val pb pn val pb pa val sort unit val pd pc val sort pn unit quicksort nat nat size int int 
unit sort arg arg quicksort arg sort nat nat size int int 
unit sort start start nat nat start size array size int start int 
order 
unit sorted checks list sorted fun size nat sorted cmp arr val len length arr fun val sub arr case cmp greater 
false 
len true nat size int 
bool len true sub arr sorted 
order 
array size 
bool structure appendix dml code examples mergesort lists structure mergesort struct datatype nil cons list typeref nat nat nil cons nat nat nat list 
assert bool 
bool rev nat list 
list hd nat list 
fun sort cmp ls fun merge ys ys merge xs xs merge xs ys cmp merge xs ys merge xs ys merge nat nat list list 
list fun ls cons nil cons cons ls cons merge ls nat nat 
list fun ls cons nil ls cons cons ls mod cons cons ls cons merge ls div nat nat int 
nat fun run rev run run xs cmp hd run run xs rev run xs nat nat 
byte copy function list list 
nat nat list list fun ls ls xs ls val run tail xs tail cons run ls nat nat nat list int 
list case ls 
ls nil sort nat 
bool 
list 
list fun sorted cmp fun rest cmp andalso rest true list 
bool sorted 
bool 
list 
bool mergesort byte copy function implementation byte copy function fox project 
optimized version byte copy function fox project 
array bound checks eliminated 
type annotations consists roughly code structure bcopy struct assert sub nat nat array int 
byte update nat nat array int byte 
unit appendix dml code examples assert sub nat nat array int 
byte update nat nat array int byte 
unit assert sub nat nat array int 
byte update nat nat array int byte 
unit assert 
byte int 
byte byte byte 
byte 
byte int 
byte fun nat nat endsrc nat unaligned src srcpos endsrc dest destpos fun loop endsrc update dest sub src loop loop nat nat endsrc int int 
unit loop srcpos destpos unaligned srcpos nat destpos nat endsrc destpos endsrc srcpos array int srcpos int endsrc array int destpos 
unit fun nat nat endsrc nat common src srcpos endsrc dest destpos case endsrc srcpos 
update dest destpos sub src srcpos 
update dest destpos sub src srcpos update dest destpos sub src srcpos 
update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos 
update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos 
byte copy function update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos 
update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos 
update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos update dest destpos sub src srcpos 
unaligned src srcpos endsrc dest destpos common appendix dml code examples srcpos nat destpos nat endsrc destpos endsrc srcpos array int srcpos int endsrc array int destpos 
unit fun nat nat endsrc nat sixteen src srcpos endsrc dest destpos fun loop endsrc update dest sub src update dest sub src update dest sub src update dest sub src loop loop nat nat endsrc mod endsrc int int 
unit loop srcpos destpos sixteen srcpos nat destpos nat endsrc endsrc srcpos mod destpos endsrc srcpos array int srcpos int endsrc array int destpos 
unit fun nat aligned src srcpos endsrc dest destpos bytes val front case 



nat int val rest bytes front val tail rest mod val middle rest tail 
byte copy function val srcpos front val destpos front val middle val middle unaligned src srcpos dest destpos sixteen src dest unaligned src endsrc dest aligned nat nat srcpos nat endsrc nat destpos nat bytes nat endsrc srcpos bytes endsrc destpos bytes bytes array int srcpos int endsrc array int destpos int int bytes 
unit fun nat nat endsrc nat src srcpos endsrc dest destpos assert byte 
byte byte 
byte fun loop carry endsrc update dest carry val sub src update dest carry val val val carry val sub src update dest carry loop loop nat nat endsrc endsrc mod endsrc int int byte 
unit appendix dml code examples loop srcpos destpos sub src srcpos srcpos nat destpos nat endsrc srcpos endsrc endsrc srcpos mod destpos endsrc srcpos array int srcpos int endsrc array int destpos 
unit fun nat nat endsrc nat src srcpos endsrc dest destpos assert byte 
byte byte 
byte fun loop carry endsrc update dest carry val sub src update dest carry val val val carry val sub src update dest carry loop loop nat nat endsrc endsrc mod endsrc int int byte 
unit loop srcpos destpos sub src srcpos srcpos nat destpos nat endsrc srcpos endsrc endsrc srcpos mod destpos endsrc srcpos array int srcpos int endsrc array int destpos 
unit assert endian int little int 
byte copy function fun src srcpos endsrc dest destpos endian little src srcpos endsrc dest destpos src srcpos endsrc dest destpos nat nat endsrc nat srcpos nat destpos nat endsrc srcpos endsrc endsrc srcpos mod destpos endsrc srcpos array int srcpos int endsrc array int destpos 
unit fun nat src srcpos endsrc dest destpos bytes val front case 



nat int val rest bytes front val tail rest mod val middle rest tail val srcpos front val destpos front val middle val middle unaligned src srcpos dest destpos src dest unaligned src endsrc dest nat nat srcpos nat endsrc nat destpos nat bytes nat endsrc srcpos bytes endsrc destpos bytes bytes array int srcpos int endsrc array int destpos int int bytes 
unit fun copy src srcpos bytes dest destpos bytes appendix dml code examples common src srcpos srcpos bytes dest destpos val srcpos mod val destpos mod val endsrc srcpos bytes aligned src srcpos endsrc dest destpos bytes mod src srcpos endsrc dest destpos bytes unaligned src srcpos endsrc dest destpos copy nat nat srcpos nat bytes int destpos nat srcpos bytes destpos bytes array int srcpos int bytes array int destpos 
unit structure bcopy bibliography andrews bishop pfenning xi june 
tps theorem proving system classical type theory 
journal automated reasoning 
augustsson 

cayenne language dependent types 
proceedings rd acm sigplan international conference functional programming pp 

augustsson coquand nordstrom 
short description logical framework 
proceedings workshop logical frameworks pp 

barendregt 

lambda calculi types 
abramsky gabbay maibaum eds handbook logic computer science volume ii pp 

oxford clarendon press 
bershad savage pardyak sirer becker fiuczynski chambers eggers 
extensibility safety performance spin operating system 
proceedings th acm symposium operating system principles sosp pp 

bird 

calculus functions program derivation 
turner ed topics functional programming 
buhler 
september 
fox project language structured approach networking software 
acm crossroads 
electronic publication available www acm org crossroads html 
burstall darlington january 
transformation system developing recursive programs 
journal acm 
church 

formulation simple type theory types 
journal symbolic logic 
church rosser 
properties conversion 
transactions american mathematical society 
cl ement despeyroux despeyroux kahn 
simple applicative language mini ml 
proceedings conference lisp functional programming pp 

constable 

implementing mathematics nuprl proof development system 
englewood cliffs new jersey prentice hall 
constable smith june 
partial objects constructive type theory 
proceedings symposium logic computer science ithaca new york pp 

bibliography coquand 

algorithm testing conversion type theory 
plotkin huet eds logical frameworks pp 

cambridge university press 
coquand 

pattern matching dependent types 
proceedings workshop types proofs programs pp 

coquand huet 
constructions higher order proof system mechanizing mathematics 
buchberger ed volume lecture notes computer science berlin pp 

springer verlag 
coquand huet may 
calculus constructions 
rapport de recherche inria rocquencourt france 
coquand huet february march 
calculus constructions 
information computation 
dantzig 
fourier motzkin elimination dual 
journal combinatorial theory 
de bruijn 

survey project automath 
seldin hindley eds curry essays combinatory logic lambda calculus formalism pp 

london academic press 
dijkstra 
august 
guarded commands formal derivation programs 
communications acm 
dijkstra 

discipline programming 
englewood cliffs new jersey prenticehall 
draves 

automatic program specialization interactive media 
ph 
dissertation carnegie mellon university 
available technical report 
cmu cs 
feferman 

constructive theories functions classes 
van dalen eds logic colloquium 
north holland 
floyd 

assigning meanings programs 
schwartz ed mathematical aspects computer science volume proceedings symposia applied mathematics providence rhode island pp 

american mathematical society 
freeman 
march 
refinement types ml 
ph 
dissertation carnegie mellon university 
available technical report cmu cs 
freeman pfenning 
refinement types ml 
acm sigplan conference programming language design implementation toronto ontario pp 

fruhwirth 

constraint simplification rules 
technical report ecrc european computer industry center ecrc gmbh munchen germany 
gupta 

optimizing array bound checks flow analysis 
acm letters programming languages systems 
harper lee pfenning january 
fox project advanced language technology extensible systems 
technical report cmu cs school computer science carnegie mellon university pittsburgh pa 
published fox memorandum cmu cs fox 
bibliography harper mitchell moggi 
higher order modules phase distinction 
conference record seventeenth annual acm symposium principles programming languages pp 

harper honsell plotkin january 
framework defining logics 
journal acm 
hayashi 

px 
huet ed logical functional programming 
addison 
hayashi 

singleton union intersection types program extraction 
meyer ed proceedings international conference theoretical aspects computer software pp 

hayashi nakano 
px computational logic 
mit press 
hoare 
october 
axiomatic basis computer programming 
communications acm 
honsell mason smith talcott may 
variable typed logic effects 
information computation 
hudak peyton jones wadler may 
report programming language haskell non strict purely functional programming language version 
sigplan notices 
hughes pareto sabry 
proving correctness reactive systems sized types 
conference record rd acm sigplan symposium principles programming languages pp 

jackson damon 
faster checking software specifications 
proceedings rd acm sigplan symposium principles programming languages 
jaffar maher may july 
constraint logic programming survey 
journal logic programming 
special th anniversary issue 
jay 
shape checking array programs 
technical report university technology sydney australia 
kahn 

natural semantics 
proceedings symposium theoretical aspects computer science pp 

springer verlag lncs 
sannella tarlecki 
deferred compilation automation runtime code generation 
report ecs lfcs university edinburgh 
wolfe june 
elimination redundant array subscript 
acm sigplan conference programming language design implementation 
acm press 
lou 

ecc extended calculus constructions 
parikh ed proceeding fourth annual symposium logic computer science pp 

ieee computer society press 
lou 

unifying theory dependent types schematic approach 
technical report lfcs university edinburgh 
bibliography martin lof 

intuitionistic type theory 
italy bibliopolis 
martin lof 

constructive mathematics computer programming 
hoare ed mathematical logic programming languages 
prentice hall 
mendler 
june 
recursive types type constraints second order lambda calculus 
proceedings symposium logic computer science pp 

computer society ieee 
michaylov 
august 
design implementation practical constraint logic programming systems 
ph 
thesis carnegie mellon university 
available technical report cmu cs 
milner 
december 
theory type polymorphism programming 
journal computer system sciences 
milner tofte 
commentary standard ml 
cambridge massachusetts mit press 
milner tofte harper 
definition standard ml 
cambridge massachusetts mit press 
milner tofte harper macqueen 
definition standard ml 
cambridge massachusetts mit press 
moggi 

computational lambda calculus monads 
proceedings fourth annual symposium logic computer science pp 

morrisett 

compiling types 
ph 
dissertation carnegie mellon university 
available technical report 
cmu cs 
morrisett walker crary glew january 
system typed assembly language 
proceedings acm symposium principles programming languages pp 

nakano 

constructive logic catch throw mechanism 
annals pure applied logic 
naur 

proof algorithms general snapshots 
bit 
necula 

proof carrying code 
conference record th annual acm symposium principles programming languages pp 

acm press 
necula lee june 
design implementation certifying compiler 
acm sigplan conference programming language design implementation pp 

acm press 
nordstrom 

alf proof editor 
proceedings workshop types proofs programs pp 

parent 

synthesizing proofs programs calculus inductive constructions 
proceedings international conference mathematics programs constructions pp 

springer verlag lncs 
paulin mohring 

inductive definitions system coq rules properties 
bezem de groote eds proceedings international conference typed bibliography lambda calculi applications volume lecture notes computer science pp 

pfenning 

elf language logic definition verified metaprogramming 
proceedings fourth annual symposium logic computer science pp 

pfenning 

undecidability partial polymorphic type reconstruction 
fundamenta informaticae 
pfenning paulin mohring 
inductively defined types calculus constructions 
proceedings fifth international conference mathematical foundations programming semantics volume lecture notes computer science pp 

pollack 

theory lego proof checker extended calculus constructions 
ph 
dissertation university edinburgh 
pugh wonnacott 
eliminating false data dependences omega test 
acm sigplan conference programming language design implementation pp 

acm press 
pugh wonnacott november 
experience constraint array dependence analysis 
technical report cs tr university maryland 
sabry felleisen 
reasoning programs continuation passing style 
lisp symbolic computation 
sannella tarlecki february 
formal development ml programs foundations methodology 
technical report ecs lfcs laboratory foundations computer science department computer science university edinburgh 
schumann pfenning 
automated theorem proving simple meta logic lf 
proceedings th international conference automated deduction cade pp 

springer verlag lncs 
shankar 
may 
steps mechanizing program transformations pvs 
science computer programming 
shostak 
october 
sup inf method proving presburger formulas 
journal acm 
sun microsystems 
java language specification 
available ftp ftp javasoft com docs ps zip 

implementation array bound checker 
th acm symposium principles programming languages pp 

tarditi morrisett cheng stone harper lee june 
optimizing compiler ml 
proceedings acm sigplan conference programming language design implementation pp 

tolmach oliva july 
ml ada strongly typed language interoperability source translation 
journal functional programming 
appear 
wright 

simple imperative polymorphism 
journal lisp symbolic computation 
bibliography xi 
november 
examples dml programming 
available www cs cmu edu dml examples 
xi 
february 
examples dtal 
available www cs cmu edu dtal examples 
xi 
january 
dead code elimination dependent types 
international workshop practical aspects declarative languages san antonio 
appear 
xi pfenning june 
eliminating array bound checking dependent types 
proceedings acm sigplan conference programming language design implementation montreal pp 

xi pfenning january 
dependent types practical programming 
proceedings acm sigplan symposium principles programming languages san antonio 
appear 
zenger 

indexed types 
theoretical computer science 
zenger 

typen 
ph 
thesis fakultat fur informatik universitat karlsruhe 
forthcoming 
index evaluation context extended evaluation context fi redex fi ml pi ml pi sigma dom dom delta index erasure function dml dml 

pat val 

memory operational equivalence ml ml exc ml exc ref ml pi sigma ml ml pi sigma exc ref delta type erasure function substitutions ffi gamma oe answers array bounds checking base types constr datatype constr fun constr pi constr pi constr prod constr sig constr sig constr unit coerce datatype coerce fun coerce pi coerce pi coerce prod coerce sig coerce sig coerce unit constr anno constr anno constr app constr app constr case constr cons constr cons constr cons wo constr cons wo constr fix constr fix constr lam constr lam anno constr constr constr match constr matches constr pi elim constr pi intro constr pi intro constr prod constr prod index constr unit constr unit constr var constr var constraint domain contexts ctx empty ctx var elab anno elab anno elab app elab app elab assign elab assign elab case elab cons elab cons elab cons wo elab cons wo elab deref elab deref elab fix elab fix elab handle elab handle elab lam elab lam anno elab elab elab match elab matches elab pat cons elab pat cons wo elab pat prod elab pat unit elab pat var elab pi elim elab pi intro elab pi intro elab prod elab prod elab raise elab ref elab ref elab sig intro elab unit elab unit elab var elab var elaboration ev app ev app ev app ev app ev assign ev assign ev assign ev case ev case ev case ev cons ev cons ev cons ev cons wo ev deref ev deref ev extrusion ev fix ev handle ev handle ev handle ev ev ev lam ev ev ev ev poly ev prod ev prod ev prod ev prod ev raise ev raise ev sig elim ev sig intro ev unit ev var evaluation contexts index exception expressions extended evaluation contexts extended values extensible datatype families empty ivar index constraints index context index contexts index erasure index objects index propositions index sorts index cons index index fun index prod index second index subset index unit index var index var subset match contexts match cons match cons wo match prod match unit match var matches memories memory natural semantics open code patterns programs redexes reduction semantics reductions sat conj sat exists sat forall sat impl satisfiability relation signatures sort base sort prod sort subset sort unit status subst empty subst subst subst ivar subst prop subst var substitution lemma substitutions ty app ty assign ty case ty cons ty cons wo ty deref ty eq ty fix ty ty ty lam ty ty letref ty match ty matches ty memo ty poly intro ty poly var ty prod ty sig elim ty sig intro ty unit ty var index type constructors type erasure type schemes type variable contexts type variables type datatype type fun type match type pi type prod type sig type unit types value forms value substitution values 
