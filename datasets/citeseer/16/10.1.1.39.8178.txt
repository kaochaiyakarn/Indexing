dynamic typing polymorphic languages mart abadi luca cardelli systems research center digital equipment benjamin pierce lfcs university edinburgh didier emy inria rocquencourt dynamic types deficiencies languages static type systems 
polymorphic types example build heterogeneous lists exploited simulate object oriented techniques safely languages lack emulating methods procedures 
dynamic types independent value polymorphic types objects available 
provide solution kind computational incompleteness inherent statically typed languages offering example storage persistent data inter process communication type dependent functions print eval function 
situations programming dynamic types presence arbitrarily advanced type features 
investigate interplay dynamic typing polymorphism 
study extends earlier see allowing polymorphism keeps basic language constructs dynamic typecase style 
interaction dynamic types gives rise problems binding type variables 
find problems clearly addressed languages explicit polymorphism 
encounter difficulties indicated 
particular unique way match type tagging dynamic value typecase pattern 
solution consists constraining syntax typecase patterns providing static guarantees unique solutions 
examples examined far suggest restriction impediment practice 
solution applies languages data types extends languages subtyping 
drawing experience explicit polymorphism consider languages implicit polymorphism ml style 
ideas interesting twists 
particular led introduce tuple variables stand tuples type variables 
addition studies considered languages dynamic types 
relevant leroy mauny define investigate extensions ml dynamic types 
compare designs section 
section brief review dynamic typing simply typed languages 
section considers general case adding dynamic typing language higher order polymorphism 
algorithmic formulation general framework obtained section restricting polymorphism second order placing conditions patters typecase expressions 
sections discuss data types subtyping respectively 
section deals language implicit polymorphism 
review integration static dynamic typing fairly straightforward monomorphic languages 
simplest approach introduces new base type dynamic dynamic expression constructing values type dynamic typecase expression inspecting 
typechecking rules expressions gamma gamma dynamic dynamic dyn gamma dynamic gamma gamma gamma typecase dyn phrases branch guards pattern just monomorphic type branch bodies 
notational simplicity considered typecase expressions exactly guarded branch clause typecase involving patterns seen syntactic sugar nested instances single pattern typecase 
intended implementation compilation dynamic pair consisting value type compile dynamic compile grab double quotes indicate result compile run time structure single quotes mark substructures built compile time 
keyword grab indicates metalevel shift compile time data structure routine inserted run time value 
dynamic particularly easy implement bootstrapped compiler run time compile time structures coincide 
typecase construct uses compiler routine compare tag dynamic branch guard compile typecase compile grab grab snd push fst compile compile languages subtyping common subtype test typecase construct give restrictive matching rule allowing tag subtype guard type requiring match exactly 
constructs analogous dynamic typecase provided number languages including simula clu cedar mesa amber modula oberon modula 
constructs surprising expressive power example fixpoint operators defined type simply typed lambda calculus extended dynamic 
important applications dynamics include persistence inter address space communication 
example primitives provide input output dynamic value stream extern writer unit intern reader dynamic dynamics give type eval primitive eval exp dynamic obtain expressive system allowing typecase guards contain pattern variables 
example function takes dynamic arguments attempts apply contents checking functional type contents second df dynamic da dynamic typecase df fu vg typecase da fg dynamic 
pattern variables introduced guard 
example arguments df dynamic int int int da dynamic int typecase guards match follows tag int int pattern result fu int intg tag int pattern int result fg result dynamic int 
similar example dynamic composition function accepts dynamic arguments attempts construct dynamic containing functional composition df dynamic dg dynamic typecase df fu vg typecase dg ftg dynamic 
explicit polymorphism formulation dynamic types may carried unchanged languages explicit polymorphism 
example function checks argument df contains polymorphic function elements type int 
creates new polymorphic function accepts type argument type instantiates appropriately applies squares result df dynamic typecase df fg int type abstraction operator written type application written square brackets 
types polymorphic functions 
example type polymorphic identity function higher order pattern variables order pattern variables give sufficient expressive power matching polymorphic types 
example generalize dynamic application example section accept polymorphic function instantiate appropriately applying df dynamic da dynamic typecase df fg 
typecase da fwg dynamic 
df da single expression fill domain apply df dynamic snd fst 
da dynamic 
df dynamic 
da dynamic int 
led introducing higher order pattern variables range pattern contexts patterns abstracted respect collection type variables 
suffice express polymorphic dynamic application df dynamic da dynamic typecase df ff gg typecase da fwg dynamic df da example df dynamic id da dynamic int typecase expressions match follows tag pattern result ff xg tag int pattern reduces result fw intg result application df da dynamic id int int 
syntax formalize dynamic types context higher order polymorphic calculus 

syntax 
type dynamic 
examples base types cartesian products labeled records types patterns omit formal treatment 
regard identical pair formulas differ names bound variables 
brevity omit kinding declarations form type empty pattern variable bindings 
technically convenient write pattern variables bound typecase expression syntactic part pattern putting front guard done examples 
typecase fvg read formally typecase fv 
tag closure critical design decision programming language type dynamic question type tags closed occurrences pattern variables may mention universally bound type variables surrounding context 
simplest scenario dynamic legal closed possibly polymorphic type 
similarly require guard typecase expression closed type 
closure restriction types passed arguments polymorphic functions run time code compiled expressions dynamic thetax 
type theta generated run time 
languages ml type information retained run time closure restriction essential see section 
consider general case tags may contain free type variables 
definiteness simple minded formulation higher order pattern variables may provide adequate expressive power sufficiently constrained lead viable language design 
problem guarantee unique matches patterns tags 
example pattern int matched type kind types kinds type operators type variables function types quantified types type operators application type operator dynamic dynamic type fv vn kn patterns variables abstraction application type abstraction type application dynamic tagging typecase tag matching syntax 
terms tag bool pattern variable forced bool 
pattern matched tag int find int 
reasonable way choose 
worse consider int pattern variable problems compel introduce restrictions form patterns 
may require pattern matches tag way run time fail 
leads unpredictable matching failures 
prefer stronger condition 
informally want allow patterns match tag way 
condition called definiteness 
example assume type variables operator variable bound current context consider patterns valid fvg run time appears expression bound matching usual firstorder pattern variables matching leaves completely undetermined set new type constant 
patterns form examples want consider definite may leave unconstrained 
invalid ffg example match tag ways instantiating valid ffg scope narrower match tag instantiating valid ffg occurrence determines value 
valid ff vg matched considered bound defining occurrence invalid ff gg considered bound bound 
note definiteness patterns checked locally 
example valid ffg int bool definite occurrence definite isolation 
definiteness condition formalized put definiteness requirement typechecking rule typecase programs definite patterns legal 
unfortunately notion definiteness suggest typechecking algorithm straightforward way 
related problem algorithm run time operation matching patterns tags 
known general case higher order matching decidable 
second third order cases decidability established lead algorithms inefficient practical implementing typecase 
second order polymorphism obtain practical language design need restriction general treatment efficient typechecking matching algorithms 
considering fragment 
second order polymorphism 
restriction matter convenience possible approach described applies full 
syntax system second order polymorphic lambda calculus dynamic restriction 
dynamic 
show lines differ 
type type operators quantified types type operators type abstraction kinds type specify functionality pattern variables abstractions applications level types describe patterns 
kind form type 
delta delta delta type simply say pattern variable kind arity pattern fv vn kn ordered total ordering pattern variables vn defining occurrence subterm occurrence delta delta delta 
appear argument pattern variable occurrence proper subphrase 
fully applied arity 
pairwise distinct 
narrower scope fv 
note condition checked statically 
ordered matching matching algorithm ordered patterns ordered pattern algorithm instantiates variables orders pattern ordered 
believe ordered patterns definite ordered matching correct terminates input yields solution independently order variable instantiations 
replace definiteness condition ordered condition typechecking evaluation adopt ordered matching 
omit detailed description ordered matching section contains similar algorithm somewhat different context 
types interaction dynamic data types gives rise puzzling design issue type tag dynamically typed value containing element type matched abstractly concretely 
arguments choices ffl matching protects identity hidden representation types prevents accidental matches cases types happen representation 
ffl transparent matching allows permissive style programming dynamically typed value type considered value different version type 
flexibility critical situations 
example program may create disk files containing dynamic values remain usable program recompiled programs different machines may want exchange data form dynamically typed values 
viewing types formally existential types see exactly difference solutions lies suggest generalization existential types supports 
existential types turn coded universal types coding design dynamic types previous sections yields second solution 
add existential types variant 
defined previous section extend syntax types terms 
typechecking rules pack open fi gamma gamma pack hiding pack gamma fv gamma gamma open open typical example element type packed dynamic existential types pack hiding packing existential open unpacking existential elimination extended syntax existential types pack push intlist int cons pop intlist cdr top intlist car new nil push int pop top int new hiding intlist open stack dynamic push new stack typecase stack top note sort example depends critically open type tags 
open tags implemented run time types 
evaluation pack construct value carries representation type 
choice evaluation rule open expression ffl evaluate expression open replacing representation type variable actual representation type obtained evaluating ffl alternatively replace new type constant 
dynamic difference rules detected 
dynamic get different behaviors 
behaviors desirable may choose introduce extended open form provides separate names transparent versions representation type gamma fv gamma gamma open open body build dynamic values tags typecase investigate representation type typecase violate type abstraction 
subtyping simple languages subtyping natural extend typecase perform subtyping test exact match 
consider example dx dynamic nat typecase dx fg int 
typecase branch taken tag dx nat different int 
unfortunately idea runs difficulties applied complex languages 
general exist general instantiation pattern variables subtype match performed 
example consider pattern problem subtype matching int nat 
int int nat nat instances supertypes int nat incomparable 
pattern covariant may general match 
pattern theta may type theta upper bound may best instantiation happen example system bounded quantifiers systems collection base types form upper semi lattice 
linear patterns pattern variable occurs avoid problems find linearity restrictive 
take different approach works general fits language described section 
intend extend system subtyping lines 
order incorporate higher order pattern variables resort 
kind structure section extended follows type power informally power type collection subtypes power collection operators kind pointwise subtype relation subtyping introduced interpreting ab power fg axiomatization power designed induce expected subtyping rules 
example power says aa 
section limit kinds appear patterns may allow bounded quantifiers xt handled easily 
power kinds write patterns typecase dx fv 
fv type power type 
branch guard typechecking corresponding branch body 
shape branch guards fv vn png may occur shape fits normal format typing environments introduces difficulties static typechecking 
consider dynamic semantics typecase presence subtyping 
idea preserve previous notion typecase performs exact type matches run time 
subtyping introduced sequence additional constraints checked run time matching 
constraints easily checked time evaluated pattern variables fully instantiated undetermined types discussed section 
example suppose tag dx nat theta int theta int instantiations nat theta int int 
matching completed successfully check theta 
examples illustrate additional flexibility obtained subtyping 
show emulate simple monomorphic languages subtyping pattern variables typecase performs subtype test 
example section reformulated typecase dx int 
example tag dx subtype int 
note assumption vint statically typecheck 
example similar section type argument subtype domain function typecase df fv wg typecase da fv vg dynamic 
polymorphic tag types polymorphic pattern types order pattern variables new happens matching subtype tests adequate ones polymorphism 
degree complexity introduced higher order pattern variables 
just subtype constraint order pattern variables may fg higherorder pattern variables 
mentioned inclusion intended pointwise fg iff assumption form dynamic application provides example higher order matches subtyping typecase df ff type type vg zv typecase da dynamic 
dynamic composition calls constraint form typecase df fg type typeg typecase dg ff type type type type dynamic ffig 
example generalizes functions bounded polymorphic types xa 
implicit polymorphism section investigate dynamics implicitly typed language ml 
show general treatment dynamics explicitly typed languages directly applies ml providing explicitly tagged dynamics untyped language 
solution spirit ml rest section devoted study implicitly tagged dynamics ml 
obvious extension ml types inferred constructs dynamics user needs provide type information creating reading dynamics 
instance consider program twice dynamic type scheme inferred bound 
check type scheme free variables general required tag 
conversely extraction value dynamic succeeds type scheme tag bound 
instances value different instances tag foo df typecase df succ 
succ successor function integers negation function booleans 
works perfectly 
requires explicit type information dynamic patterns spirit ml 
ml typechecker infer general types expressions expect compiler tag dynamic values principal types 
instance user writes twice dynamic dynamic tagged 
difficulty program apply dynamic dynamic tag 
typecase defined succeeds tag exactly matches pattern including quantifiers 
implicit tagging order quantifiers matter 
tag twice general pattern function foo ml programmer probably expect twice passed foo 
justified fact typechecker built dynamic weaker tag typecase succeeded 
ml typecase expected succeed instance tag matches pattern 
principle called tag instantiation 
dynamics tag instantiation pattern variables implemented language caml 
dynamics studied leroy mauny tag instantiation firstorder pattern variables 
order pattern variables powerful type reasonable examples function shown 
describe version dynamics ml tag instantiation second order pattern variables 
tuple variables tag instantiation second order pattern variables fit 
difficulty comes merging features ffl pattern ffg secondorder pattern variables may depend universal variables 
ffl tag instantiation requires typecase succeeds succeeds dynamic argument general tag 
tag thetaa matches previous pattern 
tag thetab supposed depend 
tag instantiation polymorphic pattern variables may depend variables ones explicitly mentioned 
capture variables appear tag correspond variables pattern tuple variables dependence pattern variable universal variables written exact set variables statically known 
tuple variable dynamically instantiated tuple variables tag matched variables pattern 
particular pattern contain instance pattern ffg written ffg tag instantiation possible 
tag thetaa matches pattern empty tuple 
tag thetab matches element tuple 
tuple variables bound different patterns may instantiated tuples different numbers variables example just 
size considerations possible tuple variable argument operator may expect argument different size 
tuple sorts order guarantee type expressions formed 
formally typecase explicit information written instance fp tuple type typeg type stands fully applied pattern variable notation reminds argument tuple 
sort variable bound run time 
necessary write sorts programs typechecker easily infer 
description language assume denumerable collection tuple sorts written sort ype 
sorts type atomic sorts sorts types dynamic types fa gt patterns kn type schemes traditional ml style left quantifiers implicit types patterns 
formation types patterns contexts controlled judgements form gamma type sort gamma gamma type schema sort gamma gamma pattern sort gamma contexts gamma empty context gamma tuple sort declaration gamma symbol declaration formation rules ensure type variables bound proper context sort consistent uses 
instance rule gamma gamma gamma sort app examples help reader different letters variables different sorts type variables tuple sorts written type variables sort type written pattern variables 
patterns pairs set pattern variables fv vn type formed signature form tuple sort exact rule pattern formation gamma gamma vn kn type type ype gamma fv vn kn type type particular exactly pattern variable tuple sort pattern 
guarantee definiteness patterns impose sufficient condition patterns ordered 
ordered patterns satisfy conditions section addition non pattern free variables sort ype appear outside pattern variables pattern 
context ml definiteness requirement reminiscent type explication restriction imposed signatures standard ml see section 
pattern variables bound typecase scope typecase introduced 
free variables bound pattern scope pattern 
expressions dynamic typecase fv vn kn type inference pattern variables behave local type symbols ml 
typechecking local type symbols implies extension judgement contexts order control scope type symbols gamma gamma variable type assignment typing judgements gamma instance rule ml gamma gamma ype instance gamma inst says instances formed current context prevents local symbols scope 
want carry types run time require types values dynamic closed tags statically compiled 
gamma closed gamma dynamic dynamic dyn rule may destroy principal typing property ml 
principal type expression closed typing dynamic requires free variables instantiated ground types 
set closed instances principal type closed principal element 
want avoid situations nonexistence principal type corresponds ambiguity concerning tag dynamic value carry 
say program typed principal typing derivation 
type inference realized algorithm ml delaying tag closure checking typechecking gathering free variables types dynamic values list instance 
variables free typechecking exists principal derivation program typed 
rule typecase gamma dynamic gamma gamma fv vn kn gt gamma vn kn gamma typecase fv vng rules ml unchanged 
evaluation compilation easily decomposed phases 
phase translates ml variant called ml dynamics explicitly typed translation requires bit inference 
ml differs form ml dynamic construct dynamic typing rule gamma closed gamma dynamic dynamic dyn translation ml program ml ml program principal type derivation principal type derivation defines uniquely types equal alpha conversion 
type reconstruction algorithm trivial adaptation usual type inference algorithm 
semantics ml program semantics translation ml evaluation rules standard 
interesting typecase involves new methods matching pattern variable instantiation 
matching quite usual allows tag instantiation deal tuple variables 
inputs pattern fv vn kn tag closed type ff ff pattern variables universal variables remaining free variables set variables occur tag ff increase tag instantiation 
algorithm returns substitution domain pattern variables exists substitution domain tag variables 
describe algorithm transformations sets unification constraints called transformations keep unchanged set substitutions satisfy constraints 
substitutions consider instantiate pattern tag variables universal variables 
metavariable stands type stands type contain pattern variables 
atomic constraints pairs pairs considered equal 
substitution solution atomic constraint unifies sides 
addition constant represent failure atomic constraint solution 
general atomic constraint conjunction existential ff solution set intersection solution sets solution set existential ff set solutions restricted variables distinct ff 
identify commutativity associativity conjunction renaming variables bound exchange consecutive removal vacuous 
equivalent set solutions 
obviously defines equivalence relation fact congruence 
reduce original matching problem finding solutions fv 
order solve problem give list equivalences top equivalent bottom 
tag variables written ff constant symbols occur fully applied universal variable pattern variable set variables ffl decomposition ffl instantiation ff ff ff ff ff ff ff ff ff ffl propagation ff ff fv ffl universal variable restriction ff ff ffl existential simplifications ff ff ff fv ff ff ff ff fv fv ffl trivial constraints ff ff equivalences rewriting rules 
rules oriented top bottom step rewriting application exactly rule applying rules order terminates 
successful process produces canonical form ff ff reduced canonical form contains constraint tn ordered condition patterns prevents second instantiation rule apply constraints 
ordered patterns rewriting produces canonical 
form rules matching unitary solutions equal renaming ff 
unique tuple variable appears bound tuple ff size bound tuple sort 
related dynamics closely related leroy mauny 
system seen extension system mixed quantification 
introducing typecase statement leroy mauny merge dynamic elimination usual case statement ml 
ignore difference dynamic patterns form qa type list existentially universally quantified variables 
instance pattern system 
existentially quantified variables play role pattern variables 
order quantifiers determines dependencies quantified variables 
pattern rephrased writing quantifiers patterns explicitly ease comparison equivalent pattern system ff gg approach fact translate patterns equivalent patterns system preserving intended semantics 
hand translation language theirs 
pattern equivalent pattern ff gg quantifiers prefix patterns linear order possible parallel dependencies obtain system intermediate theirs leaving tuple variables implicit rewrite pattern ff gg believe explicit tuple variables useful allow examples function df dxy typecase df ff typecase dxy fg hg theta 
expressed intermediate system systems just type quantifiers leroy mauny 
mart abadi luca cardelli benjamin pierce gordon plotkin 
dynamic typing statically typed language 
acm transactions programming languages systems april 
graham birtwistle ole johan dahl bjorn nygaard 
simula 
lund sweden bratt institute fuer frg bratt kent england 
luca cardelli 
amber 
guy cousineau curien bernard robinet editors combinators functional programming languages 
springer verlag 
lecture notes computer science 
luca cardelli 
structural subtyping notion power type 
proceedings th acm symposium principles programming languages pages san diego ca january 
luca cardelli simone martini john mitchell andre scedrov 
extension system subtyping 
ito meyer editors theoretical aspects computer software number lecture notes computer science pages 
springer verlag september 
luca cardelli peter wegner 
understanding types data abstraction polymorphism 
computing surveys december 
gilles dowek 
second order pattern matching algorithm cube typed calculi 
proceedings mathematical foundation computer science volume lecture notes computer science pages 
springer verlag 
rapport de recherche inria 
gilles dowek 
third order matching decidable 
proceedings seventh annual ieee symposium logic computer science 
appear 
greg nelson ed 
systems programming modula 
prentice hall 
giorgio ghelli 
proof theoretic studies minimal type system integrating inclusion parametric polymorphism 
phd thesis universit di pisa march 
technical report td dipartimento di informatica universit di pisa 
jean yves girard 
interpr etation fonctionelle elimination des coupures de arithm etique ordre sup erieur 
phd thesis universit paris vii 
mike gordon 
adding eval ml 
personal communication circa 
robert harper robin milner mads tofte 
commentary standard ml 
mit press 
fritz henglein 
dynamic typing 
esop 
erard huet bernard lang 
proving applying program transformations expressed second order patterns 
acta informatica 
butler lampson 
description cedar language 
technical report csl xerox palo alto research center 
xavier leroy michel mauny 
dynamics ml 
proceedings acm conference functional programming languages computer architecture 
liskov atkinson bloom moss schaffert scheifler snyder 
clu manual 
springer verlag 
john mitchell gordon plotkin 
types existential type 
acm transactions programming languages systems july 
alan mycroft 
dynamic types ml 
draft article 
john reynolds 
theory type structure 
proc 
colloque sur la programmation pages new york 
springer verlag lecture notes computer science 
paul 
extending modula build large integrated systems 
ieee software november 
satish thatte 
quasi static typing preliminary report 
proceedings seventeenth acm symposium principles programming languages pages 
pierre weis maria virginia alain michel mauny su 
caml manual 
research report inria rocquencourt september 
niklaus wirth 
modula oberon programming language oberon 
technical report institut fur informatik eth zurich 

