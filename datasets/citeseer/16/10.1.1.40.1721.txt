categorical multi combinator machine simon thompson computing laboratory university kent canterbury 
ac uk rafael lins department informatics federal university brazil implementations functional programming languages take number different forms implementations secd machine landin lan generalisation machine underlying implementations imperative programming languages pascal 
making implementation lazy done cost efficiency details henderson book hen natural way proceeding provided implementation uses rewriting source level expressions 
implementations pioneered wadsworth calculus wad achieved reasonable performance turner observation translation programs variable free combinator form allowed efficient execution 
turner graph reduction combinator code abd followed number researchers including hughes hug johnsson joh lins lins developed different systems combinators algorithms translating source programs combinator form 
implementations characterised interpretive reduction transformation combinator graph seen interpretation graph obvious question raised true compiler lazy functional programs produced 
attempt machine graph augustsson johnsson joh manipulations graph transformed machine instructions rendered machine code 
approach instruction machine tim comes full circle closures represent expressions evaluation 
introduce machine categorical machine 
give machine particular far discussion sharing computational information concerned 
approaches tim depend source code lifted translation takes place 
transformation discovered johnsson joh independently related hughes supercombinators effect making flat environments function bodies interpreted 
transformation came light combinators mentioned reflecting 
discuss detail close relationship tim 
categorical multi combinators second author thesis lins introduces system categorical multi combinators curien categorical combinators cur turn foundation theory cartesian closed categories sco 
major innovation number reductions performed single step rewriting sequence steps 
offers possibility increasing efficiency rewriting implementation considerably similar idea discussed implementors machine joh 
syntax categorical multi combinators consists variables constants superscript natural number combined application written juxtaposition 
usual syntactic shorthand omitting brackets left associated applications adopted 
rewriting laws combinators obey follows 
constant symbol rewrites 
notation 
multi pair ary abstraction 
rule represents selection value variable represented non negative integer block environment frame 
general expression combined frame information means composition operator second law shows distribution environment information complex application 
third rule represents formation frame takes place function application evaluated final rule embodies fact constants lambda expressions functions need environment information interpretation 
rules combined rules constant variable constant variable general expressions compiled categorical multi combinators stages 
expressions lifted removing non local function bodies variables replaced distance binding distance number intervening ls blocks ls replaced example compile combinator defined la lb lc 
ab ac code identity function lx compiles expression 
follow evaluation expression rewriting rules 
expression ii compiles rewrite denote ith clause rule rewrite redex bracket rule noting situation optimisations applies 
note cases optimised form avoided formation frame time 
note redex appears frame reduced steps 
graph reduction redex updated new value graph frame 
resuming evaluation assuming update point evaluation halts 
extending combinator set saw previous section modify rewriting rules set set making observation constant variable body lambda abstraction behaves particularly simple way 
observe compile time acknowledge defining new combinators appropriate effect cases 
examining effect reduction rule effect general form rule 
create composition body expression combined appropriate frame rule cause information values variable distributed body abstraction 
see action example ii examined 
see alternative strategy suggests perform evaluation body lambda abstraction preserve frame information separately perform lookups information necessary 
examining example looked earlier say rewrite expression frame picture expression current frame separately 
fetch values frame necessary 
point fetch value frame continue 
note procedure update frame reduced value variable reduced return issue sharing 
obviously simply create single frame course evaluation 
maintain structure frames corresponding various redexes reduce course evaluation 
stack frames natural structure frames generate stack 
time evaluate function application push frame multi pair stack frame formed arguments application 
deal pure untyped expressions ground values numbers find result function call expression reduction redex gives rise function call creating frame 
words need pop frame stack 
need preserve earlier frames formed simply keeping track current frame 
reasons 
case add base values explain second keep track information free variables 
consider situation expression frame stack calls formation new frame frame free variables previous frame 
possibilities suggest resolve free variables time form frame 
done copying entry appropriate frame copying pointer position frame 
difficulty solution allows possibility frames may longer extent suggested stack discipline 
situation outlined situation simple find values free variables frame look frame frame stack 
instance stack values variables frame top frame 
values free variables frame stack 
consider variant previous example expression frame stack formation frame produces situation problem 
sub expression refers newly formed frame final refers previous frame 
included information extent function body expression produced 
placing mark expression delimits extent function body presence shows right top frame frame stack 
similarly variable fs lookups frames stack 
analogous problem see difficulty frame formation 
expression frame stack 
calls formation frame 
note obviously argument don incorporate frame 
need note argument top frame whilst second right top 
form frame ways indicated resolve free variables time form frame 
annotate position frame formation number fs occur left corresponding argument expression 
fact easily copy fs frame leaving code 
example mean new frame form case sure confuse copied code mark prime strategies sufficient give correct information variable bindings 
structured expressions sequence instructions design decision turn expression evaluation flat sequence code instructions 
turn expressions familiar sequence code instructions left associated applications simply treated sequence instructions bracketed applications replaced labels bodies abstractions labelled 
considering example saw ii produced code code replaced fun body body obey instructions 
behaviour instructions exactly 
occurrence label instruction results code label replacing label 
obviously implemented jump code labelled return address held stack continuations example 
exactly code right instruction represents continuation computation 
effect results adding labels code 
move code frame resolve contain form free variables 
comment apply piece code contains label refers code containing free variables labels body appear example 
alternatives sort resolution mentioned 
second note frame referenced simply replaced referent 
second possibility available causes difficulty 
may number particular label different instantiations variables change code referenced label 
create new instance labelled code instantiating variables appropriate way 
imposes overhead comparable overhead template instantiation implementations 
means code longer static generate code execution proceeds 
recursion labels able treat recursion completely straightforward way recursive functions compiled functions circular definitions functions refer labels code 
stack basic values want add system values base type integers characters means stack store intermediate results calculations exactly done postfix expression evaluators familiar conventional machines 
means values stored places machine 
basic values reside ground stack functional values represented state expression multi pair stack 
detail handle base types instruction sequence instructions number transferred ground stack instruction operation applied appropriate number arguments case taken ground stack result replaced ground stack 
conditional expression treated similar way compiling code sequence code compiled label code instruction branch whichever labels code chosen point machine different tim explicit stack base values self combinator 
summary summarise behaviour machine 
note sorts instruction 
operators constants affect ground stack multi pair stack reverse 
summarise 
note convention boldface symbols represent constants symbols variables 
code multi pair ground code multi pair ground stack stack stack stack 




true 


false 



summarising instructions omit ground stack affected action 
code multi pair code multi pair stack stack 





note execution instruction treat mark different way 
fs left stack moved frames 
example 


comes entry function body second originally lay example section look example operation machine 
expression lx ly lz xy xz lw compile code body ex body ex ex body ex ex body ex execution proceed code multi pair stack ground body ex 
body ex 
ex ex 
ex ex ex 
body ex ex ex 
body ex ex ex 
note frame just formed free variable refers frame 
recorded explicitly keep informal track fact sequence moves look value careful take right frame 
ex ex ex 
ex ex ex ex 
ex ex ex 
place constant values ground stack ex ex ex ex ex ex add ex ex ex fetch value previous frame ex ex ex ex ex ex ex ex ex ex ex ex ex ex body ex ex body ex ex note frame just formed free variable 
ex ex ex ex ex ex ex place constant values ground stack ex ex ex ex ex ex fetch value previous frame ex ex ex ex ex ex ex ex 
example exhibits main features machine including fact lazy 
computation labelled ex repeated saved performed 
section look means add sharing machine making lazy 
sharing feature machine described far lacks ability share results computations 
graph reduction lifted expressions joh ensures arguments duplicated computation shared called lazy evaluation 
remains sub expressions shared arguments computation shared transformation 
way achieve full laziness graph reduction machine categorical multi combinators perform transformation maximal free expressions 
disadvantage compilation scheme granularity computation reduced 
contrast graph reduction ensure full laziness runtime strategy inspired mechanism tim 
example situation update arguments explicitly repeated consider expression lf lx ly fx fy la lq argument repeated expression result evaluation lq 
shared argument function lf lx ly fx fy 
need update slot containing argument contain value slot containing argument 
need decide mechanism achieve sharing require 
number options 
decide label occurrence variable requiring updating evaluated perform compile time analysis decide occurrences variable shared lot area see instance gol survey general techniques involved final option adopt mark occurrences repeated variables distributing marks variables evaluation proceeds 
mechanism sharing relatively straightforward 
arrange works kinds value machine 
basic values numbers transferred ground stack evaluated simple arrange appropriate frame slot updated appropriate time 
think placing mark code expression carrying information argument lies frame update take place mark reaches head code 
update slot mentioned value just transferred ground stack carry 
kind value functional 
functions represented portions code sufficient frame information interpret free variables 
instance function lx represented code function lx 
may represented number different ways depending way generated evaluation 
simplest representation code body body labels code may represented code expression bound 
la lx terms categorical combinator code body body labels code current frame binds variable 
meant sufficient frame information 
may find code part function representation contains fs 
case refer frame gain information 
fact perform update replace free variables values 
expensive option sure value frame fact label pointer 
effect update just replace index frame pointer 
alternative method provided grouping variables pointers frames come 
forms looks closure machine look closer tim 
perform update functional value 
terms perform update function reaches weak head normal form lx reduction need supply expression argument value words result canonical form find function arguments 
manifested 
marker code signifying lies left eventually represent canonical value expression 
canonical value form body code takes form body update label code left variables replaced labels pointers explained 
examine examples show sharing works 
compiling expression lx lx obtain script ex ex ex ex ex ex ex ex ex shared occurrences variables appear outline font execute example code multi pair stack ground ex 
ex ex ex 
ex ex 
ex ex 
ex ex ex ex 
note slots multi pair occupied labels appearing script 
ex ex ex ex 
ex ex ex ex 
ex ex ex 
ex ex ex point update ex entry script making link ex continue execution ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex ex second update unnecessary mark label effect 
ex ex ex ex consider second example share partial function application 
expression la lb lc ac bc li lj lk ll translates expression ex script 
ex ex ex ex ex ex ex ex ex ex look evaluation code multi pair stack ground ex 
ex ex ex ex 
ex ex ex ex 
ex ex ex ex ex 
ex ex ex ex 
ex ex ex ex 
ex ex ex ex ex 
ex ex ex ex ex 
point arguments left hand side ex perform reduction 
update label ex code left ex ex continue 
note simple example free variables code updates label 
recall replace labels refer 
evaluation proceeds ex ex ex ex 
ex ex ex ex 

account new machine ideas categorical multi combinators appeared lins 
machine links tim machine explored companion 
development machine functional programming language miranda ideal tool machine prototyping written prototype machine obviously step build complete implementation machine efficient manner 
grateful richard jones david turner university kent discussions ideas defects course responsibility 
miranda trademark research software bibliography abd abstraction algorithm combinatory logic journal symbolic logic pp 
abramsky hankin eds 
interpretation declarative languages ellis horwood 
cur 
curien categorical combinators sequential algorithms functional programming pitman 
fairbairn wray instruction machine kahn gol goldberg detecting sharing partial applications functional programs kahn hen henderson functional programming application implementation prentice hall 
hug hughes design implementation programming languages phil thesis oxford university 
joh johnsson efficient compilation lazy evaluation proceedings acm sigplan symposium compiler construction montreal acm press 
joh johnsson lambda lifting transforming programs recursive equations jouannaud ed 
functional programming languages computer architecture lecture notes computer science 
joh johnsson compiling lazy functional languages ph 
thesis chalmers 
kahn kahn ed 
functional programming languages computer architecture lecture notes computer science springer verlag 
lan landin mechanical evaluation expressions computer journal pp 
lins lins efficiency categorical combinators applicative languages ph 
thesis university kent canterbury 
lins lins categorical multi combinators kahn lins thompson equivalence cm tim computing laboratory report university kent canterbury revised 
submitted publication journal functional programming 
sco scott relating theories lambda calculus seldin hindley eds 
curry essays combinatory logic lambda calculus formalisation academic press 
tur turner overview miranda turner ed 
research topics functional programming addison wesley 
wad wadsworth semantics pragmatics lambda calculus phil thesis oxford university 
