compiling proofs george necula september cmu cs school computer science carnegie mellon university pittsburgh pa submitted partial fulfillment requirements degree doctor philosophy 
thesis committee peter lee chair robert harper frank pfenning greg nelson dec src copyright george necula research sponsored part advanced research projects agency title fox project advanced languages systems software arpa order 
issued esc ens contract 

views contained document author interpreted representing official policies expressed implied advanced research projects agency government 
keywords mobile code agents proof carrying code safety properties security properties type safety program verification certifying compilation theorem proving decision procedures proof checking proof representation logical frameworks lf lf term reconstruction software engineering compiler verification 
major challenges building software systems ensure various components fit defined manner 
problem exacerbated advent software components origin unknown inherently untrusted mobile code user extensions kernels database servers 
extensions useful implementing efficient interaction model client server data exchanges saved cost single code exchange 
dissertation propose tackle system integrity security problems techniques mathematical logic programming language semantics 
propose framework called proof carrying code extension provider sends extension code representation formal proof code meets certain safety correctness requirements 
code receiver ensure safety executing extension validating attached proof 
major advantages proof carrying code requires simple trusted infrastructure impose run time penalties purpose ensuring safety 
addition concept proof carrying code dissertation contributes idea certifying compilation 
certifying compiler emits addition optimized target code function specifications loop invariants enable theorem proving agent prove non trivial properties target code type safety 
certifying compiler proof generating theorem prover convenient producer proof carrying code powerful software engineering tool 
certifier acts effective referee correctness compilation simplifying considerably compiler testing maintenance 
complete system proof carrying code contain proof generating theorem prover purpose producing attached proofs safety 
dissertation shows standard decision procedures adapted produce detailed proofs proved predicates proofs encoded compactly checked efficiently 
just certifying compiler proof generating theorem prover significant advantages traditional prover 
case simple proof checker ensure soundness successful proving task indirectly assist testing maintenance theorem prover 
iii suffered graduate student wife provided generous support sylvia suffered love acknowledgments am greatly indebted people helping complete dissertation 
foremost course friend advisor peter lee 
guidance significant progress skills defining researcher 
taught recognize pursue promising research problems researcher moral obligation strive perfection communicating research results 
peter technical contributions deep 
read part thesis times comments improved immensely iteration 
peter dedicated researcher teacher 
am lucky studied hope small portion worn enjoyable meetings discussions 
owe special debt members thesis committee 
robert harper frank pfenning taught rigorous 
courses programming language semantics logic laid foundations thesis 
comments dissertation increased technical quality significantly 
greg nelson played dual role research career 
summer internship dec src members esc project introduced program verification theorem proving ended essential ingredients 
external member committee greg suggested improvements dissertation 
john reynolds studied manuscript carefully numerous comments improved organization material technical quality 
addition thesis committee fruitful discussions material received comments suggestions martin abadi andrew appel andrew bernard mihai budiu jose carlos karl crary peter dinda brian ford lal george garth gibson jim horning dexter kozen ht kung jay lepreau pat lincoln john mitchell greg morrisett brian noble rob callahan susan owicki fred schneider natarajan shankar olin shivers ion stoica david 

stay carnegie mellon lucky colleagues graduate school enjoyable 
remember distinct pleasure joe jose carlos romanian lunch bunch mihai budiu marius ion stoica 
vii concrete origins dissertation traced years graduate school carnegie mellon university consider culmination years education scientific pursuit 
take opportunity express gratitude long series teachers mentors encouraged thirst knowledge served role models various stages life 
serious encounter science field physics guidance high school teacher pop country birth romania 
won physics 
high standards ambitions help mentoring successful national international competitions 
sure doing time hardly called research lessons learned process invaluable 
am grateful showed computer time encouraged helped mother buy zx spectrum tip balance favor computer science away physics teacher high school radu 
radu close friend mentor best man wedding 
college teachers played significant role education pu dan suciu cristian paul polytechnic university bucharest 
special place heart goes parental advice encouragement ensured maintained high goals 
encourage pursue graduate studies cooperation val breazu tannen research career 
special go family 
mother brother edmond love support 
finished research time wife parents mihai helping entire year 
wife constant support daughters sylvia gave numerous moments joy strength required finish research write dissertation 
viii contents acknowledgments vii traditional solutions agent security 
safety personal authority 
safety hardware address spaces 
safety programming language semantics 
outline dissertation 
overview basic proof carrying code protocol 
preliminary step defining safety policy 
step generating annotated agent code 
step generating verification condition 
step proving verification condition 
step verifying proof 
variants proof carrying code 
benefits costs proof carrying code 
frequently asked questions 
proof carrying code infrastructure safety policy sal generic assembly language safe agents 
operational semantics sal 
porting proof carrying code concrete architectures 
porting dec alpha architecture 
porting intel architecture 
discussion 
ix enforcing safety proof carrying code logic 
syntax 
standard valuation model 
verification condition generator 
axiomatization logic 
discussion 
proof engineering edinburgh logical framework 
lf type system 
implicit lf representation 
algorithm lfi type reconstruction 
algorithm lfi representation 
representing arithmetic proofs 
implementation lfi 
discussion 
ii proof carrying code tools touchstone certifying compiler basics loop invariants 
type safety policies 
logic type safety 
examples type safety policies 
safe source language 
automatic generation loop invariants 
touchstone optimizations invariants 
dead code elimination 
common subexpression elimination 
copy propagation 
instruction scheduling 
register allocation 
loop invariant hoisting 
induction variable elimination 
redundant conditional elimination 
array bounds checking elimination 
discussion 
proof generating theorem prover nelson oppen prover architecture 
control core theorem prover 
handling logical connectives 
dispatcher module 
handling case splits 
decision procedures 
handling equality congruence closures 
handling linear arithmetic simplex 
example congruence closure simplex 
handling touchstone typing rules 
discussion 
iii evaluation proof carrying code experimental validation proof carrying code proof carrying code packet filters 
safety policy 
performance comparisons techniques 
experiments touchstone compiler 
experimental validation lfi 
discussion 
contributions 

bibliography soundness verification condition generation soundness lfi proof checking correctness lfi type reconstruction 
soundness lfi typing 
auxiliary lemmas 
xi list figures overview basic proof carrying code protocol 
fragment logic type safety memory safety 
sample specification type safety 
sample source code type safe agent 
agent code array bounds checking elimination 
agent code array bounds checking optimization 
example verification condition predicate 
fragment verification condition proof 
lf encoding logic 
lf representation proof fragment 
lfi representation proof fragment 
syntax safe assembly language sal 
operational semantics sal 
layout sal stack frame 
translation dec alpha sal 
translation intel sal 
register aliasing intel architecture 
addressing modes intel architecture 
special sal support operators intel 
enforcing safety vcgen 
syntax logic 
standard valuation function logic 
validity standard model 
stack management sal 
definition verification condition generator sal 
helper functions vcgen 
axiomatization logic 
axiomatization special support operators 
xiii syntax edinburgh lf 
lf representation syntax logic 
lf representation axiomatization logic 
lf representation proof 
lf type system 
lfi type system 
bimodal lfi representation algorithm 
computation bimodal representation recipes 
example bimodal representation recipes 
encoding additive group integers lf 
algorithm arith checking arithmetic equalities 
role proof carrying code tools 
type system type safety policies 
representation types 
syntax logic type safety 
axioms type safety 
syntax source language 
compilation types variable declarations 
example compilation array bounds checking 
loop residue decision procedure linear arithmetic 
structure theorem prover 
fragment hereditary harrop formulas 
handling logical connectives 
dispatcher functions 
definition split module 
interface decision procedure 
axiomatization equality 
invariants maintained congruence closure 
congruence closure decision procedure 
implementation set union 
kernel rules arithmetic 
proof rules simplex 
simplex decision procedure 
proof generation component simplex 
running example congruence closure simplex 
running example congruence closure simplex ii 
running example congruence closure simplex iii 
typing decision procedure 
xiv proof related costs pcc packet filters 
comparison run time performance packet filters 
amortization proof validation cost packet filters 
relative sizes proofs invariants machine code 
relative lengths time compilation proving proof checking target code performance comparison compilers 
compilation time comparison compilers 
target code size comparison compilers 
correlation proof size proof validation time 
correlation proof size memory usage reconstruction effect bimodal representation proof size 
effect bimodal representation proof validation time 
effect occurs check optimization proof validation time effect memory optimization memory usage 
inductive invariant vcgen soundness proof 
xv chapter provide access internal data resources server traditionally exports static collection basic operations corresponding data set system call entries exported operating system kernel 
order static interface client decompose computation sequence operations mapping directly exported server 
flexible efficient interaction model active interfaces 
active interface paradigm client creates uploads program referred agent mobile code server installs executes environment direct access data resources 
situation convenient refer client code producer server code receiver 
major advantage active interface paradigm reduce amount communication client server 
illustrate point consider case server spacecraft gathering large amounts data remote part universe 
latency communication earth order hours limited speed light available bandwidth limited kilobytes second 
obvious data processed onboard select results sent earth 
furthermore afford fix set data analysis programs entire duration trip 
natural solution constraints active interface earth station update replace set data analysis programs executed executed onboard 
particular example illustrates situation necessary agent execute efficiently possible order best scarce supply power 
suggests technique implement active interfaces penalize performance uploaded agents resident programs 
subtle advantage active interface model interaction allows server export safely flexible lower level interface agents indirectly code producers 
traditional client server interaction model server advance knowledge agent program residing client case chapter 
know uses data services provided 
means traditional server export secret data give access low level services subvert system 
active interface model hand code receiver examine agent program running ensure access secret data leak untrusted parties uses properly provided low level services 
consider example agent prepares tax return financial data provided code receiver 
code receiver controls agent program ensure financial data leaked 
similarly code receiver allow agent temporarily disable interrupts inspecting agent program verify agent keep interrupts disabled short period time 
flexibility efficiency advantages active interfaces ask scenarios described sound science fiction reality today 
think security complexity concerns raised active interfaces 
major difficulty deploying active interface ensure security code receiver system data presence untrusted agents 
involves protection malicious agents protection erroneous code supplied known trusted code producers 
scenario worth considering potential damages due error high spacecraft example 
furthermore reasonably concerned mechanisms enforce security aspect active interfaces lead agent execution overhead larger trustworthy receiver side infrastructure 
thesis 
thesis ideas logic programming languages ensure safety executing software agents means static checking sacrificing performance relying personal authority 
furthermore achieved small trusted infrastructure receiver side 
order minimize complexity static checking required infrastructure code receiver rely easily checkable producer provided evidence safety properties code 
technique called proof carrying code 
furthermore thesis safety evidence required proof carrying code produced automatically large class safety properties part compilation process generates agent executable 
variant compilation called certified compilation 
shall see addition constituting front proof carrying code certified compilation provides simple effective method testing compiler produces code matches safety specification verifying evidence compiler produces code 
dissertation describe particular instance ideas evidence safety code takes form formal proof code satisfies 
traditional solutions agent security safety specification 
proof specification expressed mathematical logic case extension order predicate logic 
outline detail techniques proof carrying code certifying compilation section discuss traditional solutions protecting code receivers misbehaving agents 
argue traditional solutions inadequate show natural way address drawbacks allow static checking safety 
rest ideas expressed dissertation merely ways overcome inherent complexity static analyses undecidability interesting code properties 
traditional solutions agent security techniques currently systems interact mobile code classified main categories 
techniques judge safety code identity agent creator 
techniques agent executed sandbox access critical data resources directly 
techniques rely interpreters receiver side compilers enforce safe agent behavior 
classes techniques advantages disadvantages discussed 
safety personal authority aim class techniques prevent unsafe code executed create accountability deterrent distribution harmful agents 
purpose agent producers required sign digitally code produce 
allows code receiver verify identity producer code integrity maintained code producer receiver 
commonly technology purpose public key cryptography example microsoft mic 
approach practical merits number disadvantages important prevent trusted producers creating uploading erroneous agents 
fact error traced concrete producer little large amount damage occurred due mistake 
personal authority approach safety penalizes unfairly small individual agent producers favor larger better known producers 
code receiver benefit doubt agent received unknown lesser known producer 
problem small interacting entities know definitely drawback environments large anonymous masses chapter 
programmers interact active agents case active interfaces exported internet 
reasons personal authority way ensure safety 
look approaches consider intrinsic properties agent code independently produced produced 
personal authority important component safety policy execution mobile code cases personal authority combination techniques discussed 
safety hardware address spaces simplest methods ensure safe execution untrusted code isolate hardware enforced address space accesses non private data resources intercepted monitored code receiver infrastructure 
main technique operating system kernels protect misbehaving userlevel applications 
important component scheme protection design secure system call interface consists server provided functions agent code may invoke accessing system data resources 
proper implementation interface check invoking agent necessary rights perform requested operation provided arguments valid 
extra care required multiprocessing environment ensure atomicity argument checking procedure 
usually accomplished copying arguments memory area inaccessible user applications 
main advantage hardware solution relatively simple easy implement trust 
disadvantage high cost associated switching protection domain agent code receiver back cost copying arguments results address spaces 
problem agents high ratio data processing system calls hurt performance majority agents 
overlooked disadvantage enforcing safety memory protection imposes constraints design client interface 
order able enforce amounts data types server introduce level indirection actual data structures agent 
example typical operating system enforces type file descriptors file handles small positive integers identity verified run time verification easily performed clients referring files actual pointers kernel data structures 
second system consider possibility having terminate agent prematurely agent chance acquire critical resources alter state system significant manner 
prevent server 
traditional solutions agent security disallow significant side effects part agent interface employ costly transaction mechanism able undo effects 
interesting data abstraction side effect problems due fact exclusive run time checking implementing safety 
furthermore necessary agent code intimate coupling code receiver provided fixed application programmer interface api separate address spaces 
consider example agent requires simple time critical processing done interrupt 
simplest way achieve allow agent install interrupt handler run privileged mode case hardware protection mechanisms usable 
disadvantage hardware techniques safety require special hardware relatively complicated operating system support features available lean environments smart cards embedded systems 
safety programming language semantics number approaches enforcing safe execution agents proceed selecting agent programming language semantics valid agent programs guaranteed conform safety policy 
important characteristic approaches programming language semantics complexity safety policies enforced strongly dependent expressiveness programming language considered 
illustrate point consider called type safety approaches type system distinguish syntactically correct programs share certain desired safety properties 
case type checker thought decision procedure subset programs behaved respect safety policy 
type safe languages safe operating system extensibility burroughs lev employed research operating systems spin bsp 
examples general purpose type safe languages currently writing untrusted agents system extensions java gjs java virtual machine bytecode language ly modula nel 
cases type safety usually means memory safety data abstraction 
level safety significant rivals hardware memory protection finer granularity lower costs careful abstraction surpass approaches purely run time checking 
type safety mean just memory protection data abstraction enrich type system 
consider example type system includes parametric polymorphism type system standard ml mth function foo polymorphic type foo vector 
possible prove type system typed implementation foo selects returns ele chapter 
ments vector argument 
general interesting code properties proved functions typed polymorphic type system acc wad 
unfortunately level type safety provided general purpose languages prevent agents subverting code receiver 
example type systems mentioned enforce resource usage bounds revocation capabilities 
fundamental reasons languages expressive interesting dynamic properties reduced halting problem turing machine undecidable 
properties enforced type safety practical type system willing restrict language strictly expressive turing machine 
path taken approaches domain specific languages dsl effect restricting syntactically valid programs small subset interest particular application domain 
example dsl system extensions berkeley packet filter mj language termination easily decidable looping constructs allowed 
general code receiver language technique enforces safe semantics stages 
static checking stage receiver performs detailed inspection agent code ensure valid program selected language 
stage includes syntax checking type checking typed languages 
second stage takes place agent executing 
second stage receiver ensures operations potentially harmful safety ascertained static checking pass preceded run time checks safety 
shall refer stage dynamic checking stage 
purpose static checking phase catch early common programming errors sources harmful behavior 
amount kind static checking performed ranges simple control flow checking complicated type checking 
example berkeley packet filter bpf mj architecture untrusted code scanned verify instructions belong restricted bytecode language branches forward targets code boundaries 
contrast approaches type safe languages full fledged type checking pass agent code 
static checking stage receiver execute agent way potentially harmful operations guarded run time checks safety array bounds checking null pointer checking 
complicated static checking fewer run time checks required 
case static checking consists type checking expressive type system code properties memory safety data abstraction guaranteed run time checks 
easiest way implement dynamic checking stage interpretation 
basically means untrusted agent code interpreted safe trusted languages function foo diverge 

outline dissertation interpreter performs required dynamic checks mandated safety policy 
example order enforce memory safety interpreter verify memory access agent accesses memory areas permitted safety policy 
examples safe interpreters berkeley packet filter interpreter mj operating system extensions java virtual machine interpreter ly mobile code 
major drawback interpreter approach reduced execution speed unusual observe order magnitude slowdown due interpretation 
natural solution interpretation overhead problem replace interpreter trusted just time compiler compiling agent code inserts run time checks similar interpreter perform 
note generic term compiler tool cases source target language 
example compiler edit machine code agents inserting bounds checks memory operations 
approach called software fault isolation sfi enforce memory safety extensible operating system vino sess 
sfi compiler mentioned analyzes modifies machine code agents enforce memory safety 
easier analyze agents written high level intermediate level languages meaning complex safety properties enforced fewer safety checks cost complicated compiler 
example compiler java virtual machine bytecode produces machine code augmented array bounds checks 
higher level language allows type checker enforce statically properties data abstraction restricts run time checking memory safety memory operations access arrays 
compiler approach safety leads agents significantly faster interpreted versions 
advantage comes high price 
compiler significantly complex interpreter means code receiver rely correctness larger complicated body code 
drawback getting pronounced optimizations incorporated compiler attempt maximize performance benefit interaction mobile code 
outline dissertation discussion traditional techniques ensuring safety untrusted agents suggests ideal enforcement method possible static checking 
way avoid overhead run time checking complications associated forcefully terminating agents 
static checking execution agent code started guaranteed safe 
thesis statement indicates propose static checking verifying safety untrusted code 
possible general propose agent producer chapter 
creates formal proof safety agent 
enables code receiver verify complex safety properties small easy trust infrastructure consisting proof checker 
second part thesis large class safety properties formal proof produced automatically certifying compiler 
particular safety properties mind enforced safe interpreter just time compiler approaches discussed previous section 
major difference certifying compilation process takes place code producer site code receiver incur cost compilation interpretation trust compiler interpreter 
gentle concepts proof carrying code certifying compilation discuss chapter high level steps taken code producer uses certifying compilation interact code receiver proof carrying code 
part process identify main software components involved summarize design implementation requirements meet 
actual details design implementations components described subsequent chapters 
overview chapter main body document divided parts dealing respectively pcc infrastructure residing code receiving tools code producer experimental evaluation entire system 
part interested reader find detailed discussions technical barriers successful implementation presentation design implementation 
cases barriers practical implementation issues cases theoretical issues solution important occurrence proof carrying code system 
chapter summarize contributions dissertation suggest directions research 
chapter overview chapter informal high level overview techniques proof carrying code certifying compilation 
presentation structured step step description interaction server code receiver client code producer code produced certifying compilation 
interaction step describe software components involved focusing functional behavior ignoring time actual implementation details 
illustration purposes simple running example show fragments proofs code transferred code producer code receiver step 
structure chapter running example intended illustrate integrated system proof carrying code certifying compilation important realize techniques taken individually different strengths characteristics 
proof carrying code general powerful sense handle complex safety properties 
contrast certifying compilation dissertation handles type safety relatively small subset class safety policies enforceable proof carrying code 
differentiating characteristic system components implementing proof carrying code referred pcc infrastructure trusted order ensure safe agents executed implementing certifying compiler need trusted 
trust relationships imply infrastructure executed trusted code receiver tools may executed untrusted systems code producers 
certifying compiler particular way producing proof attachments required proof carrying code 
general proofs produced variety methods referred collectively pcc tools 
lack detail chapter necessarily informal 
purpose rest dissertation provide missing details formalize methodology completely 
just information contained chapter reader proceed read part iii devoted experimental evaluation pcc infrastructure chapter 
overview pcc tools theorem prover certifying compiler 
proof carrying code applications application may entail variations precise details approach 
say variations section 
describe section canonical implementation pcc general variations seen optimizations special cases 
chapter ends summary benefits costs proof carrying code certifying compilation section short question answer section addressing limitations design issues arose frequently various public presentations material 
basic proof carrying code protocol general presentation proof carrying code idea useful introduce system third party proof producer addition code producer code receiver 
practice turns code producer proof producer system general may separate entities 
shows graphically steps involved typical pcc session 
code producer proof producer untrusted entities left hand side code receiver trusted entity right hand side 
boxes represent code data manipulated rectangular boxes represent pcc software components 
white boxes trusted entities grey ones untrusted 
code receiver accept pcc agents establish safety policy defines actions agents allowed perform circumstances actions allowed 
concrete embodiment safety policy pcc system consists shown components described section 
assume code producer wishes certifying compilation interact pcc enabled code receiver 
case pcc session starts code producer compiling agent source code target code annotated loop invariants 
purpose code producer uses certifying compiler discussed briefly section detail chapter 
code producer sends annotated agent code code receiver requesting execution 
receiver inspects code vcgen component safety policy returns verification condition predicate validity sufficient guarantee safety executing agent 
step described section 
receiver attempt potentially difficult task verifying validity verification condition 
verification condition sent proof producer returns proof discussed section 
proof passes proof checking process described section receiver safely install run agent code 
sections steps described detail 

basic proof carrying code protocol proof producer source certifying compiler theorem prover code producer trusted simple fast invar code proof code receiver vc untrusted complex slow spec logic safety policy vc generator proof checker basic proof carrying code protocol 
boxes represent data code rectangular boxes represent system components 
white elements elements trusted grey elements trusted 
preliminary step defining safety policy central component pcc implementation safety policy represents set rules define unambiguously agent program safe execute 
safety policy defined advance administrator code receiver system trusted component infrastructure 
variant proof carrying code described dissertation targeted safety polices focus actions agent code allowed execute situations action executed 
informally view safety policy set action preconditions 
precise description covered set policies chapter 
safety policy defined context agent language 
proof carrying code restrict languages agents programmed 
pcc adapted high level languages improve portability agent programs low level languages hand optimized machine code maximize performance agent minimizing size trusted infrastructure 
code receiver accept agents written multiple programming languages case safety policy chapter 
overview adapted language 
safety policy viewed set action preconditions agent language directly usable code receiver 
safety policy embodied pcc infrastructure distinct components follows mathematical logic able describe preconditions agent action allowed 
logic language pcc system describe verify action preconditions 
logic language encode code annotations verification conditions proofs 
variant pcc described order predicate logic extended predicate symbols required safety properties proved principle program logic 
concrete form logic set syntactic predicate constructors set axioms inference rules define provability predicates 
shown representation logic available proof producers 
safety policy specify functions agent obligated provide receiver provided functions agent allowed invoke 
done means specifications functions 
function specification pair precondition postcondition expressed predicates selected logic 
function precondition describes state variables actual arguments moment function invoked 
precondition established prior invoking function 
enables callee assume holds verifying 
function postcondition describes relationships variables actual arguments result values 
postcondition predicate established prior returning function acts precondition function return action 
enables caller assume holds return 
safety policy contains method inspecting agent code discovering actions agent perform circumstances 
accomplished verification condition generator vcgen scans agent code collects set actions performed execution partial description program state actions attempted 
information expressed predicate logic verification condition 
vcgen designed verification condition agent provable selected logic agent code considered safe execute respect current safety policy 

basic proof carrying code protocol operation vcgen described section part step pcc protocol 
aspects components safety policy described context simple example 
detailed formal discussion safety policy relationships various components see chapter 
illustrate concepts discussed overview chapter consider case code receiver wishes enforce type safety memory safety agents written generic assembly language 
purpose administrator code receiver system establishes safety policy consisting logic set specifications generator 
agent language chosen generic assembly language avoid need receiver side compiler interpreter 
actions handled safety policy hand function calls returns memory reads writes 
fact large number safety policies described small class agent actions 
safety function call return defined case set type restrictions value variables 
example safety policy considers simple types integers booleans array types 
array type encodes array element type array length 
furthermore code receiver wants retain full control representation booleans safety policy discloses bitwise operations boolean values produce valid boolean values 
memory safety aspect safety policy requires addresses fall bounds arrays dereferenced values appropriate element type written array 
order express precondition function calls returns memory operations administrator code receiver defines logic syntax shown top 
logic extension order predicate logic typing predicate written infix notation expression type 
order express memory safety generic manner arrays logic contains predicate saferd denoting safe read memory address denoted expression extensions order logic needed represent effect memory operations 
memory state modeled logic explicitly expressions 
expression denotes current memory state expression sel denotes bit contents memory location address denoted express new memory state store value address memory state write upd 
non requirement part code receiver example code receiver implemented standard ml new jersey reserves significant bit distinguish pointer values 
system boolean values represented integers values false true respectively 
simplify presentation assume chapter memory operations operate byte level 
assumption easily relaxed deal memory word sizes 
chapter 
overview expressions sel memory upd types int bool array predicates px saferd rules bool bool bool bool bool bool sizeof bool array len len sizeof saferd array len sizeof len sel fragment logic type safety 
note memory safety enforced array bounds checking booleans specified values type 
addition description syntax logic contains set inference rules proof producer prove verification condition 
fragment set inference rules shown bottom 
agents written low level language manipulate concrete representations source level types 
means logic code receiver discloses necessary representation information producers 
example rules say concrete representation array memory address sequence consecutive memory locations holding values appropriate type 
addition rules establish meaning memory safety example memory locations safely read boundaries array 
array rules reveal concrete representation arrays inference rules manage preserve view booleans 
rules agent designer knows boolean value occupies byte bitwise operations boolean values produce valid boolean values 
consequence type safe agent forge boolean values transform bit operations mentioned rules 
agent code attempt create boolean value method able prove result boolean 
note agent producer prior knowledge actual representation booleans 
recipe complex data types specified logic code receiver enforce abstraction boundaries 
interested 
basic proof carrying code protocol reader find section detailed discussion enforcing data abstraction proof carrying code 
logic component safety policy place code receiver proceeds identifying functions act interface agent 
simplify example assume receiver export functions agent agent entry point called main function boolean value array booleans length return boolean value 
specification formulated logic shown 
note specification reveals receiver calling convention registers ra rb rl actual arguments register rr return value 
note main implemented agent specification code receiver part safety policy 
ignore dissertation process code producer code receiver agree functions exported agent functions provided code receiver 
rb bool ra array bool rl post main rr bool sample specification type safety function specification entails certain obligations code receiver agent depending function defined follows functions exported agent receiver infrastructure establish precondition invoking function 
means example receiver invoke main rb containing valid boolean value ra containing address properly allocated array filled valid boolean values length array passed rl 
return agent establish postcondition case requires returning formed boolean 
verification condition agent contain part verifying 
functions exported receiver agent agent ensure function precondition holds prior invocation 
obligation stated verification condition 
return code receiver obligation establish postcondition prior returning control agent 
functions defined agent internal receiver obligations 
agent define specification function sees fit functions way consistent specification 
specification internal functions part annotations accompany agent code 
chapter 
overview note list obligations code receiver proof carrying code ensure agent satisfies obligations 
hand code receiver trusted component system means designer implementor receiver ensure interface obligations met 
component safety policy verification condition generator discussed section context concrete agent example safety policy introduced 
note safety policy established service agent processed 
steps described taken code receiver code producer individual agent 
step generating annotated agent code action code producer takes initiate interaction code receiver pcc prepare agent code requested safety policy specifically vcgen component safety policy 
vcgen requires agent code syntactically formed selected language 
vcgen requires functions defined internally agent code annotated precondition postcondition loop associated loop invariant 
loop invariants specifications internal functions referred annotations 
point view vcgen suffices annotations formed predicates selected logic 
ensure vcgen reject code sufficient guarantee code ultimately steps pcc protocol 
happen annotations correct sufficiently strong described formally chapter 
requirements clearer discuss rest steps pcc protocol 
intuitively loop invariant correct annotation valid predicate time execution reaches loop 
similarly function specification correct precondition holds time function invoked postcondition holds time function returns 
note weaker annotation easier ensure correctness 
example weakest loop invariant true evidently correct invariant 
notion sufficiently strong annotations difficult explain informally 
function precondition sufficiently strong assuming holds function prove body function safe execute 
stronger annotation easier satisfy sufficiency requirement 
see annotations strong weak 
task annotating code delicate 
fact just aspect fact designing program difficult general useful specific correctly efficiently implemented 
fortunately large class safety properties possible create annotations automatically modified compilation technique call certifying compilation 
idea borrows approaches safety programming language semantics 
basic proof carrying code protocol high level language selected agents semantics defined violations safety policy occur 
semantics enforced combination static checks performed compiler run time checks inserted compiler agent code 
far different traditional compiler safe high level language performs 
difference certifying compiler produces safe target code emits typing information supporting annotations optimizations performed 
information easy produce compiler enables external system pcc code receiver conjunction proof producer case verify result compilation type safe 
explained detail formalized completely chapter 
proof certifying compilation concept implemented certifying compiler called touchstone type safe subset programming language 
implementation details touchstone described chapter 
rest section show touchstone operates context simple agent source shown 
note dialect compiled touchstone arrays base address length accessed built operation length 
contrast common programming practice length array manipulated directly programmer 
bool main bool bool int bool length return sample source code type safe agent function main computes conjunction boolean values array boolean value received input 
touchstone parses program translates intermediate form optimized 
simplify presentation generic assembly language intermediate form target language 
touchstone behaves traditional optimizing compiler type safe language 
distinguishing aspect compilation generation annotations 
section describe informally generation loop invariants agent 
context type safety policy kind loop invariants produced typing loop invariants 
typing loop invariant conjunction typing predicates variables live loop modified chapter 
overview body loop 
example includes registers target program hold values call respectively ri rr 
typing loop invariant example follows ri int rr bool typing loop invariant fact sufficient compiler perform certain optimizations 
attempt maximize performance target code touchstone implements optimizations significant array bounds checking optimization global common subexpression elimination loop invariant optimizations 
interesting lesson emerged touchstone project optimizations complicate certification aspect compilation 
interesting optimization array bounds checking optimization discussed 
array bounds checking optimization required touchstone opposed traditional compiler type safe semantics source language mandates bounds checks compile time run time 
purpose optimization perform checks statically order reduce run time overhead 
get intuition touchstone succeeds certify code bounds checks optimized consider agent 
touchstone translates agent intermediate form shown 
register rt store temporarily value array cell 
just traditional compiler touchstone starts inserting code perform bounds checking array operations 
ri rr rb inv ri ri int rr bool ri rl goto lend ri goto ri rl goto rt ra ri rr rr rt goto lend return rr raise subscript intermediate form agent 
boxed fragments introduced compiler perform array bounds checking 
note loop invariant shown extends typing loop invariant discussed conjunct saying variable non negative 

basic proof carrying code protocol correct invariant initialized loop incremented loop iteration 
see moment significance invariant array bounds checking elimination consider touchstone discovers 
possible arithmetic invariants touchstone attempts discover integer variable monotonically increasing decreasing 
example monotonically increasing prove simple arithmetic facts touchstone uses decision procedure linear arithmetic 
rest simple monotonically increasing variable initial value touchstone emits invariant 
returning intermediate code array bounds checking optimization implemented general conditional optimization tries eliminate conditionals collapse conditionals fewer ones 
case example touchstone successfully eliminates boxed conditionals guarding boolean expressions statically proved false expression ri falsified loop invariant expression ri rl falsified loop termination condition 
consequently exception raising operation code unreachable eliminated 
resulting optimized code shown 
ri rr rb inv ri ri int rr bool ri rl goto lend rt ra ri rr rr rt goto lend return rr agent code bounds checking optimization 
touchstone differs compilers outputs invariants claim optimizing compilers purpose discovering invariants 
take example typing invariants 
typing information known compiler front touchstone preserve front compiler way code generation phase 
true invariant annotations 
optimizing compiler removes array bounds checks loop body employs static analysis discover code properties amount loop invariants 
top touchstone records invariants emits code 
touchstone compiler described dissertation handle correctly arithmetic overflow 
quite easy arrange logic inference rules correct handling arithmetic overflow plug safety hole pcc infrastructure significantly difficult modify certifying compiler theorem prover correct inference rules 
chapter 
overview continue journey example agent proof carrying code protocol want couple interesting aspects certifying compilation 
worth time point think implications certifying compiler design pcc front 
note code receiver trust certifying compiler means verify emitted code desired properties type safety case 
note correct compiler necessarily emit code desired properties 
immediately suggests possible test partially correctness certifying compiler attaching pcc infrastructure verifying proof compilation result 
procedure verify complete correctness compiler emits code certain properties type safety 
practice compiler bugs sooner result target code crashes 
exactly class unsafe target programs pcc infrastructure catches 
requiring compiler tester run target programs input data sets hoping exhibit bug 
development touchstone numerous bugs reported way 
guaranteed reveal bugs surprising traditional testing discovered bug compiler 
suggests certifying compiler technique useful compiler development strategy independent mobile code interaction pcc interest 
second certifying compiler ways produce proof carrying code 
point view pcc infrastructure matter code producer generates annotations 
thing matters code annotated properly 
fact write code hand interactive tools 
important aspect opens proof carrying code technology safety properties fully automatic ways creating annotations 
shall say important property proof carrying code section 
having discussed techniques generating annotations return sequence steps basic pcc protocol 
code producer generates annotated code certifying compiler means sends code code receiver requesting executed 
action initiates step proof carrying code protocol 
step generating verification condition receiving annotated code code receiver performs fast detailed automatic inspection code 
accomplished program called generator vcgen component receiver defined safety policy 
purpose vcgen twofold perform simple syntactic checks agent code 
basic proof carrying code protocol emit verification condition predicate agent instructions violate safety policy 
complete discussion verification condition generator see section 
syntactic checks vcgen performs depend particular safety policy 
example syntactic property commonly checked directly vcgen branch targets code boundary functions allowed code receiver invoked 
addition vcgen enforce restrictions set instructions operations occur agent code 
cases safety policy designer elects restrict syntax language desired safety properties enforced syntactically 
example vcgen enforce termination safety policy disallows function calls backward branches 
approach simple extended expressiveness language 
reason safety policies allow potentially dangerous actions impose restrictions 
example safety policy admit memory read operations provided target address lies boundaries properly allocated array 
compare syntactically checkable memory safety policy disallows memory read operations entirely 
specific conditions action considered safe expressed predicate selected logic called action precondition 
practice action preconditions denote properties difficult impossible verify directly 
vcgen attempt verify action preconditions 
collects combines control flow information specification part safety policy create verification condition entire agent code 
vcgen constituent part safety policy designed conjunction components logic specification 
ultimate criterion guide design process preserve validity soundness theorem stated informally theorem soundness safety policy informal statement verification condition corresponding agent specification provable logic agent execution violate safety policy equivalently action preconditions met execution 
implementation detail vcgen ought discussed imposes serious restrictions components pcc system 
order detect potentially hazardous instructions agent code construct meaningful verification conditions vcgen understand semantics agent code considerable detail 
simplify task vcgen consequently simplify vcgen adopt general design rule information behavior agent difficult discover code producer provide form code annotations 
chapter 
overview prevent erroneous annotations mislead verification process vcgen take special care 
important class annotations loop invariants 
invariant predicate code producer claims hold time execution reaches point code 
constraint vcgen imposes code loop loop invariant associated 
constraint vcgen simplified considerably having perform expensive program analysis programs loops 
obligation vcgen dealing invariant annotations verify invariant correct 
vcgen verify invariance emits part verification condition predicate stating invariant hold start loop predicate states preservation invariant property arbitrary iteration 
second required class annotations preconditions postconditions functions defined internally agent 
fact specification required function external ones provided safety policy 
illustrate operation vcgen consider agent code shown specification 
verification condition code specification closed predicate shown 
note line occurrence function precondition line statement loop invariant holds initially ri value rr set initial value rb 
lines statement loop invariant preserved iteration loop 
note line invariant loop line looping condition followed invariant loop new values ri rr 
far verification condition concerned verifying invariance claimed invariant 
line see unique example instance action precondition potentially dangerous operation memory read address ra ri 
note vcgen isolation enforce particular memory safety policy just marks memory read target address means saferd predicate 
logic define meaning predicate memory safety 
way vcgen variety memory safety policies just changing logic 
part verification condition enforces postcondition line event loop terminates 
initiate step pcc protocol code receiver sends verification condition predicate proof producer waits proof returned 
proof exists logic soundness theorem vcgen ensures agent safe run 
step proving verification condition receiving verification condition proof producer attempts prove logic administrator code receiver specifies part safety policy 

basic proof carrying code protocol ra rb rl rb bool ra array bool rl int rb bool ri rr 
ri ri int rr bool ri rl ri int rr sel ra ri bool saferd ra ri ri rl rr bool verification condition agent 
scope universal quantification implication operators extends predicate closing parenthesis 
code receiver trust proof producer system proof producer particular code producer act proof producer 
part proof generator general purpose theorem prover order predicate logic extended special purpose axioms 
ri rr bool rr bool rr sel ra ri bool ra array bool rl ri rr bool sizeof bool ri ri rl sel ra ri bool fragment proof verification condition 
typographic reasons subproof shown separately 
proof assumptions ra array bool rl line referred ri rr bool line referred ri rl line referred 
order logic theorem proving systems implemented able prove typical verification conditions help additional tactics 
usable pcc proof producer theorem prover able prove verification conditions capable generating detailed proofs 
furthermore proofs expressed axioms inference rules specified part safety policy 
major difficulty theorem prover output proof convenient format proof details generally chapter 
overview easy transform format expected proof checker code receiver 
theorem prover described chapter dissertation follows modular design suggested nelson oppen 
theorem prover uses decision procedures notable ones simplex deciding linear inequalities congruence closure deciding equalities 
addition theorem prover easily customized particular safety policy extending special purpose axioms 
possible general guarantee theorem prover prove verification condition arbitrary safe agent 
possible achieve automatic proving verification conditions certifying compiler 
consider example output touchstone certifying compiler absence optimizations 
target code case sequence code patterns corresponding directly source level construct 
type checking algorithm source level ensure agent type safe memory safe easily modified able prove properties result compilation 
modified type checking algorithm fact required theorem prover 
consider realistic case output optimized 
case finite number code transformation patterns compiler perform 
need theorem prover able discover transformation pattern step 
fact theorem prover need powerful compiler large amount information compiler discovers complex static analyses communicated prover part loop invariants 
returning example verification condition consider proof proceed axioms logic 
fragment proof shown proof predicate rr sel ra ri bool occurs line verification condition 
proof attempted assumptions available ra array bool rl line referred ri rr bool line referred ri rl line referred 
proof fragment uses rule bitwise rule typing array element 
proof memory safety verification condition line proceeds similar manner 
details theorem prover discovers rules order chapter 
theorem prover complicated system involving complex interactions decision procedures complex 
essential theorem prover included trusted infrastructure assurance argument pcc weakened considerably 
fact theorem prover system hosts need trusted easily verify resulting proof simple proof checker described section 
immediately suggests simple method test theorem prover successful run verify emitted proof proof checker proof checking failure signals soundness error theorem prover 
practical experience shows testing procedure extremely 
basic proof carrying code protocol effective discovering subtle bugs having small run time cost 
procedure guarantee latent theorem prover bugs 
guarantees find soon manifest 
proof checker testing soundness theorem provers help discover completeness errors 
completeness error theorem prover fails prove predicate design prover decision procedures provable 
completeness bugs difficult spot soundness bugs difficult distinguish instances decision procedures incomplete 
fortunately theorem prover conjunction certifying compiler vcgen discover completeness errors 
recall certifying compiler type safe language supposed produce type safe target code loop invariants lead guaranteed provable verification conditions 
theorem prover prove verification condition facing compiler bug manifested unsafe target code prover incompleteness bug 
effect ensemble certifying compiler vcgen provides method automatically producing large predicates guaranteed provable 
fashion discovered subtle errors individual decision procedures interaction errors extremely difficult spot 
major software engineering advantages designing theorem prover emit easily checkable proofs design complex traditionally experience suggests theorem provers certifying independent proof carrying code 
step verifying proof step pcc session proof validation step performed code receiver verify correctness proof returned proof producer 
phase performed proof checker verifies inference step proof valid instance axioms inference rules specified part logic 
addition proof checker verifies proof proves verification condition generated step predicate 
far ignored details actual representation verification conditions proofs produced sent back forth 
ignore aspect longer algorithm proof checking depends intimately method representing predicates proofs 
section describe basic principles proof representation validation defer complete formalism implementation details chapter 
technique representing validating proofs desirable attributes chapter 
overview representation proofs proof checking algorithm logic independent implementation reused multiple applications code 
details proof checking necessarily depend particular logic isolated high level logic description file 
property leads increased level confidence pcc infrastructure 
proof checking algorithm simple trusted easily 
proof checking relatively fast cost amortized quickly 
proofs predicates represented compact form order minimize cost communication code receiver proof producer 
fortunately desiderata attained techniques developed part basic type theory research 
edinburgh logical framework referred lf introduced harper honsell plotkin hhp metalanguage high level specification logics 
lf provides natural support management binding operators hypothetical schematic judgments lf bound variables 
crucial factor succinct formalization proofs 
purposes section view lf typed calculus variables constants applications abstractions 
represent predicates lf declare set lf constants standing predicate constructors 
proofs represented similarly set constants standing axioms inference rules logic 
ensemble constants denoting predicate constructors inference rules called lf signature constitutes concrete encoding logic lf 
fragment lf signature defines order predicate logic extended rules shown 
top section contains declarations type constructors exp tp pred corresponding respectively expressions types predicates type family pf indexed predicates 
middle section declarations syntactic constructors 
example lf constant true declared type pred meaning nullary predicate constructor constant array declared binary type constructor arguments type representing type elements expression representing length respectively 
bottom section declarations inference rules proof constructors 
understand declarations note representation predicate pf lf type valid proofs example constructor truei representation axiom stating truth predicate true 
line declaration corresponding conjunction rule create proof conjunction proofs conjuncts 
ignore binding operators see andi proof constructor applied 
basic proof carrying code protocol exp type tp type pred type pf pred type true pred pred pred pred imp pred pred pred int tp array tp exp tp exp tp pred saferd exp exp pred truei pf true andi pred pred pf pf pf andel pred pred pf pf pf sizeof bool exp exp exp exp tp 
pf array pf sizeof pf pf pf sel plus fragment lf signature corresponding logic 
proof predicate proof obtain lf expression represents valid proof 
similarly declaration shown encodes inference rule shown 
illustrate lf encoding proofs consider subproof 
lf encoding fragment shown 
ignore boxed components lf representation straightforward expression proof tree structure inference rule assumption hypothesis followed axiom conjunction elimination left rule applied assumption assumption furthermore declarations appropriate types assumptions type pf array bool type pf bool type pf verify term type pf sel plus bool 
far considered proof representation problem isolation proof chapter 
overview bool andel bool lf representation proof fragment 
boxed parts redundant explained text 
tion problem 
suggested representation example discussed lf type system check proof validity 
specifically lf expression type pf predicate representation valid proof proof exists meaning valid predicate 
precisely order code receiver satisfied verification condition provable logic receive proof producer lf expression checked type pf vc vc lf representation verification condition 
formal statements adequacy lf type checking proof checking proved hhp chapter 
show precise definition lf type system lf typechecking algorithm simplicity lf language type checking algorithm simple easily turned simple trustworthy proof checkers 
furthermore lf type checking algorithm independent particular signature independent particular logic 
dependency logic lf signature straightforward encoding axioms inference rules 
lf attains desirable properties listed section 
missing property compactness proof representations 
lf representation proofs compact large amount redundancy representation 
main forms redundant terms occur lf representation proof 
terms recovered proved predicate 
called inherited terms 
terms recovered context occur proof 
called synthesized terms 
illustrate informally redundancy lf representation consider lf proof type pf sel plus bool 
type considering declared type top level constant inherit second third fifth arguments 
fourth argument synthesized type 
argument andel inherited type entire application andel second argument synthesized type 
natural try avoid representing redundant subterms proofs 
chapter show done systematic manner extending lf framework deal missing subterms inherited synthesized suitably modified type checking algorithm 
resulting framework called implicit lf lfi 
illustrate effect representing proofs implicitly show lfi 
variants proof carrying code di andel lfi representation proof fragment 
boxed components redundant 
version representation 
note representation contains entire structure proof tree 
practice effects implicit representation drastic suggested simple example 
experimental measurements show size implicit representations proofs approximately equal square root size lf representation benefits lfi larger proofs larger 
furthermore similar benefits observed time required proof checking synthesized inherited subterms require type checking 
larger experiments pcc implicit representation difference completely impractical proofs tens megabytes manageable proofs tens kilobytes 
solving proof compactness problem level lf am able obtain general logic independent solution prove formally adequacy lfi type checking algorithm proof reconstruction checking 
concludes overview basic proof carrying code protocol shown 
rest dissertation concerned formal implementation details components steps described overview 
worth considering variations basic pcc protocol 
variants proof carrying code step process described section canonical view proof carrying code 
approach pcc possible 
redistributing tasks entities involved adapt pcc special practical circumstances maintaining safety guarantees 
example variant pcc code producer runs vcgen submits resulting predicate proof producer directly 
code proof sent code receiver runs vcgen verifies incoming proof proves right verification condition 
arrangement possible secret vcgen untrusted code producers 
retain safety guarantees original pcc necessary code receiver repeats vcgen step order produce trustworthy verification condition 
version saves communication step generating safety predicate preferred interactive version latency verification minimized 
chapter 
overview variant pcc code receiver proof generation 
possible case verification condition relatively easy prove automatically extra knowledge program 
variant pcc useful situations generated proof large send communication channel proof producer code receiver 
receiver variant pcc safety critical infrastructure consisting vcgen proof checker remains 
tempted save cost generating storing verifying proof altogether trusting theorem prover receiver side 
savings expense greatly increasing size complexity safety critical infrastructure practical experience suggests relying soundness complex theorem prover dangerous game 
scheme employing pcc variants establish safety code firewall machine forward code actual receiver enclave possible accompanied digital signature 
note case proof checker fallible human agent signs code 
matter variants chosen share characteristic requiring supporting information addition code possible rely small defined safety critical infrastructure simple proof checker vcgen 
benefits costs proof carrying code proof carrying code key characteristics combination give advantage previous approaches safe execution foreign untrusted code 
addition costs associated pcc 
state advantages costs front provide logical completion overview chapter supporting data examples dissertation 
proof carrying code advantages claimed 
pcc general 
pcc enforce memory safety type safety 
extreme pcc verify code property exists logic capable expressing 
includes code properties undecidable infer code 
pcc tested safety properties ranging memory type safety bounded resource usage 

pcc receiver infrastructure low risk automatic 
proof checking process code receiver determine agent safety completely automatic implemented program relatively simple easy trust 
safety critical infrastructure code receiver rely reduced minimum 

benefits costs proof carrying code 
pcc efficient 
practice proof checking process runs quickly 
furthermore contrast previous approaches code receiver modify code order insert costly run time safety checks receiver perform checking interpretation proof validated code installed 

pcc require trust relationships 
code receiver need trust code producer proof producer 
words receiver know identity producer know process agent code produced 
information needed determining safety code included annotated agent code proof 

pcc flexible 
proof checker require agents programmed particular programming language 
pcc wide range languages machine languages appropriate adaptation vcgen component 
furthermore code receiver support multiple agent languages safety policies minimal duplication infrastructure components 

pcc generation automated special cases 
safety properties decided statically enforced systematic run time checks certifying compiler matching theorem prover producer side automate process producing annotations proofs 
safety policy defined pcc involves stage interaction process 
stage code receiver inspects agent code replies challenge predicate provable code safe execute 
second stage code receiver checks validity proof simple fast proof checker 
proof valid proof verification condition untrusted code installed executed 
stage verification process key design element contributing advantages claimed 
particular reason pcc certify code properties difficult impossible infer code directly 
staging verification difficult phase proof generation simple phase proof checking am able minimize complexity safety critical infrastructure 
greatly reduces risk bug system lead failure detect unsafe programs 
fact design goal pcc task result easily checked generated performed untrusted entity code producer proof producer checked code receiver 
addition pcc benefits untrusted code execution prototype pcc system built demonstrates ideas pcc software engineering advantages building robust theorem provers compilers 
soundness theorem prover trusted prover emit proofs easily checked 
chapter 
overview similarly correctness compiler trusted completely compiler annotate code simple vcgen conjunction theorem prover verify key properties result compilation 
combination certifying compiler theorem prover discover unintended incompleteness theorem prover 
advantages adapting theorem prover compiler fit pcc framework difficult compilers theorem provers ought certifying 
benefits pcc certifying compilation discussed section come free 
costs pcc active client server interaction 
pcc cooperative process code producer involved establishing safety agent code contrast approaches safety enforcement completely transparent code producer 
poses difficulty deploying pcc potentially numerous code producers need pcc aware code receivers 
addition wide deployment pcc requires establishing standard logic set axioms libraries logics axioms 

proof carrying code prescribes precise method code producers cooperate code receivers assist verification agent properties 
defined method producers cooperate receivers purpose establishing mutually convenient safety policy 

difficult problem producer side generation code annotations 
difficult safety properties complicated agent code heavily optimized 
certifying compiler automatically certain classes safety properties 
certifying compiler approach fails interactive program verification techniques 

proving verification conditions difficult task 
theorem prover part current pcc system powerful complete 
modular new decision procedures easily added difficult cases prover guided user 
theorem proving automated code annotations compiler generated extending prover handle finite number patterns verification conditions possible 
automation achieved touchstone certifying compiler 
costs enumerated important fortunately incurred code producers 
comparing list benefits list costs apparent intentional design strategy pcc burden safety lie producer receiver code 
enables pcc small easy trust 
frequently asked questions automatic infrastructure difficult done code producer better position understand agent code interactive tools purpose 
final difficulty pcc establishing safety policy 
cost belong list cost incurred method enforcing safety untrusted code 
special case pcc safety policy expressed concrete manner exported producers 
contrast approaches safety policy implicit implementation large interpreter compiler system call interface 
fact pcc requires safety policy expressed precise concise manner easier designer avoid errors prove formally correctness safety policy 
conclude section note relative balance advantages limitations proof carrying code demonstrate promising way deal safety untrusted code having pay costs high run time overhead complex trusted computing base 
section continue discussion advantages limitations proof carrying code general implementation particular 
frequently asked questions purpose chapter give high level overview techniques code certifying compilation 
details necessarily deferred main body dissertation 
experience public presentations material shows superficial level detail quite difficult grasp fundamental characteristics limitations proposed techniques 
matters complicated running example presentation concrete easy follow 
example mislead reader blurring distinction fundamental capabilities proof carrying code certifying compilation limitations implementation 
section attempt address misunderstandings answering common questions arose various presentations material 
main body overview chapter focuses proposed techniques section just past audiences focuses techniques implementation 
section interest users trying understand thesis solves problems researchers extend 
relationship proof carrying code certifying compilation 
proof carrying code concerned verifying fragment code meets safety specification 
purpose proof carrying code requires code annotations proof safety constructed precise rules 
proof carrying code general sense safety property exists formalism distinguishing chapter 
overview safe programs unsafe ones 
furthermore proof carrying code indifferent code annotations proofs generated 
certifying compilation particular way producing code annotations proofs required proof carrying code restricted class safety properties type safety 
compensate lack generality certifying compilation completely automatic provided agents written specified source language 
pcc manage verify statically undecidable code properties 
true interesting safety properties decision procedure 
distinctive advantage proof carrying code undecidability requiring proof code desired property 
reduces problem proof checking decidable relatively simple logics 
course moves burden deciding property holds code producer 
appropriate code receiver prepared handle agents produced various means safe different reasons code producer usually specific information agents safe 
touchstone notable example code producer 
verification condition generation required component proof carrying code 
proof carrying code implemented verification condition generator 
consider example situation agent code written typed language safety property verified typedness code annotations variable declarations proof typing derivation 
pcc infrastructure case type checker 
general pcc infrastructure contain parser proof checker 
case type checker functionalities blended 
advantage verification condition generator separates functionalities resulting increased portability flexibility 
verification condition generator parses code performs syntax checking 
relevant information code encapsulated predicate architecture independent logic 
predicate processed standard tools theorem provers proof checkers 
situations verification condition generator limits enforceable safety properties shall see 
isn possible malicious code producer pack trivially valid proof unsafe agent code 
proof checked valid correspond actual agent code 
done indirectly verifying proof proves particular verification condition obtained agent code 
happens code proof components pcc binary modified transit code producer code receiver 
possible scenarios 
code modified verification 
frequently asked questions condition change proof code accepted 
section shows common optimizations transform code exactly manner 
second proof unchanged code modified verification condition changes proof checker rejects code independently safe 
code proof modified new proof valid proof verification condition extracted new code pcc infrastructure accepts code independently functionality originally programmed code producer 
note case code safe proof safety 
pcc guaranteed enforce safety authenticity 
certifying compiler technique generate proofs safety properties type safety 
crucial detail automatic certifying compilation possible code properties proved target programs statically checkable source programs 
certifying compilation applied code property exists conservative decision procedure suitably restricted source language 
language restrictions necessary avoid inherent undecidability interesting properties programs written restrictions 
example want certifying compiler emit proofs termination restrict language disallow general looping recursion 
allow structural recursion iteration proved statically correspond founded induction 
source level constructs programming language touchstone handle 
touchstone support constructs generate unchecked run time errors 
pointer arithmetic address operator arbitrary casts union types stack allocated arrays memory deallocation 
restrictions limits drastically utility language 
example pointer arithmetic replaced array index arithmetic uses address operator unnecessary language supports call memory deallocation replaced garbage collection 
addition unsafe features implementation described dissertation support floating point function pointers supported 
proof carrying code programs dynamic allocation 
touchstone 
proof carrying code touchstone compiler handle dynamic memory allocation 
trick introduce additional element machine state allocation state changed allocation function 
accessibility memory locations saferd safewr predicates changed depend allocation state 
chapter 
overview proof carrying code explicit deallocation garbage collection 
touchstone 
explicit deallocation misused generate dangling pointers reason touchstone compiler support 
touchstone prevent conservative garbage collector 
proof carrying code principle handle explicit deallocation just possible formalize notion safe memory deallocation operation 
formalisms difficult little progress automating proof generation problem 
proof carrying code handle run time stack 
ways run time stack handled 
accesses stack handled arbitrary accesses memory case safety policy specify details dynamic allocation deallocation stack frames 
simplify safety policy reduce size proofs current implementation vcgen views stack frame local addition register file 
possible program create aliases stack locations 
drawback approach complicates trusted infrastructure handle specific programming paradigm 
particular case felt handling stack directly useful large number applications result large reductions size proofs 
proof carrying code handle arithmetic overflow 
touchstone 
proof carrying code handle arithmetic overflow correctly carefully selecting axioms inference rules arithmetic see section example 
drawback decision procedures linear arithmetic anymore modular arithmetic involved handling overflow 
reason implementation touchstone compiler proof generator handle arithmetic overflow 
means implementation compiler theorem prover described leaves loophole open malicious programs generate unchecked memory errors 
proof carrying code handle sum types 
difficulties handling sum types 
example simple sum type pointer option type described section 
touchstone handle union types language handle sum types standard ml tag checking control compiler ensure value sum type correctly 
proof carrying code handle closures objects generally pointers data structures code 
touchstone 
implementation vcgen pcc described dissertation handle class functions 
reason function call site vcgen 
frequently asked questions know precondition postcondition 
current implementation achieved requiring function address function calls literal value 
limitation removed cases actual functions invoked call instruction share common precondition postcondition 
case example higher order typed language specifications contain types 
example category object oriented language dynamic method lookup 
proof carrying code handle run time code generation 
implementation proof carrying code described dissertation handle run time code generation 
vcgen able perform static inspection entire code reachable agent entry point 
order handle dynamically generated code vcgen approach changed drastically abandoned 
proof carrying code handle properties safety properties termination information flow 
proof carrying code handle properties safety properties access entire agent code 
settled vcgen basis pcc infrastructure limited handling safety properties 
means pcc verify certain run time events defined unsafe happen enforce certain events termination happen 
limited practical variant class events handled vcgen code impose deadlines various events 
termination safety property termination number instructions safety property handled proof carrying code infrastructure described thesis 
processors malfunction specified number machine cycles intervene certain instructions 
safety property enforceable code 
safety property 
unsafe event prevented instruction attempted cycles instruction executed 
described dissertation vcgen extended instruction counting enforce kind safety properties 
extension experimented successfully enforcing resource usage bounds bounded termination bounded memory allocation bounded bandwidth agents 
experiment described nl 
proof carrying code handle aliasing 
touchstone 
proof carrying code handle aliasing vcgen captures information required account effects aliasing 
vcgen attempt predict effect memory write 
vcgen just records write symbolic address chapter 
overview proof producer discover locations affected 
aliasing issue touchstone affect type safety 
touchstone care contents memory locations aliased 
cares type contents 
relative size proofs annotations executable code 
depends safety property verified 
type safety experimental results section show proofs times size executable code annotations size code 
experiments complex safety properties bounded resources observed proofs times larger code 
rule thumb safety property complex proof longer 
list questions comprehensive 
find answer question answer imprecise taste just reason read rest dissertation ultimate detail appendices 
part proof carrying code infrastructure part consists chapters discuss technique proof carrying code point view system receives code verifies associated safety proof 
details proofs produced subject part ii 
chapter gives formal requirements safety policy set conditions define particular actions function calls memory reads safely performed agent 
chapter describes generator program produces predicate provable logic program adheres safety policy 
part ends chapter describes proof checker code receiver verify proof object valid proof verification condition 
chapter safety policy schneider sch security policy predicate sets agent executions 
program agent static encoding set possible executions agent 
program said satisfy security policy security policy predicate holds set possible executions program 
important class security policies security properties defined security policies specified means predicate individual executions equivalently imposing constraints individual execution opposed constraints set possible executions 
interesting security policies properties 
example information flow security policy prohibits correlations values state components different secrecy status principals infer things state component considered classified observing values unclassified state components 
obvious information flow property notion correlation involves execution 
look single execution subset possible executions notice correlations exist executions considered 
subclass security properties safety properties stipulate bad thing happens execution lam 
safety properties characterized fact hold execution hold finite prefixes execution 
means safety property fails point failure identifiable possible check safety properties run time sch 
security properties safety properties 
liveness properties stipulate certain things termination release resource happen lam 
fact proven security property expressed combination safety liveness property 
purposes dissertation concentrate security properties furthermore safety properties 
subset security policies covers practical needs 
note omitting liveness serious restriction 
chapter 
safety policy practical applications require thing happens happens quickly 
limiting time thing happen timeouts termination resource release suddenly dealing safety properties 
dealing notion time tricky requires special machinery safety polices discussed dissertation involve timing properties 
demonstrated dissertation proof carrying code fact certify just safety properties 
deal general security properties code receiver access code agent just single execution traces 
concretely assume execution represented sequence state action pairs state mapping registers memory locations values actions events relevant safety policy potentially bad things happen 
pair execution sequence says action attempted value state 
way characterize safety policy setup means action preconditions predicates states 
execution safe state action pair action precondition holds state component pair 
distinguishing feature definition safety examines current state purpose deciding action allowed 
diminish generality definition arrange state contain history information execution implement arbitrary predicate execution prefixes predicate current state 
way extending register set history pseudo register value sequence previous execution states 
set actions am going consider thesis execution individual instructions invocation receiver provided functions termination agent execution 
correspondingly enables safety policy enforce various kinds restrictions follows 
restrictions instructions executed conditions 
part safety policy referred instruction safety 

restrictions runtime functions system calls invoked conditions invoked assumed return 
part safety policy referred system call safety 

restrictions input output behavior agent entry points 
part safety policy customarily referred partial correctness 
syntax language described section effectively restricts kind instructions agent execute 
aspects safety policy introduced part safe interpreter language described section 
distinguishing feature interpreter fails safety policy violated 
note interpreter serves definition safety policy respect pcc infrastructure proved correct 
need implement interpreter 

sal generic assembly language safe agents sal generic assembly language safe agents code receiver able execute agent informed choice agent meets safety policy require agents written specific language 
main advantages proof carrying code applied variety languages ranging high level languages way machine languages 
am focusing thesis applications involving low level languages mainly require smaller execution infrastructure code receiver give code producer freedom optimizing code 
hand describing proof carrying code context concrete machine language certainly specific 
choose introduce generic risc assembly language call sal basis description proof carrying code 
designed sal instructions typical machine languages risc cisc direct simple translations sequences sal instructions 
sal generic sense extended operators model various features target machine 
sal safe sense simple technique enables code receiver ascertain program meets certain safety policy 
proof carrying code infrastructure concretely vcgen defined thesis operating sal programs 
ways infrastructure described dissertation ported specific language 
easy way implement vcgen sal write translators agent language interest sal 
example done describe section translators dec alpha intel assembly languages 
performance vcgen important simplicity integrate translator vcgen effectively obtaining vcgen specific architecture 
syntax sal instructions shown 
sal load store risc architecture register set composed general purpose registers referred ri 
distinguished register ra hold return address current function 
sal machine stack pointer register manipulated dedicated instructions 
number general purpose registers specified depend target architecture 
rest section describe informally purpose sal instruction 
formal semantics sal section 
order preserve generality sal keep set arithmetic conditional operators generic 
consider sal generic binary expression operator eop generic unary conditional operator cop comparisons zero 
note operands kinds operators registers 
conditional branch instruction specifies immediate integer relative offset target instruction case successful comparison 
execution continues instruction comparison fails 
jump instruction relative 
chapter 
safety policy registers ri ra 
instructions move initialize eop arithmetic logical operations jump jump cond cop conditional branch ra pc compute return address call function call func ret function return memory read memory write sp sp advance stack pointer sp stack read sp stack write annotations defined section numerals syntax sal 
function invocation return instructions just typical risc architecture simple control instructions 
return instruction uses contents ra register destination 
call instruction cisc architectures obtain save return address directly 
purpose sal contains dedicated instruction current value program counter 
note definition sal destination call literal computed address 
restriction simplifies considerably pcc infrastructure drawback permit direct implementation higher order languages dynamic method lookup object oriented languages 
shall see section cases relax restrictions 
memory operations sal register index addressing mode 
way able isolate place generic expression operations various computations required implement complicated addressing modes 
addition regular memory operations sal contains distinguished instructions accessing stack case index offset addressing mode supported 
instruction incrementing decrementing stack pointer constant amount 
effectively prevents allocation stack data size known statically 
sal extended annotations purpose communicate extra information program vcgen 
semantically annotations effect 
operational semantics sal machine state execution 
fact practical implementation pcc annotations segregated special segment part code 
examples annotations discussed section definition vcgen 
operational semantics sal previous section defined syntax sal implicitly specified part instruction safety limits kinds instructions agent may execute 
section specify conditions instruction executed completing discussion instruction safety system call safety partial correctness 
introduce safety aspects means sal interpreter intended model typical physical machine fails error safety policy violated 
discuss detail notion execution state sal interpreter 
just typical machine state execution consists value program counter values registers state memory 
universe base values set possible values machine register 
typical machine complement representation bytes 
state memory encoded function finite set addresses values 
simplify presentation am considering addresses represented bytes universe store values purposes recording state execution convenient store state memory value dedicated pseudo register mem 
similarly convenient store state stack pointer part register state 
evaluator records state set registers regs 
rr ra sp mem 
technical reasons having various correctness proofs extend state sal interpreter history register states contains register states moment function invocations 
length history sequence equal depth function invocation chain initial activation agent program code receiver 
state triple values value program counter regs mem state registers call history represented sequence register states 
agent code consists function definitions bodies sequences sal instructions 
functions implemented agent set denoted kinds 
functions exported receiver entry points set denoted functions agent internally purpose implementing functionality entry functions 
set functions denoted addition functions complete execution environment contains code runtime functions system calls provided chapter 
safety policy receiver available agent code 
set external functions system set functions system important distinguish agent provided functions untrusted receiver provided functions trusted safe behavior obey specification 
order preserve generality sal am making assumptions layout instructions agent code memory execute 
assume function bodies loaded disjoint areas code segment 
assumption isomorphism valid instruction addresses pairs consisting function name offset instruction function body 
example notation refers address instruction function sal instruction occupy memory word offsets instruction addresses point valid instruction 
write dom denote instruction address marks valid sal instruction denoted fi body function assume size instruction function instruction write refer address immediately instruction starting note necessarily equal dom 
accommodate relative jumps branches notation denote usual arithmetic operation instruction addresses 
course pages describe detail operation safe interpreter shown time introduce notation concepts arise discussion 
operation interpreter generic state consists decoding current instruction shown column choose resulting state shown second column possibly depending outcome control flow checks shown third column 
interpreter defined columns meant model physical machine 
interpreter formalization safety policy fourth column contains safety checks performed step 
execution safety check fails considered violate safety policy 
implicitly interpreter defines safety policy 
register move initialization literal jump instruction annotations safety restrictions 
instruction safety component safety policy generic expression operator eop described predicate defined intuitively predicate holds safety policy allows execution eop state values registers respectively 
similar manner describe instruction safety conditional branches memory operations 
notation denotes state obtained setting value register current state 
notation eop denotes function implemented machine expression operator mnemonic eop 

operational semantics sal fi control flow test safety requirement eop eop jump cond cop cop cond cop cop mem saferd mem mem mem safewr mem sp sp sp sp stack sp sp mem sp stack sp sp mem mem sp stack sp ra pc ra dom call stack sp max call stack sp max ret ra operational semantics sal giving state obtained case dom 
certain instructions resulting state depends outcome control flow tests shown third column definition interpreter performs 
instructions separate lines definition interpreter case tests succeeds case fails 
obvious case conditional behavior conditional branch instruction 
case interpreter tests current value tested register unary relation cop relation target architecture implements conditional operator mnemonic cop 
memory read operation instruction safety described relation saferd mem 
note form relation allows readability property memory location change memory contents changed 
similarly memory writes safety policy restrict set values written various memory addresses various memory states defining appropriately ternary relation safewr 
notation denotes memory state obtained writing address normally runtime stack programming language implementations modeled portion memory special additions sal language 
chapter 
safety policy xf arg sp max stack frame sal function moment invocation addresses sp 
sp arg contain function arguments 
frame extended lower addresses max local arguments 
previous experience pcc shows approach feasible unnecessarily costly 
reason cases stack accesses follow predictable pattern making possible verify safety heavyweight machinery designed arbitrary memory operations 
benefit known stack access patterns interpreter imposes restrictions sal programs stack 
dedicated memory operations accessing stack 
stack pointer changed dedicated increment instruction 
interpreter imposes stack usage discipline restricting function access stack limited area called current invocation stack frame shown 
function arg number arguments expects stack 
stack frame invocation spans addresses sp max 
sp arg max maximum number stack locations function allowed excess arguments 
requirement stack grows lower addresses 
safety policy extended correspondingly unary relation stack holds addresses reserved receiver runtime stack 
maximize benefit having preferential treatment stack need prevent aliasing regular memory accesses stack accesses 
sal adequate safety policy need stack aliasing condition property holds 
condition attained practice setting disjoint stack data segments 
furthermore code data stack segments disjoint 
stack saferd safewr implies run time code generation implementable sal verifiable variant proof carrying code described 

operational semantics sal space stack allocated usually entering function local declaration block decrementing stack pointer 
safety condition stack pointer advance instruction resulting value stack pointer valid stack address 
check exists simplify formal proofs chapter 
particular successful outcome check means danger overflow performing addition 
possible agent attempts stack space allocated safety policy means stack relation 
prevent stack overflow instruction safety instructions involving stack prescribes address involved part stack predicate 
remaining instructions function call return instructions return address computation instruction 
simplest noting safety requires resulting address current function body 
check exists technical reasons 
complications function call instruction 
system call safety part safety policy enforced 
function call defined unexpected conditional behavior 
motivation behavior technical having modeling stack overflow exception 
anticipating difficulty proving statically lack stack overflow designed sal interpreter performs stack overflow check function invocation 
check verifies stack pointer decreased max overflowing stack 
successful outcome check guarantees entire stack frame function needs max stack slots addition arguments fits stack segment 
true require stack allocated continuous area memory stack stack stack interesting question stack overflow check fails 
technically situation constitutes exception treated non local transfer control exception handler 
simplify formal correctness proofs model exception non termination 
intuition safety policy considers stack overflow exception safe outcome program partial correctness aspect important 
consider safety properties liveness properties treat benign exceptions stack overflow infinite looping defined semantics call instruction 
system call safety partial correctness safety aspects safety policy similar sense constrain state execution function invocation boundaries 
cases dealt uniform way means function preconditions postconditions sets preserved registers 
precondition function chapter 
safety policy predicate pref state memory registers specifying may assumed execution starts 
system call precondition established agent code prior call 
agent entry point precondition assumed established receiver prior invoking agent 
sense precondition establishes calling convention function 
postcondition function predicate post state memory registers denoting may assumed execution ends 
system call postcondition may assumed established code receiver prior resuming execution agent 
agent entry point postcondition established agent code prior returning 
callee save register set set registers cs function preserve 
function preserve stack pointer register sp need appear callee save set preservation enforced sal interpreter 
ra register complete control interpreter require ra cs performing function return interpreter verify postcondition holds registers declared callee save preserved contents stack changed outside frame 
convenient denote checks collectively relation initial final states defined iff post cs sp sp stack sp arg mem mem state current function invocation started state time return 
note invocation history component state changed call return instructions 
case call current register state added history 
case return instruction interpreter verifies current call history empty removes top element history 
note execution annotation change state execution program counter 
purpose sal interpreter chapter twofold 
serves semantics sal language indirectly guide mapping concrete machine languages sal 
interpreter constitutes formalization safety policy 
interpreter set way progress state 
operational semantics sal point valid instruction satisfy safety requirements mandated safety policy 
write say interpreter executes step state resulting new state implicitly say violation safety policy state 
notation state formally means sal program match safety policy follows definition safety policy function safe written safe initial register state history pref stack holds addresses sp max sp arg state reachable sal interpreter initial state 
case ra 
case exists interpreter progress equivalently safety violation 
notation denote size call history 
note safety definition termination invocation denoted size history decreasing 
happens history increased temporarily current function invokes functions 
safe interpreter defined terms generic assembly language sal practice agents expressed concrete languages 
section describe general strategy adapting safety policy particular assembly language demonstrate strategy dec alpha intel assembly languages 
section discuss role safe interpreter defined proof carrying code scheme show fits rest infrastructure 
chapter 
safety policy porting proof carrying code concrete architectures section describe briefly general strategy porting safety policy pcc infrastructure concrete architecture 
accomplished designing translator machine instructions target architecture variant sal 
generic sal language discussed chapter instantiated needed particular architecture 
choosing appropriate set sal registers 
usually target machine registers extended sal temporary registers 

choosing instantiations generic expression operators eop conditional operators cop 
cases concrete operators need different arities generic sal 
added expression operator specify mathematical functions implemented target machine eop cop functions instruction safety conditions relations 

defining size instructions function 
rest chapter show outlined strategy applied concrete cases risc architecture dec alpha cisc architecture intel 
porting dec alpha architecture dec alpha architecture sit load store bit risc architecture 
dec alpha sal risc architectures translation particularly easy 
instantiation sal general purpose registers mapped dec alpha registers 
addition mapped sal register ra register stack pointer register sp temporary registers compute temporary results translation 
bit instance sal base universe 
shows translation sal small practical bit subset dec alpha instruction set 
added expression conditional operators mathematical functions implemented dec alpha 
addq mod subq mod eq ge 
porting proof carrying code concrete architectures dec alpha sal lda zero mov addq addq subq subq jmp jump beq cond eq cond ge jsr ra ra pc call jsr zero ra ret ldq addq stq addq lda sp sp sp sp ldq sp sp stq sp sp translation table dec alpha architecture 
agent entry points obey standard dec alpha calling convention preserve registers 
return address register 
condition ra cs dec alpha architecture requires memory accesses aligned bit boundary 
correct safety policy require alignment conditions saferd mod safewr mod stack mod chapter 
safety policy porting intel architecture intel architecture int cisc architecture translator sal complex 
issues dealt translating programs sal 
instructions complex definitions map sequences sal instructions 
example architecture addressing modes require separate sal code computing operands 

architecture allows instructions access fragments register 
register aliasing modeled special expression operands 

architecture uses segmented memory model addresses specified pair segment descriptor offset segment 

architecture condition flags set implicitly arithmetic instructions 
model behavior need extend sal arithmetic instructions having multiple results 

instructions architecture length definition function trivial 
rest section describe sample solutions issues 
focus simplicity efficiency 
solutions propose implemented efficiently expense complexity translator vcgen 
sal register set architecture contains return address register standard registers eax ebx ecx edx esi edi ebp ds es fs gs 
addition contains number temporary registers denoted ti 
esp register architecture part sal registers uses involving translated instructions manipulating sal stack pointer 
condition flags sal register contains zero 
simplicity consider zero flag zf sign flag sf overflow flag set result arithmetic operation respectively zero negative resulted overflow 
calling convention architecture requires segment registers base pointer preserved function calls 
ra ebp ds es fs gs cs architecture memory segmented memory address expressed pair segment selector offset 
segment selector reside segment registers 
consequently change syntax memory operation sal allow 
porting proof carrying code concrete architectures intel sal sub eax ebx eax eax sub ebx zf eax sub zf ebx sf eax sub sf ebx eax sub ebx mov eax eax mov eax ebx eax ebx mov eax ds ebx eax ds ebx mov ds ebx eax ds ebx eax mov eax ss esp ss sp mov ss esp eax ss sp je cond eq zf cond ge sf jmp jump call ra pc sp sp ss sp ra call ret ra ss sp sp sp ret add esp sp sp zf sp add zf sf sp add sf sp add push eax sp sp ss sp eax pop eax eax ss sp sp sp translation table intel 
composite address 
ds eax refers memory address offset eax segment selector ds 
similarly saferd safewr stack relations extended extra segment argument 
additional restriction stack addresses aligned bit boundary stack mod fragment translation table intel architecture shown 
translation subtraction function contains code set flag registers chapter 
safety policy implicitly affected instruction 
purpose introduce operator sub denotes main result subtraction operators sub zf sub sf sub denote side effects subtraction flag registers 
architecture conditional jump operations examine flag registers 
purpose jump greater equal instruction introduce binary conditional operators 
particular interest translation function call stack manipulation functions 
case function call return address computed point immediately sal call instruction saved top stack 
stack advanced bytes size stack element bits 
return function extracts return address top stack pops stack specified number arguments 
adding constant stack pointer translated sal stack pointer advance instruction followed instructions meant model potential effects addition flag registers 
disciplined programs resulting values flags need instructions prevent malicious programs assumptions contents flags 
push pop instructions access stack side effects stack pointer flag registers 
architecture instruction variants depending operands identified 
shows simplest variant instruction operand bit register 
architecture allows certain instructions access bit bit fragments registers names shown 
addition instructions allow operands reside memory 
operand addressing mode standard sequence sal instructions obtains operand register sequences instructions shown 
definitions assume operand source computation 
destination memory reads changed memory writes get extraction operators changed set updating operators 
example denote updating register ax bit bit ah ax eax bh bl bx ebx ch cl cx ecx dh dl dx edx bp ebp si esi di edi register aliasing intel architecture 

porting proof carrying code concrete architectures addressing mode example sal translation register eax eax register ax getx eax register eax register ah eax immediate index ds ebx ds ebx index displacement es ebx add ebx es base index ds ebx esi ebx add esi ds base index displacement ds ebx esi ebx add esi add ds addressing modes intel architecture shown sequence sal instructions required compute operand temporary register translation schemes assume operand source computation 
add mod sub mod sub zf mod sub sf mod sub mod eq iff ge sf iff sf getx mod mod div mod setx mod mod setl mod mod seth div mod mod definitions sal operators introduced translation sal 
definitions range functions division modular operations usual meanings integers 
chapter 
safety policy contents register write eax setx eax 
model extraction updating register fragments introduce set unary binary operators 
mathematical definitions operators operators introduced shown 
discussion safety policy viewed consisting set conditions restricting actions agent perform 
examples actions restricted function calls returns executions certain instructions memory referencing instructions 
safety policy formalized defining interpreter executes agent code checks required conditions met relevant action executed 
section defines just interpreter generic assembly language section show definition adapted deal real assembly languages 
examine carefully definition interpreter shown notice serve main purpose provide realistic execution model generic machine language 
reason safety checks practical implement 
take example relation safewr finite cardinality cardinality relation high note memory accessibility change state memory data accessible agent arranged contiguous areas memory feasible implement memory safety checks simple range checks 
stack checks implementable way stack contiguous area memory 
ignore checks related expression operators system call safety partial correctness quite feasible implement safe sal interpreter restricted safety policy 
fact exactly technique called software fault isolation sfi 
general feasible practical implement safety checks 
useful static checking verify safety checks necessary performed run time program 
succeed verify statically execution agent safety checks succeed run agent simplified sal machine implement checks shown column 
examine columns definition sal machine notice call history component state eliminated 
remains description realistic machine similar behavior physical machines 
proof carrying code quite code receiver static analysis exception stack overflow check required call instruction 
physical machines check performed hardware memory protection unit set max smaller virtual memory page 

discussion able prove static checks redundant 
necessarily conservative sense fails perfectly safe programs 
purpose proofs proof carrying code allow code producer arbitrarily powerful precise static analyses prove safety code communicate result analyses convincing way receiver 
code receiver fix static analysis way results communicated code producer shown chapters 
chapter enforcing safety proof carrying code proof carrying code enables code receiver verify statically agent code satisfies security policy having perform complex static analyses 
code producer performs static analysis proves code safe 
proof sent code receiver evidence code safe 
key decision concrete implementation proof carrying code kind proofs required ascertain security policy met 
depends course security policy 
want ensure undesired information flow probably reduce problem type checking problem hr ml vs proof typing derivation agent program appropriate type system 
variant proof carrying code described thesis security policy safety component expressed means series safety checks fictitious interpreter sal perform 
proofs accompanying code instance pcc guarantee sal translation agent executed safe sal interpreter section fail safety checks 
existence proof guarantees agent executed just safely performing safety checks 
purpose verifying safety checks sal interpreter satisfied agent introduce evaluator sal purpose execute sal program symbolically collect symbolic representation safety checks performed 
resulting collection called verification condition kind interpreter verification condition generator vcgen kin 
language safety checks expressed verification condition predicate logic proofs accompanying code derivations logic 
previous experience pcc suggests starting choice logic extension order predicate logic equality array variables 
setup verification condition formula predicate logic 
chapter 
enforcing safety proof carrying code agent safety policy program validity vc verification condition generator vcgen verification condition vc safe unsafe provability vc relationship safety policy verification condition generator validity verification conditions provability verification conditions 
suggested setup proof carrying code depicted 
top picture criterion safety safety policy concretely safe sal interpreter 
bottom proof carrying code method enforcing safety consisting verification condition generator followed verification validity verification condition produced 
main benefit get code setup run code safely having implement safe sal interpreter 
serious concern discussed previous chapter possible implement run time checks safety policy require 
furthermore note safety policy defined means safe interpreter tell program unsafe executing discovering safety violation 
pcc method hand tell statically program safe 
pcc method conservative meaning reject perfectly safe programs 
section describe syntax logic precise relationship logical formulas various safety checks sal interpreter performs 
section describe verification condition generator extracts logical formula verification condition body function 
vcgen interesting captures safety checks sal interpreter perform 
technically means diagram commutes validity path stated formally section proved appendix checking validity verification condition directly practical 
pcc uses indirect method checking validity means provability 
purpose introduce section set axioms inference rules prove formulas show set rules sound meaning provability guarantees validity 

logic logic logic symbolic language expressing safety checks symbolic form part verification conditions bridge semantics agent program symbolic proofs safety 
general ideas proof carrying code applied context logic adequate expressing required safety policy 
order predicate logic equality array variables sufficiently powerful practical safety policies 
purposes dissertation describe implementation pcc context restricted logic 
presentation mainly various correctness proofs point generic properties required pcc logic 
way correctness proofs serve assurance argument instantiation pcc guide designer wants extend logic accommodate demanding safety policies 
syntax logic symbolic language defined means syntactic rules formation formulas validity function gives meaning logical formulas relations universe values target machine 
validity function logical formulas produced vcgen assume meaning safety checks performed sal interpreter 
syntactic rules fragment order logic equality array variables shown 
main syntactic components predicates base expressions store expressions 
base expressions meant denote values base universe values fit register memory word 
role store expressions denote values universe stores equivalently states memory target machine 
associated store expressions constructors corresponding reading memory corresponding writing memory 
expression denotes current memory state expression sel denotes contents memory location address denoted express new memory state storing value denoted address memory state write upd 
base constants store constants required technical reasons 
note implicit typing rules base expressions store expressions predicates 
kinds expressions introduce versions universal quantification equality disequality 
simplify presentation drop typing superscripts possibility confusion 
example write denote comparison base expression base expression comparison store expression store expression 
chapter 
enforcing safety proof carrying code generic fragment predicates true base expressions sel store expressions upd extensions predicates 
cop saferd safewr base expressions 
eop offset syntax order predicate logic equality array variables 
generic fragment extended predicate expression constructors fit safety policy target architecture 
addition generic constructs order predicate logic array variables typical pcc logic contains predicate expression constructors denote symbolically run time entities sal interpreter 
example predicate constructors meant denote relations define instruction safety eop cop operators respectively 
saferd safewr constructors meant denote memory safety predicates cop denote comparison operation implemented target machine conditional operator cop 
expression side constructor eop stands mathematical function implemented target machine operator eop 
expression constructor offset vcgen denote instruction address offset function body starts 
standard valuation model section define precisely intended meaning logical expressions predicates syntax introduced previous section 
standard model logic quadruple universe base values universe store values represented total functions addresses standard valuation functions closed base expressions closed store expressions respectively defined 
recall eop generic mathematical function implemented target architecture generic sal operator eop denoted logic constructor eop 
shall omit superscript universes valuation functions 
logic sel upd eop eop offset definition standard valuation function 
true iff iff iff iff iff iff iff cop iff cop iff cop saferd iff saferd safewr iff safewr definition validity closed predicate standard model 
equality disequality symbols overloaded definition 
left side denote predicate constructors logic 
right side denote equality disequality predicates possibility confusion 
shall variables appropriately superscripted necessary refer individual values universes 
important note typing rules expressions predicates guaranteed valuation functions total contains formal definition validity predicate form judgment model standard model thesis henceforth abbreviate validity judgment chapter 
enforcing safety proof carrying code verification condition generator verification condition generator vcgen symbolic evaluator sal programs 
result evaluation verification condition formula logic described previous section 
main components verification condition symbolic counterparts safety checks mandated safety policy 
verification condition contains information control flow program express precisely safety check computation paths performed 
concept verification condition generation introduced floyd king kin kf appears extensively related formal program verification higher level languages bm det dij dij glb ill 
discuss definition vcgen introduce notation series simplifying assumptions 
model sal interpreter vcgen requires function defined stack frame stack accesses fall 
stack grows lower addresses reserved register sp points word top stack 
invoking function caller puts top stack callee arguments 
assume expects arg arguments passed stack 
relative location stack frame runtime stack defined value stack pointer moment invocation situation depicted 
moment words addresses sp 
sp arg contain arg arguments assume furthermore stack frame total length local extends sp arg downwards sp arg local 
variable denote offset current stack pointer current function stack frame sp denotes stack address current function frame 
relation hold number arguments number locals maximum extra stack allocated invocation arg local max arg allow easy arguments stack allocated variables convenient name stack slots frame local pseudo registers 
li alias memory location address sp arg sp value stack pointer entry function called frame pointer base pointer architectures 
note convention stack slot changes alias names time function call shown 
take special care vcgen terminates agent programs 
vcgen evaluates program symbolically attempt evaluate body loops iteratively follow recursive function call graph 
address issues loop invariants function specifications 

verification condition generator frame name address stack name xff 
ff sp lso arg sp arg sp lso sp lso sp sp local sp arg local 

frame stack management sal 
situation depicted occurs time function calls function value sp time call stack frame marks position argument implicitly defines alignment stack frame relative stack frame 
note implicit renaming local pseudo registers call 
loop invariants special case sal annotations 
state means logical formula state properties assumed hold arbitrary iteration 
run time ignored vcgen uses part operation 
loop invariants part agent program untrusted 
easy way ensure invariants 
vcgen verifies loop invariant holds entry loop preserved iteration loop simple inductive argument know holds finite number iterations 
vcgen attempt verify correctness invariants 
extends verification condition logical formulas extent valid verification condition means loop invariants correct 
presence loop invariants means vcgen needs scan loop body building inductive case argument 
hand vcgen require presence loop invariant loop 
easy conservative strategy chapter 
enforcing safety proof carrying code require backward branch target loop invariant annotation 
referring back define syntax annotations follows 
inv mod predicate denoting invariant property natural number specifies value stack offset loop mod set registers loop body change 
addition loops possible source non termination vcgen recursive function calls 
address issue fact modularize safety checking function basis current implementation vcgen requires functions specification 
function specification function form tuple pref cs arg local pref formulas representing precondition postcondition respectively cs set registers function required preserve callee save registers arg local natural numbers representing number arguments maximum number local variables allocated stack including arguments function allowed 
correct operation vcgen local pseudo registers arguments appear free variables precondition postcondition mentioned callee save registers 
condition sense values variables defined outside function 

cs fv pref fv specifications external functions system calls entry points provided code receiver 
specifications internal functions responsibility code producer accompany agent code 
note precondition postcondition relations part safety policy definition section written italic characters 
distinguish precondition postcondition logical formulas part function specification write ones typewriter characters 
correspondence specifications safety relations precise statements property correctness specifications evaluator state function pref iff arg pref post iff arg 
notation arg generalization case allowed range local pseudo registers follows 
rr ra mem arg mem sp arg li cases clear values arg abbreviate arg 

verification condition generator verification condition generator defined symbolic evaluator scans sal code function agent code produces verification condition 
symbolic evaluator maintains components state important mapping registers expressions 
set registers function contains sal registers memory pseudo register local pseudo registers follows regs 
rr ra mem 
stack pointer register general purpose registers vcgen manipulates directly 
set registers different function notation denote symbolic register state appropriate function set possible symbolic states function state regs symbolic expression logic 
addition symbolic state registers symbolic evaluator keeps track loop invariants encountered execution 
enables evaluator distinguish cases loop invariant seen time evaluation subsequent times 
information maintained sequence pairs consisting instruction address loop invariant encountered symbolic state execution immediately processing invariant 
sequence denoted letter operation adding new pair sequence written 
say occurs write dom denote state mapped write 
write denote empty sequence 
symbolic evaluator defined state transformation function parameters written se function body evaluated symbolic state registers execution function variable standing address instruction loaded memory offset current instruction function body current symbolic register state positive integer stack offset denoting difference top frame current value stack pointer loop map 
parameters written subscripts vary evaluation function omitted time simplify presentation 
spirit superscript omitted inferred context 
definition symbolic evaluator function shown explained detail rest section 
important discuss symbolic evaluator function produce verification condition 
verification condition conjunction obtained results symbolic evaluations functions contained agent code 
symbolic evaluation function started state obtained initializing registers regs new logical variables 
new variable created stand unknown address body function chapter 
enforcing safety proof carrying code loaded memory 
program counter initialized zero instruction function body stack offset variable initialized arg stack pointer points argument loop map initialized empty 
adding result symbolic evaluation verification condition agent newly introduced variables quantified making verification condition closed predicate 
formal definition operation shown vc 
yk pref se arg 
yk new variables regs 
rk 
rk yk returning description symbolic evaluator function shown note scans program vcgen performs simple checks shown second column 
frequent check control fall function shown dom definition 
checks performed vcgen fail program rejected right away 
definition symbolic evaluator recursive symbolic evaluator terminates reaches return instruction reaches loop invariant second time 
ensure loop contains invariant vcgen verifies target backward branch jump invariant instruction 
case simple register move vcgen verifies current instruction copies symbolic value source register target register continues symbolic evaluation instruction 
case binary operation verification condition extended additional predicate symbolic value target register set eop symbolic execution continues instruction 
intuition extended verification condition valid verification condition ensure actual operands eop fall safe domain operator 
intuition relies known meaning logic constructors eop shown figures 
case jump instruction symbolic evaluator verifies target instruction current function body 
furthermore backward branch evaluator verifies target invariant annotation 
symbolic evaluator continues target instruction 
case conditional branch similar jump instruction safety predicate conditional operator appended verification condition just expression operators 
execution symbolic evaluator 
verification condition generator fi check verification condition dom se dom se eop dom se eop jump dom se fn inv 
cond cop dom dom cop se fn inv 
se ra pc dom se ra offset dom call ra offset 
yk 
se dom arg copyin arg 
rk cs 
yk 
new variables 
rk yk arg 
ret arg cs dom saferd mem se sel mem dom safewr mem se mem upd mem sp sp local dom se sp local dom se lso sp local dom se lso inv 
rk dom 
yk se dom 
yk new variables 
rk yk inv mod dom dom mod definition verification condition generator sal form symbolic evaluation function se defined cases instruction fi 
chapter 
enforcing safety proof carrying code general discover branch taken 
considers branches reflected definition recursive calls 
provide information proof producer precise conditions branch taken vcgen builds implications left sides predicates assumed hold branch 
predicates rely meaning constructors cop 
case return address computation symbolic state return address register changed offset variable reserved stand address instruction body offset start target instruction 
expression constructor offset just symbolic counterpart addition addresses 
complicated case function call instruction register renaming take place twice going callee returning 
checks symbolic evaluator performs case ensure function known system known specification symbolic value return address register points instruction immediately call instruction execution resumes fall body arguments stack current stack frame 
check ensures vcgen keep track contents stack frame time 
checks succeed verification condition extended callee precondition ensure holds function entry 
symbolic evaluator abstracts execution continues evaluation instruction assuming postcondition holds return 
tricky case call symbolic state manipulations 
reasons manipulations 
function change registers modeled setting registers new variables quantified 
ensures assumed values 
second local pseudo register renaming modeled copy copy 
done helper functions copyin definition shown explained stack layout 
copyin arg function creates symbolic state appropriate symbolic state moment invokes moment stack offset arg arguments top stack 
copyin copies arguments refers local pseudo registers new state referred local pseudo registers 
local pseudo registers initialized arbitrary value zero case 
property registers appear precondition callee save set cs matter value chosen 
sal registers copied directly new state 
state obtained application copyin instantiate precondition 
verification condition generator copying arg lso arg li arg li arg local 
rr ra mem arg 
cs li arg li arg li arg zi li local 
rr ra mem cs additional helper definitions symbolic evaluator 
precondition written point view step processing call generate new variables registers declared saved potentially modified call 
variables stand new unknown values registers return resulting state instantiate postcondition written point view evaluation resumes context state changed fit new names stack slots 
accomplished call arg 
function defined creates symbolic state appropriate caller state point view callee state previous call 
state transformation preserves sal registers local pseudo registers located stack higher addresses frame local registers set contain arguments copied back changed 
local registers located stack arguments area initialized new variables zi model fact contents unknown 
completes discussion call instruction 
note vcgen described support computer function call function pointers limits drastically implementation higher order languages object oriented languages dynamic method lookup 
restriction relaxed noting vcgen need know exact function called just specification 
allow function pointers functions invoked particular computed function call share specifications 
case need able declare function pointer variable specification 
chapter 
enforcing safety proof carrying code case function return 
case postcondition asserted current state series equality predicates generated verify registers supposed preserve preserved 
set equalities generated function passed current state symbolic state registers function entry 
case memory read memory write appropriate safety predicate added verification condition state changed appropriately execution continues instruction 
case memory read target register changed case memory write memory pseudo register changed 
case stack register advance instruction stack offset component state decremented new value legal value frame current function instructions reading writing stack modeled register moves target register local pseudo register 
case invariant annotations 
symbolic evaluator verifies stack offset position specified annotation 
operation evaluator depends annotation seen time dom seen 
invariant seen time invariant predicate instantiated current state added verification condition 
intuition valid verification condition guarantee invariant holds entry loop 
registers loop allowed modify initialized new variables execution resumed new state 
note loop map extended state execution loop body 
purpose operation able detect loop invariant seen verify registers declared modified modified 
shown line definition 
concludes definition verification condition generator 
vcgen quite complex error implementation lead security holes exploited malicious code producers subvert safety checks 
verifying formally correctness particular implementation vcgen scope important prove algorithm correct 
verification condition generator correct produces valid verification condition definition validity section agent satisfies safety policy definition safety policy section 
agent functions invoke system calls need assume system calls safe 
stated formally theorem notion safety defined definition 
theorem soundness vcgen system calls safe safe agent verification condition valid vc functions system safe safe 

axiomatization logic soundness condition keystone proof carrying code infrastructure bridges semantics agent code safety policy logic 
proof theorem technical order keep main body thesis accessible give formal proof appendix proof great interest reader desiring precise understanding details verification condition generator 
proof interest intending extend symbolic evaluator features 
informally proof soundness theorem induction length execution 
step reachable state show execution immediately invocation progress 
induction collect propagate information execution initiated state satisfying precondition verification condition valid 
customarily done means induction hypothesis 
case induction hypothesis execution state exists related state symbolic evaluator point function state se 
key property run time symbolic states related complicated sense stated formally section 
need prove relation invariant execution words simulate execution interpreter related symbolic evaluator 
axiomatization logic shown previous section implementing safe sal interpreter section check code statically running verification condition generator verifying validity resulting verification condition 
major gain alternative strategy checking safety done statically having pay run time penalties 
potentially prohibitive cost verifying relations saferd safewr exists 
fact exacerbated universal quantifications require checks done large number cases 
surprising want verify statically possible executions safe 
problem worse alternative strategy checking safety ways verify validity predicates having compute valuations explicitly 
purpose section introduce framework symbolic computation formulas validity formulas verified symbolically 
framework consists set axioms inference rules allow prove formulas formulas believed valid 
axiomatic system logic set derivation rules derive validity formula formulas assumed valid 
predicate said derivation written derived rules shown natural chapter 
enforcing safety proof carrying code deduction style 
rules intuitionistic fragment logic strictly necessary 
seen valuation model logic section classical axiomatization allowed 
start discussing individual rules note obligation prove derivability logic preserves validity 
stated soundness property axiomatic system 
theorem soundness closed predicate proof derivation finite sequence uses axioms inference rules 
proof theorem follows induction structure derivation prove inference rule logic valid 
stated lemma 
lemma soundness inference rule inference rule hypotheses hi parameters aj valid uj 
um am hi um am 
soundness lemma proved inference rule logic introduced 
simplify notation proofs shall notation stand um am arbitrary substitution 
result substitution applied expression returning deductive rules classified main categories 
firstly rules order logic customarily defined elimination rules logical connectives 
rule implication hypothetical 
order prove assume proof derive proof 
case assumption named side condition requiring locally purpose proving 
similarly rule universal quantification parametric sense fresh parameter locally 
rules need prove soundness lemma just standard argument soundness natural deduction 
second class rules refers equality 
equality defined identity congruence rules 
rules derive rules symmetry transitivity 
rules case analysis case contradiction contr express properties disequality requiring general purpose negation disjunction 
proofs soundness inference rule omitted standard 
third class deductive rules rules referring array variables logic memory variables 
rule says contents memory location 
axiomatization logic order logic equality true truei andi impi impe array variables sel upd mc andel congr ander alle eb eb eb eb contr sel upd sel mc set deductive rules order predicate logic equality array variables 
updated value equal 
second rule says updating memory location change contents memory locations 
rules combination case analysis rule 
rules named mccarthy rules introduced mp 
representative case proof soundness rules consider rule mc 
soundness rule mc 

hypothesis get definition get sel upd sel valid 
fourth class rules pcc logics purpose defining properties various custom expression predicate constructors defined extensions base logic 
current version logic show special rules chapter 
enforcing safety proof carrying code addq add ge subq geq ge sub sf sub geq deductive rules custom operators introduced porting infrastructure dec alpha intel 
constructors related safety checks rely congruence rule derive predicates involving 
operators introduced porting infrastructure concrete target architecture useful specify partially meaning operators 
done deductive rules shown 
rule add says adding zero idempotent dec alpha 
rule geq says ge comparison zero result subtracting positive values subq true values relation 
surprising part rule necessarily true values positive 
fact true operation subq overflow sufficient condition non negative 
intel architecture subtraction followed comparison achieve expected result non positive input values stated geq rule 
usual give proofs soundness newly introduced rules 
show non trivial proofs geq geq rules 
soundness geq rule 

hypotheses infer 
obtain inequalities 
adding inequalities followed adding result obtain definition subq subq 
hypothesis easy verify 
note magic positive just sufficient condition ensure subtraction overflow 
soundness geq rule 
sub sf sub sf 
hypothesis valuation ge know sf 
need show assume contrary try derive contradiction 
cases mod sf means turn contradicts assumption 

discussion mod zf zero meaning contradicts assumption 
discussion chapter described formalized generic safety policy enforceable described implementation proof carrying code 
essence formalization definition safety definition 
section define verification condition generator scans agent code produces formula logic introduced section 
theorem states algorithm verification condition generation sound respect definition safety sense produces valid verification conditions safe agents 
section introduce symbolic framework deciding validity formulas means set derivation rules 
theorem states set derivation rules guaranteed derive valid formulas 
put results state formally algorithm verification condition generation axiomatization logic sound method verify safety agents 
stated correctness theorem proof carrying code 
theorem soundness proof carrying code system calls safe safe verification condition agent functions provable logic vc functions system safe 
proof soundness axiomatization theorem vc 
soundness vcgen theorem obtain desired 
general concrete pcc logic extension logic discussed chapter 
typical extensions change set logical connectives introduce new expression predicate constructors 
cases proof soundness new logic strict extension proof shown chapter 
substantial change logic attempted safety policy designer obligation redo soundness proof scratch 
hopefully technical development chapter reused case 
help logic designers extend logic summarize general strategy followed 
extend syntax new expression predicate constructors 
chapter 
enforcing safety proof carrying code 
define valuation functions newly introduced constructors 
added constructors meant denote machine operations valuation functions correspond behavior physical machine 
valuation function total 

add axioms inference rules involving new constructors 
step mandatory predicates contain new constructors provable 

newly added derivation rule extend proof soundness lemma basically proving derivation rule sound respect standard model 
chapter proof engineering chapter shown verification condition generation constructs valid verification condition agent program agent meets safety policy 
shown verifying validity verification condition directly find derivation proof formula system axioms inference rules 
technical facts proof carrying code relies 
addition proof carrying code exploits fact proving verification condition difficult general verifying validity proof 
motivates pcc requirement code producer generates proofs code receiver check validity 
properly practice need framework encoding proofs logical formulas relatively compact easy check 
need framework just proof checker logic set axioms inference rules change frequently adapt pcc different architectures safety policies 
adaptation require changes system ideally limited high level description inference rules format resembling mathematical formulation 
desiderata summarize necessary properties successful candidate framework encoding checking proofs 
framework able encode judgments derivations wide variety logics including order higher order logics 
implementation proof checker parameterized high level description logic 
allows unique implementation proof checker configured easily logics encoded framework 
proof checker perform directed pass inspection proof object having perform proof search 
leads simple implementation proof checker easy trust install extensible systems 
chapter 
proof engineering proof representation compact order minimize resources needed transmitting storing checking proofs 
desiderata important proof carrying code application proofs represented manipulated explicitly 
application proof generating theorem prover 
theorem prover generates explicit proof object successfully proved predicate enables user verify validity proved theorem checking proof object 
effectively eliminates need trust soundness theorem prover relatively small expense having trust simpler proof checker 
generated proofs proof checker great software engineering benefit lead timely discovery soundness bugs introduced development maintenance theorem prover 
impulse designing efficient proof representation validation algorithms specialize logic class related logics 
example define representation validation algorithms cases case inference rule logic 
approach major disadvantage new representation validation algorithm designed implemented logic 
matters worse proof checking algorithms large realistic logics 
prefer general algorithms parameterized high level description particular logic interest 
specialized representation validation algorithms choose edinburgh logical framework lf introduced harper honsell plotkin hhp starting point quest efficient proof manipulation algorithms scores high desirable properties listed 
edinburgh lf simple variant calculus property predicate represented lf type valid proof predicate necessarily lf expression type 
simple logic independent lf type checking algorithm checking proofs 
lf perfect choice proof carrying code representation proofs unnecessarily large due high degree redundancy 
address issue extended lf handle proof representations missing subterms extended lf type checking algorithm synthesize missing parts 
order keep resulting proof reconstruction algorithm simple particular avoid having search reconstructing impose certain syntactic restrictions proof subterms missing 
restrictions case small amounts redundant information eliminated representation proofs 
practical experience shows case representation level proofs proofs theorems deductive systems soundness completeness anyway scope proof carrying code variant described dissertation 
experiments pcc proof generating theorem prover 
edinburgh logical framework order logic show resulting logical framework call implicit lf lfi obtain reductions orders magnitude size proofs time required proof checking 
furthermore factors larger larger proofs 
rest chapter organized follows 
section describes encoding predicates proofs edinburgh logical framework demonstrates simple example effects redundancy representation proofs 
section discusses lfi type system extension lf 
lfi type system plain lf type system suggest simple deterministic type checking algorithm show section lfi reconstruction algorithm proved appendix adequate type checking lfi proof representations 
section describes algorithm convert proofs represented lf compact lfi representations 
concluding chapter section shows represent efficiently proofs linear arithmetic lfi section compares lfi related techniques representing proofs 
experimental data validating lfi algorithms described discussed section 
abbreviated form chapter appeared nl 
edinburgh logical framework edinburgh logical framework referred lf introduced harper honsell plotkin hhp metalanguage high level specification logics 
lf provides natural support management binding operators hypothetical schematic judgments 
example captures convention expressions differ names bound variables considered identical 
similarly allows direct expression contexts variable lookup arise hypothetical parametric judgment 
consider example usual formulation implication rule order logic 
rule hypothetical proof right hand side implication assumption left hand side holds 
side condition requiring assumption proof 
shall see lf represent side condition natural way representing assumption local variable bound proof implication 
fact techniques supported directly logical framework crucial factor succinct formalization proofs 
lf representation logic consists stages 
stage representation syntax logic consideration 
example show represent expressions predicates order predicate logic lf 
second stage representation axiomatization logic implicitly proofs 
lf type theory language entities levels objects types kinds 
types qualify objects similarly kinds qualify types 
chapter 
proof engineering kinds type types objects syntax edinburgh lf 
syntax entities shown dependent function type bound special case occur familiar notation 
type base kind type constant object constant 
encoding logic lf consists lf signature contains declarations set lf type expression constants corresponding syntactic formula constructors proof rules 
concrete discussion describe section representation order predicate logic equality array variables syntax shown axiomatic system defined 
syntax logic described lf signature shown 
signature defines lf type constant kind syntactic entity logic 
lf constant declaration syntactic constructor 
lf type constant describes arity constructor types arguments type constructed value 
interesting case straightforward universal quantification bound lf variable represent variable bound quantification 
higher order representation trick ensures predicates equivalent renaming bound logical variables represented terms equivalent renaming local lf variables 
furthermore substitution lf represent substitution object logic 
lf representation function defined inductively structure expressions types predicates 
example representations imp exp strategy representing proofs lf define type family pf indexed predicates 
represent proof lf expression having type pf 
representation strategy called judgments types derivations objects harper honsell plotkin hhp 
note dependent types lf allows encode expression encodes proof proof view axioms inference rules proof constructors 
justifies representing axioms inference rules similarly syntactic constructors means lf constants 
lf signature constitutes representation axiomatic system 
edinburgh logical framework exp type mem type pred type sel mem exp exp upd mem exp exp mem eop exp exp exp offset exp exp exp true pred pred pred pred impl pred pred pred exp pred pred alls mem pred pred eqb exp exp pred exp exp pred eqs mem mem pred mem mem pred exp exp pred exp pred cop exp pred exp pred saferd mem exp pred safewr mem exp exp pred lf signature constitutes representation syntax firstorder predicate logic equality array variables 
expression predicate constructors shown 
shown 
note dependent types lf define precisely meaning rule 
example declaration constant andi says order construct proof conjunction predicates apply constant andi arguments conjuncts proofs conjuncts respectively 
lf representation function extended derivations defined recursively derivation shown examples andi chapter 
proof engineering pf pred type truei pf true andi pred pred pf pf pf andel pred pred pf pf ander pred pred pf pf impi pred pred pf pf pf impl impe pred pred pf impl pf pf alli exp pred exp pf pf ball alle exp pred exp pf ball pf exp eqb congr exp exp exp pred pf eqb pf pf case exp exp pred 
pf eqb pf pf pf pf contr exp exp pred pf eqb pf pf mc mem exp exp pf eqb sel upd mc mem exp exp exp pf pf eqb sel upd sel lf signature constitutes representation axiomatization order predicate logic equality array variables 
impi pf conclude presentation lf representation consider proof simple predicate 
lf representation proof shown 
lf type system main advantage lf proof representation proof validity checked simple type checking algorithm 
check lf object representation valid proof predicate lf typing rules 
edinburgh logical framework impi pf andi lf representation proof implication followed conjunction predicate 
verify type pf context signature declaring valid proof rules 
type checking lf type system defined means judgments shown described lf valid object type lf valid type kind equivalent equivalent typing context assigning types lf variables 
derivation rules lf typing judgments shown 
equivalence judgments omit rules define equivalence congruence 
types lf objects equivalence lf lf lf lf lf lf lf lf mn lf type lf type lf type lf lf type lf lf lf type checking lf type discipline example lf type checking perform proof checking consider proof representation shown 
easy verify lf typ chapter 
proof engineering ing rules declaration constants involved proof lf type pf imp 
adequacy lf type checking proof checking logic consideration stated formally theorems 
theorems proved hhp 
proofs evident continue hold logic extended new expression predicate constructors higher order constructs 
theorem adequacy syntax representation 

closed expression lf exp 
closed expression lf mem 
closed expression lf pred 
closed lf object lf exp exists expression 
closed lf object lf mem exists expression 
closed lf object lf pred exists predicate theorem adequacy derivation representation 

derivation lf pf 

closed lf object lf pf exists derivation note theorem says code producer exhibit lf object having type pf vc know derivation verification condition logic turn means verification condition valid agent code satisfies safety policy 
owing simplicity lf lf type system implementation type checker simple easy trust 
furthermore dependencies particular object logic segregated signature implementation type checker reused directly proof checking various order higher order logics 
logic dependent component proof checker signature usually easy verify visual inspection 

implicit lf representation unfortunately mentioned advantages lf representation proofs come high price 
typical lf representation proof large due significant amount redundancy 
fact seen proof representation shown copies opposed predicate proved 
effect redundancy observed practice increases non linearly size proofs 
consider example representation proof way conjunction 
depending balanced binary tree representing predicate number copies proof representation ranges expected value log worst case value redundancy representation space problem leads inefficient proof checking redundant copies type checked checked equivalence instances predicate proved 
focus remainder chapter modify lf representation reduce redundancy representation 
implicit lf representation lf representation type checking algorithm previous section adequate representation validation proofs 
proof representations unnecessarily large 
size proofs general important factor application manipulates proofs explicitly redundancy representation particular important consequences efficiency proof checking 
consider typical situation code receiver desires check untrusted safety proof example proves certain predicate 
situation subterm proof representation type checked 
means occurrences term type checked separately 
type checking operations term compared instance contained predicate proven ensure subderivation proves desired predicate 
redundancy representation increases amount required checks lead inefficient proof validation 
solution redundancy problem eliminate redundant subterms proof 
cases eliminate copies subterm proof rely copy exists predicate proved am going assume trusted formed 
code receiver receiving proofs missing subterms 
possible strategy code receiver reconstruct original form proof simple lf type checking algorithm validate 
save proof checking time require significantly working memory size incoming lfi proof 
propose modify lf type checking algorithm reconstruct missing subterms performs type checking 
major advantage strategy terms reconstructed copies chapter 
proof engineering verification condition need type checked 
plunge formal details type reconstruction describe operation simple example 
purpose consider simple extension lf syntax new term called placeholder written mark missing lf subterm 
consider proof predicate 
replace copies placeholders get implicit proof impi andi implicit proof captures essence proof 
subterms marked placeholders recovered verifying term type pf impl described 
reconstruction starts recognizing top level constructor impi 
type entire term pf impl matched result type impi constant signature 
result matching instantiation placeholders residual type checking constraint explicit argument impi follows andi pf pf reconstruction continues remaining type checking constraint 
type recover value placeholder typing constraint body pf pf andi pf andi top level constant matching result type declared signature goal type constraint get instantiation placeholders residual typing constraints pf pf pf pf remaining constraints solved variable typing rule concludes reconstruction checking entire proof 
reconstructed full representation proof instantiating placeholders typed lf objects 
know instantiations typed ultimately extracted original constraint type assumed contain typed subterms 

implicit lf representation formalization reconstruction algorithm described informally stages 
show variant lf type system called implicit lf lfi extends lf placeholders 
type system property typed lfi terms reconstructed typed lf terms 
original lf type system lfi type system amenable direct implementation deterministic type checking 
describe separate reconstruction algorithm section prove adequate type checking lfi terms 
just previous example extend syntax lf objects placeholders written 
object fully reconstructed fully explicit placeholder free 
write pf denote property 
extend notation type environments write pf denote types assigned variables placeholder free 
introduce implicitly typed abstraction written lfi typing rules extension lf typing rules new typing rules dealing implicit abstraction placeholders new equivalence rule dealing implicit abstraction 
additions shown 
lfi typing judgment written objects pf equivalence pf pf lfi type system extension lf 
note lfi type system placeholders occur function position arguments application 
restriction allows simplify reconstruction algorithm avoiding higher order unification 
note lfi rules require types involved contain placeholders 
restriction simplifies greatly proofs soundness diminish effectiveness lfi representation 
quick analysis lfi type system reveals useful type checking chapter 
proof engineering type inference 
main reason type checking application involves guessing appropriate type recovered type application head term application placeholder easily general 
problem going lfi type system step proving correctness type reconstruction algorithm section basis implementation type checking algorithm 
property interest lfi type system typing derivation reconstruct object involved corresponding lf typing derivation 
precise introduce notation denote fully reconstructed version implicit object pf 
means obtained replacing placeholders fully explicit lf objects similarly implicit abstractions explicit abstractions 
note reconstruction relation function reconstructions implicit object type 
theorem soundness lfi typing pf pf exists lf theorem restated proved theorem appendix algorithm lfi type reconstruction lfi type system previous section benefit allows implicit lf terms 
type system immediately suggest type checking algorithm reasons explained 
show section algorithm type check lfi terms precisely reconstruct type check lfi terms 
notation addition placeholder constants introduced previous section introduce new brand variables 
unification variables play similar role placeholders stand missing terms 
shall letters denote traditional lf variables letter denote unification variable 
denote type environment containing type assignments unification variables 
letter denote type environments containing kinds variables 
special case lf object contain unification variables write uvf 
note unification variables occur free 
extend notation uvf fv mean types associated free variables contain unification variables 

algorithm lfi type reconstruction main operation unification variables substitution lf terms 
define syntactic class substitutions follows substitutions notation denotes term obtained performing substitution write dom refer set unification variables defined 
write pf mean terms substituted unification variables placeholder free 
notation denotes composition substitutions resulting composition domain dom dom maps 
write denote substitution obtained restricting set unification variables key operations performed reconstruction algorithm compute substitutions unification terms types 
precise presentation algorithm flavors unification shown case unifying objects 
atomic flavor unification defined applications regular flavor defined kinds objects 
notation expressing unification types 
atomic unification unification syntactic construct introduce list type reconstruction constraints defined follows reconstruction algorithm described unification judgments introduced additional mutually recursive judgments shown main reconstruction judgment collect constraints solve constraints rest section show definition judgments introduced collection inference rules 
inference rules implemented straightforward manner produce type reconstructor lfi 
collecting type checking constraints judgment atomic objects constants variables applied zero canonical objects 
canonical object sequence abstractions atomic body equivalently term normal form 
atomic object scanned find application head type read signature constant chapter 
proof engineering variable type environment variable 
arguments collected typing constraints constraint list placeholder argument unification variable introduced 
unification variables collected types 
resulting type type application contain unification variables 
similarly types constraint list contain unification variables 
note placeholders occur types side condition rule pertaining application placeholder 
fv pf uvf uvf fv new unification variable restriction explicit application rule ensures resulting type contain placeholders provided placeholders 
restriction simplifies proof correctness reconstruction required order match lfi typing judgments defined types placeholders 
describe list constraints solved 
main reason separate tasks collecting constraints solving allow implementation choose arbitrary order solving constraints 
previous experience implementations reconstruction algorithm shows having flexibility solving order greatly increases effectiveness reconstruction algorithm benefit proofs missing components reconstructed 
solving residual constraints judgment rules shown defines process solving typechecking constraints list arbitrary order 
accommodate arbitrary solving orders introduce constraint reordering rule 
kinds constraints typing constraints main reconstruction judgment invoked unification constraints solved unification 

algorithm lfi type reconstruction type reconstruction objects base judgment type reconstruction algorithm 
term contain variables unification variables declared constants declared 
contain placeholders implicit abstractions 
type environment type contain placeholders 
required order relate type reconstruction judgment lfi typing judgment beneficial effect simplifying proof correctness 
recall canonical lf object abstraction body canonical atomic object 
type checking judgment deals directly abstractions invokes constraint collecting solving judgments atomic objects 
note case implicit abstraction argument type recovered goal type functional type 
note reconstruction allowed abstraction body substitution returned empty meaning subterms body abstraction reconstruction outside abstraction 
restriction harm way usefulness reconstruction algorithm level proofs proof formulas simplifies significantly correctness arguments eliminating concern returned substitution contain bound variable case constant variable application typing judgment collects type reconstruction constraints solved arbitrary order 
dom dom dom previous rule required substitution returned defined unification variables introduced current collecting operation 
means entire list constraints discarded point 
respect type reconstruction algorithm simpler potentially powerful constraint algorithms allow unsolved reconstruction constraints persist place introduced 
restriction limit power algorithm reconstructing implicit representations level proofs eliminate need machinery managing persistent constraints 
chapter 
proof engineering note reconstruction algorithm check explicitly returned substitution typed 
reason reconstruction algorithm runs faster implicit representation proof lf type checking algorithm fully explicit form proof 
returned substitution guaranteed typed design unification judgment described 
unification purpose unification check equivalence objects types 
result unification substitution terms unification variables 
terms checked contain implicit abstractions canonical form contain placeholders 
main limitation unification judgment try unify terms unification variable head application 
case resulting substitution uniquely defined preferable avoid 
order express restriction precisely flavors unification atomic normal 
atomic unification head application 
consequently unification variable instantiated atomic unification 
unification judgments 
atomic unification normal unification nn xn 

xn 
nn fv side condition instantiation rule required correctness 
check called occurs check 
checking condition requires scanning object replace placeholder denoted unification variable want avoid check 
recall arguments favor implicit representation smaller representation size faster checking fact reconstructed objects require checking 
expressed 
algorithm lfi type reconstruction unification judgment reconstructed fragments require checking require scanning 
cases occurs check necessary eliminated 
optimization discussed section 
type reconstruction 
reconstruction judgments described previous sections directly type reconstruction algorithm 
summarize process reconstructing type checking object proceeds follows abstraction abstraction rule continue reconstruction body 
variable constant applied zero arguments 
collecting judgment scan arguments replace implicit ones unification variables 
collect explicit arguments list type reconstruction constraints 
add list constraints unification required type application type computed type application head arguments 
solve list constraints convenient order 
result return instantiation unification variables 
verify local placeholders instantiation 
derivation rules reconstruction judgments faithful description effective algorithm lfi reconstruction 
algorithm constitutes sound method validating proofs successful execution implies exist lfi typing derivation input proof representation turn theorem means exists fully explicit typed lf term type turn theorem means verification condition derivable logic 
formal statement correctness reconstruction algorithm stated 
theorem correctness proof reconstruction lfi object uvf pf pf 
unfortunately proof theorem simple statement devote entire appendix 
chapter 
proof engineering algorithm lfi representation reconstruction judgment section accept implicit forms typed lf object 
useful define algorithm erase lf representation proof redundant subterms possible ensuring resulting implicit object accepted reconstruction 
proof carrying code environment representation algorithm applied proof immediately produced theorem prover order reduce burden communication network 
possible algorithms erasing redundant subterms 
discuss section called bimodal representation determined experimentally compromise complexity effectiveness 
section briefly discuss representation algorithms 
lfi representation algorithm depend reconstruction algorithm able predict subterm reconstructed 
terms reconstructed omitted representation 
relevant detail reconstruction algorithm order constraints solved 
seen correctness algorithm depend order ability reconstruct subterm 
representation algorithm able predict behavior reconstruction fix solving order allow representation algorithm embed representation order constraints solved particular application 
choose simpler solution algorithm require reconstruction algorithm solves constraints reverse order introduced meaning unification constraint solved followed typing constraints 
experimental evidence suggests solving order 
discussing precise details representation algorithm useful see operates simple example 
consider representation task hand remove redundancy lf object declaration constant add add add exp exp pf pf add constant represent example idempotency adding zero 
representation algorithms section just reconstruction fixing solving order necessarily mean results representation suboptimal 
analyze constant turn decide particular constant best constraint solving order 
usually reorder arguments constant fixed solving order matches optimal 

algorithm lfi representation algorithm section independent significance signatures 
relevant reconstructing proofs logic derivation rule represented constant add 
representation algorithm works considering behavior reconstruction faced task reconstructing implicit representation lf object type follows add equation implicit representation possible implicit representations respectively 
reconstruction algorithm generates constraints ordered order solved pf pf exp exp optimistic scenario point view reconstruction fully explicit need specified recovered 
case type application fully explicit called checking case 
case typed fully explicit constraints satisfied automatically 
furthermore constraint checking mode 
checking mode representation small add representation checking mode pessimistic scenario contain structural information pf information recovered 
difficult reconstruction require type reconstructed addition term 
case called inference mode 
reconstruction able infer structure just constraint mean appear explicitly 
try see recovered constraints 
example recovered constraint done inference mode 
case constraint automatically satisfied 
inference mode fully reconstruct type fully explicit 
representation inference mode add representation inference mode addition extreme cases discussed consider situations type partially implicit recover partially collected implicit arguments 
chapter 
proof engineering arguments 
consider variant inference mandatory type fully recovered reconstruction 
section consider extreme cases name bimodal representation 
section briefly discuss potential benefits complex representation algorithms 
major advantage bimodal representation algorithm large part done statically signature loaded 
precisely constant compute constant declared type representation recipes checking inference 
representation recipe ary constant sequence representation directives directive corresponding argument representation directive specifies corresponding argument left implicit partially explicit 
case directive says mode explicit argument represented 
bimodal representation algorithm uses representation directives denote argument omitted ec ei denote explicit arguments checking inference recipes respectively recursively 
recipes corresponding constant denoted checking recipe inference recipe 
refer checking inference modes time shall letter stand components representation algorithm 
algorithm computes representation recipes constant declared type constant 
algorithm scans fully explicit lf object depending representation recipes decides subterms omitted 
part simplest describe 
main representation function described judgments compute representation mode auxiliary judgment compute representation application head mode compute recipe arguments 
cases main judgment 
case abstraction type bound variable left implicit body represented recursively 
cases auxiliary judgment invoked 
auxiliary representation judgment scans application reaches head 
head constant representation constant recipe remaining arguments constant recipe variable case representation variable recipe remaining arguments sequence em directives long arity variable 
depending computing checking inference recipe 
return auxiliary judgment representation application argument done means bimodal representation algorithm attempt job applications head variable 

algorithm lfi representation em 
em em bimodal representation algorithm 
directive 
core representation algorithm computation representation recipes constant declared type 
order describe precisely computation representation recipes define function unif computes set free variables guaranteed instantiated successful unification fully explicit type definition unif follows unification 
complement unif denoted normally consists variables occur functor position notation extended objects rules computing unifiable sets described unif unif fv unif unif unif unif unif unif unif head constant head constant fv unif consider application constant type 
xn type abstraction 
due right left order solving constraints solving operation unifies type unification succeed necessary arguments corresponding variables explicit 
checking situation contain unification variables unification finds instantiations arguments corresponding variables unif 
chapter 
proof engineering ak exp exp pf pf unif ak ak ec ec ei computation recipe directives case constant add declared type exp exp pf pf 
values table computed right left 
inference situation assume conservatively unification find instantiation 
typing constraints arguments processed reverse order 
im 
set variables 
xn guaranteed instantiated processing constraints corresponding ak 
constraint unification constraint typing constraints 
similarly em set variables required explicit unification fail processing constraints corresponding ak 

sets computed starting follows unif ik xk im im unif ak em ek xk im em ak im definitions define representation recipe rm rm 
rm recipe directives defined follows xk ec fv ak im em ei definitions say argument corresponding xk implicit inferred constraints corresponding ak 
xk appear 
representing arithmetic proofs constant ec ec ec ec andi ec ec ei ei andel ei ei impi ec ec ec ei alle ec ec ec ec ec ec add ec ec ei mc ec ec ec ei fragment representation recipes signature shown 
functor position ak 

im em 
case constraint collected im im em em argument explicit represented recursively checking mode variables occurring type required explicit em inferred constraints solved im 
consider example operation recipe computation algorithm case add constant declared 
compute unifiable non unifiable sets 
shown 
start computing im em sets 

compute checking inference representation directives 
shows examples representation recipes constants representation order logic equality array variables 
case constant alle non unifiable variables 
particular case representation algorithm particularly effective 
representing arithmetic proofs preceding sections argue formally informally edinburgh logical framework especially lfi variant excellent choice representing checking derivations variety logics interest proof carrying code 
true long logic interest finitely axiomatizable 
build lf signature containing declaration derivation rule 
unfortunately instance convenient encode logic convenient axiomatization finite 
case various forms arithmetic 
take example commutative group addition integers usual commutativity associativity identity axioms 
equality group axiomatized finite number derivation rules encode integers sort unary binary notation 
inconvenient leads complex proofs simple facts addition integer literals 
lot chapter 
proof engineering convenient able encode literals directly 
need axioms literals define 
section simple extension lf purpose encode check equality proofs commutative group 
place small number axioms required handle complex realistic fragments arithmetic integer linear programming modular arithmetic 
examples considered chapter context decision procedures emit lf proof representations 
extension consists mainly extending lf set objects include integer literals behave constants required declared explicitly signature 
integer literals assumed type exp 
add declarations addition negation equality integers shown 
exp type pred type add exp exp exp neg exp exp exp exp pred arith exp exp pf encoding additive group integers lf 
special constant arith introduced encode proofs arithmetic equality 
constant arith unusual sense constructs proof equality assumption constituents equality typed expressions 
signature adequate representing additive group equality able construct representation equality proof just pair expressions 
fix problem extend lf type checking algorithm occurrence arith just type checked analyzed algorithm arith described ensure valid proof 
intuition arith function expression involving variables vars 
xn integer literals addition unary negation exist integer constants 
value mapping vars ai xi 
words expression equivalently written linear combination free variables 
function arith computes coefficients arbitrary expression 
function arith defined take integer factor set intermediary coefficients vars addition expression set coefficients consists constant integer coefficient variable vars 
initial value factor coefficients vars vars 

representing arithmetic proofs arith arith arith add arith neg algorithm arith checking equalities additive group 
complete extension lf introduce special case rule lfi type check application situation head application arith follows arith dom dom dom pf arith add neg dom dom arith dom note left side hypothesis copied directly original rule 
new right side hypothesis ensures coefficients expression computed arith function zero 
able extend proof adequacy representation reconstruction objects constants arith 
need theorem 
theorem expressions variables vars arith add neg vars vars valuation vars 
proof proof means general lemma allows arbitrary values factor expression intermediate set coefficients 
lemma states function arith computes correct set coefficients succeeds 
fact 
extending lf reconstruction algorithm simple arithmetic decision procedure able encode arithmetic proofs concise manner 
savings due encoding integer literals explicitly avoiding trivial lengthy proofs equality additive group integers 
extension encode lf logics finite axiomatizations integer linear programming shown section 
chapter 
proof engineering implementation lfi previous sections describe lfi reconstruction algorithm validate implicit representation proofs lfi representation algorithm compact proofs erasing redundant subterms 
algorithms described abstractly terms inference rules implemented straightforward transcription rules code 
implementation details left unspecified provide freedom implementor 
experience implementations shows details significant impact performance algorithms 
section discuss implementation choices discovered beneficial 
detail implementation substitution 
example straightforward implementation substitution introduce copies free occurrences leading excessive memory usage wad 
better strategy employed twelf implementation lf psc explicit substitutions accl substitution performed lazily resulting term examined 
lf type object represented pair regular lf type object free variables substitution free variables pairs terms substitution follows lf objects lf types explicit substitutions invariant property explicit substitution representation closed pair fv dom 
maintain property able represent terms free occurrences variables arise reconstruction convention binding removed term fresh constant created substituted bound variable modified rule reconstruction abstractions cx cx cx new constant substitution cheap extend explicit substitution subject term rule reduction true cost substitution paid object traversed variable reached 
case traversal continue explicit substitution variable 
implementation lfi suggested identity appears storing explicit substitutions requires memory substituted term space required record substitution usually space required store copies substituted term 
addition explicit substitution representation saves processing time terms involved substitution rewritten avoid variable name clashes 
time required scan resulting term changed explicit substitutions 
addition substitution potentially costly operation composition substitutions unification 
purpose composition ensure instantiation unification variable instantiation applied occurrences unification variable 
effect achieved low cost explicit substitutions share mapping corresponding unification variable 
unification finds instantiation unification variable update shared cell stores explicit substitution variable result new instantiation seen simultaneously relevant explicit substitutions 
required sharing established making sure rule occurrences cell cx shared 
implementation choice face representation variables 
explicit substitutions natural represent bound variables debruijn indices deb 
notation occurrence bound variable represented positive integer counts lambda abstractions syntax tree occurrence binding abstraction 
represented 
advantage debruijn indices explicit substitutions implemented linked lists pairs 
explicit substitution variable skipping number list cells equal debruijn index variable occurrence 
dissertation ignore details external representation lfi terms 
reasonable way linearize lf term manner acceptable 
experience suggests idea encode applications head followed number arguments abstractions number bindings followed body 
encoding called functor arguments mp 
object external representation tag denoting variable case rest object debruijn index variable constant case rest object index global table constants current signature application case rest object contains number arguments head followed encoding arguments chapter 
proof engineering abstraction case rest object encodes number bindings followed encoding types binding body 
implementation basic unit representation bit word 
case tag word contain debruijn index variable index constant length application abstraction 
integer literals represented constants having indices outside maximum size signature 
close implementation section describe couple opportunities optimizing reconstruction algorithm 
promising opportunities optimization elimination occurs check unification rule 
shown clearly correctness proofs lfi reconstruction shown appendix necessary verify variable unified occur free target instantiation 
cases guaranteed checking 
purpose assume partition set unification variables guaranteed occur twice unification goal rest 
refer set variables linear variables 
know occurs check need performed unifying linear variable 
question discover variables linear 
solution suggested considering place unification variables created constraint collection rule shown new unification variable dependent type form 
xn 
occurs ai know occur constraint candidate linear unification variable 
note linearity case precomputed statically frequent case head constant portion type declared signature 
note linearity property unification variable preserved substitution linear variable preserved substituted variable linear occurs multiple times 
account case implementation unification disables occurs check optimization traversing explicit substitution nonlinear variable 
experiments section show simple optimization reduces time required proof checking factor cases high 
possible optimization reduce memory usage required reconstruction 
close inspection reconstruction rules reveals addition memory required store original lf object type reconstruction allocate space 
discussion hold explicit substitution list cells constraint list data structure 
constraint data structure allocated stack discarded immediately current reconstruction goal finished 
observe type reconstruction subterm instantiations safe deallocate entire memory allocated type reconstruction particular subterm 
take advantage common allocation pattern implementation pcc uses private heap allocates sequentially deallocates entire chunks time stack manner 
way allocation deallocation quite inexpensive 
case instantiations reconstruction subterm cases implementation refrains deallocate 
detect cases subterm basis implementation maintains counter number uninstantiated distinct unification variables 
counter initialized zero top level incremented unification variable introduced decremented unification finds instantiation 
note unification variable instantiated 
safe deallocate memory allocated reconstruction subterm number uninstantiated unification variables change 
experiments shown section show optimization reduce memory usage factor cases 
optimization interesting memory usage small anyway 
discussion problem redundancy representation proofs addressed purpose simplifying user interface theorem provers proof assistants 
miller suggests mil extreme approach proof object records substitutions quantifiers relying decidability tautology resulting matrix 
leads compact proof representations expense np complete tautology checking problem 
furthermore presence interpreted function symbols arithmetic case pcc proofs tautology checking problem easily undecidable 
argument synthesis term reconstruction algorithms implemented lego system pol coq dfh proof assistant effective algorithm sense fewer proof subterms omitted proof representation redundancy tolerated 
address difficult problem representing proof predicate proves recovered 
bimodal representation algorithm reduced effective inference mode 
example application constant type exp pf explicit recovered context 
algorithm chapter able synthesize proof subterms chapter 
proof engineering information context predicate proof supposed prove 
implementation elf pfe logic programming language lf contains reconstruction algorithm similar sense missing application arguments recovered type application inherited arguments arguments application synthesized arguments 
fact elf reconstruction algorithm powerful discussed impose restriction terms missing proof 
elf goes far allowing entire proof implicit case searches proof 
achieve flexibility elf type reconstruction uses algorithm constraint solving pfe pfe constraints survive local context introduced 
constraints remain unsolved case elf declare failure reconstruct proof 
proof checking algorithm described characterized special efficient case elf reconstruction algorithm proof structure need search higher order unification reduced simple extension order unification respects bound variables constraints generated simple rigid rigid flex rigid form solved eagerly locally 
design language mil relies syntactic restrictions purpose eliminating need higher order unification type checking 
restrictions strict purposes prevent free higher order syntax representation predicates proofs requiring costly mp explicit implementations substitution 
lfi representation techniques full lf language gain leverage substitution meta language restrictions imposed subterms missing representation 
similar ideas chapter appear pt context simple effective type inference algorithm language subtyping impredicative polymorphism 
similarity lies fact algorithms rely combination local constraint solving bidirectional checking 
result subsumes different characteristics underlying languages lf dependent types language considered pt subtyping 
distinguishing feature lfi framework related discussed representation algorithm take regular lf representation proof eliminate subterms possible keeping resulting proof reconstruction capability proof checker 
experimental data supports claim lfi representation order logic proofs substantial practical benefits 
bimodal representation algorithm section advantage done statically loading signature 
repre 
discussion sentation recipes computed actual representation algorithm just copy full lf representation certain subterms dropped 
bimodal algorithm considers possible contexts application 
direction improving effectiveness representation consider lf application actual context occurs 
experiment case implemented global representation algorithm mimics reconstruction algorithm detect subterms omitted 
application global algorithm starts assuming optimistically arguments dropped 
runs reconstruction algorithm fail checking constraints checked check dom dom rule type reconstruction application fail 
failure points set arguments explicit 
global reconstruction algorithm arguments explicit tries succeeds 
sense global representation algorithm optimal constraint solving order 
improvement size proofs bimodal representation minimal worth pay expense trial error global representation algorithm 
says bimodal representation achieves near optimal results fragments order logic experiments 
effective reconstruction algorithm improve global representation algorithm search best order solving constraints application separately 
experiment feature partly require special notation encode representation order constraints solved visual inspection results bimodal algorithm suggests left gained complex algorithms 
order constraint solving important constant usually change order arguments type constant declaration matches optimal order 
possible general important order mention hypotheses derivation rule 
dependency context bimodal representation algorithm disadvantage want system generate lf terms incrementally theorem prover builds lf representation proof gradually smaller components 
bimodal algorithm compact component known context component 
wasteful theorem prover emit fully explicit representation proofs pass bimodal representation algorithm 
need case context independent representation algorithm 
fortunately algorithm obtained simple modification bimodal algorithm making restriction ec representation directives 
achieved changing rule computing equation 
xn ensure fv ak ic ec turn chapter 
proof engineering guarantees directive ei 
obtain context independent representation algorithm just checking mode 
subterm object represented independently context possible simple representation algorithms programs generate lf terms 
note bimodal representation algorithms require input lf object fully explicit 
object missing subterms representation algorithm going omit anyway representation algorithm works 
possible implement theorem prover emits proof representations effective representation run bimodal representation algorithm compress proof sending proof checker 
conclude part dedicated proof carrying code infrastructure 
shown chapter safety policy defined fictitious interpreter verifies action performed agent 
chapter shown proof carrying code alternative enforcing safety policy means verification condition generator computes predicate valid fictitious interpreter fail run time checks 
justifies pcc infrastructure accept evidence safety valid proof verification condition predicate 
chapter describe framework encode verification conditions proofs relatively small simple logic independent proof checker validate 
part ii show couple tools code producer generate annotations proofs required satisfy pcc code receiver 
part ii proof carrying code tools second part dissertation describe pair tools code producer accomplish share attributions pcc system 
chapter describe special class safety policies type systems 
type safety policies possible generate required loop invariants completely automatic manner 
describe design touchstone certifying compiler compiles optimizes programs written type safe subset programming language generates loop invariants required vcgen 
chapter describe theorem prover order logic sufficiently powerful prove verification conditions arising output touchstone compiler capable generating proofs verification conditions lfi format required pcc proof checker described chapter 
chapter touchstone certifying compiler part dissertation describes detail infrastructure proof carrying code consisting safety policy implemented means verification condition generator code specifications proof checker 
components shown interrupted lines 
components shown solid lines part code producer 
certifying compiler code 
vcgen vc prover proof spec 
proof checker interaction pcc tools shown continuous lines pcc infrastructure shown interrupted lines 
shown successfully checked proof verification condition guarantees verification condition valid turn guarantees code adheres safety policy 
pcc infrastructure simple easy trust automatic 
difficult tasks delegated code proof producers 
difficult task writing code safe generate code annotations consisting loop invariants loops function specifications local functions 
difficult task prove verification condition produced verification condition generator 
chapter describes method generating annotated code means special compiler 
chapter describe theorem prover capable generating proofs verification conditions 
chapter 
touchstone certifying compiler difficult tasks facing code producer important generation code annotations 
chapter starts general discussion loop invariants focussing difficult practice find appropriate invariants 
discussion hints restricting safety properties checked type safety problem generating loop invariants simplified considerably 
section discuss detail type safety particular type safety policy code series examples showing common safety policies expressed types 
actual description touchstone certifying compiler starts section discussion subset programming language compiled touchstone 
section revisits issue automatic generation loop invariants time concrete case type safety touchstone subset main body chapter section discuss turn common optimizations show adapted certifying compiler 
chapter ends discussion section software engineering benefits certifying compiler approach 
note chapter entire part dissertation targeted narrow application proof carrying code safety properties checked limited type safety 
numerous restrictions imposed chapter purpose achieving automation proof generation taken necessary limitations underlying proof carrying code infrastructure 
basics loop invariants challenges facing code producer generation code annotations 
second generation proof 
shall see systematic method discovering annotations valid sufficient proving safety go reasoning steps theorem prover prove verification conditions 
suggests task generating annotations difficult theorem proving task 
illustrate point discuss problems discovering loop invariant proving verification condition generic program fragment shown loop return 
go loop program fragment contains single loop variable initialized expression updated value expression loop termination condition predicate assume precondition fragment predicate pre 
basics loop invariants postcondition predicate post body loop shown ellipses line safety predicate annotations code producer responsible example loop invariant inv set modified registers loop starting line 
trivial compute 
case singleton set 
try infer loop invariant useful compute verification condition symbolic evaluation algorithm shown 
result follows vc pre inv inv post inv important points notice precondition assumed predicate invariant assumed loop body code loop 
notice modified variable quantified assumption value body loop specified inv 
invariant condition broken separate predicates shown pre inv post pre inv pre inv pre inv inv predicates require invariant sufficiently strong implies safety loop body postcondition safety code loop code existed 
strength conditions invariants summarized predicate inv pre post invariants strong correct defined conditions 
loop invariant correct holds time execution reaches loop 
predicate requires invariant holds time execution reaches loop body predicate requires invariant preserved arbitrary iteration loop 
predicates valid simple inductive argument see invariant hold arbitrary number iterations 
strength conditions correctness predicates reduced easily simple condition 
note strength conditions correctness conditions somewhat antagonistic invariant occurs opposite sides implication 
illustration fact invariant true satisfies correctness conditions strength conditions predicate false opposite behavior 
means right chapter 
touchstone certifying compiler invariant chosen carefully strong weak 
problem discovering right invariant undecidable general 
practical instances acceptable invariants discovered iterative methods interpretation cc starting invariant strengthening satisfies correctness conditions 
important realize algorithm inferring loop invariants posses means prove implicitly conditions 
means able extract algorithm proof generator capable proving resulting verification conditions 
suggests difficult important discover right loop invariants prove verification conditions determine 
chapter show infer loop invariants automatically restricted class safety policies 
chapter show derive proof generating decision procedure verification conditions 
argued informally impossible give general algorithm discovering loop invariants 
impose sufficient restrictions form predicates pre post safety policy simplify invariant inference problem 
simple techniques 
insert run time checks code restrict predicates verified manner substitutions occurring invariant correctness conditions pose problems 
consider run time checking method 
purpose assume predicates post implemented programming language agent code means conditionals post fact conditionals need strong post respectively just strong predicates provable pre post post pre rewrite program additional conditionals prevent return execution loop body situations postcondition safety predicate body hold 
variant resulting code shown loop go done go idle 
go loop done post return idle go idle 
basics loop invariants added conditionals lines redirect unsafe execution idling loop 
acceptable explained detail page non termination considered safe behavior 
actual implementation entering idling loop program raise exception handled runtime system 
effect added run time checks explained formally modified verification condition shown pre inv inv post post post inv due conditions verification condition provable loop invariants inv set true 
example shows run time checking simplify dramatically task inferring loop invariants proving verification conditions 
run time checking proof verification condition essentially certifies checking done properly 
case means implications provable 
excessive run time checking detracts advantages proof carrying code run time overhead discussed section code properties checked conveniently statically 
second technique simplify task inferring loop invariants restrict predicates safety policy correctness conditions reduced manner similar strength conditions 
complications due substitutions inv inv 
notice substitutions arise assignments agent program idea restrict assignments substitutions simplified 
possible restriction suggested typed high level languages assignment allowed type variable left hand side agrees expression right hand side 
restrict predicates pre post conjunctions typing declarations variables easier infer loop invariants 
example inv example simply type declaration variable written example 
typing rule assignment know inv inv valid predicates precondition valid 
section introduce type system adequate low level languages discuss detail implications type safety policies 
section show type system high level language derived programming language 
rest chapter concerned bridging gap high level language type system low level type safety policy means compiler generates assembly language annotated typing loop invariants 
chapter 
touchstone certifying compiler base types int bool 
structured types memory types mem type system type safety policies 
type safety policies section describe distinguished class proof carrying code safety policies type systems classify values stored registers memory locations 
advantages type safety policies 
extremely flexible easy configure 
type system selected interesting safety policies easily obtained simply declaring types values stored certain registers memory location 
safety polices obtained varying type system 
major advantage type safety policies interesting type systems loop invariants generated automatically certifying compiler verification conditions proved simple theorem prover 
proceed detailed discussion type safety polices useful recall terms notations introduced chapter 
pcc safety policies described series safety predicates state execution fictitious interpreter generic assembly language called sal 
purposes section consider sal machine words span bytes universe base values consists integer values represented complement notation bits 
consider addresses represented bytes memory access memory word consisting consecutive bytes 
assumptions memory value function positive multiples set functions superscripts dropped clear form context universe meant 
type safety policies described terms classification register values types type system 
illustrate concept consider types shown 
base types classify values stored machine registers individual memory locations 
structured types classify contents sequences memory locations 
memory type distinguish memory states contents typed sense defined section 
paragraphs describe informally relationship various types source level types pointers arrays 
simplest base types int bool 
value classified types valid integer value respectively valid boolean value 
class contains 
type safety policies values valid memory addresses pointing sequence memory locations storing structure type 
type called pointer type counterpart source level pointer types 
accommodate languages java modula source level pointer values include distinguished value called null introduce pointer option type written 
informally class contains values value representing null consider numeral zero 
continuing discussion base types useful examine structured types 
structured types classify contents sequences memory words 
special case sequence contains memory word 
case contents sequence base type consecutive memory words classified tuple type 
example tuple type classify sequence memory words storing sequence value type followed value type 
array structured type denotes memory words stores address array elements structured type length stored memory word 
recursive type just allows recursive entire type 
bound type variable marks recursive 
usual observations bound variables equivalence substitution avoiding variable capture apply type variables introduced recursive types 
illustrate recursive types consider common representation lists boolean values null pointer pair containing boolean list booleans 
type written type system bool 
recursive types restricted type variables occur pointer pointer option array modifier 
means things body recursive type type variable 
restriction specified precisely defining size structured type number memory locations requires 
size type written defined follows note size operator defined type variables 
type variable occurred outside scope pointer array modifier size operator defined type invalid 
returning base types class contains values valid memory addresses marking sequence memory locations storing vectors structures type 
constraint length parameter positive multiple 
informal description meaning types formalized means representation function associates closed base type subset values type 
association valid representation chapter 
touchstone certifying compiler int bool 
mod mod mem dom dom mod 
validity conditions type representations 
satisfy conditions shown 
denote valid representation write valid 
valid representation values base universe valid integers boolean value numeral zero 
pointer option value zero representation null valid pointer value 
condition ensures zero valid pointer values 
condition ensures pointer values multiples word size close memory range 
condition ensures value valid pointer different base types 
note condition required base types structured types 
condition says value array type points contiguous sequence values element type 
condition says components structured types laid consecutive memory locations 
open arrays represented memory length field base 
type safety policies address field 
condition says values pointing open arrays valid pointers base types ensure length field written writing fields 
note take extreme care involve contents memory conditions discussed far 
condition restricts contents memory 
condition says typed memory value defined addresses pointers base types furthermore contents corresponding locations typed 
condition specifies representation open arrays 
note representation function defined precisely types int bool partially int 
example rule saying int int 
rule sound allow writing integer value accessible memory location 
converse rule sound 
chapter defines general pcc safety policy having components instruction safety restrictions instructions executed conditions safety restrictions receiver provided functions called conditions partial correctness restrictions input output behavior agent functions specified preconditions postconditions 
instruction safety component described series safety predicates saferd safewr 
system call partial correctness components safety described pair precondition postcondition predicates function 
chapter predicate saferd hold safe read memory word address memory state similarly predicate safewr hold safe write value address memory state safety policy defines memory address accessible read write pointer type follows saferd iff safewr iff definition safewr surprising restrict type value written 
define safewr impossible update safely locations containing structured types dependency values components 
reconcile liberal definition safewr type safety function postcondition require mem value memory function invocation 
informally constrains memory values typed function boundaries instruction 
type safety policies defined section include memory safety 
fact stated formally proved easily condition validity chapter 
touchstone certifying compiler representations 
theorem soundness type memory safety valid representation typed memory state mem accessible memory address dom 
obvious point safety predicates depend particular representation function furthermore type system valid representation functions multiple safety policies 
property turned major advantage safety policy designer 
requiring agent code behaves safely respect valid representation functions safety policy effectively hide aspects concrete representation types expose just properties guaranteed true valid representations 
section shows examples type safety policy abstraction 
recall chapter agent function proved safe input values memory state registers satisfy precondition 
suggests simple trick enforce safety possible representation functions 
add pseudo register repr set sal registers consider current representation function passed argument agent 
agent code access register directly absence allocation representation function change invocation agent 
presence allocation trusted allocation function expand representation newly allocated value 
set sal registers regs 
rr mem repr number machine registers mem special pseudo register hold values memory 
register state sal interpreter function regs ri mem state repr register representation function 
preconditions postconditions require representation valid written valid repr memory typed current representation written mem repr mem 
additionally require contents various registers certain types current representation 
explained chapter safety predicates part safety policy directly proof carrying code infrastructure 
useful define formally safety policy prove soundness proof carrying code technique 
proof carrying code encodes safety predicate symbolic expressions logic uses set axioms inference rules verify symbolically safety predicates hold 
section describes syntax meaning axiomatization logic 
section discuss examples type safety policies 

type safety policies extensions predicates 
sizeof type expressions int bool mem ptr array pair mu extensions required order logic shown handle types type safety 
logic type safety order express symbolically predicates involved type safety policy extend fragment order predicate logic shown set type expressions pair additional predicates shown 
predicate symbolic notation representation predicate sizeof valid 
type expressions mimic language types defined 
note recursive type uses higher order representation techniques handle bound type variable 
model section set valuation function mapping type expressions types follows int int bool bool ptr 
array pair mu extend validity relation predicates follows iff note validity typing predicate respect representation function technically typing predicate refer representation function 
simplify notation change typing predicate assume particular logic representation function arbitrary valid representation 
discussed chapter validity verification conditions involving types typing predicates verified directly derived set axioms inference rules 
rules consist axiomatization order logic equality chapter 
touchstone certifying compiler pointer types ptr saferd read mem ptr sizeof sel sel ptr pair ptr ptr write safewr ptr mem ptr sel array sel ptr pair sizeof ptr array sizeof mod array ptr types int inti memory updates auxiliary bool true mu mu mu null bool false bool bool bool ptr mem ptr sizeof upd mem upd mem ptr array upd upd mem sizeof int sizeof array sizeof bool sizeof sizeof sizeof pair sizeof ptr sizeof type safety axioms 
sizeof 
type safety policies shown type specific rules shown 
set rules constant stand machine word size 
set inference rules shown split parts 
part rules concerning pointer types 
rules read write say addresses pointer type necessarily pointer base types safe read write operations 
rule says non null pointer options valid pointers 
rules inferring types values read memory 
rule sel corresponds condition pointer base types rule corresponds condition pointers open arrays 
note condition hypothesis sizeof ensures rules apply time 
rules correspond condition 
rule section allows breaking array series pointers specified condition 
section rules concerning base types 
rule shows type assembly language operators specified 
rule mu corresponds directly condition rules section correspond condition 
third section provides rules proving various memory update operations preserve typedness memory defined condition 
section specifies rules computing size representation type 
just section obligation verify soundness axiomatization 
done verifying rule arbitrary valid representation valuation functions hypotheses rule valid valid 
cases relatively easy prove validity conditions shown 
delicate cases upd rules 
illustration proofs done sketch soundness proof rule upd 
theorem soundness rule upd valid mem mem 
proof prove satisfies condition 
part condition turn 
pick 
prove 
condition 
desired follows mem 

pick 
prove 
condition infer 
required follow mem 
chapter 
touchstone certifying compiler theorem similar theorems rules axiomatization establish sound verify validity verification conditions exhibiting derivation inference rules 
section describe examples safety policies described easily type system introduced section 
examples type safety policies instructive discuss type safety policies type system introduced 
keep mind safety policy determined current representation turn restricted preconditions 
examples considered restrictions current representation valid 
recall agent behave safely valid representation matches precondition particular restrictive representation matches preconditions 
representation restrictive representation closed types 
restrictive valid representation properties mem seen unique valid representation properties 
memory access policy 
safety policy disallows memory operation outside run time stack area 
simplify presentation assume agent entry point function entry expects boolean value register 
memory access safety policy established precondition valid repr mem repr mem repr bool precondition expressed symbolically logic bool mem mem 
note fact representation valid left implicit 
valid representation matches precondition 
agent function entry behave safely valid representations safe defined 
case safety predicates saferd safewr empty way execution entry safe attempt memory 

type safety policies sandboxing 
safety policy allows read write memory accesses long memory range say starting address non zero multiple having length strictly positive multiple 
achieve effect function entry passed register array integers specified precondition valid repr mem repr mem repr int precondition expressed symbolically logic array int mem mem 
representation function valid satisfy precondition 
particular representation satisfies precondition defined follows mod int int mem int dom representation precondition satisfied register state repr representation accessible memory locations int exactly intended 
types 
example type safety policy exploits larger extent capability abstracting representation details considering representation passed argument requiring execution proceed safely valid representations 
demonstrate power abstraction consider safety policy requires agent function pass token runtime functions invokes 
token generated code receiver passed agent starts executing 
safety policy ensure means abstraction agent code passes exact token received receiver forged 
purpose safety policy designer extends type system type expressions logic base type token changing definition validity representations 
effectively hides agent information concrete representation token 
precondition entry function valid repr mem repr mem repr token chapter 
touchstone certifying compiler precondition expressed symbolically logic token mem mem 
agent code invoke runtime function runtime token received input 
precondition runtime function valid repr mem repr mem repr token restrictive representations satisfying preconditions obtained assuming representation tokens singleton set containing value corresponding representation defined follows token mem register state start agent execution repr assume agent eventually tries invoke runtime function state registers satisfying precondition runtime 
know agent function change value repr register 
repr implies member repr token 
shows type safety enforce abstraction 
wanted avoid types run time checking enforce safety policy concrete representation token restricted run time check identify value member type 
example implementation runtime type safety costly cryptographic functions detect high probability token member type 
type system described section appropriate low level languages high level languages 
section describe type system type safe subset programming language translated typing predicates defined section 
safe source language part chapter suggested safety policies inspired high level type systems simplify considerably task generating loop invariants 
section shown details type safety policy adequate low level languages 
rest chapter typed highlevel language method bridging abstraction gap high level type system low level type safety policy means certifying compiler called touchstone 

safe source language high level language considered type safe subset programming language 
notable features missing memory deallocation address operator 
features misused generate unchecked run time errors 
simplify implementation implemented source language features type safe floating point operations function pointers 
language compiled touchstone certain features standard language exceptions length operator array expressions built array bounds checking null pointer checking 
built run time checks needed ensure type safety compiled code 
purpose length operator enforce read access length component array exceptions necessary clean implementation run time checks 
core touchstone language shown 
main goal language selection process keep close possible programming language time ensure execution lead unchecked run time errors 
checked run time errors array bounds violations allowed flexible exception mechanism provided handle 
touchstone program consists series top level declarations 
function declarations global variable declarations structured type declarations 
note global variables initializer 
declarations simply associate types identifiers 
shown compiler supports complex forms declarations allowing initializers multiple declarations single type 
level types notable omissions function union types 
simplify parser type abbreviations allowed global structured types 
level expressions language constructs require explanation 
construct new typ exp exp allocates heap array consisting exp elements type typ initialized value exp 
typ structured type initializer field required 
predefined exception subscript thrown part failed array bounds check nil exception thrown part failed null pointer check 
source level construct throwing exceptions handled try catch construct 
compiler supports derived form try statement keyword guaranteed executed normal exceptional termination execution construct 
addition core constructs values compiler supports derived forms 
example lval synonym lval lval id synonym lval id 
brevity show formal type checking compilation rules selected subset programming language 
enumerate aspects compilation different usual programming language 
start compilation variable field declarations 
code generated case 
new intermediate language variables henceforth named temporaries chapter 
touchstone certifying compiler top typ id decl 
decl decls stm 
typ id exp typedef struct id decl 
decl decl typ id typ int bool typ typ struct id exp lval true false exp binop exp id exp 
exp new typ exp exp exp length binop lval id lval exp lval id stm decls stm 
return exp lval exp id exp 
exp exp stm stm exp stm stm exp stm stm break continue try stm catch exn stm try stm stm exn subscript nil syntax touchstone subset created hold values source level variables 
number temporaries needed depends type expression follows 
expression type int bool temporary required 
expression type temporaries hold length array base address 
structured type number temporaries sum number temporaries required hold fields 
example declaration struct foo structured type foo declared typedef struct foo equivalent pair declarations xa xb 
process repeated recursively types involved declaration base types 
compilation declarations discussed detail section 
compilation expressions results code computes value expression temporaries 
return type function restricted base type functions multiple return values 
fact required order compensate absence address operator programming language return multiple values function 
compilation expression length consists code compute temporaries temporary holding length moved temporary selected hold value expression 
result new expression array temporaries required represent 
result compilation case consists call allocation function provided runtime followed initialization loop 
compilation lval done stages 
stage touchstone computes 
automatic generation loop invariants set temporaries memory addresses follows 
variable set temporaries associated variable declaration compiled 
lval structured type form lval id case set temporaries memory addresses computed lval restricted hold field called id lval array pointer type form lval exp 
case value expression exp multiplied compile time constant representing size base type array 
result added variable memory address representing lval resulting memory address returned 
type lval exp base type consecutive memory addresses returned 
second stage compilation lval depends lval expression left assignment 
case memory addresses computed phase read results put set temporaries selected hold value expression 
case expression assigned compiled resulting temporaries written set addresses computed lval phase 
case set memory operations preceded bounds checks verifying array index set greater equal zero verifying index length array 
failure case set throw subscript exception mechanism discussed 
memory addresses obtained pointer array run time check inserted verify pointer value non zero 
exception nil raised 
compilation statements results code 
compilation labels maintained destination break statement continue statement current exception handler 
destinations set innermost enclosing loop destination set innermost enclosing catch statement 
compiler rejects programs break continue statements occurring outside body loops wraps body functions try catch statement aborts execution calling special run time function unhandled exception thrown 
simplifies compiler considerably means exceptions handled functions throw 
superficial discussion touchstone compilation process prepared consider issue automatic loop invariant generation 
discuss simplest general form loop invariants consider additional complications raised various optimizations code generation techniques 
automatic generation loop invariants discussion chapter suggests limit function specifications safety predicates typing predicates loop invariants just predicates equivalent type declarations modified variables loop 
obviously chapter 
touchstone certifying compiler int int bool bool int 
struct id cd ti vi typedef struct id id tn idn int int bool bool 
struct id typedef struct id id tn idn struct id ti compilation rules types variable declarations 
easy detect level source language previous section variables modified inside loop furthermore source level types 
hand section describes extension order predicate logic consisting typing predicates type system similar identical high level language 
start section discussion high level types mapped low level types 
purpose define formally compilation procedure discussed informally previous section compilation declarations types 
defined function compiles declaration source level variable list declarations temporaries 
element returned list form vi vi fresh temporary base type defined precisely section 
compilation types defined function source level type returns corresponding structured type defined precisely section 
compilation functions defined 
notice source level pointer types compiled pointer option types low level language 
notice structured types compiled recursive types 
resulting recursive types valid language restricts definition recursive types manner similar restrictions imposed type safety policy 
simplify presentation rest chapter am going consider single temporary generated compiling declaration variable furthermore am going name temporary 
allow say source level declaration compiled predicate intermediate language 
notation easily generalized case multiple temporaries correspond source level variable replacing typing predicate conjunctions typing predicates 

automatic generation loop invariants reconsider simple program shown page 
recall strength correctness conditions shown pre precondition predicate post postcondition predicate safety predicate body loop inv loop invariant predicate denotes loop termination condition 
subscript marks predicates depend pre inv post pre inv pre inv pre inv inv consider code fragment body function foo prototype foo 
tn xn returns value variable immediately loop 
function declared local variable declaration form possible return value function 
obtain forms predicate pre post low level counterpart high level type tk low level counterpart pre 
xn post 
form predicate restricting safety policy types 
mentioned part predicate source program passed type checking phase 
furthermore typing predicates constitute precondition 
typedness source program implies predicates provable 
xn 
xn facts easy see invariant inv satisfies strength correctness conditions invariant 
suggests sufficient invariant conjunction typing predicates modified variables loop 
set modified variables types known compiler means easy touchstone emit necessary loop invariants 
furthermore easy see example proving resulting verification conditions going easy 
fact true touchstone chapter 
touchstone certifying compiler performs simple code transformations 
optimizations require complicated loop invariants 
interaction code transformations necessary loop invariants explored section 
touchstone optimizations invariants absence optimizations loop invariants generated touchstone limited typing predicates modified variables loop 
furthermore remains true common optimizations code transformations 
section examine turn code transformations compiler want perform optimizing code generation 
optimization discuss additional invariants generated describe techniques infer additional invariants 
section intended guide certifying compiler writer interested finding systematic way loop invariants emitted optimization 
rest section notation refer sequence instructions verification condition predicate predicate depend variables live entrance code sequence 
example sequence return abbreviated notation post post postcondition current function written terms dedicated variable hold return value 
code transformation discussed section analyzed point view modifications generates verification condition generic fragment code 
section need series properties verification conditions stated property proved definition verification conditions section 
property 
verification condition code 
replace expression occurrences variable including assignment sequence instructions verification condition resulting sequence instructions 
resulting sequence instructions abbreviated 
prevailing argument section verification condition transformed code identical original code additional loop invariants modifications theorem prover necessary 
verification condition change explore remains logically equivalent original case additional invariants necessary theorem 
touchstone optimizations invariants prover require changes able prove equivalence 
third difficult case resulting verification condition equivalent original 
case explore additional invariants required preserve equivalence reduce problem second case mentioned 
consider code transformations starting fall case unchanged verification conditions 
starting section discuss couple optimizations additional required area loop invariants 
dead code elimination dead code elimination code transformation removes program instructions statically reachable 
common situation shown left side table code line reachable 
code vc code vc go 

obvious possibility optimizing program fragment eliminate dead code altogether obtaining code shown right side table 
table shows verification condition code optimization 
notice verification condition change optimization 
means prover able prove optimization able prove optimization additional loop invariants changes theorem prover 
verification condition generator able see syntactic features code manifestly unreachable code 
property invariance verification condition serve effective criterion correctness code transformations 
dead code elimination important optimization purpose eliminating code manifestly unreachable source program code unreachable optimizations 
fact shall revisit dead code elimination discussing redundant conditional removal section 
optimization removes conditionals proved statically take branches 
removal conditional instruction exposes branch dead code 
chapter 
touchstone certifying compiler common subexpression elimination common subexpression elimination cse program transformation repeated computation expression avoided reusing results computation 
ignore static analysis detects subexpressions eliminated 
simple representative case cse shown left table static analysis determined common subexpression 
note expression common example variable occur 
case eliminate second computation shown right table 
code vc code vc 

occur expression verification condition code optimization 
verification condition optimization 
verification condition preserved optimization cse optimization require special certification point view 
optimization suggested code resulting cse example 
copy propagation optimization discussed attempts eliminate assignment instruction 
copy propagation consider code resulting common subexpression elimination example discussed previous section 
copy propagation code transformation assignment variable variable eliminated code assignment reassignment changed replaced optimization shown table code vc code vc 


touchstone optimizations invariants assignment line eliminated occurrences code follows replaced verification condition resulting code means copy propagation optimization require special treatment 
instruction scheduling instruction scheduling code transformation reorders unrelated instructions attempt maximize utilization processor pipeline 
ignore compiler decides instructions reorder depends characteristics target architecture 
assume compiler determined beneficial lines program shown reordered 
operation valid dependency instructions case means fv fv 
code vc code vc 

verification condition code transformation equal dependency instructions 
means instruction scheduling code transformation preserves verification conditions 
register allocation register allocation code transformation required code generation phase map temporary names machine registers 
difficulty lies large number temporaries intermediate language form program uses relatively small number physical machine registers available 
temporaries introduced compiler simplify implementation expression evaluation calling conventions 
instances temporaries live short number instructions share machine registers similar temporaries 
fortunate case maximum number live registers instruction number available machine registers 
case register allocation simply renaming temporaries register names 
chapter 
touchstone certifying compiler consider simple case shown left table code vc code vc rj ri rj rj rj 
ri assume temporary occurs expressions occur code line 
case say dead register line 
means occur predicate assume aggressive register allocator allocates machine register ri hold variable line register rj hold variable line line register rj hold value code line 
note different registers allocated disjoint live ranges 
verification condition code renaming ri occur predicate equal shown right side table 
encountered code transformation changes verification condition 
recall final step verification condition generation quantifies free variables verification condition 
means resulting verification condition identical original renaming bound variables turn means register allocation change final form verification condition 
register allocators try assign machine registers non interfering temporaries temporaries live instruction assigned 
case resulting program contain assignments form ri ri coalesced simple case copy propagation 
practical programs temporaries machine registers 
case register allocator spill temporaries stack frame 
basically register allocator borrows stack frame locations difference number machine registers maximum number temporaries live moment 
constructs mapping temporaries register names spill slots 
renaming operation involved case occurrence temporary left assignment changed write spill slot occurrences right changed memory read 
fortunately verification condition generator described section designed spilling mind considers memory accesses stack frame accesses pseudo registers 
effect verification condition unchanged presence spilling 

touchstone optimizations invariants loop invariant hoisting loop invariant hoisting code transformation eliminates repeated computation part loop body modified loop body 
loop invariant computed loop starts resulted value loop body 
consider example fragment code shown left table 
consider furthermore modified variable loop occur 
loop invariant 
notation denotes code fragment performs operations safety predicate loops back loop presence loop invariant code vc code vc go 

go 

compiler notices expression loop invariant decides hoist outside loop 
purpose introduces fresh temporary hold value entire duration loop 
resulting code shown right table 
verification condition transformed loop initialization just code loop expression replaced fresh variable occur effect initialization verification condition identical code transformation 
loop invariant hoisting affect verification condition require special treatment certification purposes 
induction variable elimination basic induction variable elimination loop invariant optimization purpose replace expensive multiplicative operations body loop faster additive operations 
consider example variable incremented body loop loop invariant expression 
value computation loop invariant increases time loop 
exploited replace multiplicative computation increment 
situation shown code fragment 
chapter 
touchstone certifying compiler code vc code vc go 

go 

anticipating need modify loop invariant case verification condition resulting code uses denote new loop invariant transformed code 
verification condition simplifying assumption variable live original loop occur transformed code fresh temporary need occur invariant certainly occur predicates start assuming change loop invariant case occur 
significant difference replaced 
consider example case replacements get certainly provable provable assumptions occur 
encountered optimization changes code way new verification condition provable assumptions weak 
remedy case strengthen loop invariant adding missing assumption 
returning example difference predicates expression occurs occurs 
attempt modify loop invariant follows replace invariant new verification condition reduce subgoals shown right hand side table 
left side table subgoals original verification condition 
assuming original subgoals provable verify new ones provable 

touchstone optimizations invariants pose difficulty theorem prover fourth 
case theorem prover able apply rule congruence starting equality 
induction variable elimination optimization require additional loop invariants possibly increased capability theorem prover apply congruence rule 
form required additional invariants simple easy task modify implementation induction variable elimination emit 
redundant conditional elimination redundant conditional elimination optimization removes conditional branches outcome statically predictable 
code transformation removes redundant conditional branch instruction improving code speed unreachable body conditional improving code size 
example redundant conditional elimination consider code shown assume compiler able infer ck hold holds 
positioning conditional ck tested true conditional succeed 
compiler removes conditional instruction false branch shown code 
places loop invariant annotations predicate empty set modified variables 
resulting code shown right side table 
invariant annotation necessary simplify task theorem prover 
touchstone insert 
chapter 
touchstone certifying compiler code vc code vc go go cn go go 



cn go go cn go inv 


cn notice time verification condition altered significant way 
attempting prove new verification conditions subgoals subgoals proof original verification condition predicate cn notice predicate expresses fact conditional redundant 
predicate compiler prove order conditional removed 
need theorem prover powerful compiler terms proving predicates 
return invariant instruction introduced place conditional 
annotation missing resulting verification condition follows 
cn valid precondition original proving requires little bit power part theorem prover 
basically task prove predicate cn know theorem prover able prove predicates cn cn 
touchstone optimizations invariants predicates occurs original verification condition theorem prover able prove second just redundancy condition 
complete theorem prover problem handling predicate directly mention subgoal practical instances presence subgoal guides theorem prover successful proof 
practical experience theorem provers suggests proving tasks fail theorem provable prover exploring non productive subgoals 
situation prover helped user provided intermediate subgoals 
invariant annotations provide convenient way code producer specify subgoals theorem prover 
theorem prover touchstone compiler powerful prove predicates directly invariant annotations emitted eliminated conditionals 
conditional elimination optimization section detects redundant conditionals conditionals existing code 
optimization improved compiler employs static program analyses discover properties program obvious user provided conditionals 
section describe implementation touchstone array bounds checking elimination special case conditional elimination situation static analysis improve optimization 
array bounds checking elimination array bounds checking elimination special case conditional elimination 
targets conditionals introduced compiler check array accesses fall bounds array 
language compiled touchstone compiler obligation insert bounds checks code safe 
inserted checks eliminated proving statically array index bounds array 
want touchstone generate code comparable performance plain compilers crucial job discovering eliminating redundant checks 
discuss section approach taken touchstone eliminate array bounds checks 
show simple minded optimization special case conditional elimination discussed previously 
show static analysis improves optimization 
case focus implications required loop invariants theorem proving techniques certification purposes 
consider simple example function adds elements array integers indices multiple stride parameter 
source code function shown left side stylized form target code shown right hand side 
consistent type representation techniques discussed section source level array argument represented chapter 
touchstone certifying compiler int add int int stride int stride return length stride return add array int int go inv int int go go err go err go int return err go err compilation example array bounds checking registers hold base address hold length 
register holds integer stride parameter 
assume calling convention specifies return value put register 
note loop invariant loop starting line consists typing declarations temporaries modified loop live loop 
invariant sufficient array bounds checks lines 
see recall vcgen emits saferd predicate memory read operation 
fragment verification condition emitted lines saferd 
furthermore predicate fragment scope precondition contains assumption array int 
fragment verification condition provable read proof rule introduced section reproduced simplified form array int read saferd notice rule run time checks safety predicate array access inside array equivalent array 
important means presence arrays safety predicates consist typing declarations simplified typing loop invariants sufficient 
far attempted remove bounds checks 
attempt eliminate redundant conditional elimination optimization discussed section 

touchstone optimizations invariants dc dc dom dc foreach dom dc dc dc dc dom dc foreach dom dc dc dc dc dc raise true dc dc raise false foreach dom dc dc min dc dc dc return dc loop residue decision procedure linear arithmetic shown function compute dc dc obtained set constraints adding constraint 
proceed useful show touchstone infers validity predicate follows validity enclosing conditionals 
touchstone uses simple decision procedure inequalities form integer numeral variables 
variables fact stand arbitrary expressions decision procedure able benefit internal structure 
decision procedure fragment arithmetic pratt pra terms finding negative weight cycles directed graphs 
collection inequalities function defined pair variable names maximal value expression points satisfy equalities value bounded special symbol value 
consider behaves positive infinity added compared finite values 
touchstone implementation loop residue decision procedure computes value set linear constraints variables occurring constraints 
easily verify set constraints entails validity falsity arbitrary follows proof facts simple definition focus chapter 
touchstone certifying compiler touchstone computes dc constraints function undefined variable names 
function compute dc dc set constraints obtained adding new constraint 
function returns new value dc raises exceptions true false additional constraint provably true false respectively original set constraints 
returning example consider operation loop residue decision procedure sequence conditionals leading execution line 
constraints put form 
purpose need dummy variable zero value fixed zero 
third column table shows transformed constraints 
column shows significant values dc values shown form dc zero values 
simple example nontrivial inference loop residue decision procedure shown line table 
dc dc zero decision procedure sets dc zero 
informally means decision procedure inferred execution reaches line 
conditional constraint zero zero zero zero zero zero zero touchstone encounters condition line checks truth falsity implied current function takes conditional transforms canonical form 
checks 
check succeeds touchstone infers check line falsified enclosing conditionals 
touchstone removes lets execution fall 
far touchstone applied redundant conditional elimination saw section necessitate additional invariants changes theorem prover 
fact shall see chapter theorem prover uses complex powerful decision procedure arithmetic infer loop residue decision procedure 
redundant conditional elimination bounds check line redundant value temporary starts zero increasing 
touchstone optimizations invariants positive amount iteration 
increment guaranteed positive conditional line 
conditional proved redundant add loop invariant line conjunction 
general effectiveness code optimizations improved compiler uses static analysis infer non obvious program properties 
observed simple loop invariant analysis able supply additional loop invariants required eliminate array bounds checks 
analysis attempts discover variables modified loop body way increasing decreasing 
variables called monotone variables 
compiler collects modified variable path loop body expression assigned compiler attempts discover simple rules arithmetic written 
monotone variable 
hand exists touchstone attempts discover greater equal zero equal zero loop residue decision procedure 
note attempted conditionals scope inside loop body 
expressions assigned paths loop form greater equal zero variable declared monotonically increasing variable 
symbolic value loop predicate added loop invariant 
procedure touchstone discovers monotone variable adds predicate loop invariant 
step performed loop body scanned conditional line redundant eliminated 
consider additional loop invariants emitted part code 
assume loop invariant line interesting part generated verification condition code array bounds checking follows array int saferd see way prove saferd predicate read rule shown invariant contains conjunct 
fact exactly invariant touchstone removing array bounds checks 
note line verification condition verifies invariant correct invariant 
proving part predicate theorem prover reconstruct reasoning led touchstone infer fact greater equal zero 
advantage theorem prover compiler consider possible candidates monotone variables 
concludes discussion optimizations certifying compiler 
list possible optimizations longer number optimizations possibly discuss chapter 
touchstone certifying compiler dissertation 
section taken recipe analyzing code transformation determining additional loop invariants emitted certifying compiler 
discussion goals touchstone project demonstrate certifying compiler generate code quality comparable non certifying compilers gnu gcc digital cc 
touchstone starts disadvantage performance competition semantics safe subset mandates array bounds checks null pointer checks memory operations 
touchstone attempts minimize performance cost run time checks redundant conditional optimizations described sections 
optimizations conjunction global register allocation caching global variables registers allow touchstone generate code performance generated optimizing compilers 
detailed description experimental results collected touchstone compiler section 
course performance 
code emitted touchstone safe design provably safe theorem prover described chapter 
optimized code generated touchstone installed untrusted extensions variety environments type safety requirement 
particular application touchstone compiler generate type safe native code extensions typed languages java standard ml 
touchstone project initiated explore automatic front ends proof carrying code system 
usefulness certifying compiler concept extends environments safety untrusted code key issue 
probably main benefit certifying compiler traditional compiler certification stage consisting verification condition generation theorem proving acts effective referee correctness compilation simplifying compiler testing development 
sections shown optimization touchstone precise effect verification condition 
shown assuming verification condition provable optimization remain provable optimization 
fact simple correctness criterion compiler optimizations 
optimizations additional loop invariants required 
optimizations compiler designer put effort designing appropriate extensions loop invariants guarantee provability verification conditions 
experience benefits outweigh cost extra effort 
testing certifying compiler easier effective testing traditional compiler 
traditional case compiler writer write compile test cases 

discussion traditional case compiled output executed various data sets hoping trip compiler bug certifying compiler case vcgen theorem prover inspect code prove possible input values code type safe 
furthermore theorem prover fails prove type safety points precise place code typing predicate prove 
contrast traditional debugging compilers actual compilation bug scavenged failed execution 
example bugs register allocator instruction scheduler notoriously difficult find lead subtle errors output program tend surface sporadic program failures usually instructions past actual erroneous instruction 
furthermore low level nature output fact errors occur large programs visual inspection output quite tedious 
true touchstone certifying compiler guarantees detection compilation errors break type safety 
means errors preserve type safety code detected 
example certifier detect compiler generates code returns integer zero integer source level function 
practical experience compiler debugging suggests compilation errors sooner lead generation code memory safe type safe 
exactly kind error certifier detects 
development touchstone encountered error signaled certifier opposed large number errors caught 
question compiler correctness old compiler implementations 
published john mccarthy refers problem interesting useful goals mathematical science computation mcc 
despite large body area dyb moo mor lack technology prove automatically correctness optimizing compiler 
manual proofs rare tend verify algorithms implementations 
plus correctness proofs need redone slightest modification improvement compiler 
proving compiler correctness just means actual goal ensuring correct output produced compiler 
certifying compiler potentially practical approach goal 
verifying compiler check aspects correctness individual compilation 
ensure compiler bug free signal incorrect compiler outputs soon produced 
reduce complexity checking process touchstone try check full equivalence source target programs verifies target program certain key properties verified small amount information source program 
idea checking individual compilations verifying compiler ap chapter 
touchstone certifying compiler pears pnueli pss simpler instance non optimizing compiler signal asynchronous language programming language 
similarly cimatti implemented certifying compiler expression language loops function calls rtl language 
case kozen koz certification step simplified considerably restricting optimizations source level construct compiled pattern target code 
certifier recognize patterns check adjacent patterns assembled properly 
hand limitations optimizations simplicity certifier permit certifying compilers ambitious attempt verify just type safety target code equivalence source program 
approach certifying compiler inspired need automatic front proof carrying system 
integration pcc generality simplicity certifier important chosen alternate implementation approaches 
alternative suggested fact verification conditions emitted vcgen output touchstone guaranteed provable automatically 
incorporate parts theorem prover vcgen prove safety predicates created generating verification condition proof 
particularly practical optimizations array bounds checking elimination induction variable elimination allowed simple type theorem prover necessary 
java bytecode verifier ly viewed approach type checker typed assembly language morrisett mwcg 
illustrate point compare depth certifying compiler theorem prover java gjs compiler bytecode verifier ly 
similarity systems produce code annotated purpose enabling certification system bytecode verifier java case verify type safety 
difference certifier flexible annotation language permits verification arbitrarily optimized assembly language necessitating fewer annotations 
pcc requires annotations backward branch targets java bytecodes contain annotations single instruction 
java bytecode verifier works specially designed bytecode intermediate language typing annotations contained instruction codes 
furthermore java bytecode verifier prevents compiler doing important optimizations array bounds checking elimination global register allocation 
compilation approach resembles respects compilation strategy til tmc compiler standard ml uses typed intermediate language easily type checked achieve independent validation optimiza 
discussion tions 
til type system guarantee memory safety presence certain optimizations array bounds checking elimination furthermore register allocation phase variables registers reused hold values different types body function 
reason types dropped til compiler register allocation phase type checking possible level compiler output 
problems related register allocation solved morrisett mwcg choosing expressive type system issue memory safety til programs presence optimizations array bounds checking elimination remains problem 
chapter presents class type safety policies design certifying compiler generates necessary loop invariants policies compiling programs written type safe subset programming language 
takes care challenging tasks facing code producer wants proof carrying code system 
difficult task generate proofs verification conditions arise code annotated loop invariants 
chapter describe theorem prover powerful prove verification conditions arising output touchstone certifying compiler able emit proofs format required proof checker described chapter 
chapter proof generating theorem prover difficult tasks front code producer wishing proof carrying code interact mobile code code receiver 
difficult generate loop invariants 
accomplished system dissertation touchstone compiler described chapter 
second difficult task prove verification conditions axiomatization provided code receiver part safety policy 
verification conditions predicates extension order predicate logic application specific function symbols saferd predicate constructor express memory safety 
proof producer theorem prover order logic possibly implemented discussed literature bm cab ch det gor ors 
knowledge able prove typical verification conditions help additional tactics 
safety properties automatic decision procedures exist effective 
cases practical semi interactive theorem prover guided person deep understanding reasons underlying safety untrusted code 
usable pcc proof producer theorem prover able prove verification conditions capable generating detailed proofs 
furthermore proofs expressed particular logic axioms inference rules specified part safety policy code receiver encoded lfi framework code receiver lfi type checker verify 
major difficulty theorem prover output detailed proof form proof details generally easy transform lfi format expected receiver 
implementations pcc different theorem provers far 
primitive theorem prover suggested decision represent chapter 
proof generating theorem prover proofs lf expressions 
theorem prover uses elf pfe implementation lf 
powerful type reconstruction algorithm elf system able find lf expressions having lf type respect specified signature 
feature theorem proving loading signature encodes axiomatization logic giving elf type form pf lf representation predicate proved 
query elf searches lf term required type shows term find 
adequacy representation proofs lf theorem know term encoding valid proof furthermore term exactly form required code receiver 
advantage elf approach theorem proving trivial implement 
just need elf system give encoding logic lf signature 
note encoding provided code receiver anyway 
elf prove verification conditions emits proof exact format required pcc 
major problem elf approach theorem proving elf uses relatively simple depth search algorithm inappropriate theorem proving realistic logics 
means order approach inference rules written way order search goal directed 
cases having integer arithmetic add redundant inference rules safety policy elf find proof 
elf approach theorem proving extreme importance early validation proof carrying code technique need real theorem prover state art decision procedures theories equality arithmetic 
order able experiment easily different decision procedures different proof generating strategies chose implement version theorem prover nelson oppen architecture cooperating decision procedures implemented stanford pascal verifier extended static checking det systems 
believe proof generating techniques chapter adapted theorem prover architectures retrofitted existing theorem provers 
start discussing technical details want point ability generate proof representations theorem prover beneficial theorem prover intended front proof carrying code 
theorem prover generates explicit proof object successfully proved predicate enables user verify validity subject theorem checking proof object 
effectively eliminates need trust soundness theorem prover relatively small expense having trust simpler proof checker 
theorem prover complicated system implementing complex algorithms great practical importance rely soundness 
generated proofs proof checker great software engineering benefit lead timely discovery soundness bugs introduced development maintenance theorem prover 

nelson oppen prover architecture rest chapter structured follows 
section review nelson oppen architecture theorem prover show implementation adheres 
section describe pseudo code algorithms control part theorem prover responsible handling order logical connectives backtracking integration individual decision procedures 
section describe general interface decision procedure implement 
section show standard decision procedures congruence closure simplex adapted interface 
illustration purposes show section operation theorem prover proving simple theorem involving linear inequalities equalities 
example proof generating decision procedure show section simple decision procedure proving typing predicates arising output touchstone compiler 
chapter concluded discussion possible improvements algorithms producing proofs 
nelson oppen prover architecture section describe high level general strategy combining decision procedures theories decision procedure combined theory 
strategy proposed nelson oppen basis proof generating theorem prover described chapter 
architecture theorem prover easily extensible new theories touchstone typing theory 
informally theory consists set function symbols called free functions theory set axioms constraining interpretation function symbols 
axioms written order predicate calculus function symbols equality theory gets equality automatically having define congruence rules free functions 
illustrate concepts consider theory arrays introduced section free functions sel upd axioms sel upd sel upd sel literal atomic formula theory formula contains free functions corresponding theory equality symbol 
formula valid theory satisfied interpretation function symbols satisfies axioms set literals called hypotheses entails literal called goal goal literal satisfied interpretations satisfy axioms theory hypotheses literals 
set literals satisfiable exists interpretation satisfies axioms literals 
decision procedure theory algorithm attempts discover conjunction set literals entails literal 
chapter 
proof generating theorem prover cases decision procedure implemented satisfiability procedure discovers set literals satisfiable 
set literals entails literal set satisfiable literal negation consider theory rational numbers free symbols numerals usual axioms rational arithmetic 
consider theory uninterpreted unary function symbol function symbol uninterpreted axioms pertaining congruence axiom 
satisfiability problems theories considered separately solved long ago fourier ackermann ack 
necessary sufficient decision procedures isolated theories theorem proving goals combine literals multiple theories 
need method combine multiple satisfiability procedures combined theory 
straightforward unexpected interactions theories sight common 
illustrate difficulties provide example presenting nelson oppen solution consider set literals combined theory informally demonstrate set literals satisfiable literals middle infer literal demonstrate 
note inference steps entirely congruence rule infer 
move prove back prove 
allows detect contradiction literal declare set literals satisfiable 
example demonstrates general decision procedures interact non obvious way detect unsatisfiability 
nelson nel defines exact way decision procedures cooperate follows definition order detect unsatisfiability set literals free functions theories satisfiability procedures respectively rewrite equivalent pair sets fs ft set contains literals corresponding theory 
satisfiability procedure detect unsatisfiability set literals propagate procedure equalities variables detects 
theories convex cooperation procedure complete theory provided complete complete example taken nel 

nelson oppen prover architecture example consider nelson oppen strategy behaves set literals shown 
introduce variables stand respectively 
auxiliary variables separate set literals fq fe shown fq fe fq fe unsatisfiable isolation fq entails equality 
entails equality propagated equality variables 
fact correct propagate equality free function belong theory 
addition fe set able infer propagate equality 
turn added fq entails added fe set fe unsatisfiable 
example complete proof generating part revisited detail section 
nelson oppen strategy complete convex theories 
theory convex exists formula variables 
xn 
yn implies disjunction xi yi theories considered example convex 
theory arrays theory integer linear arithmetic convex demonstrated example entails nelson oppen architecture adapted deal non convex theories performing case split conjunction literals entails disjunction 
informally prover tries guess disjuncts holds asserts decision procedures 
lead unsatisfiability disjunct tried 
procedure correct additional technical requirements theories satisfy 
mention requirements note theory satisfies 
requirements formal proof soundness algorithm nelson nel 
structure theorem prover shown 
top level module knows break predicates order logic literals 
module chapter 
proof generating theorem prover pred proof logical control core connectives assertion contradiction dispatch command case split command command response response add split convex non convex decision decision procedure procedure structure theorem prover 
receives input predicate returns proof indication failure 
logical connectives module responsible implementing backtracking necessary proof search 
result breaking predicate literals set hypothesis literals typically obtained left hand side implications goal literal 
predicate contains multiple goals proved separately 
literals dispatch module responsible propagating decision procedures 
just example discussed decision procedures try find contradictions case return contradiction 
decision procedure discover new equalities variables case gives dispatch turn broadcasts decision procedures 
additionally non convex decision procedure discover case split special module dealing case splits 
module queried logical connectives module current goal fail 
case splits tried order logical connectives module 
modules decision procedures discussed sections 

control core theorem prover control core theorem prover control core theorem prover consists logical connectives module dispatch split modules 
part decides individual decision procedures invoked 
section describe give pseudo code algorithms modules 
handling logical connectives order proof search efficient restrict combination logical connectives prover deal described grammar 
addition absence existential quantifier major restriction fragment order logic left hand side implication contain conjunctions literals universal quantifications restricted form implication 
set literals contains equalities disequalities variables general expressions 
language expressions possible literals determined free functions theories implemented decision procedures 
restrictive fragment logic note verification condition generator emits predicates subset provided function specifications loop invariants fact true annotations emitted touchstone compiler 
goals true false assumptions true false literals 
fragment order logic handled theorem prover 
fragment proving goal directed efficient 
fragment order logic subset order hereditary harrop formulas extension horn logic 
fragments order logic admit complete sequent style goal directed proof system declarative meaning logical connectors coincides search related reading 
resulting proofs called uniform 
implementation uniform proof search logic shown pair recursive functions 
function fol main entry point 
takes predicate produces lfi representation proof input predicate raises exception failure signal find proof 
function assert helper function provides interface dispatch module 
chapter 
proof generating theorem prover fol true truei fol false raise failure fol andi fol fol fol try fol handle failure fol fol alli fol new variable fol try snapshot try assert new variable impi fol handle contradiction prf impi prf undo fol try snapshot try assert new variable raise failure handle contradiction prf contra prf undo assert true return assert true raise contradiction assert assert andel assert ander assert true dispatch split isempty sg split try raise contradiction fol sg handle failure continue definition functions responsible handling logical connectives order logic 
boxed components contain lfi terms representing proofs 

control core theorem prover get details functions say words proof representations 
described detail chapter proofs represented lfi expressions language constructors correspond directly axioms inference rules logic 
example proof conjunction denoted expression andi expressions represent proofs conjuncts respectively 
axiomatization fragment logic considered shown 
general rule consider inference rule having hypotheses ary proof constructor having name rule 
exceptions hypothetical parametric judgments representation contains fresh variable uses hypothetical judgment denote uses hypothesis 
example implication rule represented impi considered bound marks places left hand side implication assumed true 
distinguish proof objects pseudo code section enclosed boxes 
algorithms theorem prover described pseudo language exceptions 
exception raised raise statement handled try handle event statement raises exception exception consumed statement executed 
statement try guarantees run matter statement terminates normally exceptionally 
exception consumed case 
exceptions theorem prover 
exception failure raised fol function signal failed proving attempt 
exception contradiction raised decision procedures function implements case splitting signal contradiction 
exception carries proof false 
proof constructed example proof equality proof disequality pair expressions 
proof false predicate proved false elimination rules 
rules shown false falsei false back function fol returns proof input predicate 
input predicate false proof exists exception failure raised 
case conjunction conjuncts proved separately resulting proof constructed andi 
note recursive invocations fol raises exception failure proof fails 
case disjunction proof disjunct attempted 
succeeds resulting proof build left rule 
second disjunct tried 
note case fails proofs fail 
case implication left hand side asserted 
purpose new variable created stand assumed proof left hand side helper function assert called 
function passed assumption asserted chapter 
proof generating theorem prover proof 
proof right hand side attempted proof constructed impi 
account case left hand side implication contradiction 
case invocation assert function raise contradiction exception proof false 
innermost exception handler takes care case generating proof implication rule 
execution continues retract assertions purpose proving implication 
done implicitly pair calls snapshot instructs decision procedures save current state undo instructs decision procedures revert state corresponding undone snapshot 
try statement ensure assertions retracted call assert fol raise exceptions 
case literal negation asserted contradiction expected 
assertion generate contradiction case splits tried expecting contradiction 
proof fails failure exception raised 
negation operation implemented changing top level literal constructor changing equality disequality simply having unary negation predicate constructor 
function assert takes predicate proof asserts 
return result raise propagate decision procedure contradiction exception 
case conjunction conjuncts processed order 
case literal dispatcher called 
cases assertion universal quantification implication discussed require moderate amount extra machinery 
function module invoked proof goal fail 
case split module queried subgoals tried order 
subgoal accompanied function called proof transformer proof subgoal produces proof false 
section discusses detail case splits proof transformers 
proof subgoal succeeds proof transformer applied produce proof false contradiction exception raised 
proof fails exception consumed case tried 
cases successful function terminates normally 
set current subgoals viewed disjunction proved 
functions discussed described language supports exceptions adapted language exceptions making function return results indication return normal exceptional return value 
functions implemented quite elegantly continuation passing style success failure continuation 
reason need functions snapshot undo dispatch function side effects state decision procedures 
elegant implementation purely functional decision procedures state passed explicitly fol assert functions 

control core theorem prover dispatch accum foreach foreach accum accum accum snapshot split snapshot foreach undo split undo foreach definition dispatcher functions 
functions snapshot undo dispatched decision procedures instruct save undo internal state 
function fixpoint invokes decision procedures new assertions produced 
dispatcher module implementation dispatch module quite simple 
needs ensure assertions proofs broadcast decision procedures 
processing assertion decision procedure return set new equality assertions proofs 
assertions propagated back decision procedures 
process continue new assertion generated 
dispatch function implementation shown essentially fixpoint computation 
addition dispatch function dispatch module implements systemwide snapshot undo functions 
implementations simply forward messages split module decision procedures 
dispatch module module needs know decision procedures system 
handling case splits discussed section illustrated example certain decision procedures conjunction literals entail new equalities variables entail disjunction equalities 
allow decision procedures theorem prover introduce split module 
fact split module perform general chapter 
proof generating theorem prover form case split 
decision procedure prove contradiction generate new equalities variables look subgoals proved entail contradiction 
subgoals arbitrary predicates class subgoals function proof subgoal produces proof false split module function split add 
proof transformer function viewed proof hole inside filled proof subgoal proved 
illustrate general approach case splits deal disjunction equalities entailed non convex decision procedures consider disjunction example 
decision procedure discovers disjunction implicitly discovered negation subgoal proved lead contradiction 
proof transformer case shown 
outermost rule disjunction elimination rule containing hypothetical judgments marked disjuncts 
box stands hole proof subgoal plugged 
false false false split module exports functions modules 
seen logical connectives module uses isempty extract splits 
dispatch module invokes functions snapshot undo 
addition add function non convex decision procedures wish add case splits 
shows possible implementation storage manipulation splits 
main data structure stack sets splits 
purpose stack record state time snapshot 
clearer presentation stack set manipulation functions fully functional 
stack data structure held variable called splits initialized element stack containing empty set 
nonconvex decision procedures add new subgoals calling function split add subgoal proof transformer 
happens pair subgoal proof transformer added set top stack 
note function stack top just returns set top stack removing 
implementation snapshot just copy current set splits top stack pushes top stack 
undo function just pops discards element top stack 
function returns arbitrary element current set splits removes set 
purpose 
decision procedures var splits stack set pred proof proof stack push stack empty set empty add sg splits stack splits set add stack top splits sg snapshot splits stack push splits stack top splits undo splits stack pop splits isempty set isempty stack top splits sg rest set stack top splits splits stack splits rest return sg definition functions implementing split module theorem prover 
uses function set returns element set rest set 
implementation set returns added split 
completes description modules responsible control decision procedures 
section describe general requirements proof generating decision procedure particular decision procedures theorem prover 
decision procedures control core theorem prover decomposes predicates literals passes decision procedures means dispatch module 
decision procedures analyze literals passed discover contradiction new equalities variables case split 
major advantage architecture easily extensible 
add new theory write cooperating decision procedure theory plug system 
section describe general terms requirements decision procedures 
separate subsections discuss examples decision procedures realistic theorem provers 
major innovation respect nelson oppen approach decision procedures control core adapted emit natural deduction proofs predicates proved 
decision procedures theorem prover internal representation literals global expression directed acyclic graph refer dag 
dag node corresponding expression subexpression predicate proved 
node labeled expression constructor descendants arity constructor 
building dag care taken ensure common subexpressions shared 
dag chapter 
proof generating theorem prover procedure snapshot procedure undo function pred proof set pred proof raises contradiction proof interface decision procedures implement 
node corresponding expression system refer expression 
thing done assertion coming logical connectives module internalize constituent expressions dag 
assertion rephrased terms dag nodes propagated decision procedures 
internalization done dispatch module implementation right fixpoint operation initiated 
addition global dag decision procedure free maintain internal data structures 
decision procedure required implement interface shown 
functions discussed 
control core theorem prover ensures snapshot matching undo properly nested pairs snapshot undo 
intended semantics undo operation decision procedures adjust internal data structures reflect assertions chronologically matching snapshot operation 
ensures assertions properly retracted system time undo 
ways implement snapshot undo operations 
decision procedure maintain stack assertions 
time new assertion arrives considered respect assertions memorized stack 
snapshot places marker stack undo pops stack nearest marker 
simple strategy appropriate decision procedures require maintenance separate data structures undo stack 
example decision procedure described section dealing touchstone typing rules 
decision procedure style uses internal data structure records relationships current assertions 
case implementation snapshot undo involved 
possibility snapshot complete copy state internal data structures undo recreate identical state 
expensive cases unnecessary 
undo operation needs recreate equivalent state identical 
usually accomplished minor changes current state choice internal data structures wisely 
indication particular changes performed undo stored snapshot undo stack 
decision procedure implemented 
decision procedures style called incremental 
decision procedure efficient non incremental requires considerably care implementor 
examples decision procedures congruence closure decision procedure described section dealing equalities uninterpreted function symbols simplex described section dealing linear arithmetic 
main operation exported decision procedure function type shown 
function processes new assertion 
scan assertion predicate occurrences free functions theory decision procedure implementing 
assertion predicate internalized dag nodes serve convenient names subexpressions 
definition decision procedure detect contradiction case raise contradiction exception proof false detect new equalities dag nodes 
set equality assertions proofs returned case normal return 
addition detecting contradiction returning set equality assertions decision procedure generate case splits 
create subgoals proven allow decision procedure generate contradiction 
subgoal passed function proof subgoal creates proof false split add function 
decision procedure identifies subgoals logical connectives split modules decide try subgoals 
fact subgoals tried goal fail 
sections describe main decision procedures implementation proof generating theorem prover 
handling equality congruence closures central theory implementation nelson oppen architecture theory equality 
decision procedure system able discover manipulate equality predicates 
free functions theory uninterpreted function symbols 
axioms theory shown 
inference rule function symbol system 
theory shown decidable ackermann ack 
problem finding equality consequence equalities tackled points view 
downey sethi tarjan dst view variation common subexpression problem kozen koz word problem finitely algebras 
decision procedures shostak sho nelson oppen 
problems reduced problem constructing congruence closure relation graph 
equivalence relation set terms say terms 
tn 
congruent ti related 
closed congruences congruent terms related chapter 
proof generating theorem prover en 
en 
congr false falsei axioms theory equality 
congruence inference rules function symbol system 
congruence closure relation smallest extension equivalence relation closed congruences 
see equality follows set equalities construct congruence closure check see sense algorithm computing congruence closure set equalities base decision procedure section describe implementation congruence closure algorithm adapted proof generating decision procedure nelson oppen theorem prover 
implementation inspired shown nelson nel emphasis efficiency simplicity proof generation aspect proving 
addition dag congruence closure algorithm uses internal data structures described functions defined nodes 
node dag decision procedure maintains root equivalence class root 
equivalence class denoted class defined set nodes having root parents set nodes arguments equivalence class forbid set nodes specified equal means disequality assertions 
addition functions decision procedure maintains stack assertions equalities disequalities proofs 
data structure called undostack plays roles 
stores information enable decision procedure undo changes internal state requested dispatch module 
second assertions undostack produce proofs equalities propagated congruence closure decision procedure proofs required contradictions 
describes main invariants maintained implementation congruence closure 
invariant cc just says root equivalence class belongs class 
remember equivalence class defined indirectly set elements value root 
invariant cc says entry undostack equality disequality assertion proof 
implementation store additional information undostack purpose 
decision procedures cc 
root root root cc 
undostack representation proof equality disequality dag nodes cc 
root root exist 
ai ai pf undostack ai ai pf undostack 
cc 
parents root exist class arg cc 
class forbid root exist class class undostack 
invariants maintained congruence closure decision procedure class shorthand notation set root root 
invariant cc says nodes equivalence class equivalence relation induced equality assertions undostack 
part invariant ensures completeness representation part ensures soundness 
invariant cc says parents root node exactly elements argument equivalence class node 
note parents function specified root nodes 
parents set speedup search node pairs congruent due changes equivalence classes 
invariant cc specifies forbid function equivalence class contains member class classes specified equal undostack 
just parents forbid function specified root nodes property class individual node 
shows core implementation congruence closure 
core consists main entry points merge merge equivalence classes response external equality assertion congruence discovered forbid equality equivalence classes response external disequality assertion 
helper function detects propagates congruences functions generate proofs 
function merge called nodes proof equality purpose combining equivalence classes 
root combined class root implementing undo operation 
chapter 
proof generating theorem prover second input class 
function checks class forbidden merged 
contradiction raised proof false produced helper function 
note symmetry equality second invocation convert proof proof 
contradiction checks unsuccessful series changes internal data structures entry undostack record changes 
forbid set new class updated parents set new class computed 
input class re rooted new root 
result merge function set assertions proofs 
assertions combined classes equal 
assertion add congruences discovered function 
function receives sets nodes find pair congruent nodes 
nodes congruent proof equality constructed congr rule merge function called recursively combine equivalence classes 
note merge changing internal data structures 
external disequality assertion encountered function invoked nodes equal proof disequality 
time contradiction nodes equivalence class 
case contradiction raised proof false constructed false rule proof equality disequality nodes 
proof equality nodes equivalence class constructed helper function 
invariant cc significant 
guarantees nodes equivalence graph path undirected graph defined equality assertions undostack 
path leads immediately proof equality build transitivity proof equality individual hops 
occasionally symmetry rule adjust order variables individual hops 
function creates proof false proof equality nodes forbidden equal 
rely invariant cc find disequality assertion undostack responsible contradiction 
series equalities constructed contradict disequality undostack 
note congruence closure convex decision procedure need create case splits 
proven nel similar implementations congruence closure algorithm sound complete decision procedure addition functions shown decision procedure implement snapshot undo function 
typical implementation snapshot place special marker undostack undo knows operations undo 
places internal state changed 
merge function equality assertion put undostack function disequality assertion pushed undostack 
general rule 
decision procedures merge node node proof proof root root class forbid root raise contradiction class forbid root raise contradiction undostack stack push undostack forbid root forbid root forbid root pa parents root pb parents root parents root pa pb foreach class root root return pa pb pa node set pb node set pred proof set accum foreach pa pb head head root root congr head arg arg 
argn argn accum accum merge return accum node node proof root root raise contradiction falsei undostack stack push undostack forbid root forbid root node node 
invariant cc pf ai ai pf undostack pf pf ai ai pf undostack return pf pf 
pf pf 
class forbid root class class undostack return falsei main algorithms defining congruence closure decision procedure 
chapter 
proof generating theorem prover easily implementation set union obtained representing sets circular lists swapping contents cdr cells 
operation undone swapping contents cdr cells 
kinds entries undostack enriched additional information undo operation 
illustration purposes section show behavior congruence closure decision procedure case concrete example 
nelson nel shows complete implementation congruence closure complete undo operation 
basic trick recommend implement sets circular lists 
representation supports scanning required forbid parents sets advantage union operation done simply swapping contents cdr cells shown 
operation called splicing easily undone swapping cdr cells incidentally exactly corresponding nodes mentioned undostack assertion 
complete section congruence closure algorithm mention complexity determined method discover congruent pairs nodes 
function shown uses nested iteration predecessor lists yielding algorithm complexity number nodes dag 
parents lists maintained sorted lexicographically obtain algorithm complexity log 

decision procedures handling linear arithmetic simplex theory integers free functions containing integer numerals usual arithmetic comparison operators 
notational convenience allow multiplication integer numerals 
decision problem essentially problem deciding linear inequality consequence inequalities 
equivalent general linear programming problem instances problem arise program verification differ significantly arising operations research verification researchers devised special new methods modified traditional linear programming methods handle cases encountered practice 
example pratt pra reports inequalities encountered program verification simple form integer numeral variables 
decision procedure fragment obtained detecting negative cycles weighted directed graphs example section part touchstone optimizer 
shostak sho generalizes method inequalities form ax integer numerals 
decision procedures fragment described nelson nel 
variety decision procedures general case linear inequalities 
theorem provers fourier motzkin elimination method sup inf method due bledsoe ble variations simplex linear programming algorithm nel 
section describe variant simplex linear programming algorithm proof generating decision procedure linear arithmetic 
emphasis presentation proofs generated internals algorithm 
variant simplex proof generating component described detail nelson nel 
curious reader find implementation details missing 
decision procedure nelson oppen theorem prover linear arithmetic decision procedure isolates incoming assertions subexpressions involve free functions integers integer operators 
letter denote expressions built variables numerals additive operators 
addition notation shorthand way addition mapping variables integer numerals write denote integer value obtained evaluating variables replaced value 
decision procedures pratt loop residue decision procedures kinds inequalities arising practice program verification integer case handled quite satisfactorily combination decision procedure rationals heuristics 
chapter 
proof generating theorem prover write mapping variables integers 
internal data structure simplex algorithm tableau depicted form matrix shown 
ti ti tij tic 
tr tr trc entries tij rational numbers 
column rows columns owned expressions 
expression owns row denoted expression owns column denoted 
simplex tableau described far encodes linear relationships owning expressions 
actual encoding input assertions means restrictions values owning expressions take 
kinds restrictions simplex maintain 
row column restricted means owning expression take values greater equal zero restricted case owning expression equal zero 
explained nel reason restricted rows columns simply deleted tableau support inexpensive implementation undo operation 
turns maintaining restricted rows columns useful proof generation 
describe operation simplex algorithm indirectly means set invariants stated invariant 
understand invariant consider tableau encodes set inequality constraints inequality restricted owner 
fact invariant says restricted owner proof positive 
actual tableau entries encode linear relationships owners involved 
number variables owners rows columns invariant set variables current set literals known set points satisfy set linear inequations convex polyhedron called solution set 
long polyhedron non empty set inequations satisfiable coefficients rational numbers 
necessarily mean satisfiable empty polyhedron means inequations satisfiable means simplex method sound complete integer inequalities 
convention nel current state tableau represents unique point called sample point expressions columns value zero 
means expression owns row value ti sample point 
invariant operation simplex decision procedure relies fact 
decision procedures moment sample point tableau solution set 
motivation invariant 
restricted row owner expression value zero solution points 
rows columns detected notion maximized row defined 
definition tableau row said manifestly maximized ti non zero entries restricted columns negative restricted columns 
intuition definition linear combination restricted expressions restricted negative factors guaranteed zero 
owner row definition expression 
account constant entry row see maximal value take solution set ti 
restricted row maximized zero means take value zero safe restricted row 
restricted restricted columns non zero entries row mechanism rows columns restricted invariants 
invariant variables occurring current set literals exactly row exactly column 
row 
simplex tableau positive integer constant mi integer 
mi row restricted restricted restricted proof 
refer proof proof 
similar fact holds restricted columns 
row restricted ti row restricted ti non zero tij columns restricted column restricted exists restricted row tij tik row called column chapter 
proof generating theorem prover main operation performed simplex tableau pivoting gaussian elimination 
pivot row column tuv means rewrite contents tableau expressions row column swapped 
invariant invariant row extract value terms columns 
rows rewritten replacing computed expression carrying required algebraic simplifications 
new values tableau entries shown 
note owners row column swapped 
ti tu tiv tuv row tu tuv 
column tij tiv tuv tuv 
tiv tuv tuv core simplex decision procedure concerned choosing pivots 
combinations rows columns valid pivots lead better performance 
definition validity pivots 
algorithm choosing valid pivots described detail nel 
definition pivot valid 
tuv 
row column restricted 
tableau pivoting satisfies invariant 
main significance valid pivot operation preserves invariant 
part preserved trivially set row column owners change pivoting 
preservation invariant verified simple tedious algebraic manipulation 
surprising criterion definition pivoting operation 
invariant holds trivially definition valid pivots parts invariant true restricted rows left untouched pivoting restricted column invariant know tiv zero 
operation preserve invariant 
decision procedures arith constant greater equal kernel rules arithmetic introduced section 
permutation columns restricted columns change relative order 
proceed discuss implementation simplex decision procedure establish set axioms inference rules simplex build proofs 
described detail section convenient deal integer numerals directly means unary binary encoding 
means theory finitely axiomatizable directly implementable lfi 
overcome problem shown section extend lfi type reconstruction check proofs involving special proof constructors arith shown 
recall proof checker encounters proof object arith checks reduced simple algebraic simplification rules equivalently 
case proof term considered valid representation proof predicate 
similarly proof object considered valid representation proof integer numeral greater equal zero 
addition kernel proof rules define set axioms shown 
point presentation obvious simplex rules 
time concerned soundness 
rules shown top row convert various inequality literals canonical form 
similarly rule convert equality inequality 
rules geq construct proof linear combination positive expressions positive factors positive 
purpose rule times length linear combination geq terminate chain 
remaining rules top level rules simplex produce proofs false case contradiction proof equality variables 
rules sound form somewhat strange 
carefully formulated fit precisely situations simplex needs 
verify rule falsei sound notice sequence inequalities 
contradicts hypothesis 
note rule eqi group hypotheses proves second valid infer 
having settled axiomatization theory proceed description simplex algorithm 
chapter 
proof generating theorem prover geq falsei false proof rules simplex decision procedure uses construct proofs 
shows skeleton simplex decision procedure 
entry point processes literal proof returns set equality assertions proofs 
finds contradiction raises contradiction exception proof false 
step performed decision procedure convert literal canonical form 
note proof adjusted accordingly invariant holds simplex invoked 
invariant function simplex invocation simplex prf prf proof 
result invocation set equalities proofs contradiction exception raised proof false 
execution function simplex starts adding new row tableau owned expression row entries computed invariant holds 
expression variable owns column value added column added row 
variable owns row owned row added added row 
sum expressions added row contain sum entries rows corresponding expressions 
execution proceeds simplex checks added row identical existing row zero entry equal column situation added row deleted row considered owned situation column pivoted row position continue case equal rows 
step execution simplex represent assertion greater equal zero 
explained done making row owns eqi 
decision procedures case restricted 
row restricted done 
invariant allows restriction ti zero 
simplex tries series valid pivoting operations increase value tr zero 
choosing pivots valid achieve required effect fewer steps delicate issue implementation simplex 
possible algorithm choosing pivots shown nel 
situation value ti positive pivoting row maximized value zero 
earlier discussion maximization means zero contradicts proof greater equal zero 
case contradiction exception raised 
proof false generated function definition shown discussed section 
fact sample value row increased zero implementation simplex proceeds making restricted row setting corresponding proof 
simplex detects new rows columns maximized zero restricted 
reordering step necessary preserve invariant turn necessary prove easily certain proof generating procedures terminate 
step execution simplex concerned discovering new equalities owner expressions 
owners rows equal entries rows equal possibly restricted columns 
similar situation involves owners row column entries row zero column possibly non zero entries restricted columns 
situations equality expressions follows invariant 
reasons explained detail nel algorithm ensures owners zero solution set restricted situations ones owners equal 
guarantees simplex discovers equalities propagated 
situations proof equality obtained auxiliary function described 
concludes description part simplex decision procedure concerned discovering new equalities contradictions 
turn novel proof generating aspect decision procedure 
defining property proof generation simplex required information exists tableau mapping proof restricted owners proofs 
proof generating components simplex shown 
describe functions means input output invariants 
function create proof false proof owner maximized row greater equal zero row maximized negative value 
chapter 
proof generating theorem prover prf simplex prf prf simplex prf prf simplex prf prf simplex prf prf prf prf simplex prf fill row mtr row identical row row zero pivot column row row restricted return try increase value ti valid pivoting row maximized ti raise contradiction prf restricted row proof prf foreach restricted row maximized restricted row reorder columns come changing relative order restricted columns foreach restricted column restricted column accum foreach rows differing restricted columns accum accum foreach row non zero restricted columns column restricted tij accum accum return accum core simplex decision procedure 

decision procedures invariant function invocation prf row maximized negative value ti prf proof 
function implemented terms helper function described proof rule falsei 
note numeral falsei inference rule schema instantiated mti positive integer constant returned 
function called produce proof owner maximized row equal ti 
precisely behavior described invariant 
invariant function invocation row maximized value ti 
return invocation triple prf positive integer numeral mti integer mti 
prf proof 
discuss detail implemented consider implementation terms function produces proof row owners equal entries differ restricted columns 
invariant describes input state function 
invariant function invocation expressions represented tableau correspond rows zero possibly restricted columns 
trick case create new temporary row owner 
invariant new row maximized zero safely invoked 
row rewritten similar reasons invoked 
results invocations construct hypotheses needed rule eqi 
complete discussion proof generation simplex need discuss implementation satisfying invariant 
purpose introduce notion map expressions rational numbers 
convenient view map sequence pairs described bnf form empty map 
convenience define operation maps equivalent expression mapping mapped old mapping overridden 
chapter 
proof generating theorem prover return falsei arith mti mti fill row coefficients prf fill row coefficients prf return eqi arith prf arith prf foreach tik tik foreach tik tik scm ti return row invariant restricted tij tik tik restricted tij foreach tik tik tij foreach tik tik tij return return geq return mf proof mf proof generating components simplex decision procedure 

decision procedures definition map valid conditions holds 
dom restricted expressions proof 
proof referred proof 
dom 
intuition implementation maximized row written linear combination negative coefficients restricted expressions 
function computes coefficients valid map exists integer products mti dom integers mti dom note row maximized non zero entries restricted columns 
columns entries negative added directly map 
entries positive restricted entries added map means helper function 
function scm shown called compute smallest positive common multiple denominators entries ti function called construct actual proof 
invariant function invocation restricted column positive rational factor denote resulting valid map exists integer mf dom dom idea implementation restricted column written linear combination negative factors restricted expressions 
find linear combination search row express value column invariant row 
note recursive invocation guaranteed terminate stated invariant 
function simply builds proof negation linear combination negative coefficients restricted expressions greater equal zero 
returns proof negated expression 
completes description implementation proof generating decision procedure linear arithmetic simplex 
case congruence closure proof generating component decision procedure complicated contradiction generating component 
actual implementation proof generating part third decision procedure 
better understanding congruence closure simplex decision procedures interested reader encourage read section revisit decision procedures showing operation context simple theorem proving task 
chapter 
proof generating theorem prover example congruence closure simplex illustrate cooperation congruence closure simplex decision procedures consider example introduced chapter 
predicate proved case simplify presentation abbreviations prover invoked fol 
definition fol implication new variable created stand assumed proof left hand side implication follows pf function assert invoked left hand side 
definition assert shown leads invocations dispatch function follows dispatch andel andel dispatch ander andel dispatch ander assume follows dispatch modules invokes congruence closure decision procedure simplex decision procedure 
responding invocation dispatch modules creates nodes dag corresponding subexpressions literal involved 
congruence closure forbids merge class class 
resulting state shown nodes solid lines belong dag interrupted lines mark equivalence relations forbid relations belonging congruence closure 
current value congruence closure undostack andel andel 
literal asserted simplex introduces tableau expression 
resulting simplex tableau shown 

decision procedures simplex function invoked free function belong theory contradiction detected invocation initiated 
dispatcher adds dag node labeled 
passes assertion congruence closure algorithm effect state algorithm 
simplex receives assertion recognizes constructor invokes simplex ander andel name associated expression 
simplex adds expression tableau tableau shown 
simplex tries increase sample value pivot row 
simplex restricted state shown sets proof ander andel simplex tries success restrict rows columns propagate equalities 
invocation started dispatcher adds necessary nodes dag shown 
congruence closure find new congruences leaves state unchanged 
simplex encounters new literal adds variable empty column variables row column processes expression going call invocation simplex ander adding row corresponding tableau shown 
simplex tries increase sample value past zero purpose pivots resulting tableau shown 
sample value zero pivoted anymore cycling encountered states simplex restricted row proof ander literals left hand side implications asserted contradiction 
logical connectives modules continues evaluation function fol top level implication trying prove right hand side 
fol invoked results new proof variable created negation goal literal dispatcher invoked follows dispatch pf chapter 
proof generating theorem prover state history congruence closure simplex decision procedures 

decision procedures state history congruence closure simplex decision procedures ii 
chapter 
proof generating theorem prover state history congruence closure simplex decision procedures iii 
dispatcher expands dag shown passes assertion congruence closure 
congruence closure inactive 
simplex decision procedure invoked simplex simplex tries add expression tableau discovers immediately expression owns column 
brings row pivoting 
resulting tableau shown restrictions explained 
note state sample value increased anymore restricted proof simplex discovers restricted maximized zero restricted columns 
state simplex tableau shown 
restrictions enable simplex discover equalities row zero restricted columns column 
equality interesting involve expressions exist original predicate introduced simplex purposes 
produce proof simplex invokes 
definition shown 
results new temporary row created represent 
current columns row zero column corresponding 
function builds map needing call positive coefficients new 
decision procedures row 
map returns prf geq ander andel dx row rewritten encode meaning coefficient column corresponding zero 
invokes compute map column 
result 
return values prf geq ander dy final proof constructed dx eqi arith dx arith dy equality discovered simplex propagated congruence closure decision procedure function merge dx called 
undostack andel andel dx 
singleton classes merged procedure discovers congruence 
produce proof congruence need proof purpose function defined called 
simple case equality exists identical form undostack 
function terminates calling recursively merge congr dx 
call discover new equalities final state congruence closure decision procedure shown 
result congruence closure decision procedure new equality value undostack point andel andel dx congr dx equality propagated simplex leads calls simplex follows simplex congr dx simplex congr dx chapter 
proof generating theorem prover dt dt proofs simplex invoked 
simplex tries add expression tableau discovers owning row 
tries restrict row 
row pivoted simplex goes ahead restricted row shown 
proof map modified proof dt congr dx simplex asserts purpose adds tableau new row representing 
state tableau adding row shown 
simplex tries increase sample value pivots 
resulting tableau shown 
pivoted simplex restricted proof dt congr dx simplex discovers maximized zero restricted 
point simplex discovers new equalities restricted 
equalities interest decision procedure propagated 
order produce proof function called turn calls calculate linear combination negative coefficients restricted expressions 
results proof produced dz eqi arith geq proof proof proof arith geq proof proof equality propagated congruence closure results merging singleton classes turn leads discovery congruence resulting state shown 
congruence closure undostack point 
decision procedures undostack andel andel dx congr dx dz congr dz trying merge equivalence classes congruence closure algorithm detects contradiction invokes function build proof false 
searches undostack find disequality responsible contradiction finds assertion proof andel andel 
builds proof falsei congr dz andel andel function merge raises exception contradiction proof 
exception caught fol function trying prove right hand side implication 
complete proof predicate dp impi contra concludes step step example operation congruence closure simplex decision procedures 
simple example discussed global operation theorem prover quite complicated 
demonstrates difficult write single decision procedure handle combination theories interest 
rely clean separation decision procedures provided nelson oppen architecture develop reason decision procedure time 
section describe decision procedure time handling typing predicate arise verification conditions programs generated touchstone compiler described chapter 
handling touchstone typing rules want theorem prover able prove type safety output touchstone certifying compiler module handles inference rules shown 
typing module prove predicates forms saferd safewr 
section sketch proof generating decision procedure typing predicates 
convex decision procedures considered typing decision procedure extensive case split capability theorem prover 
chapter 
proof generating theorem prover internal data structure typing decision procedure stack typing assertions 
stack pushed typing assertion dispatched popped execution undo operation 
addition typing decision procedure access data structure 
typing decision procedure simply collects stack typing assertions dispatched 
encounters negation forms predicates prove 
case tries prove direct form asserted literal accumulated typing assertions succeeds generates contradiction asserted negation 
proofs discussed section refer axiomatization shown 
trying prove memory safety predicates form saferd form safewr decision procedure rules read write attempt find type proof ptr 
subgoal proved helper function discussed section 
form assertion proved 
type base type ptr type handled straightforward manner syntax directed rules shown types section 
simplify typing decision procedure recursive type mu encountered replaced mu rule mu 
order handle rules related sizeof predicate constructor typing decision procedure contains procedure sizeof structured type computes integer constant proof predicate sizeof 
helper functions succeed trivial arithmetic rules expression rewritten respectively constant 
possible functions abort result interpreted falsehood conditional context 
helper functions implemented scanning node corresponding order handle rules shown memory updates section typing decision procedure uses function shown top 
function tries rules upd prove modified memory state typed 
purpose finds types update address proved type ptr 
done helper function return value list elements form ptr list subgoals proof ptr possibly referring proofs subgoals 
list subgoals proof required split add function described page 
element returned list scanned base type verified sizeof rule upd tried 
open array type rule tried 
rules tried registering 
decision procedures split module theorem prover list goals named proof upd mem 
remaining detail handling rules shown section labeled 
rules handled helper function pseudo code description shown 
trying find types ptr tries expressions rewritten helper function collects types assumptions case form sel rules sel 
pseudo code helper function shown 
returning type array type rewritten sizeof array rule tried 
getfield helper function called index proof ptr 
proof constructed array rule proofs subgoals result successful execution getfield type offset structured type proof ptr 
pseudocode function getfield shown bottom 
return getfield function adds result list assertion ptr original list goals proof obtained congruence typing predicate 
cases analyzed type pointer option pointer type 
cases getfield called find base type open array type points 
important observations related typing decision procedure 
decision procedure complete 
instances prove predicates derivation logic 
take example predicate array int mod sel upd ptr int predicate arises compiler generates code bounds checking index stores address indexed array element location array 
loads back pointer tries pointer integers 
predicate provable mccarthy axiom logic saying sel upd 
predicate proved decision procedure outlined section tries rewrite term sel upd trivial axioms arithmetic 
solution completeness problem ensure helper function succeeds provable possible significantly expensive 
fortunately predicate arise agent produced touchstone compiler typing rules contents element chapter 
proof generating theorem prover upd foreach ptr da sizeof ds split add mem upd da ds upd split add mem array da foreach foreach de array sizeof ds getfield array de ds mod add ptr constant getfield de add ptr ptr constant getfield de add ptr foreach assumption add sel foreach ptr da sizeof ds add mem sel da ds foreach ptr da add array sel mem da getfield sizeof ds return pair sizeof ds return getfield return getfield ds return false functions proving touchstone typing predicates 

discussion array integers pointer 
addition touchstone optimizer eliminate bounds checks index value loaded memory 
optimization added compiler improve theorem prover recognize cases prove verification conditions arise 
discussion chapter shown known decision procedures modified produce proofs natural deduction style verified simple proof checker 
shown proof generating decision procedures integrated modified nelson oppen architecture modular theorem prover 
allows easy extension theorem prover decision procedures various logics 
simplify presentation chapter low priority various performance aspects proof generation process 
rest section discuss briefly optimizations determined effective reducing running time theorem prover size generated proofs 
possibility improving running time theorem prover modify split module discussed section case split tried 
note definition split snapshot shown copies current set splits 
necessary function invoked current set backtracking mechanism built function shown ensures entire set tried needed 
means marker set splits record invoked copy sets invoked 
mechanism implemented relies fact subgoals proved final proof 
consider case case split subgoal fails 
proofs generated preceding subgoals needed 
suggests worth generating proofs lazily needed 
implementation generating proof generate closure invoked produce proof 
closure structure records minimal amount information module responsible generating proof easier construct proof 
especially true decision procedures proof generation non trivial task simplex 
note internal data structures various decision procedures change moment subgoal proved closure created moment closure invoked proof generated 
provided undo operation invoked information needed proof generation 
discuss couple optimizations meant reduce size proofs generated theorem prover 
obvious opportunity proof optimization chapter 
proof generating theorem prover tion trivial uses contradiction rule 
beneficial theorem prover proves literal assuming negation generating contradiction 
implemented proof optimization scans proof eliminates uses contradictions 
effect size proofs reduced 
opportunity easy optimization elimination trivial uses rule typing decision procedure 
uses arise typing decision procedure indiscriminately wraps typing derivation congruence rule 
optimization implemented post pass changing typing decision procedure 
consider example proof transformations shown falsei false contra left hand size instance trivial contradiction 
order prover literal theorem prover asserts negation case contradiction generated obtaining proof contradiction proof replaced typing decision procedure generates proofs form tries contradict negation goal proving goal 
assumption deeper proof false simple exercise write proof transformation eliminates contradiction direct proof 
right hand side see elimination trivial rule 
concludes part ii dissertation 
discussed useful tools proof carrying code producers 
touchstone compiler translate agents written type safe subset programming language optimized machine code annotated loop invariants function specifications 
undecidable task possible case specifications restricted typing predicates source language typed 
second tool described theorem prover powerful prove verification conditions capable generating proofs 
theorem prover touchstone compiler acts effective referee signaling compilation errors manifested unsafe assembly language output 
theorem prover proved invaluable debugging maintaining compiler 
third final part dissertation discuss various experiments designed performed gain experience proof carrying code 
part iii evaluation proof carrying code part dissertation experiments done proof carrying code purpose gaining experience technique understanding significant practical 
discuss sets experiments 
designed compare proof carrying code techniques ensuring safety untrusted code 
set experiments designed reveal practical significance various costs proof carrying code starting cost certifying compilation theorem proving cost storing checking proofs 
purpose final set experiments validate effectiveness proof optimizations discussed chapter 
chapter experimental validation proof carrying code chapter presents experimental evidence proof carrying code practical approach safe execution untrusted code 
order gain experience pcc compare approaches code safety performed series experiments safe network packet filters 
experiments discussed detail section demonstrate run time performance pcc agents order magnitude better obtained techniques 
section discuss set experiments touchstone certifying compiler produce proof carrying code type safety policy 
part experiments measure various costs proof carrying code starting cost certifying compilation theorem proving cost storing checking proofs 
final set experiments discussed section designed gauge practical benefits gained implicit representation proofs various proof optimizations discussed chapter 
experiments show savings due lfi representation proofs plain lf representation high orders magnitude making difference impractical proofs megabytes manageable proofs tens kilobytes 
section share observations correlation size proofs time required validate lfi type checking 
proof carrying code packet filters network packet filter application provided subroutine scans incoming network packet decides user application interested receiving 
packet filter executed kernel address space incoming packet 
chapter 
experimental validation proof carrying code effect small number accepted packets copied user address space 
packet filters supported today workstation operating systems 
mra packet filters successfully network monitoring diagnosis 
malicious buggy packet filters exploit high level privilege executed corrupt kernel internal data structures 
prevent various safety techniques including proof carrying code 
section describing safety policy implementation packet filters proof carrying code show quantitative comparisons techniques achieve similar level safety 
description experiments appeared second symposium operating system design implementation nl 
safety policy standard procedure proof carrying code kernel administrator establish safety policy packet filters 
simplify comparisons alternative techniques chosen safety policy models enforced berkeley packet filter architecture bpf mj implemented unix operating system kernels 
bpf safety policy allows filter examine current network packet write kernel provided scratch memory area 
informally safety policy requires memory reads restricted packet scratch memory memory writes limited scratch memory branches forward reserved callee saves registers modified 
rules establish memory safety termination assuming kernel calls packet filter valid packet scratch memory addresses 
bpf safety policy obtained easily type safety policy described section 
filter agent input arguments passed registers follows 
registers contain start address current packet index valid word contains address byte scratch memory area 
filter return boolean result register 
furthermore safety policy designer specifies network packets ethernet packets bytes long 
unfortunately type safety policies introduced section quite sufficient encode bpf safety policy 
need extend type system distinguish read arrays represent inspected packet regular read write arrays represent scratch memory 
say notation ro denotes read array axiomatization type safety extended appropriately 
fully compliant bpf safety policy modify vcgen disallow 
changes specification part safety policy expressed 
proof carrying code packet filters follows recall length component array type denotes accessible index int ro int bool performance comparisons techniques order experiment proof carrying code packet filters implemented typical packet filters dec alpha assembly language 
illustrate simple case packet filter programming show equivalent sal code filter 
load bytes offset extr extract bytes offset failure code cond compare ether ip return extr expression operator supported directly dec alpha instruction set extract sequence bytes starting index byte expression typical packet filter accepts rejects network packets examining contents various fields packet header 
location valid values fields defined network protocol standards 
example ethernet packet bytes located offset packet contain values respectively packet belongs ip protocol 
filter shown accepts exactly ip packets assuming host machine dec alpha experiments machine memory words stored memory significant order 
note array bounds checks necessary safety packets bytes long 
filter accepts ip packets originating network number 
involves checking bit value starting offset packet addition done filter 
filter accepts ip arp packets exchanged networks 
filter complex control flow considered experiments source destination fields located different offsets ip arp packet fields spread word boundaries 
filter branches depending packet ip packet arp packet packet rejected true 
originating network address bytes starting offset ip packets offset arp packets compared 
test succeeds repeated destination address bytes starting offset ip packets offset arp packets 
chapter 
experimental validation proof carrying code packet filter instructions proof size bytes validation time cost space kilobytes proof size validation cost pcc packet filters 
filter accepts tcp packets destination port 
filter check ethernet packet ip packet tcp packet packet sequence lastly destination port matches value 
interesting feature filter offset tcp destination port field computed value header field length ip header 
guaranteed computation yields offset minimum packet size bytes filter contains run time bounds check 
furthermore possible lack alignment tcp port byte requires extra instructions 
matter procedure wrote packet filters hand dec alpha assembly language 
contain loops helper functions need additional annotations 
reasons simpler verification condition generator pcc system dedicated packet filters 
verification conditions proved theorem prover discussed chapter proofs checked lfi proof checker discussed chapter 
start discussion proof related costs proof carrying code packet filters 
costs theorem proving cost discussed similar larger set agents section 
shows packet filters size proof time required checking mhz dec alpha processor 
line shows memory requirements proof validation relatively modest 
shall see section scratch memory type checking increases slowly size proof 
focus benefit pcc packet filters high run time performance characteristic hand optimized assembly language programs 
gauge significance benefit implemented filters techniques enforce safety policy 
alternative techniques described 
standard way ensure safe execution packet filters interpret filter program perform extensive run time checks 
approach best exemplified bsd packet filter architecture mj commonly referred bpf inspiration source set experiments 
bpf approach filter encoded restricted accumulator language 
bpf semantics filter 
proof carrying code packet filters packet filtering time filter filter filter filter bpf sfi pcc bpf sfi pcc comparison average packet run time 
attempts read outside packet scratch memory write outside scratch memory terminated packet rejected 
bpf interpreter simple static check packet filter code verify instruction codes valid branches forward code limits 
measured time overhead microseconds negligible 
bpf packet filters times slower pcc filters 
pcc approach checks moved validation stage allowing faster execution 
order collect data bpf packet filters extracted bpf interpreter implemented osf kernel compiled user library 
approach safe code execution software fault isolation sfi 
sfi inexpensive method parsing binaries inserting run time checks memory operations 
flavors sfi depending desired level memory safety 
entire code runs single protection domain size power memory stores checked run time cost sfi relatively small 
hand untrusted code interacts frequently code receiver untrusted components residing different protection domains read operations checked overhead run time checks amount 
serious disadvantage sfi ensure memory safety 
order better accommodate sfi packet filters safety policy relaxed slightly 
example assumed packet aligned byte boundary entire byte block accessible filter 
usually sfi performed trusted component code receiver 
sfi performed code producer site possibly part code generation phase modified compiler 
case code receiver inspect code verify run time checks 
validator reportedly simple try eliminate redundant checks 
hand relatively complex chapter 
experimental validation proof carrying code cumulative filtering time ms bpf sfi pcc network packets thousands startup cost amortization filter 
slower validator required want validator optimize placement run time checks 
knowledge sfi validator presently exist 
order collect data sfi packet filters inserted run time checks memory operations assembly language filters 
cost checks slowdown filtering process 
part sfi experiment produced safety proofs resulting sfi packet filters adhere safety policy 
proofs viewed proofs sfi performed correctly effect proof checking replaces sfi validator described 
alternative technique examined write filters type safe language rely correctness compiler ensure execution type safe 
approach untrusted code safety modula language nel taken spin extensible operating system bsp 
attempt maximize run time performance resulting packet filters view language extension ssp developed purpose spin project allow efficient manipulation multi byte fields arrays bytes 
unfortunately way communicate modula compiler bounds checks eliminated packets bytes long 
coupled moderate amount register shuffling spilling introduced compiler packet filters obtained compilation modula source code factor slower hand optimized packet filters 
shows comparison packet running time filters discussed implemented bpf modula sfi pcc 
performance measurements done dec alpha mhz processor mbyte secondary cache mbyte main memory running osf 
measurements performed line packet trace busy ethernet network carnegie mellon university 

experiments touchstone compiler packet latency point view pcc packet filters outperform filters developed considered approach 
times faster interpreted bpf filters times faster filters compiled modula faster filters sfi 
pcc method time startup cost consisting proof validation cost 
despite relatively high validation cost run time benefits pcc packet filters large amortize startup cost processing reasonable number packets 
shows running time including startup cost function number packets processed filter filter largest proof validation cost 
particular case cost proof validation amortized packets compared bpf version filter packets compared modula version packets compared sfi packet filter 
note counted ethernet packets second time collected packet trace experiments 
experiments touchstone compiler set experiments am discussing attempts global quantitative picture proof carrying code system touchstone certifying compiler frontend 
experiments exercise parts system discussed dissertation 
measured quantitative aspects system 
follow experiments packet filters show relative sizes executable code loop invariants proofs pcc binaries obtained touchstone compiler 
show distribution time typical pcc session consisting compilation verification condition generation proving proof checking 
support claim certification coexist optimizations show code produced touchstone compiler competitive code produced optimizing traditional compilers dec cc gnu gcc 
complete comparison traditional compilers compare code sizes compilation times 
benchmark programs experiments contain language features currently implemented touchstone certifying compiler rules floatingpoint benchmarks example bias programs array elimination significant difference running time 
furthermore preferred programs useful native code components safe mobile code system order evaluate certifying compiler front system safe execution proof carrying code 
considerations led benchmarks 
blur sharpen edge bidimensional convolutions image processing filters xv image manipulation program bra 
qsort implementation quicksort algorithm array integers 
simplex linear programming algorithm implemented rational numbers 
kmp implementation kmp search algorithm unpack gzip decompression algorithms core unix utility name chosen chapter 
experimental validation proof carrying code pcc binary size bytes blur sharp qsort simplex kmp unpack bcopy edge proof bytes bytes code bytes relative sizes bytes proofs invariants machine code 
time ms blur sharp qsort simplex kmp unpack bcopy edge proof checking ms proving ms vc generation ms code generation ms distribution time spent compilation certification benchmarks 
data table expressed milliseconds 

experiments touchstone compiler examples cases array bounds checking elimination effective 
bcopy program implementation string copy non overlapping strings 
worth noting programs fairly realistic size complexity required minor syntactic modifications conform safe dialect compiled touchstone 
main changes involved replacing pointer arithmetic array indexing 
results average runs dec alpha running mhz 
shows size safety proofs annotations compared size machine code benchmark 
annotations size code average 
average ratio proof size code size consistent observations experiments pcc hand written assembly language 
similar results shown section similar larger set experiments 
displays graphically distribution time spent compilation certification 
average time spent compiling theorem proving rest split evenly vc generation proof checking 
results observations 
cost certification third cost compilation meaning reasonable certifier life compiler just compiler development 
second vcgen proof checker simpler compiler theorem prover faster 
safety critical pcc infrastructure small fast 
important situations infrastructure executed systems limited computational power smart cards 
shows effect optimizations running time benchmark programs gnu gcc compiler dec cc compiler touchstone certifying compiler 
compilers invoked optimizations enabled 
running times reported speedups running time unoptimized code compiled gcc 
set bars geometric mean speedups compiler 
average touchstone compiler performs slightly better gcc quite cc difference 
programs touchstone quite compilers kmp unpack due bounds checks eliminated bcopy lack loop unrolling addition array bounds checking elimination inter procedural register allocation common subexpression elimination played major role making quality code generated touchstone comparable produced compilers 
experiments compilers compile programs bounds checking touchstone handicap having implement hopefully remove array bounds checks 
array bounds checking elimination described section able eliminate checks proof redundancy local current function ineffective elimination requires global information 
weakness problem benchmarks blur edge bcopy 
alleviate cost array bounds checking cases added chapter 
experimental validation proof carrying code speedup vs gnu gcc blur sharp qsort simplex kmp unpack bcopy edge gnu gcc dec cc touchstone effect optimizations certifying compiler expressed ratio running time optimized code running time code compiled gnu gcc 
comparison show benchmark effect optimizations gnu compiler gnu gcc vendor compiler dec cc 
column geometric mean benchmarks 
benchmarks assert conditionals enable touchstone eliminate bounds checking inside loop bodies 
benchmarks kmp unpack compute array indices contents auxiliary data structures 
formal safety argument array operations involves proof complicated global program invariants probably reasonable expect compiler able eliminate bounds checks automatically 
due fact touchstone early prototype compilation time significantly larger compilers performance comparisons 
shows compilation times including time vc generation proof generation proof checking touchstone compilers optimizations enabled set benchmarks 
average touchstone slower gnu gcc slower dec cc 
shows comparison machine code sizes programs compiled touchstone compilers 
compilation times sizes machine code emitted touchstone emitted compilers 
note fundamental reason certifying compiler emit code larger emitted traditional compiler 
respect compilation time certifying compiler incur extra cost emitting loop invariants type specifications 
cost negligible compared rest compilation effort 

experiments touchstone compiler compilation time ms blur sharp qsort simplex kmp unpack bcopy edge gnu gcc dec cc touchstone comparison compilation time touchstone gnu gcc dec cc compilers optimizations enabled 
times table shown milliseconds 
average touchstone slower gcc slower cc 
note compilation time include vc generation proof generation proof checking 
code size bytes blur sharp qsort simplex kmp unpack bcopy edge gnu gcc dec cc touchstone comparison target code sizes programs compiled touchstone gnu gcc dec cc compilers optimizations enabled 
sizes table shown bytes machine code 
average touchstone sizes code emitted compilers 
chapter 
experimental validation proof carrying code experimental validation lfi section describe set experiments purpose quantify advantages implicit representation proofs benefits various optimizations discussed section 
experimental data collected set proofs memory safety type safety produced theorem prover described chapter touchstone compiler described chapter 
measured programs sizes fully explicit bimodal representations proofs time memory required proof reconstruction fully explicit form bimodal representations 
measurements done pentium ii machine running mhz 
cases fully explicit representations proofs fit level cache size kbytes 
start analyzing optimizations show typical proof sizes proof reconstruction time memory usage proof reconstruction proof representation set proof optimizations presently proof carrying code system 
shows proof reconstruction time function proof representation size 
worst case complexity reconstruction expected nonelementary similarity problem normalizing terms typed calculus sta 
correlation observed experimentally linear reason experiments variants order logic quantification higher order syntax limited 
furthermore proofs considered experiment state type safety type system type checking syntax directed 
shows scratch memory usage proof reconstruction 
largest example uses kilobytes working memory reconstructing proof bimodal representation kilobytes explicit representation megabytes 
observe graph reconstruction algorithm need recreate full proof checking uses memory implicit proof 
common characteristic experimental results optimizations perform better larger problem sizes meaning effective just need 
characteristic misleading try capture effect optimization average improvement percentage 
show scatter plots improvement due optimization function problem size 
shows ratio size bimodal lfi representations lf representations function size lf representation 
size representation measured bytes external form lfi terms discussed section 
note improvement ranges larger problems 
biggest problem size size fully explicit lf representation megabytes lfi representation just kilobytes reduction huge impact practicality proof carrying code 
shows improvement time required reconstruction bimodal representation respect time required type checking fully explicit lf 
experimental validation lfi bimodal reconstruction time bimodal representation size bytes correlation reconstruction time size bimodal representation logarithmic scale 
memory usage proof reconstruction bytes bimodal representation size bytes correlation memory usage reconstruction size bimodal representation logarithmic scale 
chapter 
experimental validation proof carrying code size reduction bimodal representation explicit representation size bytes ratio size explicit representation size bimodal representation function original size 
reconstruction time reduction bimodal representation explicit lf typechecking time ratio time required checking explicit representation time required reconstruction bimodal representation function original checking time logarithmic scale 

experimental validation lfi reduction reconstruction time bimodal representation size bytes speed reconstruction due occurs check optimization function bimodal representation size logarithmic scale 
reduction memory usage bimodal representation size bytes reduction memory usage due memory optimization function bimodal representation size logarithmic scale 
chapter 
experimental validation proof carrying code terms logarithmic scale 
results demonstrate lfi save terms proof size terms proof checking time 
largest experiment reduction factor lf type checking time seconds lfi reconstruction time just milliseconds 
occurs check optimization memory usage optimization simple major impact reconstruction time memory usage shown 
occurs check optimization eliminates occurs checks reduction reconstruction time ranging smaller problems times larger cases 
similarly reduction memory usage ranges times 
cases optimizations effective larger problem sizes 
discussion experiments chapter demonstrate practical instances proof carrying code technique efficient techniques interpretation run time checking 
performance benefit due large part static checking safety involved proof engineering targeted maintaining low cost storing validating proofs safety 
chapter final chapter summarize main technical contributions dissertation discuss promising directions extending research 
contributions major challenges building software systems ensure various components fit defined manner 
problem exacerbated advent software components origin unknown inherently untrusted mobile code user extensions operating system kernels database servers 
extensions useful implementing efficient interaction model client server data exchanges saved expense single code exchange 
dissertation propose tackle system integrity security problems techniques mathematical logic programming language semantics framework provided proof carrying code 
proof carrying code requires extension provider send extension code representation formal proof code meets certain safety correctness requirements 
code receiver ensure safety executing extension validate attached proof 
proof carrying code key characteristics combination give advantage previous approaches safe execution foreign untrusted code 
advantages claimed 
pcc general 
pcc enforce memory safety type safety 
extreme pcc verify code property exists logic capable expressing 
includes code properties undecidable infer code 
pcc tested safety properties ranging memory type safety bounded resource usage 
chapter 

pcc receiver infrastructure low risk automatic 
proof checking process code receiver determine code safety completely automatic implemented program relatively simple easy trust 
safety critical infrastructure code receiver rely reduced minimum 

pcc efficient 
practice proof checking process runs quickly 
furthermore contrast previous approaches code receiver modify code order insert costly run time safety checks code receiver perform checking interpretation proof validated code installed 

pcc require trust relationships 
code receiver need trust producer 
words receiver know identity code producer know process agent code produced 
information needed determining safety code included annotated agent code proof 

pcc flexible 
proof checker require particular programming language 
pcc wide range languages machine languages 
furthermore code receiver support multiple agent languages safety policies minimal duplication infrastructure components 

pcc producer automated special cases 
safety properties decided statically enforced systematic run time checks certifying compiler matching theorem prover code receiver side automate process producing annotations proofs 
advantages pcc due imbalance difficulty tasks assigned code producer generation annotations proving verification conditions code receiver generation verification conditions validation proofs 
dissertation contributes concept certifying compiler design proof generating decision procedures purpose assist code producers attributions proof carrying code system 
certifying compiler compiler emits addition target code function specifications loop invariants enable theorem proving agent prove non trivial properties target code type safety 
certifying compiler proof generating theorem prover convenient producer proof carrying code powerful software engineering tool 
certifier acts effective referee correctness compilation simplifying considerably compiler testing maintenance 
advantages claimed certifying compiler 

certifying compilation conjunction proof generating theorem proving practical method producing automatic manner loop invariants proofs required proof carrying code system type safety 

certifying compilation significantly easier employ formal verification compiler formal verification restricted proving target code type safe 
easier general verify correctness result computation prove correctness computation 
furthermore approach compiler revisions improvements require change certifier 

method applied optimizing compilers design certifier restrict optimizations compiler allowed perform 
touchstone optimizing compiler generates code programs matches performance gcc cc optimizations enabled 

presence certifier drastically improves effectiveness compiler testing test case statically signals compilation errors require executions detect 
approach ensure full compiler correctness experience vast majority compiler bugs lead compiler generate unsafe target programs test cases 

method applicable compilation type safe language certifying properties target programs type safety 
significant benefit design requires relatively modifications traditional compiler possible adapt existing compilers technique 
complete system proof carrying code contain proof generating theorem prover purpose producing attached proofs safety 
dissertation shows standard decision procedures adapted produce detailed proofs proved predicates 
just case certifying compiler theorem prover significant software engineering advantages traditional prover 
case simple proof checker ensure soundness successful proving task indirectly assist testing maintenance theorem prover 
concepts thesis broad general feasibility reasons actual implementations describe covers small part design chapter 
space 
section discuss promising directions extending ideas discussed dissertation 
notable limitations implementation proof carrying code described handle liveness properties general security policies 
recall chapter general security policies expressed predicates set possible executions program 
information flow example security property 
security properties expressed predicates individual executions 
security properties safety properties disallow certain bad things happen execution liveness properties stipulating certain things happen 
explained detail chapter vcgen implementation proof carrying code targeted enforcing safety properties 
seen case type safety policies described section vcgen approach enforce data abstraction 
data abstraction safety property security property 
data abstraction security policy definition schneider sch 
tell program violates abstraction boundaries looking executions 
look source code equivalently set possible executions able distinguish programs truly respecting abstraction violate abstraction boundaries guessing concrete representations 
experience type safety policies suggests promising technique extending proof carrying code new flavors security properties non standard type systems basis security policy adapt vcgen theorem proving act type checking system 
strategy special interest position proof carrying code gain leverage large body area type static analyses 
example research groups developed nontraditional type systems expressing checking information flow hr ml vs non interference vs performing control flow analysis hei ps po strictness analysis km binding time analysis hen 
main advantages vcgen proof carrying code system insensitive code transformations variable renaming common subexpression elimination dead code elimination 
feature cases prevent vcgen certain safety policies 
example new generation epic processors allow non valid memory addresses read long result read operation subsequent computation 
natural way capture behavior vcgen property value subsequent computation property current state memory registers 
order handle code properties extend notion state execution creative ways conventional syntax type checking approach 

opportunities research suggested limitations imposed source language compiled touchstone compiler 
limitations imposed vcgen 
currently vcgen handle programming paradigms result target code enriched runtime data structures affect behavior 
examples problematic data structures function closures implementing higher order functions dynamic dispatch tables implementing object oriented languages exception dispatch tables implementing exceptions root tables assisting garbage collector 
fact vcgen currently support runtime data structure stack 
data structures supported similar manner cost complicated vcgen 
direction research mention area proof optimizations 
recall chapter transitioning lf representation proofs implicit lfi representations proof sizes validation times decreased due elimination redundant components 
significant common sub proofs shared lfi representation 
common sub proofs considered redundant possible reconstruct missing 
consider example situation subgoal occurs times verification condition 
proof common subgoal appear multiple times proof 
situations beneficial apply strategy humans handling large proofs state prove lemmas proofs building blocks 
lemma extraction process proof scanned common sub proofs identified factored manner similar common subexpression elimination 
lemma extraction scan safety proofs multiple agents safety policy 
lemmas detected case added derived proofs rules axiomatization safety policy 
proofs simplified simply referring lemmas proving time arise 
conclude dissertation note research described demonstrates ideas logic programming languages solving problems posed real software systems 
design implementation proof carrying code shows identify practical problem address helpful focus underlying phenomenon analyze understand thoroughly supporting theory 
working higher level abstraction propose solutions elegant rigorous general particular artifacts initially motivated 
complete research important implement level solutions concrete practical setting order validate experimentation 
bibliography acc abadi cardelli 
curien 
formal parametric polymorphism 
conference record twentieth annual acm sigplan sigact symposium principles programming languages pages 
acm new york ny 
accl martin abadi luca cardelli 
curien vy 
explicit substitutions 
journal functional programming october 
ack wilhelm ackermann 
solvable cases decision problem 
studies logic foundations mathematics 
north holland amsterdam 
bengt yossi 
polynomial time algorithm solving systems linear inequalities variables inequality 
siam journal computing april 
bowen alpern fred schneider 
defining liveness 
information processing letters october 
albert benveniste paul le guernic christian 
synchronous programming events relations signal language semantics 
science computer programming september 
ble bledsoe 
sup inf method arithmetic 
technical report university texas math dept december 
bm robert boyer strother moore 
computational logic 
academic press 
bm boyer moore 
correctness problem computer science 
academic press new york ny usa 
bra john bradley 
xv interactive image display window system 
available ftp ftp cis upenn edu pub xv 
bsp brian bershad stefan savage pardyak emin gun sirer david becker marc fiuczynski craig chambers susan eggers 
extensibility safety performance spin operating system 
symposium operating system principles pages december 
bibliography alessandro cimatti provably correct embedded verifier certification safety critical software 
computer aided verification 
th international conference 
proceedings pages 
springer verlag june 
cab constable allen bromley cleaveland cremer harper howe knoblock mendler panangaden sasaki smith 
implementing mathematics nuprl proof development system 
prentice hall 
cc patrick cousot radhia cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
proceedings th acm symposium principles programming languages pages 
ch coquand gerard huet 
constructions higher order proof system mechanizing mathematics 
proc 
european conf 
computer algebra euro cal lncs pages 
springer verlag 
deb debruijn 
lambda calculus notation nameless dummies tool automatic formula manipulation 

mat 
det david detlefs 
overview extended static checking system 
proceedings formal methods software practice workshop 
dfh dowek amy felty herbelin rard huet chet murthy parent christine paulin mohring werner 
coq proof assistant user guide 
version 
technical report inria rocquencourt may 
dij edsger dijkstra 
guarded commands formal derivation programs 
communications acm 
dij edsger dijkstra 
discipline programming 
prentice hall 
dst peter downey ravi sethi robert tarjan 
variations common subexpressions problem 
journal acm 
dyb dybjer 
domain algebras prove correctness compiler 
kurt mehlhorn editor proceedings nd annual symposium theoretical aspects computer science stacs volume lncs pages saarbr cken frg january 
springer 
free software foundation 
gcc gnu compiler 
available www gnu org software gcc gcc html 
gjs james gosling bill joy guy steele 
java language specification 
java series 
addison wesley reading ma usa 
bibliography glb donald ralph bledsoe 
interactive program verification system 
ieee transactions software engineering march 
gor michael gordon 
hol machine oriented formulation higher order logic 
technical report university cambridge computer laboratory july 
joshua guttman john mitchell wand 
verified implementation scheme 
lisp symbolic computation 
hei nevin heintze 
control flow analysis type systems 
lecture notes computer science 
hen fritz henglein 
efficient type inference higher order binding time analysis 
hughes editor functional programming languages computer architecture th acm conference volume lecture notes computer science pages 
springer berlin heidelberg new york 
hwu hank gallagher mahlke gyllenhaal august 
compiler technology microprocessors 
proceedings ieee pages december 
hhp robert harper furio honsell gordon plotkin 
framework defining logics 
journal association computing machinery january 
hr nevin heintze jon riecke 
slam calculus programming security integrity 
conference record popl th acm sigplan sigact symposium principles programming languages pages san diego california january 
ill shigeru igarashi ralph london david luckham 
automatic program verification logical basis implementation 
technical report cs tr stanford university department computer science may 
int intel intel architecture software developer manual 
vol 
basic architecture 
intel 
kf king floyd 
interpretation oriented theorem prover integers 
journal computer system sciences august 
kin king 
proving programs correct 
ieee transactions computers november 
km 
kuo mishra 
analysis new perspective type inference 
functional programming languages computer architecture pages 
springer verlag 
bibliography koz dexter kozen 
complexity finitely algebras 
conference record ninth annual acm symposium theory computing pages boulder colorado may 
koz dexter kozen 
efficient code certification 
technical report tr cornell university january 
lam leslie lamport 
proving correctness multiprocess programs 
ieee trans 
software engineering 
lev hank levy 
capability computer systems 
digital press 
david luckham steven german friedrich von henke richard karp milne derek oppen wolfgang polak william scherlis 
stanford pascal verifier user manual 
technical report cs tr stanford university department computer science 
ly tim lindholm frank yellin 
java virtual machine specification 
java series 
addison wesley reading ma usa january 
mcc john mccarthy 
mathematical theory computation 
editor proceedings international congress information processing pages 
north holland 
mic microsoft 
proposal authenticating code internet 
www microsoft com security tech htm april 
mil dale miller 
compact representation proofs 
studia logica 
mil dale miller 
logic programming language lambda abstraction function variables simple unification 
journal logic computation september 
mj steven mccanne van jacobson 
bsd packet filter new architecture user level packet capture 
winter usenix conference pages 
usenix association january 
ml andrew myers barbara liskov 
decentralized model information flow control 
proceedings th symposium operating systems principles sosp volume operating systems review pages new york october 
acm press 
dale miller nadathur frank pfenning andre scedrov 
uniform proofs foundation logic programming 
annals pure applied logic 
bibliography moo strother moore 
mechanically verified language implementation 
journal automated reasoning december 
mor lockwood morris 
advice structuring compilers proving correct 
proceedings acm symposium principles programming languages pages 
mp john mccarthy james painter 
correctness compiler arithmetic expressions 
schwartz editor proceedings symposia applied mathematics 
american mathematical society 
mp michaylov frank pfenning 
empirical study runtime behavior higher order logic programs 
miller editor proceedings workshop prolog programming language pages july 
available technical report ms cis 
mp michaylov frank pfenning 
higher order logic programming constraint logic programming 
workshop principles practice constraint programming pages newport rhode island april 
brown university 
mra jeffrey mogul richard rashid michael accetta 
packet filter efficient mechanism user level network code 
acm symposium operating systems principles pages 
acm press november 
updated version available dec wrl research report 
mth robin milner mads tofte robert harper 
definition standard ml 
mit press cambridge massachusetts 
mwcg greg morrisett david walker karl crary neal glew 
system typed assembly language 
th annual acm symposium principles programming languages 
acm january 
appear 
nec george necula 
proof carrying code 
proceedings th acm symposium principles programming languages popl pages paris france january 
nel greg nelson 
log algorithm variable constant linear programming satisfiability problem 
technical report stan cs stanford university 
nel greg nelson 
techniques program verification 
technical report csl xerox palo alto research center 
nel greg nelson 
systems programming modula 
prentice hall 
bibliography nl george necula peter lee 
safe kernel extensions run time checking 
usenix editor nd symposium operating systems design implementation osdi october 
seattle wa pages berkeley ca usa october 
usenix 
nl george necula peter lee 
design implementation certifying compiler 
proceedings acm sigplan conference language design implementation pldi pages 
nl george necula peter lee 
efficient representation validation proofs 
thirteenth annual symposium logic computer science pages indianapolis june 
ieee computer society press 
nl george necula peter lee 
safe untrusted agents proof carrying code 
giovanni vigna editor lncs special issue mobile agent security pages 
springer verlag june 
greg nelson derek oppen 
simplification cooperating decision procedures 
acm transactions programming languages systems october 
greg nelson derek oppen 
fast decision procedures bases congruence closure 
journal association computing machinery april 
ors owre rushby shankar 
pvs prototype verification system 
deepak kapur editor th international conference automated deduction cade volume lecture notes artificial intelligence pages saratoga ny june 
springer verlag 
dino oliva john mitchell wand 
verified compiler 
lisp symbolic computation 
pfe frank pfenning 
logic programming lf logical framework 
rard huet gordon plotkin editors logical frameworks pages 
cambridge university press 
pfe frank pfenning 
unification anti unification calculus constructions 
sixth annual ieee symposium logic computer science pages amsterdam netherlands july 
pfe frank pfenning 
elf meta language deductive systems system description 
alan bundy editor th international conference automated deduction lnai pages nancy france june july 
springer verlag 
po jens palsberg patrick keefe 
type system equivalent flow analysis 
acm transactions programming languages systems july 
bibliography pol robert pollack 
implicit syntax 
informal proceedings workshop logical frameworks antibes may 
pra vaughan pratt 
easy theories combination hard 
unpublished manuscript 
ps jens palsberg michael schwartzbach 
safety analysis versus type inference 
information computation april 
psc frank pfenning carsten sch cervesato 
twelf project 
available online www cs cmu edu twelf 
pss amir pnueli siegel eli 
translation validation 
bernhard steffen editor tools algorithms construction analysis systems th international conference tacas volume lncs pages 
springer 
pt benjamin pierce david turner 
local type inference 
th acm sigplan sigact symposium principles programming languages pages january 
sch fred schneider 
enforceable security policies 
computer science technical report tr cornell university computer science department september 
sess margo seltzer endo christopher small keith smith 
dealing disaster surviving misbehaved kernel extensions 
second symposium operating systems design implementations pages 
usenix october 
sho robert shostak 
algorithm reasoning equality 
communications acm july 
sho robert shostak 
deciding linear inequalities computing loop residues 
journal acm october 
sit richard sites 
alpha architecture manual 
digital press 
ssp emin gun sirer stefan savage pardyak greg defouw brian bershad 
writing operating system modula 
workshop compiler support systems software pages february 
sta statman 
typed calculus elementary recursive 
theoretical computer science 
tmc david tarditi gregory morrisett perry cheng chris stone robert harper peter lee 
til type directed optimizing compiler ml 
pldi conference programming language design implementation pages may 
bibliography james thatcher eric wagner jesse wright 
advice structuring compilers proving correct 
hermann maurer editor automata languages programming th colloquium volume lecture notes computer science pages graz austria july 
springer verlag 
vs dennis volpano smith 
type approach program security 
lecture notes computer science 
wad wadsworth 
semantics pragmatics lambda calculus 
phd thesis oxford university 
wad philip wadler 
theorems free 
functional programming languages computer architecture pages 
acm 
wahbe lucco anderson graham 
efficient software fault isolation 
th acm symposium operating systems principles pages 
acm december 
william young 
mechanically verified code generator 
journal automated reasoning december 
appendix soundness verification condition generation main result appendix valid verification condition agent guarantees safety invocations agent functions 
agent functions invoke system calls need assume system calls safe 
stated formally soundness theorem restated theorem soundness vcgen system calls safe safe agent verification condition valid vc functions system safe safe 
proof soundness theorem induction length execution 
step reachable state show execution returned current invocation progress 
induction propagate information execution initiated state satisfying precondition verification condition valid 
customarily done means induction hypothesis 
case induction hypothesis execution state exists related state symbolic evaluator point function state se 
key property run time symbolic states related complicated sense stated formally section 
defining issues relation exists substitution variables occurring symbolic execution state values 
disclosing formal definition invariant just say relation eleven parameters written ih 
just symbolic evaluation function subscripts constant function body omitted time 
appendix soundness verification condition generation lemma soundness system calls safe safe agent verification condition valid vc function initial state satisfies precondition pref entire frame fits runtime stack assuming invoked agent functions safe execution get stuck reachable state current invocation exists induction hypothesis holds ih 
fi ret 
fi call execution safe assumption 
exists induction hypothesis holds new state 
proof theorem means lemma 
note soundness lemma considers reachable states current invocation 
current invocation function calls safety property follows assumption system calls safe invoked agent functions safe 
problem case recursive agent functions soundness lemma assumes holds 
fixed technical trick 
introduce additional definition safety involving parameter executions lead nested function calls considered 
executions treated non terminating considered safe 
change statement soundness lemma assume agent functions safe nested executions conclude agent functions safe nested executions 
base case invocations invoke functions 
modified soundness lemma constitutes base case inductive case inductive argument soundness lemma true values kind safety desire 
having argued informally possible fix apparent bug statement soundness lemma proceed simpler form 
termination part soundness theorem follows soundness lemma property requires ra preserved register 
left proving lemma 
lemma proved lemmas stating induction hypothesis established invocation agent function lemma stating induction hypothesis holds current instruction function call return execution progress state satisfies induction hypothesis lemma deal function call case stating executing function call safe function potential completion preserves induction invariant lemma deal function return case lemma 
lemmas stated 
lemma invocation function valid verification condition vc safe invocation state pref stack sp arg local sp arg call history exist ih arg new variable 
lemma progress ih current instruction call return instruction interpreter progress exist ih 
lemma function call ih current instruction function call fi call safe execution progress possibly returning state 
case exist ih 
lemma function return ih current instruction return return safe 
attempt prove lemmas state formally definition induction hypothesis 

definition induction hypothesis proofs follows letter denote substitutions values logical variables 
notation domains substitutions disjoint denotes extension substitution substitution course proof necessary congruence lemma stated 
lemma congruence predicate free variables regs evaluator states mapping symbolic registers regs values arg regs fv arg 
proof congruence lemma proof congruence lemma easy induction structure judgment predicate proceed formal proofs lemmas 
proof invocation lemma verification condition valid definition 
yk pref se arg appendix soundness verification condition generation definition induction hypothesis consider simultaneous execution sal interpreter state vcgen symbolic evaluator state se 
consider current instantiation logic variables 
say induction hypothesis holds situation written ih conditions hold ih 
verification condition valid se ih 
correct local sp sp arg ih 
correct ih 
correct regs arg arg ih 
stack preserved stack sp arg mem mem ih 
frame fits stack stack holds addresses satisfy inequalities sp arg local sp arg ih 
correct respect ih 
empty regs ih 
dom ih 
arg 
ih 

rk yk ih 
fi inv 
rk ih 
yj new variables yj dom fv fv ih 

yk vk ih 
ih 

yk se ih 
correct respect defined ih 
inductive invariant proving soundness generation 
number registers regs 
rk 
yk new variables initial symbolic state 
rk yk 
definition validity universal quantification pref se arg arg 
yk arg rk 
want prove ih arg 
clauses induction hypothesis trivial ih 
clause proved inferring pref holds clause ih correctness preconditions property congruence lemma 
note clause ih proved case option ih 
proof progress lemma proof case analysis current instruction precisely case symbolic evaluation 
start difficult cases loop invariants 
case rule symbolic evaluation rule loop invariant inv 
rk encountered time 
annotation safety checks progress guaranteed state 
prove invariant ih 
yk new variables 
yk rk 
rk yk clauses ih ih ih follow immediately induction hypothesis counterparts state registers change 
clause ih follows induction hypothesis 
way defined clause ih induction hypothesis verify clause ih equation holds regs order prove ih notice clause ih induction hypothesis se equation clause ih induction hypothesis congruence lemma deduce 
congruence lemma time appendix soundness verification condition generation equation deduce definition validity implication conclude clause ih holds 
step proof case prove clause ih 
ih ih true construction ih follows clause ih induction hypothesis 
clause ih follows clause ih induction hypothesis observation verified vcgen 
clause ih equation 
case case consider loop invariant inv 
rk encountered dom 
case progress guaranteed execution state 
trick find corresponding state symbolic evaluator 
need clause ih induction hypothesis 
clause dom know 
yk vk 
rk yk yj variables occur 
know clause ih induction hypothesis 
yk se suggests prove induction hypothesis stated follows ih 
yk rk 
notice chosen 
rk 
registers modified loop know clause ih induction hypothesis 
part verification condition clause ih induction hypothesis know 
modified loop extension sequence equalities concludes proof clause ih equation regs clause ih induction hypothesis know 
equation clause ih induction hypothesis get congruence lemma 
conjunction definition validity implication universal quantification equation leads clause ih equation holds 
clauses ih ih ih ih hold register state changed 
note clause ih holds clause ih induction hypothesis 
concludes case loop invariants 
note cases loop map change fact 
implies substitution change 
clauses ih ih ih trivial prove induction hypothesis directly 
case rule symbolic evaluation register move rule prove ih 
clause interest case ih case prove follows clause ih induction hypothesis 
case register initialization similar 
case rule symbolic evaluation expression operand rule prove know execution progress 
clause ih induction hypothesis definition validity conjunction 
clause ih congruence lemma infer definition validity know 
conclude case proof prove induction invariant holds new state ih eop eop 
clause ih follows clause ih induction hypothesis 
interesting clause case ih case prove eop eop 
follows definition valuation expression constructor eop clause ih induction hypothesis congruence lemma 
case rule symbolic evaluation conditional branch rule progress guaranteed holds 
proved case expression operators clauses ih ih induction hypothesis congruence lemma definition validity predicate constructor 
know execution progress consider cases depending outcome comparison 
comparison successful state invariant prove ih 
clause ih interesting parameters induction hypothesis changed 
clause ih follows clause ih induction hypothesis prove cop 
follows immediately definition validity cop clause ih induction hypothesis know control flow test cop succeeds 
fall case branch similar 
case case memory write instruction verify safety condition safewr mem holds execution progress 
follows clauses ih ih induction hypothesis appendix soundness verification condition generation congruence lemma definition validity safewr predicate constructor 
prove form induction hypothesis holds ih mem upd mem mem mem 
clause ih follows clause ih induction hypothesis 
case memory changes verify clause ih 
property know stack clause ih follows directly clause ih hypothesis 
prove clause ih prove equality holds upd mem mem follows directly definition valuation upd constructor 
finish proof clause ih verify memory contains values local pseudo registers change 
follows fact memory locations stack clause ih induction hypothesis stack changed generic memory writes 
case memory reads similar expression operators 
case case stack pointer advance instruction prove stack sp 
know clause ih sp sp arg know check performed vcgen inequalities hold sp arg local sp sp arg 
see safety condition follows clause ih induction hypothesis 
progress established verify induction hypothesis holds ih sp sp 
clauses follow directly induction hypothesis ih case simple arithmetic sufficient 
case case read stack argue progress just stack pointer advance instruction 
prove induction hypothesis holds ih lso mem sp 
clause follow directly induction hypothesis ih case prove lso mem sp 
note mem sp mem sp arg arg lso desired follows clause ih induction hypothesis 
check vcgen performs ensures lso valid local pseudo register frame case case write stack progress clause ih argued manner similar case reads stack 
case extra obligation verify clause ih 
easy verify address written smaller sp arg due checks performed vcgen clause ih induction hypothesis 
concludes proof progress lemma 
proof function call lemma induction hypothesis case function call 
safety requirement call instruction 
proved easily property congruence lemma prove arg regs fv 
prove property am doing case analysis register follows arg 
rr ra mem case see definition copyin arg equation follows clause ih induction hypothesis 
possible case arg li 
case lso arg clause ih induction hypothesis sequence equalities lso arg arg lso arg arg li holds 
equality follows definition substitution clause ih 
note lso arg valid local registers regs clause ih check vcgen performs function call 
proved holds guaranteed execution interpreter progress 
stack overflow check fails execution returns possible benign outcomes lemma 
stack overflow check succeeds know continuity stack property entire stack frame fits stack 
assumption safe stated definition know execution progress returns current state ra know clause ih ra ra 
vcgen checks value return address register time call see know ra offset clause ih know return point instruction call ra 
complete proof lemma need show induction hypothesis holds state return function symbolic state substitution variables values 
symbolic state defined arg 
yk arg rk arg lso 
arg 
prove ih appendix soundness verification condition generation start proving clause ih 
show arg arg registers regs second part clause follows immediately clause ih induction hypothesis realize registers 
variables yi zj new 
part clause proved case analysis register distinguish cases labelled follows arg 
rr ra mem case definition 
consider subcases depending cs 
saved equation get arg 
desired follows clause ih note extension 
case saved yj arg arg 
case local register sits stack frame arg li 
lso arg case arg definition clause ih 
definition substitution arg mem sp arg note sp arg equation arg arg concludes case proof 
case local register argument arg li lso arg 
lso case li arg consider subcases depending li arg callee save 
saved li arg li arg li definition copyin 
arg li arg li arg arg li arg arg li 
times clause ih induction hypothesis callee save condition equation 
get desired clause ih induction hypothesis observe li li 
second subcase li arg saved li arg yj arg li arg arg li concludes case 
case proof clause ih local register sitting arguments arg li lso 
case li zi arg li concludes case proof clause ih 
prove clause ih equation 
clause ih induction hypothesis se need prove se 
sufficient prove 
equation post get property knew arg regs fv 
distinguish cases follows arg 
rr ra mem case arg arg reuse proof equation 
case argument local register cases property 
arg rho li 
case reuse proof equation convert local names frame concludes proof clause ih 
proof clause ih follows directly equation clause ih induction hypothesis 
proof clause ih follows directly clause ih induction hypothesis 
proof clause ih follows equation clause ih induction hypothesis frame frame modified call ensured check performed vcgen 
proof clause ih follows directly clause ih induction hypothesis 
proof clause ih follows clause ih induction hypothesis noticing substitution extension new variables loop map change 
concludes proof function call lemma 
proof function return lemma note defines return safe history empty 
condition trivially true induction hypothesis 
proof safety condition parts requested definition follows 
clause ih induction hypothesis deduce 
clause ih induction hypothesis follows 
appendix soundness verification condition generation correctness postcondition specifications post need prove 

clause ih induction hypothesis deduce cs clause ih deduce callee save registers 

sp sp follows immediately ih clause induction hypothesis arg checked verification condition generator 

preservation stack follows immediately ih clause induction hypothesis 
appendix soundness lfi proof checking appendix prove reconstruction algorithm section adequate checking validity proofs 
proof correctness just exercise type theoretic proofs 
obvious purpose ensuring correctness type reconstruction algorithm obvious inspection correctness proof constitutes thorough analysis strengths limitations algorithm 
limitations algorithm imposed side conditions rules notably collection explicit parameters typing abstractions instantiation rules 
correctness proof serve documenting side conditions needed 
practical cases reconstruction algorithm circumstances side conditions need enforced 
circumstances discovered deep understanding purpose side conditions correctness proof 
proof stages 
stage prove reconstruction succeeds lfi typing derivation subject implicit proof 
stated theorem restated theorem correctness proof reconstruction lfi object uvf pf pf 
second stage proof show lfi typing implicit proof exists fully explicit typed reconstruction proof 
theorem restated theorem soundness lfi typing pf pf exists lf start proof theorem continue proof theorem 
introduce additional notation notation introduced section 
appendix soundness lfi proof checking notation conventions write denote result applying substitution type environment 
resulting type environment defined dom dom dom follows dom dom write denote substitution typed type environment lfi typing rules follows iff dom dom order simplify presentation correctness proofs section convention types involved placeholder free 
applies types part theorem hypotheses types mentioned helper lemmas theorems 
new types created proof shall verify property expressed explicitly statements theorems 
convention necessary check pf side conditions lfi typing judgments involved proofs 
order keep presentation focused separated number helper lemmas section appendix 
correctness lfi type reconstruction type reconstruction algorithm expressed mutually recursive judgments 
surprisingly correctness proof reconstruction algorithm consists mutually dependent correctness proofs constituent judgments 
proofs induction structure corresponding judgment 
occasionally proof invokes theorem related judgment way corresponding judgment invokes related judgment 
proofs hand chain theorem invocations circular derivations involved structurally smaller induction founded 
correctness type reconstruction judgment correctness theorem main reconstruction judgment 
prove theorem directly 
strengthen statement theorem induction succeeds 
particular allow arbitrary typing environments types possibly containing unification variables placeholders 
correctness theorem stated formally bellow theorem correctness type reconstruction type environment type respectively pf pf type term uvf 
correctness lfi type reconstruction pf 
theorem immediately prove theorem empty type environment empty substitution note pf pf definition representation function 
proof theorem proof induction structure derivation 
cases depending rule case abstraction obvious empty substitution typed placeholder free 
pf pf follows apply induction hypothesis infer infer desired 
case abstraction follow sequence deduction steps shown 
type hypothesis 
pf pf uvf hypothesis 
theorem infer dom dom 
exist 
apply theorem infer 
type 
pf 
pf 
pf uvf type 
infer type 
appendix soundness lfi proof checking 
apply theorem infer 


pf 

lemma dom dom infer 

apply theorem infer 

unification variables new occur dom dom dom 
get desired 

lemma prove dom easily prove pf dom 
correctness unification important judgments type reconstruction algorithm previous section unification judgments 
properties crucial correctness reconstruction implementation determine performance reconstruction 
key property unification judgments resulting substitution preserves types unification variables consequence algorithm need type check resulting substitution 
properties interest unification judgments expressed theorem 
parts theorem deal atomic unification types objects respectively 
part deals normal unification objects 
theorem correctness unification types mentioned statement assumed placeholder free 
pf 
correctness lfi type reconstruction pf pf pf pf pf pf complicated statement required order prove theorem induction 
actual uses theorem form simpler corollary shown 
corollary follows immediately case theorem type 
corollary type type 

pf 

proof theorem proof induction structure unification derivations 
show cases unification objects cases 
proof atomic unification types follows patterns 
case empty substitution typed environment placeholder free 
hypothesis know 
lemma stated page conclude 
rest follows immediately 
case typing condition resulting substitution vacuously true 
hypothesis know 
lemma infer concludes proof case 
appendix soundness lfi proof checking case purpose correctness proof consider reduction case argument 
general case proved similar way 
hypothesis 
lemma infer 
pf infer pf pf 
pf 
lemma infer 
apply induction hypothesis infer pf 
conclude induction hypothesis 
completes proof case 
case follow sequence deductions 
hypothesis lemma get 




hypothesis lemma get 




apply induction hypothesis 
conclude 

pf 



corollary deduce 

correctness lfi type reconstruction 
corollary deduce deduce 

infer pf pf 
apply induction hypothesis 
deduce 

pf 


lemma get part pf 

lemma deduce 
allow prove 

lemma deduce 
similarly get 
lemma get part 
concludes cases regarding atomic unification 
rest cases normal unification 
interesting cases abstraction instantiation cases shown 
case empty substitution typed placeholder free 
hypothesis lemma 
induction hypothesis infer required case fv hypothesis pf 
corollary deduce 
pf infer pf 
rest trivial appendix soundness lfi proof checking correctness constraint collection solving due presence dependent types close relationship constraint collection constraint solving consider separately 
intuitively constraint solving judgment sense typing constraints contain typed types due dependent types types contain objects reconstructed solving constraints 
things complicated able assume constraints solved order produced 
assume time constraint solved prove type involved formed kind type 
want prove correctness arbitrary order solving constraints power reconstruction originates ability solve constraints order 
circular dependency judgments complicates correctness proof substantially 
able prove correctness theorem judgments state correctness sequence theorems theorem establishes assumptions 
sequence theorem third theorem theorem refer constraint solving theorem theorem constraint collection 
theorem says constraint list solving typing constraint eventually solved 
depending particular order solving unification variables may instantiated 
theorem exist 
proof theorem proof induction structure derivation 
vacuously true empty 
rule reordering rule induction hypothesis proves directly 
cases similar show case rule solving typing constraint 
case show separately typing constraints considered constraint follows immediately 
typing constraint 
correctness lfi type reconstruction constraint 
induction hypothesis get exists 
proves required substitutions 
continue theorem constraint collection judgment 
result previous theorem show types resulting constraint list formed kind type 
theorem pf uvf exist type pf pf pf uvf type 
theorem establishes crucial properties required unification invoked constraint solving judgment 
side condition application explicit parameter 
main purpose side condition allow infer type explicit parameter part dependent type type formed 
proof theorem proof induction structure derivation 
cases depending rule cases constants variables follow immediately list constraints empty pf 
interesting cases deal application 
case explicit application need helper theorem states reconstruction reduced lfi typing objects types involved fully explicit 
case new unification variable immediately apply induction hypothesis follows sequence steps shown appendix soundness lfi proof checking 
type 
pf 
pf 
type pf uvf 

new transform type proves part 

similarly deduce type part 

show pf 
show pf concludes proof case 
case fv pf uvf induction hypothesis infer 
type 
pf part 
pf uvf fv 
type pf uvf part 

deduce pf part 
note fact fv pf 

part remains proved type 
fv follows immediately 
suffices prove 
hypothesis exist 
uvf get 
uvf hypothesis know uvf 

conclude 
correctness lfi type reconstruction 
transform 
uvf unification variables occur transform 

know uvf fv transform 

apply theorem deduce motivated concludes proof case 
theorem shows constraint solving judgment constraints types formed produces typed substitution satisfies constraints 
theorem pf pf pf type type uvf pf type true pf proof theorem proof induction structure derivation 
case rule reordering rule poses problems 
similarly case empty constraint list trivial 
show case rule solving typing constraint 
case pf pf uvf type apply theorem infer pf 
appendix soundness lfi proof checking substitution placeholders typed constraint list satisfies conditions applying induction hypothesis respect type environment 
deduce induction hypothesis pf 
final step lemma conclude proof case 
case unification constraint solved similar difference theorem invoked show unification returns typed substitution 
theorem correctness proof reconstruction algorithm shows existence typed substitution defined locally introduced unification variables guarantee typedness original term 
theorem pf dom dom uvf 
proof theorem proof induction structure derivation 
cases constant variable follow immediately hypothesis 
consider cases application explicit terms placeholders 
case fv pf uvf uvf fv apply induction hypothesis conclude 
hypothesis uvf 
application rule lfi uvf deduce 
note newly introduced type placeholders occurs pf 

correctness lfi type reconstruction case follow sequence deductions follows new unification variable 
hypothesis dom dom hypothesis deduce 

dom dom 

dom dom 

infer 

lemma new appear 
deduce 
apply induction hypothesis conclude 


new appear deduce 

recall assume types involved placeholders 
pf pf 

implicit application rule lfi placeholder replacement 
resulting type 

case complete verify newly introduced type placeholders 
follows immediately pf pf 
note place require property typed defined variables 
concludes skeleton correctness proof reconstruction algorithm 
proofs helper lemmas correctness proofs 
start family theorems mirroring correctness proof special case terms involved fully reconstructed 
appendix soundness lfi proof checking correctness fully explicit case correctness reconstruction algorithm fact reconstruction correct special case lf term type involved contain placeholders unification variables 
stated theorem 
correctness proof fully explicit form follows pattern proof general case simplifications 
show complete proof case 
just state lemmas involved 
theorem pf pf pf uvf uvf uvf fv proof proof theorem done similarly theorem induction derivation 
abstraction case simple 
application case need series auxiliary lemmas constraint collection solving judgments case fully explicit terms types 
lemmas stated proof 
lemma pf pf uvf uvf fv pf uvf pf uvf pf uvf uvf fv 
intuition lemma placeholders unification variables introduced 
terms subterms contain placeholders unification variables free variables types contain unification variables 
types constructed fully explicit types pf uvf fv subterms lack condition types 
lemma uvf uvf 
soundness lfi typing proof lemma induction structure unification judgment 
intuition lemma terms unified contain unification variables resulting substitution empty 
case terms equivalent 
lemma pf pf uvf pf uvf pf uvf pf uvf uvf fv proof lemma induction structure derivation 
unification solved lemma conclude resulting substitution empty unified types equivalent 
typing constraint solved hypothesis provides conditions necessary apply theorem conclude substitution empty typing constraints satisfied 
lemma pf pf proof lemma induction structure collection derivation 
placeholders disallowed typing constraints satisfied immediately prove typing rules lfi 
soundness lfi typing addition proving reconstruction algorithm succeeds lfi typing derivation proof need show existence lfi typing derivation guarantees existence typed fully explicit lf form proof 
adequacy lf representation theorems guarantee provability verification condition 
theorem stated page theorem proved section 
clarity restate theorem theorem soundness lfi typing pf pf exists lf appendix soundness lfi proof checking proof proof induction structure derivation case constants variables trivial 
case equivalence rule induction hypothesis assumption pf 
lf equivalence rule 
case abstraction assumption ensure apply induction hypothesis 
remaining cases deal application term placeholder 
case pf hypothesis pf apply induction hypothesis deduce exists lf theorem assumption pf 
infer pf pf 
justifies applying induction hypothesis inferring exists lf lf application rule infer lf evident remains proved case fv 
know hypothesis pf implies pf case rule application term similar case 
auxiliary lemmas lemmas correctness proof type reconstruction algorithm section 
trivial prove omit proof 
recall convention types involved statements theorems lemmas placeholder free 
lemma establishes canonical forms types lfi judgments 
lemma true 

auxiliary lemmas lemma saying reduction preserves type expression 
lemma pf continue crucial lemma proof correctness 
lemma says substitution typed certain unification variables preserves typing relation 
lemma dom fv pf dom 
pf 
proof lemma proof induction structure derivation case constant trivial constant type change substitution 
interesting cases variable unification variable 
case normal variable unification variable outside dom follows immediately definition 
case unification variable dom follows hypothesis variable fv consider cases case pf case apply induction hypothesis infer 
note hypothesis pf ensure implicit convention types preserved 
lemma get 
pf pf deduce pf 
lfi rule beta equivalence infer 
case set unification variables know 
occur deduce apply induction hypothesis conclude 
abstraction rule lfi deduce desired 
appendix soundness lfi proof checking case pf know pf iff pf pf 
induction hypotheses free variables pf pf pf induction hypotheses infer desired 
note implicit convention types pf implies pf pf 
case pf note case pf 
apply induction hypothesis derivation infer 
induction hypothesis infer 
follow steps previous case 
note 
lemma form 
uses form corollaries stated proved 
corollary pf 
proof corollary corollary follows immediately lemma note dom implies dom 
corollary pf fv proof corollary pf apply lemma dom fv infer 
fv 


auxiliary lemmas continue lemmas dealing typing substitution 
concerned typedness composition substitutions 
second deals restricted substitutions 
lemma pf pf pf 
proof lemma obvious pf 
prove consider unification variable dom 
dom case gamma lemma get desired dom dom case 
lemma dom dom dom dom proof lemma easy prove definition substitution applied type environments 
case contain unification variable contained get dom 
second part dom dom 

occur conclude dom lemmas required concerned equivalence 
proof trivial state proof 
lemma 
lemma 
