direct ray tracing displacement mapped triangles brian peter shirley michael stark university utah bes shirley cs utah edu 
algorithm ray tracing displacement maps requires additional storage base model 
displacement maps rarely ray tracing due cost associated storing intersecting displaced geometry 
unfortunate displacement maps allow addition large amounts geometric complexity models 
method works models composed triangles normals vertices 
addition discuss special purpose displacement creates smooth surface interpolates triangle vertices normals mesh 
combination allows relatively coarse models displacement mapped ray traced effectively 
visually rich images generated simpler models applying displacement maps increase surface detail 
displacement maps special type offset surface usually assumed perturb surface positions small distance function 
images displacement maps usually computed explicit subdivision 
displacement semi random procedural function uses perlin style noise 
somewhat surprisingly displacement maps ray tracing 
turns entirely technical reasons straightforward implementation need store fit main memory computers 
reason sophisticated caching strategies suggested 
caching strategies variety applications problematic applications resist reordering metropolis light transport 
alternatively explicit numeric root finding provided displacements nicely bounded 
third approach displacement mapped surfaces recursive subdivision scheme procedural geometry kajiya 
approach requires knowing tight bounds subdivided region displacement function order efficient 
global illumination algorithms require ray tracing desirable find simple way add displacement maps ray tracing programs 
allow realism global lighting complexity local geometric complexity 
introduce method ray tracing polygonal models displacements avoids complex strategies restricting allowable base geometry triangle meshes vertex normals 
narrow class modeling primitive modeling primitives converted triangle meshes practical manner 
key problem triangle meshes known artifacts 
show deterministic spline displacement function smooth tessellated models 
restricted base models represented feel fig 

image complex object created displacement mapping icosahedron 
ray traced global illumination 
triangles stored 
resulting benefits computation storage restriction 
section give overview assumptions model restrictions impose algorithm 
section ray intersection algorithm triangles displacement functions 
requirements displacement function smooth triangle meshes discussed section 
images resulting algorithm shown section 
discuss directions section 
overview inspiration method comes reyes rendering architecture 
simple architecture worked decades relies simplifying assumptions related displacements displacements bounded distance base surfaces know subdivide subdividing displaced base surfaces net simple sub pixel patches provides sufficient accuracy 
borrow assumptions directly 
assuming finely subdivided model provides sufficient accuracy normals directly derivative properties displacement need known 
add assumption displacements direction interpolated normal 
restrictive displacement mapping reyes architecture displaced surface base surface fig 

set points normals partitions space cells shaded traversed order ray 
observation holds 
analogous partition added cell 
type displacement mapping maya 
intersection method imagine base surface carved set vertices normals 
partition displace triangle vertices lie projected normal vectors base surface 
considers triangle possible displacements sweeps region space 
reasonably behaved surfaces adjacent triangles adjacent regions 
shape boundaries regions depends normal vectors base geometry behave 
imagines regions swept triangles triangle forming column space possibility traversal algorithm presents 
base geometry plane displacements perpendicular plane traversal algorithm similar usually ray intersections height fields traversed cells triangular rectangular cross sections 
choose base geometry general geometrically expressive restrictive traversal algorithm feasible 
practice obvious choices nurbs surfaces subdivision surfaces implicit surfaces 
primitive types quite different desirable find common representation converted 
obvious choice common representation triangulated mesh straightforward convert nurbs subdivision surfaces feasible implicit surfaces 
reason choose triangles base geometry 
ensure displaced surface continuous shared vertex normals displace normals computed barycentric interpolation phong normal interpolation 
general displacements useful leverage restriction direction displacement create simpler algorithm possible 
strengthen restriction bound displacement limit range possible displacements resulting displaced surface unable intersect 
point valid region corresponds exactly position displacement value base triangle 
restriction means region set neighbors requirement simple traversal algorithm 
means intersection closest intersection ray origin 
displacement framework assumes point underlying surface displaced direction normal vector displacement function 
triangle points corresponding normals displaced surface base surface fig 

simple displacement function normal direction creates new curve 
fig 

icosahedron displacement pushing point sphere 
interpolated points normals barycentric coordinates triangle displaced surface ray intersection ray intersection test similar spirit intersecting ray height field regular grid base plane 
take advantage implicit triangular grid formed barycentric coordinates 
choose subdivision amount dividing lines creates grid cells triangle 
grid cell generates displaced shown 
grid regular base triangle due interpolated surface normals irregular space 
irregular restrictions limit range displacement function interval traversal algorithm possible 
standard grid traversal algorithms phases algorithm 
start point initialized 
grid traversed checking cell intersection triangle contains 
traversal algorithm described order determine quantities need initialized 
base triangle volume fig 

base triangle displaced generated setting subdivision parameter 
volume maximum displacement shown 
traversal assuming able initialize traversal algorithm focus efficient traversal 
traversal conceptually simple triangles complicates indexing 
cell entered generated 
hit traversal missed cell determined new generated 
new triangle differ previous triangle exactly vertex 
means step grid need evaluate expensive displacement function 
position grid labeled triple corresponding lines constant barycentric coordinates indices sum depending triangle lower triangle upper triangle shown 
classification lower upper determines vertices generated indices 
lower triangle barycentric lines corresponding indices edges triangle 
upper triangle barycentric lines corresponding indices touch triangle vertices 
neat possible numbering schemes means triangle differs neighbors exactly index 
represented displaced points order chosen ray assumed entered cell passing side corresponding edge cell tested marked index change index incremented decremented 
flag represented depends orientation current triangle side cell ray exits 
knowing ray entered current cell usually options ray leaves cell 
exception ray exits face enters handled initialization code discussed 
options checked seeing side line determined snc far point normal ray passes shown 
list choices viewed ring possible choice flag ring increasing increasing lower upper increasing fig 

barycentric indexing 
moving adjacent triangles exactly index changes 
triangle change sign edges 
upper triangle smaller index 
fig 

ray tv passes normals leave normals normals tested ray passes left right goes left line tn negative 
previous flag ring 
traversal terminated checking values cell je ke determined initialization phase 
terminate traversal ray exits volume 
traversal loop expressed pseudocode follows ray ray ray including valid interval vector vertices ordered vector uva vertex vector normal vertex inti indices current cell bool flag determine cell change change float delta true ray return true return false ray origin ray direction uva take advantage numbering 
mod change change change return false vector delta delta change return false vector delta delta change return false vector delta delta change return false vector delta delta change return false vector delta delta change return false vector delta delta initialization initialization phase algorithm determine grid traversal algorithm starts ends 
volume traversal takes place shown 
top bottom space bounded triangles sides bounded bilinear patches 
start cells determined subdivision amount 
fixed displacement map adaptive projected screen area 
allow compute adaptive size area estimate distance camera user defined nmax 
initialization phase determine correct index starting traversal 
standard grid traversal algorithms traversal may start inside grid 
clearly sense ideal determining index arbitrary point equivalent determining barycentric coordinates displacement height point 
computation involves solving cubic equation method numeric problems 
solution treat ray infinite line find place line enters volume exits 
require longer traversal necessary uniform space subdivision ray tracing grid bounds environment complex object displaced triangle tends occupy relatively small fraction scene rays pass completely volumes triangles 
start points smallest largest intersections ray volume 
intersection point bilinear side patches barycentric coordinates zero parametric value intersecting side directly determine 
intersection point triangular caps barycentric coordinates intersection point exactly needed 
index grid cell 
part initialization determine face cell ray entered traversal algorithm determine appropriate cell 
intersection bilinear sides top bottom boundaries 
case bilinear walls cell checked 
ray entered top bottom side hit side ray leaves 
valid assume ray entered sides 
ray hit sides cell cell parameter matter 
complications complications created traversal algorithm walk irregular volume filled small triangles 
significant sides volume planar ray may intersect twice 
means traversal may exit grid reaching correct cell 
importantly intersection surface may lie second interval volume 
initialization code modified ray hits bilinear sides twice intersection interval traversal called new start cell determined second intersection point 
second complication occurs due sides grid cells non planar 
way cause problems briefly mentioned discussing traversal 
geometrically ray enter cell briefly quickly return cell 
happen algorithm way traversal chooses cell ray passes side point normal pairs side ray enters cell 
terms ray possibly intersect bilinear patch edge bc twice algorithm ignores double intersection chooses cell side edge ac 
certain extreme fig 

icosahedron smoothing displacement uses vertices vertex normals triangle displaced 
configurations possible ray may intersect missed cell 
cells general exactly bound possible ray hit neighbor triangle ray misses bilinear wall cell 
due small size significantly smaller size potentially missed piece noticed significant errors caused problem 
solution grow triangle slightly triangle intersection test solution prevent cracking simple triangle meshes 
chose experience expanding geometry eventually causes set problems 
final issue consider method potential create small triangles 
standard triangle intersection tests may suitable size input 
cause falsely missed 
intersection algorithm implemented entirely byte floats 
occasional rays surface problems frequency ray tracers simple polygonal objects 
smoothing displacement function mechanism create images displacements useful displacement creates smooth mesh 
allow rendering smoothed versions tessellated models additional displacements 
problem local possible smoothing displacement knowledge triangle vertices vertex normals 
knowledge neighboring triangles allow smoother surface create additional complexities representation triangle mesh 
examining smooth triangle meshes examined researchers problem different function algebraic form height function barycentric coordinates respect barycentric interpolated normals 
created simple smoothing displacement proof concept 
displacement interpolates triangle vertices smooth tangent plane transition adjacent triangles 
implies number constraints surface depend vertices vertex normals surface smooth triangle surface interpolate vertices triangle surface normal vertex match prescribed vertex normals tangent plane edge surface match constructed adjacent triangle joined patches meet continuity 
final requirement listed difficult satisfy hermite derivative interpolation difficult enforce line single points 
patch approach construct surface 
boundary curves prescribed tangent planes constructed ordinary hermite interpolation 
surfaces constructed interpolate boundary curves tangents edges 
surfaces blended way preserve derivatives remove bad edges final surface 
surface constructed terms barycentric coordinates 
approach applied icosahedron shown 
displacement function useful eliminating artifacts certain models creates objectionable artifacts models 
details smoothing function available technical report 
results evaluated system models large number displaced triangles 
additionally wanted verify robustness algorithm fairly extreme displacements 
scenes rendered parallel sgi mhz processors fairly standard monte carlo path tracer order capture shadows indirect lighting effects 
image shows icosahedron high frequency displacements roughly half sphere radius 
smoothing displacement outline icosahedron visually obvious 
second example piece containing initial triangles 
final displaced shown 
scene fixed 
initial triangles generated triangles geometry represented explicitly 
note instancing helped 
image shows global illumination shadowing effects grooves possible bump mapping ray tracer global illumination framework 
image rendered paths length pixel took roughly cpu hours run 
final example small section terrain data consisting roughly meter cells 
resulting triangles displacement mapped expensive displacement function uses turbulence function shown 
viewpoint set near ground roughly eye height person 
amount subdivision determined adaptively triangle 
view foreground subdivided large amount 
set nmax resulting potential input triangle approximately cm wide 
maximum achieved needed left quarter image facets seen 
storing triangles required terabytes 
implementation requires roughly megabytes terrain data 
image generated paths length pixel 
total cpu time hours 
believe optimizing algorithm displacement function reduce time changing assumption ray tracer object intersections cheap testing objects multiple times acceptable 
discussion algorithm produce ray traced images displacement mapped geometry resorting explicitly stored tessellation numerical 
goal system able render models large amounts displaced geometry 
resulting displaced geometry small explicitly generating polygons putting general acceleration scheme prove faster 
approach benefits processor speeds continuing grow faster memory speeds sizes provides viable alternative geometry caching schemes numerical root finding 
view proof concept 
potential numeric stability problems traversal 
areas efficiency improved 
adaptively determining subdivision amount provides performance benefits problems occur 
changing level subdivision adjacent pixels may cause tearing 
conservative choosing subdivision level haven seen artifacts due 
potentially serious problem occurs displacement maps represent surfaces scratched metal 
reducing subdivision level result significant changes appearance geometry subpixel 
case carefully replace geometry brdf discussed becker max 
current spline smoothing displacement function ensures base tessellations converted smooth surfaces 
smooth surface desirable particularly regions high curvature triangles poor aspect ratios 
may take information surface allowed restrictions section eliminate problems 
global interpolation scheme ensure higher orders continuity intuitive fit data 
acknowledgments michael mark bloomenthal elaine cohen simon helpful discussions 
alias wavefront donation maya 
supported nsf cda 

alias wavefront 
maya 
toronto canada 

becker max smooth transitions bump rendering algorithms 
computer graphics siggraph proceedings aug kajiya ed vol 
pp 


cook carpenter catmull reyes image rendering architecture 
computer graphics siggraph proceedings july 
held anaheim california 

hahn global illumination implementation renderman standard 
journal graphics tools 
issn 

seidel 
ray tracing procedural displacement shaders 
graphics interface june 
isbn 

kajiya new techniques ray tracing procedurally defined objects 
computer graphics siggraph proceedings july vol 
pp 


krishnamurthy levoy fitting smooth surfaces dense polygon meshes 
siggraph conference proceedings aug rushmeier ed annual con ference series acm siggraph addison wesley pp 

held new orleans louisiana august 

patterson inverse displacement mapping general case 
computer graphics forum december 

grid tracing fast ray tracing height fields 
technical report yaleu dcs rr yale university dept computer science research 

pederson displacement mapping flow fields 
proceedings siggraph orlando florida july july glassner ed computer graphics proceedings annual conference series acm siggraph acm press pp 

isbn 

perlin 
computer graphics siggraph proceedings july lane ed vol 
pp 


hanrahan geometry caching ray tracing displacement maps 
eurographics rendering workshop june 
isbn 
held porto portugal 

phong 
illumination computer generated pictures 
communications acm june 

shirley stark direct ray tracing smoothed displacement mapped triangles 
tech 
rep uucs computer science department university utah march 

hart guaranteeing topology implicit surface polygonization interactive modeling 
siggraph conference proceedings aug whitted ed annual conference series acm siggraph addison wesley pp 

isbn 

guibas metropolis light transport 
siggraph conference proceedings aug whitted ed annual conference series acm siggraph addison wesley pp 

isbn 
fig 

vase modeled triangles showing interreflection effects 
generating displaced resulted triangles 
fig 

terrain dataset initial polygons shown displacements left 
right nmax procedural displacement map 
instantiating geometry resulted triangles 

