systematic study functional language implementations mi douence pascal fradet inria irisa campus de beaulieu rennes cedex france douence irisa fr fradet irisa fr introduce unified framework describe relate compare classify functional language implementations 
compilation process expressed succession program transformations common framework 
step different transformations model fundamental choices 
benefit approach structure decompose implementation process 
correctness proofs tackled independently step amount proving program transformations functional world 
approach paves way formal comparisons making possible estimate complexity individual transformations compositions 
study aims covering known design space sequential functional languages implementations 
particular consider call value call name call need reduction strategies environment graph implementations 
describe compilation step diverse alternatives program transformations 
cases illustrate compare relate compilation techniques express global optimizations hybrid implementations 
provide classification known machines 
key words functional programming compilers optimization program transformation combinators studied issues concerning functional languages implementation 
landin seminal proposal years ago plethora new machines compilation techniques proposed 
list existing machines includes secd cam tim zam machine krivine machine 
implementations described machine collection transformations compilation techniques compilers continuation passing style cps 
furthermore numerous papers optimizations adapted specific machine specific approach 
looking myriad distinct works obvious questions spring mind fundamental choices 
respective benefits alternatives 
precisely common points differences compilers 
particular optimization designed machine adapted machine 
finds comparatively papers devoted questions 
studies relationship individual machines best knowledge global approach study implementations 
goal fill gap introducing unified framework describe relate compare classify functional language implementations 
approach express compilation process succession program transformations 
common framework considered hierarchy intermediate languages subsets lambda calculus 
description implementation consists series transformations tn compiling particular task mapping expression intermediate language 
language consists functional expressions seen assembly code essentially combinators explicit sequencing calls 
step different transformations designed represent fundamental choices optimizations 
benefit approach structure decompose implementation process 
seemingly disparate implementations share compilation steps 
approach interesting payoffs far correctness proofs comparisons concerned 
correctness step tackled independently amounts proving program transformation functional world 
approach paves way formal comparisons estimating complexity individual transformations compositions 
concentrate pure expressions source language fundamental choices described simple language 
steps cause greatest impact compiler implementation reduction strategy searching redex environment management compilation reduction 
steps include implementation control transfers calls returns implementation closure sharing update implied call need strategy representation components data stack environments various optimizations 
section describe framework model compilation process 
section alternatives compile reduction strategy call value call name 
compilation control graph peculiar 
separate section dedicated point 
section ends comparison compilation techniques call value study relationship compilation control environment graph models 
section resp 
section describes different options compile reduction resp 
control transfers 
call need call name redex sharing update section expressed framework 
section embodies study taxonomy classical functional implementations 
section outline extensions applications framework 
section devoted review related section concludes indicating directions research 
order alleviate presentation involved material proofs variants transformations technical details kept main text 
refer motivated reader electronically published appendix 
appendix noted 
previous conference concentrates call value short :10.1.1.35.2834
additional details companion technical reports phd thesis :10.1.1.35.2834:10.1.1.35.2834
general framework compilation step represented transformation intermediate language closer machine code 
implementation process described transformation sequence starting involving intermediate languages close 
framework possesses benefits strong formal basis 
intermediate language seen formal system conversion rules subset calculus defining constructs expressions 
intermediate languages share laws properties important reduction strategy normalizing 
features facilitate program transformations correctness proofs comparisons 
relatively 
want model completely precisely implementations intermediate languages come closer assembly language progress description 
framework possesses features lessen precision 
combinators intermediate languages conversion rules allow description notions instructions sequencing stacks encoding expressions 
consequence compilation control expressed abstractly cps expressions implementation components data stack environment stack separate step 
modular 
transformation implements compilation step defined independently steps 
transformations implementing different steps freely composed specify implementations 
transformations implementing step represent different choices compared 
extendable 
new intermediate languages transformations defined inserted transformation sequence model new compilation steps register allocation 
overview step compilation control described transformations intermediate language defined combinators push new form abstraction intuitively sequencing operator read evaluate evaluate push returns result sx binds previous intermediate result evaluating pair push specifies component noted storing intermediate results data stack 
push seen store fetch notable syntactic feature rules unrestricted applications 
main property choice weak redex relevant anymore weak redexes needed 
key point view transformations compiling evaluation strategy 
transformations compile reduction 
language excludes unrestricted uses variables needed define macro combina tors 
encoding environment management possible new pair push 
behave exactly push just act conceptually different component stack environments 
push push push push push push push push push push intermediate languages transformations describe compilation control transfers 
language calls returns explicit 
introduces pair push specifies component storing return addresses 
transformations adds memory component order express closure sharing updating 
language introduces pair push specifies global heap expressions language read assembly code 
conversion rules substitution notion free bound variables calculus 
basic combinators different definitions possible definitions 
pick specific ones point simply impose associativity sequencing combinators satisfy equivalent conversions 
assoc push push occur free conversion rules consider reduction rules corresponding classical reduction push standard implementations interested modeling weak reductions 
framework weak redex redex occur inside expression form push ix weak reduction reduce push write redex resp 
reduction normal form weak redex resp 
weak reduction weak normal form 
example illustrates reduction note push weak redex global expression 
push push push push push push push push push push push push redexes clearly disjoint reductions left linear term rewriting system orthogonal confluent 
alternatively easy show relation strongly confluent confluent furthermore redex needed rewrite suppress redex property reduction strategies normalizing 
property key point view transformations compiling reduction order 
typed subset expressions intermediate languages meaning expressions section 
conversion rules assoc expression represented differently 
example write equivalently push push push push flexibility useful transform reshape code 
unrestricted transformations may lose information structure expression 
laws transformations see laws section transformation hc section rely fact subexpression denotes result reduced expression form push function reduced expression form 
allow subexpressions push push denote result function laws transformations expressed 
convenient restrict type system 
push typed subset restrictions enforced type system results functions combined example composition restricted denotes result type type constructor denotes function 
type system restricts set normal forms general includes expressions push push natural facts property closed expression normal form push closed expression normal form reduction typed expression reaches expression form push loops 
transformations implementing compilation steps produce typed expressions denoting results compilation process compiled program typed 
typing maintain structure expression impose restrictions source expressions regarded syntactic tool se mantic 
ill typed expressions meaning terms expressions see section 
laws framework possesses number algebraic laws useful transform functional code prove correctness equivalence program transformations occur free occur free rules permit code moved inside outside function bodies invert evaluation order intermediate results correct consider purely functional expressions 
illustrate conversion rules prove law 
note occur free ix hypothesis push push assoc subst rules laws 
assoc may lead untyped programs long final program typed 
example closed typed expression push push transformed assoc typed expression push push simplify presentation omit parentheses write example push push 
syntactic sugar tuples simple pattern matching instantiation intermediate languages subsets calculus combinators 
important point give precise definition combinators 
just assume respect properties assoc 
definitions chosen compilation step 
feature allows shift reduction state machine expression reduction 
permits specify implementation components independently steps 
example may eventually choose implement data component environment component single stack separate ones 
section example instantiation cam 
order provide intuition give possible definitions terms standard expressions 
natural definition sequencing combinator abc 
fresh variable seen continuation implements sequencing 
pairs combinators push seen encoding component underlying machine definitions specifying state transitions 
sequence code push push suggests underlying machine possess component stack list tree vector order store intermediate results 
choose keep components separate merge 
keeping components separate leads possible definitions fresh variables push push push push reduction classical reduction normal order expressions seen state transitions machine components code data stack environment stack control stack heap push push definition rewriting rule sequencing note plays role continuation 
code seen state transformer type data env control heap ans data env control heap ans reduced code applied initial continuation id initial empty data environment control components initial heap 
keeping components separate brings new properties allowing code motion simplifications 
push push push push second option merge components 
underlying machine components code data environment control heap stack 
possible definitions push push push push reduction expressions form push point term machines suggest layer interpretation 
abstraction consists components generic code 
compilation process get realistic assembly code machines resemble real machines 
compilation control focus compilation call value call name reduction strategies 
call need refinement call name involving redex sharing update 
described section 
main choices taken implementations 
peyton jones terminology options named eval apply model section push enter model section :10.1.1.53.3729
graph implementations interpretative implementation reduction strategy 
section 
compare eval apply push enter schemes call value relate environment machines graph 
eval apply model eval apply model abstraction considered result application function argument explicit operation 
model natural choice implement call value functions evaluated arguments 
call value scheme applications compiled evaluating argument function applying result result normal forms denote results abstractions variables strict languages bound normal forms transformed results push 
compilation right left call value formalized transformation va 
compilation choice taken secd machine compiler 
rules explained intuitively reading return value push evaluate va apply app 
environment management tackled section useful keep mind expression returning function push involve building closure data structure containing function environment recording values free variables 
va va push va push va va va va app app compilation right left call value eval apply model va strictly speaking va enforce right left evaluation va reduced va 
instantiation normal order reductions en force sequencing nature 
easy check va produces typed expressions result type rs correctness va stated property establishes reduction transformed programs simulates call value reduction cbv source expressions standard consider source program global expression closed expression 
property closed expression cbv va va clearly useless store function apply immediately 
optimization expressed law push app push example 
simplifications get va push push push push push push push push push va source expression redexes chosen call value strategy 
contrast va compiled version redex 
illicit call value reduction occur va illustrates fact reduction strategy compiled choice redex semantically relevant 
law central implementation uncurrying see 
illustrate simple case uncurrying take case function applied arguments va va va push push va app app assoc expression simplified va va va app combinators statically removed 
doing avoided construction intermediary closures corresponding unary functions denoted important point note denotes ary function say function applied arguments push 
exist variants va va cam implements left right call value sml nj compiler assume data stack disallows pushes row call name call name eval apply model applications compiled returning evaluating applying evaluated function unevaluated argument 
choice implemented call need version compiler described transformation na 
na na na push na na push na na app app compilation call name eval apply model na correctness na stated property establishes reduction transformed expressions simulates call name reduction cbn source expressions 
property closed expression cbn na na example 
simplifications get na push push push push push push va illicit call name reduction occur na va transformation na variant assume data stack disallows pushes row push enter model eval apply model straightforward compilation function expecting arguments produces code building closures 
practice overhead removed uncurrying optimization possible functions passed arguments 
main motivation push enter model avoid useless closure buildings 
push enter model unevaluated functions applied right away application implicit operation 
call value evaluating function argument applying results eval apply model solution evaluate argument apply unevaluated function right away 
call value function evaluated argument 
case immediately applied returned result 
order detect evaluation way distinguish argument absent role marks 
function evaluated test performed mark function returned result closure built argument function applied 
technique avoids building closures price performing dynamic tests 
implemented zinc 
mark supposed value distinguished 
functions transformed grab satisfies reduction rules push grab push mark function returned push grab push mark function applied argument combinator grabs mark defined practice grabs implemented conditional testing presence mark 
transformation left call value described 
vm vm grab vm grab vm vm push vm vm compilation right left call value push enter model vm correctness vm stated property 
property closed expression cbv vm vm example 
simplifications vm push push grab grab grab push grab grab grab push grab grab grab grab vm function known applied arguments code optimized save dynamic tests 
appears vm subject kind optimizations va uncurrying related optimizations expressed reduction rules grab 
sense consider left right strategy 
point approach prevent building closures testing argument 
argument evaluated function 
closely related transformations marks exist call name contrary call value natural choice implement call name push enter model 
call name functions evaluated applied argument 
functions considered results 
option taken tim krivine machine graph implementations see section 
transformation nm formalizes choice described 
nm nm nm nm nm push nm nm compilation call name push enter model nm variables bound arguments evaluated accessed 
functions returned results assume argument 
applications transformed returning unevaluated argument function 
correctness nm stated property 
property closed expression cbn nm nm example 
nm push push push nm arguably nm simplest way compile call name 
compilation call need problematic 
evaluation unevaluated expression bound variable closure call need implementation updates normal form 
contrary na nm impossible distinguish results closures updated regular functions applied right away 
problem solved vm help marks 
come back issue section 
transformations share goal compiling control cps transformations 
properly chosen instantiation combinators transformation fischer cps transformation cps expressions possible design inverse transformation mapping expressions back expressions graph reduction graph implementations manipulate graph representation source expression 
reduction consists rewriting graph 
motivations approach elegantly represent sharing ubiquitous call need implementations 
call value envisaged known graph implementations consider call need 
focus push enter mod el call name largely adopted existing graph 
refinement call need section 
graph building compilation control expressed transformations step divided parts graph construction reduction interpreter 
transformation produces expression builds graph tree reduced 
push push generic graph building code new combinators take arguments component return graph nodes respectively variable function application nodes condition formalizes fact reduction just graph construction terminates yields result component 
expression push graph scanned reduced small interpreter denoted combinator unwind compilation control global expression form unwind transformation common graph reduction schemes describe 
push enter eval apply models compilation call value call name specified simply defining interactions unwind graph builders mk var call name push enter model option defined conditions gnm unwind unwind gnm push unwind unwind gnm unwind unwind conditions explained intuitively gnm reduction variable node amounts reducing graph bound variable 
combinator may useless bypassed unwinds call need considered needed implement updating losing sharing properties 
combinator represents indirection nodes 
gnm reduction function node amounts applying function argument reducing resulting graph 
rule push enter model clear 
reduction function node return function result immediately applies 
gnm reduction application node amounts storing argument graph reducing function graph 
presents possible instance graph combinators 
push push push unwind push push unwind app instantiation graph combinators gnm option node code graph encoded data structures code performing needed actions 
example takes function returns code builds closure evaluate function applied argument unwind takes expressions returns code apply encoding simplifies interpreter just trigger code unwind just application 
easy check definitions verify conditions gnm gnm gnm 
definition identity function clear indirection chains collapsed 
say combinator instantiation graph represented closures 
classical representations data structures mentioned section 
correctness respect conditions gnm stated property property gnm gnm gnm hold closed expression cbn unwind unwind compared corresponding properties previous transformations va na vm nm property expressed equality reduction 
normal form unwind may contain indirections nodes general syntactically identical unwind verifies stronger easily formalized property property unwind reduces expression removal indirection chains syntactically equal graph example 

push push unwind unwind unwind iz iy ix unwinds push push 
push push unwind iz iy unwinds push 
push push unwind iz unwinds iz unwinds example indirection chain result syntactically equal graph source normal form 
push unwind exactly unwind reductions corresponding graph construction 
sequence reductions corresponds graph construction 
unwind scans leftmost spine push represents application node 
graph representing function applied 
result application node push push scanned unwind reduction proceeds way reaches normal form 
interpretative essence graph reduction naive implementation call need possible introducing marks opposed nm section 
scheme performs useless updates detected simple syntactic criteria sharing analysis 
optimized implementation performing selective updates defined introducing marks 
points section 
choices graph associated reducer seen data type different implementations 
encoding represents nodes code closures 
natural solution represent graph data structure 
amounts introducing data constructors defining interpreter unwind case expression 
refinement exploited machine enclose nodes code executed unwound 
adding code data structures comes close solution closures described 
interpreter unwind just execute code perform dynamic test 
case new combinator definitions verify gnm properties order implement push enter model compilation call name 
far common graph reduction implementation call need push enter model 
eval apply model compilation call value expressed 
choices specified redefining interactions unwind graph builders 
case amounts defining new properties gnm gnm gnm 
details alternate choices 
comparisons compare efficiency codes produced transformations va eval apply cbv vm push enter cbv 
exhibit precise relationship environment graph approaches 
particular shown derive transformation nm properties 
take examples show advantages unified framework terms formal comparisons 
clear comparisons carried transformations compilation steps 
va versus vm emphasize comparisons focus finding complexity upper bounds 
take place benchmarks required take account complex implementation aspects interactions memory cache garbage collector 
code produced vm builds closures corresponding va code 
mark represented bit bit stack parallel data stack vm average efficient respect space resources 
concerning time efficiency size compiled expressions provides approximation cost entailed encoding reduction strategy assuming push grab app constant time implementation 
easy show code expansion linear respect size source expression 
precisely vx va vm size size vx 
upper bound reached example occurrences 
thorough investigation possible associating costs different combinators encoding control push cost pushing variable mark clos cost building closure push app grab cost corresponding combinators 
take number abstractions number occurrences variables source expression cost va clos push app cost vm grab push benefit vm va replace useless closure construction test 
closure built vm involves useless test compared va clos comparable cost test example returning closure amounts building pair section vm produce expensive code va closure building constant time operation section vm arbitrarily better va change program complexity contrived cases 
practice situation clear 
mark grab implemented test followed app 
mark test followed push closure building abstractions 
cost vm test app clos push push resp 
representing likelihood presence resp 
absence mark depends program 
best situation vm closure built 
take reasonable hypothesis test app find cost closure construction times costly app test vm advantageous 
favorable odds clos worth app 
led conclude vm considered closure building potentially costly ac transformation section builds closures copying part environment 
tests may costly practice compared construction small closures 
best way probably perform analysis detect cases vm profitable 
information taken account get best approach 
va vm mixed 
environment machine versus graph reducer starting points utterly different graph environment machines related 
done specific implementations shows transform machine tim 
focus compilation control compare transformation nm gnm approach graph reduction 
main departures graph reduction environment approach potentially useless graph constructions 
example rule builds graph reduced needed 
hand nm suspends operations variable instantiation building closure nm nm nm 
interpretative nature graph reduction 
node code instantiation application node interpreted unwinds environment family interpreter needed approach seen specialization interpreter unwinds source graph built order formalize points change rule graph building case applications push unwind corresponds lazy graph construction graph argument built needed 
particular variables bound graphs 
new kind graph entails replacing property gnm gnm push unwind show nm merely specialization unwind respect graph nm unwind example specialization application case unwind push unwind unwind unfolding push unwind unwind gnm push nm nm induction hypothesis nm folding property shows far compilation control concerned environment transformations efficient graph counterpart 
optimized graph avoid possible interpretative scans graph graph building similar environment implementations 
compilation reduction compilation step implements substitution transformations transformations akin abstraction algorithms consist replacing variables combinators 
compared adds pair push encoding environment component uses variables define combinators 
graph specific usually environment transformations 
express framework ski abstraction algorithm section 
environment abstractions calculus reduction defined textual substitution 
environment implementations substitutions compiled storing value substituted data structure environment 
values accessed environment needed 
technique compared activation records imperative language compilers 
main choice list shared environments vector copied environments 
choice transformations depending environments copied 
generic abstraction denotational transformation ag generic abstraction specialized model choices sections 
introduces environment values variables stored fetched 
transformation done respect compile time environment initially empty closed expression 
note variable occurring ith entry environment 
ag env ag dupl ag swap se ag ag push push ag mkclos ag mkbind ag ag access appclos generic abstraction ag ag needs new combinators express environment saving restoring dupl swap se closure building calling mkclos appclos access values access adding binding mkbind 
combinator pair dupl swap se defined dupl push push swap se push push note swap se needed implemented single component 
approach choice final implementation step see section 
eventually implemented say distinct stacks new algebraic simplifications valid particular swap se removed definition expression identity function 
closure combinators mkclos appclos different definitions long satisfy condition push push mkclos appclos push evaluating closure function environment amounts evaluating environment example possible definitions mkclos push appclos push mkclos push push appclos app option uses pairs way concrete 
second option abstracts representation considerations 
simplifies expression correctness properties rest 
way environment combinators mkbind access instantiations note comb sequence comb comb times definitions mkbind access satisfy condition push push push mkbind access push property simply says adding bindings environment accessing ith value equivalent returning directly examples definitions mkbind access appear 
transformation ag optimized adding rules ag app ag appclos ag pop se ag free pop se push variables bound closures stored environment 
original rules ag push build closure 
useless boxing may lead long indirection chains avoided rule ag push access new rule duplicates closure address depends memory management section 
call need sure access returns address closure closure duplication may entail loss sharing 
shared environments choice instantiate ag linked environments 
structure environment tree closures closure added environment constant time 
hand chain links followed accessing value 
access time complexity number occurrence variable binding de bruijn index 
specialization noted cam secd strict lazy versions krivine machine 
specializing ag amounts defining environment combinators follows mkbind push access fst snd times fst push snd push combinator instantiation shared environments example 
push mkbind mkbind dupl push mkclos swap se access appclos bindings added mkbind mkbind current environment access coded access fst snd 
correctness stated property property closed typed expression push copied environments choice provide constant access time 
case structure environment vector closures 
code copying environment length operation inserted ag order avoid links 
scheme prone space leaks permits suppressing useless variables copies 
macro combinator copy produces code performing copy structure 
copy dupl access swap se dupl access swap se access push mkbind combinators dupl swap se needed pass environment access store value environment values fresh copy environment built push mkbind 
see structure environment tree closures effect copy prevent sharing 
environments represented vectors 
combinator mkbind adds binding vector access constant time operation 
mkbind push access push adds value empty cell vector combinators instantiation abstraction copied environments ac index designates free cell vector 
statically computed rank variable associated mkbind occurrence static environment 
example ac mkbind ac rank stored fourth cell environment 
maximum size vector statically calculated 
simplify presentation leave administrative tasks implicit 
abstractions time copies 
indicating rules differ ag 
solution copy environment just adding new binding 
compilation step know ary functions fully applied shared need copy environment 
overhead placed function entry closure building remains constant time operation 
transformation ac produces possibly oversized environments shared closures 
indirection accessing environment 
environment represents restricted variables occurring free subexpression ac copy mkbind ac copy function entry ac example 
ac push copy mkbind dupl push ac mkclos swap se access appclos code builds vector environment specialized copy previous environment new bindings mkbind access coded constant time access second solution copy environment building opening closures 
copy opening time necessary order able add new bindings contiguous memory environment remain vector 
transformation ac produces environments shared may accessed directly packaged code pointer form closure 
ac push copy push copy ac mkclos copy closure building opening ac refinement option ac abstraction copy environment building closures 
variations ac sml nj compiler spineless tagless machine :10.1.1.53.3729
order able add new bindings closure opening additional local environment needed 
starting different properties collection abstractions systematically derived ag 
abstractions new wellknown implementations 
example starting equation ag swap ag derive swap transformation ag variation environments stay fixed distance bottom stack popped swapped 
variations introduce different environment ma schemes avoiding stacks elements reordering swap environment duplication dupl environment building mkbind closure building mkclos comparison assuming basic combinator implemented constant time size abstracted expressions gives approximation overhead entailed encoding reduction 
easy show entails code expansion quadratic respect size source expression 
precisely size size va number abstractions number variable occurrences source expression 
expression reaches maximum 
upper bound approached example 
product indicates efficiency depends equally number accesses length 
ac size size ac va clear efficiency ac dependent accesses 
transformations complexity order may adapted individual source expressions 
complexities highlight main difference shared environments favors building copied environments favors access 
point bounds related quadratic growth implied turner abstraction algorithm 
balancing expressions reduces upper bound nlogn 
technique applied expressions get nlogn complexity environment management 
abstractions compared memory usage 
ac copies environment closure ac may share bigger copy 
code generated ac consumes memory implies frequent garbage collections code generated ac may create space leaks needs special tricks plug see section 
ski abstraction algorithm abstraction algorithms environment notion encode separately substitution 
simple algorithm uses combinators inefficient respect code expansion 
different refinements extended combinators families proposed 
usually lower complexity code expansion exponential quadratic nlogn 
describe ski abstraction algorithm 
clear optimized versions expressed easily framework 
possible define transformation ski applied expressions :10.1.1.35.2834
particular composed transformations compilation graph reduction control section 
resulting code correct accurately model classical compilation scheme ski machine 
easiest way model precisely define transformation specialized graph code 
ski var ski push ks ski free ski ski push ss ski push ski ski ski push push abstraction ski ski ss ks combinators build select graph 
defined ss push push push push ks push push way transformation ag dsb dupl swap mkbind abstraction algorithm specialized graph code :10.1.1.35.2834
precisely model classical abstraction machine 
compilation control transfers conventional machine executes linear sequences basic instructions 
framework reducing expressions form appclos involves evaluating closure returning calls returns explicit 
solutions 
push push push rts general compilation control transfers rts push solution adopted implementations save return address call stack transformation saves code function call push returns rts push function ends 
intuitively combinators seen implementing control stack 
compared expressions appclos code sequences 
correctness stated property 
property closed typed expression normal form optimized version different previous transformations easily derived 
example get dupl swap se dupl push swap se swap ke second solution transformation sl control abstraction phases sl 
transforms expression cps 
continuation encodes return addresses abstracted ordinary variable 
transformation rules sl push push sl sl push push sl sl replaces returns continuation calls second rule encodes return stack continuation composition 
solution sml nj compiler 
sharing updates call need strategy optimization call name strategy shares updates closures 
order express sharing introduce memory component store closures 
evaluation unevaluated argument amounts accessing closure memory reducing updating memory normal form 
way argument reduced 
new intermediate language adds combinator pair push specifies memory component component represented accessed heap pointer 
transformation hc threads component closures allocated accessed 
express updating options specific graph reduction 
heap transformation hc introduces new component encodes heap threaded expression 
reduction expression heap single threaded 
transformed expression hc takes heap argument returns heap result 
rules hc responsible making closure allocation access explicit 
framework constructions updatable closures form push accesses updatable closures form bound rules contexts 
context store read allocate new cell heap write code cell return address heap 
context call read access expression stored heap cell address reduce heap argument 
henceforth argument function closure address closure 
closure address represented integer heap represented pair list written cells address free cell tail add val free 
initial empty heap noted defined 
combinators alloc write read perform basic heap manipulations 
single threaded combinators implemented efficiently constant time operators mutable data structure 
hc fresh variable hc hc hc hc push hc hc push store hc push hc push hc call bound store push alloc push push push write push push call push push read push alloc heap free push free push heap free write heap free add val push heap add val free read heap add val free add add add push val push heap free push add read introducing heap closures allocated accessed hc apply transformation hc get new versions combinators introduced previous compilation steps 
combinator create call closure transformation hc threads heap interaction 
example combinator dupl introduced abstraction ag get dupl eh hc dupl push push push hand combinators appclos mkclos create call closures 
transformed definitions call store appclos hc appclos hc push call mkclos hc mkclos push store push push updating transformation hc memory management explicit 
heap stored closure reduced time accessed 
call need strategy updates heap allocated closures normal forms 
main choice update performed caller code closure accessed callee code closure 
caller update scheme updates closure time accessed callee update scheme updates closures time accessed normal form accesses entail useless updates 
scheme efficient implemented realistic environment implementations 
model callee updates 
callee update order self updating closures transformation changes rule hc push introduces combinator takes arguments heap address result address closure updated 
returns address new heap cell contains indirection combinator swap sh reorders address heap 
push store push swap sh swap sh push push push push push push push write callee closure update push push closure allocated heap created hc code modified 
closure stores address push evaluation followed 
note variable bound context store see definition store denotes address fresh allocated cell 
course syntactically normal form simple rule push store suffices 
closure updated access compiled code normal form hc push contains 
callee update scheme nm 
noted section marks inserted expressions suspend reduction performing update 
rule abstractions nm grab nm specialized push enter model follows push store push swap sh push swap sh resume resume push grab evaluation context isolated inserting mark update address push resume resumes reduction update performed 
combinator grab defined hc grab marks tim clean krivine machine spineless tagless machine :10.1.1.53.3729
codes produced na nm update opportunities 
call name call need version nm may prevent building unnecessary intermediate closures 
updating graph reduction previous transformations employed transform call name graph reduction schemes call need 
updating techniques spineless spine variations introduced machine 
spineless machine updates selected application nodes 
unwinding application nodes entails stacking address updatable argument address non updatable 
general complete leftmost spine graph appear stack 
code annotate updatable nodes marks necessary dynamically detect update performed 
updatable nodes distinguished combinator definition redefined detect marks push push push grab push unwind transformation push enter model applied graph constructors 
get store push swap sh push swap sh push resume suggested section marks mandatory express updating machine graph building graph reduction separate steps 
application nodes stack address unwound updates systematically inserted graph building reduction step 
naive scheme call spine variation expressed previous transformations 
canonical definition gnm push push push hc shares expressions form push application nodes considered updating definition order model scheme new transformation defined see 
threaded memory component functional intermediate code formal manipulations complicated 
example property ensuring reduction hc simulates reduction decompilation transformation order replace addresses reduced expressions actual values lie heap 
prevented finding simple convincing formulation correctness properties transformations section 
classical functional implementations description compilation process complete 
compiler described simple composition transformations 
states main design choices structuring classical implementations 
cosmetic differences descriptions real implementations 
descriptions literature leave compilation control transfers implicit cam tim 
extensions optimizations described 
describe precisely modeling categorical machine state differences description 
cam implements left right call value strategy eval apply model linked environments 
framework expressed cam va simplifying composition transformations get cam fst snd cam push mkbind cam mkclos cam dupl cam swap se cam appclos appclos push illustrate output consider expression cam dupl push mkclos swap se dupl push mkclos swap se mkbind snd push mkclos appclos appclos code linear code sequences composed combinators implemented standard assembly instructions 
minor step consisting naming code fragments left implicit 
instantiating combinators get rules machine 
cam components merged instantiation abc push push definitions macro combinators follow 
example dupl push push mkbind push snd push combinators considered basic instructions machine definitions imply state transitions dupl mkbind snd fst snd dupl swap se combinators correspond cam fst snd push swap 
sequence push mkclos equivalent cam cur 
difference comes place mkbind closure case 
shifting combinator place closures evaluated merging appclos get push mkbind exactly cam sequence cons app 
gathers implementations strict lazy functional languages 
refers transformations described 
quickly review differences real implementations 
clean implementation graph rewriting final code similar environment machines example closure encoded ary node 
replica environment machine believe close 
numerous optimizations especially lack clear description details examples final code difficult precisely determine compilation choices 
compiler transformations components cam va id id clean nml ac id machine gnm ac dsb id spineless machine ac dsb id spineless tagless machine nml ac id mak cbn nml id cbv vm id secd va id ski machine gnm ski id sml nj va ac sl id registers cbv va ac dsb id cbn na ac dsb tim nml ac id classical compilation schemes machine spineless machine perform test arguments function comparing arity function activation record size grab combinator performs test argument 
ary combinator grabs introduced 
spineless tagless machine uses ary version grab local global environment :10.1.1.53.3729
abstraction environments ac framework directly compatible grab extra environment copies inserted 
simplest way model faithfully real machine introduce specialized abstraction algorithm 
grab instruction krivine machine mak combination grab fact recursive version mkbind combinators 
secd machine saves environments bit scheme 
furthermore control stack environment stack grouped component called dump 
data stack saved dump 
replica closer idealized version derived 
ski machine reduces graph combinators application nodes 
graph representing source expression totally built compile time 
machine recursive interpreter data stack store unwound spine 
modeling close somewhat informal description ski machine 
sml nj compiler uses heap represented framework unique environment includes registers numerous optimizations described 
compiler product greatly inspired study 
implements strict non strict languages program transformations 
integrated optimizations described 
call name tim description accurate 
environment copying included transformation ac effect preliminary lambda lifting phase tim 
ary grab added call need version 
extensions applications framework powerful handle realistic languages model optimizing compilers hybrid implementations 
illustrate point turn 
integration constants primitive operators data structures take example express classical global optimization describe hybrid transformation 
constants primitive operators data structures considered pure expressions fundamental choices described simple language 
realistic implementations deal constants primitive operators data structures easily taken account framework 
concerning basic constants question results basic type returned component push introduced 
advantage marking difference pointers values exploited garbage collector 
case precise type information available compile time transform variables abstractions correctly 
polymorphic setting information available general variable polymorphic type bound constants functions data structures stored fix point operator conditional primitive operators acting basic values introduced language straightforward way 
compilation control eval apply model constructs described 
naive compilation reduction letrec expressions yields code building closure recursive call 
optimizations exist 
consists building lar environment graph 
second optimization environment machines implement recursive calls statically known functions jump address letrec push push push push push cond push true cond push false cond plus push push plus push head head cons cons head tag push cons push tag extension constants primitive operators lists far data structures concerned choose represent tags higher order functions 
describes possible extension data stack store constants tagged cells lists 
just indicates simple way accommodate data structures framework 
efficient implementation data structures brings new collection choices see optimizations see 
thorough description subject scope 
considered pure expressions typing source language issue 
constants data structures taken account cases arise depending typing policy source language 
source language statically typed code produced transformation need modified supporting polymorphism efficiently involves new specific optimizations unboxing floats tuples 
dynamically typed languages functions constants data structures carry type information checked combinators primitive operators run time 
optimizations take example optimization brought strictness analysis call need implementations 
changes evaluation order interestingly avoids thunks unboxing 
assume strictness analysis annotated code denotes strict function variable defined strict abstraction na optimized follows na push na na na app underlined variables known evaluated represented unboxed values 
example strictness information expression compiled push push push plus 
code push represented closure evaluated call boxed representation 
strictness annotations push push push plus evaluation call value closure built 
general forms unboxing optimizations floating expressed 
hybrid implementations study different options showed universal best choice 
natural strive get best world 
framework intricate related correctness proofs possible 
example possible mix eval apply models design va vm hybrid transformation 
describe mix shared copied environments 
suppose static analysis produced annotated code indicating chosen mode subexpression 
solution coercion functions fit environment chosen structure list vector 
describe sophisticated solution allows lists vectors coexist environments 
motivations feature may optimize run time vectors resp 
links access resp 
closure building cost predominant optimize space usage copy scheme vectors eliminates space leak introduced linking environments 
mixa mix mkbind mixa mixa access mixa mixa access mixa mixa xi appclos mixa xi appclos resp 
version accesses list resp 
vector hybrid abstraction extract abstraction annotated new mixed environment structure indicates bind current value vector link 
mixed structures built macro combinator mix copies restructures environment annotation 
paths values expressed sequences abstraction algorithm distinguishes vectors lists compile time environment constructors 
related review section different formalisms description functional implementations calculus calculi explicit substitutions combinators monads 
papers comparing specific implementations related area semantic directed compiler derivation 
approach stem previous compilation functional languages program transformation 
goal show implementation process described functional framework 
main steps compilation control cps conversion compilation reduction indexed combinators seen basic instructions stack 
remained calculus introduce ad hoc machine 
described particular implementation main motivation correctness proofs realistic implementations simpler describe compare various implementation techniques 
sml nj compiler described program transformations including cps closure conversions 
compilers cps transformation encode reduction strategy calculus 
encoding implementation issues calculus leads complex expressions sequencing coded composition continuations 
constructors push framework simplify expressions 
instantiation constructors expressions provides interesting new implementation step section choice number representation components underlying machine kept apart 
calculus choose describing implementation example data environments stored separate components single 
de bruijn calculus uses indices variables intermediate language machines 
saw section de bruijn index seen address value run time environment 
collection formalisms calculi explicit substitutions emphasize environment management seen calculi closures 
calculi help formal reasoning substitution implementation details explicit 
important implementation choices representation environments lists vectors general tackled formalisms 
hardin introduce weak calculus explicit substitutions serve output language functional compilers 
describe machines framework 
goal exhibit common points implementations model precisely existing implementations 
variant describe sharing eases proofs concerning memory management 
expressions stay higher level real machine code example sharing modeled formal labels parallel reductions 
closely related framework intermediate language combinatory logic 
combinators encode compilation reduction 
compilation issues representation environments usually dealt 
different set combinators define abstraction algorithms graph 
categorical combinators environment machines cam krivine machine 
arising different roots intermediate language surprisingly close moggi computational metalanguage 
particular may interpret monadic construct push get back monadic laws ass 
monadic framework 
example write monadic expressions formalism need reorder data environment swap combinator push swap se administrative combinators allow merge components instantiation step 
features monads hindrance express low level implementation details get closer machine code 
example monadic call byvalue cps expression evaluates argument function returns application state application reduced returned 
disallow unrestricted applications previous reduction explicit app combinator 
key feature approach describe structure compilation process composition individualized transformations 
monadic framework appear suited purpose monads notoriously difficult compose 
liang needs complex parametrized monads describe compose different compilation steps 
difficulties compose monads represent low level details serious drawbacks respect goals 
monadic framework general tool structure functional programs small framework tailor describe implementations 
benchmarks functional language implementations compared 
particular compilation steps studied 
example compare different abstraction algorithms expresses cps transformations monadic framework 
works explore relationship machines cmc tim tim machine 
goal show equivalence seemingly different implementations 
cmc tim compared defining transformations states machines 
comparison tim machine informal highlights relationship environment machine graph reducer 
mention asperti provides categorical understanding krivine machine extended cam cr gut studied relationship tween tim krivine machine 
implementation comparisons focus particular compilation steps machines define global approach compare implementations 
related includes derivation machines denotational operational semantics 
starting denotational semantics continuations wand compiles reduction combinators linearizes expressions sequences code 
semantics program translated sequence representing code machine execute 
approach semantics machines appear explicitly 
hannan sestoft start big step natural operational semantics incrementally suppress ambiguities impose left right reduction order refine complex operation reduction get small step structural operational semantics 
refinement steps deal operations specific framework suppressing unification 
meijer uses program algebra calculate simple compilers denotational semantics series refinements 
derivation techniques aim providing methodology formally develop implementations semantics 
focus refinement process correction issues usually describe derivation single implementation 
surprisingly derived compilers model precisely existing implementations 
best described idealized sophisticated optimized implementations 
comparisons implementation choices harder description semantics refinement description program transformations 
choices difficult naturally obtain derivation push enter model call value 
hand semantics methodologies potentially applied language described semantics framework 
review implementation choices encountered study 
significant choice compilation control eval apply model va na push enter model vm nm 
minor options variations va na right left vs left right call value 
shown transformations employed graph seen interpretative versions environment transformations 
compilation reduction main choice environment ski abstraction algorithms list shared environments vector copied environments ac 
choice transformations depending way environments copied ac ac ac 
complete family generic transformations modeling different environment stack derived 
control transfers introduce return address stack cps conversion 
self updatable closures callee update standard way implement updating graph reduction brings options 
approach focuses restricted description comparison fundamental options 
transformations designed model precise compilation step generic respect steps 
surprising simple compositions transformations model accurately real implementations de sign ad hoc generic 
cases differences superficial sufficient specialize transformations obtain existing implementations 
program transformations appears suited precisely completely model compilation process 
standard optimizations uncurrying unboxing hoisting peephole optimizations expressed program transformations 
unified framework simplifies correctness proofs 
example introduce explicitly machine prove operational definition coherent semantics language 
program transformations possible reason efficiency produced code complexity transformations 
advantages appear clearly compilation step 
threaded state seriously complicates program manipulations correctness proofs 
surprising final code similar real assembly code 
main goal structure clarify design space functional language implementations 
exploration far complete 
avenues research interesting give concrete form framework implementing transformations 
compiler construction workbench possible implement wide variety implementations just composing transformations 
useful try completely new associations compilation choices assess implementations optimizations practice 
step high quality machine code modeling register allocation 
done component vector registers 
systematic description standard optimizations program transformations undertaken 
benefit clarify impact program transformation depending implementation choices 
consider example lifting controversial transformation 
intuitively lifting beneficial implementations linked environments 
case effect shorten accesses variables performing copies 
gain worth cost depends times variable accessed 
believe question studied settled framework 
proving correctness optimizations static analyses difficult largely neglected problem 
expressing optimizations program transformations unified framework task easier 
research direction design hybrid transformations mixing compilation schemes 
hinted solution mix copied linked environments section solution mix eval apply push enter model 
hybrid transformations analyses needed transformations worthwhile devised 
help formal framework transformations quite difficult design prove correct 
description previously unknown compositions transformations mechanical derivation new abstraction algorithms hybrid transformations indicate approach suggest new implementation techniques 
interesting formal comparisons transformations remain done 
moment just compared couples transformations va vm na nm ac 
case specific choice compilation step designates best candidate compilation step 
established comparing compositions transformations va ac va 
believe accomplished shows framework expressive powerful tackle problems 
grateful luke hornof daniel le tayer comments versions 
due referees provided helpful suggestions 
abadi cardelli curien levy 
explicit substitutions 
proc popl pp 

appel 
compiling continuations 
cambridge university press 

argo 
improving instruction machine 
proc 
fpca pp 

asperti 
categorical understanding environment machines 
journal functional programming pp 

barendregt 
lambda calculus 
syntax semantics 
north holland 
barendregt 
types lambda calculi programming languages 
rd european symp 
programming lncs vol 
pp 

benaissa lescanne rose modeling sharing recursion weak reduction strategies explicit substitution 
proc plilp pp 

burn peyton jones robson 
spineless machine 
proc 
lfp pp 

burn le tayer 
proving correctness compiler optimisations global analysis 
journal functional programming pp 

cousineau 
curien mauny categorical machine 
science computer programming pp 

cr gut 
machines environnement pour la duction valuation 
th se de universit de paris vii 
curien 
categorical combinators sequential algorithms functional programming 

curry feys 
combinatory logic vol 
north holland 

de 
calculus notation nameless dummies tool automatic formula manipulation application church rosser theorem 
mathematicae pp 

danvy 
back direct style 
proc 
esop lncs vol 
pp 

douence fradet 
taxonomy functional language implementations 
proc plilp lncs pp 

douence fradet 
taxonomy functional language implementations 
part call byvalue 
inria research report jan 
douence fradet 
taxonomy functional language implementations 
part ii call byname call need graph reduction 
inria research report nov 
douence 
les mises en de langages 
phd thesis university rennes 
fairbairn wray 
tim simple lazy machine execute supercombinators 
proc fpca lncs pp 

fischer 
lambda calculus schemata 
proc 
acm conf 
proving properties programs sigplan notices vol 
pp 

fradet le tayer 
compilation functional languages program transformation 
acm trans 
prog 
lang 
sys pp 

hall 
hindley milner type inference optimise list representation 
proc 
lfp pp 

hannan 
operational semantics machines 
math 
struct 
comp 
sci pp 

hardin 
functional back ends lambda sigma calculus 
proc 
icfp pp 

hatcliff danvy 
generic account continuation passing styles 
proc 
popl pp 

johnsson 
compiling lazy functional languages 
phd thesis chalmers university 
joy smith burton 
efficient combinator code 
computer languages 
klop 
term rewriting systems 
handbook logic computer science 
vol 
pp 
oxford university press 
kranz rees hudak philbin adams 
orbit optimizing compiler scheme 
sigplan notices pp 

landin 
mechanical evaluation expressions 
computer journal pp 

leroy 
zinc experiment economical implementation ml language 
inria technical report 
leroy 
unboxed objects polymorphic typing 
acm symp 
princ 
prog 
lang pp 

lester combinator graph reduction congruence application 
phd thesis oxford university 
liang hudak jones 
monad transformers modular interpreters 
proc 
popl pp 

lins 
categorical multi combinators 
proc 
fpca lncs pp 

lins thompson peyton jones 
equivalence cmc tim 
journal functional programming pp 

meijer calculating compilers 
phd thesis nijmegen university 
meijer paterson 
lambda lifting 
unpublished 
copies available erik cs kun nl 
moggi 
notions computation monads 
inf 
comp 
peyton jones 
implementation functional programming languages 
prentice hall 
peyton jones 
implementing lazy functional languages stock hardware spineless tagless machine 
journal func 
prog 
peyton jones lester 
implementing functional languages tutorial 
prentice hall 
peyton jones launchbury 
unboxed values class citizens non strict functional language 
proc 
fpca lncs pp 

peyton jones partain santos 
floating moving bindings give faster programs 
proc 
icfp pp 

plasmeijer van eekelen 
functional programming parallel graph rewriting 
addison wesley 
plotkin call name call value lambda calculus 
tcs pp 

schmidt 
denotational semantics methodology language development 
brown publishers 
sestoft 
deriving lazy machine 
technical report technical university denmark 
shao appel 
space efficient closure representations 
proc 
lfp pp 

shao reppy appel 
unrolling lists 
proc 
lfp pp 

steele 
rabbit compiler scheme 
ai tr mit cambridge mass 
turner 
new implementation technique applicative languages 
soft 
pract 
exper pp 

turner 
algorithm bracket abstraction 
symbolic logic pp 

wadler 
essence functional programming 
proc 
popl pp 

wand 
deriving target code representation continuation semantics 
acm trans 
prog 
lang 
sys pp 

appendix strong confluence reduction evident 
important point note different redexes 
expression redexes written context different reductions seen reduced redexes 
clearly expression proof property typing issues 
simplicity reasons implicitly assume source language typed standard type system 
note allow reflexive types type system similar curry type source expression compiled version 
example expression type compiled form example va section push push type 
typing impose restrictions source expressions 
restrictions enforced type system results functions combined order prove property show subject reduction property property proof 
clearly sufficient show property reduction step 
proof inductive rules obvious 
interesting rule reduction proof boils proof 
shown structural induction 
definition substitution enforces occur free variable renaming convention 
induction hypothesis implies push property 
induction hypothesis get push induction hypothesis push property closed expression canonical push reducible 
proof 
structural induction 
show expression ri reducible 
push redex hypothesis redex reducible 
hypothesis redex reducible 
property direct consequence previous properties 
normal form property property reducible push push thing consequence type system reduction typed closed expressions specified natural semantics push normal form property typed closed expression normal form proof 
induction reduction tree 
evident canonical implicit rule 
reduction strategies normalizing push property push induction hypothesis laws stated laws valid corresponding classical consistent extension calculus 
framework comprises additional rules closed expressions weak normal form closed expression intuitively motivation extension concern equal terms behave reduction 
accept replace expression long equal free variables instantiated replace looping expression looping expression 
may wonder rules assoc define consistent theory 
recall meaning expressions defined terms expressions section 
sufficient verify instantiation rules valid consistent theory calculus 
instantiations considered easy check rules valid lambda theory barendregt terminology 
write expression obtained instantiation expression amounts showing 
theory defined classic laws calculus identifies unsolvable terms general case terms weak normal form see chapters 
proof law 
free variables closed normal form expressions normal forms 
equal closed know property exists push push free push closed proof law similar 
show va yields typed expressions 
property closed va type variable proof 
prove stronger property expression free variables va 
proof 
structural induction 
push va induction hypothesis va va push va va induction hypothesis va va app va app va va app proof property 
proof property needs preliminary lemmas 
context said closed expressions variable closed context introduce free variables bind free variables 
lemma closed contexts transformation proof 
structural induction 
closed introduce free variables induction hypothesis closed induction hypothesis closed particular transformation va vm nm na verifies conditions lemma 
va va va push prove property notion reduction equivalent property 
need lemma lemma closed va va proof 
va va va app 
property property va push derivation va push va push sx push induction hypothesis va push va push va 
va va lemma va push deduce induction hypothesis va push call value reduction described natural operational semantics normal forms cbv cbv cbv cbv proof property shape reduction trees 
axioms 
ife reducible form closed va push va reducible 
va reducible form closed alternative va reducible redex push va app 
reducible 
induction 
reducible cbv cbv cbv induction hypothesis va va va va va va 
closed va push lemma va va va push va app va va va va va va app va 
va reducible va 
va typed property reduction tree form va push va push 
lemma know va push va push va va induction hypothesis cbv cbv lemma va va induction hypothesis cbv cbv proofs transformations similar 
variants va transformation va implements describing left right call value expressed va rule application va va va app app push compilation choice taken cam 
transformations va va may produce expressions push push push 
reduction expressions requires structure stack capable storing arbitrary number intermediate results 
implementations sml nj compiler choice data stack disallow pushes row 
case rule applications va changed va va va reading transformation rules grammar rules clear va produces expressions push occur row push push 
expressions component push act may single register 
possible motivation style transformation called produced expressions possess unique redex reduction 
reduction sequence sequential unique 
variations va va easily derived va conversions rules algebraic laws 
variant na va transformation na may produce expressions push push require stack store intermediate results 
get variant na rule compositions changed na push na na push variant component push act may single register 
combinator grab mark defined way conditional expressions defined pure calculus 
possibility grab push push push push push argument associated mark pair 
mark selects alternative apply function id mark associated dummy function id selecting second alternative yield result 
obviously efficient implement grab predefined conditional operator provided target machine 
variants vm call value generic transformation marks described follows vm vm vm vm push vm vm combinators push push push push generic compilation right left call value marks vm get back vm grab id second canonical transformation see page vm grab sl id reduction rule grab sl recursive 
making grab explicit code vm permits simplifications alternative 
example vm push vm push mark grab simplified transformation vm yields push grab sl vm push grab sl executed twice 
relationship cps conversion cps expressions redex reduction closest transfor mations ones naf 
take definitions def push satisfy assoc rewrite va follows va push def va push va va def va va va def exactly fischer cps transformation 
far types concerned saw va 
recognize cps types giving meanings ans ans ans ans ans distinguished type answers 
note ary functions allowed add rule ans ans inversion transformation expressions cps expressions possible design inverse transformation 
transformation seen generic decompilation transformation easy show structural induction property expression va va va na na nm note transformation just left inverse 
order get true inverse transformation domain restricted expressions encoding evaluation strategy 
push back expressions proof property call name reduction described natural operational semantics cbn cbn normal form cbn proof property shape reduction trees 
need lemmas 
lemma push condition insures push 
definition easy check free variable expression occurs push push push push 
easy prove structural induction lemma push axioms 
reducible form closed 
property trivially verified 
induction 
reducible cbn cbn induction hypothesis unwind unwind unwind unwind unwind unwind unwind unwind push unwind unwind gnm induction hypothesis def 
gnm proof property push unwind unwind lemma lemma unwind induction hypothesis order prove push prove induction general property push fv fv set free variables fact fv closed easy check 
note important expression typed law relies types 
push push dupl swap se push push push push push push push induction hypothesis push push push push push push mkclos induction hypothesis push push mkclos def push induction hypothesis push push bind push push bind def 
push push closed push induction hypothesis push push access appclos push appclos access def appclos def ac abstraction algorithm refinement consists copying environment building closures 
order able add new bindings closure opening local environment needed 
closure built concatenation specialized environments copied 
code variables specify environment accessed 
transformation scheme remains similar rule redefined take account environments 
ac dupl ac swap se ac ac push copy push push ac mkclos ac mkbind ac ac access appclos ac access appclos dupl push push push push swap se push push push mkbind push push push mkbind push abstraction local environments ac abstraction push local environments compatible vm ac grab generate different versions ac may appear closure may applied 
code duplication obviously realistic 
family abstractions algorithms starting different properties large family abstractions derived ag 
transformations introduce indexed combinators generalizations previous combinators arity notion 
definition expression type said arity dupl transformation ag suppresses occurrences dupl ag duplications postponed really needed closure building opening 
ag derived equation ag copy ag arity note copy push push push push generalized form dupl copy dupl 
abstraction algorithm exploits sequencing encoded compositions 
saving restoring environment ag passed may add new bindings remove passing environment ag env ag ag swap se ag ag push push ag pop mkclos ag mkbind ag ag copy access appclos arity dupl abstraction algorithm ag rule evaluation ag unique current environment threaded ag help swap se second rule builds closure mkclos duplicating current environment 
abstraction rule adds mkbind argument environment removes 
rule saves environment copy calling closure 
give definitions new combinators pop mkclos emerge naturally derivation process 
transformation shared copied environments 
change depth environment stack needed reduce expression order magnitude 
example depth environment stack ag ag 
derived abstractions ag abstraction correct construction 
illustrate ag derived ag take rule compositions ag copy ag ag property copy dupl ag swap se ag unfolding copy ag swap se copy ag copy dupl swap se definitions ag swap se ag folding ary ary technique allows derive realistic abstraction algorithms indexed combinators mimic real stack machine instructions 
order compare different options imperative determine cost indexed combinator 
definition components instantiation indexed combinators constant cost 
example copy boils dupl distinct components combinator flush push implemented single instruction stack machine 
easy define swap ag mkbind ag mkclos ag variations combination 
algorithms specialized shared copied environments suited specific choice 
mention tim uses mkclos variation ac integrates dupl mkbind variation ac 
recursion rewriting rule push push push naive way compile reduction fixpoint operator build closure recursive call recursive function free variables closure built 
option described combinator rewriting rule push push push push push push mkclos solution builds call closure function push push push mkclos added current environment 
recursive calls access closures execute sequence code fst snd appclos 
closure code environment built recursive call refinement build circular environment 
manipulate directly store create cycle 
recall source fixpoint operator form letrec corresponding expression form push expression form push mkbind rewriting rule push push mkbind env env push push env push mkclos mkbind closure push env push mkclos built series recursive calls note initial mkbind suppressed 
circular environment env closure environment recursive function closure 
accessing closure circularity code environment env free 
second refinement environment machines implement recursive calls statically known functions jump address 
sufficient replace recursive call fst snd appclos fst recursive call anymore evaluation closure consists installing environment free variables function fst calling code 
course order get real code machine call implemented jump label 
solution recursive functions appear closures passed argument 
