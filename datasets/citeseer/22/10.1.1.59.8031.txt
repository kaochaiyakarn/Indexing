developing context aware pervasive computing applications models approach karen henricksen crc enterprise distributed systems technology dstc level general purpose south university queensland qld australia indulska school information technology electrical engineering university queensland qld australia growing interest context awareness technique developing pervasive computing applications flexible adaptable capable acting autonomously behalf users 
context awareness introduces variety software engineering challenges 
address challenges proposing set conceptual models designed support software engineering process including context modelling techniques preference model representing context dependent requirements programming models 
software infrastructure software engineering process conjunction models 
discuss case study demonstrates strengths models software engineering approach respect set software quality metrics 
key words context aware applications software engineering pervasive computing infrastructure context modelling reported funded part operative research centre enterprise distributed systems technology dstc australian federal government crc programme department education science training 
email addresses karen itee uq edu au karen henricksen itee uq edu au indulska 
preprint submitted elsevier science july motivation known pervasive computing introduces set design challenges traditional desktop computing 
particular requires applications capable operating highly dynamic environments placing minimal demands user attention 
context aware applications aim meet requirements adapting selected aspects context current location time user activities 
years variety prototypical context aware applications appeared context aware guides tourists information tailored location capture tools augment various types media contextual metadata describing context recorded 
efforts ongoing construct context aware environments instrumented sensors enable tracking occupants activities 
environments vary scale single rooms classrooms meeting spaces smart homes support independent living elderly disabled 
despite flurry interest context aware applications transition laboratory everyday 
largely result high application development overheads social barriers associated privacy usability imperfect understanding truly compelling uses context awareness 
presents software engineering approach developed address challenges simplifying design implementation tasks associated context aware software facilitating types rapid prototyping experimentation required order overcome obstacles 
approach set novel conceptual foundations including context modelling techniques preference abstraction pair complementary programming models 
introduced sections section describes integration models software infrastructure pervasive systems 
section outlines process involved developing context aware application models infrastructure section presents case study demonstrates value approach terms software quality metrics 
section provides summary discussion 
context modelling techniques research field context awareness predominantly adopted infrastructure centred approach assumed complexity engineering context aware applications substantially reduced solely infrastructure capable gathering managing disseminating context information applications require 
line approach variety solutions acquire interpret context information sensors manage repositories information support queries notifications proposed 
include context toolkit solar platform various context services 
solutions help simplify application development promote reuse functionality argue infrastructure centred view leads abstractions describing programming context natural ones 
earlier observed proposed infrastructures context models informal lacking expressive power :10.1.1.19.8899
goal develop framework integrates set defined context modelling programming abstractions types infrastructural support described 
designed conceptual foundations framework starting context modelling primary interest 
set objective creating tools support software engineer variety tasks developed modelling techniques enable incremental refinement software lifecycle 
sections separate closely integrated modelling approaches support exploration specification application context requirements ii management context information stored context repository iii specification classes context close way programmer user view context 
briefly discuss features context aware systems differentiate modelling management context information types data knowledge representation management 
characteristics context information context information originate wide variety sources leading heterogeneity terms quality persistence 
previous research context awareness focuses sensed information rich context models integrate sensed static user supplied profiled derived information useful 
classes information display distinctive characteristics example sensed context usually highly dynamic prone noise sensing errors user supplied information initially reliable easily date :10.1.1.19.8899
problem imperfect context information recognised causes described 
context modelling solutions address part problem allowing context information associated channel communication channel id person device identity located near id engaged activity name mode permitted located requires device engaged dependson located iff located near iff located located communication mode name located location name synchronous key fig 

example cml model 
probability nr certainty sensed fact type static fact type profiled fact type derived fact type temporal fact type ambiguous alternative fact type key uniqueness constraint snapshot uniqueness constraint alternative uniqueness constraint dependency quality annotation quality metadata certainty freshness estimates 
approach address entire problem 
instance provide solution representing reasoning ambiguity unknowns 
types imperfection common sensors providers context information report conflicting values fail report values 
modelling abstractions unique address issues 
graphical modelling approach developed graphical context modelling approach context modelling language cml tool assist designers task exploring specifying context requirements context aware application 
provides modelling constructs describing types information terms fact types classifications sensed static profiled derived relevant quality metadata dependencies different types information 
cml allows fact types annotated indicate ambiguous information permitted alternative location readings historical information retained 
supports variety constraints general cardinality relationships special purpose snapshot lifetime constraints historical fact types 
initially formulated cml independently established information modelling technique 
afforded flexibility express desired concepts flexible way 
results initial exploration previous :10.1.1.19.8899
subsequently chose reformulate modelling concepts extensions object role modeling orm 
orm adopted closeness original modelling approach superior formality expressiveness comparison solutions er presence mapping relational model allowing straightforward representation context model terms relational database 
illustrate notation cml show example model 
model suitable variety context aware communication applications represents subset model developed part case study section 
model captures user activities form temporal fact type covers past activities associations users communication channels devices locations users devices absolute relative represented derived fact type 
ellipsis depicts object type value parentheses describing representation scheme object type box denotes role played object type fact type 
give example channel fact type contains roles played person object type communication channel object type 
example instance fact type channel michelle williams second value fact telephone number identifying channel michelle reached 
example fact types contain roles larger numbers roles permitted 
annotations fact types show user device locations sensed populated alternative facts user device multiple recorded locations 
additionally recorded location fact associated certainty measure form probability estimate 
types context information exception proximity information derived sensed fact types user supplied static profiled depending persistence information 
user activity modelled partially dependent user location 
dependency interest infrastructural components responsible managing context information behalf context aware applications 
example components knowledge dependency pro actively issue queries refresh activity facts response location changes 
information cml previous publications 
relational representation halpin describes procedure mapping orm relational model 
leverage mapping create relational representation cml fact types suited context management tasks enforcement constraints storage database querying applications 
cases mapping translates fact type corresponding relation roles fact type represented columns attributes relation orm cml constraints expressed database constraints 
special treatment provided alternative temporal fact types respective constraints discussed 
relational mapping leads representation context information consists set facts expressed form database tuples 
order support reasoning facts adopt form closed world assumption follows 
assume set relations belonging context model instantiation model henceforth termed context instance represents set tuples belonging relation dom set constant values permitted context instance 
assertion form cn ci dom true tuple cn false 
stands simple interpretation accommodate uncertain context information 
extend deal unknowns represented null values tuples ambiguity represented alternative facts valued logic 
assertion cn cn constrained evaluates third logical value possibly true tuple cn matching tuple constants ci replaced special null value tuple ambiguous alternative facts 
assertion false true possibly true 
situation abstraction graphical modelling notation suited specifying context information context aware application relational mapping natural choice context storage management serves natural programming abstraction 
represent context information finer level granularity typically required describing conditions determine application behaviour 
developed situation abstraction way define conditions context terms fact abstraction cml 
situations combined promoting reuse enabling complex situations easily formed incrementally programmer 
situation abstraction conceptually similar proposed dey abowd context toolkit considerably expressive 
situations expressed novel form predicate logic balances efficient evaluation expressive power 
defined named logical expressions form vn name situation vn variables logical expression free variables correspond set vn 
logical expression combines number basic expressions logical connectives special forms universal existential quantifiers 
permitted basic expressions equalities inequalities assertions form tn described previous section 
problems associated evaluating unconstrained quantified expressions terms efficiency unsafe expressions employ restricted forms quantification xi tn xi tn xi tn tn assertion logical expression assertion middle expressions serves restrict possible values variables xi evaluated values 
terms assertion tn equal variables constant value including special wildcard value 
evaluation situation binding values variables vn context instance occurs usual semantics logical operators valued logic modifications described universal existential quantifiers closed world interpretation assertions outlined previous section 
typically variable bindings supplied context aware application describe selected aspects current application state context instance set information available context management infrastructure residing outside application information captured cml model 
note symbol acts separator special semantics 
occupied person activity engaged person activity activity meeting activity call person channel device requires device channel device located near person device permitted person device channel mode mode channel mode synchronous mode urgent priority priority high fig 

situations communication application context model 
example situations communication application described section shown 
specified terms fact types defined cml model 
occupied situation describes condition person engaged activity generally interrupted defined meeting call basis temporal engaged fact type relation 
examines exactly activity facts current time returned function overlaps recorded time interval providing special treatment facts recorded start time 
similarly satisfied person communication channel devices required order located close proximity permission devices 
situation holds communication channel provided mode channel recorded mode relation synchronous indicated appearance synchronous relation 
simple urgent situation satisfied priority variable value high 
preference model appropriate context modelling techniques necessary sufficient prerequisite managing complexity involved engineering context aware applications 
trivial applications additional tools desirable support decision making process involved mapping context appropriate application behaviours 
process complicated known usability challenges associated context awareness related predictability trade autonomy user control 
order address problems decision making process accommodate requirements vary person person time 
little research addressed problem 
exception byun cheverst explores integration user modelling techniques context aware applications 
involves machine learning techniques derive user models leveraged order support various proactive behaviours 
appears promising argue explicit means representing user preferences required 
explicit representation allows users formulate preferences desired provides tool context aware systems explain choices users exposing associated preference traces 
traceability significantly improves user acceptance users tolerant incorrect actions taken context aware applications able understand rational basis 
addition preference traces help users prevent erroneous actions identifying correcting preferences desired effect 
explicit representation preferences conjunction automated learning techniques enable evolution preferences time response user feedback 
surveyed variety preference modelling approaches area context awareness fields decision theory document retrieval aim identifying preference model support customisable context aware behaviour 
context aware systems preferences regarded type context modelled accordingly approach taken cc pp 
solution appropriate describing simple requirements languages acceptable presenting information user sophisticated context dependent preferences 
encountered similar problem preference models fields offered way incorporate context determinant preferences 
accordingly developed novel preference model situation abstraction 
designed compatible automated preference elicitation techniques support composition preferences users express simple possibly conflicting requirements combine form comprehensive preference descriptions 
preference model loosely prior agrawal wimmers supports ranking choices context 
case communication application choices communication channels available people interact information retrieval domain choices may documents search terms 
channel callee channel rate urgent priority channel rate urgent priority channel rate fig 

example preferences channel selection context aware communication application 
preference takes form named pair consisting scope scoring expression 
scope describes context preference applies terms situations 
recall situations may evaluate true false possibly true 
preference considered applicable context scope expression true 
scoring expression assigns score choice numerical value range increasing scores represent increasing desirability special values follows represents veto indicating choice score assigned selected context specified preference scope represents obligation essentially opposite veto represents indifference absence preference represents undefined score signalling error condition 
presents example preferences user supply context aware communication application indicate contacted people precisely types communication channels prefers particular circumstances 
preference name shown left scope scoring expression preceded keywords rate respectively 
example forbids synchronous channels telephone video conferencing channels user access requisite devices 
preferences imply synchronous channels preferred choice urgent calls assigns highest possible score assigns asynchronous channels email sms score 
note preference format shown exposed directly users 
users typically select standard preference sets natural language descriptions construct combine preferences graphical editing tools supply libraries predefined situations scoring policies 
preferences grouped sets combined policies single score produced choice reflects preferences set 
policies dictate weights attached individual preferences determine conflicting preferences handled 
common policy involves averaging numerical scores allowing obligations undefined scores override 
see policy works consider preferences context set variable bindings channel urgent priority true callee channel false 
evaluates veto evaluates evaluates indifferent scope expression false context 
small example average numerical scores simply veto produced overrides 
implies channel represented channel variable unsuitable context 
policies need static 
example user feedback dynamically adapt policy user requirements redistributing weights assigned preferences 
section shows preferences context aware applications support decision making behaviours actions appropriate context 
programming models suitable programming models crucial helping limit complexity effort involved implementing context aware applications progress developing new models slow 
context servers frequently acquiring managing context information applications form support instance programming toolkits infrastructure interpreting making decisions context 
general context aware software developed traditional programming methods models context information embedded directly source code 
cases logic process context information react context changes isolated special components model proposed dey 
approach leads cleaner code unstructured approach results applications difficult maintain source code modified order support additional classes behaviour context 
models proposed suffer problem applicable narrow domains 
sections describe general programming models build situation preference abstractions 
branching model offers scores rate choice preference valuation context cx choice choice preference valuation context cx choice int choice preference valuation context cx choice score threshold choice preference valuation context cx choice choice preference valuation context cx fig 

selected methods programming toolkit branching api 
novel flexible means insert context preference dependent decision points flow application logic 
contrast triggering model supports event driven programming style 
widely previously implementation adaptive applications reformulated exploit situation abstraction basis describing context changes 
programming models complementary single application address different problems 
see consider context aware tourist guide 
triggering model application generate requests information proactive fashion example user moves branching model select best information display new context 
applications may require models case communication application discuss 
branching branching model designed assist decision problems involving context dependent choice set alternatives 
arbitrary choice types supported instance information retrieval branching select relevant information user suitable modes presentation communication domain identify appropriate communication channels interactions users 
domains context dependent choices typically implemented case statements 
approach results tight binding context model application logic making difficult evolve context model sensing infrastructure user requirements change 
overcome problem exploit preference model described section model branching 
user preferences form link context chosen action preferences assign ratings alternatives context application parameters ratings application selects invokes actions 
solution extremely flexible preference information expressed application neutral format enables modification fine tuning required ii facilitates sharing preferences applications 
implemented support branching form java programming toolkit 
small subset api shown 
provides variety methods evaluating selecting candidate choices context 
instance rate method parameters set choices preference generally composite preference policy combining large set requirements users binding variables contained preference constant values current application state context wrapper repository context information 
method uses values compute return mapping choices scores application interrogate act necessary 
methods perform similar evaluations returning mappings select return single best best choices respectively basis scores assigned preference 
remaining methods perform selections criteria returns set choices assigned numerical scores specified threshold returns set choices assigned obligation score 
example toolkit select communication channels appropriate users contexts preferences illustrated section 
versions branching toolkit intend support selection choices trace user feedback mechanisms 
trace mechanisms allow users visualise links preferences applications actions feedback mechanisms support automated preference learning evolution 
triggering support asynchronous style programming actions invoked response context changes provide trigger mechanism builds situation abstraction 
context changes described changes situation states 
states true false possibly true distinct state transitions 
triggers associated transitions write situation 
allow transitions matches occupied amy carr true notify missed calls fig 

example trigger 
false changed matches state transitions allow triggers attached sequences transitions written tn tn transitions sets alternative triggers written tn 
triggering mechanism follows event condition action model trigger includes precondition invocation specified action evaluated detection event 
precondition event specified terms situations 
model associates trigger lifetime start times 
example trigger appears 
event condition action prefixed keywords respectively 
action described natural language simplicity usually takes form invocation relevant source code 
trigger effect notifying user amy carr missed calls engagement defined occupied situation 
trigger additional preconditions detection specified event condition simply value true 
support triggering model provided programming toolkit alongside branching functionality described previous section 
software infrastructure implemented software infrastructure incorporating programming toolkit support related tasks management context information 
section overview architecture implementation 
context manager programming toolkit model model model adaptation manager situation repository receptor receptor receptor receptor interpreter preference repository query interface context repository aggregator interpreter interpreter key application application application trigger repository sensor sensor sensor sensor sensor synchronous communication asynchronous communication application layer adaptation layer query layer context management layer context reception layer context gathering layer fig 

layered architecture software infrastructure 
infrastructure organised loosely coupled layers shown 
context gathering layer acquires context information sensors processes information interpretation data fusion aggregation bridge gap raw sensor output level abstraction required context management system 
involves mapping sensor outputs appropriate context facts ensuring appropriate frequency updates order balance resource consumption quality context data 
content routing scheme achieve loose coupling sensing processing components reception layer 
introduces tolerance component failures disconnections evolution sensing infrastructure 
context reception layer provides bi directional mapping context gathering management layers 
translates inputs fact representation routes queries appropriate components 
context management layer responsible maintaining set context models instantiations expressed terms relational repre sentation described section 
applications may define context models share models similar applications 
addition handling sensed information propagates reception layer context management layer supports static derived profiled information 
derived information handled internally standard database mechanisms typically virtual views depending performance requirements frequency queries 
support static profiled information inserted context management system human users layer provides customisable user interfaces browsing manipulating selected types context information 
query layer provides applications components software infrastructure convenient interface query context management system 
supports queries terms facts situations masks distribution context management layer providing query routing services 
simple synchronous queries persistent asynchronous queries permitted 
preference evaluation trigger evaluation 
adaptation layer manages common repositories situation preference trigger definitions evaluates behalf applications services lower layers 
repositories generally shared groups applications applications running single device network belonging single user 
application layer provides toolkit support programming models 
branching api described detail section 
triggering api supports dynamic creation activation deactivation triggers 
current version infrastructure implemented java various pieces open source software 
context adaptation managers standard java database connectivity jdbc api postgresql rdbms storage fact types situations preferences 
jdbc leaves open possibility substituting rdbms software instance lightweight implementations suitable operation resource constrained devices 
parsing situation preference trigger definitions performed parsers constructed javacc parser generator approach enables trivially regenerate parsers extend grammars invaluable rapid prototyping purposes 
java sun com products jdbc www postgresql org javacc dev java net requirements analysis specification analysis modelling context requirements cml situation abstraction elicitation specification sample user preferences triggers preference trigger models customisation context gathering infrastructure cml relational mapping application design branching triggering models implementation instantiation sample sets context preferences programming toolkit triggers testing unit testing system testing generation custom user interfaces context adaptation managers field acceptance testing fig 

software engineering process 
tools step shown parentheses 
followed re iteration earlier steps 
software engineering methodology models infrastructure designed support wide variety software engineering tasks 
section outline process generally followed building context aware application tools 
process abstracted experiences building context aware applications described section 
illustrates generic software engineering process graphically 
steps partitioned tasks analysis design implementation programming infrastructure customisation testing 
design implementation steps rely branching triggering context query apis incorporate context aware functionality adopt traditional methodologies languages 
focus discussion remaining parts software engineering process 
analysis analysis task begins general goal documenting functionality requirements application step software lifecycle models 
initial step software engineering process includes additional steps specific context aware applications 
focuses types context information required order implement functionality identified 
gray salber provide discussion issues need considered stage 
include identifying type context information required information quality terms resolution timeliness sources information suitable terms intrusiveness cost constraints 
approach step produces context model parts 
cml model documenting basic fact types origins sensed derived profiled appropriate types quality metadata domain constraints 
second set situations application adapt defined terms fact types situations 
outputs rarely produced scratch considerable overlaps context requirements context aware applications 
final analysis step refines functionality identified focusing specification aspects context dependent 
step analyst identifies choices events influenced triggered context documents role context producing sample preferences triggers 
generally performed iteratively step outputs steps consistent 
analysis software engineering process diverges sets tasks performed parallel concerned design implementation customisation software infrastructure 
infrastructure customisation prior executing new application top software infrastructure usually necessary customise components 
new fact types situations required inserted management layers shown 
step largely automated tool inputs textual representations fact types situations relational mapping described section uses generate scripts manipulate relevant databases 
addition sensed fact types may require implementation receptors interpreters aggregators context gathering reception layers 
tasks step 
system testing purposes generally require sample sets context information preferences triggers 
step consists building appropriate sets populate context adaptation managers 
step occurs prior deployment application underlying models stable consists mapping context model preference sets triggers developed steps customisation interfaces 
enable developers system administrators users browse manipulate profiled context information configure preferences triggers appropriate user interface abstractions 
testing task testing context aware applications involves unique challenges 
tse point longer adequate perform unit testing solely basis source code traditional white box methods part application behaviour determined triggers rules separate code 
describe additional difficulties arise testing applications rely sensor data argue testing live simulated data essential 
unfortunately satisfactory solutions problems exist describe typical ideal testing process 
unit testing stage apply traditional white box testing methods test framework junit system test stage carry black box testing specially constructed sets context information preferences triggers 
behaviour context aware application dependent variables including numerous kinds context user particular configuration preferences triggers difficult anticipate exact nature behaviour advance solely studying context model preferences triggers 
consequently large part goal system testing experiment fine tune preferences triggers developed step verify combination context preferences triggers yields satisfactory behaviour 
final stage testing evaluates application field realistic hardware environment live sensor data real users 
stage information quality privacy issues associated sensors sources context junit sourceforge net information may uncovered leading possible re iteration earlier steps 
case study context aware communication means validating models infrastructure carried case study built context aware communication tool 
section presents objectives design outcomes study 
completing case study demonstrated value approach applying variety applications briefly outlined section 
full discussion applications scope refer interested reader papers information 
objectives goals case study evaluate ability models infrastructure support software engineering tasks facilitate development flexible evolvable software 
study primarily considered core application development tasks infrastructure related tasks development interpreters receptors 
primary interest lies rapid prototyping evaluation concerned performance issues efficiency context management system 
concerned expressiveness modelling approaches discussed papers demonstrated implicitly fact approaches development variety context aware applications discussed briefly section 
lists software quality measures considered study metrics evaluate quality software respect measure 
set measures metrics exhaustive reflects principal goals software engineering approach 
usability metrics rate inappropriate context aware actions ease configuration important outside scope initial study 
goal perform comparative evaluation contrasting prototype developed alternative implementations developed programming models infrastructure 
discuss prototype section results section 
note alternative implementations possible depending assumptions context information queried interpreted feasible quality measures metrics evaluation code complexity lines application code concerned context querying manipulation processing maintainability support evolution new modified lines code required support changes context model context requirements reusability ease reuse context definitions context processing components fact situation definitions preferences triggers context interpreters aggregators fig 

selected software quality measures context aware applications 
straightforward quantitative comparison 
discussion necessarily qualitative places quantitative 
note formality evaluation somewhat limited absence established methods evaluating software quality relation context aware applications 
application application developed case study took form tool designed recommend communication channels interactions people context preferences 
priority topic list people tool suggests appropriate contact addresses phone numbers instant messaging ids 
aims minimise disruption prevent missed calls messages improve timeliness interactions 
remainder section briefly outline process develop communication tool subset software engineering steps described section 
tool developed prototype stable application testing mainly carried informally 
similarly design infrastructure customisation tasks straightforward discuss 
analysis developed context model sample sets user preferences tool informal user study study asked people record interactions people course day channel interaction particular telephone number email address reason choice channel 
examining cited reasons able compile list relevant types context note triggers required chosen application design 
current activity person importance interaction time inside outside working hours 
basic types context user activity mapped directly fact types derived context types temporal conditions better represented situations 
mapped types context priority user current interaction application state variables fact types represent information supplied directly application user 
application state variables appear relevant situations preferences 
showed subset cml model produced application 
main types information captured model activity location proximity data represented engaged located located near fact types shown associations people communication channels devices captured channel permitted fact types information interpersonal relationships shown 
fact type investigated suitable sources information prototype account required implementation effort relevant usability issues privacy concerns burden user 
decided derive location proximity information variety location sensors rely users specify types context information 
user supplied information requires direct configuration case information users communication channels represented channel fact type information obtained indirectly case user activity information pulled calendar applications 
creating context model re examined list reasons cited study participants choices communication channels mapped reason preferences 
doing identified fact types situations previously missing context model 
formed comprehensive preference sets representative study participants testing purposes 
small subset preference sets appeared corresponding situation definitions appeared 
challenging aspect specifying preferences deciding suitable preference ratings choosing policy combine ratings 
communication tool applications simple averaging policy described section restricted set numerical preference ratings representing high medium high medium medium low low preference 
experience rarely necessary levels preference addition special non numerical values model allows arbitrary values range 
drafting preferences sets worked preference evaluations hand small set scenarios tweaked preferences certain cases 
task drafting testing tweaking preferences way course scope average user 
reinforces argument section preference model application developers exposed users 
developer provide users configuration options manipulate preferences controlled way editing preferences directly 
implementation implemented prototype java query branching facilities programming toolkit 
mainly designed desktop pcs laptops run mobile device pda 
user executes copy tool henceforth referred agent responsible evaluating context preferences maintaining personal history interactions 
requested recommendation agent sends details requested interaction agents operating behalf participants soliciting suggestions suitable channels 
agents query channel fact type find contact addresses suitable users invoke branching toolkit rate method evaluate suitability user context preferences 
contact addresses receive obligation score agent returns querying agent returns highly rated addresses 
querying agent combines results filters sorts preferences rate method presents results user 
implementation prototype branching toolkit discussed section 
evaluation evaluation prototype respect software quality measures described section follows 
code complexity design tool restricts context queries invocations branching toolkit single java class implements channel selection algorithm 
functionality represents approximately dozen lines source code percent total 
representative sample consisting little half code shown 
code fragment implements method discover communication channels available user lines filter obtain suitable channels user requirements context lines 
loss generality concentrate implementation method evaluation order keep discussion focused concrete 
numbered lines listing aid discussion note discussing line code loc counts refer statement counts numbers new line characters count code lines code 
agent explicitly queries single fact type time channel selection procedure invoked lines 
means context model initially contained dozen fact types grew subsequently incorporated new types context ignored programmer 
branching model shifts context evaluation programming toolkit preference management layer 
evaluation carried response agent calls rate method programming toolkit branching api shown lines 
branching supporting preference situation abstractions number context queries lines code devoted context processing substantially larger 
illustrate show alternative implementation method uses programming toolkit direct queries context facts 
implements preference retrieves communication channels associated user discards synchronous channel requires device close proximity user ii user lacks required permissions 
note preference implemented number context queries risen lines loc count method grown 
lines listing responsible implementing preference collectively loc count 
extrapolating implementation moderate number additional user preferences similar fashion say dozen preferences adds lines code 
represents fold increase implementation able support arbitrary numbers types user preferences 
note appropriate tool support loc count code written precise count number semicolons including special cases semicolons conditions loops plus number case statements 
channel identity initiator priority priority string subject throws look suitable communication channels valuation channels context bind channel new tuple user variables channel bind state variables preference situation evaluation valuation new valuation bind variables person config user bind variables callee config user bind variables caller initiator bind variables priority priority bind variables subject subject evaluate channels branching toolkit scores scores branching rate choice channels new preference config user preference name context process results preference evaluation scores return scores scores return scores config max channels scores return scores throw new fig 

code fragment taken prototype 
contains single context query application preference evaluations mentioned section 
programming toolkit reduced third half current level 
mcfadden demonstrate helper classes generated specific context models reduce need tasks packing unpacking valuation objects containing variable bindings context queries preference evaluations lines 

list new vector int channels length determine channel type synchronous channel channel channels lookup variables channel valuation modes context bind mode new tuple channel variables communication mode modes length mode modes lookup variables communication mode synchronous context synchronous new tuple mode synchronous istrue synchronous channels check user currently requisite devices hand valuation context bind requires device new tuple channel variables device int length device device lookup variables device tuple tuple new tuple config user device boolean context permitted tuple istrue boolean context located near tuple istrue add channel add channel size throw new return fig 

code fragment evaluates suitability communication channels situation preference definitions branching api 
lines omitted identical 
code result preference listed 
maintainability support evolution loose coupling source code prototype underlying context model trivial modify response changes sensing infrastructure user requirements changes 
removal modification fact types may require situation preference definitions updated changes definition channel necessitate code changes changes confined just lines method showed 
said alternative implementation despite having severely limited functionality single preference dependent fact types channel mode synchronous requires device permitted located near tolerant changes context model 
new fact types situations added prototype modification code preferences exploited preferences updated 
feature occasions incorporate new types sensors 
alternative implementation coding effort required take advantage additions context model 
cases effort substantial context processing logic complex difficult structure appropriately large context models large numbers user preferences 
changes context user requirements incorporated prototype simply manipulating preference definitions considerably easier changing decision logic embedded source code alternative implementation 
software engineering approach time consuming task involved accommodating changes sensing infrastructure lies producing components process outputs new sensors interpreters aggregators receptors 
task unavoidable context aware systems 
common infrastructure allowing elements context models shared effort usually amortised applications 
additionally receptor code infrastructure automatically generated demonstrated mcfadden 
reusability communication prototype represented application developed models infrastructure necessary design context model preferences scratch 
potential reuse apparent developed subsequent applications included additional communication tools vertical handover prototype capable dynamically switching network interfaces network quality service qos location changes context information 
communication applications modified original context model slightly add information device capabilities status 
reuse portions preference sets defined prototype 
vertical handover prototype minimal extensions context model represent network qos network interfaces supported device 
able reuse situations interpreters receptors developed communication tools define new preferences support selection network interfaces 
reuse difficult alternative implementation shown 
implementation retains context model prototype context management infrastructure reuse fact types infrastructural components interpreters aggregators remains possible 
situation preference definitions embedded source code 
code reasonably complex implements single preference difficult structure effectively reuse problematic error prone 
summary summarises results evaluation respect set quality metrics shown leftmost column 
second column presents results implementation produced part prototype uses branching model api shown 
third column evaluates implementation uses programming toolkit direct queries fact types implements single preference 
rightmost column considers extension single preference implementation reasonably large number preferences assumptions discussed section 
implementations columns regarded generally representative context aware software low medium levels complexity implemented infrastructural support context management querying somewhat similar provided context toolkit solar high level programming models support flexible mapping contexts appropriate actions 
context aware applications currently implemented fashion 
results compelling justification software engineering approaches infrastructures form provide integrated set high level design programming abstractions addition support context acquisition management querying 
software quality metric branching api branching api preference total loc number explicit context queries loc affected removal modification fact types new loc required exploit new fact types new loc required support new preferences new modified loc required support modification preferences mechanisms context reuse mechanisms preference reuse branching api preferences number fact types number fact types numerous numerous numerous numerous numerous numerous fact types situations interpreters aggregators shared preferences fact types interpreters aggregators copied shared source code fact types interpreters aggregators copied shared source code assuming types context information preferences 
actual loc count varies depending context 
actual loc count varies depending preferences 
fig 

comparison implementations 
concluding remarks set conceptual models designed facilitate development context aware applications introducing greater structure improved opportunities tool support software engineering process 
evaluation previous section showed models approach lead applications maintainable evolvable set reusable foundations context definitions context processing components 
support high degree customisation users generally case context aware applications developed ad hoc software engineering approaches 
plan case studies evaluate aspects approach usability issues mentioned section 
intend extend branching toolkit support user feedback mechanisms conjunction algorithms learning preferences 
longer term interested investigating aspects software engineering process remain poorly understood relation contextaware software 
believe challenges related testing particular need addressed context aware applications widely deployed 
gratefully acknowledge contributions ted mcfadden peter jessica applications developed initial case study described briefly section 
cheverst experiences developing deploying context aware tourist guide guide project 
th international conference mobile computing networking boston august 
pp 

patel abowd automated point capture video annotation 
th international conference ubiquitous computing 
lecture notes computer science volume pp 

springer 
shi smart classroom merging technologies seamless tele education 
ieee pervasive computing pp 
april june 
chen intelligent agents meet semantic web smart meeting room 
rd international joint conference autonomous agents multiagent systems july 
pp 

helal enabling location aware pervasive computing applications elderly 
st ieee conference pervasive computing communications fort worth march 
dey salber abowd conceptual framework toolkit supporting rapid prototyping context aware applications 
human computer interaction pp 

chen kotz context aggregation dissemination ubiquitous computing systems 
th ieee workshop mobile computing systems applications june 
pascoe adding generic contextual capabilities wearable computers 
nd international symposium wearable computers october 
pp 

lei design applications context service 
acm mobile computing communications review pp 
october 
henricksen indulska rakotonirainy modeling context information pervasive computing systems :10.1.1.19.8899
st international conference pervasive computing 
lecture notes computer science volume pp 

springer 
schmidt advanced interaction context 
st international symposium handheld ubiquitous computing 
lecture notes computer science volume pp 

springer 
halpin information modeling relational databases conceptual analysis logical design 
morgan kaufman san francisco 
henricksen indulska modelling imperfect context information 
st workshop context modeling reasoning percom workshop proceedings ieee computer society march 
pp 

henricksen indulska rakotonirainy generating context management infrastructure context models 
th international conference mobile data management industrial track january 
pp 

henricksen framework context aware pervasive computing applications 
phd thesis school information technology electrical engineering university queensland 
september 
dey abowd context aware system supporting reminders 
nd international symposium handheld ubiquitous computing 
lecture notes computer science volume pp 

springer 
cheverst context crystal ball rewards pitfalls 
personal ubiquitous computing pp 

byun cheverst harnessing context support proactive behaviours 
ecai workshop ai mobile systems lyon july 
usability trade offs adaptive user interfaces ease learnability 
th international conference intelligent user interfaces acm press 
pp 

nilsson composite capabilities preference profiles requirements architecture 
working draft july 
agrawal wimmers framework expressing combining preferences 
acm sigmod conference management data dallas may 
pp 

dey designer support context monitoring control 
technical report irb tr intel research berkeley 
june 
brown stick document framework creating context aware applications 
electronic publishing palo alto 
pp 

segall content routing elvin 
auug conference canberra june 
gray salber modelling sensed context information design interactive applications 
th ifip international conference engineering human computer interaction 
lecture notes computer science volume pp 

springer 
mcfadden henricksen indulska automating context aware application development 
ubicomp st international workshop advanced context modelling reasoning management september 
pp 

tse testing context sensitive middleware software applications 
th annual international computer software applications conference ieee computer society 
testing demonstrating context aware services quake iii arena 
communications acm pp 

mcfadden henricksen indulska applying disciplined approach development context aware communication application 
rd ieee conference pervasive computing communications hawaii march 
pp 

indulska henricksen mcfadden common context model virtual community applications 
nd international conference smart homes health telematics 
assistive technology research series volume pp 

ios press 

