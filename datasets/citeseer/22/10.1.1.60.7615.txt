proceedings uist seattle wa usa preference elicitation interface optimization decision theoretic optimization popular tool user interface community creating accurate cost utility functions bottleneck cases numerous parameters functions chosen manually tedious error prone process 
describes arnauld general interactive tool eliciting user preferences concerning concrete outcomes feedback automatically learn factored cost function 
empirically evaluate machine learning algorithm automatic query generation approaches report informal user study 
krzysztof gajos daniel weld university washington seattle wa usa weld cs washington edu acm classification design tools techniques user interfaces 
models principles user machine systems general terms algorithms human factors keywords optimization utility elicitation active learning years revealed trend increasing optimization method automatically designing aspects interface interaction user 
cases optimization may thought decision theoretic objective minimize expected cost user interactions equivalently maximize user expected utility 
example system mediates incoming notifications decision theoretic model expected cost interruption computed terms user activity history location time day number companions conversational status 
system generates graphical representations driving directions optimization find optimal balance readability fidelity original shapes directions lengths individual road segments 
ria system chooses best answer user query optimizing cost function offsets content quality quantity factors 
examples final case supple system uses optimization generate concrete user interfaces declarative specifications user interface target device user model :10.1.1.10.9812
decision theoretic optimization provides powerful flexible principled approach systems quality resulting solution completely dependent accuracy underlying cost utility function 
unfortunately defining cost function complex timeconsuming error prone task 
domain specific learning techniques occasionally practitioners parameterize cost function engage laborious unreliable process hand tuning 
problem unique user interfaces 
economists medical researchers people fields decision support artificial intelligence developed methodologies utility preference elicitation 
young furthermore significant differences preference elicitation applied user interface context 
method uses gamble queries asking user prefer choice mixture probability chance ideal outcome chance worst outcome 
technique elegant theoretical properties believe users coherently report preferences respect probability distributions interface properties 
approaches users asked pick numbers infinite continuous range 
example horvitz propose asking users assign dollar amounts quantify cost various outcomes 
question approach users report accurate results concrete setting context visible 
methods ask questions parameter time ignoring interactions parameters 
factors independent undesirable outcomes occur 
presents fully implemented interactive system uses combination complementary interaction techniques solicit user feedback concrete user interfaces parts 
frees humans having reason numerous unintuitive parameters probabilities monetary values different tradeoffs moves discourse space concrete outcomes 
contributions identify types interactions users conveniently provide feedback regarding preferences arnauld named antoine arnauld french philosopher applied principle maximum expected utility 
example critiquing acquires implicit feedback certain types user actions interface active elicitation explicitly asks user compare alternatives 
investigate question generation algorithms proposing solutions analyzing concrete outcomes performing computation entirely parameter space 
evaluate empirically demonstrating fast learning 
describe new machine learning algorithm maximum margin techniques estimating user cost function feedback provided 
empirical evaluation shows method substantially faster bayesian approach produces equivalent results 
argue arnauld general tool applying optimization systems 
demonstrate arnauld utility integrating supple explain arnauld ria contextsensitive notifications 
results preliminary user study showing arnauld useful tool designers variety backgrounds 
continues stating guiding desiderata introducing supple running example 
discuss types interactions source preference feedback arnauld 
algorithm learning cost functions feedback algorithms generating queries 
informal user study shows arnauld largely meets desiderata achieves user acceptance 
argue approach general explaining arnauld may applied variety optimization systems 
conclude discussion related 
desiderata utility theory stems notion preferences outcomes 
outcomes result choices system user user preferences defined terms order outcomes 
preference order defined terms real valued cost function outcomes prefers written lower cost 
people capable specifying preferences concrete outcomes difficulty articulating real valued cost function 
applications typically need actual cost function seek tool automatically construct set concrete preference examples 
depending application cost function denote things 
cost measures estimated cognitive difficulty user reading map 
automated travel assistant ata cost reflect sequence airline flights 
responsive information architect ria cost measures degree user unsatisfied systems answer query 
supple cost measures difficulty different combinations widgets ui tasks 
typically cost functions defined parameterized form parameters represent various tradeoffs 
decision theoretic systems strong claims extensibility 
may easy add new components systems hard pick cost parameters correctly integrate new features 
creates possible source error designers original platform control 
general hard choose parameter values way accurately orders wide variety outcomes 
furthermore parameters reflect subjective judgments potentially controversial 
parameters need set humans certain values constraints values may set incorrectly inconsistently system degrade gracefully face contradictions 
advantages optimization approach potential personalize application individual users simply defining separate cost functions user 
tool facilitating definition cost functions may reduce burden developers enable wide scale personalization capabilities 
summary choosing appropriate weights parameterized cost function long acknowledged challenging 
conclude tool facilitates elicitation problem satisfy desiderata 
fast easy developers users find values weighting parameters 

output weights correct robust face erroneous inconsistent user feedback 
running example arnauld general system define cost utility function optimization interface applications 
order discussion concrete explain preference elicitation context specific application supple 
supple fast efficient ui toolkit ubiquitous applications automatically generates user interfaces run time optimized specific hardware platform device characteristics owner individual working style 
supple takes inputs functional specification interface device model user model 
functional specification defines types data need exchanged user application 
device model describes widgets available device provides cost function estimates user effort required manipulate widgets interaction methods supported device 
user typical activities modeled device user trace 
supple rendering algorithm combines constraint propagation branch bound search find optimal concrete rendering interface 
optimality decided respect cost function derived information contained device model 
original formulation supple cost function casts weighted sum element cost functions reflect particular concrete widget supports operations usually performed particular element functional specification 
weights derived user model 
element cost functions example critiquing supple 
initial rendering stereo controller 
user asks supple slider combo box controlling volume 
new rendering 
information recorded interaction arnauld improve supple cost function renderings 
originally formulated computationally opaque complex functions 
reformulated sums weighted factors render ukf render denotes element functional specification render denotes concrete widget rendering function render chosen lastly render factors comprising cost function uk corresponding weight 
factors binary indicator functions reflecting presence absence property return non negative real value reflect magnitude property 
example binary factors indicate widget checkbox assigned represent numerical value 
continuous valued factors include example downsampling factor images maps number lines list widget short accommodate expected number elements 
supple factors corresponding weights chosen manually yield desired solutions 
process tedious error prone repeated time new kind widget added platforms supported supple 
user interactions section demonstrate classes interactions eliciting users preferences encode inequalities form indicating user prefers outcome preferences section explains calculate real valued cost function maximally consistent preferences generate interfaces 
elicitation method called example critiquing suited developers users critiques may derived implicitly normal user actions 
second active elicitation computer driven questioning process human operator asked supple requires factors return non negative values arnauld imposes restrictions 
comparisons different pairs automatically chosen interfaces 
example critiquing interfaces user natural interactions provide information cost model cases may learn cost function imposing additional burden user process called example critiquing 
demonstrate approach context supple extensive customization framework allows designers users modify structure behavior appearance rendered user interfaces 
things supple customization facility allows human operators right click part desktop computer interface choose selection possible ways element rendered 
arnauld automatically record customization requests improve parameters supple cost function 
note changes small part user interface causing light intensities rendered sliders combo boxes may cascade causing changes causing top level pane interface split separate tabs making navigation interface difficult 
local improvement lead global decrease quality 
order correctly learn parameters objective function account tradeoffs important record user considers resulting interface global improvement previous version 
reason arnauld detects critiquing caused non local changes outcome requests feedback global result addition local choice 
active elicitation cases user natural actions provide insufficient feedback learn cost model 
cases computer facilitate preference elicitation generating information gathering questions ask user 
researchers advocate ranking multiple outcomes simplicity binary queries presenting users pairs outcomes asking prefer 
consecutive steps active elicitation process 
arnauld poses ceteris paribus query showing renderings light intensity control isolation user prefers slider 
realizing choice may impact parts classroom controller interface arnauld asks user consider concrete interface uses combo boxes light intensities able show elements interface sliders different parts interface put separate tab panes order meet size constraints 
keep questions simple user believe important emphasize called ceteris paribus equal queries users asked consider small differences isolation 
local change options causes cascading global changes ask user compare entire outcomes 
key challenge active elicitation determining best questions ask user 
explain algorithm sections explain answers questions learn cost function 
learning user feedback described elicit set user preferences pairs outcomes formally represent preferences constraints infer best values cost function underlying parameters 
observe system studied cost utility outcome decomposed linearly respect class parameters consequently represented ukf factor cost function 
factors represent presence absence intensity various properties solution 
example supple factor indicate particular widget reflects image scaled desired size 
probabilistic system factors correspond probabilities 
uk non negative weight corresponding factor values weights estimated 
turning feedback constraints quite naturally convert user preferences pair outcomes constraint noting cost greater factor functions return values outcomes goal find weight values uk satisfy constraints 
consider simple example 
rendering left hand side factors set combo box combo box number set indicating combo box provide access numeric state variable 
right hand side factors set slider horizontal slider 
equation combo box combo box number slider horizontal slider clear formally interpret user responses active elicitation queries example critiquing feedback deserves additional attention 
note user interface right pane wishes supple render shown left pane proceed possible ways supple critiquing facility tell tab pane organize top level interface request light intensities rendered combo boxes sliders 
case feedback reflected preference avoiding tab panes possible 
second case downgraded widget light intensity order improve interface 
order formalize preference correct constraint arnauld needs able determine intended 
perform disambiguation assume vast majority feedback events kind user preference widget apply situation 
cases may reasonable assume user critiques example expressing preference outcome preferred outcome interpreted better possible outcomes just explicitly stated dominate 
interpretation correct arnauld takes narrow interpretation 
defining learning problem objective find values weight ui constraints possible satisfied 
sure cost function robust wish maximize degree satisfaction constraint ci 
degree satisfaction called margin denoted mci mci oci ci way find weight values approach finds bayesian estimate values user responses 
method relies metropolis sampling slow interactive demonstrate 
consequently propose faster direct technique explicitly tries maximizes margin linear optimization 
maximum margin learner algorithm maximum margin methods support vector machines 
maximum margin approach finds factor weight values satisfy constraints 
furthermore values chosen maximize difference sides constraint inequality 
time explicit slack variables allow optimization succeed presence contradictory hard satisfy constraints 
formally reformulate constraints equation include addition shared margin variable slack variable ci oci ci standard practice constrain margin greater equal 
note causes upper bound number violated constraints 
formulate objective function form maximize stands parameter controls tolerance learner small number violated constraints constraints satisfied margin smaller approach provide user interface mechanism disambiguating interpretations attempting automatically predict user intention 
set parameters returned optimization satisfies maximum number constraints satisfies maximum possible margin 
notice constraints objective function linear solve problem fast linear programming techniques 
bayesian learner max margin algorithm utilize prior knowledge form constraints allow knowledge summarized form concise statistics 
address shortcoming extend approach take account prior knowledge 
suppose prior belief factory preset weight th factor want new value uk close prior value 
may formalize desire optimization problem minimize subject uk 
constraint linear rewrite pair linear constraints uk uk combine prior knowledge knowledge newly acquired constraints final objective function maximize replaced previously undefined equations square root total number constraints representing user preferences including newly acquired preferences ones contained prior 
additionally weighted parts objective function corresponding new constraints prior 
stands equivalent sample size setting mean knowledge included prior treated weight new constraints 
allows encode certainty knowledge represented prior 
generating query examples discussed previously way arnauld elicits feedback user presenting alternative outcomes asking statement preference 
surprise choice questions asked affect number questions necessary learn cost function 
example repeatedly asking similar questions provide little information learning algorithm progress 
unfortunately choosing optimal question perspective expected information gain intractable 
furthermore complex questions usually harder users answer simple ones 
specifically asking user compare vastly different outcomes may result ambivalent response apples vs oranges vast number tradeoffs 
seek heuristic query generating algorithms ask simple informative questions 
assume user provides set training examples sample input application 
case learning cost function supple device description training example functional specification interface screen size constraint 
example route ria example set information user 
note example may decomposed primitive constituents corresponding smallest portion example argument cost function 
supple element node functional specification tree constituent widget layout assigned 
order generate simple localized questions restrict attention queries single constituents 
weight question generation weight ranking algorithm applies application enumerate space queries 
applied supple arnauld enumerates pairs different renderings single element interface specification example varying single widget layout portion interface 
queries ranked computation space possible factor weights best chosen 
key observation follows cost function defined terms weights constraints far recorded define sub region space region centroid denotes weight values define current best cost function 
candidate query defines hyperplane space set weight values cause 
answer query statement form transforms query new constraint half space side hyperplane consistent constraint 
shown question corresponding hyperplane falls close region centroid 
intuitive matter user answers region containing true cost function cut nearly half :10.1.1.16.4036
may hyperplanes passing close centroid oriented differently orthogonal best 
intuitively constrained region approximately spherical 
region narrowly constrained dimension cut orthogonal 
put way average questions equally constrain dimension weight space 
algorithm exploits intuitions heuristic encoded modified distance function 
rank queries distance corresponding hyperplane centroid distance function scales dimension value proportional number constraints cutting dimension 
method heuristic fast compute effective 
outcome question generation algorithm applies applications satisfying condition factor cost function corresponds single constituent cost example may written sum costs example constituents 
instance supple may create new example constituent element functional specification considering element isolation computing best rendering interface single widget corresponding element 
outcome ranking algorithm enumerates example uses current cost function choose best outcome example 
constituent notes partial outcome oe assigned solution addressed example 
iterates possible partial outcomes assigned computes score oe 
note score ends positive means oe suboptimal local outcome presumably chosen order allow better solution different part interface 
score negative oe better choice current cost function 
algorithm chooses query oe score highest 
positive values score challenges tradeoff interface generator 
slightly negative values score asks close second best local outcome helping spot incorrect choices widening margin options 
evaluation conducted sequence experimental studies measure arnauld meets desiderata evaluate learning method compare algorithms 
recall requirements fast easy developers endusers find values weighting parameters output weights robust face inconsistent erroneous user feedback 
informal user evaluation desideratum concerns ease developers users evaluate pilot user study 
study observed users arnauld connected supple 
users represented developers experienced contributors supple project unfamiliar arnauld 
users represented sophisticated users experienced programmers unfamiliar arnauld cursory knowledge supple 
typical users believe arnauld quite mature novices 
soon hope perform studies true users 
gave sophisticated user group overview supple behavior architecture followed instruction operation arnauld including ability switch question generation driven domain dependent algorithm example critiquing modes 
asked create cost function new supple interface platform arnauld satisfied supple creating reasonable concrete user interfaces 
treated developer group slightly differently asking manually assign values parameters cost function 
subjects done past different set parameters describing different interface platform 
instructed arnauld asked construct cost function scratch 
addition monitoring satisfaction arnauld recorded preference response compared hand crafted cost functions generated 
interestingly subjects disagreed hand crafted preference model time respectively 
additionally cases hand crafted cost function disagreed strongly expressed preference considered options equivalent 
certainly shows hard manually define cost function 
subjects felt arnauld easier accurate way find set cost parameters 
attributed improvement able improve function rapid iterative manner immediately visible feedback 
sophisticated users felt confident produce robust set parameters developers felt tool arrive right result quickly helped address trade offs missed manually setting parameter values 
users able produce robust cost functions minutes supple developers took minutes construct cost functions hand 
users tool generally easy pointed arnauld asking compare complex outcomes difficult pinpoint differences color coded 
hand answers automatically generated queries ambivalent indicating differences alternatives usually easy evaluate 
users commented closer blending implicit explicit approaches desirable able modify examples provided active elicitation able quickly alternate modes 
user requested undo button reverse critique answer remove corresponding input learner 
comparison learning methods desideratum requires fast easy operation consider speed accuracy learning algorithm comparing bayesian approach metropolis sampling proposed 
metropolis sampling approximation run long methods produced essentially parameter weights 
approach produced exact answers faster 
metropolis sampling anytime approximation method may trade solution quality speed 
generates relatively answers quickly 
shows average error percentage stdev average sampling error parameters parameters parameters number samples sampling error bayesian approach diminishes huge number samples slow interactive accurate answers require samples seconds compute maximum margin algorithm returns exact answers ms 
average error metropolis sampling estimates percentage standard deviation underlying distribution cases need estimate variables time 
implementation metropolis algorithm sample times second 
maximum margin algorithm produce exact solution ms standard desktop computer 
draw samples time learner 
estimating variables case supple sample size produces average error standard deviation 
error goes willing wait seconds result respectively 
error stays samples drawn takes seconds 
conclude maximum margin clear choice fast interactive required desideratum 
comparison query generation methods aspect desideratum concerns questions need answered 
evaluate algorithms see interactions required order find set values parameters supple cost function 
experiments simulate user interacting arnauld automated querying interface example critiquing 
cost function defined previously validated set weights denoted target function order simulate user responses 
query simulator registers preference option lower cost target function 
response arnauld updates weights cost function learned 
quality learned cost function assessed step generate concrete interfaces 
target function score interfaces 
compute apple dual mhz gb ram distance ideal learning rate different query generation algorithms weight query generation outcome query generation random query generation number elicitation steps distance ideal performance presence input errors weight query generation input error outcome query generation input error random query generation input error number elicitation steps rate learning results averaged runs 
axis reflects far ideal interfaces generated currently learned parameter values see text detailed explanation different query generation strategies presence input errors step chance simulated user give answer opposite intended 
render test interfaces render test interfaces target cost function function learned 
words compute ratio true cost rendering guided learned cost function true cost rendering guided true cost function 
quotient reflects far ideal interfaces generated currently learned parameter values testing fair different interface specifications generate queries evaluate results 
queries classroom amazon search interfaces see screenshots interfaces mentioned section evaluation stereo controller email client interactive interface 
shows quality learned function improves number queries issued 
weight algorithms resulted learned functions performing identically target function queries 
control evaluated random query generator resulted slower learning rate 
summary query generation algorithms require sufficiently short interactions satisfy desideratum 
sensitivity input noise evaluate arnauld second desideratum results robust presence input errors inconsistencies 
query generation algorithm repeated experiment previous subsection observing system behaved face probability input error step situation response suggested target function exists continuum parameter values may produce concrete outcomes evaluate learned cost function cost results produces actual weight values flipped opposite 
simulates user providing inconsistent input making mistake 
shows results error probability 
outcome algorithm generates interaction nearly optimal results obtained interactions 
weight algorithm tends spread queries uniformly parameter values meaning erroneous input received system waits long asking affected weights 
delay results algorithm performing noticeably poorer input errors compared error free condition 
user arrive set weights switching example critiquing mode interaction directly addressing cases system mistakes 
conclude outcome ranked question generation consistent desiderata preferred approach despite slightly higher computational cost 
arnauld general platform experimented context supple argued arnauld benefit optimization interface systems 
section defend claims considering different systems showing arnauld facilitate operation 
ria responsive information architect ria system automatically decides information user second best match different pieces information different modalities 
phase ria balances certain tradeoffs numerous manually tuned parameters reflecting different classes information inform final decision 
ria objective function particularly complex different parameters multiplied 
arnauld current restriction linear systems applied estimate classes parameters 
class parameters held constant objective function linear combination remaining class parameters making amenable learning approach 
interaction methods appropriate case special interaction method provided allow users critique information delivered speech 
automated queries speech simulated text faster interaction cycles 
context sensitive notifications system described designed deliver notifications user manner sensitive user levels 
uses decision theoretic framework estimate utility delivering particular piece information available modalities conditioned estimate user current 
primary focus innovative machine learning algorithms estimating probability user engaged different classes activities 
contrast actual cost parameters indicating relative level distraction incurred different modes notification delivery obtained asking users abstractly assign different dollar amounts reflecting willing pay avoid notification assuming certain level 
cost function driving system relies classes parameters costs interrupting user different modalities cost delaying delivery message hope user 
classes parameters combined linear manner learned arnauld 
currently system learns sensor model recording sensory inputs particular user environment recording video time 
order train system user watch video annotate transitions different attentional states levels 
interaction arnauld ask user queries form deliver important message point preferred email displayed message screen message deliver preferred delivered immediately displaying screen waited till called phone 
resulting system tuned personalized deployment user option commenting notifications delivered 
example critiquing easily supported messages displayed screen specialized interfaces needed comment messages delivered email real time phone call 
related place arnauld context past preference elicitation user interaction utility function representation reasoning query generation mechanisms 
user interactions eliciting preferences example critiquing systems notably trip planning assistants ata system 
cases computer presents user options initial set requirements user refines preferences narrowing requirements concerning initially unspecified attributes locations airline 
authors argue users unaware preferences think specify confronted particularly example 
adopt example critiquing approach arnauld 
highlights distinction user fundamental objectives means achieving warning system attributes reflect fundamental objectives users accurately estimate values attributes 
cases parameters system match user objectives direct manipulation approaches instant feedback may right approach explore space options 
systems benefit arnauld large sets parameters parameter semantics complex unintuitive 
reason avoid direct manipulation parameter values focus reasoning concrete examples system output 
representation reasoning user preferences systems described constraints represent user preferences 
order accommodate inconsistent requests systems constraint solvers allow partial satisfaction constraints mechanism provided select different solutions level feasibility 
propose treating utilities random variables 
constraints encoding user preferences just means constructing bayesian model estimate values utilities metropolis algorithm inference 
approach bayesian learner 
worth noting potentially faster accurate methods available inference hybrid bayesian networks implementational complexity renders application problematic 
approach similar proposed calendar scheduling 
approach designed just application uses standard svm quadratic optimization estimating parameter values 
reasons utilities terms minimizing maximum regret representing uncertainty value utility parameters hard intervals 
refinement approach allow inconsistent responses user 
generating optimal queries past generating optimal queries value information see example 
case computationally prohibitive requires hypothesizing potential query impact presentation interfaces 
query generation algorithms ideas heuristic approaches context svm training aim select queries maximally reduce size remaining version space 
decision theoretic optimization adopted number researchers automatically generate various aspects user interfaces 
cases numerous unintuitive parameters optimization objective function chosen hand adding element principled approach 
address problem presenting evaluating interaction methods algorithms allowed build arnauld system interactively elicits user preferences purpose automatically learning parameters optimization systems 
interaction mechanisms algorithms applicable systems intend arnauld learning methods available 
furthermore ensure compatible toolkits gadget promise easy embed optimization user interface systems 
acknowledgments pedro domingos suggesting look discriminative approach deepak verma help formulating optimization problem 
mary czerwinski james fogarty useful discussion donald patterson tan william anonymous reviewers helpful comments drafts subject provided feedback system 
customization infrastructure example critiquing developed raphael hoffmann 
research supported nsf iis onr darpa project calo sri number 

agrawala 
rendering effective route maps improving usability generalization 
siggraph 

arnauld 
art thinking 
merrill 

borning stuckey 
cassowary linear arithmetic constraint solving algorithm 
acm transactions computer human interaction tochi 

boutilier 
pomdp formulation preference elicitation problems 
aaai iaai 

boutilier poupart schuurmans 
constraint optimization minimax decision criterion 
international conference principles practice constraint programming 

burges 
tutorial support vector machines pattern recognition 
data min 
knowl 
discov 

koller 
utilities random variables density estimation structure discovery 
uai 

koller ormoneit 
learning agent utility function observing behavior 
icml 

koller parr 
making rational decisions adaptive utility elicitation 
aaai iaai 

fogarty hudson 
aesthetic information generating decorative displays contain information 
uist new york ny 

fogarty hudson 
gadget toolkit optimization approaches interface display generation 
uist vancouver canada 

gajos christianson hoffmann shaked henning long weld 
fast robust interface generation ubiquitous applications 
proceedings ubicomp tokyo japan 

gajos weld 
supple automatically generating user interfaces 
iui madeira portugal 

pollack taylor uribe 
active preference learning personalized calendar scheduling assistance 
iui new york ny usa 

heckerman horvitz middleton 
approximate computation value information 
ieee trans 
pattern anal 
mach 
intell 

horvitz 
principles mixed initiative user interfaces 
chi new york ny usa 

horvitz 
learning reasoning interruption 
international conference multimodal interfaces 

horvitz jacobs 
alerting 
uai san francisco ca 

horvitz koch 
creating fielding personalized models cost interruption 
cscw new york ny usa 

keeney raiffa 
decisions multiple objectives preferences value tradeoffs 
john wiley sons 
republished cambridge university press 

linden hanks lesh 
interactive assessment user preference models automated travel assistant 
user modeling 

minka 
expectation propagation approximate bayesian inference 
uai san francisco ca usa 
morgan kaufmann publishers 
pu faltings 
user involved preference elicitation 
ijcai workshop configuration acapulco mexico 

schohn cohn 
active learning support vector machines 
icml 

lieberman 
intelligent profiling example 
iui 

tong koller 
support vector machine active learning applications text classification 
journal machine learning research 

zhou aggarwal 
optimization approach dynamic data content selection intelligent multimedia interfaces 
uist 

zhou wen aggarwal 
approach dynamic media allocation intelligent multimedia interfaces 
iui 
