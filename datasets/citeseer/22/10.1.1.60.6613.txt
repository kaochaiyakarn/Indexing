lazy shape analysis dirk beyer thomas henzinger gr gory th technical report 
mtc report december ecole polytechnique rale de lausanne informatique communications ch lausanne switzerland lazy shape analysis dirk beyer thomas henzinger gr gory th epfl switzerland software model checkers predicate abstraction 
values variables branching conditions represented abstractly predicates 
strength approach path sensitive nature 
control flow depends heavily values memory cells heap approach difficult find predicate abstractions represent heap 
contrast shape analysis lead compact representation data structures stored heap 
combine shape analysis predicate abstraction integrate software model checker blast 
shape analysis expensive apply globally 
ensure shapes computed stored locally necessary proving verification goal 
achieve extend lazy abstraction refinement far predicate abstractions shapes 
approach increase precision model checking shape analysis taken individually increases efficiency shape analysis compute shapes necessary 
implemented technique extending blast calls tvla evaluated programs manipulating data structures result combined tool automatically verify programs verifiable shape analysis predicate abstraction 
classification software engineering software program verification logics meanings programs specifying verifying reasoning programs keywords software model checking shape analysis counterexample guided abstraction refinement predicate abstraction interpolation 
counterexample guided abstraction refinement dramatically increased performance software model checkers past years possible verify programs previously large model checking 
current implementations model checkers capable dealing efficiently contents heap 
shape analysis static data flow analysis models heap contents compressed way 
provides finite abstraction portion program state space located heap 
method produces large amount false positives due nature 
shape analysis expensive static analyses 
contribution show increase effectiveness model checking efficiency shape analysis combining advantages techniques 
computing predicate shape information increase precision analysis obtain fewer false positives method 
efficiency pure shape analysis improved expensive shape computations postconditions performed control locations shape information necessary prove verification goal 
achieve apply lazy abstraction paradigm shapes 
lazy abstraction involves lazy fly abstraction construction lazy abstraction refinement 
lazy abstraction construction means reachability tree art program computed onthe fly 
node art labeled predicate shape information 
computation branch art terminated concrete states represented leaf covered node tree 
art construction path sensitive avoids computation joins 
lazy abstraction refinement means predicate shape information refined branches art represent spurious counterexamples order remove false positives 
blast additional predicates discovered craig interpolation 
method allows pin pointing necessary predicates individual program locations 
key novelty interpolation predicate discovery refine granularity shape analysis 
computation locally necessary predicates combination alias analysis type information pointer variables algorithm decides individually location spurious counterexample predicates pointers observe refine local shape abstraction infeasible error path removed 
implemented algorithm blast calls tvla shape operations 
evaluated method applying programs manipulate list data structures 
half programs verified previously pure predicate model checking old version blast pure shape analysis tvla method sufficiently precise leads false positives integrated approach succeeds automatically proving programs correct 
half programs verified individual methods measure overhead combined implementation 
interpolation iterated refinement adds cost shape operations fewer required due lazy analysis 
related 
fischer implemented blast combination lattice data flow analysis predicate abstraction consider automatic refinement data flow analysis 
rajamani proposed non lazy cegar method interpretation showed applied shape analysis 
refinement done globally lazily believe crucial scalability expensive analyses shape analysis 
sagiv experimented method speeding shape analysis ignoring parts heap constructing procedure summaries 
best knowledge integration shape analysis lazy abstraction framework novel contribution 

existing techniques 
model checking predicate abstraction counterexample guided abstraction refinement ce gar 
classical cegar algorithm starts initial trivial predicate abstraction refines abstraction iteration 
iteration explores reachability tree 
states visited states safe algorithm stops answer safe returns reachability tree proof 
counterexample checked exists feasible concrete path program reported bug counterexample spurious due coarse abstraction corresponding feasible concrete path program 
concrete path analyzed discover new predicates need added representation program order eliminate spurious counterexample iteration 
repeated program proven safe program bug 
lazy abstraction refinement 
classical version check refine loop drawbacks necessary represent analyze state space reachable second necessary refine portions program proved save 
lazy abstraction refinement integrates steps loop fly analysis refines predicate abstraction locally 
algorithm produces refinement predicate abstraction demand discovers predicates particular error path refines abstraction locations error path need new predicates eliminate error path 
craig interpolation 
crucial measure efficiency analysis number predicates abstraction 
keep number predicates location small possible interpolation predicate discovery produce precisely predicates needed eliminate infeasible path reachability tree 
error path corresponding path formula prove infeasibility path wish discover predicates needed location 
path formula split location formulas prefix leads program initial program location considered location postfix leads program considered location error location 
craig interpolant formula implied prefix formula conjunction postfix formula unsatisfiable contains variables occur prefix formula postfix formula 

data flow analysis shape analysis shape analysis static analysis represents unbounded instances recursive data structures finite structures called shape graphs 
shape graph abstraction instance heap data structure obtained blurring information data elements keeping track shape data structure depending abstraction level analysis 
shape graphs represented valued logical structures post operator implemented predicate transformer 
shows instance list data structure consisting list elements data value data value 
pointers point list element 
shows shape graph represents list instances pointers point list element data values data value resp 

list instance fig 
instance shape graph 
shape graph represented unary predicates rp sm binary predicate predicate true pointer variable pointing node predicate true pointer node pointing node predicate rp true node reachable pointer pointer relation predicate sm false node represents single list element value summary nodes 
summary node represents list elements drawn double circled nodes picture 
pointer list element abstracted second node may point may point third node pointer list element may point list elements represented second node 
dotted edges represent don know value predicate 
overview example cegar shapes 
classical cegar algorithm extended heap abstraction abstraction consists predicate abstraction heap abstraction cf 
fig 

initial predicate abstraction trivial predicate abstraction predicate true initial heap abstraction trivial shape class representing heap 
complete reachability tree explored state unsafe algorithm stops answers safe 
error path path formula heap predicated constructed checked satisfiability 
path formula unsatisfiable infeasibility due predicate abstraction interpolation procedure discover new predicates added predicate abstraction avoid infeasible path iteration 
heap abstraction changed 
path formula satisfiable due incompleteness path formula necessarily mean bug 
construct precise extended path formula takes account may aliasing relation occur nodes 
generated path formula feasible system considered unsafe interpolation procedure new path 
abstraction refinement heap abstraction typedef struct node int struct node list void foo int flag list list malloc null exit list random flag list malloc null exit check flag assert example program concrete list heap shape concrete list null 
example program list representations formula interpolant predicates decide refine heap abstraction 
example 
function fig 
generates list contains sequence data values depending ends data value 
second part function verifies list really consists sequence data values depending flag ends data value 
path insensitive static analysis prove program safe statement loop analysis forgets fact values list depend flag 
due join occur corresponding shape lattice 
path sensitive predicate second error path third error path 
shape graphs error reached reachability analysis prove program safe analysis keep track heap values stored list 
combination predicate abstraction shape analysis tracks predicate shape information time 
computing successor region method computes successor abstractions checks successor region non empty ensures region contradict 
analysis starts trivial predicate abstraction trivial heap abstraction 
infeasible error path new method reports skips loop sets assumes flag skips loop branch violates assertion 
list consists list element pure predicate abstraction yield false positive due restricted path formula 
analysis error path yields track choose shape class type pointer track shape data structure pointing 
alias analysis yield pointer needs tracked add node predicate shape abstraction 
second infeasible error path enters loop assumes flag sets sets assumes flag skips loop branch violates assertion 
list represents sequence state region associated program location assertion represented predicate true hand shape graph fig 
hand 
current shape class knows node node consists nodes representing list element data value node predicate false second list element data value 
path formula error path fig 
aliasing constraints omitted clear pre sentation 
number annotated value path formula corresponds number command written value 
numbering encodes history computation path 
path formula unsatisfiable know path infeasible 
proceed add node predicate shape abstraction 
third infeasible error path enters loop assumes flag sets sets assumes flag skips loop branch violates assertion 
list represents sequence state region associated program location assertion represented predicate true hand shape graph fig 
hand 
current shape graph knows node predicates consists nodes representing list element data value node true second list element data value 
predicate abstraction keep track predicate flag leads infeasible situation loop predicate assumed true second part program predicate assumed false 
proceed add boolean predicate abstraction 
fourth infeasible error path enters loop assumes flag sets sets assumes flag skips loop branch violates assertion 
list represents sequence add node predicate shape abstraction 
iteration unfolds remaining states marks covered constructs complete reachability tree acts safety certificate 
note program contained second list created checked analysis track shapes list interpolants yield predicates inevitable eliminating infeasible error path 

lazy abstraction refinement shapes shape classes 
level abstraction shape analysis defined shape class pabs consists sets predicates set core predicates set instrumentation predicates instrumentation predicate associated defining formula core predicates set pabs abstraction predicates 
set predicates shape class denoted set core predicates contain special unary predicate sm value normal nodes command constraint malloc true pred pred flag flag malloc pred pred flag flag pred pred error 
path formula second infeasible error path summary nodes 
distinct special subsets core predicates set ppt points predicates set pnode node predicates 
points predicate unary predicate indicates pointer variable points node node predicate unary predicate corresponds boolean predicate predicate abstraction holds variable points node boolean predicate parametric variable name 
denote instance predicate refers variable node predicates represent content structure element structure shape 
shape class refines shape class written core instr abs pabs 
union shape classes shape class core instr pabs abs require instr core 
shape graph val shape class pabs consists set shape nodes valuation predicates valued logic predicate arity val 
shape regions 
shape region consists shape class set shape graphs 
shape class shape region includes possible shape regions corresponding true predicate abstraction shape graph single shape node constant function valuation predicate 
shape region corresponds false predicate abstraction 
shape classes shape graph shape class extended shape graph shape class set shape nodes left unchanged predicate value shape nodes 
extend operator sets shape graphs natural way 
shape region covered shape region denoted join sets shape graphs defined tvla 
semantics sps defined sps op op 
defined tvla 
depending operations apply tvla operators focus coerce respectively transforming set shape graphs 

extracting interpolants extended path formulas precise analysis memory configuration extend path formulas previously blast recursive data structures 
programs lvalues paths path formulas 
formalization programs similar 
program represented set control flow automata path length sequence op 
op commands statements assume predicates 
rest consider flat programs program single function 
approach extended programs functions 
program variables integer values pointers possibly recursive structures fields integers pointer structures 
restrict lvalues occur program ident ident field ident denotes variable identifier field denotes name structure field 
function maps lvalue set labels structure pointed lvalue lvalue pointer type empty set lvalue integer type 
state lvalue ident ident field command statement predicate statement ident expression ident alloc ident ident ident ident field ident field ident predicate fol formula variables 
grammar program ments predicates composing program 
semantics path terms strongest postcondition operator formula represents state program op command formula sp op represents set successor states 
predicate abstraction path mapping ol path locations sets atomic predicates 
formula abstraction set atomic predicates strongest formula atomic predicates implies operator sp abstraction operator sp formula sp op abstraction formula sp op extend sp sp paths natural way 
path sp infeasible sp infeasible sp true sp true satisfiable 
check error path feasible exists corresponding feasible execution program construct path formula pf conjunction constraints instruction pf feasible iff path feasible 
technique building pfs reused directly restricted programs recursive data structures 
approach extended trivially result infinite formulas 
number memory cells possibly involved path formula bounded produce finite sound complete path formula 
address structure heap accessed path previously assigned pointer variable point consider restricted set possible lvalues 
able refer addresses constraint formulas ssa renamed lvalues 
lvalue constants annotated lvalues aliasing 
lvalue constant ident variable constant ident field annotated lvalue ident ident field 
labels correspond position path annotated values may modified 
function clean maps lvalue constant annotated lvalue lvalue removing labels 
annotated lvalue map function annotated lval ues numbers 
lvalue renaming function sub defined sub sub sub sub variable field 
encode path formula aliasing memory cells function may maps position path lvalue constant set variable constants may value lp may th command path value may equal value th command path 
path formulas constraints 
function con maps pair consisting annotated lvalue map constraint map ol command op pair consisting new annotated lvalue map new constraint map 
path compute recursively result con path computing con op location op path 
map constant map empty map 
map differs annotated lvalues may modified op mapped map results map extended mapping constraint derived op derive constraints path commands similarly 
major extension necessary assignments pointers 
structure may recursive unroll data structure equate possibly reachable memory cells yields infinite formulas 
additionally add aliasing constraints cases lvalue constants may point memory cell 
formal definition function con 
path formula obtained conjunction formulas final constraint map 
note size formula highly dependent precision alias analysis 
definition con refers functions 
function returns constraint corresponding equality variables considering fields 
sub sub sub sub function clos returns constraint corresponding predicate 
clos clos op clos clos op sub true command opl new map allocated constraint expr sub sub expr may may sub sub sub may sub sub sub may sub ite sub ite sub sub sub sub sub may sub alloc allocated allocated allocated predicate clos true 
definition con command 
con op algorithm 
extract input infeasible path op pc 
op pc output map locations sets atomic predicates pc con derivation false pc pc atoms clean return algorithm 
algorithm constructs constraint map function con represents path formula path splits infeasible path formula program location computes predicates necessary eliminate infeasible error path refining abstraction way path infeasible 
split path formula proof unsatisfiability function returns interpolant formula proof formulas function atoms returns set atomic predicates formula 
theorem soundness 
path program path sp infeasible iff sp infeasible extract 
difference corresponding theorem new theorem require program free recursive data structures 
particular theorem states method sound method report infeasibility real bug exists 
theorem state method necessarily complete 
cases eliminate infeasible path refinement abstraction shape class 
general limitation shape analysis fixed set shape classes implemented tvla refinement method 

shape class refinement interpolants program restrict analysis finite set shape classes analyze program 
define space shape classes approach considers way refinement shape classes occur 
tracking definition shape types 
tracking definition represents pointers predicates heap track analyzing program 
tracking definition consists sets set tracked pointers set pointer variables may pointing node shape set ts separating pointers set variables want corresponding points predicates abstraction predicate set node predicates 
define refinement relation tracking definitions 
tracking definition ts refines tracking definition ts shape type consists structure type map tracking definitions shape classes map preserves refinement relation 
instance shape type singly linked lists associated type struct node int data struct node map tracking definition ts shape class predicates default unary predicate sm binary predicate representing links nodes list variable points predicate abstraction predicate variables ts node predicates precise shape types singly linked list defined adding instrumentation predicates tracking reachability 
refinement 
section described algorithm cf 
fig 
combined approach 
remaining step need explain refine shape abstraction reachability algorithm 
predicate abstraction starts empty set predicates lazy shape analysis starts empty tracking definition 
consider shape type current tracking definition refined extended path formula unsatisfiable variable occurs interpolant matches type shape type variables refine current tracking definition follows add set tracked pointers set separating pointers 
close set tracked pointers aliasing 
add atomic boolean predicates interpolants tracked pointer dereferenced node predicates 
map shape type maps refined tracking definition shape class 
mapping preserves refinement relation new shape class refinement current shape class 
outcome refinement infeasible error path eliminated iteration reachability analysis refinement reaches fixed point pointers node predicates extracted path formula infeasible error path occurs iteration 
case refinement succeeds algorithm proceeds refined shape abstraction 
case conclude shape type precise choose refined shape type analysis re launched new shape type 
interpolation analysis precisely locates refinement necessary restrict refinement shape analysis local context done predicate abstraction refinement 
technique ensures algorithm refines necessary 

evaluation example programs examples 
evaluated method example programs manipulate list data structures containing integers data elements 
programs simple simple create list arbitrary number traverse check element 
difference order nodes created 
creates list begins arbitrary number proceeds arbitrary number ends 
list traversed check numbers occur correct order 
program list flag builds list begins depending flag ends lists traversed checking expected numbers 
prove safety example requires track simultaneously boolean predicate flag shape graphs 
program alternating similar list list begins alternating ends 
program splice builds list alternating 
list split different lists list contains nodes odd positions second list contains nodes positions original list 
new list checked contains number 
implementation 
concepts implemented blast version integrates tvla shape transformation foci library blast predicate interpolation 
tvla written java integrated blast written ocaml particular implementation shape analysis module principle able plug shape analysis tools 
shape analysis plugged blast fly analysis extending state region triple far program counter stack predicate shape region 
previously tried integrate shape analysis predicated lattice described method refinement data flow lattices joined join points control flow graph predicate regions different 
want distinguish states reached different paths covered precise control flow sensitive analysis 
table reports results experiments 
programs successfully verified blast predicate abstraction shape analysis system able prove program safe reports false positive column table 
examples proved safe pure shape analysis predicate refinement tracking maximal shape information ev table 
time verifying singly linked list manipulation programs seconds ghz intel xeon processor cfa control flow automaton loc lines code fp false positive number refinement steps parenthesis program cfa nodes loc pred 
abstr 
shape analysis pa sa simple fp simple fp list fp list flag fp fp alternating fp fp splice fp fp tvla fails due missing control flow sensitivity column 
model checker blast lazy shape analysis proves example programs safe column 
runtimes show overhead refinement shape abstraction programs compared pure shape analysis significantly increase run time analysis cases 
contrast programs combination shape analysis predicate refinement really necessary reported runtime higher analyses fast finding false positive 
surprisingly run times list higher shape analysis involved 
interesting note shape refinement overhead reasonably small path formulas proportionally larger increasing size shape graphs 
examples chosen require amount shape operations methods measure overhead lazy shape analysis compared shape analysis advantage laziness 
results experiments including source code examples error paths analysis log files pre compiled binary blast available supplementary web page athttp mtc epfl ch beyer blast sa 
ball rajamani 
slam project debugging system software static analysis 
proc 
popl pages 
acm 
clarke grumberg jha lu veith 
counterexample guided abstraction refinement 
proc 
cav lncs pages 
springer 
fischer majumdar 
joining dataflow predicates 
proc 
esec fse pages 
acm 
rajamani 
counterexample driven refinement interpretation 
proc 
tacas 
springer 
henzinger majumdar mcmillan 
abstractions proofs 
proc 
popl pages 
acm 
henzinger majumdar 
lazy abstraction 
proc 
popl pages 
acm 
lev ami sagiv 
tvla system implementing static analyses 
proc 
sas lncs pages 
springer 
mcmillan 
interpolation sat model checking 
proc 
cav lncs pages 
springer 
sagiv 
interprocedural functional shape analysis local heaps 
technical report tau cs tel aviv university 
sagiv reps wilhelm 
parametric shape analysis valued logic 
proc 
popl pages 
acm 
