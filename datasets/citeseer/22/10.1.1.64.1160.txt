brics rs ller schwartzbach design space type checkers xml transformation languages brics basic research computer science design space type checkers xml transformation languages anders ller michael schwartzbach brics report series rs issn december copyright anders ller michael schwartzbach 
brics department computer science university aarhus 
rights reserved 
reproduction part permitted educational research condition copyright notice included copy 
see back inner page list brics report series publications 
copies may obtained contacting brics department computer science university aarhus ny munkegade building dk aarhus denmark telephone telefax internet brics brics dk brics publications general accessible world wide web anonymous ftp urls www brics dk ftp ftp brics dk document design space type checkers xml transformation languages anders ller michael schwartzbach brics university aarhus mis brics dk 
survey statically type checking xml transformations covering wide range notations ambitions 
concept type may vary idealizations dtd full blown xml schema expressive formalisms 
notion transformation may vary clean simple transductions domain specific languages integration xml general purpose programming languages 
type annotations explicit implicit type checking ranges exact decidability pragmatic approximations 
characterize evaluate existing tools design space including result authors providing practical type checking full unannotated xslt stylesheets general dtds describe input output languages 
xml established format structured data document essentially ordered labeled tree 
xml language subset trees typically described formalisms known collectively schemas 
schema denote set xml trees describes 
different schema formalisms proposed original dtd mechanism part xml specification expressive schemas xml schema relax ng dsd various tree automata formalisms :10.1.1.12.9903
different languages devised specifying transformations xml data covering wide range programming paradigms 
languages type systems aim statically catch runtime errors may occur transformations consider problem type checking global effect transformation input schema sin output schema sout decide compile time sin sout input output language may course 
notice schemas act types programming language 
notion type checking general sense covers techniques dataflow analysis 
supported foundation contract number ans 
basic research computer science www brics dk funded danish national research foundation 
describe design space xml transformation languages type checkers survey representative collection examples xduce xact xj jdom tree transducers xquery 
furthermore preliminary report novel point design space flow type checker full xslt language 
xml transformations motivated different usage scenarios queries xml databases generate results xml data xml documents xhtml xsl fo versions translations performed different dialects xml languages views summaries xml publications automatically extracted 
major contributing factor success xml ability unify diverse tasks single framework 
various languages survey certainly different sweet spots reasonable expect support scenarios 
aspects xml transformation languages languages programming xml transformations may characterized different ways 
major distinction relevant kind application domain domain specific languages dsls general purpose languages 
gpl ordinary programming language java 
approach obtaining integration xml library allows construction deconstruction xml values provides support parsing unparsing 
approach data binding represents xml data native types programming language guided schemas manually specified mappings 
xml documents ordinary data values language special syntax analysis xml manipulations 
dsl specially designed language supports domain specific values operations 
dsl may stand embedded 
stand dsl designed implemented scratch tailor compiler interpreter 
allows highest degree exploitation domain specific knowledge syntax analysis implementation 
stand dsls obvious expensive implement language scratch active research lowering cost difficult provide complete infrastructure say java language libraries 
second potential users steep learning curve dsls designed resemble known languages 
xml transformations stand dsl kind xml trees native values 
embedded dsl gpl framework xml programming 
domain specific parts consist specialized syntax analysis 
domain specific syntax typically xml constants navigation xml data may provided preprocessor dsl syntax gpl syntax 
runtime dsl operations handled gpl library 
domain specific program analysis may performed dsl source code level desugared code may exploit gpl analysis 
compared stand dsl having foundation gpl easier interact systems example communicate web access data bases preexisting libraries 
simpler integrate non xml computations xml processing example complex string manipulations construction xml data non xml data vice versa 
distinction categories blurry gpl may extended xml features allow better data binding dsl xml processing may extended gpl 
shall call approaches xml centric 
distinguishing aspect xml transformation language expressiveness 
clearly turing complete embedded dsls designed express limited class transformations 
benefit restricted language twofold certain transformations required specialized syntax programming easier 
second restricted language may subjected precise analysis 
important distinguish different kinds turing completeness ability perform arbitrary computations representations xml trees vs ability perform arbitrary computations encoding integers 
stand dsls turing complete sense 
embedded dsl may turing incomplete xml sense underlying gpl turing complete traditional sense 
common example language element names attribute names generally computed chosen constants appear program 
restriction limitation practice schemas written existing schema languages define fixed sets names anyway 
known aspect language paradigm 
purpose shall merely distinguish roughly imperative languages explicit mutable state declarative languages side effects implicit control flow 
widely imperative stand dsls declarative 
languages consider apply abundance different models xml data 
treat xml mutable tree structures view immutable 
course aspect closely related language paradigm 
mutability natural imperative language immutability advantages particular respect type checking beneficial languages data generally mutable 
approaches involve data binding xml data represented underlying data model object oriented languages mapping schema types classes xml data objects 
different models may involve varying mechanisms constructing xml data navigating deconstructing data 
approach perform direct tree manipulation construction navigation level individual xml tree nodes term language constructing tree fragments constants dynamically evaluated expressions 
deconstruction navigation pattern matching xpath expressions 
variant model xml data templates tree structures gaps substituted values 
quality implementation language may obviously vary 
distinguish levels industrial strength implementation scales real life applications robust infrastructure support documentation 
second prototype provided research group shown moderately sized examples sporadically supported 
implementation feasibility established research little practical experience exists 
note prominent software tools taken full trip prototype industrial strength 
aspects xml type checking independently aspects type checking capabilities xml transformation language may characterized 
xml transformation language may course entirely unchecked means errors observed runtime 
languages distinguish internal external type checking 
internal type checks aim eliminating runtime errors execution 
gpl framework property mainly inherited underlying language xml operations throwing kinds exceptions generally scope type system 
embedded dsl type system underlying language perform checks separate analysis may perform additional checks xml operations 
example verify program navigates say attribute element attribute guaranteed exist schema 
standalone dsl domain specific type checker integrated compiler 
external type checks aim validating behavior xml transformation xml tree belonging language input schema transformed xml tree belonging language output schema 
gpl framework require global program analysis underlying language 
true embedded dsl restrictions imposed domain specific syntax may task considerably simpler 
stand dsl external type check may require program analysis possible express external type checks terms internal type checks schemas mapped domainspecific types 
types xml data specified type formalism 
simple choice dtd closely related formalism local tree grammars 
ambitious choice general regular unranked tree languages corresponding bottom tree automata 
approach full xml schema language advanced schema languages reallife development projects 
gpl frameworks embedded dsls types characterized native effectively underlying language 
approaches rely schema languages dtd xml schema tacitly ignore uniqueness constraints id idref dtd key unique xml schema aspects validity exceedingly hard capture type systems dataflow analysis usually regarded secondary features compared structural aspects schemas 
type checkers type annotations part language syntax explicitly state expected required types variables expressions 
annotations may mandatory meaning certain language constructs explicit types 
languages require annotation xml variable light annotations example input output 
heavy type annotations pros cons 
type annotations may task type checker easier inference needed 
may argue explicit types code comprehensible intention clear 
hand types involved xml processing quite complicated writing explicit types viewed annoying extra burden programmer 
explicit types may incur rigid type checker type correctness obeyed program point 
consequences xml trees built strictly bottom sequences updates gradually convert data type possible type check 
discuss issues section 
turing complete languages type checking undecidable problem 
internal type checks decision problem determine absence certain runtime errors 
external type checks decision problem determine input language transformed output language 
type systems approximate answers problems 
characterize precision internal external type checking capabilities levels guarantees provided typical solution devise static type checking algorithm conservatively soundly completely decides desired properties hold 
type checker unfairly reject programs common experience programmers 
solution apply pragmatic type checker attempts catch errors possible may generate false positives false negatives words sound complete 
note conservative internal type checkers usually ignore certain kinds runtime errors classical examples division zero null pointer dereferences 
approaches belonging pragmatic category sound certain unchecked assumptions adhered 
course non turing complete languages feasible guarantee exact answers 
theoretical complexity type checking algorithm relevant aspect 
asymptotic complexity algorithm true measure experienced running time example ml type inference exponential runs smoothly practice 
related aspect modularity type checking 
highly modular approach scale large programs 
algorithms analyze operation individually operation type checks entire program type checks 
involve program type inference dataflow analysis fixed point iteration 
naturally aspect depends type annotations described high modularity correlated heavy annotations 
transformation implementation characterize type checking implementation languages transformation implementation developed type checker 
availability implementations interesting distinguish open source free binary distributions commercial products implementations unavailable 
points design space discussions allow provide succinct profile xml transformation language type checker 
language look aspects applicable examples language type language gpl library data binding framework stand dsl embedded dsl xml centric gpl 
case stand dsl imperative declarative 
turing complete 
model xml data xml data mutable immutable 
xml data constructed 
type formalism formalism types 
annotations approach depend explicit types programs 
precision type system exact conservative pragmatic 
guarantees program type checks 
aspect relevant internal external type checks 
conservative systems precision acceptable practice semantically correct programs rejected type checker 
complexity theoretical complexity type checking process known 
course aspect evaluated modularity aspect 
observed behavior practice may appear different 
modularity granularity type checking 
ranges individual operations program analyses 
implementation quality availability quality implementations transformation language type checker 
source code available 
additionally try relate language closely related ones investigate similarities essential differences 
xduce xduce programming language type checking xml operations schemas types 
simplistic language provided foundation languages particular xtatic briefly mention influenced design xquery see section popular schema language relax ng 
language type xduce declarative stand dsl 
characterized order pure functional language 
intention investigate type safe integration xml programming languages full fledged programming language 
original description language include attributes amended version 
turing complete exception compute element names attribute names dynamically 
model xml data language pure xml data obviously treated immutable trees 
construction values expressed tree terms 
navigation deconstruction mechanism regular expression pattern matching combination regular expressions ml style pattern matching closely connected type system 
type formalism type system xduce notion regular expression types corresponds class regular tree languages 
essential part type system subtyping relation defined inclusion values represented types called structural subtyping 
annotations xduce requires explicit type annotations function arguments return values provides local type inference pattern matching operations means pattern variables need annotations 
precision type checker xduce conservative program passes type checking guaranteed transform valid input valid output 
regarding internal checking various properties pattern matching operations checked exhaustiveness clause matches clause match value unambiguity unique bindings obtained 
type formalism decidable exist programs semantically correct appropriate type annotations expressible problematic programs described xduce papers 
complexity subtyping automata language inclusion complexity type checking including local type inference checks pattern matching operations exponential time complete 
algorithm appears efficient practice 
modularity global type inference fixed point iteration involved approach highly modular 
implementation quality availability open source prototype available 
implementation focuses type checking analysis patterns runtime efficiency 
key success xduce clean mathematical foundation regular expression types 
number issues remain 
current design handle unordered content models common real life schemas 
second regular expression pattern matching mechanism situations low level example navigating deep xml tree structures processing data iteratively performing identity transformations 
ongoing aims provide higher level pattern matching primitives 
third devising efficient runtime model language challenging example pattern matching may involve exponential time space algorithms 
issues addressed descendants xduce xtatic aims integrate main ideas xduce categorized embedded dsl 
part making technologies available mainstream language efficient runtime representation xml data considered 
language goes direction extending xduce xml centric functional gpl adding features higher order functions variations pattern matching primitives 
additionally parametric polymorphism considered 
xact xact roots language java language development interactive web services 
contains mechanism dynamic construction html xhtml pages includes static program analysis checks validity pages xact mechanism generalized full xml transformations 
language type xact embedded dsl java host language 
xduce turing complete compute element names attribute names dynamically 
model xml data language uses variant immutable trees called templates xml tree fragments named gaps appearing element contents attributes 
values filled gaps order time conversely subtrees replaced gaps order remove replace data 
constant templates written xml syntax 
main operations plug constructs new value inserting xml templates strings gaps name select takes xpath expression argument returns array selected subtrees takes xpath expression argument contrast select replaces addressed subtrees gaps name inserts replaces attributes selected xpath similarly replaces element content 
addition methods importing exporting xml values formats strings streams jdom documents 
note major difference xduce family languages xact relies xpath navigation xml trees 
type formalism static guarantees xact obtained dataflow analysis exploits formalism called summary graphs approximatively tracks operations templates program 
dtd input output types analyzer permit stronger schema language dsd output types 
asymmetry arises input type translated summary graph final check output type uses separate algorithm tests inclusion summary graphs dsd schemas 
theoretically possible map dsd schema summary graph accepting language ignoring usual uniqueness pointer constraints implemented 
annotations dataflow analysis annotation overhead lighter techniques 
types dtds specified input designated analysis points typically output 
precision analysis conservative program passes analysis produce invalid xml runtime 
analyzer performs internal checks plug operations fail attempting plug templates attribute gaps xpath expressions xml operations potentially select nonempty node sets 
main practical limitations analysis precision caused facts current implementation employs monovariant path insensitive analysis field variables treated flow ensure soundness 
complexity analysis polynomial complexity 
modularity approach poor modularity performs fixed point iteration entire program 
appears reasonably efficient practice 
implementation quality availability open source prototype available 
analyzer handles full java language 
runtime representation crafted obtain performance despite operating immutable structures 
mathematically elegant template mechanism xact flexible program xduce model 
plug operation templates gaps passed class values 
gaps may filled order computed templates reused xduce family languages trees constructed bottom 
second xpath appears powerful addressing deeply xml trees languages chosen xpath purpose described sections 
third operation easy transformations explicitly reconstructing change 
despite differences xduce xact approaches connection underlying formalisms type checkers shown notions summary graphs regular expression types closely related 
current xact project aims obtain closer integration new generics iteration features introduced java 
xj development xj language aims integrating xml processing closely java xml schema type formalism 
language type xj embedded dsl java host language 
model xml data xml data represented mutable trees 
construction xml data performed level individual nodes 
dynamically checked node parent 
subtrees addressed xpath 
updating attribute values character data likewise expressed xpath insertion deletion subtrees involving elements expressed special insert delete operations 
type formalism types regular expressions xml schema declarations elements attributes simple types 
type system levels regular expression operators xml schema constructions 
subtyping schema level defined type derivations extensions restrictions substitution groups schemas derived substitution group defined subtype words nominal style subtyping 
subtyping regular expression level defined regular language inclusion top schema subtyping 
coercions certain xml types normal java types example int xml schema int java kleene star java lang list 
annotations xml variable declarations annotated types 
precision type checker pragmatic category updates require runtime checks due potential aliasing 
features xml schema accounted type system example facet constraints 
updates involving xpath expressions evaluate multiple nodes result runtime errors 
complexity subtyping relies inclusion regular expressions complexity exponential size regular expressions 
modularity due heavy annotations operation checked separately leads high degree modularity 
implementation quality availability prototype implementing parts system particular type checking updates complex types implemented 
prototype available 
authors acknowledge fact type checker xj rigid 
values variable times adhere type type fixed variable declaration impossible type check sequence operations temporarily invalidate data 
plausible example constructing element inserting number mandatory attributes sequence updates 
problem nominal style subtyping xml value tied closely schema type 
imagine transformation inspired addrbook example creates telephone book document address book document extracting entries telephone numbers 
output language subset input language difference telephone elements mandatory content model person elements output 
nominal type system treats versions person elements unrelated xj transformation explicitly reconstruct person elements merely removing telephone element 
language developed similar goals xj similarities language design type checking approach appears closer xduce 
language type embedded dsl java host language 
model xml data xml data represented mutable trees 
explicitly stated available papers xml trees mutable example program strongly suggests case 
construction xml trees written xml notation embedded expressions xj 
subtrees addressed xpath expressions 
type formalism underlying type formalism regular hedge expressions corresponds class regular tree languages instance xduce relies 
programmer point view xml schema type formalism features xml schema go regularity naturally handled type checker 
clear type derivation substitution group features xml schema handled lines suggested 
annotations requires explicit type annotations xml variable declaration 
precision main ingredient type checker checking subtype relationship assignment statements 
mutable updates possible potential aliases may arise apparently ignored xj approach relies runtime checks type checker unsound belongs pragmatic category 
assuming problematic aliases arise type checking conservative 
xml schema type formalism certain kinds constraints expressible xml schema number occurrences restricted string types handled runtime checks 
complexity complexity checking subtype relationship exponential 
modularity xj modularity type checking high 
implementation quality availability binary code prototype available time writing minimal documentation 
xj integrating xml gpl mutable trees data model xpath addressing subtrees tempting elegant approach 
crucial problems remain appears infeasible ensure soundness type checker aliasing updates mixed type checker rigid noted 
jdom baseline include jdom popular approach perform type checking validity generated xml data ensures wellformedness 
return simple offers maximal flexibility performance widely 
jdom developed java specific alternative language independent dom 
language type jdom gpl library java 
model xml data xml data represented mutable trees particular nodes unique parents 
library contains plethora operations performing low level tree navigation manipulation importing exporting formats 
additionally built support evaluating xpath location path expressions 
type formalism formedness comes free tree representation jdom contains type system addition java 
implementation quality availability jdom open source industrial strength implementation 
compared approaches mentioned dom jdom generally regarded low level frameworks 
foundations implementing advanced approaches 
relative dom jdom sun framework numerous related projects viewed step integrating xml gpl programming languages 
language type data binding framework java 
model xml data schemas written xml schema language converted java classes mimic schema structure 
xml data represented objects classes 
conversion textual xml representation objects performed marshall operations 
mapping schemas classes customized annotations schema separate binding files 
type formalism relies native java type system 
note contrast jdom representation able obtain static guarantees certain aspects validity binding reflects properties schemas 
full xml schema validation left runtime feature 
annotations special annotations needed java code 
precision approach pragmatic due significant impedance mismatch xml schema languages type system java 
customized binding mismatch alleviated 
automatic translation dtd xml schema idealized schema languages provides precise bindings 
implementation quality availability open source industrial strength implementations 
data binding frameworks commonly alternative dom jdom approach 
constitute pragmatic approach provide static guarantees conservative frameworks 
host language advanced type system data binding may precise 
example system uses haskell host language 
additionally contains generic library jdom consider 
language type data binding framework haskell 
model xml data dtds converted algebraic types fixed strategy 
type formalism uses native haskell types 
annotations type annotations optional 
precision haskell type checker conservative generally acknowledged precision 
xml binding lack subtyping algebraic types rejects natural programs 
hand presence polymorphism allows different class useful programs type checked 
complexity type checker haskell exponential 
modularity modularity excellent haskell supports separate compilation 
implementation quality availability haskell compiler industrial strength implementations 
different binding algorithms haskell discussed enabling flexible programming styles trading full dtd validity 
language known xen extension aims unifying data models objects xml databases 
goes step data binding 
language type xml centric gpl language 
model xml data mutable data values extended include immutable structural sequences unions products top objects simple values 
xml trees encoded values 
xml templates may syntactic sugar corresponding constructor invocations 
member access emulates simple xpath expressions navigation deconstruction 
type formalism type system similarly supports structural sequence union product types 
support external types basic features dtd xml schema may encoded type system 
annotations requires ubiquitous type annotations precision type checker appears somewhat restrictive notion subtyping semantically complete types values subset relation necessarily subtype relation 
means programs unfairly rejected type checker 
example addrbook mandatory telephone elements assigned variable expecting addrbook optional telephone elements 
complexity complexity stated appears polynomial simple notion subtyping 
modularity type system highly modular underlying language 
implementation quality availability language available prototype implementation 
solves ambitious problem merely type checked xml transformations interesting features arise merger different data models 
tree transducers xml mathematical idealization ordered labeled trees schemas may modeled regular tree languages 
corresponding view xml transformations may seen notion tree transducers 
representative examples tl transformers pebble transducers 
language type tree transducers declarative stand dsls 
generally simply tuples alphabets transition functions 
languages turing complete capture central aspects transformation languages 
model xml data xml data immutable 
attributes encoded special nodes attribute values character data ignored 
construction performed node node 
navigation pattern matching pebble approach performed tree walking tl approach evaluating formulas monadic second order logic 
type formalism types general regular tree languages 
annotations input output types specified 
precision classes tree transducers particularly interesting type checking problems decidable 
pebble transducers may viewed low level machines tl transformers provide succinct declarative syntax 
complexity type checking algorithms hyperexponential 
modularity tree transducers closed composition provides simple form modular type checking 
implementation quality availability type checking algorithms implemented pure 
non elementary algorithms tree automata previously seen feasible practice 
fits classical scenario practical language design theoretical underpinnings inspire 
type checking algorithms turing complete languages precise formalisms decidable type checking expressive course meet 
xquery xquery recommendation programming transformations xml currently status working draft 
xml trees may seen generalize relational databases tables xquery language designed generalize sql query language 
language type xquery turing complete declarative stand language 
xduce order pure functional language 
model xml data xml data treated immutable trees 
extensions plan generalize update mechanisms sql query language continues operate immutable data 
nodes trees physical identity means fragments may identical merely equal labeled trees 
term language constructing values xpath deconstruction pattern matching 
type formalism input output types xml schema instances 
internally types tree languages data values corresponding tree grammars 
input output types mapped approximately internal types subtyping structural xj 
xml schema fits framework 
annotations variables parameters function results type annotations default denote type containing values 
precision internal type checker conservative type rules 
xquery constructions difficult describe designers acknowledge type rules may need sharpened versions 
xquery transformation languages handle computed element attribute names noted corresponding type rule pessimistically assume kind result arise 
external type checker strictly speaking pragmatic 
unsoundness arises xml schema mapped approximately internal types 
achieve conservative external type checker mapping input language produce upper approximation mapping output language lower approximation 
current mapping apparently meets criterion 
practical precision type checking algorithm unknown 
complexity type checking algorithm exponential 
modularity type checker sense modular functions may type checked separately type annotations 
type system lacks analogies principal type schemes single general choice type annotations exist 
implementation quality availability xquery available prototype implementations commercial open source 
single prototype supports type checking 
industrial strength implementations undertaken companies 
xquery undoubtedly fulfill goal industrial xml standard 
light strong theoretical foundation welcome novelty 
type checking xslt xslt current recommendation programming transformations document centric xml 
associated type checker project applied summary graph technology xact create flow external type checker 
tool designed handle real life situation full xslt language supported 
language type xslt declarative stand dsl 
turing complete encoded sense 
computed element attribute names allowed xml transformations expressed primarily xslt transformations composed 
example transformation sorts list items alternatingly colors red blue programmed xslt 
model xml data xml data treated immutable trees 
templates term language declarative fashion template mechanism xact 
navigation performed xpath 
type formalism xslt untyped tool uses summary graphs internal types 
external types dtds 
output type may fact dsd schema xact 
annotations tool works ordinary xslt stylesheets input output type specified 
precision analysis conservative 
internal type checks performed obtain required information catch xpath navigation errors detect dead code 
external type checker tested dozen scenarios xslt files ranging lines dtds ranging lines 
examples originate real life projects culled web 
total lines xslt type checker reported errors 
identified real problems stylesheets covering mixture misplaced undefined missing elements attributes unexpected empty contents wrong namespaces 
easily corrected indicate serious problems 
false errors fall categories 
total due insufficient analysis string values causes problems attribute values restricted nmtoken output schema 
variation string analysis may remedy 
remaining false errors caused approximations introduce require sophisticated refinements avoid 
important measure achieved precision generic identity transformation type checks 
complexity algorithm polynomial appears reasonably efficient practice 
largest example lines xslt lines input dtd lines output dsd schema xhtml ran seconds typical pc constructing summary graph nodes 
modularity type checker program analysis modular 
implementation quality availability xslt course industrial strength implementations 
type checker implemented prototype currently developing 
analysis phases 
full xslt syntax smaller core language instructions apply templates choose copy attribute element 
transformation property type check original stylesheet may soundly performed reduced version 
second perform control flow analysis finding apply templates instruction possible target template rules 
reduces checking xpath expressions compatible relative dtd challenging solve required precision 
combination heuristic algorithms partly inspired statistical analysis lines real life xslt code written hundreds different authors 
third summary graph soundly represents possible output documents constructed control flow graph input dtd 
main challenge provide sufficiently precise representations content sequences output language 
resulting summary graph compared output schema algorithm 
approaches type checking xslt stylesheets tool working implementation full language 
different programming systems proposed writing transformations xml data 
identified number aspects systems type checking capabilities compared 
approaches range integration xml existing languages development language extensions entirely new languages 
aim soundness pragmatic 
additionally brief overview novel approach type checking xslt stylesheets shown fits design space xml type checkers 
extensive description approach currently preparation 
variety approaches indicates general problem integrating xml programming languages static guarantees validity canonical solution 
general observations fundamental issue real life schema languages far traditional type systems programming languages 
choice immutable representation common imperative languages 
seen problems arise mutability aliasing 
common rely type annotations variable declarations 
improves modularity type checking extra burden programmer 
type checkers appear restrictive sense significantly limit flexibility underlying language 
example type systems structural rigidity enforces programming style xml trees constructed purely bottom 
irrespectively type checker important language flexible supporting common xml transformation scenarios 
example variants template mechanisms convenient writing larger fragments xml data 
xpath widely addressing xml data 
proposals runtime efficiency issue addressed 
handling huge amounts xml data problematic systems 
claim papers high theoretical complexity appear problem practice 
unclear proposed type checking techniques real large scale programming projects 
general problem challenging far definitively solved look forward seeing xml transformation languages type checking techniques 
acknowledgments claus brabrand christian useful comments inspiring discussions 

document object model dom level specification october 
recommendation 
www org tr rec dom level 

philippe rose 
stylesheet validation 
technical report rr ens lyon november 

benzaken giuseppe castagna alain frisch 
general purpose language 
proc 
th acm international conference functional programming icfp august 

gavin bierman erik meijer wolfram schulte 
essence data access 
technical report microsoft research 
research microsoft com 

scott xquery xml query language november 
working draft 
www org tr xquery 

ronald 
xml data binding resources september 
www com xml htm 

claus brabrand anders ller michael schwartzbach 
bigwig project 
acm transactions internet technology 

tim bray jean paoli sperberg mcqueen eve maler 
extensible markup language xml third edition february 
recommendation 
www org tr rec xml 

simon christensen anders ller michael schwartzbach 
static analysis dynamic xml 
technical report rs brics may 
programming language technologies xml plan 

simon christensen anders ller michael schwartzbach 
extending java high level web service construction 
acm transactions programming languages systems november 

simon christensen anders ller michael schwartzbach 
precise analysis string expressions 
proc 
th international static analysis symposium sas volume lncs pages 
springer verlag june 

james clark 
xsl transformations xslt november 
recommendation 
www org tr xslt 

james clark makoto murata 
relax ng specification december 
oasis 
www oasis open org committees relax ng 

denise draper xquery xpath formal semantics november 
working draft 
www org tr query semantics 

vladimir benjamin pierce 
regular object types 
proc 
th european conference object oriented programming ecoop volume lncs 
springer verlag july 

vladimir michael levin benjamin pierce alan schmitt 
xml goes native run time representations xtatic 

matthew harren mukund oded shmueli michael burke vivek sarkar rajesh 
xj integration xml processing java 
technical report rc ibm research 

haruo hosoya 
regular expression filters xml january 
programming language technologies xml plan 

haruo hosoya makoto murata 
validation boolean operations attribute element constraints october 
programming language technologies xml plan 

haruo hosoya benjamin pierce 
regular expression pattern matching xml 
journal functional programming 

haruo hosoya benjamin pierce 
xduce statically typed xml processing language 
acm transactions internet technology 

haruo hosoya jerome vouillon benjamin pierce 
regular expression types xml 
acm transactions programming languages systems 
appear 

jason hunter brett mclaughlin 
jdom 
jdom org 

martin volker 
xml objects october 
programming language technologies xml plan 

stephan 
proof turing completeness xslt xquery 
technical report sfb university bingen 

christian simon christensen anders ller 
runtime system xml transformations java 
proc 
second international xml database symposium volume lncs 
springer verlag august 

christian anders ller michael schwartzbach 
static analysis xml transformations java 
ieee transactions software engineering march 

nils klarlund anders ller michael schwartzbach 
mona implementation secrets 
international journal foundations computer science 
world scientific publishing 

michael levin 
compiling regular patterns 
proc 
th acm sigplan international conference functional programming icfp august 

sebastian alexandru thomas helmut seidl 
xml type checking macro tree transducers 
technical report tum tu munich 

erik meijer wolfram schulte gavin bierman 
programming rectangles triangles circles 
proc 
xml conference exposition xml december 

tova milo dan suciu victor vianu 
typechecking xml transformers 
journal computer system sciences february 
special issue pods elsevier 

anders ller 
document structure description december 
brics department computer science university aarhus notes series ns 
available www brics dk dsd 

anders ller mads olesen michael schwartzbach 
static validation xsl transformations 
preparation 

makoto murata lee murali mani 
taxonomy xml schema languages formal language theory 
proc 
extreme markup languages august 

frank neven 
automata logic xml 
proc 
th international workshop computer science logic csl september 

sun microsystems 

java sun com xml 

peter thiemann 
typed representation html xml documents haskell 
journal functional programming 

henry thompson david beech murray maloney noah mendelsohn 
xml schema part structures may 
recommendation 
www org tr xmlschema 


static type checking xslt 
proc 
acm symposium document engineering november 

arie van deursen paul klint joost visser 
domain specific languages annotated bibliography 
acm sigplan notices june 

malcolm wallace colin runciman 
haskell xml generic combinators type translation 
proc 
th acm sigplan international conference functional programming icfp september 
brics report series publications rs anders ller michael schwartzbach 
design space type checkers xml transformation languages 
december 
pp 
appears eiter libkin editors database theory th international conference icdt proceedings lncs pages 
rs simon christensen christian anders ller 
runtime system xml transformations java 
december 
pp 
appears milo suciu editors database xml technologies second international xml database symposium proceedings lncs pages 
rs philipp 
quantitative version kirk fixed point theorem asymptotic contractions 
december 
pp 
rs philipp ulrich kohlenbach 
strongly uniform bounds semi constructive proofs 
december 
pp 
rs olivier danvy 
reduction reduction free normalization 
december 
pp 
invited talk th international workshop reduction strategies rewriting programming wrs aachen germany june 
appear entcs 
rs ma olivier danvy 
operational foundation delimited continuations cps hierarchy 
december 
iii pp 
rs mads sig ager olivier danvy jan 
functional correspondence monadic evaluators machines languages computational effects 
december 
pp 
extended version article appear theoretical computer science 
rs gerth st rolf gabriel 
adaptiveness quicksort 
december 
pp 
appear tamassia editors seventh workshop algorithm engineering experiments proceedings 
