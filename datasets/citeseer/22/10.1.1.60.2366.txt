ieee transactions software engineering vol 
march style aware architectural middleware resource constrained distributed systems sam malek medvidovic member ieee emergence small resource constrained highly mobile computing platforms presents numerous new challenges software developers 
refer development new setting programming small prism 
provides description evaluation prism mw middleware platform intended support software architecture development prism setting 
prism mw provides efficient scalable implementation level support key aspects prism application architectures including architectural styles 
additionally prism mw extensible support different application requirements suitable prism setting 
prism mw applied number applications educational tool graduate level software architecture embedded systems courses 
prism mw successfully evaluated major industrial organization key distributed embedded systems 
experience middleware indicates principles architecture software development successfully flexibly applied prism setting 
index terms software architecture architectural style middleware prism mw 
software systems continuously growing size complexity 
years increasingly migrated traditional desktop setting highly distributed mobile possibly embedded pervasive computing environments 
environments daunting technical challenges effective understanding existing prospective software configurations rapid composability dynamic reconfigurability software mobility hardware data code scalability large amounts data numbers data types numbers devices heterogeneity software executing device devices 
furthermore software execute small devices characterized highly constrained resources limited power low network bandwidth slow cpu speed limited memory small display size 
refer development software systems described setting programming prism exposition purposes order distinguish traditional software engineering paradigm programming large primarily targeted desktop computing 
software engineering researchers practitioners successfully dealt increasing complexity systems employing principles software architecture 
software architecture provides design level models guidelines composing structure behavior key malek medvidovic department computer science university southern california th pl los angeles ca 
mail malek usc edu 
google th street santa monica ca 
mail google com 
manuscript received mar revised feb accepted feb published online apr 
recommended acceptance kramer 
information obtaining reprints article please send mail tse computer org ieeecs log number tse 
properties software system 
architecture described terms software components computational elements software connectors interaction elements configurations referred topologies 
system architecture adhere architectural styles 
architectural style architectural composition guidelines result software systems certain desired properties 
examples widely styles event clientserver pipe filter peer peer blackboard central role software architectures architectural styles played setting expect importance grow complex prism setting 
corroborated preliminary results studies software architectural issues embedded mobile ubiquitous systems 
order architectural models stylistic guidelines truly useful development setting accompanied support implementation 
particularly important prism setting prism systems may highly distributed decentralized mobile long lived increasing risk architectural drift clear relationship architecture implementation 
describes design evaluation prism mw middleware developed support implementation software architectures prism setting 
say middleware architectural provides programming language level constructs implementing software architecture level concepts component connector configuration event 
middleware tailorable provide native implementation level support arbitrary architectural styles 
allows software developers transfer directly architectural decisions implementations distinguishing prism mw ieee published ieee computer society malek style aware architectural middleware resource constrained distributed systems existing middleware solutions including previously published version 
key contribution prism mw modular design employs extensive separation concerns 
resulted middleware flexible efficient scalable extensible 
middleware assessed flexibility terms support independent selection variation composition concerns 
middleware assessed efficiency terms size speed overhead added application 
middleware assessed scalability terms numbers components connectors events execution threads hardware devices 
middleware assessed extensibility terms support new development concerns situations prism setting including new architectural styles 
properties prism mw successfully evaluated series example applications benchmark tests performed group external users extensions implemented number architectural styles distributed systems 
time experience evaluations prism mw suggested areas study 
rest organized follows section presents objectives 
section briefly describes example application illustrate concepts 
section presents key aspects prism mw design implementation 
section details specific extensions constructed date support various challenges posed prism setting section discusses prism mw support different architectural styles 
section evaluates prism mw respect objectives 
concludes overviews related 
objectives software development prism setting presents number challenges unique inherited 
devices prism applications reside may limited power network bandwidth processor speed memory display size resolution 
constraints demand highly efficient software systems terms computation communication memory footprint 
trade offs address scarcity computing resources directly result highly heterogeneous computing environment 
world prism characterized proprietary operating systems palmos specialized dialects existing programming languages sun java kvm microsoft embedded visual evc data formats prc palmos efs qualcomm brew 
modeling analysis simulation semi automated implementation software systems problems researchers practitioners working actively decades 
problems amplified highly distributed heterogeneous mobile world prism 
goal investigate issues address challenges highlighted context prism mw 
blush number challenges quite familiar software developers years ago 
resource constrained nature prism hardware platforms proprietary development infrastructures platforms reminiscent development world especially arena embedded systems 
time sophistication demanded today software systems comparatively greater size complexity wider distribution mobility desired interoperability heterogeneous platforms demand major advances solutions disposal engineers past 
area believe gain lot leverage tackling challenges software architecture 
aspects architecture development component system composition explicit software connectors architectural styles upstream system analysis simulation support dynamism appear fit needs prism 
software architecture forms approach objective 
prism mw provide native support designing implementing architectural abstractions components connectors events 
furthermore studies recognized currently dearth understanding architectural styles suitable prism setting 
reason prism mw configurable accommodate system development rules different styles possibly single application 
native support software architecture middleware platform primary objective research 
aims address key term prism acronym programming manner leverages best software engineering practices architecture design component implementation middleware distribution 
order truly useful prism setting resulting solution address terms prism acronym small 
additional objectives 
objective 
prism mw impose minimal overhead application execution 
current goal enable efficient execution applications platforms varying characteristics speed capacity network bandwidth 
ongoing extending support include efficient access sharing hardware resources battery peripheral devices 
objective 
prism mw scalable order effectively manage large numbers devices execution threads components connectors communication events prism systems 
objective 
prism mw extensible configurable order accommodate varying development concerns heterogeneous prism setting 
include multiple architectural styles recall objective awareness mobility dynamic reconfigurability security real time support delivery guarantees 
ieee transactions software engineering vol 
march fig 

tds application 
discussion prism mw extent satisfies objectives illustrated example application introduced section 
example application illustrate concepts application distributed deployment personnel situations natural disasters search rescue efforts military crises 
specific instance application depicted fig 
developed cooperation third party organization addresses distributed military troops deployment battle simulations tds 
computer headquarters gathers information field displays current battlefield status locations friendly enemy troops vehicles obstacles mine fields 
headquarters computer networked secure links set pdas commanders field 
commander pdas connected directly large number soldier pdas 
commander capable controlling part battlefield deploying troops analyzing deployment strategy transferring troops commanders 
case headquarters device fails designated commander assumes role headquarters 
soldiers view segment battlefield located receive direct orders commanders report status 
fig 
shows possible instance tds single headquarters commanders soldiers 
detailed analysis tds requirements inputs domain experts identified set candidate software components 
map component maintains model system resources terrain personnel tank units obstacles 
resources permanently stored inside repository component 
components respectively analyze deployments friendly troops respect enemy troops obstacles suggest deployments friendly troops availability positions enemy troops obstacles incrementally simulate outcome battle current situation field 
components store strategy rules provide user interface changing rules respectively 
components enable allocation transfer resources periodically update state resources 
weather components provide weather information analyze effects weather conditions 
provides user interface application 
architect select different subsets components compose different variants tds shown fig 
discussed 
tds helps illustrate number prism concepts 
aspects tds embody notion multiplicity inherent prism 
discussed tds designed combination architectural styles client server pipe filter peer topeer 
implemented top prism mw dialects programming languages java jvm java kvm evc 
devices tds deployed different types palm pilot vx compaq ipaq hp jornada nec sun ultra pc running oss palmos windows xp solaris 
tds deployed mobile devices mobile device emulators running pcs total software components interact software connectors 
dynamic size application approximately mb headquarters subsystem kb commander kb soldier subsystem 
middleware design prism mw supports architectural abstractions providing classes representing architectural element enabling direct mapping architecture implementation 
furthermore prism mw employs defined extensibility mechanism addressing emerging development concerns 
discuss middleware structure semantics extensibility section 
prism mw core fig 
shows class design view prism mw 
shaded classes constitute middleware core represents minimal subset prism mw required implementing executing architecture 
dark gray classes prism mw core directly relevant application developer 
goal keep core compact reflected fact contains classes interfaces 
furthermore tried keep design core entire middleware highly modular limiting direct dependencies classes classes interfaces inheritance discussed 
brick class represents architectural building block 
encapsulates common features subclasses architecture component connector port 
architecture records configuration constituent components connectors ports provides facilities addition removal reconnection possibly system runtime 
distributed application implemented set interacting architecture objects 
events capture communication architecture 
event consists name payload 
malek style aware architectural middleware resource constrained distributed systems fig 

uml class design view prism mw 
middleware core classes highlighted 
event payload includes set typed parameters carrying data metalevel information sender type 
base event types request recipient component perform operation reply sender component performed operation 
ports loci interaction architecture 
link ports welding link acts bidirectional communication channel ports 
port port 
port type request reply 
event placed port forwarded port linked manner shown fig 
request events forwarded request ports reply ports reply events forwarded opposite direction 
components perform computations architecture may maintain internal state 
component dynamically associated application specific functionality class 
allows perform dynamic changes component application specific behavior having replace entire component 
component arbitrary number attached ports 
components interact exchanging events ports 
component generates event places copies event ports appropriate type 
components may interact directly ports connectors 
connectors control routing events attached components 
components connector arbitrary number attached ports 
component attaches connector creating link ports single connector port 
connectors may support arbitrary event delivery semantics unicast multicast broadcast 
order support needs dynamically changing applications prism mw component connector capable adding removing ports runtime 
subclass brick class associated interface 
interface exposes weld method attaching ports 
interface exposes send handle methods exchanging events 
component provides default implementation send method generated events placed asynchronously component ports appropriate type 
detailed section provide implementations interface including synchronous sending events 
interface provides handle method routing events 
connector class provides default implementation handle method forwards request events connector attached request ports reply events attached reply ports 
detailed sections provided implementations different routing policies including unidirectional broadcast bidirectional broadcast multicast 
interface provides method creating association ports 
prism mw core associates scaffold class brick 
scaffold schedule queue events delivery class pool execution threads event dispatching class decoupled manner 
prism mw core provides default implementations respectively 
novel aspect design separation concerns allows independently select suitable event scheduling queueing dispatching policies application 
furthermore allows independently assign different scheduling queueing dispatching policies architectural element possibly change policies runtime 
example separate event queue assigned component alternatively single event queue shared number collocated components 
additionally dispatching scheduling decoupled architecture allowing easily compose scheduling dispatching policies single application 
scaffold directly aids architectural awareness referred reflection allowing probing runtime behavior brick different implementations class discussed section 
prism mw core implemented java jvm 
large subsets described functionality implemented java kvm evc python brew example applications evaluating prism mw 
implementation middleware core relatively small sloc aid prism mw understandability ease 
prism mw semantics distributed system implemented prism mw consists number architecture objects serves container single subsystem delimits address ieee transactions software engineering vol 
march fig 

event dispatching prism mw 
link ports 
steps performed single shepherd thread 
steps performed shepherd threads assuming sending event recipient components 
event dispatching remote scenario 
space 
components different architecture objects interact exchanging events 
default implementation prism mw uses circular array storing events single address space 
allowed optimize event processing introducing pool shepherd threads implemented prism mw round class handle events sent component address space 
size thread pool adjustable 
event queue fixed size determined system construction time producer consumer algorithm keep event production control supply shepherd threads constant stream events process 
figs 
show event processing alternative usage scenarios prism mw 
figures show base case event processing single address space 
technique proved quite flexible allowed support distributed event processing similar manner shown fig 
discussed section 
default prism mw processes events asynchronously 
shepherd thread removes event head queue 
scenario fig 
shepherd thread run connector attached sending component connector dispatches event relevant components thread 
recipient component generates events added tail event queue different threads dispatching events intended recipients 
scenario fig 
direct connections component ports allow separate threads dispatching event queue intended recipient component steps fig 

increases parallelism resource consumption architecture 
solution represents adaptation existing worker thread pool technique results unique benefits 
leveraging explicit architectural topology event routed multiple destinations 
minimizes resource consumption events need tagged recipients recipients need explicitly subscribe events 

optimize resource consumption single event queue storing locally remotely generated events depicted fig 
discussed section 

prism mw processes local remote events uniformly routing accomplished multiple explicit ports connectors prism mw allows seamless redistribution existing applications different hardware topologies 
extensibility mechanism prism mw key objectives extensibility recall section 
design prism mw core intended support objective providing extensive separation concerns explicit architectural constructs classes interfaces 
date built specific extensions support architectural awareness real time requirements security heterogeneity data compression delivery guarantees mobility 
furthermore able support directly multiple architectural styles single application 
section outline mechanism employed supporting extensibility prism mw depicted fig 

detail mechanism applied achieve specific extensions sections 
experience extensions built date indicates easily added middleware manner 
support extensibility built intent keep prism mw core unchanged 
core constructs component connector port event architecture subclassed specialized classes number classes fig 

class multiple implementations extension fig 
enabling selection desired functionality inside instance extensible class 
class instantiated extensible class instance instance exhibit behavior realized inside implementation class 
multiple malek style aware architectural middleware resource constrained distributed systems fig 

prism mw extensibility mechanism extensions ports events components scaffolds 
fig 

usage scenarios 
classes may instantiated single extensible class instance 
case instance exhibit combined behavior installed class implementations 
support prism setting outlined section prism setting imposes stringent requirements software applications application developers 
focused attention number resulting challenges section report facilities built prism mw dealing 
distribution order address different aspects interaction class number classes support various interaction services 
turn class multiple implementations 
fig 
shows different port extensions implemented far 
importance distribution prism domain section focus solely distribution extensions 
section discuss aspects interaction 

prism mw objective arbitrarily extensible principle middleware places restrictions combined behaviors 
developers responsibility ensure behaviors sense 
class implemented concrete classes supporting socket infrared port interprocess communication ipc 
refer instantiated 
instantiated modes operation server client 
operating server mode listening thread socket server waiting incoming connection requests specified network port 
operating client mode listening thread capable making connection requests 
implementation allows arbitrary number network connections remote ports association ports 
receives event broadcasts event network connections 
note association deviation semantics basic port 
discussed section deviation introduced efficiency 
fig 
shows different usage scenarios prism mw 
architectures figs 
semantically identical cases request sent recipient components architecture fig 
efficient ieee transactions software engineering vol 
march uses 
hand architecture fig 
allows connector address space route outgoing event 
prism mw uses basic mechanism communication spans address spaces local communication sending component connector places outgoing event attached port 
depositing event local event queue case deposits event network shown fig 

event propagated network server recipient device uses internal thread retrieve incoming event place local event queue 
supports distribution transparency allows component migrated hosts minimal impact system 
example impact moving fig 
limited replacing attached conn connector local ports 
communication properties depicted figs 
implemented port event extensions respectively enable different aspects communication distribution 
provide brief description 
security class shown fig 
port extension implementations performing combinations authentication authorization encryption event integrity 
services implemented major cryptographic algorithms symmetric secret key asymmetric public key event digest function 
rsa asymmetric key algorithm establishing connection new users transmitting secret session key 
session key efficient des symmetric key algorithm subsequent event exchanges 
order prevent request tampering message digest function combination rsa generate message signature 
message digest kind cryptographic checksum message verify data integrity 
delivery guarantees port event extensions respectively support event delivery guarantees 
implemented support exactly best effort delivery semantics 
prism mw event tagged delivery policy component application logic best effort default 
delivery policy event corresponds implementation installed event 
communicating appropriate implementation installed implement handshaking protocol ensure proper event delivery address spaces 
event delivery guarantee requirements port support requested delivery guarantee event delivered default best effort policy 
order maximize efficiency delivery guarantee support address space programing language pl exceptions assume exception raised event delivered 
real time delivery class shown fig 
assign real time deadline event 
implemented class support aperiodic periodic real time events 
support real time event delivery provided additional implementations class see fig 

implements scheduling aperiodic events algorithm implements scheduling periodic events rate monotonic scheduling 
coupled provided variant implementation supports threads varying priorities 
data conversion order support communication pls provided extensions port event classes respectively 
prism mw events installed default implementation representation encoded decoded ports default implementation 
data compression provided extension port goal minimizing required network bandwidth event dispatching 
implemented huffman coding technique inside compression class 
developed extensions past years need arisen 
adding new extensions prism mw relatively straightforward 
example addition new extension requires adding appropriate class invoking methods inside handle method 
change extensible class minimal averaging new lines code new extension 
overhead introduced solution instance may null corresponding extension classes instantiated 
values checked time handle method invoked 
alternative solution trade extensibility efficiency subclass port class directly desired extensions 
awareness support various aspects awareness reflection prism mw supports metalevel components 
typically metalevel component implemented contains architecture object interface 
class malek style aware architectural middleware resource constrained distributed systems classes provide specific metalevel functionality see fig 

role components metalevel observe facilitate different aspects execution application level components 
point developer may add metalevel components running application 
metalevel components may specific application level connectors exercise control particular portion architecture 
alternatively metalevel component may remain may exercise control entire architecture pointer architecture object 
structural interaction characteristics metalevel components identical application level components eliminating need separate treatment middleware 
date augmented extensions 
implementation class analyzing architectural descriptions assessing proposed architectural changes application execution 
implemented versions interface encapsulate different subsets environment 
section discuss detail class performing component deployment mobility 
relevant awareness discussed section 
deployment mobility distributed architecture prism mw represented configuration components possibly connectors deployed set connected hosts 
setting component migration may required minimize need remote communication increase local subsystem autonomy disconnection perform component upgrade forth 
existing approaches focused providing support component mobility prism setting 
support mobility exploits prism mw explicit software connectors event interaction awareness 
discuss stateless stateful component mobility 
stateless mobility deployment prism mw components communicate exchanging application level events 
prism mw allows components exchange may contain architectural elements components connectors opposed data 
additionally implement serializable interface recall fig 
allowing dispatching address spaces 
order migrate desired set architectural elements set target hosts assume skeleton configuration preloaded host 
skeleton configuration consists prism mw architecture object contains attached 
admin implementation installed shown fig 

device contains pointer architecture object able effect runtime changes local subsystem architecture instantiation addition removal connection disconnection components connectors 
able send receive device connected contain application components connectors referred migrant elements 
process stateless migration described follows sending packages migrant element 
parameter event compiled image migrant element collection java class files parameter denotes intended location migrant element destination subsystem configuration 
sends event forwards event attached remote 
receiving delivers event attached migrant elements event invokes add weld methods insert element local configuration 
stateful mobility technique described provides ability transfer code set hosts 
stateless technique useful performing initial deployment set components connectors target hosts 
cases runtime migration architectural elements required migrant element state needs transferred compiled image element 
additionally migrant element may need disconnected deleted source host 
provide complementary techniques stateful mobility serialization event stimulus 
serialization technique relies existence java serialization mechanisms underlying pl sending set compiled images local possibly disconnects removes active migrant elements local subsystem remove methods serializes migrant element packages set forwarded 
receiving host architectural elements events attach appropriate locations local subsystems 
cases serialization mechanism available java kvm event stimulus technique compiled image migrant element sent network stateless technique 
addition event containing migrant element accompanied set application level events needed bring state migrant element desired point execution see details events captured recorded 
migrant architectural element received destination loaded memory added architecture attached running subsystem 
migrant element stimulated application level events sent 
events migrant element issues response propagated element detached rest architecture 
migrant architectural element brought desired state ieee transactions software engineering vol 
march enabled exchange events rest architecture 
efficient serialization migration scheme simpler technique pl independent natively supported prism mw 
disconnected operation highly distributed mobile systems commonly prism domain challenged problem disconnected operation system continue functioning temporary absence network connectivity 
ensuring availability system disconnection may require system critical interactions occur locally reliable network links 
prism mw support disconnected operation leverages support awareness mobility discussed requires runtime monitoring facilities 
support monitoring prism mw provides class associated scaffold brick shown fig 

allows autonomous active monitoring brick runtime behavior 
provided implementations class records frequencies different events associated brick sends records reliability connectivity associated remote common pinging technique 
maximize availability distributed system leverage implementations class discussed section capable sending receiving installing software components architecture 
capable accessing monitoring data local components connectors recorded associated implementation class forwarding data interested remote hosts 
attached implementation installed 
capabilities recall fig 
additional ability calculate new deployment architecture improves system availability monitored data 
improved deployment architecture calculated component system sending instructions admin components host 
support architectural styles complex large scale system multiple architectural styles may required facilitate different subsystems requirements 
middleware platform implement architectures need support multiple styles 
prism mw design leveraged support number distributed systems styles useful prism setting 
section describe prism mw configured support different architectural styles mechanism introduced section leveraged extensions described section 
order effectively support architectural styles prism mw configured provide 
ability distinguish different architectural elements style distinguishing clients servers client server style 
ability specify architectural elements stylistic behaviors clients block sending request components send requests asynchronously 
ability specify rules constraints govern architectural elements valid configurations disallowing clients connecting client server style allowing filter connect pipe pipe style 
ability multiple architectural styles single application 
leveraged prism mw extensibility support requirements 
extensibility properties prism mw satisfy requirements brick attribute identifies style specific type 
value variable corresponds architectural style element client server pipe filter default value variable null corresponding null style supported prism mw core 
association brick style specific type satisfies requirement enabling identification different architectural elements 
associated implementation class support event routing policies see fig 

example pipe forwards data connector uses bidirectional event broadcast 
partially satisfies second requirement allowing tailoring connector behavior 
associated implementation class provide synchronous component interaction see fig 

default asynchronous interaction provided prism mw core 
partially satisfies second requirement allowing tailor component style specific behavior client blocks sends request server unblocks receives response 
associated implementation class support interprocess communication see fig 

partially satisfies second requirement supporting architectural styles require distribution server may serve distributed clients 
malek style aware architectural middleware resource constrained distributed systems fig 

prism mw support architectural styles 
associated implementation class ensure topological constraints style see fig 

example client server style clients connect servers clients connected 
time extensible architecture weld method invoked appropriate implementation ensures topological rules style preserved 
result performs weld operation raises exception 
satisfies third requirement stated section allowing specification modification valid configurations architectural elements 
note invoking add method results addition component connector architecture object affect system architectural style 
similarly component connector removed method called ensures removal undermine system architectural style 
implements interface allowing hierarchical composition components see fig 

hierarchical component internally composed adhere different architectural styles 
satisfies fourth requirement allowing combinations different styles single system 
support individual styles produce style specific architectural element developer instantiates corresponding extensible class recall fig 
sets desired stylistic behavior installing appropriate extensions 
simplify task provided utility class shown partially fig 
automatically generate architectural elements 
illustration discuss developed support client server style 
style client triggering process server reactive process 
clients requests trigger reactions servers 
client initiates activity times choosing blocks request serviced 
hand server waits requests reacts 
client server prism mw represented 
client uses implementation overrides default nonblocking behavior component 
clients synchronous requests blocking corresponding reply comes back 
reply indicates completion requested operation server 
request ports sends request events servers reply ports 
server component reply ports sends reply events back requesting clients 
prism mw supports client server applications reside address spaces 
fig 
shows simple client server style architecture corresponding code prism mw 
client server architecture composed implementation 
enables welding clients fig 

client server style example 
ieee transactions software engineering vol 
march fig 

architecture tds style single headquarters commander soldier subsystems 
prism mw ports elided clarity 
servers enforcing topological rules disallowing welding clients 
implemented number additional styles see fig 
similar manner 
style required average addition new sloc prism mw 
changes prism mw localized new implementations classes 
average described extensions style required person hour effort including testing 
number supported styles prism mw grows expect implementing new style require effort existing style implementations different connector routing policies may reused 
multiple styles single application complex large scale system multiple architectural styles may required facilitate different subsystems requirements 
prism mw supports multiple architectural styles single application leveraging hierarchical composition 
implements interface recall fig 
allows instances hierarchical components 
application architecture contains multiple styles composed configuration hierarchical components internal architectures may adhere different architectural style 
discuss example tds application introduced section 
tds initially designed style implemented earlier version prism mw 
fig 
shows initial architecture tds 
consists subsystems headquarters commander soldier resides separate device internal architecture 
modified tds architecture soldier commander subsystems commander headquarters subsystems engage client server relationships 
different commander subsystems communicate peers 
details modifications elided brevity 
issue faced original design clock component overwhelming system broadcasting tick messages components system application logic components weather needed delivery tick messages 
moved clock dependent components separate pipe filter style 
modification resulted percent improvement event round trip time events events originating component processed map component 
evaluation prism mw support objectives system implementation architectural abstractions extensibility discussed depth preceding sections 
section summarize evaluation prism mw remaining objectives efficiency scalability recall section 
goals provide empirical results performance trade offs associated design decisions demonstrate middleware efficiency scalability large possibly distributed systems different structures 
support goal evaluated types performance trade offs discussed earlier trade alternative configurations local architecture recall fig 

architectures single component communicates varying number identical components single connector ports directly connect components 
trade alternative configurations distributed architecture recall fig 

considered special case connectors broadcast events results semantically identical configurations distributed architecture detailed 
support second goal measured overhead application size caused prism mw 
evaluated execution large architectures different topologies processing loads sensitivity analysis middleware performance size architecture 
consider architecture configured manner similar depicted fig 
execute different malek style aware architectural middleware resource constrained distributed systems platforms varying numbers events bottom components 
middleware scalability large architectures different topologies 
interested measuring overhead induced application prism mw software components example scenarios contain minimal application logic counting number events sent received forwarding events 
furthermore events exchanged local remote components simple events payload 
selected size thread pool event queue expected load size architecture 
note prism mw allows specification arbitrarily large thread pools event queues 
case benchmarks kept constant size thread pool event queue simplify assessment middleware performance varying loads 
environment set consisted mid range pcs intel pentium iv ghz processors mb ram running jvm microsoft windows xp pdas type compaq ipaq mhz processors mb ram running jvm dedicated network leveraging dual band wireless ghz router 
middleware size memory usage prism mw core mw mem recorded time architecture initialization kb 
overhead base prism mw component comp mem application specific methods state kb overhead base connector conn mem kb 
memory overhead base port port mem kb overhead kb 
memory overhead connection object kb leverages java implementation socket tcp ip communication protocol 
memory overhead contains single connection instance kb 
memory overhead creating sending single event evt mem estimated formula obtained empirically evt mem kb num parameters formula assumes parameters contain complex objects may contain simple objects java integer string 
illustration memory overhead induced prism mw largest instantiation tds architecture recall fig 
consisted single headquarters subsystem commander subsystems soldier subsystems closely approximated follows num arch mw mem size evt mem num comps comp mem num conn mem num ports port mem num dist port mem kb formula uses average size event queue architecture object average number parameters tds events 
formula assumes event queue full observed actual execution tds 
recall section approximate dynamic size headquarters subsystem mb commander subsystem kb soldier subsystem kb resulting total application size mb 
prism mw induced percent overhead application dynamic memory consumption 
measurements memory overhead awareness deployment mobility disconnected operation support recall section showed average java implementation prism mw skeleton configuration prism mw core occupies kb 
occupies kb memory 
middleware performance local setting performance prism mw core local architectures extensions comparable solutions plain programming language pl 
prism mw event exchange causes pl level method invocations typically highly optimized pl comparatively expensive context switch architecture instantiated shepherd thread 
analogous functionality accomplished pl invocations assuming concurrent processing desired context switch 
noted plain pl support number development situations prism mw suited asynchronous event multicast due introduces performance overhead place 
empirically evaluate prism mw core architecture component communicating varying number identical recipient components connector fig 
shows architecture recipient components 
components architecture part architecture object reside single address space 
architecture pool shepherd threads queue events size 
table shows representative benchmark results 
maximum simple parameter events sent asynchronously single sender component maximum recipient components resulting invocations component handle methods application running pc 
events processed seconds pc 
bottom portion table shows results obtained pda comparatively platform maximum events sent maximum components resulting invocations component handle methods 
addition flat architecture series benchmarks ran involved chain components communicating directly ports 
method invocations involve traversing ports placing event queue dispatching recipient component 
ieee transactions software engineering vol 
march intervening connectors 
example total round trip time single event case architecture involved components connectors milliseconds pc 
addition demonstrating prism mw core efficiency benchmarks served highlight scalability 
evaluate performance trade alternative usage scenarios prism mw recall fig 
employed variations flat architecture 
variation discussed communication takes place single connector second variation employs direct links component ports 
components implemented fixed event handling delay msec simulate application specific processing comp proc time utilize benefits parallel processing 
results benchmark shown table 
parameter event sent asynchronously single sender component recipient components resulting events handled 
results demonstrate higher degree parallelism better performance achieved direct connections components 
hand connector resulted lower memory consumption table benchmarking prism mw pc pda outgoing event replicated times 
note total processing time case direct communication illustrated bottom half table approximated formula represents number components represents number shepherd threads architecture total proc time comp proc time total proc time comp proc time middleware performance distributed setting prism mw principle independent employed communication protocols recall section performance directly impacted underlying implementations protocols 
results leverage java implementation tcp ip sockets 
large number benchmarks involving architectures varying sizes topologies communication profiles table components communicating connector versus directly ports malek style aware architectural middleware resource constrained distributed systems compared performance pure java implementation tcp ip 
results indicate prism mw adds percent performance overhead java implementation tcp ip 
section identified different ways instantiating distributed architecture identical event routing semantics 
fact routing policy event broadcast filtering performed connectors semantically equivalent ways instantiating distributed architecture possible 
study performance created example scenarios comprising distributed architecture objects components configured follows scenario 
component communicates directly component separate see fig 

scenario 
component requesting device uses single communicate directly component see fig 
requesting device corresponds address space 
scenario 
component requesting device uses local bidirectional broadcasting connector communicate remote components 
connector separate remote component see fig 

scenario 
similar architecture scenario exception connector single communicate remote components 
scenario 
local bidirectional broadcasting connectors single mediate communication architectures 
table shows performance measurements scenarios described different event loads sent requesting architecture 
measurements reflect time elapsed requesting architecture receives reply events remaining architectures 
ports connectors example broadcast events event sent requesting components events sent scenarios depicted table results table distributed architecture scenarios total replies returned events returned 
observations results table architectures lower numbers lower memory footprints faster running times 
expected adds overhead terms memory execution 
response issue prism mw allows multiple connections associated single 
significantly architectures lower numbers network connections lower memory footprints faster running times 
expected network connection internal thread reads writes events network link 
minimize number network connections may leverage prism mw connectors 
example scenario usage connectors architectures resulted efficient configuration total connections instantiated 
related prism mw primarily influenced research areas architectural styles middleware 
architectural styles discussed sections 
discuss related approaches architectural middleware arena 
additionally describe representative commercial research middleware technologies comparison technologies prism mw 
extension java unifies software architecture implementation ensuring implementation conforms architectural constraints 
arch java currently limitations limit applicability prism setting communication components achieved solely method calls applicable applications running single address space currently limited java efficiency assessed 
aura architectural style supporting middleware ubiquitous computing applications special focus user mobility context awareness context switching 
aura applicable certain classes applications prism setting 
similarly prism mw aura explicit class connectors 
aura ieee transactions software engineering vol 
march provides set components perform management tasks environment monitoring context observing service supplying 
suggests aura style successfully supported prism mw augmented set aura specific extensions 
eliminate need performing optimizations aura current implementation support date tested traditional desktop platforms 
agile going project aim develop architectural approach mobility aspects modeled explicitly mapped physical distribution communication topology 
agile comprises different facets primitives explicitly addressing mobility architectural models community algebraic models evolution processes result system reconfiguration caused component mobility 
particular interest agile open klaim experimental kernel programming language tuple spaces modeling programming distributed concurrent applications code mobility 
prism mw network connectivity implicit open klaim provides constructs explicitly modeling connectivity network nodes handling changes network topology 
time open klaim lacks support explicit architectural constructs components connectors focuses processes units mobility 
projects appear complementary perspective 
related approaches software architecture literature performed comparison prism mw representative middleware solutions respect objectives identified section 
cross section selected middleware technologies covers commercial orbix net research ace dle lime open source solutions jini jxta 
bellow provide comparison technologies prism mw 
architectural abstractions 
tao orbix net provide partial support architectural abstractions form explicit components 
middleware solutions support multiple explicit tailorable software connectors 
furthermore support explicit architectural styles clearly distinguishing prism mw 
styles surveyed technologies implicit fall distributed objects category 
efficiency 
unable locate information performance studied middleware platforms 
section report speed size discussed literature 
studied middleware platforms employ different optimization strategies result achieve different levels efficiency 
efficiency orbix achieved providing ability choose subset features application 
minimal orbix configuration requires kb memory 
tao undergone major redesign improve efficiency minimal configuration tao requires kb memory commercialized version real time corba requires mb memory 
jxta introduces relatively high payload overheads event kb 
protocols xml resulting message composition processing overhead 
net efficiency mainly hampered due reliance underlying windows platform 
example compared unix linux spawning new process windows relatively time consuming operation decreases net performance 
measurements indicate prism mw introduces lower memory performance overheads surveyed middleware solutions 
scalability 
tao orbix support application scalability expense middleware size 
primarily due fact middleware solutions initially targeted desktop platforms designs tailored mobile resource constrained devices 
surveyed middleware technologies implicitly support distributed objects style scalability ultimately hampered reliance single connector orb 
hand peer peer solutions jini address scalability federations groups communities 
jini lookup service issues scalability due lack hierarchical organization lookup servers 
discussed section prism mw scales numbers components connectors events hosts 
extensibility 
different middleware platforms support different aspects extensibility including mobility reconfigurability awareness security delivery guarantees 
example jini supports mobility reconfigurability java object serialization net xmiddle support mobility reconfigurability xml describe units mobility dynamic class loading object serialization perform code migration 
focuses supporting device mobility ensuring components mobile device communicate support code mobility software reconfigurability 
supports mobility reconfigurability form facilities known configured chained service objects provide augmented services underlying mobile applications 
lime supports mobility form agents 
jini xmiddle lime support location awareness 
xmiddle jini extend notion awareness location system properties resource availability battery power technologies tao jxta net rcm support security significant extent 
security highly important context prism systems possibly untrusted components hosts may enter system time 
example net supports security encryption digital signatures provides security enforcement level application users mobile code 
tao provides extensive support event delivery guarantees including exactly delivery semantics orbix provides event storage playback order support reliable malek style aware architectural middleware resource constrained distributed systems event delivery 
surveyed techniques support event delivery guarantees 
design implementation evaluation prism mw middleware targeted applications highly distributed resource constrained heterogeneous mobile settings 
described design implementation result close years research effective techniques implementing software architectures 
key properties prism mw native flexible support architectural abstractions including architectural styles efficiency scalability extensibility 
properties enabled prism mw extensive separation concerns spans dimensions adopting explicit architectural perspective prism mw inherited separation computation handled components interaction handled ports connectors intrinsic software architectures 
providing simple mechanism supporting multiple architectural styles possibly single application prism mw allows system developers separate cleanly system design implementation prism mw style extensions automatically ensure relevant architectural relationships properties 
prism mw extensive classes interfaces minimized dependencies classes allow tailoring concerns ability select different schedulers independently dispatchers compose distribution xml encoding compression facilities network interactions 
prism mw completely separates application conceptual architecture realization 
example component architecture may implemented multiple pls implementations fully interchangeable appropriate implementations class 
turn separation concerns multiple dimensions enables easy selection tailoring exact middleware features needed development situation prism setting 
experience prism mw positive far 
context graduate level classes software architectures embedded systems university southern california collaborations external software development organizations 
successfully team researchers field mobile communication ad hoc networks 
time recognize number pertinent issues remain unexplored 
span issues adding configuration management support prism mw automatically generating optimized version middleware desired set features eliminating need store check class prism mw class implementation 
alternative considering address problem parameterize prism mw variation points classes interfaces 
aware comparable attempts parameterizing middleware extent consider interesting research challenge 
acknowledgments authors reviewers detailed thoughtful reviews 
wish acknowledge beckman sanchez viswanathan students usc courses contributed development prism mw various applications top 
sukhatme discussions subject handheld mobile embedded computing 
especially boehm taylor generous support obtaining initial equipment described research 
described supported equipment intel 
material supported national science foundation numbers ccr itr jet propulsion laboratory army darpa agreement number 
abowd programming environments 
literally ubicomp grand challenge software engineering proc 
sigsoft symp 
foundations software eng nov 
aldrich chambers notkin connecting software architecture implementation proc 
int conf 
software eng pp 
may 
andrade corradini fiadeiro gadducci hoffman koch lapadula lopes montanari oliveira pugliese tarlecki wirsing agile software architecture mobility proc 
th int workshop algebraic development techniques pp 

mascolo capra emmerich middleware mobile computing survey advanced lectures networking networking tutorials pp 
may 
carzaniga rosenblum wolf design evaluation wide area event notification service acm trans 
computer systems vol 
pp 
aug 
chan chuang reflective middleware context aware mobile computing ieee trans 
software eng vol 
pp 
dec 
programming large versus programming small ieee trans 
software eng vol 
pp june 
emmerich software engineering middleware roadmap proc 
conf 
software eng pp 

fiadeiro maibaum categorical semantics parallel program design science computer programming vol 
nos 
pp 
apr 
fielding architectural styles design network software architectures phd thesis univ california irvine june 
fuggetta picco vigna understanding code mobility ieee trans 
software eng vol 
pp 
may 
iona orbix datasheet www iona com whitepapers ds pdf 
ieee transactions software engineering vol 
march lee embedded software advances computers zelkowitz ed vol 

lime lime sourceforge net 
liu layland scheduling algorithms multiprogramming hard real time environment acm vol 
pp 
jan 
mascolo capra emmerich xmiddle data sharing middleware mobile computing personal wireless comm vol 
pp 

medvidovic mehta family software architecture implementation frameworks proc 
working ieee ifip conf 
software architecture vol 
pp 
aug 
medvidovic mehta malek software architectural support handheld computing ieee computer pp 
sept 
medvidovic rosenblum taylor language environment architecture software development evolution proc 
int conf 
software eng pp 
may 
medvidovic taylor classification comparison framework software architecture description languages ieee trans 
software eng vol 
pp 
jan 
mehta medvidovic taxonomy software connectors proc 
int conf 
software eng pp 
june 
microsoft net www microsoft com net 
medvidovic support disconnected operation architectural self reconfiguration proc 
int conf 
autonomic computing pp 
may 
medvidovic adaptable architectural middleware programming small proc 
acm ifip usenix int middleware conf vol 
pp 
june 
medvidovic increasing confidence shelf components software connector approach proc 
symp 
software reusability ssr pp 
may 
object computing www com 
taylor heimbigner johnson medvidovic quilici rosenblum wolf architecture approach self adaptive software ieee intelligent systems vol 
pp 
may 
perry wolf foundations study software architecture acm sigsoft software eng 
notes vol 
pp 
oct 
peterson davie computer networks 
morgan kaufmann 
project jxta www jxta org 
salomon data compression complete 
springer verlag dec 
shaw deline klein ross young abstractions software architecture tools support ieee trans 
software eng vol 
apr 
schmidt ace www cs wustl edu schmidt html 
schmidt flores gokhale software architectures reducing priority inversion non determinism real time object request brokers real time systems vol 
pp 

schmidt tao www cs wustl edu schmidt tao html 
sousa garlan aura architectural framework user mobility ubiquitous computing environments proc 
working ieee ifip conf 
software architecture pp 
aug 
sun microsystems jini tm network technology sun com software jini 
smart small world reputation system manets master thesis dept electrical eng univ southern california oct 
szyperski component software object oriented programming 
addison wesley 
taylor medvidovic anderson whitehead jr robbins component message architectural style gui software ieee trans 
software eng vol 
pp 
june 
ben shaul programming model system support disconnected aware applications resource constrained devices proc 
int conf 
software eng 
icse pp 

yau context sensitive middleware real time software ubiquitous computing environments proc 
int symp 
object oriented real time distributed computing may 
sam malek received ms degree computer science university southern california bs degree university california irvine 
currently phd student computer science department university southern california 
research interests design construction adaptation largescale distributed software systems 
member acm acm sigsoft 
received phd degree university southern california 
works software engineer google research interests area software architectures specific focus architecture software development support highly distributed mobile resource constrained environments 
member acm acm sigsoft 
medvidovic received phd degree university california irvine 
associate professor computer science department university southern california 
recipient national science foundation career award 
research interests area architecture software development 
focuses software architecture modeling analysis middleware facilities architectural implementation product line architectures architectural styles architecture level support software development distributed mobile resource constrained embedded computing environments 
member acm acm sigsoft ieee 
information computing topic please visit digital library www computer org publications dlib 
