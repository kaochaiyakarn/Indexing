programming language probabilistic computation park august cmu cs school computer science carnegie mellon university pittsburgh pa thesis committee frank pfenning chair sebastian thrun chair stanford university geoffrey gordon robert harper norman ramsey harvard university submitted partial fulfillment requirements degree doctor philosophy park research sponsored navy contract 
air force contract nos 
army contract 
dabt generous national science foundation 
views contained document author interpreted representing official policies expressed implied sponsoring institution government entity 
keywords probabilistic language probability distribution sampling function robotics computational effect monad modal logic 
probabilistic computations play increasing role solving various problems researchers designed probabilistic languages facilitate modeling 
existing probabilistic languages focus discrete distributions little effort develop probabilistic languages expressive power discrete distributions 
dissertation presents probabilistic language called ptp probabilistic programming supports kinds probability distributions 
key idea ptp sampling functions mappings unit interval probability domains specify probability distributions 
sampling functions mathematical basis ptp provides unified representation scheme probability distributions drawing syntactic semantic distinction different kinds probability distributions 
independently ptp develop linguistic framework called account computational effects general 
extends monadic language applying possible world interpretation modal logic 
characteristic feature distinction stateful computational effects called world effects contextual computational effects called control effects 
ptp arises instance language construct probabilistic choices 
sound complete translator ptp embed objective caml 
ptp demonstrated applications robotics robot localization people tracking robotic mapping 
ptp serves example high level language applied problem domain imperative languages traditionally dominant 
acknowledgments am grateful advisor frank pfenning support gave graduate years 
unusual patience encouragement eternal witnessed excellent leadership academic advisor technical discussions learned know programming language theory 
am grateful advisor sebastian thrun suggesting thesis topic teaching robotics 
thesis committee time involvement 
chapter grew numerous discussions bob harper fun source inspirations am particularly indebted norman ramsey showing interest carefully reading draft writing insightful comments twice 
sharon burks patience assistance completing dissertation months 
friends carnegie mellon shared experience graduate school younes tu jonathan moody jeff joshua amit 
high school friends thought live pittsburgh graduate years kim park kim 
express sincere gratitude cha unconditionally supportive hard times pittsburgh 
happy times deeply appreciate 
lastly dissertation written support family past years 
ultimately dissertation family achievement 
vi acknowledgments contents motivation 
previous 
sampling functions mathematical basis 
linguistic framework ptp 
applications robotics 
outline 
linguistic framework computational effects 
logical preliminaries 
curry howard isomorphism judgmental formulation 
semantics modal logic 
language 
logic 
language constructs 
substitutions 
world terms instructions 
operational semantics 
examples world effects 
probabilistic computations 
sequential input output 
mutable 
supporting multiple notions world effect 
fixed point constructs 
unfolding semantics 
backpatching semantics 
continuations 
continuations terms 
continuations expressions 
summary 
probabilistic language ptp definition ptp 
syntax type system 
operational semantics 
fixed point construct expressions 
vii viii contents distinguishing terms expressions 
examples 
proving correctness encodings 
approximate computation ptp 
expectation query 
bayes operation 
expectation bayes expression constructs 
cost generating random numbers 
summary 
implementation representation sampling functions 
translation ptp call value language 
extended syntax 
approximate computation 
simultaneous computation multiple samples 
summary 
applications sensor readings action measurement 
robot localization 
people tracking 
robotic mapping 
summary 
list figures translation inference rules hypothetical judgments typing rules 
syntax 
typing rules 
schematic view 
operational semantics uses expression substitutions expression computations 
operational semantics direct style 
typing rules reduction rules mutable 
syntax continuations terms 
reduction rules continuations terms 
syntax continuations expressions 
reduction rules continuations expressions 
syntax ptp 
typing rules ptp 
operational semantics ptp 
fragment ptp source language 
call value language target language 
typing rules target language 
operational semantics target language 
translation source language 
prob truncate 
horizontal vertical computations 
execution times seconds generating total samples 
range readings produced laser range finder 
samples action model 
points map correspond measurements set true pose robot 
points map correspond measurements set hypothetical pose robot 
approximating ms measurement pose 
grid map likelihood map 
probability distribution robot pose processing batch range readings 
progress real time robot localization run 
equations people tracking 
ix list figures implementation people tracking ptp 
progress real time people tracking run 
range readings area robot people tracking run 
implementation robotic mapping ptp 
raw odometry readings robotic mapping experiment 
result robotic mapping experiment 
chapter dissertation describes design implementation applications probabilistic language called ptp probabilistic programming 
ptp uses sampling functions mappings unit interval probability domains specify probability distributions 
sampling functions specifying probability distributions ptp supports kinds probability distributions uniform manner 
ptp demonstrated applications robotics robot localization people tracking robotic mapping 
contribution dissertation fold sampling functions specifying probability distributions 
existing probabilistic languages focus discrete distributions probabilistic computations involving non discrete distributions usually implemented conventional languages 
sampling functions open new way specify kinds probability distributions serve mathematical basis probabilistic languages expressive power discrete distributions 
linguistic framework computational effects 
develop new linguistic framework called account computational effects general 
extends monadic language pfenning davies applying possible world interpretation modal logic :10.1.1.17.1563
distinguishes stateful computational effects called world effects contextual computational effects called control effects provides different view combine computational effects language design level 
ptp arises instance language construct probabilistic choices 
applications ptp robotics 
order execute ptp programs sound complete translator ptp embed objective caml 
ptp demonstrated applications robotics robot localization people tracking robotic mapping 
ptp serves example high level language applied problem domain imperative languages traditionally dominant 
motivation probabilistic computation computation probabilistic choices result represented probability distributions 
alternative paradigm deterministic computation successfully diverse fields computer science speech recognition natural language processing robotics 
success lies fact probabilistic approaches overcome practical limitation deterministic approaches 
trivial example problem testing multivariate polynomial program branch statements identically zero 
difficult find practical deterministic solution simple probabilistic solution evaluate polynomial randomly chosen input check result zero 
probabilistic computations play increasing role solving various problems researchers designed probabilistic languages facilitate implementation :10.1.1.16.5350:10.1.1.29.1299:10.1.1.21.2579
probabilistic language treats probability distributions built datatypes abstracts representation schemes data structures representing probability distributions 
example conventional language may extended datatype probability distributions specified certain choice representation scheme set operations probability distributions 
result allows programmers concentrate formulate probabilistic computations level probability distributions representation schemes 
translated probabilistic language programmers formulation usually produces concise elegant code 
typical probabilistic language supports discrete distributions exists representation scheme sufficient practical purposes set pairs consisting value probability domain probability 
probabilistic language problems involving discrete distributions 
non discrete distributions involved usually conventional language sake efficiency assuming specific kind probability distributions gaussian distributions choosing specific representation scheme set samples probability distribution 
reason little effort develop probabilistic languages expressive power discrete distributions 
unavailability probabilistic languages means implementing probabilistic computation involving non discrete distributions resort conventional language 
wish develop probabilistic language supporting kinds probability distributions discrete distributions continuous distributions belonging group 
furthermore wish draw distinction different kinds probability distributions syntactically semantically achieve uniform framework probabilistic computation 
probabilistic language significant practical impact formulated level probability distributions probabilistic computation directly translated code 
example illustrates disadvantage conventional languages implementing probabilistic computations motivates development ptp 
notation variable ranges domain probability distribution means depending context probability distribution probability distribution probability particular value probability 
write probability distribution want emphasize variable need specific name probability distribution prob probability distribution prob 
similarly means conditional probability probability conditioned write py probability distribution conditioned denotes uniform distribution unit interval 
motivating example ptp bayes filter popular solution wide range state estimation problems 
estimates state system sequence actions measurements action induces change state measurement gives information state 
core bayes filter computes probability distribution bel state update equations bel bel ds bel bel probability system transitions state action state probability measurement state normalizing constant ensuring bel ds 
update equations formulated level probability distributions sense assume particular representation scheme 
unfortunately update equations difficult implement arbitrary probability distributions 
comes implementation usually simplify update equations making additional assumptions system choosing specific representation scheme 
example assumption bel gaussian distribution obtain variant bayes filter called kalman filter 
bel approximated set samples obtain variant called particle filter 
variants bayes filter trivial implement conventional languages 
example kalman filter requires various matrix operations including matrix inversion 
particle filter manipulates weights associated individual samples results complicated code 
conventional languages simulate probability distributions difficult intended meaning code update equations bayes filter 
alternative approach existing probabilistic language discretizing probability distributions 
idea appealing theory impractical reasons 
probability distribution may easy choose appropriate subset support discretization performed 
example order discretize gaussian distribution support need choose threshold probabilities discretization confined interval finite length arbitrary probability distribution threshold computed examining entire probability domain 
subset support fixed advance process discretization may incur considerable amount programming 
example fox develop non trivial techniques specific applications sole purpose efficiently manipulating discretized probability distributions 
second probability distributions discretized meaningful way 
example probability distributions probability distributions functions occur real applications chapter presents example 
probabilistic language supporting kinds probability distributions implement update equations effort 
ptp probabilistic language designed goals mind 
previous number probabilistic languages focus discrete distributions 
language usually provides probabilistic construct equivalent binary choice construct 
presents probabilistic language binary choice construct 
koller mcallester pfeffer order functional language coin toss construct flip probability 
pfeffer generalizes coin toss construct multiple choice construct dist pn en pi :10.1.1.29.1299
gupta jagadeesan panangaden stochastic concurrent constraint language probabilistic choice construct choose dom dom finite set real numbers 
ramsey pfeffer stochastic lambda calculus section indices stands probabilities program fragments values :10.1.1.16.5350
binary choice construct choose 
constructs different forms equivalent binary choice construct expressive power 
easy way process binary choice construct equivalent computation generate sample probability distribution denotes probabilistic languages 
way return accurate representation probability distribution enumerating elements support probabilities 
extended lambda calculus uses probabilistic construct form ei pi pi 
program denoting probability distribution computes normal form vi pi accurate representation probability distribution 
jones presents metalanguage binary choice construct orp 
operational semantics uses judgment 
mogensen presents language specifying die rolls 
denotational semantics called probability semantics formulated similar style directly terms probability measures 
jones mogensen provide equivalent recursion construct enables programmers specify discrete distributions infinite support geometric distribution 
probability distribution difficult represent accurately infinite number elements support 
reason jones assumes pi judgment mogensen uses partial probability distributions sum probabilities may 
intuition finite recursion depth elements support omitted enumeration 
probabilistic languages supporting continuous distributions 
kozen investigates semantics probabilistic programs 
random assignment random assigns random number variable assume specific probability distribution random number generator language serves framework probabilistic languages 
thrun extends probabilistic data types created template prob type 
language called ces supports common continuous distributions semantics formally defined 
originally motivated desire develop probabilistic language expressive ces formal semantics 
sampling functions mathematical basis expressive power probabilistic language determined large extent mathematical basis 
set probability distributions expressible probabilistic language determined principally mathematical objects specifying probability distributions 
intend support kinds probability distributions drawing syntactic semantic distinction choose applicable specific kind probability distributions 
examples probability mass functions specific discrete distributions probability density functions specific continuous distributions cumulative distribution functions assume ordering probability domain 
probability measures possibility synonymous probability distributions 
probability measure domain mapping satisfying conditions 

countable disjoint union idi subsets di idi required subset idi di conceptually maps set subsets set events probabilities 
probability measures practical choice mathematical basis difficult represent domain infinite 
example consider continuous probability distribution position robot dimensional environment 
continuous domain infinite environment physically finite 
probability measure corresponding able calculate probability part environment opposed particular spot environment contiguous region collection disjoint regions rectangular oval shaped 
finding suitable representation involves problem representing arbitrary part environment far routine task 
main idea specify probability distribution answering generate samples equivalently providing sampling function 
sampling function defined mapping unit interval probability domain random number drawn returns sample specifies unique probability distribution 
way random numbers serve source probabilistic choices 
specifying generate samples wish exploit sampling techniques developed simulation theory consume multiple independent random numbers produce single sample 
generalized notion sampling function maps denotes infinite product 
operationally sampling function takes input infinite sequence random numbers drawn independently consumes zero random numbers returns sample remaining sequence 
generalization notion sampling function acceptable measure theoretically 
example technique expanding single real number infinite sequence real numbers odd bits binary representation real number produce real numbers repeating procedure 
mathematical basis ptp choose sampling functions overcome problem probability measures applicable kinds probability distributions easy represent global random number generator generates random numbers necessary infinite sequences random numbers 
comparison probability measures consider probability distribution position robot discussed 
devising sampling function construct algorithm probabilistically generates possible positions robot need consider problem representing arbitrary part environment essential case probability measures 
intuitively easier formalize answer robot robot region 
sampling functions mathematical basis leads desirable properties ptp 
provides unified representation scheme probability distributions longer distinguish discrete distributions continuous distributions belonging group 
unified representation scheme difficult achieve candidates mathematical basis 
second enjoys rich expressiveness specify probability distributions infinite discrete domains continuous domains unusual domains infinite data structures trees cyclic domains angular values 
third enjoys high versatility way specify probability distribution know better encode 
section demonstrates properties various examples written ptp 
data abstraction probability distributions ptp sampling function represented probabilistic computation consumes zero random numbers single random number drawn 
context data abstraction means probability distribution constructed probabilistic computation 
expressive power ptp allows programmers construct encode kinds probability distributions uniform way 
equally important question observe reason probability distribution get information various queries 
probabilistic computation ptp describes procedure generating samples way observe probability distribution generating samples 
result ptp limited support queries probability distributions 
example permit precise implementation queries means variances probabilities specific events 
ptp alleviates limitation exploiting monte carlo method approximately answers query probability distribution generating large number samples analyzing 
example consider continuous probability distribution pose position orientation robot dimensional environment 
queries answered approximately draw sample robot pose random 
expected average pose robot 
probability robot facing degrees due east 
probability robot peter office 
assumption robot peter office probability robot feet door queries answered approximately repeatedly performing probabilistic computation associated analyzing resultant samples 
example query answered follows 
generate samples 
filter samples indicating robot peter office 

count number samples indicating robot feet door divide total number remaining samples 
certain queries probability distributions difficult answer approximately monte carlo method 
example queries difficult answer approximately simple analysis samples position robot 
room robot number rooms unknown 
due nature monte carlo method cost answering query proportional number samples analysis 
cost generating single sample determined specific procedure chosen programmers probability distribution draw samples 
example geometric distribution encoded recursive procedure simulates coin tosses certain outcome observed simple transformation called inverse transform method requires single random number 
methods encoding probability distribution differ cost generating single sample cost answering query monte carlo method 
similar reason accuracy result monte carlo method improves number samples affected procedure chosen programmers 
measure theoretic view sampling functions accepted mathematical basis probability theory measure theory associates probability distribution unique probability measure 
give summary measure theory discussing connection sampling functions measure theory 
discussion sampling functions refer input generalized ones input 
measurable sets space subsets measurable space collection measurable sets 

closed complement 
countable collection measurable sets si holds isi 
closed countable union 
measurable function mapping 
measure mapping 
countable disjoint union isi measurable sets si holds isi si 
probability measure satisfies 
lebesgue measure unit interval probability measure equal total length intervals measure theory allows certain sampling functions specify probability distributions 
consider sampling function introduced primarily mathematical function may interpreted measurable function case defines unique probability measure lebesgue measure unit interval 
intuition event assigned probability equal size inverse image dissertation investigate measure theoretic properties sampling functions definable ptp 
probabilistic computation expressed ptp consumes random number drawn easy identify corresponding sampling function 
sample consumed obvious construct sampling function 
fact presence fixed point constructs ptp recursive computations consume arbitrary number random numbers difficult define measurable spaces sampling functions map unit interval fixed point constructs domain theoretic structures measure theoretic structures order solve resultant recursive equations 
probabilistic computation expressed ptp easily translated generalized sampling function takes input 
unknown generalized sampling functions definable ptp measurable 
unknown generalized sampling functions measure theoretically equivalent ordinary sampling functions measurable function determines unique measurable function 
generalized sampling functions definable ptp shown closely connected sampling techniques simulation theory measure theory widely agreed form probabilistic computation ptp designed support 
discussion section 
linguistic framework ptp develop ptp functional language extending calculus imperative language library embedded existing conventional language 
decide monadic syntax probabilistic computations 
decision observations 
sampling functions operationally equivalent probabilistic computations describe procedures generating samples infinite sequences random numbers 
second sampling functions form state monad set states observations imply monadic syntax probabilistic computations straightforward interpret probabilistic computations terms sampling functions :10.1.1.16.5350:10.1.1.26.2787
monadic syntax treats probability distributions class values offers clean separation regular values probabilistic computations 
designing monadic syntax specialized sampling functions developing linguistic framework accounts computational effects general 
borrow syntax moggi monadic metalanguage ml 
extends monadic language pfenning davies reformulation ml modal logic perspective :10.1.1.17.1563
may thought monadic language combined possible world interpretation modal logic 
characteristic feature classifies computational effects kinds world effects control effects 
world effects stateful computational effects mutable input output control effects contextual computational effects exceptions continuations 
probabilistic choices particular case world effect ptp arises instance language construct consuming drawing random numbers 
applications robotics implementing ptp complete programming language embed existing functional language building translator 
specifically extend syntax objective caml incorporate syntax ptp translate language constructs ptp back original syntax 
translator sound complete sense type reducibility program ptp typed reducible ill typed irreducible preserved translated objective caml 
important part demonstrate ptp applying real problems 
main testbed choose robotics 
offers variety real problems necessitate probabilistic computations continuous distributions 
ptp applications robotics robot localization people tracking robotic mapping 
case state robot represented probability distribution update equation formulated level probability distributions translated directly ptp 
experiments carried real robots 
comparison robot localizer written gives evidence benefit implementing probabilistic computations ptp readability conciseness code outweigh disadvantage speed see section details 
ptp serves example high level language power exploited problem domain imperative languages traditionally dominant 
outline rest dissertation organized follows 
chapter presents linguistic framework ptp 
chapter presents syntax type system operational semantics ptp 
chapter describes translator ptp objective caml 
chapter presents applications ptp robotics 
chapter concludes 
chapter linguistic framework chapter presents linguistic framework ptp 
extension calculus modality accounts computational effects general 
developing interested modeling computational effects input output mutable continuations 
view probabilistic choices particular case computational effect ptp arises instance language construct probabilistic choices 
key concepts development follows segregation world effects control effects 
classifies computational effects kinds stateful world effects contextual control effects 
distinction easy combine computational effects language design level 
possible world interpretation modal logic 
uses modal logic characterize world effects relates modal logic world effects possible world interpretation 
result notion world world effects coincides notion world possible world interpretation formulating logic judgmental style pfenning davies :10.1.1.17.1563
core applies possible world interpretation monadic language pfenning davies uses lax logic judgmental style reformulate moggi monadic metalanguage ml :10.1.1.36.5778:10.1.1.17.1563
monadic language pfenning davies analyzes computational effects level proof theoretic perspective readily extend programming language computational effects 
attempt extend monadic language operational semantics support concrete notions computational effect 
key idea combine possible world interpretation judgmental style way accessibility relation integral part possible world interpretation inference rules system modal logic simpson example 
specific probabilistic computations development optional purpose designing ptp investigate better explain logical foundation ptp 
definition ptp chapter self contained chapter skipped loss continuity readers want understand ptp 
computational effects section gives definition computational effects 
clarification notion computational effect may appear little significance know called computational effects profound impact design 
section gives overview level syntax semantics 
definition computational effects context functional languages computation effects usually defined destroys purity functional languages 
informally purity functional language means function denotes mathematical function black box converting valid argument unique outcome 
example function fn ml denote mathematical function outcome depends content conclude mutable computational effects 
examples computational effects include input output exceptions continuations non determinism concurrency probabilistic choices 
notion purity subtle universally accepted definition purity 
sabry shows common criteria purity soundness equational axiom confluence church rosser property independence order evaluation preservation observational equivalences incomplete fail hold pure functional languages continue hold impure functional languages referential transparency considered universally accepted definition 
proposes definition purity independence reduction strategies definition drawback functional language implementations reduction strategies call value call need call name 
result definition computational effects destroys purity functional languages ambiguous concepts called computational effects justification 
example nontermination called computational effect convention special kind computational effect observable 
time may argue non termination computational effect pointed types types augmented bottom element denoting non termination preserves property mathematical functions 
definition computational effects necessary designing functional language ml scheme allows program fragment produce computational effects 
crucial design functional language haskell subsumes sublanguage computational effects criterion computational effects determines features supported sublanguage 
case haskell illustrates importance proper definition computational effects inspires definition computational effects 
computational effects haskell programming language community monads considered elegant means structuring functional programs incorporating computational effects functional languages :10.1.1.33.5381:10.1.1.100.9674
example functional language extensive monads design haskell 
programming level provides type class monad facilitate modular programming language design level provides built io monad producing computational effects compromising properties pure functional language 
haskell assume particular definition computational effects 
implicitly identifies computational effects monads confines kinds computational effects monad similar st monad :10.1.1.118.8664
haskell conceptually consists sublanguages functional sublanguage produces computational effects monadic sublanguage formed monad 
abbreviated haskell henceforth 
identification computational effects monads may appear innocuous success monads means modeling different computational effects uniform manner 
kinds computational effects identification problematic monads combine :10.1.1.33.5381
haskell uses monad kinds computational effects explicitly addressing difficulty 
identification enforces unconventional treatments computational effects 
example disallows exceptions functional sublanguage useful handling division zero pattern match failures 
disallows continuations functional sublanguage useful implementing advanced control constructs non local exits routines 
identification significantly limits practical utility exceptions continuations 
reason extension haskell proposed peyton jones allows exceptions monadic sublanguage functional sublanguage deviating identification computational effects monads 
view computational effects identified monads identification computational effects monads haskell consequence lack proper definition computational effects 
capability monads model kinds computational effects may rationale identification really warrant identification implies monads particular tool studying denotational semantics computational effects 
example consider set monad modeling non determinism 
set monad suitable specifying denotational semantics non deterministic language non deterministic choice construct program translated set enumerating possible outcomes 
set monad lend operational design non deterministic language program returns single outcome set possible outcomes producing computational effects 
set monad useful developing denotational semantics possibly syntax non deterministic language implementing operationally 
fact set monad implementing non deterministic language operationally argue built io monad unnecessary haskell instantiate type class monad mimic computational effects supported io monad 
main lesson learned haskell modeling computational effect separate issue implementing operationally 
lesson learned haskell implementation state monad io monad suitable stateful computational effects mutable input output compatible contextual computational effects exceptions continuations 
stateful computational effects may identified monad contextual computational effects need restricted monadic sublanguage 
definition computational effects captures distinction kinds computational effects calling world effects control effects 
world effects control effects directly define computational effects relying notion purity functional languages 
central assumption run time system consists program world 
program subject set reduction rules 
example program calculus runs applying reduction rule 
world object behavior specified programming environment reduction rules 
example keyboard buffer part world keystroke read operation changes contents 
contrast heap part world just convenience implementing reduction rules 
implement reduction rules heaps 
reader holds view computational effects monads identified example may hard follow 
external agent program interacts world causes transition world say world effect occurs 
example keyboard buffer part world keystroke user read operation program changes contents causes world effect 
example store mutable part world operation allocate dereference deallocate interacts world causes world effect 
program undergoes change sequence reduction rules induce say control effect occurs 
example reduction rule reduction rule raising exception causes control effect general induces change independent reduction rule 
similar reason capturing throwing continuations cause control effects 
note concept control effect relative set basic reduction rules assumed run time system 
imagine run time system built reduction rules exceptions case raising exception regarded control effect 
world effects control effects fundamentally different characteristics realized different ways 
world effects realized specifying world structure empty world structure world effects keyboard buffer display window input output store mutable 
control effects realized introducing program transformation rules defined terms existing reduction rules 
world structures program transformation rules concerned different parts run time system world effects control effects treated orthogonal ways 
distinction world effects control effects easy combine computational effects language design level 
different world effects combined merging corresponding world structures 
example world structure keyboard buffer display window store realizes input output mutable 
need explicitly combine control effects computational effects control effects pervasive corresponding program transformation rules introduced 
world effects divided internal world effects external world effects 
internal world effect caused program ephemeral sense change world undone run time system 
example allocate new reclaimed run time system 
external world effect caused external agent affecting program program affecting external agent 
perpetual sense change world undone run time system 
example keyboard input send output printer type password malicious program print public printer going back catastrophic consequence 
internal world effects occur run time system external world effects involve interactions external agents 
regard external world effects examples concurrency presence external agents 
intended model external agents restrict internal world effects developing 
haskell mentioned earlier haskell conceptually consists sublanguages functional sublanguage essentially calculus produces computational effects monadic sublanguage formed io monad produces world effects control effects 
peyton jones clarifies distinction sublanguages level semantics inner denotational semantics functional sublanguage outer transition operational semantics monadic sublanguage 
control effects need restricted monadic sublanguage consider variant haskell allows functional monadic sublanguages produce control effects 
comparison haskell variant disadvantage function may denote mathematical function overcomes limitation haskell dealing control effects 
thought reformulation variant haskell logical perspective 
syntactic categories terms expressions 
terms form sublanguage subsumes calculus allowed produce control effects expressions forms sublanguage allowed produce world effects control effects 
logic definition expressions logic underlying monads lax logic 
monadic sublanguage haskell expressions enforce monadic syntax modality 
logical preliminaries firm logical foundation providing logical analysis computational effects 
section explains concepts logic play key roles development 
curry howard isomorphism judgmental formulation curry howard isomorphism principle connecting logic programming languages 
states propositions logic correspond types programming languages propositions types correspondence proofs logic correspond programs programming languages proofs programs correspondence 
formulation logic systematically derives type system reduction rules corresponding programming language 
development follows pattern formulate logic apply curry howard isomorphism obtain type system reduction rules 
logic formulated judgmental style pfenning davies :10.1.1.17.1563
judgmental formulation logic adopts martin methodology distinguishing propositions judgments 
differs traditional formulation relies solely propositions 
review results pfenning davies :10.1.1.17.1563
propositions judgments judgmental formulation logic proposition object verification truth checked inference rules judgment object knowledge evident proof 
examples propositions equal equal inference rules arithmetic 
examples judgments equal true proof equal true proof 
clarify difference propositions judgments consider statement moon cheese statement object verification proposition way check truth 
proposition inference rule example written way moon cheese true moon white holes true attempt verify proposition example picture moon 
know proposition true virtue inference rule know counts verification 
picture shows moon white holes inference rule evident judgment moon cheese true know moon cheese true proof consisting picture inference rule 
proposition object verification may may true judgment object knowledge know know 
concrete example consider conjunction connective 
order proposition need way check truth 
intended true true inference rule explain proposition assume propositions abbreviate truth judgment true true true true true rule says true true true 
follows usual interpretation inference rule premises hold holds 
rule construct proof true proof da true proof db true write da true mean da proof true da db true true true proposition check truth rule true judgment know know depending existence proof 
rule called rule conjunction connective deduces truth judgment introduces 
dual concept elimination rule premises exploit truth judgment prove judgment eliminates 
case elimination rules el er true true el true true elimination rules sense true implies true true 
discuss properties formal way 
important judgmental formulation logic notion judgment takes priority notion proposition 
specifically notion judgment depend propositions new kind judgment defined terms existing judgments existing connectives modalities 
hand propositions explained existing judgments including truth judgments new connective modality defined compactly represent knowledge expressed existing judgments 
example define falsehood judgment false true hold new modality rule false true say rule false proposition definition connective modality involves connective modality say orthogonality destroyed sense connectives modalities developed independently orthogonally 
dissertation connective modality destroying orthogonality 
categorical judgments hypothetical judgments judgment true called categorical judgment involves hypotheses unconditional 
judgment need hypothetical judgment involves hypotheses 
general form hypothetical judgment reads judgments jn hold judgment holds written jn refer ji antecedent succedent 
hypothetical judgment jn evident proof jn assumed evident proofs 
proof called hypothetical proof written er follows jn 
inference rules inference rules judgment ji requiring proof hypothesis 
say hypothesis ji discharged inference rules deduce ji 
note hypothetical proof antecedent essentially proof judgment vice versa proofs show holds categorically 
notion hypothetical proof illustrated implication connective 
order proposition need way check truth 
intended true true implies true rule uses hypothetical proof premise true true true elimination rule exploits true premises prove true true true true rule sense true licenses deduce true true holds case second premise 
definition hypothetical judgments implicit assumptions order antecedents immaterial antecedent may zero times hypothetical proof 
assumptions formally stated structural rules hypothetical judgments exchange ji ji jn ji ji jn 
weakening jn jn jn judgment jn 
contraction ji ji jn ji jn hypothetical proof combined hypothetical proof 
example hypothetical proof jn combined hypothetical proof jn produce hypothetical proof written jn jn jn 
equivalence mean hypothetical judgment equivalent judgment states holds categorically unaware hypotheses hypothesis hypothetical proof 
example assumption implies show implies converse case 
note hypotheses jn may twice proving proving property hypothetical judgments hypothetical proof substituted hypothetical proof called substitution principle substitution principle convenient way prove hypothetical judgments inference rules hypothetical judgments relying hypothetical proofs 
example explain implication connective inference rules hypothetical judgments abbreviate collection antecedents true true true true true true rule uses hypothetical judgments express proposition true true implies true elimination rule uses hypothetical judgments express true licenses deduce true true holds 
proof inference rules guarantees existence corresponding hypothetical proof special form hypothetical judgment ji jn ji succedent matches antecedent evident vacuous proof 
inference rule called hypothesis rule expresses property hypothetical judgments simply says hypothesis hyp assume antecedents hypothetical judgments basic judgments 
example consider hypothetical judgments 
curry howard isomorphism curry howard isomorphism connects logic programming languages representing proof judgment program corresponding type 
words typed program compact representation valid proof curry howard isomorphism 
typically apply curry howard isomorphism translating inference rules logic typing rules programming language 
convention typing rule name inference rule derived 
example consider logic truth conjunction connective implication connective 
curry howard isomorphism logic corresponds type system calculus product types 
proof true represented proof term type note interpreted proposition type 
judgment mean proof term represents proof true proof term type correspondence true consider inference rule constructing proof true proof da true proof db true 
proof terms ma mb represent da db respectively product term ma mb product type represent inference rule translated typing rule ma mb ma mb true true hyp true true true true el true true er true true true true true true true hyp fst el snd er translation inference rules hypothetical judgments typing rules 
projection terms fst snd translating rules el er fst el snd er hypothetical proof uses true hypothesis assumes existence proof 
proof unknown represented concrete proof term 
represented variable special proof term replaced proof term 
proof true true true represented proof term satisfying hypothetical judgment xn means proof term type assumption variable xi type ai true true true xn refer collection judgments xn typing context 
collections antecedents abbreviate typing contexts variables typing context assumed distinct 
correspondence hypothetical judgments inference rules hypothetical judgments logic translated typing rules hypothetical judgments example inference rules translated typing rules lambda abstraction lambda application proof terms shows inference rules hypothetical judgments logic shown left column translation typing rules shown right column 
left column shows inference rules hypothetical judgments right column shows corresponding typing rules 
hypothesis rule hyp translated typing rule called hypothesis rule typechecks variable 
typing rules right column constitute type system calculus product types 
hypothetical proof substituted hypothetical proof proof term substituted proof term 
suppose represent hypothetical proofs true true true respectively symbol collection antecedents corresponding typing context 
replace occurrences obtain proof term written contains occurrence substitution principle proof terms states represents hypothetical proof true true substitution principle true true called synthetic judgments prior information proofs search synthesize proofs inference rules 
contrast called analytic judgments proofs represented reconstructed analyzing prove typing rules analyze determines typing rule applied deduce example product term deduction ends application typing rule reason deduction called derivation proof 
construct unique derivation check represents proof true searching unknown proof 
derivation effectively typechecks testing type call typing judgments 
reduction expansion rules inference rules far sense intuitively correctness established formal way 
show inference rules satisfy properties local soundness local completeness 
curry howard isomorphism properties correspond reduction expansion rules proof terms culminating foundation operational semantics programming languages 
rule compresses knowledge expressed premises truth judgment elimination rule retrieves knowledge compressed truth judgment premise deduce judgment 
local soundness property states knowledge retrieved judgment elimination rule part knowledge compressed judgment 
local soundness property fails elimination rule strong sense capable knowledge justified judgment 
local completeness property states knowledge retrieved judgment elimination rule includes knowledge compressed judgment 
local completeness property fails elimination rule weak sense incapable retrieving knowledge compressed judgment 
elimination rule satisfies properties retrieves exactly knowledge compressed judgment premise 
verify local soundness property showing reduce proof rule immediately followed corresponding elimination rule 
example consider proof conjunction connective true true true el true elimination rule el strong deduces true judgments deduce true 
proof reduces simpler proof true true true el true true elimination rule strong deducing true proof re 
example consider proof implication connective true true true true true substitution principle proof reduces simpler proof true true true true true true true true refer reductions local reductions 
verify local completeness property showing expand proof judgment proof elimination rules followed rule judgment 
example consider proof true 
elimination rules el er weak deduce true true sufficient reconstruct proof true true true true el true true er true elimination rules weak unable deduce true proof expandable 
example consider proof true 
weakening property proof true true 
reconstruct proof true expanding true true true true true hyp true true true refer expansions local expansions 
proof terms essentially proofs local reductions expansions induce reduction expansion rules proof terms fst snd fst snd note reduction expansion rules preserve type proof term 
implies reduction rules called reduction rules expansion rules called expansion rules 
programming language calculus program defined typed closed proof term proof term certain type usually run program applying reduction rules specific reduction strategy 
example call name reduction strategy reduces program reduction rule regardless form term contrast call value reduction strategy reduces reduction rule applicable value 
operational semantics programming language calculus specified reduction strategy applying reduction rules 
semantics modal logic modal logic form logic truth may qualified modalities 
examples modalities common literature necessity modality possibility modality 
informally true means necessarily true true means possibly true modal logic expressive ordinary logic modalities applied design programming language enables type system specify richer properties difficult specify 
popular way explain semantics modal logic possible world interpretation 
assumes set worlds truth worlds 
ordinary truth true uses relative truth true world primitive notion 
proposition may true world world 
possible world interpretation assumes accessibility relation worlds explain meaning modality 
example necessity possibility modalities defined follows true world world accessible true true world true world accessible 
ordinary connectives explained locally individual worlds irrespective 
example true world true implies true definition modalities proposition true world regardless accessibility relation 
example true world sufficient show true accessible world 
various systems modal logic obtained requiring satisfy certain properties 
table shows properties corresponding propositions true world property proposition reflexivity 
symmetry implies transitivity imply imply example reflexive transitive obtain system modal logic usually referred true world 
semantics modal logic explained explicitly notion world 
judgmental formulation modal logic pfenning davies define validity judgment valid true internalize valid modal proposition valid true true interpreted true world know equivalently world :10.1.1.17.1563
note judgment defined corresponding modality introduced 
possibility judgment poss interpretation poss true certain world definition worlds explicitly 
true poss 

poss true poss poss 
possibility judgment poss internalized modal proposition poss true possible world interpretation richer judgmental formulation proposition true possible world interpretation judgmental formulation 
example proposition 
true possible world interpretation follows write true world hyp hyp truth provable judgmental formulation true true true true certain sense possible world interpretation inherently expressive judgmental formulation explicitly specifies world proposition true 
hand may basis type system programming language accessibility relation proofs implies type system needs reason relation worlds difficult depending concrete notion world chosen type system 
judgmental formulation lends purpose worlds explicitly inference rules 
logic combines possible world interpretation judgmental style assuming accessibility relation worlds judgments worlds 
example uses truth judgment form true mean true world 
inference rules judgments showing accessibility worlds case judgmental formulation modal logic see simpson system modal logic uses judgments inference rules 
requires accessibility relation satisfy certain condition monotonicity eliminates need judgments inference rules 
possible world interpretation worlds part run time system lack judgments inference rules implies type system explicitly model changes run time system case typical type system 
language pfenning davies monadic language reformulates moggi monadic metalanguage ml :10.1.1.17.1563
applies curry howard isomorphism lax logic formulated judgmental style lax truth judgment lax 
true lax 
lax true lax lax essentially monadic language pfenning davies coalesced possible world interpretation 
difference definition judgment relies truth accessibility relation clauses describing properties clauses 
words definition judgment directly conveys intuitive meaning 
logic development begins formulating logic 
logic uses possible world interpretation define accessibility relation worlds 
world refers notion describes part run time system 
definition 
world accessible world written exists world effect causes transition describes transitions worlds world effects produced accessibility relation temporal relation worlds 
say world past world note reflexive transitive vacuous world effect causes transition world combination world effects regarded single world effect 
logic uses kinds basic judgments relativized worlds truth judgment true means true world 
computability judgment comp means true world true holds truth judgment true represents known fact world 
world reached producing world effect computability judgment comp may interpreted meaning true producing world effect world 
properties hypothetical judgments characterize truth judgments truth judgment computability judgment characterization truth judgments 
true true 

true true clause expresses true may hypothesis 
second clause expresses substitution principle truth judgments 
definition computability judgments gives characterization adaptation characterization lax truth possible world interpretation characterization computability judgments 
true comp 

comp true comp world comp 
clause expresses true true producing world effect 
follows reflexivity true holds true accessible comp holds 
second clause expresses true producing world effect may true hypothesis deducing judgment judgment computability judgment comp transitivity allows deduce comp proof second clause 
assume comp implies true 
prove comp hypotheses follows comp holds comp 
true holds assumption comp 
comp holds true comp 
true holds world definition comp 
comp holds transitivity 
second clause substitution principle computability judgments 
monotonicity accessibility relation intend world effects accumulating knowledge discarding existing knowledge 
informally world effect causes transition world facts known world effects produced 
monotonicity accessibility relation formalizes intention world effects accumulating knowledge definition 
accessibility relation monotonic worlds true implies true true true comp implies true true comp condition monotonicity truth states world inherits facts known past worlds 
proves new properties hypothetical judgments 
true true 
true true second condition persistence computation states world effect produced world facts reproduced world equivalent facts 
monotonicity truth uses hypothetical judgments antecedents truth judgments world succedent 
reason world effect may require facts world produced allocating new requires argument initializing new heap cell corresponding computability judgments different worlds compared persistence equivalent facts individual worlds 
note monotonicity truth imply persistence computation 
example comp holds true monotonicity truth allows conclude comp world accessible world accessible 
simplified form hypothetical judgment principle hypothetical judgment imposes restriction antecedents succedent judgment world may include truth judgments computability judgments world past worlds worlds worlds unrelated 
general form hypothetical judgment allows express reasoning past 
examples reasoning past transaction failure database system past create log file 
program produced output input 
heap cell deallocated longer available copy 
program open file eventually close 
intend reason logic imposes restrictions antecedents hypothetical judgments uses simplified form hypothetical judgment described 
simplified form uses antecedents truth judgments 
computability judgment exploited antecedent truth judgment asserts shown second clause characterization computability judgments 
second simplified form uses judgments world 
words hypothetical proof reasons world consider relation past worlds unrelated worlds 
rationale second simplification fold 
facts past worlds automatically facts world monotonicity 
reason consider facts past 

general facts worlds unknown world temporal nature 
support reasoning worlds necessity possibility modalities necessary 
logic uses forms hypothetical judgments true true true abbreviated true true true 
true true comp abbreviated true true comp 
logic requires simplified form hypothetical judgment simplify characterization truth computability judgments accordingly 
new characterization truth judgments just special case previous characterization characterization truth judgments 
true true 

true true judgment world 
new characterization computability judgments consider transitions worlds characterization computability judgments 
true comp 

comp true comp comp 
proof second clause 
true true write true true 
assume comp true comp 
world true comp holds persistence computation true comp holds monotonicity truth 
comp comp holds substitution principle computability judgments 
note second clause comp leads new hypothesis truth judgment world world 
comp holds true new hypothesis true true reason world effect corresponding comp cause transition world virtue monotonicity reasoning provides simple way test comp world previous characterization computability judgments 
second clause allows type system typecheck program producing sequence world effects producing seen subsection 
language constructs represent proofs judgments syntactic categories terms truth judgments expressions computability judgments 
curry howard isomorphism gives correspondence typing judgments annotated worlds terms expressions reside true comp represent proof true term type world written proof comp expression type world written 
analogously hypothetical judgments form correspond typing judgments typing contexts typing context set bindings typing context means variable assumes term type world world may typecheck worlds 
term typing judgment means type world satisfied world similarly expression typing judgment means type world satisfied world 
alternatively may think typing judgments indexed worlds 
terms expressions form separate sublanguages 
difference manifest operational semantics draws distinction evaluations terms involving worlds computations expressions involving transitions worlds term evaluation interact world term resides resultant value resides world 
contrast expression computation may interact type term cmp expression letcmp value cmp hyp syntax 
term cmp letcmp typing rules 
world expression resides causing transition world resultant value may reside world 
term evaluations effect free expression computations potentially effectful respect world effects 
note worlds required type system operational semantics 
worlds compile time objects run time objects definition 
worlds involved expression computations definitely serve run time objects argue abstractions worlds worlds store typing contexts stores appropriate type system 
view worlds acceptable type system reason terms expressions appear type system operational semantics type system determines static properties terms expressions operational semantics describes reduce terms expressions likewise type system determines static properties worlds respect terms expressions operational semantics describes transitions worlds 
incidentally type system designed way initial world run time system starts empty store required typechecking program 
practical problem arises implementing type system simply disregard worlds 
introduce term expression constructs 
summarizes syntax 
summarizes typing rules 
variables 
term constructs terms represent proofs truth judgments characterization truth judgments gives properties terms interpreted curry howard isomorphism 
clause gives rule variable term hyp second clause gives substitution principle terms substitution principle terms 

denote capture avoiding term substitutions substitute occurrences give definition term substitution introducing term expression constructs 
apply curry howard isomorphism truth judgments introducing implication connective true expresses true true 
gives elimination rules lambda abstraction lambda application terms reduction relation term term reduction rule corresponding proof reduction term expression constructs term similarly truth judgments interpreting characterization computability judgments terms typing judgments 
clause means term type expression type term second clause gives substitution principle expressions substitution principle expressions 
term substitution analyzes structure expression substitution analyzes structure intended ensure computed exactly order compute obtain value proceed compute bound value 
replicate places occurs result computing multiple times 
conceptually replicate places computation finishes computation ends computing 
sense expression substitution substitutes give definition expression substitution introducing expression constructs 
apply curry howard isomorphism computability judgments internalizing comp modality true expresses comp 
elimination rules computation term cmp bind expression letcmp cmp letcmp reduction relation exp expression reduction rule corresponding proof reduction letcmp cmp exp cmp letcmp cmp exp cmp denotes computation compute say cmp encapsulates computation letcmp enables sequence computations evaluates computation term 
note typing rule accurately reflect operational behavior letcmp specifically rule typechecks world typechecks computation may take place different world expression computation preceding computation sound typing rule monotonicity accessibility relation allows type system reason world effect cause transition world clarified characterization computability judgments 
computation terms bind expressions may thought monadic constructs modality forms monad 
haskell syntax monad written follows instance monad return cmp cmp letcmp letcmp definition satisfies monadic laws modulo expression reduction rule term expansion rule modality exp cmp letcmp introduce fixed point construct terms rule invalid 
example fixed point construct reduction terminates expansion cmp letcmp justified reduction expanded term immediately terminates 
modality ceases form monad call monadic language 
substitutions term expression constructs introduced define term expression substitutions 
consider term substitutions essentially textual substitutions 
term substitution term substitutions straightforward define correspond substituting proof true hypothesis hypothetical proof 
formally define term substitutions need mapping fv obtaining set free variables term expression free variable bound lambda abstractions bind expressions fv fv fv fv fv fv fv cmp fv fv letcmp fv fv comp true comp comp comp schematic view true true definition implicitly rename bound variables necessary avoid capture free variables fv cmp cmp letcmp letcmp fv definition term substitution conforms substitution principle terms proposition substitution principle terms 


proof 
simultaneous induction structure proposition implies term reductions term type preserving corollary type preservation term 

term substitution need defined cases 
expression substitution expression substitution combines typing judgments finding expression 
corresponds substituting hypothetical proof true hypothesis proof comp 
shows schematic view expression substitution expression contains term type ultimately determines type 
example letcmp type replaced expression type resultant expression type operationally computation finishes evaluating expression contains variable corresponds hypothesis true hypothetical proof comp 
substitutes results new expression type replaces way substitutes note transforms structure type type ultimately determined expression replaces analyzes structure find term ultimately determines type letcmp letcmp definition expression substitution conforms substitution principle expressions proposition substitution principle expressions 

proof 
induction structure 
proposition implies expression reductions exp type preserving corollary type preservation exp 
letcmp cmp 
world terms instructions operational semantics provides rules term evaluations expression computations term evaluations introduce term reduction identified reflexive transitive closure expression computations introduce expression reduction identified reflexive transitive closure iff iff point language construct producing world effects typing rules reduction rules require worlds 
language constructs introduced far purely logical definition explained properties judgments variables inclusion terms expressions elimination rules lambda abstractions lambda applications 
fact erase typing judgments reverts monadic language pfenning davies :10.1.1.17.1563
introduce language constructs interacting worlds presenting operational semantics 
instructions expressions producing world effects 
interface worlds provided programming environment 
example instruction new allocating new produces world effect causing change store returns 
instruction may arguments term substitution instructions arguments defined structural way proposition continues hold 
refer objects originating worlds world terms decomposed ordinary terms world terms assumed atomic values containing subterms special world term types example type ref world term type 
note world terms may contain ordinary terms world term types may contain ordinary types ref 
new syntax follows type world term type term world term expression instruction value type world term may depend world resides 
example pointer heap cell type depends store valid 
typing rules world terms may analyze worlds 
world terms atomic values typing judgments world terms require typing contexts 
contrast typing judgments instructions require typing contexts instructions may include terms arguments note instruction necessarily world term type 
example instruction dereferencing type heap cells contain values type 
instruction arguments values typechecks world empty typing context regard reducible require instruction reduction type preserving type type preservation progress requirement instructions arguments values exists world satisfying allow means world effect causes change world reading contents store world effect 
means instruction computes value causing transition world implies accessibility relation fully specified instruction reductions assumption reflexive transitive 
note additional requirements instructions guarantee monotonicity maintained 
example instruction deallocating existing violates monotonicity truth longer typechecks deallocated violates persistence computation corresponding heap cell discarded 
order maintain monotonicity require instruction reductions designed way types world terms instructions unaffected monotonicity requirement instructions implies implies argument assume implies letcmp letcmp letcmp cmp letcmp cmp letcmp cmp operational semantics uses expression substitutions expression computations 
clause corresponds monotonicity truth second clause persistence computation 
monotonicity requirement instruction reductions affect types existing terms expressions proposition monotonicity 
implies implies proof 
simultaneous induction structure expression constructs instructions explained logically expression substitution defined 
intuitively reduced expression reveal term evaluated computation 
term value known instruction reduction attempt directly reduce letcmp cmp 
sake convenience uniform notation abuse notation definition effectively prevents letcmp cmp reduced exp letcmp cmp definition allows exp applied part expression proposition continues hold 
operational semantics term reduction term expression reduction exp proof reductions may applied part term expression affecting type 
operational semantics defines term reduction relation expression reduction relation specifying strategy arranging reductions term exp consider different styles operational semantics syntax reduction relations 
instruction assume instruction reduction causes transition world arguments reduce values applying repeatedly 
shows operational semantics uses expression substitutions expression computations term evaluations choose reduction strategy uses callby name discipline 
rule shorthand applying term rules letcmp letcmp letcmp cmp letcmp cmp letcmp cmp operational semantics direct style 
term reduction reduce term value 
rule shorthand applying exp letcmp cmp case reduces letcmp cmp reducing rule perform instruction reduction shows alternative style operational semantics called direct style requires term substitutions expression computations term evaluations choose reduction strategy uses call value discipline 
rules 
letcmp cmp apply rule repeatedly reduced value rule reduces letcmp cmp variable replaced value term evaluations expression computations 
direct style extensible style expression substitutions 
new expression construct requires new reduction rules 
comparison style hinges expression substitutions requires new reduction rules augmented definition expression substitution new expression construct 
expression substitution defined new expression construct may specialize existing reduction rules 
example rules thought derived common reduction rule instructions introduced 
type safety consists properties type preservation progress 
proof type preservation uses corollaries type preservation progress requirement instructions proposition 
proof progress requires canonical forms lemma 
style operational semantics proofs proceed way 
theorem type preservation 

proof 
induction structure lemma canonical forms 
value type lambda abstraction value type computation term cmp proof 
inspection typing rules 
theorem progress 
value exists value exist proof 
induction structure expressions may produce world effects converted terms 
contrast terms lifted expressions typing rule term 
define program closed expression typechecks certain initial world initial initial 
choose initial world structure employed 
run program compute initial 
examples world effects order implement specific notion world effect specify world structure provide instructions interact worlds 
section discuss specific notions world effect 
probabilistic computations order facilitate coding sampling techniques developed simulation theory model probabilistic computation computation returns value consuming real numbers drawn independently single real number 
real number world term type real 
world source probabilistic choices represented infinite sequence real numbers drawn independently 
instruction consuming real number world 
world term type real world term instruction world ri ri real real real sampling sampling easy show instruction satisfies type preservation progress requirement 
world affect types world terms instructions monotonicity holds trivially 
world initial world 
see chapter constructs probabilistic computations serves core ptp 
sequential input output model sequential input output computation consumes infinite input character stream outputs finite output character stream os character world term type char 
instructions read reading character input stream write writing character output stream 
world term type char world term instruction read write world os os nil os char char read read char char write write char read read os os write write write os os write write easy show instructions satisfy type preservation progress requirement 
probabilistic computations world affect types world terms instructions monotonicity holds trivially 
empty output character stream nil initial world 
mutable probabilistic computations sequential input output easy model worlds affect types world terms instructions 
mutable require world terms type depends worlds 
consequently worlds designed way provide information correctly determine type 
ref world term types 
world represented collection pairs closed value annotated type may thought typed store type world distinct 
instructions new initializing fresh read reading contents world write updating world 
reading contents world world effect cause change world 
world term type ref world term instruction new read write world shows new typing rules reduction rules prove type preservation progress requirement instructions show typed instructions generate corrupt worlds corollaries 
lemma postulate world possesses structure store may typed 
lemma 
world implies implies fresh 
proof 
simultaneous induction structure interesting case implies ref rule ref 

corollary 
world world fresh proof 
world 
lemma 
lemma follows 
ref ref ref read read new ref new ref write new new new fresh new read read read new read write write write write write write write write typing rules reduction rules mutable 
lemma postulate world 
lemma 
world implies implies 
read write proof 
simultaneous induction structure interesting case corollary 
world world 
proof 
similarly proof corollary 
proposition type preservation progress requirement instructions 
arguments values exists world satisfying proof 
case analysis corollaries 
monotonicity requirement instructions directly prove proposition exploiting lemmas 
proof proposition 
accessibility relation specified instruction reductions implies equal proceed induction order maintain monotonicity world persistent deallocated type longer determined 
means explicit instruction deallocating delete allowed 
framework garbage collections allowed destroy monotonicity garbage collection transition ensure ref implies ref possible including program precisely deallocates 
practice garbage collections interfere evaluations computations safe implement 
empty store initial world 
supporting multiple notions world effect world structure realizes specific notion world effect instructions provide interface worlds support multiple notions world effect combining individual world structures letting instruction interact relevant part worlds 
example instructions world consists sub worlds infinite sequence real numbers input output streams typed store 
combines world effects language design level 
may think providing built implementation state monad states worlds 
ease combining world effects reflects fact state monads combine combining individual states 
fixed point constructs section investigate extension fixed point constructs 
consider unfolding semantics fixed point construct reduces unrolling 
consider backpatching semantics scheme 
expressions assume operational semantics direct style 
uniform treatment types choose allow fixed point constructs types 
alternative approach confine fixed point constructs lambda abstractions ml inadequate purpose recursive computations require fixed point constructs computation terms type anyway 
unfolding semantics fix term fixed point construct recursive evaluations 
typing rule reduction rule usual term fix fix fix fix fix presence term fixed point constructs truth judgment true holds vacuously fix typechecks type represents proof true 
term type represent constructive proof true may contain nonsensical proofs fix definition computability judgment comp remains defined relative truth judgment true 
conjunction computation terms cmp term fixed point constructs enable encode recursive computations build term fixed point construct type convert expression letcmp denotes recursive computation 
generalizing idea define syntactic sugar recursive computations 
introduce expression variable expression fixed point construct efix new form binding expression variables typing contexts new typing rules reduction rule follows expression efix typing context evar efix efix efix efix efix rule efix efix denotes capture avoiding substitution efix expression variable efix behaves term fixed point constructs substituting expression expression variable term ordinary variable 
simulate expression fixed point constructs define function translates efix letcmp yr fix xp cmp letcmp yv xp yv yr introduce variable xp encapsulate efix expand bind expression letcmp yv xp yv 
translation terms expressions structural sake simplicity consider world terms instructions cmp cmp fix fix letcmp letcmp proposition shows translated function typing rules evar efix sound respect original type system rules evar efix 
lemma 


proof 
simultaneous induction structure proposition 


proof 
simultaneous induction structure derivation 
interesting case efix case efix efix induction hypothesis xp weakening xp letcmp yv xp yv typing derivation xp letcmp yv xp yv lemma letcmp yr fix xp cmp letcmp yv xp yv yr typing derivation efix definition contain expression fixed point constructs rule efix 
rule evar contains free expression variables 
term expression free expression variable function returns term expression type need rules evar efix 
propositions show reduction rule efix sound complete respect operational semantics direct style section 
fact computation require rule efix 
proposition 
term expression proof 
simultaneous induction structure lemma 
proof 
induction structure derivation lemma 
exists proof 
induction structure derivation introduce equivalence relation expressions state expressions compute value 
definition 
implies vice versa 
equivalences proofs letcmp cmp letcmp cmp letcmp cmp efix efix third equivalence follows expression reduction efix letcmp yr cmp efix yr 
proposition 
rule efix proof 
induction structure derivation consider case letcmp cmp letcmp letcmp rule lemma letcmp letcmp letcmp letcmp letcmp letcmp 
letcmp proposition 
exists proof 
induction structure derivation interesting case rule applied derivation 
letcmp letcmp lemma exists letcmp letcmp 
letcmp 
efix efix efix efix efix efix 
seen definition expression fixed point constructs term fixed point constructs leak expressions give rise recursive computations 
note non terminating computations necessarily due term expression fixed point constructs mutable exploited encode recursive computations 
example expression initiates non terminating computation stores computation term dereferences letcmp cmp new cmp letcmp cmp write cmp letcmp cmp read letcmp letcmp letcmp cmp write cmp letcmp cmp read letcmp letcmp letcmp cmp letcmp cmp read letcmp letcmp cmp letcmp cmp letcmp cmp read letcmp backpatching semantics cmp int cmp letcmp cmp read letcmp int cmp letcmp cmp read letcmp int unfolding semantics backpatching semantics evaluates computes fixed point construct finishing reduction body tying recursive knot backpatching result 
term evaluations semantics equivalent unfolding semantics gives rise infinite loop backpatching semantics generates error 
investigate fixed point construct vfix expressions backpatching semantics 
efix computes fixed point values world effects interpreted expression computes fixed point values term 
reason computation usually referred value recursion 
similar constructs erk launchbury fixed point construct mfix haskell launchbury peyton jones recursive state transformer haskell 
regard fixed point constructs expressions compare directly 
syntax type system introduce recursion variable underscore term value recursion construct vfix expression term expression vfix substitution defined standard way 
simplify presentation type preservation theorem theorem separate recursion variables ordinary variables type system introducing value recursion context recursion variables value recursion context typing judgment includes value recursion context record type recursion variable term typing judgment expression typing judgment typing rules judgments induce judgments straightforward way adding judgment 
need additional rules recursion variables value recursion constructs vfix vfix monotonicity accessibility relation proposition stated new typing judgments 
proposition 
implies implies operational semantics conceptually compute vfix follows bind black hole premature attempt read results value recursion error compute obtain value occurrence return value result 
approach backpatching replacing fixed point construct fix 
problem approach may appear resultant world computing world computes world may need substitutions worlds fix defined kind world effect want avoid type preservation property difficult prove 
eliminate need substitutions worlds maintain recursion store 
associates recursion variable value recursion store reformulate operational semantics reduction judgments term reduction means recursion store reduces expression reduction means world recursion store reduces world recursion store term reduction requires update recursion store may read recursion variables 
expression reduction may update world reducing instructions recursion store reducing value recursion constructs 
reduction rules judgments induce judgments straightforward way adding judgment 
directly modeling black holes certain special values indirectly model black holes reducing vfix intermediate value recursion construct vfix presence vfix means assumed bound black hole currently reduced term attempts read results value recursion error reduction gets stuck 
typing rule vfix vfix expression vfix vfix vfix rules reducing recursion variables value recursion constructs follows vfix vfix vfix vfix vfix rules ensure premature attempt read recursion variable bound black hole results value recursion error reduction gets stuck 
rule implies value 
rule initiates computation vfix reducing vfix rule reduces body vfix rule note conversion freely applicable vfix reduction rule assumes dynamic renaming recursion variables recursion variables recursion store remain distinct 
example consider expression letcmp cmp vfix letcmp cmp vfix need rename instance typechecking rename second instance computing vfix recursion store contains recursion variable name 
result evaluation computation may contain recursion variables need incorporate recursion stores abstractions stating type preservation property 
value recursion contexts purpose essentially result typing recursion stores 
formally write exists correspondence holds 
type preservation property stated follows theorem type preservation 
suppose 

exists proof 
induction structure derivation interesting cases rules applied derivation 
consider representative cases 
case implies rule 

case vfix type type rule vfix implies vfix 

type system detect value recursion errors computation typed expression may value recursion error 
catch value recursion errors statically adopt advanced type systems value recursion 
simulating value recursion constructs section shown efix simulated fix simulate vfix fix haskell value recursion construct mfix specific monad defined terms ordinary fixed point construct fix 
example moggi sabry show state monad type constructor type states mfix defined follows mfix fix fst product type projection term fst mfix type 
type constructor essentially forms state monad may appear define vfix terms fix state monad access states worlds terms 
exploit idea simulate vfix fix idea simulate vfix instructions mutable compute vfix initialize fresh update store 
case longer term evaluation requires access store 
words defined expression 
term contt value contt evaluation context contt continuations syntax continuations terms 
far restricted world effects transitions worlds 
confines world effects expressions terms free world effects 
extend control effects immediately clear syntactic category permitted produce control effects 
hand choose confine control effects expressions terms remain free kind effect 
distinction effect free evaluations effectful computations drawn conventional sense 
hand order develop practical programming language desirable allow control effects terms 
example exceptions terms easy way handle division zero pattern match failures occurring evaluations 
time exceptions expressions useful instructions execution succeed 
hold view expressions principle syntactic category specialized world effects allow control effects terms expressions 
decision prevent developing control effects orthogonally world effects control effects realized reduction rules world effects realized world structures 
fact reason confine control effects syntactic category concept control effect relative constitutes basic reduction rules anyway 
example control effect consider continuations 
consider kinds terms expressions 
continuation terms denotes evaluation parameterized terms continuation expressions denotes computation parameterized terms 
independent notions discuss separately 
primarily interested continuations change state run time system focus operational semantics type system refer reader literature 
syntax assume value recursion constructs interact continuations expressions interesting way 
continue reduction judgments section different style 
continuations terms shows syntax continuations terms 
evaluation context term hole filled term produce term assumes call value discipline 
contt lifts evaluation context value called term continuation 
constructs capturing throwing term continuations respectively 
operational semantics uses reduction judgment form recursion store 
note term reduction judgment section terms 
rule uses term reduction term rule binds variable term continuation containing current evaluation context rule current evaluation context activate new evaluation context formulation continuations terms standard 
interesting logical perspective continuations terms change meaning true intuitionistic truth classical truth 
change meaning true mean change definition term contt contt reduction rules continuations terms 
term conte value conte expression computation context letcmp letcmp cmp vfix conte syntax continuations expressions 
expressions accordingly definition comp subject particular definition true 
words change meaning true definition comp remains valid respect new definition true previous definition expressions remains valid 
continuations expressions shows syntax continuations expressions 
computation context expression hole filled term expression 
conte lifts computation context value called expression continuation 
constructs capturing throwing expression continuations respectively 
operational semantics uses reduction judgment form note expression reduction judgment section expressions 
rule binds variable expression continuation containing current computation context rule current computation context activate new computation context rule computation context vfix marks bound black hole 
important rule require premise removed recursion variables remain distinct 
reason expression continuation captured completion computation vfix may thrown completion 
case recursion variable bound value previous computation vfix returned 
exploit property show example vfix letcmp letcmp vfix behave differently free consider expression vfix letcmp cmp free expression continuation captured may escape scope value recursion construct 
thrown bound value attempt erk launchbury call equivalence expressions left shrinking property value recursion 
letcmp cmp conte conte vfix vfix vfix reduction rules continuations expressions 
read succeeds raising value recursion error 
case expression letcmp cmp vfix computation bound black hole rule 
consequently attempt read results value recursion error 
general value recursion unsafe presence expression continuations value recursion construct may compute value containing unresolved recursion variables recursion variables bound black holes counter example rewritten 
error resulting reading unresolved recursion variable similar value recursion error result attempt read recursion variable bound black hole 
difference value recursion error results premature attempt read recursion variable eventually bound value unresolved recursion variable remains bound black hole forever 
summary moggi monadic metalanguage ml served de facto standard subsequent monadic languages 
benton biermann de paiva show type theoretic perspective ml connected lax logic curry howard isomorphism 
pfenning davies reformulate ml applying martin methodology distinguishing propositions judgments lax logic :10.1.1.17.1563
new formulation ml draws syntactic distinction values computations uses modality computations 
design security typed monadic language underlying modal type theory inspires type systems effect systems 
idea syntactic distinction explicit modality computations petersen 
idea walker harper 
language similar operational semantics type system uses accessibility relation worlds 
meaning world slightly different world language collection facts world 
extends new formulation ml pfenning davies operational semantics support concrete notions computational effect 
compared monadic languages ml strictly increase expressive power straightforward devise translation typical monadic language ml vice versa 
regard syntactic distinction may thought cosmetic change syntax monadic languages 
inspires new approach incorporating computational effects monadic languages allowing control effects terms expressions confining world effects expressions 
monadic language ml unorthodox approach mean pure functional sublanguage allowed produce control effects 
syntactic distinction leads interpretation terms expressions complete languages candidate unified framework study languages traditionally studied separately haskell corresponding terms ml corresponding expressions 
ultimately believe idea syntactic distinction conveys design principle monadic languages 
chapter probabilistic language ptp chapter presents syntax type system operational semantics ptp 
give examples demonstrate properties ptp show verify program correctly encodes target probability distribution 
propose monte carlo method means overcoming limitation ptp lack support precise reasoning probability distributions 
reader read previous chapter ptp may viewed simplified account language constructs probabilistic computations section 
source simplification world infinite sequence random numbers affect types terms expressions typing judgments ptp require worlds 
table show judgments corresponding judgments ptp judgments judgments ptp syntax ptp uses type constructors familiar programming languages logic specific keywords specialized probability distributions syntax syntax ptp cmp prob letcmp sample definition ptp chapter self contained supplemented previous chapter logical foundation 
definition ptp syntax type system ptp augments lambda calculus consisting terms separate syntactic category consisting expressions monadic syntax 
terms denote regular values expressions denote probabilistic computations 
say term evaluates value expression computes sample 
type real term fst snd fix prob expression sample value sample prob real number sampling sequence ri ri typing context syntax ptp 
hyp lam app fst fst snd snd fix fix prod prob prob real real term sample bind real sampling typing rules ptp 
shows syntax ptp 
variables 
lambda abstraction application term 
product term fst snd projection terms include terms support joint distributions 
fix fixed point construct recursive evaluations 
probability term prob encapsulates expression class value denoting probability distribution 
real number 
kinds expressions term bind expression sample sampling expression expression returns probability result evaluating sample sequences probabilistic computations evaluates probability term 
consumes random number sampling sequence infinite sequence random numbers drawn independently 
type system employs kinds typing judgments term typing judgment meaning evaluates value type typing context 
expression typing judgment meaning computes sample type typing context 
typing context set bindings shows typing rules ptp 
rule prob rule type constructor means type denotes probability distributions type rule bind elimination rule type constructor 
rule term means tpr snd snd fst fst fix fix tpl fst snd sample sample sample prob sample prob sample prob sampling operational semantics ptp 
term converts probabilistic computation involves probabilistic choice 
rule real shows real type real numbers 
sampling expression type real shown rule sampling computes real number 
operational semantics ptp draws syntactic distinction regular values probabilistic computations operational semantics needs kinds judgments term evaluation judgment meaning term evaluates value expression computation judgment meaning expression sampling sequence computes sample remaining sampling sequence conceptually consumes random numbers properties consumed sequence length directly observable 
term evaluations introduce term reduction call value discipline equally choose call name call need 
identify reflexive transitive closure expression computations introduce expression reduction re identified transitive closure reductions capture avoiding term substitutions defined standard way section 
shows reduction rules operational semantics ptp 
expression reductions may invoke term reductions reduce sample 
rules mean bind expression sample prob finish computing substituting value note term evaluation expression computation deterministic vary sampling sequences expression exhibits probabilistic behavior 
expression computation means takes sampling sequence consumes finite prefix order returns sample remaining sampling sequence proposition 
rn ei ri rn en sequence expressions en 
expression computation coincides operational description sampling function applied sampling sequence implies expression represents sampling function 
generalized notion sampling function mapping certain type 
type safety ptp consists properties type preservation progress 
proofs omitted special cases theorems satisfies type preservation monotonicity requirements instructions 
theorem type preservation 
theorem progress 
value exists sample sampling sequence exist fixed point construct expressions ptp expressions describe non recursive probabilistic computations 
probability distributions defined recursive way geometric distributions desirable able describe recursive probabilistic computations 
introduce expression variable expression fixed point construct efix new form binding expression variables typing contexts expression efix typing context new typing rules reduction rule follows evar efix efix efix efix efix rule efix efix denotes capture avoiding substitution efix expression variable expression fixed point constructs syntactic sugar simulated fixed point constructs terms 
see section details 
distinguishing terms expressions syntactic distinction terms expressions ptp optional sense grammar need distinguish expressions separate non terminal 
hand semantic distinction statically form term expression typing judgments dynamically form evaluation computation judgments appears essential clean formulation ptp 
ptp conservative extension conventional language terms constitute conventional language 
essence term evaluations deterministic need terms writing deterministic programs 
separate syntactic category expressions provide framework probabilistic computation abstracts definition terms 
example addition new term construct change definition expressions 
programming ptp syntactic distinction terms expressions aids deciding deterministic evaluations probabilistic computations focus 
section show encode various probability distributions investigate properties ptp 
examples encoding probability distribution ptp naturally concentrate method generating samples calculating probability assigned event 
probability distribution defined terms process generating samples simply translate definition 
probability distribution defined terms probability measure equivalent may derive sampling function mechanical manner 
exploit unique properties devise sampling function 
show examples encoding various probability distributions ptp 
examples demonstrate properties ptp unified representation scheme probability distributions rich expressiveness high versatility encoding probability distributions 
sampling methods examples simulation theory 
ptp programming language sampling methods developed simulation theory formally expressed fashion concise readable remaining efficient originals 
assume primitive types int bool boolean values true false arithmetic comparison operators conditional term construct 
assume standard binding recursive rec binding pattern matching convenient examples 
syntactic sugar expressions sample eif prob prob chooses sample probability distribution denoted choose keyword suggest opposite prob 
eif branches depending result evaluating type inference polymorphism ignored binding recursive rec binding may interpreted follows wildcard pattern types rec fix unified representation scheme ptp provides unified representation scheme probability distributions 
type system distinguishes different probability domains operational semantics distinguish different kinds probability distributions discrete continuous 
show example case 
encode bernoulli distribution type bool parameter follows bernoulli real prob sample prob bernoulli thought binary choice construct 
expressive specify discrete distribution finite support 
fact bernoulli suffices specify probability distributions capable simulating binary choice construct probability assigned element domain computable 
example continuous distribution encode uniform distribution real interval exploiting definition sampling expression uniform real real prob sample prob encode combination point mass distribution uniform distribution domain discrete distribution continuous distribution rich expressiveness point uniform prob sample prob demonstrate expressive power ptp number examples 
encode binomial distribution parameters exploiting probability terms binomial real int 
bernoulli rec int 
prob prob sample sample takes integer input returns binomial distribution parameters probability distribution defined terms recursive process generating samples translate definition recursive term 
example encode geometric distribution parameter discrete distribution infinite support follows geometric rec real 
bernoulli rec geometric prob sample eif sample geometric geometric recursive term geometric type int 
equivalently expression fixed point construct geometric efix real 
bernoulli prob efix geometric int 
sample eif sample prob geometric encode exponential distribution inverse cumulative distribution function sampling function known inverse transform method exponential prob sample log rejection method generates sample probability distribution repeatedly generating samples probability distributions satisfy certain termination condition implemented recursive term 
example encode gaussian distribution mean variance rejection method respect exponential distributions bernoulli bernoulli gaussian rejection real real 
rec gaussian prob sample exponential sample exponential eif sample bernoulli gaussian gaussian probability termination condition positive rejection method terminates probability 
way programmers ensure particular sampling strategy rejection method terminates probability 
encode joint distribution independent probability distributions product term 
mp denotes mq denotes term denotes joint distribution prob prob sample mp sample mq joint distribution interdependent probability distributions conditional probability represent lambda abstraction regular value returning probability distribution 
mp denotes mq denotes conditional probability term denotes joint distribution prob prob sample mp sample mq returning compute integration prob dx prob sample mp sample mq due lack semantic constraints sampling functions specify probability distributions unusual domains infinite data structures trees function spaces cyclic spaces angular values probability distributions 
example add probability distributions angular values straightforward way add angle real real prob sample sample mod modulo operation mod take account fact angle identified 
simple application implement belief network assume alarm burglary denotes probability distribution alarm goes burglary happens variables form interpreted similar way 
alarm burglary earthquake bool bool 
burglary alarm burglary earthquake alarm burglary earthquake alarm burglary earthquake john calls alarm bool 
alarm john calls alarm john calls alarm mary calls alarm bool 
alarm mary calls alarm mary calls alarm conditional probabilities alarm john calls mary calls answer query belief network describe structure 
order answer specific query implement corresponding probability distribution 
example order answer probability mary calls john calls mary calls john calls mary calls john calls essentially implements logic sampling rec mary calls john calls prob sample sample sample alarm sample john calls sample mary calls eif mary calls john calls mary calls john calls denotes probability distribution burglary happens probability distribution earthquake happens 
mean mary calls john calls gives mary calls john calls 
see calculate mary calls john calls section 
implement common operations probability distributions 
exception bayes operation second update equation bayes filter 
results probability distribution normalization constant ensuring dx zero undefined 
difficult achieve general implementation usually additional assumption achieve specialized implementation 
example function constant kp certain constant implement rejection method bayes rejection real real rec bayes prob sample sample prob eif bayes bayes see implementation section 
high versatility ptp allows high versatility encoding probability distributions probability distribution exploit unique properties encode different ways 
example exponential uses logarithm function encode exponential distribution ingenious method due von neumann requires addition subtraction operations exponential von neumann rec search real real real 
prob sample prob eif sample prob eif search sample prob search prob sample prob search recursive term gaussian rejection consumes random numbers 
encode gaussian distribution random numbers gaussian box muller real real 
prob sample prob sample prob log cos approximate gaussian distribution exploiting central limit theorem gaussian central real real 
prob sample prob sample prob sample prob examples serve evidence high versatility ptp know probability distribution better encode 
examples section just rely intuition sampling functions prove correctness encodings 
example know bernoulli encodes bernoulli distribution equivalently expression generates true probability section investigate formally prove correctness encodings 
proving correctness encodings programming ptp ask probability distribution characterizes outcomes computing expression operational semantics ptp directly answer question expression computation returns single sample certain unknown probability distribution 
need different methodology interpreting expressions directly terms probability distributions 
take simple approach appeals intuition meaning expressions 
write prob outcomes computing distributed prob 
determine prob supply infinite sequence independent random variables analyze result computing terms random variables 
prob denotes probabilistic computation generating samples prob regard prob denotation prob illustrate approach examples 
example ri means th random variable means infinite sequence random variables ri 
random variable regarded value represents real numbers 
trivial example consider prob computation proceeds follows outcome random variable 
example discrete distribution consider bernoulli expression computes follows sample prob sample prob true false 
random variable probability outcome true probability false probability bernoulli denotes bernoulli distribution parameter example continuous distribution consider uniform expression computes follows sample prob iff probability outcome lies assume 
uniform denotes uniform distribution 
proposition shows binomial denotes binomial distribution parameters write proposition 
prob ep ep proof 
induction base case 
ep 
point mass distribution centered ep inductive case 
computation ep proceeds follows sample sample sample prob xp sample sample prob bp xp xp xp bp true xp 
induction hypothesis generates sample xp consuming ri 
ri independent random variable generates sample bp independent xp 
obtain outcome probability bp true xp bp false xp equal 
ep final example show geometric rec denotes geometric distribution parameter suppose geometric prob prob 
computation proceeds follows sample prob bp eif sample geometric bp true sample prob 
case happens probability get prob second case compute expression random variables independent thought fresh sequence random variables 
computation returns samples probability distribution prob get prob prob 
solving equations get prob probability mass function geometric distribution parameter approach thought adaption methodology established simulation theory 
proof correctness sampling method simulation theory easily transcribed proof similar shown section interpreting random numbers simulation theory random variables ptp 
ptp serves programming language sampling methods developed simulation theory formally expressed formally reasoned 
possible part expression computation ptp provided infinite sequence random numbers consume equivalently generalized sampling functions mathematical basis 
alternative approach develop denotational semantics measure theory translating expressions measure theoretic structure 
denotational semantics useful answering questions expression ptp result measurable sampling function 
possible write pathological expression corresponds measurable sampling function 
expression ptp define probability distribution 
possible write pathological expression defines probability distribution 
ignore fixed point constructs ptp straightforward translate expressions directly probability measures probability measures form monad expressions follow monadic syntax sampling expression translated lebesgue measure unit interval 
write term denotation term translate expression probability measure exp follows prob term exp exp term exp term sample exp fd term function defined exp fd term integral measure term 
exp lebesgue measure unit interval 
note translation immediately reveal probability measure corresponding expression returns formula probability measure probability measure 
order obtain probability measure go essentially analysis approach 
ultimately invert sampling function represented expression event assigned probability proportional size inverse image sampling function may easy mechanical way presence various operators 
add fixed point constructs ptp expressions translated domain theoretic structure recursive equations 
specifically term fix gives rise recursion equation type measure theoretic structure denotation terms type difficult solve recursive equation domain theoretic structure recursive equation theoretical treatment 
jones suggests domain theoretic structure constructed domain theoretic model real numbers leave development denotational semantics ptp domain theory 
approximate computation ptp explored encode probability distributions ptp interpret ptp terms probability distributions 
section discuss important aspect probabilistic languages reasoning probability distributions 
expressive power probabilistic language important factor affecting practicality 
important factor support reasoning probability distributions determine properties 
words important able encode various probability distributions able determine properties means variances probabilities specific events 
unfortunately ptp support precise reasoning probability distributions 
permit precise implementation queries probability distributions 
intuitively able calculate probabilities specific events tantamount inverting sampling functions 
example calculate mary calls john calls belief network example section analyze mary calls john calls compute mean similar way previous section 
hope precise reasoning ptp choose support approximate reasoning monte carlo method 
approximately answers query probability distribution generating large number samples analyzing 
example approximate mary calls john calls equal proportion true infinite number samples mary calls john calls generating large number samples counting number true monte carlo method gives approximate answer accuracy improves number samples 
applicable kinds probability distributions particularly suitable ptp 
section monte carlo method implement expectation query 
show exploit monte carlo method implementing bayes operation 
implementations provided primitive constructs ptp 
expectation query common queries probability distributions important expectation query 
expectation function respect probability distribution mean write fdp queries may derived special cases expectation query 
example mean probability distribution real numbers expectation identity function probability event event probability distribution event 
monte carlo method states approximate fdp set samples vn vn lim fdp introduce term construct expectation exploits equation term expectation mf mp mf real mp expectation mf mp real mf mp prob ep new sampling sequence ep vi vi vi expectation mf mp vi rule exp says mf evaluates lambda abstraction denoting mp evaluates probability term denoting expectation mf mp reduces approximation fdp run time variable chosen programmers specifies number samples generate evaluate expectation mf mp run time system initializes sampling sequence generate sample vi indicated new sampling sequence 
rule exp accuracy vi controlled ptp solely programmers 
ptp responsible choosing value analyzing ep guarantee certain level accuracy estimating fdp programmers decide suitable value achieve desired level accuracy expression ep encoding 
programmers allowed pick particular value expectation query value expectation queries 
pdo consider weakness ptp ep chosen programmers affects accuracy vi 
ptp provides concrete guidance choosing value rule exp programmers empirically determine suitable value largest value finishes expectation exp exp query time constraint 
large value results faithful approximation samples vi smaller difference vi true expectation fdp ideally time evaluate expectation mf mp directly proportional practice computation expression ep may take different time especially ep expresses recursive computation 
programmers try different values find largest finishes expectation query time constraint 
problem definition expectation term construct reduction probabilistic sampling sequence rule exp violates principle term evaluation deterministic term may evaluate different values contains expectation 
order violate principle assume sampling sequence rule exp uniquely determined expression ep calculate mary calls john calls bayes operation expectation bool mary calls john calls previous implementation bayes operation assumes function constant kp certain constant difficult find optimal value maximum value take conservative estimate monte carlo method conjunction importance sampling allows dispense approximating set samples set weighted samples 
introduce term construct bayes bayes operation expression construct importance importance sampling term bayes mp mq expression importance vi wi spirit data abstraction importance represents internal data structure directly available programmers 
mp real mq bayes mp mq bayes vi wi real importance vi wi imp mp mq prob eq new sampling sequence eq vi vi wi bayes mp mq prob importance vi wi wi wi wi importance vi wi vk imp bayes rule bayes uses sampling sequences initialized run time system approximates samples vn run time variable rule exp applies sample vi calculates weight wi creates set vi wi weighted samples argument importance 
rule imp implements importance sampling random number probabilistically select sample vk account weights associated samples 
expectation decide define bayes term construct assumption sampling sequence rule bayes uniquely determined expression eq 
expectation bayes expression constructs reduction involves sampling sequences expectation bayes defined expression constructs assumption sampling sequence rules exp bayes unnecessary 
choose define expectation bayes term constructs pragmatic reasons 
consider probability distribution defined terms probability distributions du similar example section obtained bayes operation prob du encoded ptp bayes expectation mf mq mp mp mq probability terms denoting respectively mf lambda abstraction denoting expectation expression construct difficult encode expression expectation mf mq converted term 
essence mathematically expectation function respect probability distribution result bayes operation unique exist turn implies expectation bayes defined expression constructs write code involving expectations bayes operations manner reason mathematically 
actual implementation ptp chapter enforce assumption sampling sequence rules exp bayes unrealistic practice required semantic clarity ptp 
strictly speaking term evaluations necessarily deterministic clear separation terms expressions regard 
terms protected computational effects input output mutable term evaluations result unique values anyway non deterministic term evaluations regarded new problem 
expressions best interpreted syntactic category dedicated probabilistic computations mathematical sense strict adherence implementation level semantic distinction terms expressions defining expectation bayes expression constructs cost code readability apparent benefit 
cost generating random numbers essence monte carlo method trade accuracy cost gives approximate answers relieves programmers cost exact computation impossible certain problems 
ptp relies monte carlo method reason probability distributions important programmers able determine cost monte carlo method 
decide define cost monte carlo method proportional number random numbers consumed 
decision assumption random number generation account significant portion total computation time 
cost random number generation negligible number random numbers consumed little importance 
implementation ptp random number generation examples section accounts average total computation time 
table shows execution times seconds percentages random number generation generating samples pentium iii mhz mbytes memory test case execution time random number generation uniform binomial geometric efix gaussian rejection exponential von neumann gaussian box muller gaussian central mary calls john calls ptp programmers responsibility reason cost generating random numbers expression computation judgment length consumed sequence observable 
analysis similar section estimate cost obtaining sample terms number random numbers consumed 
case geometric rec example expected number random numbers consumed calculated solving equation accounts random number generated bernoulli distribution probability attempt generate sample probability distribution 
technique applies equally rejection method gaussian rejection 
summary conceptually simple idea sampling functions specifying probability distributions new history probabilistic languages 
ptp example probabilistic language indirectly expresses sampling functions monadic syntax 
choose different syntax expressing sampling functions 
example author extends lambda calculus sampling construct directly encodes sampling functions formal argument denotes body sampling function 
computation proceeds generating random number substituting compared ptp resultant calculus facilitates encoding probability distribution reduces code readability program fragment denotes probability distribution separation regular values probabilistic computations 
idea monadic syntax ptp inspired stochastic lambda calculus ramsey pfeffer denotational semantics monad probability measures probability monad :10.1.1.16.5350
implementing query generating samples probability distributions note probability monad interpreted terms sampling functions denotationally operationally 
designing ptp take opposite approach monadic syntax probabilistic computations relate directly sampling functions interpret terms probability distributions 
operational semantics ptp different styles 
example expression computations judgment form rn meaning expression computes sample consuming finite sequence random numbers rn 
new judgment better reflects actual implementation expression computation stick formulation chapter emphasize logical foundation ptp 
chapter implementation chapter describes implementation ptp 
implementing ptp complete programming language choose embed existing functional language pragmatic reasons 
conceptual basis probabilistic computations ptp simple easy simulate language constructs ptp modification run time system 
second intend ptp real applications robotics wish exploit advanced features module system interface foreign languages graphics library 
building complete compiler ptp justified extending existing functional language sufficient examining practicality ptp 
emphasize embedding ptp existing functional language different adding library host language 
example syntax host language extended syntax ptp case library added 
type system ptp faithfully reflected host language programmers benefit type system ptp programming host language environment 
library partially reflect type system ptp type abstraction completely different syntax library 
implementation objective caml host language 
formulate sound complete translation ptp simple call value language thought sublanguage objective caml 
extend syntax objective caml preprocessor objective caml incorporate syntax ptp 
extended syntax translated back original syntax 
representation sampling functions probability term denotes probability distribution specified sampling function implementation ptp translates probability terms representations sampling functions 
translate probability term type value type type constructor prob conceptually defined follows type real real real type real numbers real type infinite sequences random numbers 
simplify definition prob steps 
implement real numbers type real floating point numbers type float objective caml 
second dispense infinite sequences random numbers global random number generator fresh random numbers needed compute sampling expressions 
definition type unit type real term prob expression sample efix value sample prob floating point number sampling sequence ri ri typing context fragment ptp source language 
unit type inhabited unit value 
means finite precision representing sampling functions 
overhead exact real arithmetic justified applications robotics samples approximations programmers may demand higher precision supported type float 
contrived example consider binary distribution assigning probability true probability false prob sample prob uses bit mantissa part computes probability term denotes wrong probability distribution point mass distribution centered false bits mantissa part denotes intended probability distribution 
finite precision supported implementation ptp bits floating point numbers objective caml adequate typical applications noted sampling functions demanding higher precision errors induced floating point numbers problematic applications 
type datatype 
definition exposed ptp values type accessed member functions 
provide member functions prb app 
prb builds value type function type unit defined identity function 
app generates sample value type applies argument unit value 
interface implementation datatype prob follows type type unit unit fun unit fun 
translating probability terms app translating bind expressions 
conjunction type constructor prob data type provide sound complete translation ptp shown section 
translation ptp call value language translate fragment ptp shown call value language shown 
source language excludes product types straightforward translate target language extended product types 
directly translate expression fixed point constructs simulating type float unit expression fun prb app random fix value fun prb function fun floating point number sampling sequence ri ri typing context call value language target language 
hyp fun lam app unit prb prb app papp float float unit unit random float random fix fix typing rules target language 
fixed point constructs terms 
target language supports floating point numbers source language restricted floating point numbers 
target language call value language extended datatype prob 
single syntactic category consisting expressions distinguish effect free evaluations effectful computations 
ptp expression denotes probabilistic computation say expression computes value 
note fixed point constructs fix allow recursive expressions function types 
type system target language shown 
employs typing judgment meaning expression type typing context 
rules prb papp conform interface datatype prob 
operational semantics target language shown 
employs expression reduction judgment meaning computation sampling sequence reduces computation sampling sequence capture avoiding substitution defined standard way 
rule defined implementation datatype prob 
rule shows sampling expressions ptp consumes random number sampling sequence 
write reflexive transitive closure shows translation source language target language 
overload function types typing contexts terms expressions 
terms expressions type source language translated expressions type target language 
prob suspends computation building function fun unit 
just prob suspends computation target language allows recursive expressions function types expression variable type translated xx xx special variable type unit annotated wildcard pattern variables types 
fun app app random fun fun prb prb fix fix efix operational semantics target language 
prob real float xx unit fun prob prb fun unit 
sample fun app random xx efix fix xx unit fun unit 
translation source language 
target language allowed recursive expressions type efix translated xx xx respectively 
propositions show translation faithful type system source language 
proposition proves soundness translation typed term expression source language translated typed expression target language 
proposition proves completeness translation typed term expression source language translated type expression target language 
proposition 
proof 
simultaneous induction structure proposition 
objective caml syntax efix rewritten rec xx xx 
exists exists proof 
simultaneous induction structure clause implies interesting case case assumption xx xx xx unit xx special variable annotated expression variable xx translation faithful operational semantics source language 
show translation sound term reduction source language translated corresponding expression reduction consumes random number proposition expression reduction source language translated corresponding sequence expression reductions consumes sequence random numbers proposition 
note proposition directly reduce reduces expression eventually reduces consuming random numbers 
lemma 
proof 
simultaneous induction structure lemma 
efix fix xx unit fun unit 
xx efix fix xx unit fun unit 
xx proof 
simultaneous induction structure corollary 
efix fix xx unit fun unit 
xx proposition 
sampling sequence 
proof 
induction structure derivation case case induction hypothesis bye induction hypothesis fun fun fun bye fun case fun fun bye lemma proposition 
exists proof 
induction structure derivation consider interesting cases 
case sample prob sample prob induction hypothesis sample prob fun app prb fun unit 
fun app prb fun unit 
fun fun unit 
fun bye fun sample prob fun app prb fun unit 
fun app prb fun unit 
fun ande fun case efix efix efix efix fix xx unit fun unit 
fix xx unit fun unit 
fun unit 
fix xx unit fun unit 
xx fix xx unit fun unit 
xx bye efix fix xx unit fun unit 
xx corollary completeness translation states valid term expression reduction source language translated corresponding sequence expression reductions target language 
words term expression reduced source language translated expression reduction eventually gets stuck 
simplify presentation introduce judgments express term expression reduces 
means exists term reduces 
means exists expression reduces 
means exists expression reduces target language 
corollary proves completeness translation terms proposition proves completeness translation expressions 
proposition 
proof 
induction structure need consider case 
cases structure corresponding rules ande 
case rule uses lemma 
corollary 
sampling sequence 
proposition 
exists 
proof 
induction structure consider cases sample remaining cases trivial 
case corollary case sample fun app prob corollary rule apply rule apply prb prob exists induction hypothesis 
fun unit 
fun fun prob hold rule target language thought sublanguage objective caml datatype prob built random implemented float 
objective caml serves host language ptp need extend syntax objective caml incorporate syntax ptp 
extended syntax translated back original syntax objective caml function section gives definition extended syntax 
extended syntax conservatively extend syntax objective caml assumed specified non terminal term corresponding terms ptp new non terminal expr corresponding expressions ptp patt non terminal patterns id identifiers term prob expr probability term expr term term expr 
sample patt term expr bind expr 
uniform sampling expr 
efix id expr expr 
fixed id expr 
variable term eif term expr expr eif strict random implemented 
random float 
term explicitly marks term instance expression 
id refers expression variable id expression constructs resemble counterparts chapter 
example encode bernoulli distribution follows bernoulli fun prob sample prob uniform true false geometric distribution encoded expression fixed point construct follows geometric fun bernoulli bernoulli prob efix geo sample bernoulli eif sample prob geo examples section encoded similar way 
approximate computation ptp reasoning probability distribution accomplished generating multiple samples analyzing 
implementation ptp provides functions generating independent samples probability distribution type set type val prob set prob set val prob prob float set datatype sets samples type datatype sets weighted samples type sample assigned weight may thought float set 
weights normalized sum 
prob set generates samples evaluating 
prob generates samples assigns sample weight programmers specify number samples generated prob set prob controlling accuracy approximating probability distributions 
implementation ptp provides functions applying monte carlo method val set monte carlo set float float val monte carlo float float ws prob truncate ws weight weight set monte carlo returns sample prob truncate 
sf monte carlo ws returns ws sample functions convert sets weighted sets back probability distributions val set prob resample set prob val prob resample prob set prob resample returns uniform distribution prob resample ws returns prob performs importance sampling select samples 
expectation query section bayes operation section implemented composing functions set monte carlo prob set bayes fp prob resample prob implementation ptp provides function approximating support probability distribution 
support arbitrary probability distribution calculated accurately represent uniform distribution val prob truncate prob prob truncate ws returns uniform distribution samples highest weights parameter specifying number samples generated set 
illustrates prob truncate works 
ws samples prob truncate invoked parameter set 
samples lowest weights perish surviving samples assigned weight 
prob truncate useful particularly want extract small number samples high weights probability distribution 
approximation uniform distribution support prob truncate prob fun fun constant objective caml function returning 
vertical computations expression vn vn horizontal vertical computations 
simultaneous computation multiple samples horizontal computation vn implementation ptp uses simple strategy generate multiple samples probability distribution compute expression repeatedly 
alternative strategy perform single parallel computation simulates multiple independent computations 
distinguish kinds computations refer strategy vertical computations strategy horizontal computation shown 
horizontal computation potentially faster equivalent number vertical computations 
example horizontal computation sample avoids overhead evaluating term advantage horizontal computation pronounced takes long time evaluate 
cost associated language construct remains constant horizontal computation 
example horizontal computation sample performs substitution vertical computations perform substitutions examine potential benefit horizontal computations implement translator ptp horizontal computations 
conceptually expression computes ordered set samples way sample corresponds result independent vertical computation expression 
may think translator implementing operational semantics judgment vn means vi translator implemented similar way operational semantics vertical computations syntax objective caml extended terms expressions extended syntax translated back objective caml 
definition type constructor prob complex conditional constructs eif 
motivate definition consider expression sample prob sample prob eif vertical computation reduces expression needs keep reduced expression 
horizontal computation may keep multiple samples generated variable example ordered set generated variable horizontal computation reduces smaller horizontal computations bound bound 
note may compress ordered set variable bound may correlated variable led define type constructor prob bit vectors ordered sets type type type prob type bit vectors fixed size 
datatype ordered sets element type ordered set element type may contain ordinary values type null values example 
ordinary values correspond values null values values bit vectors 
prob datatype probability distributions type expressions type defined type function takes bit vector performs horizontal computation values bit vector returns resultant ordered set 
variables bind expressions bound ordered sets distinguish terms manipulating ordinary values terms manipulating ordered sets 
new syntax augmenting extended syntax section introduces non terminal terms manipulating ordered sets definition non terminal expr uses place term term lam patt lambda abstraction app application term pif cond 
term construct id variable const term constants cmp 
built constants new syntax bernoulli distribution geometric distribution encoded follows bernoulli fun prob sample prob uniform pif cmp 
const geometric fun bernoulli bernoulli prob prob efix geo sample bernoulli eif const sample prob geo const compared examples section code terms expressions manipulate ordered sets ordinary values 
experimental results test case vertical horizontal overhead bernoulli uniform binomial geometric efix gaussian rejection exponential von neumann gaussian box muller gaussian central mary calls john calls execution times seconds generating total samples 
compare execution times generating number samples vertical horizontal computations 
type uses bit integers type int objective caml means single horizontal computation performs independent vertical computations datatype uses arrays elements type amd athlon xp ghz mb memory experiments 
shows execution times various test cases chapter 
test cases horizontal computations slower vertical computations indicated overhead relative vertical computations 
overhead horizontal computations especially high test cases involving conditional constructs binomial geometric efix gaussian rejection exponential von neumann mary calls john calls 
high overhead attributed fact horizontal computation allocates array size expression regardless number ordinary values 
example horizontal computation simulating just single vertical computation encountering conditional constructs computation expression requires array size 
experimental results show overhead maintaining ordered sets handling conditional constructs exceeds gain simulating multiple vertical computations single horizontal computation 
implementation just translator rely support compiler 
order fully realize potential horizontal computations necessary integrate implementation compiler run time system 
speculation horizontal computations twice faster vertical computations random number generation costs vertical horizontal computations accounts half total computation time overhead random number generation horizontal computations twice faster vertical computations 
summary ptp implemented indirectly translation objective caml type system operational semantics faithfully mirrored datatype 
existing features objective caml available programming ptp may think implementation ptp conservative extension objective caml 
translation easily generalized monadic language complementing established result call value language translated monadic language see 
translator ptp protect terms computational effects available objective caml input output mutable direct uses random float 
example term bind expression sample supposed produce world effect translator way verify evaluation effect free 
translator ptp relies programmers ensure term denotes regular value 
linguistic framework ptp reformulation moggi monadic metalanguage ml see chapter haskell choice host language embedding ptp 
embed ptp haskell define haskell monad say prob probabilistic choices translate expression type program fragment type prob ignoring keyword prob probability terms 
alternatively exploit global random number generator maintained io monad translate ptp haskell 
choice objective caml due personal preference 
directly implement ptp extending compiler run time system objective caml 
immediate benefit type error messages informative type errors detected level ptp 
implementation detects type errors translated code source code programmers analyze type error messages locate type errors source code 
execution speed conjecture gain negligible overhead incurred datatype prob invoke tiny functions member functions invoked identity function function applying argument unit value 
chapter applications chapter presents applications ptp robotics robot localization people tracking robotic mapping popular topics robotics 
different goal applications share common characteristic state robot estimated sensor readings definition state differs case 
key element applications uncertainty sensor readings due limitations sensors noise environment 
problem estimating state robot interesting challenging sensor readings accurate state robot accurately traced simple non probabilistic analysis sensor readings 
order cope uncertainty sensor readings estimate state robot probability distributions 
computational framework bayes filters 
case formulate update equations level probability distributions translate ptp 
implementations tested data collected real robots 
sensor readings action measurement update state robot kinds sensor readings action measurement 
bayes filter action induces state change measurement gives information state action represented odometer reading returns pose position orientation robot relative initial pose 
tuple 
measurement consists range readings return distances objects visible certain angles 
array dn di denotes distance robot closest object visible certain angle 
shows typical example measurement 
displays range readings produced laser range finder covering degrees 
robot shown center occluded regions colored grey 
range finders prone errors mechanical nature 
odometer usually tends drift direction time 
accumulated error manifest especially robot closes loop circular route 
range finders occasionally fail recognize obstacles report maximum distance measurable 
order correct errors probabilistic approach representing state robot probability distribution 
probabilistic approach action increases set possible states robot induces state change probabilistically 
contrast measurement decreases set possible states robot gives negative information states positive information states 
demonstrate probabilistically update state robot different applications 
range readings produced laser range finder 
robot faces person right visible shadows legs 
robot localization robot localization problem estimating pose robot map environment available 
initial pose problem pose tracking keeps track robot pose compensating errors sensor readings 
initial pose problem global localization begins multiple hypotheses robot pose involved pose tracking 
consider robot localization assumption called markov assumption past independent current pose known equivalently environment static 
assumption allows bayes filter estimating robot pose 
specifically state bayes filter robot pose estimate probability distribution bel threedimensional real space 
compute bel update equations shown section bel bel ds bel bel normalizing constant ensuring bel ds 
interpretation probability robot moves pose action pose called action model 
probability measurement taken pose called perception model 
action pose new pose generated action model adding noise applying implementation assumes constant translational rotational velocities action taken pose assumes errors translational samples action model 
rotational velocities obey gaussian distributions 
shows samples new pose curved trajectory 
measurement pose compute unknown constant map determines unique accurate measurement ms pose squared euclidean distance ms assumed proportional 
figures illustrate compute 
shows points map correspond measurement set true pose robot case unique measurement ms pose coincides recall measurement consists points map range readings 
point projected contour map assigned high likelihood indicated dark color 
shows points map correspond measurement set hypothetical pose robot unique measurement ms pose represented points crosses 
measurement taken hypothetical pose point correctly aligned contour map 
point assigned relatively low likelihood indicated grey color degree darkness indicates likelihood 
compute product individual likelihoods 
implementation simplifies computation approximating ms points contour map closest points corresponding measurement shows approximate ms points crosses 
simplification allows precompute likelihood point map closest point contour map fixed 
implementation uses grid map centimeter resolution generates likelihood map stores likelihood cell map see figures grid map likelihood map 
ma denotes conditional probability mp returns function implement update equations follows prob sample bel sample ma bayes mp bel pose tracking global localization achieved specifying appropriate initial probability distribution robot pose 
pose tracking point mass distribution gaussian distribution implementation filters outlier range readings computing 
points map correspond measurements set true pose robot 
points map correspond measurements set hypothetical pose robot 
global localization uniform distribution open space map 
experimental results test robot localizer nomad xr mobile robot wean hall carnegie mellon university 
robot equipped laser range finders degree cover degrees 
robot localizer uses fifth range reading measurement consists batch range readings 
carmen controlling robot collecting sensor readings 
robot localizer runs pentium iii mhz mbytes memory 
test robot localizer global localization 
initial probability distribution robot pose uniform distribution open space map approximated samples 
batch range readings processed update equation 
resultant probability distribution approximated samples replaced support approximated samples 
number samples chosen empirically samples prevent probability distribution converging correct pose 
shows probability distribution robot pose processing batch range readings pluses represent samples generated probability distribution 
robot starts right character relatively samples true position robot 
shows progress real time robot localization run continues probability distribution 
pictures show robot localizer performing global localization 
picture shows robot localizer started pose tracking probability distribution robot approximating ms measurement pose pose converged single hypothesis 
test robot localizer runs takes different path 
test experiment succeeds localize robot runs fails runs 
result considered statistically significant 
comparison carmen robot localizer uses particle filters written succeeds runs fails runs condition samples initialization samples localization range readings measurement 
note sequence sensor readings guarantee result probabilistic nature robot localizer 
worst scenario example initial probability distribution robot pose may samples true pose case robot localizer recover errors 
difficult precisely quantify performance robot localizer goal convince implementation ptp reasonably acceptable totally fake 
people tracking people tracking extension robot localization estimates robot pose positions people unmapped objects 
robot localization robot takes action change pose 
robot localization robot categorizes sensor readings measurement deciding correspond objects map people 
sensor readings correspond objects map update robot pose rest sensor readings update positions people 
simple approach maintain probability distribution bel robot pose positions people 
works pose tracking approach general solution global localization 
reason sensor readings people correctly interpreted correct hypothesis robot pose global localization may incorrect hypotheses lead incorrect interpretation sensor readings 
example objects upper right region interpreted person correct hypothesis robot pose 
means global localization exists dependence robot pose positions people captured bel 
maintain probability distribution bel ps robot pose probability distribution ps positions people conditioned robot pose ps captures dependence implementation assumes people move independently represents ps set independent probability distributions keeps track position individual person 
grid map likelihood map 
robot pose positions people 
bel ps thought probability distribution probability distributions 
robot localization update bel ps bayes filter 
difference robot localization state pair ps action model takes input action measurement update equations obtained replacing ps update equations 
action model ps ps generates ps ps utilizing action measurement generate ps equation 
write prob equation ps 
second prob equation indicates generate ps ps utilizing action measurement exactly situation bayes filter 
inner bayes filter update equations 
write prob equation simplify prob equation prob depend write 
shows implementation people tracking ptp 
denote conditional probabilities respectively 
returns function constant 
fixed computing consider range readings correspond people 
implementing update equation fact ps expectation function respect ps ps ps implementation simplifies models update equations 
ps robot localization 
ignore interaction robot people generating new poses robot 
similarly probability distribution robot pose processing batch range readings 
assumption positions people affected robot pose obtained adding random noise simplify ps update equation computed way robot localization equation exploited implementation 
experimental results test people tracker robot machine robot localization 
people tracker uses implementation global localization succeeds localize robot starts pose tracking maintains probability distribution bel longer dependence robot pose positions people 
robot localizer intend quantitatively measure success rate people tracking focus ensuring implementation ptp completely useless 
shows progress real time people tracking run uses sequence sensor readings 
picture taken processing batch range readings pluses represent robot poses crosses represent positions people 
second picture shows people tracker performing global localization 
picture shows people tracker started pose tracking position person sight indicated grey dot 
shows range readings third picture taken right picture shows magnified view area robot 
note person may occluded person objects map grey dots reflect movement people instantly 
refined action model people estimating position velocity person alleviate problem 
robotic mapping robotic mapping problem building map spatial model environment sensor readings 
measurements sequence inaccurate local snapshots environment robot simultaneously localizes explores environment corrects aligns local snapshots construct global map 
reason robotic mapping referred simultaneous localization mapping slam 
probabilistic approach formulate robotic mapping problem bayes filter maintains probability distribution bel robot pose map action measurement update bel follows bel bel bel bel assume action independent map change environment simplify update equation follows bel bel ds action model robot localization 
implement new update equation follows prob sample sample ma update equation implemented bayes operation 
unfortunately space maps huge dimension impossible maintain bel simplifying representation 
usually additional assumptions maps derive specific representation 
example assuming map consists set landmarks locations estimated gaussian distributions kalman filter general bayes filter 
measurements local snapshots environment assumed accurate relative robot poses represent map sequence robot poses measurements taken 
exploit expectation maximization perform hill climbing space maps find map 
approach maintain probability distribution maps keeps map iteration 
assume environment consists unknown number stationary landmarks 
goal estimate positions landmarks robot pose 
key observation may think landmarks people move empty environment 
means problem special case people tracking equations 
subscript landmark people sake clarity 
people tracking maintain probability distribution bel ps robot pose probability distribution ps positions landmarks conditioned robot pose landmarks stationary non zero skip update equation implementing update equation 
equation uses test likelihood new robot pose respect old positions landmarks fastslam ps prob ps prob prob prob ps prob ps prob prob prob prob ps prob prob ps ps implement equation bayes operation 
shows implementation robotic mapping ptp 
compared implementation people tracking omits update equation incorporates equation 
denote conditional probabilities respectively people tracking 
landmarks stationary longer need approximate bel ps single sample robot pose associated map update equation unnecessary 
experimental results test mapper data set collected outdoor vehicle victoria park sydney 
mapper runs machine robot localization people tracking pentium iii mhz mbytes memory 
data set collected vehicle moves approximately meters odometry readings seconds 
vehicle driving uneven terrain raw odometry readings noisy reflect true path vehicle particular vehicle follows loop 
shows raw odometry readings data set 
true positions vehicle measured gps sensor represented crosses available part entire traverse exploited mapper 
note odometry readings eventually diverge true path vehicle 
shows result robotic mapping experiment approximate bel ps single sample samples expectation query bayes operation 
circles represent landmark positions mean probability distributions 
mapper successfully closes loop building map landmarks path 
experiment takes seconds longer takes collect data set seconds 
summary ptp probabilistic language allows programmers concentrate formulate probabilistic computations level probability distributions regardless kind probability distributions involved 
applications robotics substantiate practicality ptp illustrating directly translate probabilistic computation code providing experimental results real robots 
finding benefit implementing probabilistic computations ptp improved readability conciseness code outweigh disadvantage speed 
example robot localizer lines long lines objective caml ptp code probabilistic computations lines code interfacing carmen carmen robot localizer uses particle filters written lines long 
robot localizer uses translator ptp lines long lines code lines objective caml code 
comparison conclusive piece code carmen contributes robot localization 
reduction code size attributed objective caml host language 
comparison taken indicative reduction code size due ptp 
speed loss significant 
example carmen robot localizer processes sensor readings robot localizer processes average sensor readings shows comparable accuracy 
hand ptp allow programmers exploit particular representation scheme probability distributions inevitable achieving high scalability applications 
robotic mapping problem example may choose approximate position landmark gaussian distribution 
cost representing gaussian distribution relatively low approximation possible build highly scalable mapper 
example montemerlo presents fastslam mapper handles maps landmarks 
problem ptp useful quickly building prototype implementation test correctness probabilistic computation 
progress real time robot localization run 
taken seconds seconds seconds processing batch sensor readings 
bel ps ps ps bel ps ps bel ps ps bel ps bel ps ps ps ps prob ps prob ps ps ps prob ps ps ps prob ps ps ps prob ps ps equations people tracking 
bayes filter computing bel ps 
decomposing action model 
inner bayes filter computing ps 
prob sample ps bel sample ps ps prob sample ps sample ps bayes ps ps bayes ps expectation ps bel implementation people tracking ptp 
numbers right hand side show corresponding equations 
progress real time people tracking run 
taken seconds seconds seconds processing batch sensor readings 
range readings area robot people tracking run 
prob sample ps bel sample bayes expectation ps ps bayes ps ps bayes ps expectation ps bel implementation robotic mapping ptp 
raw odometry readings robotic mapping experiment 
result robotic mapping experiment 
chapter probabilistic language ptp mathematical basis sampling functions 
ptp supports kinds probability distributions discrete distributions continuous distributions belonging group drawing syntactic semantic distinction 
developed linguistic framework ptp demonstrated ptp applications robotics 
best knowledge ptp probabilistic language formal semantics applied real problems involving continuous distributions 
probabilistic languages capable simulating continuous distributions combining infinite number discrete distributions require special treatment lazy evaluation strategy limiting process 
ptp support precise reasoning probability distributions 
note inherent limitation ptp due sampling functions mathematical basis necessary feature ptp precise reasoning probability distributions impossible general 
words ptp supported precise reasoning support smaller number probability distributions operations 
utility probabilistic language depends problem applied 
ptp choice problems kinds probability distributions precise reasoning unnecessary 
robotics example kinds probability distributions probability distributions similar point uniform section modeling laser range finders precise reasoning unnecessary sensor readings inaccurate rate 
hand ptp may best choice problems involving discrete distributions rich expressiveness fully exploited approximate reasoning may weak discrete distributions 
operational semantics ptp suffices practical purposes denotational semantics argue ptp probabilistic language 
may answer important questions ptp exactly expressive power ptp 
encode probability distribution ptp 
kinds probability distributions impossible encode ptp 
challenge presence fixed point constructs measure theory come rescue recursive equations 
domain theoretic structure probability distributions constructed properly handle recursive equations 
jones suggests structure constructed domain theoretic model real numbers 
development ptp effort marry possible ways seemingly unrelated disciplines programming language theory robotics 
programming language theory contributes new linguistic framework series probabilistic languages 
robotics sets precedent high level formulation problem discarded comes implementation 
remains seen ways disciplines married 
bibliography experimental data 
www usyd edu au homepages academic dataset htm 
australian centre field robotics university sydney 
objective caml 
caml inria fr 
abelson dybvig haynes iv friedman kohlbecker steele jr halstead sussman brooks hanson pitman wand 
revised report algorithmic language scheme 
higher order symbolic computation aug 
blelloch harper 
adaptive functional programming 
proceedings th acm sigplan sigact symposium principles programming languages pages 
acm press 
blelloch harper 
selective memoization 
proceedings th acm sigplan sigact symposium principles programming languages pages 
acm press 
ariola sabry 
correctness monadic state imperative call need calculus 
proceedings th acm sigplan sigact symposium principles programming languages pages new york ny 
benton bierman de paiva 
computational types logical perspective 
journal functional programming 
bierman de paiva 
intuitionistic necessity revisited 
technical report csr university birmingham school computer science june 
boudol 
recursive record semantics objects revisited 
lecture notes computer science 
fox schrage 
guide simulation 
springer verlag nd edition 
charniak 
statistical language learning 
mit press cambridge massachusetts 
chellas 
modal logic 
cambridge university press 
crary pfenning 
monadic analysis information flow security mutable state 
technical report cmu cs school computer science carnegie mellon university 
dempster laird rubin 
maximum likelihood incomplete data em algorithm 
journal royal statistical society series 
doucet de freitas gordon 
sequential monte carlo methods practice 
springer verlag new york 
dreyer 
type system founded recursion 
proceedings st acm sigplan sigact symposium principles programming languages 
acm press 
edalat potts 
new representation exact real numbers 
brookes mislove editors electronic notes theoretical computer science volume 
elsevier science publishers 
erk launchbury 
recursive monadic bindings 
proceedings fifth acm sigplan international conference functional programming pages 
acm press 
mendler 
propositional lax logic 
information computation 
fox burgard thrun 
markov localization mobile robots dynamic environments 
journal artificial intelligence research 
gill 
computational complexity probabilistic turing machines 
siam journal computing 

categorical approach probability theory 
editor categorical aspects topology analysis volume lecture notes mathematics pages 
springer verlag 
griffin 
formulae type notion control 
proceedings th acm sigplan sigact symposium principles programming languages pages 
acm press 
gupta jagadeesan panangaden 
stochastic processes concurrent constraint programs 
proceedings th acm sigplan sigact symposium principles programming languages pages 
acm press 
harper duba macqueen 
typing class continuations ml 
journal functional programming october 
henrion 
propagation uncertainty bayesian networks probabilistic logic sampling 
lemmer kanal editors uncertainty artificial intelligence pages 
elsevier north holland 
howard 
formulas types notion construction 
seldin hindley editors curry essays combinatory logic lambda calculus formalism pages 
academic press ny 

stochastic processes filtering theory 
academic press new york 
jelinek 
statistical methods speech recognition language speech communication 
mit press boston ma 
jones 
probabilistic non determinism 
phd thesis department computer science university edinburgh 
jones duponcheel 
composing monads 
technical report yaleu dcs rr department computer science yale university december 
king wadler 
combining monads 
launchbury sansom editors glasgow functional programming workshop glasgow 
springer verlag 
koller mcallester pfeffer 
effective bayesian inference stochastic programs 
proceedings th national conference artificial intelligence th innovative applications artificial intelligence conference aaai iaai pages 
aaai press 
kozen 
semantics probabilistic programs 
journal computer system sciences 
kripke 
semantic analysis modal logic 
normal propositional calculi 
zeitschrift mathematische logik und grundlagen der mathematik 
launchbury peyton jones 
lazy functional state threads 
proceedings acm sigplan conference programming language design implementation pages 
acm press 
launchbury peyton jones 
state haskell 
lisp symbolic computation dec 
lu milios 
globally consistent range scan alignment environment mapping 
autonomous robots 
th ghani 
composing monads coproducts 
proceedings seventh acm sigplan international conference functional programming pages 
acm press 
mackay 
monte carlo methods 
jordan editor learning graphical models nato science series pages 
kluwer academic press 
walker harper 
effective theory type refinements 
proceedings eighth acm sigplan international conference functional programming pages 
acm press 
martin meanings logical constants justifications logical laws 
nordic journal philosophical logic 
text lectures originally distributed 
mogensen 
roll language specifying die rolls 
dahl wadler editors th international symposium practical aspects declarative languages volume lncs pages 
springer 
moggi 
computational lambda calculus monads 
proceedings fourth annual symposium logic computer science pages 
ieee computer society press 
moggi 
notions computation monads 
information computation 
moggi sabry 
monadic encapsulation effects revised approach extended version 
journal functional programming nov 
moggi sabry 
monadic semantics value recursion 
theoretical informatics applications 
montemerlo 
fastslam factored solution simultaneous localization mapping problem unknown data association 
phd thesis robotics institute carnegie mellon university 
montemerlo roy thrun 
carmen carnegie mellon robot navigation toolkit 
www cs cmu edu carmen 
montemerlo whittaker thrun 
conditional particle filters simultaneous mobile robot localization people tracking 
ieee international conference robotics automation icra pages washington dc 
icra 

dynamic binding state modal possibility 
proceedings th acm sigplan international conference principles practice programming pages 
acm press 

modal calculus effect handling 
technical report cmu cs school computer science carnegie mellon university 
park 
calculus probabilistic languages 
proceedings acm sigplan international workshop types language design implementation pages 
acm press 
petersen harper crary pfenning 
type theory memory allocation data layout 
proceedings th acm sigplan sigact symposium principles programming languages pages 
acm press 
peyton jones editor 
haskell language libraries revised report 
cambridge university press 
peyton jones gordon finne 
concurrent haskell 
proceedings rd acm sigplan sigact symposium principles programming languages pages 
acm press 
peyton jones reid henderson hoare marlow 
semantics imprecise exceptions 
proceedings acm sigplan conference programming language design implementation pages 
acm press 
peyton jones 
tackling awkward squad monadic input output concurrency exceptions foreign language calls haskell 
hoare broy editors engineering theories software construction 
ios press amsterdam 
pfeffer :10.1.1.29.1299
ibal probabilistic rational programming language 
nebel editor proceedings seventeenth international joint conference artificial intelligence ijcai pages 
morgan kaufmann publishers 
pfenning davies :10.1.1.17.1563
judgmental reconstruction modal logic 
mathematical structures computer science 

general analysis recursive probability models 
breese koller editors proceedings seventeenth conference uncertainty artificial intelligence uai pages 
morgan kaufmann publishers 
prawitz 
natural deduction 
almquist wiksell stockholm 
rabiner 
tutorial hidden markov models selected applications speech recognition 
proceedings ieee feb 
ramsey pfeffer :10.1.1.16.5350
stochastic lambda calculus monads probability distributions 
proceedings th acm sigplan sigact symposium principles programming languages pages 
acm press 
rudin 
real complex analysis 
mcgraw hill new york edition 
russell norvig 
artificial intelligence modern approach 
prentice hall 
sabry 
purely functional language 
journal functional programming 
sabry wadler 
reflection call value 
acm transactions programming languages systems 

probabilistic lcf 
editor proceedings th symposium mathematical foundations computer science volume lncs pages 
springer 
sabry 
monadic encapsulation ml 
proceedings fourth acm sigplan international conference functional programming pages 
acm press 
simpson 
proof theory semantics intuitionistic modal logic 
phd thesis department philosophy university edinburgh 
thrun 
probabilistic algorithms robotics 
ai magazine 
thrun 
programming language extension probabilistic robot programming 
workshop notes ijcai workshop uncertainty robotics 
thrun 
programming tools robots integrate probabilistic computation learning 
proceedings ieee international conference robotics automation icra 
ieee 
thrun 
robotic mapping survey 
lakemeyer nebel editors exploring artificial intelligence new millenium 
morgan kaufmann 
wadler 
comprehending monads 
mathematical structures computer science 
wadler 
essence functional programming 
proceedings th acm sigplan sigact symposium principles programming languages pages 
acm press 
wadler thiemann 
marriage effects monads 
acm transactions computational logic 
welch bishop 
kalman filter 
technical report tr department computer science university north carolina chapel hill 

