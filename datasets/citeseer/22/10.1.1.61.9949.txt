comparative study language support generic programming ronald garcia jaakko rvi andrew lumsdaine jeremy siek open systems lab indiana university bloomington bloomington usa garcia osl iu edu modern programming languages support basic generic programming sufficient implement type safe polymorphic containers 
languages moved basic support broader powerful interpretation generic programming extensions proven valuable practice 
reports comprehensive comparison generics programming languages standard ml haskell eiffel java proposed generics extension generic 
implementing substantial example languages identify language features support broader view generic programming 
find features necessary avoid awkward designs poor maintainability unnecessary run time checks painfully verbose code 
languages increasingly support generics important language designers understand features necessary provide powerful generics absence causes serious difficulties programmers 
categories subject descriptors software engineering reusable software reusable libraries programming languages language classifications multiparadigm languages programming languages language constructs features data types constraints polymorphism general terms languages design standardization keywords generics generic programming polymorphism standard ml haskell eiffel java permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
oopsla october anaheim california usa 
copyright acm 

generic programming increasingly popular important paradigm software development modern programming languages provide basic support 
example type safe polymorphic containers routine programming practice today 
languages moved elementary generics broader powerful interpretation extensions proven valuable practice 
domain generic programming particularly effective reusable libraries software components example standard template library stl part standard library 
generic programming paradigm gains momentum important clearly deeply understand language issues 
particular important understand language features required support broader notion generic programming 
aid process results depth study comparing programming languages support generics standard ml haskell eiffel java proposed genericity extension generic 
currently support generics proposed extensions prototype implementations 
languages selected widely represent state art programming languages generics 
high level goals study understand language features necessary support generic programming understand extent specific languages support generic programming provide guidance development language support generics illuminate community power subtleties generic programming 
decidedly goal demonstrate language better language 
comparison generic programming object oriented programming paradigm 
conduct study designed model library extracting small significant example generic programming state art generic library boost graph library 
model library fully implemented target languages 
example chosen includes variety generic programming techniques scope say stl expose subtleties generic programming 
attempted create uniform implementation languages standard techniques idioms language 
implementation evaluated language features available realize different facets generic programming 
addition evaluated implementation respect software quality issues generic programming enables modularity safety conciseness expression 
results process constitute main results summarized table 
table lists language features identified important generic programming shows level support feature language 
find features necessary development high quality generic libraries 
incomplete support features result awkward designs poor maintainability unnecessary run time checks painfully verbose code 
languages increasingly support generics important language designers understand features necessary provide powerful generics absence causes serious difficulties programmers 
rest describes reached table language properties important 
organized follows 
section provides brief generic programming defines terminology 
section describes design generic graph library forms basis comparisons 
sections individual implementations graph library selected languages 
sections evaluates level support generic programming provided language 
section discuss detail important issues encountered course study provide detailed explanation table 
section 

generic programming definitions generic programming vary 
typically generic programming involves type parameters data types functions 
true type parameters required generic programming generic programming just type parameters 
inspired stl take broader view generic programming definition reproduced 
associated definition terminology techniques carrying generic programming supporting key ideas emerged 
terminology fundamental realizing generic algorithms notion abstraction generic algorithms specified terms properties types terms particular types 
terminology stepanov adopt term concept mean formalization abstraction set requirements type set types 
requirements may semantic syntactic 
concept may incorporate requirements concept case concept said refine second 
types meet requirements concept said model concept 
note necessarily case concept specify requirements just type case concept involve multiple types specify relationships 
concepts play important role specifying generic algorithms 
concept may modeled concrete type meeting requirements algorithms specified terms concepts able multiple types 
generic algorithms polymorphic 
languages explicitly support concepts generic programming sub discipline computer science deals finding representations efficient algorithms data structures software concepts systematic organization 
goal generic programming express algorithms data structures broadly adaptable interoperable form allows direct software construction 
key ideas include expressing algorithms minimal assumptions data abstractions vice versa making interoperable possible 
lifting concrete algorithm general level possible losing efficiency form specialized back concrete case result just efficient original algorithm 
result lifting general cover uses algorithm additionally providing general form ensuring efficient specialized form automatically chosen applicable 
providing generic algorithm purpose level abstraction dominates efficiency inputs 
introduces necessity provide sufficiently precise characterizations domain algorithm efficient 
definition generic programming concepts constrain type parameters 
traditionally concept consists associated types valid expressions semantic invariants complexity guarantees 
associated types concept specify mappings modeling type collaborating types see example 
valid expressions specify operations implemented modeling type 
point state art type systems typically include semantic invariants complexity guarantees 
state type properly model concept associated types valid expressions specified concept defined 
primary aspects generic programming generic algorithms concepts refinement modeling constraints realized different ways different target programming languages 
specific language features support generic programming summarized table 
example simple example illustrates generic programming issues 
example initially shows versions languages 
type parameterization functions accomplished templates 
example generic algorithm realized function template template class const pick const const better return return algorithm applies better function arguments returns argument better returns true returns second argument 
type pick 
concept comparable defined represent types may pick 
standard ml haskell eiffel java generics generic multi type concepts multiple constraints associated type access retroactive modeling type aliases separate compilation implicit instantiation concise syntax multi parameter type class extension haskell :10.1.1.48.5674
planned language additions 
planned inclusion release 
table level support important properties generic programming evaluated languages 
multi type concepts indicates multiple types cane simultaneously constrained 
multiple constraints indicates constraint placed type parameter 
associated type access rates ease types mapped types context generic function 
retroactive modeling indicates ability add new modeling relationships type defined 
type aliases indicates mechanism creating shorter names types provided 
separate compilation indicates generic functions type checked compiled independently 
implicit instantiation indicates type parameters deduced requiring explicit syntax instantiation 
concise syntax indicates syntax required compose layers generic components independent scale composition 
rating column indicates explicitly support feature program feature supported due flexibility templates 
role ml haskell eiffel java generics generic generic algorithm function template functor polymorphic function generic class generic method generic method concept documentation signature type class deferred class interface interface refinement documentation include inheritance inherit extends inherit modeling documentation implicit instance inherit implements inherit constraint documentation param sig context conformance extends support concepts directly naming documentation conventions established represent 
comparable concept documented way comparable bool better const const type model comparable better function signature 
int model comparable simply define better function ints bool better int int return customary identify concepts appropriately naming template parameters 
previous example normally written template class comparable const comparable pick const comparable const comparable better return return define types apple orange struct apple apple int rating int rating bool better const apple const apple return rating rating struct orange orange const string name string name table roles language features generic programming 
bool better const orange const orange return lexicographical compare name name name name apple orange model comparable concept implicitly existence better function types 
finish calling generic algorithm pick arguments type int apple orange 
int main int char inti apple orange miller int pick apple pick orange pick return exit success 
generic graph library evaluate support generic programming library graph data structures implemented language 
library provides generic algorithms associated breadth search including dijkstra single source shortest paths prim minimum spanning tree algorithms 
design descends generic graph library evolved boost graph library 
depicts graph algorithms relationships parameterized 
large box represents algorithm attached small boxes represent type parameters 
arrow algorithm specifies algorithm ml haskell concept comparable bool better const const template class comparable const comparable pick const comparable const comparable better return return struct apple apple int rating int rating bool better const apple const apple return rating rating int main int char apple apple pick signature comparable sig type value val better value value bool functor comparable struct type value value fun pick better structure apple struct datatype value applet int fun create applet fun better applet applet structure apple val apple create apple create val pick class comparable better bool pick comparable pick better data apple int instance comparable apple better pick eiffel java generics generic deferred class comparable feature better boolean deferred class pick comparable feature go better result result class apple inherit comparable apple create feature integer rating better apple boolean result rating rating feature apple rating integer class root class create feature local apple pick apple create create create go interface comparable boolean better class pick static extends comparable pick better return return class apple implements comparable apple apple int rating public boolean better apple return rating rating int rating public class main public static void main string args apple new apple new apple apple pick go interface comparable bool better class pick static go comparable better return return class apple comparable apple public apple int rating public bool better apple return rating rating private int rating public class main public static int main string args apple new apple new apple apple pick go apple return comparing apples apples 
comparable concept pick function apple data type implemented target languages 
simple example language shown 
implemented 
arrow type parameter unboxed name specifies type parameter model concept 
example breadth search algorithm type parameters vis 
requirements model vertex list graph incidence graph concepts model read write map concept vis model bfs visitor concept 
breadth search implemented graph search algorithm 
core algorithm library graph search traverses graph performs user defined operations certain points search 
order vertices visited controlled type argument models bag concept 
concept abstracts data structure insert remove operations requirements order items removed 
bound fifo queue traversal order breadth 
bound priority queue distance source vertex order closest dijkstra single source shortest paths algorithm 
graph search parameterized actions take event points search vertex discovered 
parameter vis model visitor concept 
graph search algorithm takes type parameter mapping vertex color required model read write map concept 
read map read write map concepts represent variants important abstraction graph library property map 
practice graphs represent domain specific entities 
example graph depict layout communication network vertices representing endpoints edges representing direct links 
addition number vertices edges graph may associate values elements 
vertex communication network graph name edge maximum transmission rate 
algorithms require access domain information associated graph representation 
example prim minimum spanning tree algorithm requires weight information associated edge graph 
property maps provide convenient implementation agnostic means expressing algorithms relations graph elements domain specific data 
graph data structures directly contain associated values node external associative data structures express relationships 
interfaces property maps equally representations 
graph algorithms parameterized graph type 
graph search takes type parameter model concepts incidence graph vertex list graph 
incidence graph concept defines interface accessing edges vertex 
vertex list graph specifies interface accessing vertices graph unspecified order 
bellman ford shortest paths algorithm requires model edge list graph concept provides access edges graph 
graph capabilities partitioned concepts illustrates generic programming emphasis algorithm requirements 
bellman ford shortest paths algorithm requires graph operations described edge list graph concept 
graph search contrast requires functionality required concepts 
partitioning functionality graphs algorithm data type meets minimum requirements 
graph concepts replaced algorithm require graph type parameter necessary unnecessarily restrict set types 
graph library design suitable evaluating generic programming capabilities languages includes rich variety generic programming techniques 
algorithms implemented library algorithms breadth search dijkstra shortest paths graph search prim minimum spanning tree algorithm uses dijkstra algorithm johnson pairs shortest paths algorithm uses dijkstra bellman ford shortest paths 
type parameters algorithms parameter breadth search model multiple concepts 
addition algorithms require certain relationships type parameters 
example consider graph search algorithm 
type argument model read write map required associated key type 
type argument required associated vertex type 
graph search requires types 
graph library remainder common basis discussion 
entire library implemented language discussion limited brevity 
focus interface breadth search algorithm infrastructure surrounding including concept definitions example algorithm 
interested reader find full implementations language including instructions compilation url www osl iu edu research comparing 
graph library generics intentionally designed exceed required implement containers 
resulting template system provides platform experimentation insight expressive power generic programming 
templates primarily considered object oriented programming language 
templates added reason generics added languages study provide means developing type safe containers 
greater emphasis placed clean consistent design restriction policy 
example function templates necessary develop type safe polymorphic containers supported classes standalone functions equally supporting function templates addition class templates preserves design philosophy 
early experiments developing generic functions suggested comprehensive facilities beneficial 
experiments inspired design decisions differ object oriented generics designs java generics generic eiffel 
example contain explicit mechanism constraining template parameters 
standardization mechanisms proposed constraining template parameters including subtype constraints 
proposed mechanisms undermine expressive power generics inadequately express variety constraints practice 
language features combine enable generic programming templates function overloading 
includes function templates class templates function templates represent generic algorithms 
discuss role function overloading section 
templates separately type checked 
type checking performed instantiation call site 
type checking bound types succeed input types satisfied type requirements function template body 
unfortunately generic algorithm invoked improper type byzantine potentially misleading error messages may result 
implementation breadth search function template shown 
provide direct support constraining type parameters standard practice express constraints documentation bag read write map read write map bfs visitor models visitor vertex list graph models incidence graph models models breadth search prim min span tree vis models uses uses read write map read map vertex list graph models models models uses models vis graph search dijkstra shortest paths models edge list graph uses models read write map bellman ford shortest paths uses models johnson pairs read map models graph algorithm parameterization reuse graph library 
arrows redundant models relationships shown 
example type parameter breadth search model incidence graph breadth search uses graph search 
template class class class vis void breadth search const typename graph traits vertex vis vis constraints models vertex list graph incidence graph models read write map map traits key vertex map traits value models color vis models bfs visitor breadth search function template 
conjunction meaningful template parameter names 
techniques checking constraints implemented library 
techniques distinct actual language support involve insertion essentially compile time assertions bodies generic algorithms 
graph traits class template provides access associated types graph type 
graph traits access vertex type 
traits classes idiom map types types functions 
traits class class template 
type domain map specialized version class template created containing nested typedefs member functions 
specialize graph traits class models graph 
inside breadth search function calls functions associated concepts edges incidence graph resolved usual function overloading rules 
resolved best overload argument types 
documentation graph concepts shown table 
addition function signatures concepts specify access associated types vertex edge iterator types graph traits class 
sketch concrete adjacency list implementation shown 
class model incidence graph vertex list graph concepts fact implicit 
mechanism specifying models concepts 
graph traits class specialized associated types accessed function templates 
definitions read write map read map concepts table definition bfs visitor concept table 
graph graph traits vertex graph traits edge vertex src edge const vertex tgt edge const incidence graph refines graph graph traits edge iter models iterator pair edge iter edges vertex const int degree vertex const vertex list graph graph traits vertex iter models iterator pair vertex iter vertices const int num vertices const table documentation graph concepts 
class public private vector list int lists template struct graph traits typedef int vertex typedef pair int int edge typedef list int const iterator edge iter 
sketch concrete graph implementation 
read map map traits key map traits value value get const key read write map refines read map void put key value table documentation mapping concepts 
bfs visitor void discover vertex vertex void finish vertex vertex void examine edge edge void tree edge edge void non tree edge edge void gray target edge void black target edge table documentation bfs visitor concept 
code example breadth search function 
vertices graph output breadthfirst order creating test vis visitor overrides function discover vertex empty implementations visitor functions provided default bfs visitor 
graph constructed class call breadth search 
call site point type checking occurs body breadth search function template function templates separately type checked 
type check ensures argument types satisfy needs body generic function verify types model concepts required algorithm needs body may declared constraints function 
typedef graph traits vertex vertex struct test vis public default bfs visitor void discover vertex vertex const cout int main int char int typedef pair int int edges edges vertex get vertex vector property map color white breadth search color test vis return exit success evaluation generics templates succeed enabling expression generic algorithms large complex generic libraries 
relatively easy convert concrete functions function templates function templates just convenient client call normal functions 
traits mechanism provides way access associated types area languages fail 
template mechanism drawbacks area modularity 
complete implementations templates reside header files equivalent 
users recompile template implementations change 
addition call sites function templates arguments type checked interface function interface expressed code body function template type checked 
result function template misused resulting error messages point lines function template 
internals library needlessly exposed user real reason error harder find 
problem modularity introduced overload resolution rules 
overload resolution functions namespaces contain definitions types arguments considered overload set argument dependent look 
result function call inside function template may resolve functions namespaces 
may desired result times 
typically operations required constraints function template meant bind functions client namespace calls meant bind functions namespace generic library 
argument dependent lookup calls accidentally hijacked functions name client namespace 
templates provide type safety genericity need downcasts similar mechanisms constructing generic libraries 
course fully type safe various loopholes exist type system 
loopholes orthogonal templates 
template system introduce new issues respect type safety 
templates purely means obtaining static compile time polymorphism run time performance penalty due templates se 
generic libraries heavy procedural data abstraction induce run time overheads optimizing compilers adept flattening layers abstraction 
excellent tool applications run time efficiency critical 
heavy templates lead significant increases executable size programming idioms ameliorate problem 

graph library ml generic programs standard ml leverage language features structures signatures functors 
structures group program components named modules 
manage visibility identifiers time package related functions types values structures 
signatures constrain contents structures 
signature prescribes type names values nested structures appear structure 
signature prescribes type value signature nested structure 
essence signatures play role structures types play values 
functors templates creating new structures parameterized values types structures 
multiple structures similar form represented single functor emphasizes characteristics structures hold common 
differences structures captured functor parameters 
functors represent ml primary mechanism generics 
illustrated structures signatures functors enable generic programming 
implementation concepts expressed ml signatures 
code shows ml representations graph concepts breadthfirst search algorithm signature sig type graph vertex signature sig include type edge val edges graph vertex edge list val source graph edge vertex val target graph edge vertex signature sig include val vertices graph vertex list val num vertices graph int signature names convention sig corresponding concept names 
signature represents graph concept requires graph vertex types 
requires vertex equality type meaning vertex values compared operator 
demonstrate concept refinement ml 
clause include signature imports contents signature 
include directive represent refinements concepts 
signature may include signature included signatures declare different identifiers 
consider code error overlap signature sig include include example shows incorrect attempt describe vertex list incidence graph concept refines vertex list graph incidence graph concepts 
ml type system rejects example share vertex graph names signature 
issue algorithm require model vertex list incidence graph concept requires arguments model vertex list graph model incidence graph places additional restrictions arguments 
implementation breadth search ml shown demonstrates technique 
program components model concepts implemented structures 
code shows adjacency list graph implemented ml structure struct datatype graph data int int list array array type vertex int type edge int int fun create nv int data nv array array nv fun add edge data src int tgt int array update src tgt array sub src fun vertices data list tabulate fn fun num vertices data fun edges data map fn array sub fun adjacent vertices data array sub fun source data src tgt src fun target data src tgt tgt fun edges data array foldl fn int list src sofar int int list src map fn src sofar structure encapsulates types represent graph values functions operate 
meets requirements incidence signatures said model graph ver tex list graph incidence graph concepts 
defines additional functions fall outside requirements signatures 
create function example constructs value type graph represents graph nv vertices 
ml algorithms implemented functors 
code illustrates general structure generic breadth search implementation functor params struct fun breadth search vis map generic algorithms instantiated way functor application 
functor applied parameters satisfy certain requirements creates new structure specialized functor parameters 
functor takes parameter structure fulfills requirements signature signature sig structure structure structure structure vis sharing vis sharing type key vertex signature dictates params contain nested structures corresponding algorithm parameter 
enforces concept requirements constraining nested structures signatures 
structure example constrained signature 
breadth search algorithm ideally requires graph type argument models incidence graph vertex list graph concepts 
signatures represent concepts composed implementation requires arguments constrained signatures respectively 
functor applied structure bound type parameters 
addition listing required structures specifies type names structures refer identical types 
denoted sharings 
sharings appear signature 
structure sharing vis 
states structures share nested element name common name refer entity structures 
example structures required signature contain nested type vertex sharing requires vertex vertex vis vertex refer type 
second sharing type sharing declares key vertex type 
sharings emphasize addition signature requirements placed substructure params certain relationships structures hold 
ml supports multi parameter functors support sharing specifications parameters 
workaround functors implement generic algorithms accept single structure parameter signature lists algorithm arguments specifies necessary relationships 
structure argument functor defined point application single parameter solution reasonable 
code shows call breadth search structure bfs struct structure structure structure structure vis bfs breadth search src create create graph algorithm instantiated applying structure defined place meets requirements 
structure match signatures 
awkward avoids explicit declaration sig signature constructed composing mentioned signatures 
structure models read write map concept 
structure models bfs visitor concept encapsulates user defined callbacks 
structures meet sharing requirements 
application functor defines bfs structure encapsulates breadth search function specialized structures 
bfs breadth search called parameters match concrete type requirements 
evaluation ml ml language mechanisms provide support generic programming 
signatures structures conveniently express concepts concept models nested types functions implement associated types valid expressions 
structure representation concept models enables modularity managing identifier visibility 
functors express generic algorithm similar complexity described graph library algorithms 
signatures effectively constrain generic algorithms respect concepts algorithms parameterized 
sharing specifications enable separate type checking generic algorithms call sites 
capture additional requirements concept parameters algorithm 
necessary sharing relationships functor parameters declared explicitly 
ml issue type checking errors functor analyzed 
functor applied ml verifies arguments meet sharing signature requirements imposed functor 
technically functors means implementing generic algorithms 
ml programmers polymorphic functions parameterized data types achieve genericity 
example style programming follows 
concept datatype comparable cmp bool models datatype apples apple int fun better apple apple apple datatype oranges orange int fun better orange orange orange algorithm fun pick cmp better comparable better examples pick cmp better apple apple apple pick cmp better orange orange orange example implements better algorithm terms comparable concept 
concept realized parameterized data type holds table functions dictionary 
concept associated types data type parameters valid expressions dictionary functions 
addition val ues generic algorithm takes dictionary concept model requires 
algorithm implemented terms functions dictionaries 
style generic programming ml possible ideal 
larger ml programs managing dictionaries manually cumbersome increases code base significantly 
situation analogous implementing virtual tables leveraging object oriented programming features 
fact haskell environments lower programs generics type classes equivalent haskell programs dictionary passing style 
automating mechanisms generic programming preferable implementing manually 
ml functors implement generic algorithms enables convenient application algorithms variety user defined components 
functors ml require arguments conform structurally specified signatures 
ml structures implicitly conform signatures structure need designed signature mind 
generic ml algorithm written terms signatures operate structures meets requirements 
order promote modularity language may allow program components model concepts statically checked concepts prior generic algorithms 
structure defined ml may constrained signature 
manner structure conformity signature confirmed apart generic algorithm 
constraining structure signature limits interface described signature 
may desired result structure defines members signature declare 
example structure declared structure longer meet requirements vertices num vertices visible 
constrain structure directly conformity necessary signatures checked shown code outline structure struct structure structure structures assigned constrained signatures respectively 
structures confirms statically conforms corresponding signature limiting access structure members 
technique side effect introduces unused structures 
previously described include mechanism signature combination ml express concept refinements involve overlapping concepts 
ramsey discusses shortcoming suggests language extensions address 

graph library haskell haskell community uses term generic describe form generative programming respect algebraic datatypes 
typical term generic respect haskell somewhat different term 
haskell provide support generic programming defined section 
specification graph library translates naturally polymorphic functions haskell 
haskell function polymorphic undefined type name appears type function type treated parameter 
constraints type parameters context function code 
context contains class assertions 
haskell concepts represented type classes 
keyword haskell uses class type classes confused object oriented classes 
traditional object oriented terminology talks objects instances class haskell types instances type classes 
class assertion declares concepts type parameters model 
haskell term instance corresponds term model 
saying type models concept say type instance type class 
implementation previous languages focus interface breadth search 
haskell version function shown 
line gives name context function 
function curried parameters return type user defined type output data accumulated search 
breadth search color vis vis type classes graph incidence graph vertex list graph concepts class graph gev src tgt class graph gev edges degree int class vertices num vertices int contexts type class declarations haskell mechanism concept refinement 
refining graph concept 
associated types handled haskell type classes differently ml 
haskell associated types concept parameters type class 
graph concepts parameterized main graph type vertex edge types 
iterator abstraction plain lists edges vertices graph type classes parameterized iterator types 
haskell type classes restricted single parameter haskell implementations support multiple parameters 
denotes functional dependency 
graph type unique edge type 
functional dependencies difficult construct legal type haskell breadth search 
type class shown parameterized graph queue output type queue output type needed haskell pure functional language state changes passed explicitly done implicitly monads 
visitor concept parameterized vertex edge types associated types data array int int deriving read show data vertex int deriving eq ord read show data edge int int deriving eq ord read show list int int int list elist accumarray elist instance graph edge vertex src est vs tgt est vt instance edge vertex edges degree length instance vertex vertices iota bounds num vertices bounds simple adjacency list implementation 
graph 
type class default implementations 
class graph gev vis discover vertex vis examine edge vis discover vertex vis examine edge vis 
implementation type shown 
type explicitly declared instance incidence graph vertex list graph concepts 
shows example breadth search function create list vertices breadth order 
int list vertex data vis instance int edge vertex discover vertex vis idx color init map vertices white res breadth search color vis int idx function converts vertex integer 
call site polymorphic function haskell implementation checks context requirements function satisfied looking instance declarations match types arguments 
compilation error occurs match 
evaluation haskell generics general haskell provide support generic programming 
haskell type class mechanism extensions multiple parameters type classes functional dependencies provides flexible system expressing complex generic libraries 
type classes polymorphic functions provide succinct mechanisms abstraction invoking polymorphic func tion easy invoking normal function client may need instance declarations 
modularity provided type classes excellent 
name lookup function calls generic function restricted namespace generic function plus names introduced constraints 
generic functions calls generic functions type checked separately respect interface generic function 
type errors hugs november implementation tend difficult understand 
believe haskell type system type inferencing 
deduced type body generic function match type annotation function error message points type annotation 
important piece information expression function body caused mismatch 
issues regards convenience expression haskell 
presence associated types parameter list type class burdensome especially type classes composed 
example type class parameters 
parameters needed principle associated types 
parameters associated types graph edge vertex associated type visitor output type 
second convenience issue clients polymorphic function declare types instances type classes constraints polymorphic function 
adds textual overhead calling generic function compared normal function 
hand instance declarations add level safety forcing clients think types model required concepts semantic syntactic level 

graph library eiffel eiffel supports generics type parameterization classes 
formal type parameter accompanied constraint type actual type argument conform term eiffel uses substitutability 
type parameters follow class name square brackets arrow attaches constraint type parameter 
omitted constraint defaults class root eiffel class hierarchy 
constraining type may refer type parameters 
example constraint graph edge shown 
implementation concepts represented deferred classes cf 
classes 
model concept type inherit class representing concept 
requirements concept definition need refer associated types constrain 
eiffel mechanism attach types classes associated types expressed type parameters classes represent concepts 
parameters examples 
due lack parameterized methods generic algorithms represented parameterized classes contain method named go 
bodies generic algorithms frequently associated types algorithm parameter types 
example breadthfirst search algorithm vertex edge types graph type accessible 
generic algorithms access associated types including additional type parameters 
example type parameters represent associated vertex edge types type arguments constraint graph type analogously type parameters appear definitions corresponding concepts 
interface breadth search algorithm shown representative generic algorithms eiffel graph library implementation 
graph type model vertex list graph incidence graph concepts 
combined set requirements concepts encompassed class vertex list incidence graph shown 
class breadth search graph edge vertex list incidence graph feature go src color readwrite map integer vis bfs visitor 
interface breadth search algorithm eiffel 
deferred class vertex list graph feature vertices iterator deferred num vertices integer deferred deferred class incidence graph feature edges iterator deferred degree integer deferred deferred class vertex list incidence graph inherit vertex list graph incidence graph class adjacency list inherit vertex list incidence graph integer basic edge integer feature data list linked list integer 
graph concepts class conforms concepts 
stand vertex edge types respectively 
graph library implementation eiffel deviates design described 
eiffel implementation uses fewer type parameters 
example classes implement graph concepts type parameters vertex edge iterator types 
early attempts rigorously follow original design calls generic algorithms overly verbose 
reasons explicit instantiation inability properly represent associated types discussed section 
disadvantage fewer type parameters exact types arguments return values generic algorithms expressed 
example return type vertices iterator exact vertex iterator type 
similarly static type vis parameter breadth search algorithm exact type visitor object 
loss type accuracy performance implications eiffel compilation model exact types exploited static dispatching 
inexact types result situations relying covariant changes type parameters needed 
covariant change formal parameters methods controversial feature eiffel leads type safety problems 
covariance type parameters problems discussed section 
evaluation eiffel generics eiffel supports type checking generic classes independent 
allows type errors caught generic class instantiated 
furthermore generic classes compiled separately 
regardless number instantiations compiled code contains realization generic class 
abstraction modularity factors affect eiffel support abstraction modularity instantiation generic algorithms language mechanisms representing accessing associated types lack multiple generic constraints 
eiffel requires explicit instantiation caller generic algorithm pass actual arguments type arguments 
assuming arguments types adjacency list src integer color hash map integer integer vis bfs visitor call breadth search algorithm eiffel bfs breadth search integer basic edge integer adjacency list create bfs bfs go src color vis explicit instantiation tedious number type parameters large 
furthermore explicitly instantiated call generic algorithm carries unnecessary dependencies implementation details parameters 
section covers issues 
associated types constraints part concept requirements eiffel classes properly encapsulate requirements 
time concept constraint associated types constraints stated explicitly 
common problem eiffel java generics generic discussed greater length section 
eiffel anchored types chapter provide solution express arbitrary dependencies types 
set problems arises combined effect explicit instantiation accessing associated types type parameters 
problem verbose calls generic algorithms exacerbated 
instantiating generic algorithms explicitly inside generic components type arguments instances generic classes 
result specifying type arguments explicitly significant programming overhead 
earlier implementation followed original library design graph search algorithm type parameters 
dijkstra shortest path algorithm counting nested parameters internal call graph search algorithm required type arguments 
effect alter library design reduce number type parameters described section 
second associated types dependent implementation details concrete types 
explicit instantiation spreads dependency call sites generic algorithms 
sections demonstrate examples discuss issue detail 
type parameter constraint single class 
classes represent combinations concepts obvious mechanism lack multiple constraints 
classes vertex list graph incidence graph graph type required derive class vertex list incidence graph 
requirements generic algorithms determine combinations concepts require classes 
adding new algorithm requires previ ously unused combination concepts necessitates creation new class combination 
change propagates subclasses combination including concrete graph types 
multiple generic constraints open issue eiffel standardization potential addition language 
multiple constraints requirements parameter written vertex list graph incidence graph static type safety eiffel criticized type safety problems 
particular type conformance checking subclass relation allows instance variables parameters routines change covariantly 
rules subclass relation imply substitutability additional measures taken guarantee type safety 
suggested approaches include system validity check requires program analysis ban called polymorphic 
knowledge publicly available compiler implements analyses 
polymorphic check conservative rule useful programs clear 
proposal suggests requiring programmers add explicit handler functions potentially type unsafe program point 
applying scheme existing libraries evaluating provides satisfactory solution way 
eiffel applies covariance generic parameters type safety problems concern 
eiffel conformance rules type conforms type generic class derives conforms leads type safety problems avoided overly conservative assumptions rejection useful reasonable code 
difficult fabricate example case leading program crash practice ran issue repeatedly 
example demonstrates problem deferred class readwrite map key value put key val value deferred class whiten vertex cm readwrite map integer inherit colors feature go color map cm color map put white graph algorithms attach state information vertices property maps 
state represented integer constants white black gray 
example shows generic algorithm setting state vertex white 
whiten vertex algorithm takes method parameters vertex property map color map types type parameters cm 
call color map put white example fails 
map color map type cm inherits readwrite map integer may expect signature put method put key val integer 
due possible covariance type parameters compiler assume differently 
suppose generic class map inher readwrite map vertex inherits vertex int integer 
map vertex int conforms class readwrite map vertex integer making instantiation seemingly valid whiten vertex vertex map vertex integer instantiation put method signature put vertex val integer called arguments types vertex integer 
obvious error prevent errors compilers attempt partially solve covariance problem reject definition go method whiten vertex class time disallowing legitimate uses 
compilers accept definition making programs vulnerable uncaught type errors 
sum covariance rule causes code perfectly reasonable rejected leads type 
immediate fix situation change type color map parameter go color map readwrite map integer integer color map type readwrite map integer put signature guaranteed put val integer 
change exact type actual argument bound color map lost 
particular case critical 
suppose algorithm kept original map intact returned modified copy map result 
signature method go color map readwrite map integer integer readwrite map integer regardless type actual argument bound color map return value coerced readwrite map integer losing capabilities original type potentially 
interface johnson algorithm illustrates covariance exploited decrease number type parameters 
parameters johnson algorithm map maps storing distances vertex pairs graph 
type constraint argument read map readwrite map distance concrete type map integer map integer real bound integer distance real conform constraint covariance 
generic programming fundamentally benefit covariance type parameters language feature 
resorted covariance reduce difficulties arising lack implicit instantiation support associated types 
particularly able reduce number type parameters situations possible covariance 
notably covariance rules reduced flexibility 
guarantee type safety new restrictions introduced 
restrictions lead compiler rejecting code reasons easy programmer discern 

graph library java generics java generics extend java programming language type parameters classes interfaces methods 
public interface vertex extends iterator vertex vertices int num vertices public interface vertex edge extends iterator edge edges vertex int degree vertex public interface extends public class adjacency list implements integer simple edge integer iterator integer integer iterator simple edge integer integer iterator simple edge integer 
interfaces representing graph concepts java adjacency list data structure models concepts 
proposed official addition java planned version language 
implementation version proposed generics java 
respect generics differences version proposed generics java affect evaluation 
java generics support parameterized classes methods 
generic methods implicitly instantiated 
type parameters constrained subtyping including multiple constraints parameter 
implementation java generics represent concepts interfaces 
type declares models concept inheriting corresponding interface 
shows java representations graph concepts adjacency list graph data structure modeling concepts 
implements clause adjacency list model vertex list graph incidence graph concepts 
generic algorithms straightforwardly expressed functions 
languages functions emulated static methods 
choices parameterize method parameterized methods non parameterized classes non parameterized methods parameterized classes 
alternative advantage implicit instantiation second alternative requires verbose explicit specification type arguments 
convention eiffel implementation section class name refers name algorithm implementation method named go 
java support type aliases typedef statement associated types challenge 
eiffel implementation associated types included type parameters interface representing concept 
example interface associated types 
adjacency list graph type demonstrates connecting concrete associated types type parameters interface edge type list edge integer vertex type integer shows interface breadth search algorithm 
algorithm takes type parameters method parameters 
type parameters types method pa public class breadth search public static vertex edge extends vertex extends iterator vertex extends iterator edge visitor extends colormap extends vertex integer void go vertex edge vertex colormap visitor vis breadth search interface java generics rameters represent associated types method parameter types graph type 
straightforward implementation type parameter graph type approach feasible due limitations type system java generics 
problems explained detail 
type parameters constrained extend class optionally implement set interfaces 
implicit instantiation calling generic method different calling non generic method 
example breadth search algorithm invoked breadth search go src color map visitor evaluation java generics interfaces provide mechanism represent concepts language 
type parameter constraints expressed directly enforced compiler 
arguments generic algorithms bodies algorithms checked separately concept requirements leading separation types generic algorithms implementations algorithms 
java generics provide support generic programming allow type safe implementation generic graph library 
due problems related subtyping constrained polymorphism generic programming java restricted cumbersome 
problem originates inheritance express models relation 
inheritance relation fixed class defined 
consequently existing classes model new concepts retroactively definitions modified 
section explains problem significantly decreases modularity 
second problem related representing associated types 
java classes interfaces encapsulate methods member variables types 
concept associated types represented separate type parameters 
referring concept generic algorithm requires repeating type parameters including algorithm 
results unnecessarily lengthy code repetition type constraints 
sections discuss problem detail 
classes interfaces type arguments builtin types int double 
integer double classes 
results inefficient code 
example int common choice representing vertices double edge weights 
wrapper classes syntax setting weight graph edge weight map set new list edge new integer new integer new double built types allowed type arguments code simpler weight map set new list edge planned feature java solves problems 
feature allows automatic conversion primitive type wrapper type cast reverse conversion 
allows shorter syntax requiring explicit creation integer double objects 
example unnecessarily verbose code java syntax declaring initializing variable requires type variable written twice 
example code create integer object integer new integer example name type short 
case generic programming libraries 
types graph library implementation span lines see section example 
repetition names tedious increases possibility errors 
repetition unavoidable java type aliasing facility typedef 
generic components uses compiled separately 
generic algorithm implementation type checked instantiation 
uses generic algorithm checked ensure concept requirements satisfied independently implementation generic algorithm 
allows faster compilation catching type errors early possible major advantage relative 
java generics provide type safe generic programming framework 
backwards compatibility language implemented type erasure forces type checks performed run time effect performance 
certain type constraints expressed type language 
restrictions known resolved java generics losing backward compatibility current java language definition 
restrictions type erasure encountered graph library implementation 
alternative flexible approaches adding generics java suggested 
major problem current type system java generics type arguments inferred constraints generic method 
proper support associated types kind type inference necessary associated types simulated 
behavior explicitly stated type system specification java generics 
behavior code fails compile public class java associated types public static value iter extends iterator value boolean iter iter return iter value null public static void main string args arraylist integer null iterator call main values derived type parameters value iter 
iter iterator integer iterator type container implicit instantiation mechanism examine type constraints value value default value object 
call fails iterator integer subtype iterator object 
possible extend java type system type parameter constraints public class breadth search public static extends vertex vertex edge vertex edge extends vertex extends iterator vertex extends iterator edge visitor extends vertex edge colormap extends vertex integer void go vertex colormap visitor vis breadth search interface java generics improved type system public interface vertex vertex vertices int num vertices public interface vertex edge edge edges vertex int degree vertex public interface vertex edge vertex vertex edge edge vertex vertex edge public class adjacency list int list edge int int list edge int 
generic representations graph concepts type models concepts 
aid implicit instantiation allow correct value integer value 
modification interface breadth search java written shown 
current design implicit instantiation appears follow similar rules problem 
language proper support associated types need able derive type parameter values constraints 
summary java language extended generics provides solid support generic programming problems writing generic programs tedious restricted 

graph library generic generic extends programming language parameterized classes interfaces methods 
apart minor syntactic differences generic class method definitions similar java generics 
generic programming analogous concepts represented interfaces class declares models concept implementing interface representing concept 
full separate type checking compilation supported 
generics planned feature release prototype implementation named gyro released 
implementation graph library version gyro 
public class breadth search public static void go vertex edge colormap visitor vertex colormap visitor vis vertex edge edge vertex vertex edge colormap vertex visitor vertex edge breadth search interface generic 
interface provides iteration mechanism 
breadth search go adjacency list int list edge int int list edge int bfs visitor adjacency list int list edge int graph src vertex color map visitor call breadth search algorithm generic 
implementation shows interfaces representing vertex list graph incidence graph concepts interface representing combined requirements concepts 
combined interface necessary gyro prototype implementation generic support multiple constraints type parameter 
furthermore graph data structure modeling concepts shown 
interface breadth search algorithm shown 
example invocation algorithm illustrates significant difference current prototypes java generics generic gyro implementation generic support implicit instantiation 
evaluation generic generic avoids java generics particularly primitive types arguments generic components 
severe drawback gyro implementation generic lack implicit instantiation 
need explicitly specify type arguments generic methods leads unnecessary code duplication loss modularity discussed section 
consequently gyro implementation generic allows similar levels abstraction type safety java generics substantially modularity 
proposed standard generics includes implicit instantiation infer type parameter values constraints 
problems occurred java generics proposed generics 
gyro implementation generic support constraint type parameter 
type parameter model concept combination interfaces created 
interface example combination interface 
problems strategy discussed evaluation eiffel generics section 
support constraining type current specification generics planned release net 

discussion sections describe specific problems encountered surveyed languages 
problem concerns type constraint mechanism evolving software systems especially new algorithms concepts created 
second problem regards limitations subtyping constrain type parameters 
third discuss repercussions way associated types accessed surveyed languages 
fourth explicit instantiation combined insufficient support representing associated types generic function calls dependent implementation details argument types 
fifth lack mechanism type aliasing source unnecessary verbosity especially generic components explicitly instantiated 
establishing modeling relation type arguments generic algorithm model concepts constrain algorithm type parameters 
languages study different techniques establish modeling relationships 
java generics generic eiffel subtyping point class definition 
haskell requires explicit instance declaration independent data type definition 
modeling relationships ml implicitly checked structural conformance generic function call sites 
structure meets signature requirements satisfies modeling relationship 
provides language feature establishing modeling relationships 
type arguments required provide functionality function template body 
modeling mechanisms java eiffel haskell rely named conformance 
explicit declaration links concrete type concepts models 
haskell differs named conformance occurs separate data structure definition 
modeling ml relies structural conformance 
names concepts irrelevant requirements established signature matter 
modeling mechanisms ml haskell worked implementing graph library 
ml structural conformance small advantage area convenience user generic function declare types model required concepts 
named conformance hand avoids problems accidental conformance 
canonical example accidental conformance rectangle class move draw methods cowboy class move draw shoot methods 
modeling structural conformance cowboy rectangle expected possibly resulting troublesome runtime errors 
experience accidental conformance significant source programming errors 
languages modeling established named conformance type definition time types retroactively model concepts 
type defined set concepts models fixed 
modification definition modeling relationships altered 
causes problems libraries interesting interdependencies composed 
shows example retroactive modeling problem 
example library defines graph concept vertex list graph graph data structure adjacency list models concept 
library creates algorithm requires subset vertex list graph concept library library defines concept vertex number graph corresponding subset 
problem adjacency list model new concept library possible languages java eiffel modeling relationships fixed type defined 
languages haskell solve allowing modeling refinement relationships established related types concepts defined 
languages ml encounter problem structural conformance named constrain type parameters 
namespace public interface 
vertices int num vertices public interface 
edges public class adjacency list 
namespace public interface 
int num vertices class bellman ford public static void go 

namespace adjacency list problem adjacency list inherit bellman ford go adjacency list example showing need retroactive modeling 
problem retroactive subtyping addressed providing language mechanism external class definition establishes subtyping relation 
analogous haskell instance declaration established modeling relation 
aspect oriented programming systems aspectj allow modification types independently original definitions 
example existing class modified implement newly created interface static crosscutting 
external polymorphism design pattern attempt address integration problem changes existing object oriented languages 
related problems encountered component interfaces component software 
subtyping modeling refinement java generics generic concepts approximated interfaces similarly eiffel deferred classes 
modeling relation type concept approximated subtype relation type interface 
refinement relation concepts approximated interface extension 
constraints interfaces subtyping correctly express constraints multiple types 
concepts commonly group constraints concerning multiple types 
example vertex list graph concept places constraints graph type vertex type graph vertex iterator type 
particular vertex list graph concept requires vertex iterator type model iterator concept 
express constraints multiple types interface parameterized 
example java generics try approach definition interface 
constraint placed parameter interface vertex extends iterator vertex vertices int num vertices problem approach referring name sufficient include associated type constraint concept context generic algorithm 
example breadth search function constraint express requirement type model iterator class breadth search public static extends vertex vertex edge vertex edge visitor extends vertex edge colormap extends vertex integer void go vertex colormap visitor vis code fails type check type argument fails implement interface iterator 
shows corrected version adds constraint extends iterator vertex 
repetition constraint means interfaces fail provide way organize group constraints multiple types 
constituent constraints concepts repeated generic algorithm 
reduces benefits grouping constraints concepts extremely verbose 
similar problem respect approximating concept refinement interface extension 
example java generics declaration legal type declared extend iterator edge instantiating interface vertex edge extends vertex edge 
corrected version interface vertex edge extends iterator edge extends vertex 
access associated types generic functions need mechanism access associated types 
example breadth search type second parameter source search vertex type associated graph type 
prototype breadth search shows traits class map graph type vertex type 
ml mapping accomplished nesting types structures 
languages evaluated provide direct mechanism expressing functions types able dispatch inputs 
instance iterator type iterator value type int iterator type iterator value type double 
associated types accessed generic function added type parameter list generic function 
relationship extra type parameters types associated established parameterizing interfaces java generics eiffel type classes haskell constraints generic function 
approach results significant increase verbosity constraints generic components 
example java generics version breadth search shown includes type parameters associated types graph 
contrast version breadth search type parameters 
verbosity introduced approach compounds problem repeated constraints discussed previous section 
implicit instantiation languages support implicit instantiation properly encapsulate associated types eiffel gyro prototype generic explicit instantiation results overly verbose generic algorithm invocations 
call breadth search algorithm generic demonstrates problem programmer specify types deduced argument types 
representing associated types type parameters increases verbosity addition types arguments passed generic algorithm programmer specify associated types 
breadth search algorithm type arguments associated types type argument graph type 
code serves stark exaggerated example combined effect explicit instantiation representing associated types type parameters 
need specify associated types creates unnecessary implementation dependencies 
explained type arguments call breadth search algorithm associated types type argument 
types represent internal implementation details graph type 
call algorithm types explicitly specified 
consequently changes implementation details require changes user code call sites generic algorithms 
consider call breadth search algorithm eiffel shown section adjacency list src integer color hash map integer integer vis bfs visitor bfs breadth search integer basic edge integer adjacency list create bfs bfs go src color vis adjacency list class uses integer vertex type basic edge integer edge type 
breadth search algorithm take edge object parameter edge type specified 
consequently changing implementation adjacency list different edge type edge integer requires type bfs changed accordingly bfs breadth search integer edge integer adjacency list call site graph algorithm uses edges internally takes argument type adjacency list updated reflect new edge type 
type aliases type aliasing mechanism provide alternative name type cf 
typedef keyword 
parameterization components introduces long type names especially parameterized components composed 
example generic type visitor object dijkstra algorithm dijkstra visitor mutable queue vertex indirect cmp vertex distance vertex edge distance example type arguments instantiations parameterized components 
types resulting cluttered unreadable code 
long type name may appear times 
line long type appear times implementation dijkstra algorithm 
type aliasing short name type reduce clutter code 
repeating type increases probability errors changes copy type consistently applied copies 
addition avoiding repetition long type names type aliases useful abstracting actual types losing static type accuracy 
shows allocation visitor object call graph search algorithm appears inside dijkstra implementation 
type aliases lines code lines 
mechanism type aliases java eiffel 
type aliasing simple crucial feature managing long type expressions commonly encountered generic programming 
dijkstra visitor mutable queue vertex indirect cmp vertex distance vertex edge distance bfs vis new dijkstra visitor mutable queue vertex indirect cmp vertex distance vertex edge distance graph search go vertex edge hash map vertex mutable queue vertex indirect cmp vertex distance dijkstra visitor mutable queue vertex indirect cmp vertex distance vertex edge distance color bfs vis lack type aliases leads unnecessarily lengthy code 

mainstream object oriented programming languages begun include support generics 
java generics accepted expected releases languages 
eiffel supported generics inception 
generics primarily added languages support type safe polymorphic containers 
object oriented programming techniques remain primary mechanism building abstractions languages generics fill small specific need 
languages studied ml haskell support broader powerful version generic programming 
experience template system demonstrates flexible generics facility requires different design intended merely polymorphic containers 
object oriented languages studied subtyping constrain generics rejected approach lacks expressiveness flexibility 
subtype constraints adequate polymorphic containers typically place constraints parameters convey complex constraints needed generic programming 
provides implicit function template instantiation enables convenient generic algorithms 
eiffel support implicit instantiation generics planned addition java 
support generic programming limitations 
language support explicit expression concepts 
documentation generally describes concept constraints enforcing 
argument dependent lookup obscures operations generic function may call 
function templates type checked independent 
spite flaws commercial generic programs libraries successfully written language 
ml haskell experience respect generics ml haskell provide informative contrast object oriented languages 
ml haskell provide polymorphic functions data types sufficient implement polymorphic data structures 
languages provide powerful mechanisms type classes haskell functors ml 
discussions java generics generic eiffel suggest haskell ml avoid difficulties implementing generic libraries object oriented languages share 
ml structures signatures support associated types component modularity static type safety 
haskell improves ml generic programming support implicit instantiation generic functions 
languages disadvantages 
ml lacks functions constrained genericity aside functions nested functors 
haskell quite expressive requires awkward mechanism express associated types 
general languages provide fine substrates build generic libraries 
appeal language designers time writing language support generics continues evolve 
updates standard currently way 
generics promised java standards 
eiffel currently undergoing ecma standardization 
languages opportunity address shortcomings respect support generic programming 
doing augment benefits generics currently offer 
conscious consideration support flexible generics expressive constraints improve ability languages express modular reusable program components 
acknowledgments supported nsf eia aci endowment 
authors todd veldhuizen anonymous referees careful reading considered comments 


generic programming stl 
professional computing series 
addison wesley 
backhouse jansson jeuring meertens 
generic programming 
lncs volume pages 
springer verlag 
revised version lecture notes afp 
baumgartner ufer 
half half multiple dispatch retroactive abstraction java 
technical report osu tr ohio state university 
bellman 
routing problem 
quarterly applied mathematics 
bracha bloch 
jsr extending java programming language enumerations enhanced loops static import december 
www jcp org en jsr detail id 
bracha cohen kemper marx jsr add generic types java programming language april 
www jcp org en jsr detail id 
bracha odersky stoutamire wadler 
making safe past adding genericity java programming language 
proceedings acm conference object oriented programming languages systems applications oopsla 
bruce 
typing object oriented languages achieving expressibility safety 
technical report williams college 
chi 
compound types java 
proceedings oopsla pages october 
www abo fi publications oopsla html 
cartwright steele jr compatible genericity run time types java programming language 
chambers editor acm symposium object oriented programming systems languages applications oopsla pages 
acm 
schmidt harrison 
external polymorphism object structural pattern transparently extending concrete 
martin riehle buschmann editors pattern languages program design volume software pattern series 
addison wesley 
cook 
proposal making eiffel type safe 
computer journal 
dijkstra 
note problems connexion graphs 
numerische mathematik 

programming language 
invited talk object oriented programming systems languages applications oopsla 
hinze jeuring 
generic haskell practice theory 
summer school generic programming lncs 
springer verlag 
howard meyer keller 
type safe covariance competent compilers catch 
apr 
international standardization organization iso 
ansi iso standard programming language 
rue de case ch gen switzerland 
jazayeri musser stepanov 
generic programming 
report dagstuhl seminar generic programming schloss dagstuhl germany apr 
jeuring jansson 
polytypic programming 
launchbury meijer sheard editors tutorial text nd int 
school advanced functional programming volume pages 
springer verlag berlin 
jones 
type classes functional dependencies 
european symposium programming number lncs pages 
springer verlag march 
jones hughes haskell non strict purely functional language february 
www haskell org 
jones jones meijer :10.1.1.48.5674
type classes exploration design space 
haskell workshop june 

standard library tutorial 
addison wesley 
kennedy syme 
design implementation generics net common language runtime 
proceedings acm sigplan conference programming language design implementation pldi pages snowbird utah june 
kiczales hilsdale hugunin kersten palm griswold 
overview aspectj 
lecture notes computer science 
kiczales lamping mendhekar maeda lopes 
loingtier irwin 
aspect oriented programming 
aks matsuoka editors ecoop object oriented programming vol 
lecture notes computer science pages 
ufer baumgartner russo 
safe structural conformance java 
computer journal 
magnusson 
code reuse considered harmful 
journal object oriented programming nov 
mcnamara smaragdakis 
static interfaces 
workshop template programming october 
meyer 
eiffel language 
prentice hall new york ny edition 
meyer 
static typing 
addendum proceedings th annual conference object oriented programming systems languages applications pages 
acm press 
meyer 
start eiffel standard 
journal object technology july august 
www fm 
microsoft 
generics september 
part gyro distribution generics net 
microsoft 
generics net clr may 
research microsoft com projects 
milner tofte harper macqueen 
definition standard ml revised 
mit press 
myers bank liskov 
parameterized types java 
th acm symposium principles programming languages 
laboratory computer science mit january 
myers 
traits new useful template technique 
report june 
odersky 
inferred type instantiation prototypes gj 
epfl ch odersky ftp local ti ps jan 
prim 
shortest connection networks generalizations 
bell system technical journal 
ramsey 
calculus signatures 
www eecs harvard edu nr pubs html october 
siek 
lee lumsdaine 
boost graph library user guide manual 
addison wesley 
siek lumsdaine 
concept checking binding parametric polymorphism 
workshop template programming october 
siek 
lee lumsdaine 
generic graph component library 
proceedings acm sigplan conference object oriented programming systems languages ions pages 
acm press 
siek lumsdaine 
matrix template library generic programming approach high performance numerical linear algebra 
international symposium computing object oriented parallel environments 
stepanov lee 
standard template library 
technical report wg iso programming language project may 
stroustrup 
design evolution 
addison wesley 
veldhuizen 
arrays 
proceedings nd international scientific computing object oriented parallel environments volume lecture notes computer science 
springer verlag 
