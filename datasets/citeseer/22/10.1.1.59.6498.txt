ownership encapsulation disjointness type effect dave clarke institute information computing sciences utrecht university utrecht netherlands dave cs uu nl ownership types provide statically enforceable notion object level encapsulation 
extend ownership types computational effects support reasoning objectoriented programs 
ensuing system provides access control effects reporting 
type system codify formal systems reasoning aliasing disjointness computational effects 
prove evaluation expressions lead aliases show non interference expressions 
categories subject descriptors software programming languages general terms languages theory keywords ownership types encapsulation aliasing type effects systems 

possibility aliasing key question aspects system development implementation optimisation 
compiler optimisations valid respective manipulations preserve program semantics 
example synchronisation may eliminated concurrent programs established data races occur 
debugging code maintenance require knowledge aliasing structure parts object graph potentially accessed changed code consideration 
garbage collection assisted know aliases example escape particular region play part computation permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
oopsla november seattle washington usa 
copyright acm 
sophia drossopoulou department computing imperial college london great britain sd doc ic ac uk 
security required safe deployment applets depends certain confinement properties 
concrete notion object aggregate component really exist integrity encapsulated objects maintained :10.1.1.23.2115:10.1.1.30.5600
modular reasoning possible control knowledge aliasing effects possible 
tasks require knowledge potential aliasing potential accesses parts state 
aliasing effect information appeared part type annotations type system deduce properties program behaviour 
properties convenient obtain full blown theorem prover supplied axioms assist theorem prover 
suggest ownership types extended computational effects address issue :10.1.1.23.2115
ownership types impose structural restrictions object graphs statically definable checkable notions owner representation 
owner object object representation objects owned 
ultimately ownership types enforce statically checkable notion encapsulation object private collection representation objects accessible outside object owns 
adopting ownership basis effects system diverge complementary alternative taken greenhouse boyland employ uniqueness 
addition ownership types effects system introduce formal systems reasoning programs 
determines types disjoint deduce aliasing properties 
second determines effects statements disjoint show non interference expressions 
contributions threefold firstly extend previous ownership types support inheritance dynamic aliases allow description iterators whilst maintaining strong notion encapsulation 
secondly extend ownership types system computational effects 
thirdly apply ownership types reason absence aliasing apply effects system reason non interference computation 
believe system robust adapted sophisticated programming languages 
structured follows 
section sets scene describing ownership encapsulation reason disjointness type effect 
section describes joe core object oriented language extended ownership types effects annotations 
section examples discuss consequences joe annotations 
static dynamic semantics joe described sections section statement relevant properties 
section details rules disjointness type effect illustrates 
related discussed section conclude section giving possible directions 

ownership effects describe notion object ownership encapsulation 
indicate help determine types disjoint effects phrases disjoint denote non interfering computation 
contexts ownership encapsulation ownership types system object owner 
owner object predefined constant world objects owned system 
call owners contexts incorporate type system statically track object ownership 
essential differences object ownership uniqueness include object refer objects need refer objects object may referred number objects 
code owner indicated parameter parameterised type 
example owner objects field head class list owner add method argument data parameter list class owner data object added populate method world 
parameters objects class main owner assumed world 
object ownership stems notion containment object considered inside owner 
induces transitive tree shaped ordering objects root 
preventing access object objects outside owner gain strong notion encapsulation object 
exact property dubbed owners objects dominated owners paths root object graph object pass owner 
exhibited earlier type system abstractly terms object graphs 
consequence owners dominators property objects surrounded imaginary boundary protects internal objects accesses external objects 
system satisfies owners dominators property enforces call deep ownership 
alternative shallow ownership prevents direct access internal objects ensuring owners invariant program execution preventing indirect external access objects apart owner 
shallow ownership results weaker 
shallow ownership imposes weaker constraint objects graphs restrictive terms programs legal 
regain potential loss expressiveness dynamic aliases stack representation objects 
fact class list owner data link data head void add data data writes head new link data head class main list world list main writes list new list world void populate writes list add new data world list add new data world static void main writes world main main new main main populate example code really loss expressiveness se 
merely sacrifice protection enable certain implementation patterns 
object level encapsulation achieved steps 
firstly objects owned current object denoted owner context 
objects called representation context called representation context 
access objects owner restricted current object objects inside current object 
secondly ensure subtyping forget nesting objects enable passed objects ought access 
running code results element list object graph 
solid circles denote objects 
hollow labelled world denotes top system need actual object 
solid arrows ordinary 
dotted arrows denote object ownership need represented run time 
owners dominators property depict encapsulation boundaries objects 
prevent certain outside inside represented dashed arrow 
starting top world preexisting context objects owned system wide 
owner main class main owner parameter 
owner data world specified type data world 
type list world specifies list owned instance main data list owned world 
additional code indicates links list owner 
disjointness type effect strong form encapsulation conclude certain types disjoint 
example class main fields list world shared list conclude shared aliases 
world differ list link world main owner data link illegal data encapsulation boundary object ownership encapsulation ent contexts refers current instance main world global constant context 
infer link objects referred object shared disjoint referred object collection links encapsulated list 
conclude data objects stored lists disjoint 
viewing shared common supertype object allow concluded alias properties 
extend ownership types system clarke potter noble computational effects 
greenhouse boyland allow effects calculated expressions declarations accompany method 
declarations enable modular checking 
primitive effect occurs field object read written 
contexts correspond objects contexts basis effects 
effect statically denoted collections contexts called effect shapes containing contexts may read written 
effect shapes denotes contexts inside including 
example add method list write effect 
indicates write read may occur list object object inside 
nesting objects enforced ownership types allows description precision effects unknown parts object graph 
example conclude running code shared add new data world produce effect disjoint effect resulting evaluating add new data world 
said earlier shared aliases 
addition shared owner demonstrate set objects denoted effect writes shared disjoint set objects denoted effect writes 

joe java ownership effects joe object oriented programming language resembling java extended ownership types effects annotations 
subscript indicates series languages 
syntax joe 
notation pi indicates sequence set items pi element sequence set classes 
class collection fields methods 
addition class may parameterised contexts 
parameter denotes owner 
parameters owners objects accessed objects class 
subclassing specified extends clause parameters superclass instantiated contexts scope preserving owner position 
types 
type pi consists name class parameters instantiated contexts pi scope 
parameter owner objects type 
parameters required type written just owner global context world 
formalism write type binding context parameters contexts 
forms equivalent formal parameters pi 
substitution example determining types fields 
notation pi denote pi methods 
methods annotated effects specification 
indicates effect shape collection contexts may read written method evaluated 
loss generality methods take argument keep formal system simple 
examples arguments necessary 
expressions 
expressions encompass basic object operations field access field update method call object creation null 
expressions form intermediate value stored local variable updated 
variable name subsequently refer internal representation context value stored variable feature absent earlier system 
enables tracking dynamic aliases stack objects heap representation objects 
java syntax final local variables 
contexts 
object owner change 
owner object context world indicating owned system 
said earlier owner dominate point classname class class class extends pi fd fieldname fd field methodname meth method expr var computation new null context world 
natural number effect rd wr type pi execution path root pass example link objects owned list object turn owned main object data objects owned world 
easily proven ownership relationship forms tree world root 
transitive closure relationship dubbed inside captures nesting objects 
forms context occur program source called just contexts occur run time called actual contexts denote actual object owners world object created 
contexts statically refer actual contexts type system 
contexts consist world program source run time denotes root context context parameters denoted variables denotes owner objects owned object stored variable 
particular context owner representation 
classes parameterised context variables example allows distinction lists data different owns 
constraints contexts statically capture desired nesting actual contexts required maintain owners dominators property 
effect shapes effects 
effect consists pair effects shapes capturing contexts may read capturing contexts may written 
rd wr denotes read may occur context write may occur context consider write effect include reads may occur contexts greenhouse boyland 
read denoted effect may occur context fact reflected static aspects joe location value null 
dynamic aspects single type rule 
easily modified 
effects shapes denote collections contexts 
shape represents empty collection 
context shapes referred band referred shape 
shapes depicted shows objects tree ordering 
shape set contexts exactly steps beneath context tree ordering 
singleton set 
sufficient write just 
shape corresponds shape world cor responds union contexts world top context 
union effect shapes denoted chosen collection shapes enable representation effects unknown parts object internals retaining precision dealing internals 
obvious effect shape corresponding denoting internal object precise 
examples effects shapes 
greenhouse boyland offer alternative compatible approach 

examples consider example 
consists list iterator implemented language compressing expressions 
list iterator created part list representation access rest list representation links 
accessed externally dynamic alias 
effect add method wr included wr effect 
similarly effect elem method wr owner shape included band band basic effects shapes class link owner data link owner data data data data link link owner data data data data writes data data class list owner data link data head void add data data writes head new link data head iterator data reads writes return new iterator data head class iterator link current iterator link writes current void reads writes current current data elem reads return current data boolean done reads return current null list iterator additional information superfluous 
method encapsulated effects 
thing interest example system express effects method read write encapsulated object method operates 
kind thing formal reasoner desires 
example effect method add wr indicating affects target object representation 
list type list world expression list add new data world effect wr list meaning affects internal representation list 
execution expression guaranteed interfere modify fields object list objects owned list 
representation access dynamic aliases 
incarnation ownership types dynamic aliases 
limited expressiveness programming language preventing short lived abstractions list iterator access representation object 
type system allows dynamic aliases keeping track dependencies pleasing manner limiting lifetimes imposing limitations restricting read 
example create list iterator list world list new list world iterator list world iter list notice type iterator iter variable name list owner 
means iter part allowed access list representation iter externally accessible list scope 
list scope type iterator list world type containing context list illegal 
furthermore supertype iterator list world mention context list subtyping break property 
dynamic aliases briefly break dominators property stack local variables 
dynamic aliases permit friendly functions functions access representation different objects mixed different representations 
example method part class list bool equals list owner data link data head link data head data equal data 
type system allows initialisation object representation externally created objects guarantee external aliases problem identified detlefs leino nelson 
example require socket underlying stock class externally created client decide implementation part representation 
personal communication bart jacobs november 
class socket void socket writes class main void 
writes 
new socket achieve variable holding handler owner newly created socket 
context externally denotes representation 
separation construction initialisation example eliminated simple static analysis 
uses uniqueness achieve behaviour 
gain encapsulation guarantees ownership types enable requiring uniqueness transfer socket created stored 
avoid complications uniqueness guarantee resulting socket unique 
allowing dynamic aliases weaken possible encapsulation controlled full programming language privacy annotations 
example permit certain dynamic aliases iterators prohibit direct access list links 
consequence deep ownership dynamic aliases stored object field inside object owns 
permitted system shallow ownership results hold case 
dynamic aliases represent sensible compromise permits certain idioms ones discussed losing desired properties owners dominators property 
treatment examples initialisation iterators friendly functions pleasing previous attempts type dynamic alias contains name entity representation dynamically aliases 

static semantics static semantics describe formed programs 
type rules defined respect program left implicit avoid unnecessary clutter 
program populate dictionaries helper functions described 
type rules defined environment provides types free term variables locations formedness dynamics constraints context variables equivalent environments allows newly introduced parameter case denoted left hand side relation dom collection free variables 
dynamic semantics defined terms explicit binding free variables substitution 
affect static semantics programming language bindings required type rules prove type preservation theorem 
avoid duplicating include binding list assumption set judgements 
bindings map context variables actual contexts variables values note contexts defined modulo equality binding list rules bind bind section 
effect shapes effects types defined modulo context equality 
keep presentation tractable elided rules dealing equalities 
judgements define type system environment binding pair context prp context related effect shape effect type type subtype value type expression type evaluation produces effect meth method class class program shall establish notation means appropriate right hand side 
owner takes owner type classes parameters manifest owner world 
arity number parameters expected class 
owner world owner arity class 
names extracts method names mk tk mk xk 

classname fin map classes field list fieldname fin type 
write fc 
fc gives type field class super classes dom fc gives collection field names 
mt classname methodname map classes method interface type type effect 
mt gives argument variable type method class denoted argument variable argument type return type expected effect 
mt take consideration parameter instantiations occur subclassing 
example flist head link data head link class 
denotes disjoint union finite maps requiring domains disjoint 
substitution substitution 
construction needed accessing field method variable type determining actual types effect type variable type declared class 
convert internal name appear types effects external name 
variable name extend substitution type effect occurring class accessed variable note mechanism behaves correctly internal access 
type empty substitution substitution required 
type rules type rules series fragments description 
rules formed environments omitted standard 
contexts ctx var rp ctx rep ctx world world rule ctx var rule ctx rep permits variable location denote context representation context object referred variable location 
contexts ordered relations refer directly inside strictly inside inside respectively 
notation suggests transitive closure reflexive transitive closure 
relations satisfy inclusions composition defined follows note relations appear explicitly program text key preserving owners dominators property defining effect shapes 
context ordering env rp rp world world weaken prq pr refl rep owner trans rq pr important rule rep populates relations 
states representation context directly inside owner variable type 
rules handle constraints context variables env relational properties refl weaken trans establish world greatest element partial order world 
effect shapes fx fx fx band union fx different kinds effect shape valid contexts scope 
direct refl trans union band rules express simple set theoretic properties effect shapes 
rules interesting 
direct captures contexts levels context included contexts levels context directly 
rule band band context included corresponding context 
rule lifts ordering contexts effects observing effects correspond downward closure captures effect particular level contains deeper effects 
effects fx rd wr basic rd wr rd wr rd wr rd wr rd wr effect formed rule fx valid effect shapes 
rule basic lifts relation effects 
rule captures write effect includes reads effect shape 
types type arity pi pi rule type enforces types constructed class context scope long correct number arguments supplied owner parameter provably inside parameters 
required ensure owners dominators property maintained 
example inside body class iterator type link formed type link formed owner parameter proved inside requirement owner parameter provably inside remaining context parameters matches formedness rule classes class ultimately ensures owners dominators property holds soundness effect disjointness tests see section 
expressive possibilities exist example allowing programmer declare expected relationship context parameters class see author dissertation 
subtyping sub refl sub trans sub class class extends pi 
pi subtyping reflexive sub refl transitive relation generated subclassing sub class account instantiation context parameters 
class list owner data extends object owner derive substitution owner data type list follows list object subtyping permit owner context parameter vary unsound 
seen example class test owner test owner void fiddle writes owner 
assume allowing owner vary permit test test valid subtyping relation 
assume test test aliases 
subtyping relation valid firstly able read write values type test field break encapsulation 
secondly computations fiddle fiddle effects wr wr distinct system refer object 
similar problems arise considered test test valid subtyping 
val null null values val exp val null null type 
val variables locations type declared environment 
rule exp allows value treated expression evaluation causes effect 
notation expression rules write denote effects omit read write part empty denote union underlying components 
expressions exp new new exp exp field fc rd exp update fc wr exp call mt exp sub object creation rule exp new valid type scope produces effect 
exp rule follows usual pattern expressions effects part expression collected 
furthermore additional clauses ensure resulting effect involve local variable mean longer scope 
type field rule declared appropriate class modulo instantiation context parameters substitution 
handle internal variable substitution extended mapping give local variable name 
addition read effect produced context rule exp update employs trick exp field requires value placed field appropriate type 
addition updating field produces write effect context method call rule exp call produces effects latent method declared class 
extended substitution applied effect expression may refer method argument convert terms names scope 
subtyping exp sub follows usual pattern 
variable type list owner data 
type head field class list declared link data head type link data link remains type tracking owner representation object variable discuss briefly scoping rule exp 
consider just types 
type expression new list head link expect type contains longer scope 
expression typed supertype include owner forgotten 
representation escape scope object owns 
short lived dynamic alias 
require effects escape scope variables denote effects global consequence 
consider new list head null subexpression produces effect computation head 
produces effect rd scope expression find suitable includes effect 
effect rd 
note effect rd safe imprecise overestimation expression reads field locally created object 
general appropriate effects encapsulation ought able report effect certain expressions left 
method method rule method premise ensures method body type effect declared propagated downwards rule classes 
may include shapes involving argument enables effects return type defined terms argument variable permitting statement argument read written 
classes class object class object class world owner owner fi dom fc tj names dom mt mt mt class extends tj fj sitting top hierarchy class object single owner parameter 
aspects rule class numbered 
firstly class checked environment consisting unbounded owner parameter number parameters outside 
minimal requirement ensuring owners dominators property soundness 
addition type defined 
secondly extends clause valid type valid requiring constraints imposes satisfied ownership preserved 
thirdly fields declared class distinct inherited fields types formed 
checks methods declared current class okay 
overridden method method type declared current class method type declared superclass naturally prior subclassing account argument return types modulo instantiation superclass parameters effect declared current method effect corresponding method superclass modulo instantiation parameters 
issues illustrated class extends class list associated environment checking class body world associated substitution owner data method redefined 
return type class data data class data requirements satisfied 
effect function effect list wr wr owner 
requirement satisfied 
hand class extending class list illegal proven inside environment requirement satisfied 
class return type data requirement violated 
lastly class effect wr requirement violated 
programs prog class list owner data link data head void add data data writes head new link data head data data writes owner class extends list list void add data writes add data writes 
subclasses example code program formed constituent classes formed 
properties important property satisfied judgements including extension lemma 
states judgements preserved add typings new variables introduce new parameters environment add new bindings contexts variables 
assertion type system remains valid regardless configuration appears long assumptions free variables satisfied 
includes possible configurations may appear evaluation 
giving lemma define means extend environment binding 
definition 
say extends denoted subsequence similarly define lemma extension 
assume right hand form 


clause applicable judgements assumption set 
part lemma corresponds usual extension lemma second part usual substitution lemma meta theory type systems 

dynamic semantics specify dynamic behaviour joe large step operational semantics 
semantics uses heap mapping locations objects bindings variables values just stack 
additional features introduce dynamics joe 
locations addresses objects 
values consist locations null 
objects real owners extend actual contexts locations 
heaps maps locations objects 
objects map field names values carry type 
note contrast usual semantics objects carry type just class extra information substitution represents object owner owners objects reachable object fields 
ownership information directly needed evaluation bindings required proof type preservation demonstrated settings 
heap represented list main world 
data world 
data world head list world data link world null data link world represents main object represent data objects represent list links 
notation denote double lookup location map field object returns 
example 
finite map denotes update binding semantics takes form relations capture basic computations expression evaluation 
computation relation takes computation configuration final configuration 
evaluation relation takes expression configuration final configuration 
function mbc gives body method class triple consisting method argument expression constituting method body map context parameters class method declared contexts visible class required provide correct actual contexts contexts scope evaluation method body turn required provide information proving soundness 
example want call method add object class shall find method body class list need convert context parameters class list context parameters class 
look add giving owner data third component 
hand want call add object class list look add third component equal owner owner data data 
evaluation evaluation effectively java ownership information effect computation 
threaded semantics said facilitate proof soundness 
addition ownership information computational effects recorded 
computation rules null comp null null location value null 
object type fieldname fin value vf dom fc heap location fin object config heap bindings heap value config computation effect config expr effect comp new dom fc new pi mb classname methodname fin var expr cmap cmap fin context comp field rd comp update wr comp call vf dom fc mbc pi pi comp null null evaluates 
object creation adds new location heap bound object appropriate type fields set null 
new object exact type superscript determined looking context variables binding list freshness new location implicit definition 
computation rules looks variable bindings 
field access simply returns value appropriate field object produces effect indicating object read 
similarly field update comp update writes value appropriate field produces effect indicating object written 
complicated rule comp call method call 
firstly target object extracted binding list type determined method lookup performed 
method body evaluated new binding actual context context parameter class method body defined bound location target object method formal parameter bound value bound actual parameter 
dynamic aspects joe example binding owner data world defined creation object type link data evaluates new link data null data null link world calling method add object class list creates new link add head list world data link world note applied usual semantics constructors object creation followed field initialisation 
evaluation rules ev var ev variables require evaluation ev var simply lookup binding list 
expressions ev evaluated performing computation binding resulting value variable adding binding list evaluating expression new heap binding list 
omitted rules trapping errors accessing null field accesses updates method calls objects appropriate field method rules error propagation 
properties evaluation rule comp update clear write effect produced evaluation denotes set locations refer objects written 
easily show lemma states objects reported written remain unchanged evaluation 
lemma 
rd wr rd wr dom dom 
typing enable formulation type preservation theorem need specify formedness dynamic features 
provide type rules bindings giving additional judgements aspects dynamics 
bindings binding context rp rp dom binding value dom bind bind bindings added binding assumptions actual context binding context value binding value satisfied 
rules bind bind introduce equivalences contexts 
note rule bind apply binding null 
additional judgements location object binding heap configuration type produces effect write effect important result configurations 
heap typing object vf dom fc vf fc dom fc heap rule object heap binding formed values object fields typed fields object class 
rule heap states heap formed heap bindings formed 
note object require field value type results substitution substitution object type object required checking context 
environment containing link indicating owner holds 
head list list head list list head list list configuration typing config single rule type different kinds configurations 
rule config extracts binding list configuration uses type expression 
bindings equate variables may appear type effect object correspond 
appears binding prove wr wr obvious equality rules omitted 
effect wr type system anticipates wr actual effect occurs 
able exploit equivalence essential proving type preservation 
type preservation theorem states evaluation preserves type expression computation 
furthermore effects evaluation produces included predicted effect 
theorem preservation 
exists 
similarly soundness explore means effect included effect 
demonstrate soundness rules specifically rules provide interpretation effect shape basic entities ultimately locations denotes 
generating basic shape underlies effect shape 
definition basic 
effect shape basic consists possibly empty union shapes form 
treat basic effect shapes sets 
states basic effects behaves subset lemma 
basic considered sets function generates basic effect shape underlies shape environment binding considered set variables locations shape corresponds 
lemma underlying shape wellformed corresponds precisely collection contexts underlying effect shape lemma 
hold theorem amounts saying sound 
theorem 
important implication theorem preservation lemma actual effects evaluating expression covered effects reported type system corollary 
rd wr rd wr exists similarly easily formulate owners dominators property system 
due space limitations refer readers prior dealing 

disjoint types effects main contributions tests disjointness type effect 
judgements allow deduce facts aliasing effects program rules relying general theorem prover 
types disjoint variables fields having types aliases 
disjointness effect shapes determine expressions potentially interfere show section 
disjointness tests depend simpler test determines contexts disjoint turn may depend disjointness types 
disjointness information stems ultimately number facts representation context object different externally visible contexts rule rep types non overlapping due relative places inheritance hierarchy nesting follows encapsulation objects induces tree shaped partial order objects structure exploited 
disjointness rules defined additional judgements context disjoint type disjoint shape disjoint non interference effects rules designed remain valid valid bindings free variables valid example invalid world world binding world world result world world world world world world clearly false 
disjointness relations symmetric 
space reasons omitted corresponding rules 
disjointness context 
context disjointness rules guarantees contexts disjoint regardless bindings context parameters 
stronger similar notion role separation flexible alias protection 
neq disjointness context type loc dom rule neq context disjointness derived relation informs contexts related equal 
utilise type disjointness rule type give representation contexts variables locations aliases disjoint 
distinct locations disjoint representation contexts loc 
disjointness type 
rules disjointness type rely disjointness class relative positions inheritance hierarchy disjointness context parameter bindings 
disjointness type dtype class extends dtype ctx pi qi pi qi pi qi dtype sub rule dtype class types definitely disjoint classes extend 
types class disjoint rule dtype ctx contexts argument position provably disjoint 
rule dtype sub states subtyping preserves disjointness relation 
consequence rules guiding principle lemma 
lemma 
hold 
different rules required language multiple inheritance interfaces 
basic modification change rule dtype class apply classes interfaces subclasses common 
language multiple inheritance case open world assumption reasoning part program rule comparable dtype class exist 
disjointness effect shape 
disjointness effect shape ultimately relies tree shaped nesting objects shapes depicted guide design 
disjointness effect shape dfx dfx sub dfx union rules dfx dfx sub structural derived simple properties sets 
interesting 
disjointness effect shape ii dfx neq dfx dfx dfx band dfx dfx dfx rule dfx neq states different bands stemming context disjoint 
contexts equal rule dfx band shape containing just context disjoint containing just 
rules dfx dfx give conditions band shape disjoint 
bands levels disjoint rule dfx bands step deeper disjoint 
knowing context directly inside allows precision rule dfx 
final rule captures effects disjoint objects owner disjoint 
corresponds fact contexts form tree subtrees rooted disjoint nodes having parent disjoint 
properties 
interesting fact derived rules 
ultimately states internals distinct objects completely disjoint 
lemma 
assume 

theorems follow combined extension lemma lemma imply disjointness judgement holds regardless bindings free variables 
theorems hold program configuration satisfies initial assumptions valid extension theorems stem states contexts prove disjoint equal theorem context disjointness 
holds impossible 
disjoint types restrict aliasing prove types disjoint impossible variables having types aliases theorem type disjointness 
dom useful corollary theorem evaluation expressions disjoint types produces results aliases corollary 
null corollary formal justification conclude section aliases 
consider declarations list world world shared list world list local prove world conclude shared aliases types provably disjoint 
furthermore conclude internal representation shared head head aliases 
shared head shared head shared head 
alias head head head 

shared head data local head data aliases 
hand shared head data head data shared head data head data type data data may aliases 
application formal reasoning 
reasoning object oriented programs calculating weakest preconditions explicit alias test frequently inserted assertion statements 
alias tests tend cause blow complexity consequent verification 
simple class alias tests reduce complexity somewhat expect alias test offer advantage 
disjoint effects restrict interference soundness effects disjointness amounts showing effects shapes overlap judgements assert disjoint 
show considering underlying basic shape effect shape 
firstly show basic shapes underlying effects shapes provably disjoint basic shapes disjointness relation interpreted disjointness underlying sets 
lemma 
furthermore basic 
consequence results lemma obtain theorem states sets contexts denoted disjoint effects disjoint possible configurations 
theorem disjoint shapes 

define effects non interfering 
definition simple notions data dependence avoiding swapping write read write location 
non interference non interference rd wr rd wr theorem states non interfering effects imply non interfering execution order evaluation expressions disjoint effects immaterial producing results heap 
theorem 
assume exists proof fact semantics relations capture nondeterministic choice names locations newly created objects 
examples 
check evaluation expression affect object considering effect 
prove rd know affect fields prove stronger judgement rd know affects representation 
apply ideas list world list new list world iterator list world iter list examining effects methods modulo parameter bindings obtain method effect list add wr list iter rd list wr iter iter elem rd list appropriate know iter list rep 
iter list 
conclude iter list list rules 
system reflects fact changes list may affect iter course visible inspection method bodies example show method call list add interfere iter 
wr list rd iter proven due inclusion iter list 
system reflects fact calling methods elem iter affect list 
show rd list wr iter rd list 
course show iter affect list representation iter part representation list 
impossible show rd list wr iter rd list 
move different example 
show lists independent show operations respective internal representations interfere 
perform potential optimisations loop fusion 
consider code list world list list world list list add new data world exp list add new data world exp firstly assuming prove list world list world deduce list list aliases 
infer effect produced expression marked exp wr list effect expression exp wr list 
obtaining wr list wr list demonstrate computations exp exp interfere 
permits loop fusion list add new data world list add new data world examples demonstrate type system may help improve tools ranging program understanding optimisation 

related geneva convention treatment object aliasing stressed need better treatment aliasing object oriented programming 
early approaches lead include islands balloons 
focused fully encapsulated objects objects object access accessible outside object 
moving objects encapsulation boundaries required copy assignment defeats object identity destructive reads 
successfully replaced ordinary reads help boyland analysis odd programming style required slippery variables approaches uniqueness require destructive reads :10.1.1.16.5732
systems approach problems caused aliasing read generally employing fixed version const limits computation reading transitive state 
papers describe read help reason programs help write robust software 
boyland noble capabilities system uniformly deal read write ownership capturing notions uniqueness borrowing process 
capability attached limit done 
exclusive capabilities refuse employing capability giving system neat duality 
system express concepts just read write identity ownership exclusive capability exists 
unfortunately apply refers clear semantics especially exclusive effects exhibit non local behaviour 
sophisticated approach dealing aliasing object oriented programming noble vitek potter flexible alias protection 
proposal introduced number important new ideas 
prominent notion representation employ 
secondly classes parameterised call contexts allowing classes different contexts 
classes generic 
addition mode call arg enforce property called argument independence arg limited methods read mutable state 
system lacked inheritance formalised gap remained system properties give formal reasoner 
ownership types devised formalise core flexible alias protection 
apart providing formal system contributed notion owner required give type self idioms allowing arbitrary object graph part object representation formal demonstration owners dominators property 
ownership types explored author thesis context abadi cardelli object calculus 
systems similar ownership types developed independently 
universes ownership types system parameterised classes employs pervasive read 
part modular reasoning system java specify useful frame properties jml 
confined types adopt package level ownership provide better security java 
rinard employ object ownership enable race free java programs lee preventing deadlocks 
type systems offer shallow ownership different form effect sufficient problem address obtain results 
lee rinard extends prior systems guava notion thread ownership flanagan freund classes locks 
incidentally adapts ideas outside object oriented world 
aldrich chambers developed includes shallow notion object ownership uniqueness borrowing method arguments 
include algorithm inferring alias annotations surely adaptable system 
addition results indicate system practical 
banerjee naumann demonstrated advantage having confinement properties java programs 
language include specific means denoting representation ownership types provide able reason incidental representation 
different semantic approach able achieve somewhat deeper results including representation independence 
encouraging result formal demonstration confined representations replaced semantically equivalent ones affecting surrounding program 
seminal dealing interference reynolds syntactic control interference proposal addressed issue parameter aliasing algol programs 
proposal overly conservative 
effects systems overcame limitations initially requiring explicit annotations program analysis 
approach developed region memory management ml programming language 
refinements improvements variations regionbased memory management functional programming languages considered object oriented programs 
back object oriented world leino described modifies clauses interact subclassing enable modular specifications 
approach key modular effects specifications applies finite collection regions called data groups 
greenhouse boyland followed lead designing object oriented effects system specifies read write effects employs uniqueness enables notion representation 
number differences system described greenhouse boyland main difference employ uniqueness ownership alias control results different style programming 
boyland argues object oriented effects system employ uniqueness ownership 
secondly effect shapes slice different depths object graph illustrated theirs slice object groups fields 
kind effects shape added system readily added theirs lack ownership 
final main difference system parameterised context region information theirs 
merging best features fruitful 
yates presents type effect system java 
employs global collection regions allows effect masking expressions trimming effects operate objects accessed outside scope expression 
classes effect owner parameter exploited internally owner parameters notion representation 
type disjointness test part resembles diwan mckinley moss additional ownership information nesting objects available existing programming languages 
sophisticated aliasing analyses exist combined precision 
calculus capabilities uses linearity uniqueness region enable non stack region memory management 
techniques uniqueness region passed method added enhance disjointness tests wish assumptions disjointness class headers method parameter lists 
leavens dynamic dispatch eliminate parameter aliasing 
aim simplify method specifications definite guarantees parameter aliasing available 
system compatible enhance disjointness test considerably provide fine grained form disjointness provide express variables type definitely definitely aliases 
programming language cyclone variant region memory management notion ownership object ownership outlives ordering similar nesting enables memory deallocated provably safe manner avoiding dangling pointers 
subtyping cyclone permits change ownership unsound system demonstrated section 
ultimately types classes cyclone types low level 
type theory underlying cyclone serve fundamental semantics language just author thesis 
designers cyclone expended effort reducing syntactic burden annotations impose programmer 
similar techniques apply indications direction author thesis classes generic 
vault extend manner similar cyclone relying linearity regions 
style requires quite low level annotations techniques may spill object oriented programming 
cyclone vault deal objects consequent subtyping 

extended previous ownership types support inheritance dynamic aliases maintaining owners dominators property consequent strong form encapsulation 
resulting ownership type system added computational effects manner exploiting strong encapsulation 
applied ownership types reasoning absence aliasing effects system reason noninterference computation 
prototype implementation extending features described complete programming language 
main directions 
firstly see closer integration specification language jml associated formal reasoning system 
expect reduce burden reasoning applications java card 
part done universes ownership types system 
secondly wish extend programming language 
firstly include effects masking localise effects expressions 
opens way stack allocable objects objects allocated deallocated manner scoped memories real time java 
addition allowing context parameterisation methods enable notion borrowing useful applications 
acknowledgments 
james noble tobias useful comments earlier versions anonymous referees suggested numerous improvements including example 

mart abadi luca cardelli 
theory objects 
springer verlag 
alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley 
jonathan aldrich valentin craig chambers 
alias annotations program understanding 
oopsla november 
paulo almeida 
balloon types controlling sharing state data types 
ecoop proceedings june 
david bacon robert strom 
guava dialect java data races 
oopsla proceedings pages 
henry baker 
variables linear objects storage management reflection multi threading 
acm sigplan notices january 
anindya banerjee david naumann 
representation independence confinement access control 
proceedings th acm symposium principles programming languages popl portland oregon january 
bruno blanchet 
escape analysis object oriented languages application java 
oopsla proceedings october 
boris jan vitek 
confined types 
oopsla proceedings 
greg james gosling benjamin peter steve mark turnbull 
real time specification java 
addison wesley 
chandrasekhar boyapati robert lee martin rinard 
type system preventing data races deadlocks java programs 
oopsla november 
chandrasekhar boyapati martin rinard 
parameterized type system race free java programs 
oopsla proceedings 
john boyland 
alias unique variables destructive reads 
software practice experience may 
john boyland 
interdependence effects uniqueness 
rd workshop formal techniques java programs june 
john boyland james noble william 
capabilities sharing generalization uniqueness read 
ecoop proceedings june 
bryce 
approach safe object sharing 
oopsla proceedings october 
edwin chan john boyland william scherlis 
promises specifications analysis manipulation 
ieee international conference software engineering icse 
chen 
java card technology smart cards 
java series 
addison wesley 
david clarke 
object calculus ownership containment 
foundations object oriented programming fool london january 
available www cs williams edu kim fool fool html 
david clarke 
ownership containment 
phd thesis school computer science engineering university new south wales sydney australia 
submitted 
david clarke james noble john potter 
simple ownership types object containment 
ecoop proceedings june 
david clarke john potter james noble 
ownership types flexible alias protection 
oopsla proceedings 
karl crary david walker greg morrisett 
typed memory management calculus capabilities 
symposium principles programming languages 
frank de boer 
wp calculus oo 
foundations software science computation structures fossacs volume lncs 
robert deline manuel hndrich 
enforcing high level protocols low level software 
proceedings acm conference programming language design implementation pages june 
david detlefs rustan leino greg nelson 
rep exposure 
technical report src rr compaq systems research center july 
amer diwan kathryn mckinley eliot moss 
type alias analysis 
acm sigplan conference programming language design implementation june 
cormac flanagan mart abadi 
types safe locking 
programming languages systems volume lecture notes computer science pages march 
cormac flanagan stephen freund 
type race detection java 
acm sigplan conference programming language design implementation june 
aaron greenhouse john boyland 
object oriented effects system 
ecoop 
dan grossman greg morrisett trevor jim michael hicks wang james cheney 
region memory management cyclone 
proceedings acm conference programming language design implementation june 
john hogg 
islands aliasing protection object oriented languages 
oopsla proceedings november 
john hogg doug lea alan wills dennis de richard holt 
geneva convention treatment object aliasing 
oops messenger april 
stuart kent john 
value types eiffel 
tools paris 
nter dirk 
jac java transitive readonly access control 
workshop aliasing object oriented systems ecoop lisbon portugal june 
gary leavens olga 
acl eliminating parameter aliasing dynamic dispatch 
technical report department computer science iowa state university ames iowa february 
gary leavens albert baker clyde ruby 
jml notation detailed design 
haim kilov bernhard rumpe ian simmonds editors behavioral specifications businesses systems pages 
kluwer academic publishers boston 
rustan leino 
data groups specifying modification extended state 
oopsla proceedings 
john lucassen david gifford 
polymorphic effect systems 
proceedings eighteenth annual acm sigact sigplan symposium principles programming languages january 

values objects programming languages 
acm sigplan notices december 
minsky 
alias free pointers 
ecoop proceedings july 
greg morrisett robert harper 
semantics memory management polymorphic languages 
andrew gordon andrew pitts editors higher order operational techniques semantics volume publications newton institute pages 
cambridge university press 
ller 
modular specification verification object oriented programs 
phd thesis hagen 
ller poetzsch heffter 
universes type system controlling representation exposure 
poetzsch heffter meyer editors programming languages fundamentals programming 
hagen 
peter ller arnd poetzsch heffter gary leavens 
modular specification frame properties jml 
technical report tr department computer science iowa state university february 
flemming nielson hanne riis nielson chris hankin 
principles program analysis 
springer 
james noble jan vitek john potter 
flexible alias protection 
eric jul editor ecoop object oriented programming volume lecture notes computer science pages berlin heidelberg new york july 
springer verlag 
martin odersky christoph zenger 
nested types 
foundations object oriented programming fool london january 
available www cs williams edu kim fool fool html 
john potter james noble david clarke 
ins outs objects 
australian software engineering conference adelaide australia november 
ieee press 
john reynolds 
syntactic control interference 
th acm symposium principles programming languages january 
mats tobias 
alias control read 
sixth conference computer science informatics march 
bjarne stroustrup 
programming language 
addison wesley 
talpin jouvelot 
polymorphic type region effect inference 
journal functional programming july 
dirk 
enhancing encapsulation oop practical approach 
master thesis institut informatik iii 
bonn universit bonn 
mads tofte jean pierre talpin 
region memory management 
information computation 
mark 
reasoning aliasing 
fourth australasian refinement workshop 
joachim van den berg bart jacobs 
loop compiler java jml 
margaria yi editors tools algorithms construction analysis software tacas lncs pages 
springer verlag 
alan wills 
reasoning aliasing 
ecoop proceedings 
bennett norton yates 
type effect system encapsulating memory java 
master thesis department computer information science graduate school university oregon august 
