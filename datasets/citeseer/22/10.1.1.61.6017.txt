exe system automatically generating inputs death symbolic execution cristian paul vijay ganesh dawson engler stanford university computer systems laboratory engler cs stanford edu systems code defines error prone execution state space built deeply nested conditionals function call chains massive amounts code enthusiastic casting pointer operations 
code hard test difficult inspect single error crash machine form basis security breach 
presents exe system designed automatically find bugs code symbolic execution 
high level running code manually constructed concrete input exe runs symbolic input initially allowed input derived values observed conditional statements checks symbolic constraints incrementally added values 
exe generates concrete test cases solving symbolic constraints concrete values bit level precision 
exe novel features 
implements complete precise symbolic pointer theory correctly handles pointer arithmetic expressions reads writes memory locations referenced pointers symbolic values 
second handles language bit level precision 
third exe greatly amplifies effect running single code path uses powerful constraint solver reason possible values path run single set concrete values individual test case 
exe successfully applied applications ranging running linux kernel symbolically order find numerous security holes ext ext jfs file systems detecting invalid memory reads writes server implementation finding buffer overflow attacks bsd linux packet filter implementations 
systems code defines tricky execution state space built deeply nested conditionals function call chains massive amounts code frequent casting pointer operations 
code process input received directly potential attackers system call parameters network packets memory usb sticks forcing exhaustively vet input 
checks subtle especially presence arithmetic overflows buffer overruns programmers reason poorly 
features conspire manual inspection erratic usual 
random testing faces difficulties 
conditionals equalities bit values hitting exact value satisfy conditional probably require billions attempts 
similarly errors overflow occur narrow input range making finding random test cases 
bugs depend precise layout objects memory complicated interactions heap detection static analysis tools 
describes exe execution generated executions practical symbolic execution system engineered deep automatic checking systems code 
central insight exe code automatically generate potentially highly complex test cases 
running code manually generated test cases exe runs symbolic input initially free value 
code executes data results conditional expressions operations incrementally inform exe constraints place values input order execution proceed path 
time code performs conditional check involving symbolic value exe forks execution adding true path constraint branch condition held false path constraint 
exe generates test cases program constraint solver find concrete values satisfy constraints 
automatically generated inputs fed back code 
exe novel features 
precisely models operations symbolic pointers pointers address values concrete symbolically constrained 
exe correctly handles constraints generated pointer arithmetic expressions involving concrete symbolic pointers concrete symbolic offsets reads writes memory dereferencing symbolic pointer arrays symbolic size 
implementing features involves subtleties may expect 
example concrete symbolic constrained andn conditional expression essentially equivalent big disjunction 

similarly assignment potentially assign element array index name 
design exe precise view concrete heap treats sequence untyped bytes constraints induced observation matter data manipulated pointers manufactured cast 
second exe symbolically executes language bit level precision 
exe works presence unions bit fields casts aggressive bit operations shifting masking byte swapping checksumming 
bit program executing test symbolic represented exactly program memory corresponding symbolic constraint exactly accurate 
program point deterministic program generate concrete solution constraints point re execute program solution execution guaranteed arrive exactly back point concrete values compatible current symbolic constraints 
third exe amplifies effect running single code path constraint solver lets reason possible values path run single set concrete values individual test case 
illustrate dynamic memory checker purify catch bounds array access index pointer specific concrete value bounds 
contrast exe identify bug possible input value path cause bounds access array 
addition arithmetic expression uses symbolic data exe solve associated constraints values cause overflow division zero 
assert statement exe searches possible input values path values cause assert fail 
assert fail input path cause fail bug exe 
fourth system just check values single path forcibly construct input values ideally go paths getting coverage practical reach random manual testing 
conceptually exe offspring static symbolic dynamic concrete execution techniques aim achieve precision testing systematic coverage static methods 
exe works real code 
automatically buffer overruns mature audited berkeley packet filter code linux networking code server 
exe scale large real overly complex systems code 
separate application describe exe symbolically check large chunks linux kernel user level numerous security holes widely linux file systems ext ext jfs data mounted file system crash kernel allow buffer overflow attack 
described aspects exe previous papers 
application mentioned takes exe focuses primarily new security attack exe find errors 
contrast main contribution exe describes detail focusing broader set applications 
second invited workshop initial primitive version system support reads writes symbolic pointer expressions symbolic arrays bit fields casting sign extension arithmetic overflow universal checks 
applied small benchmarks 
main contribution exe system 
exe explicitly designed complex system software combines bit level accurate symbolic modeling code including integer casting sign extension accesses arbitrary pointer casting 
design sound accurate pointer theory handles symbolic pointers supporting arbitrary updates symbolic data blocks including data blocks symbolic size 
discussion exe potential ability verify certain properties execution path set built universal checks designed catch common errors null pointer dereferences buffer overflows division modulo zero 
scalable implementation uses mixed concrete symbolic execution generate test cases real systems code 
experiments demonstrate exe applicability real complex systems code bsd linux packet filter implementations server implementation 
core exe described sections section gives overview section describes model memory bit level accuracy section presents exe support symbolic pointers detail 
remainder discusses practical issues limitations results related concludes 
overview exe implications section gives overview exe 
high level exe automatically generate test cases steps 
user marks memory exe treat symbolic manually inserting calls functions void symbolic obj void symbolic bytes void bytes unsigned nbytes marks entire symbolic second marks byte range starting nbytes symbolic 
cases contents symbolic memory initially treated entirely unconstrained values 
program executes values constraints added solved 
multiple calls functions exe emits concrete values order called 

user compiles program exe compiler exe cc uses cil frontend instrument program symbolic execution 
exe compiler main jobs 
inserts checks assignment expression branch tested program check operands concrete symbolic 
operands concrete operation executed concretely identically operation uninstrumented program 
operand symbolic operation performed passed exe runtime system added constraint 
second inserts code fork program execution symbolic value lead possible actions 
consider 
ifx concrete execution happens normal expression evaluated true true branch taken false branch ifx symbolic exe forks execution system call true path asserts true false path 

rewritten source code compiled normal compiler gcc linked exe runtime system produce executable run 

instrumented code runs forks decision point 
execution program path terminates exe solves path constraints concrete values 
path terminates crashes assertion fails exe detects error 
constraint solutions literally concrete bit values symbolic input cause path execute 
generated response error provide actual bit values concrete attacks launched tested system 
directly causing error output induce system checked correctness comparing implementation inverting result 

concrete inputs fed back tested program test cases 
stage program compiled normal compiler uninstrumented program run exe system 
false positives possible error caught test cases true error false positive due exe mistakes 
analysis literally runs program information known 
main limit technique power cost generality constraint solver 
cvcl decision procedure solver supports things arrays bit vectors arithmetic operations 
fastest solver cvcl powerful successfully applications ranging hardware verification program analysis mathematical theorem proving 
natural question exe cost 
experiments needed hour generate tests trigger errors discuss 
sense happy system run weeks 
long tests exe generates explore paths difficult reach randomly real alternative manual test generation generally speaking impressive results 
tests generated run uninstrumented checked program full speed saved regression runs 
elide discussion straightforward mechanics exe front translation accepts entire language including gnu extensions handled cil lowers form easier exe runtime system handle 
front main limitation instrument inline assembly directives passes uninstrumented 
give detail interesting implications symbolic execution ability perform universal checks 
power symbolic execution universal checks central difference concrete symbolic execution concrete execution operates single possible set concrete values symbolic execution operates values current constraints allow practice modulo power constraint solver 
sym expr div transformation sym expr sym expr query satisfiable fork add constraint return symbolic expression add constraint terminate error div pseudo code symbolic division rewritten universal checking 
include assert include void main void int symbolic assert trivial universal check form correctly invert bit inputs 
universal checks 
exe uses ability provide universal symbolic checks 
symbolic check powerful concrete check checks single specific value symbolic checks check possible values program path 
checks universal sense check passes possible value symbolic input take cause check fail program path 
exe full set symbolic constraints cvcl solve path verified safe possible input values 
best knowledge approach guarantees powerful 
discussed main cases exe misses constraints uninstrumented code called exe constraint progress cases occurs discussed exe performs universal checks integer divisor modulus zero dereferenced pointer null dereferenced pointer lies valid object 
checks follow general pattern front inserts check relevant action division modulus pointer dereference calls constraint solver determine condition occur 
forks execution branch asserts condition occur emits test case terminates false path asserts condition occur continues execution 
gives pseudo code showing mechanically exe null pointer check similar symbolic pointer dereference queries constraint 
memory overflow errors complicated described detail section 
gives example universal checks 
generalized universal checks 
exe turns symbolic expression universal checks values 
having assert detects condition violated specific input exe hits assert systematically search set include assert int main void unsigned symbolic error exe catches potential overflow 
point 
error exe catches div 
point 
demonstrate simple gross casting exe handles arbitrary casting exposition show simple casting 
unsigned value equal point 
error exe catches buffer overflow 
return unsigned return contrived example illustrate errors exe built universal checks catch 
run emit test cases errors 
exe performs accurate memory tracking errors guaranteed despite gross cast false positives arise 
constraints try reach false path conditional 
assert passes exe find input violate 
input lies exe constraint solver ability solve find 
exponentially amplifies domain assertion code just checking single concrete value 
feature conditionals verify function inverts function accomplish simply ask exe search possible input values case example networking code uses byte swap bit values host network order 
shows checking implementation correctly inputs trivial 
note system terminates proved bit inputs opposite direction 
leads startling results correct passing assertion equals full verification total correctness 
applicable verification method practical traditional approach theorem proving plus correctness specifications 
similar fashion ask exe find places routines intended implement function fail making inputs symbolic asserting 
happens commonly networking code different implementations servers exist implementations core networking library functions 
exe cross check search inputs lead incompatible outputs 
find terminates exe verified incompatibilities exist 
bit level accurate modeling memory memory stores exist run exe program concrete store just memory underlying machine flat byte array addressed bit pointers symbolic store resides inside constraint solver 
concrete store concrete operations act includes heap stack data segments 
symbolic store includes set symbolic variables current set constraints addition constants obvious set constraints 
solving symbolic store constraints gives concrete store 
symbolic store describes zero concrete stores zero constraints solution different solutions 
exe accurate bit level solution symbolic store guaranteed valid legal concrete store 
concrete bytes holding concrete values corresponding storage symbolic store 
user marks concrete set bytes symbolic system creates corresponding identically sized range bytes symbolic store 
exe records correspondence hash table maps byte addresses corresponding symbolic bytes 
initially contains memory regions explicitly marked symbolic 
program executes may grow bytes symbolic assigning symbolic expression concrete variable indexing data block symbolic index case discussed section 
cvcl support cvcl nelson oppen cooperating decision procedures framework allows decision procedures quantifier free theories merged decision procedure union theories 
theory deductively closed set sentences starting set axioms sentences formulas language theory free variables 
exe uses theory fixed length bit vectors theory arrays 
theory bit vectors theory finite non empty strings length known priori 
includes standard arithmetic operations division modulo discuss subsection bitwise boolean operations relational operations equal multiplexers provide construct converted logical formula 
bit vector theory distinguished cvcl theories ability efficiently support bit concatenation bit extraction 
concatenation symbolic bit vector variables asym denoted asym 
example concatenation 
extraction sub bit vector bit vector asym starting bit bit denoted asym 
example extracting lower bits 
represent byte symbolic memory bit bit vector 
represent data object array bit elements 
main advantage cvcl bit vectors complete fidelity concrete memory symbolic bit program corresponding bit constraint solver 
property lets express constraints refer bits memory different ways 
result exe views memory completely untyped 
read memory generates constraints static type read int unsigned types persist 
observing bits unsigned access impede subsequent signed access 
accesses performed expected respective constraints conjoined 
having multiple views piece memory crucial handling systems code frequently converts pointers different types pointers integers back 
confuse exe 
benefit bit correspondence exe approximations constraints symbolic store completely accurate systematically explore corner cases resorting giving random choice 
extensions cvcl cvcl original theory bit vectors missing direct support common operations encountered systems code signed comparators sign extension shifts non constant bit vector 
wrote wrappers express terms base operations provided bit vector theory exploiting fact cared limited finite quantities size bits smaller 
example general case complicated give constraints correctly describe shift unsigned value non constant bit vector 
special case bit entities trivial different cases shift greater shift shift shift case explicitly checked handled simply cvcl multiplexer 
occasional speed problems inherent constraint solver tackle np hard problems main limitation cvcl bit vector theory omission division modulo symbolic values 
cases arise constrain operand power potentially discarding certain execution paths replace division modulo operation shift bitwise mask respectively 
plan implement full division modulo circuits version system 
symbolic operations untyped memory operation program assignment branch exe queries hash table check operands concrete 
operand considered concrete constituent bytes concrete 
operands concrete operation performed concretely original program 
operation performed symbolically 
expression symbolic operation constructed way 
read storage location exe checks concrete 
read replaced concrete value 
byte ll exe queries hash table get symbolic expressions associated bytes symbolic expressions concatenated obtain symbolic expression associated replacement expression traversed bottom fashion 
expression form op op denotes operator symbolic expressions sym sym computed order construct esym exe may cast sym sym type operator inferred front 
example add bit bit vector expression obtained example char variable bit bit vector expression obtained example variable bit bit vector expression needs converted bit bit vector expression 
part strategy drive execution corner cases exe attempts force overflow symbolic arithmetic operation 
exe performing symbolic arithmetic operation twice 
precision specified program tested 
second precision produce overflow 
results operations different arithmetic overflow possible exe forks execution adding path overflow possible 
note arithmetic overflow necessary error definitely event worth exploring 
fact mechanism helped find bugs linux packet filter implementation arithmetic overflow cause programmer written bounds check falsely succeed leading simple exploit buffer overflow kernel memory 
note assignment symbolic realm destructive 
concrete assignment overwrites previous value symbolic assignment variable creates new fresh symbolic variable sets equality constraint 
variable may involved previous constraints distinguish new value generated constraints 
example assume assignments 
assignment generate constraint second generate constraint 
point constraints imply false new value assignment prior constraints impact 
modeling scalar casts modeling casts easily done cvcl 
divide scalar casts categories narrowing casts casts larger shorter primitive type widening casts casts shorter larger primitive type 
narrowing casts translated simple bit extraction operations symbolic store 
precisely variable bits cast variable bsize bits exe adds constraint asym bsize order handle widening casts modified cvcl support symbolic sign extension 
define sx asym operator denote sign extension symbolic bit vector asym larger number bits 
variable unsigned sign extension means padding 
signed variable sign extension means padding sign bit padding sign bit 
example sx sign unsigned sx sign signed 
casting lead bugs hard diagnose cast operations intentionally unsafe narrowing casts may introduce bugs lead information loss 
widening signed unsigned value may introduce bugs sign extension signed variable negative result cast large positive number intended 
exe optionally drive execution corner cases caused potentially dangerous casts 
narrowing casts exe checks information lost truncation forks execution different execution paths execution path asserts information lost truncation path information lost 
precisely variable bits narrowed variable bsize bits exe checks constraint sx asym bsize asym widening casts signed unsigned value exe checks sign bit signed variable 
exe forks execution create paths sign bit constrained constrained 
example mapping memory operations cvcl struct header unsigned len char msg header unsigned char buf symbolic bytes buf sizeof buf buf exit header struct header buf header len printf invalid length exit contrived code fragment refers memory differently typed views :10.1.1.112.8742
subsection steps memory constraints gen erated contrived code example receives input symbolic size bytes 
program implements simple filter rejects invalid buffers 
checks th byte value rejects buffer 
casts buffer structure header rejects buffer bigger 
main difficulty symbolically running program buffer buf accessed different ways array char structure type header 
discussed modeling memory bits easy add constraints derived different typed views memory location 
level cvcl code symbolic bytes exe allocates array length having elements bit vectors size readability examples simplified cvcl syntax exe uses cvcl api sym buf array bitvector program refers system finds symbolic cvcl bits associated buf emits symbolic query query sym buf symbolic query return different results valid cvcl prove proposition values inputs invalid 
point code constraints buf equal query true query result 
point exe forks execution adding symbolic constraint assert sym buf true path assert sym buf false 
true path exits ask cvcl generate concrete values current set constraints 
currently cvcl happens generate value buf rest symbolic bytes 
false path continues query header len exe finds finds symbolic bits associated len 
system determines len starts symbolic buf bytes long 
comparison multi byte quantity bit concatenation construct symbolic bit vector corresponding entire byte expression note query values inputs may fact satisfy query just 
show true value query negated 
header len 
exe emits query note order concatenate bytes reflects little endian architecture machine query sym buf sym buf sym buf sym buf query 
constraint buf byte values satisfy query 
system forks execution adding branch constraint assert sym buf sym buf sym buf sym buf path constraint assert sym buf sym buf sym buf sym buf paths reach exit points exe asks cvcl concrete values 
path cvcl generates concrete buf buf buf len bytes 
second cvcl generates concrete value buf len bytes 
symbolic pointers section describes exe implements symbolic memory overflow checks maps memory blocks symbolic store implements reads writes symbolic pointer expressions corner case issues 
symbolic overflow checking exe checks memory overflow pointer expression dereferenced 
tracking memory way similar bounds checking compiler cred 
data object exe records size 
pointer records objects pointer contained 
information exe emit warning program tries dereference pointer outside intended object allowing pointer wander outside object long dereferenced 
exe obtains size data object wrapping standard allocation calls get size returned object object file symbol table get size global data instrumenting function calls get size local variables erased function returns 
text assumes base address object byte returns object size 
exe front simplifies pointer arithmetic expressions pointers integer 
exe tracks base object points recording points inside base object ofq 
assume address pointer returns object pointer points 
shows exe short example 
information sufficient bounds checking 
pointer expression composed parts pointer offset may 
gives completely standard check exe concrete 
shows exe checking ork symbolic 
mapping memory blocks cvcl arrays mirroring promotion scalars exe promotes concrete byte memory blockb symbolic domain allocating byte cvcl array inserting mapping concrete symbolic hash table maps start address 
pointer exe determine corresponding cvcl array lookup base 
cvcl provide pointers 
order emulate symbolic pointer expressions recast array offset 
machinery described previous section original code instrumented code base case direct assignment base object malloc malloc size base assignment possibly derived object 
base base base base optimized away 
base base simple example pointer rewrites 
point outside base object 
char base ub size ub error memory overflow memory overflow check concrete pointer expression 
point outside base object 
char base ub size query ub exists fork assert error solve constraints terminate path 
add constraint ub terminate error array overflow assert error happen continue execution 
add constraint ub pseudo code memory overflow check symbolic pointer expression 
tracking sizes memory blocks 
pointer expression form determine symbolic array refers lookup base compute possibly symbolic offset base object points base add original possibly symbolic offset evaluate symbolic expression 
reads writes symbolic pointer expressions problem symbolic pointer expressions scalars refer different symbolic variables 
example array size bounds symbolic index boolean expression simple essentially big disjunction 
similarly simple array update value ina 
exe handles reads writes pointer expressions pointer offset expression symbolic 
course reads writes concrete pointers offsets performed concretely usual way 
example consider contrived programs figures 
programs execute correctly exe produce assertion violations 
difficulty translating constraint symbolic domain 
symbolic potentially refer element 
exe follows true branch statement constraint added symbolic memory store 
point symbolic store refer possible concrete stores 
program checks fact exe proves true 
assignment creates symbolic store generate different concrete memory stores depending element overwritten 
exe asserts branch statement number possible concrete stores reduced way condition true value array 
include assert int main unsigned char unsigned char symbolic symbolic force bounds exit assert simple example pointer reads include assert int main unsigned char unsigned char symbolic symbolic symbolic force bounds exit assert simple example pointer writes rest discussion loss generality assume techniques previous subsections pointers expressions checked overflow translated corresponding array 
ease exposition loss generality consider reads writes forma cases similar 
main cases reada symbolic concrete easy case 
add constraint th element symbolic memory associated asym equal symbolic memory associated asym 
recall assigning symbolic expression tox symbolic 
symbolic symbolic 
case know element 
add constraint precisely asym size concrete symbolic 
conceptually case implemented identically previous disjunction involves concrete values constants ofa size current implementation cvcl easier faster symbolic array contents fixed constants equal currently ina 
handling case reduces previous case symbolic symbolic 
writes complicated reads 
described section assignment symbolic variable creates new fresh copy 
thing assigning symbolic array asym complication may know array element mutated 
assignment requires steps allocate new fresh symbolic array sym bind sym address constrain elements sym equal old elements asym exception updated element 
cvcl provides support incremental updates efficient versioning similar functional languages 
main cases write forma mirror reads space elide formal notation symbolic concrete 
create sym fresh copy asym elements equal asym element sym constraint sym concrete sym symbolic 
symbolic symbolic 
slightly complicated disjunction expression 
concrete symbolic 
reads reduces previous case symbolic symbolic promoting concrete symbolic domain 
pointers unknown base object situations exe determine base object pointer dereferenced 
base object may allocated uninstrumented code 
second pointer may initialized dereference symbolic pointer usage usually occurs symbolic collection hash table 
base object known exe determine symbolic expression associated symbolic dereference pointer needs value symbolic pointer expression perform dereference concretely 
exe arbitrary symbolic pointer expression copying current execution environment asking constraint solver solution values 
solution copied back original environment added constraint symbolic pointer expression means exe may discard certain execution paths 
mechanism allows exe continue execution base object pointer unknown obviously preferable completely stopping execution 
currently exploring options extending exe support pointers initialized dereference symbolic pointer modify constraint solver keep track base object size symbolic data block single symbolic memory array size sparse represent memory 
data blocks symbolic size exe supports data blocks symbolic size 
lets model memory size determined symbolic input 
cvcl provides efficient support symbolic arrays essentially arbitrary size construct translates directly symbolic constraints 
feature main challenge constructing mapping back concrete store know big data block clear allocate memory concrete store 
fortunately way track data objects lets simple trick solve problem 
exe simply allocates byte concrete memory gives unique base address object unique name refer symbolic array 
array updates reads proceed normal 
practical exe issues section discusses practical aspects exe need special consideration 
summarize main limitations verification show exe interacts instrumented code search strategies employed exe show validate test suite produced exe discuss various configuration options 
limitations verification 
exe system designed find bugs critical systems code 
exe potentially verify certain properties system tested universal checks discussed section main practical limitations may impede verification execution may terminate solving constraints generated application np complete exe may certain symbolic inputs execution paths example encounters modulo operation non power execution may call uninstrumented code exe generate constraints 
uninstrumented functions 
program tested interacts uninstrumented code compiled exe cc system calls calls standard libraries 
calls concrete parameters exe simply calls uninstrumented code original program 
calls symbolic parameters exe problem generate constraints code instrumented 
possible strategy force generation concrete values symbolic parameters making call 
current methodology different designed ensure complete constraint generation 
execution exe logs calls uninstrumented functions symbolic parameters 
approach run exe inspect log subsequently instrument functions recorded log 
iteration repeated uninstrumented calls log 
default exe uses instrumented functions standard libraries 
search strategies 
exe forks execution choice branch follow 
default exe uses depth search dfs 
dfs keeps number current children small linear depth process chain opposed breadth search 
unfortunately dfs works poorly cases 
example exe encounters loop symbolic variable bound dfs get stuck attempt execute loop times possible long time exits loop 
order overcome problem search heuristics drive execution interesting execution paths 
call forked exe process calls search server description current state file line number backtrace blocks server replies 
search server examines blocked processes picks best terms heuristic 
server structured new heuristics simple plug 
current heuristic uses mixture best dfs search 
picks process blocked line code run fewest number times 
runs process children dfs manner 
picks best candidate iterates 
finding bugs exe 
running checked program exe records basic blocks visits 
reaches path generates test case rerun instrumented version program test case verify causes path execute 
check proved useful development exe 
exposed bugs system due errors constraint collection phase cvcl constraint solver generate correct concrete solutions 
configuration options 
exe configuration options easily specified configuration file 
configuration options supported exe include possibility disable certain built checks trade additional checks number visited paths enable various logging mechanisms enable central server caches satisfiability queries specify search strategy specify timeout query sent constraint solver 
results section describes preliminary results 
applied exe packet filter implementations buffer overflows server implementation invalid memory reads writes device drivers code file system implementations kernel panic buffer overflow attacks 
experiments performed modern laptop ran hours completing minutes 
packet filters operating systems variant packet filters allow user level programs typically privileged specify packets desire receive 
prevalent packet filters variants berkeley packet filter bpf system 
bpf filters written pseudo assembly language loaded kernel applications checked bpf system conceptually applied incoming packet 
filters easily modeled exe packet filters contain intricate internal structure interpretation behavior difficult standard testing cover comprehensively 
filter represented array instructions instance bpf isn 
field code represents opcode fields represent control flow data related instruction 
arrays lowered flat ranges bytes easily marked exe symbolic 
struct bpf insn short code char jt char jf bpf int cross checked packet filter implementations current bpf implementation freebsd linux packet filter implementation initially derived freebsd implementation subsequently heavily modified 
exe uncovered buffer overflows freebsd implementation errors linux implementation 
procedure check packet filters exe straightforward mark buffer holding filter holding data packet symbolic call packet filter checking routine buffer holding filter 
routine returns true apply valid symbolic filter symbolic data generating possible data packets valid symbolic filter accepts 
automatic generation packet filters flen bytes testing filters packets dlen bytes performed code create symbolic array encodes packet symbolic bytes filter flen filter represented flen bytes create symbolic array contains bytes packet symbolic bytes data dlen bpf validate filter flen printf accepted filter bpf filter filter data dlen printf accepted data printf rejected data exe discovered conditions buffer overflow freebsd implementation 
errors occured opcode bpf instruction bpf stx bpf bpf mem 
opcodes validate function check instruction offset field legal range 
code shows bpf checks instructions st bpf ld bpf mem valid offsets 
check absent instructions opcodes bpf stx bpf mem check memory operations uses valid addresses 
check forgets stx 
bpf class code bpf st bpf class code bpf ld code xe bpf mem bpf return elided check causes bpf interpreter allow instructions write read arbitrary offsets fixed sized buffer mem crashing kernel allowing trivial exploit pc points current instruction case bpf bpf mem mem pc continue 
case bpf stx mem pc continue linux trickier example 
exe filters cause kernel crash arithmetic overflow bounds check 
legal filters return smallest filters cause errors instructions long various forms loads filters cause error 
bpf ld bpf bpf ind bpf ld bpf bpf ind code bpf ld bpf bpf abs code bpf ret ul bpf causes problem 
instructions eventually lead call function static inline void header pointer struct sk buff int offset int len void buffer int hlen offset len hlen return data offset 
routine parameter thelen parameter 
routine extracts size current message checks len hlen 
large offset signed integer holding sum overflow small value passing check causing large value added message data pointer 
allows attackers easily crash machine 
error easily eliminated fixing bounds check newest kernel versions correct bounds check 
error example power exe hard hit random testing 
furthermore error occurs highly visible widely code demonstrating tricky cases empirically withstand repeated manual inspection 
complete server checked complete networking server implements user space server code clean tested 
run server system marked input packet symbolic restructured loop interacted badly current system 
modified network read call return packet equal bytes 
generated test cases 
reran concrete test cases checked executions valgrind tool dynamically checks types memory corruption storage leaks 
valgrind flagged different errors byte read overflows line similar errors lines errors tested code random testing 
due time constraints currently inspected errors 
device drivers commonly accepted wisdom device driver code higher defect rate core operating system code 
unfortunate reliability perspective device drivers vast majority code linux 
matters worse individual kernel developers test handful drivers limited available hardware 
step improving driver testing created user space test harness device driver initialization cleanup functions tested 
interpose routines inb pci read config word device drivers read hardware leverage power symbolic execution arbitrary values reads 
interpose visible hardware interface able simulate hardware driver reading 
symbolic execution primitive form model checking model potential choices kernel environment memory allocation failing acquiring lock checks user privilege perform action failing 
symbolic inputs constitute control information device driver initialization cleanup routines drives code interesting execution paths 
specifically test driver initialization routine completes successfully allocates necessary kernel resources resources freed driver unload function initialization fails kernel resource leaked 
currently track memory allocations lock state interrupt request line reservations 
run device driver initialization teardown routines testing framework including watchdog timer drivers cryptography modules arc cast joystick driver ethernet driver de 
able successfully load kernel module having device generate failure cases device cryptography modules fail load 
add lines code device drivers get run system 
generated tests apply resource usage checks discussed previously addition running code valgrind 
date errors results preliminary 
file system implementations ext ext jfs previous application exe check mount operation file system implementations ext ext jfs 
approach mark disk symbolic input run mount code file system inside version linux exe instrumented 
bugs file systems malicious data cause kernel panic form basis buffer overflow attack 
dangerous exploit ext ext code allows potential attacker read write arbitrary regions memory 
similar bug bpf bug involves combination events arithmetic overflow exposed help arithmetic overflow mechanism described section buffer overflow detected checker described section 
illustrates exe detecting complex errors require multiple successive events order triggered 
related simultaneously initial dart project developed similar approach generating test cases symbolic inputs 
dart runs unit tested concrete random input symbolically gathering constraints decision points depend input values 
dart negates symbolic constraints generate test case 
dart handles constraints integers random testing pointer constraints usual problems missed paths 
uses randomization initialize pointers pointer symbolic dart randomly sets value address newly allocated memory block 
cute project dart extends dart approach tracking symbolic pointer constraints form null null addition cute correctly tracks constraints formed reading writing symbolic memory constant offsets field field deal symbolic offsets 
example cute shows code snippet error cute fails generate case driven code paths 
contrast dart cute exe completely accurate constraints memory lets check code potentially thoroughly 
bounded model checker ansi programs designed cross check ansi re implementation circuit verilog implementation 
exe uses mixture concrete symbolic execution runs code entirely symbolically 
takes requires entire strictly conforming ansi program translates constraints passed sat solver 
provides full support arithmetic control operations reads writes symbolic memory 
limitations prevent handling systems code 
strongly typed view memory prevents checking code accesses memory pointers different types 
experimenting limit means check program program casts pointers integers back 
second translate entire program sat check stand programs interact environment systems calls calling code source 
limits prevent check code bugs 
loops recursive calls means may bugs exe find may execute symbolic loops times current set constraints allows 
larson todd system dynamically tracks primitive constraints associated tainted data data comes untrusted sources network packets warns data potentially dangerous way 
associate tainted integers upper lower bound tainted strings maximum length string terminated 
potentially dangerous uses inputs array calls string library check integer bounds string violate library function contract 
exe system detect error occur program concrete execution 
system lacks symbolic power exe provides 
exe generate inputs cause paths executed require user provide test cases check paths covered test cases 
compare exe past static checking test generation dynamic bug finding methods 
static input generation 
long stream research attempts static techniques solve constraints generate inputs cause execution reach specific program point path 
nice features static techniques require running code 
theory practice weaker dynamic technique exe access useful information impossible get running program 
static checking 
focused static bug finding 
tools look dramatically different exe 
saturn tool exception expresses program properties boolean constraints models pointers heap data bit level 
roughly speaking dynamic checking runs code limited just executed paths effectively check deeper properties 
examples include program executions loop bad inputs byzantine errors occur formatting command properly obeyed 
errors difficult discover statically 
view static analysis com exe testing lightweight reason apply exe 
software model checking 
model checkers previously find errors design implementation software systems 
approaches tend require significant manual effort build test harnesses 
degree approaches complementary tests approach generates drive model checked code similar approach embraced java pathfinder jpf project 
jpf combines model checking symbolic execution check applications manipulate complex data structures written java 
jpf differs exe support untyped memory needed java strongly typed language support symbolic pointers 
dynamic techniques test input generation 
past automatic input generation techniques appear focus primarily generating input reach path typically motivated problem answering programmer queries control reach statement 
exe differs focusing problem comprehensively generating tests paths controlled input effective exploring state space programs tested 
key aspects exe achieves accurate exact bit level symbolic execution complete pointer theory including mutation symbolic sizes operational view exe semantics support universal checks 
applied exe variety widely mature systems powerful uncover subtle surprising bugs 
ball 
theory predicate complete test coverage generation 
symp 
formal methods components objects 

ball majumdar millstein rajamani 
automatic predicate abstraction programs 
pldi proceedings acm sigplan conference programming language design implementation pages 
acm press 
ball rajamani 
automatically validating temporal safety properties interfaces 
spin workshop model checking software may 
barrett 
cvc lite new implementation cooperating valid ity checker 
alur peled editors cav lecture notes computer science 
springer 
boyer levitt 
select formal system testing debugging programs symbolic execution 
acm sigplan notices june 
bush pincus 
static analyzer finding dynamic programming errors 
software practice experience 
engler 
execution generated test cases systems code crash 
proceedings th international spin workshop model checking software august 
longer version appeared technical report cstr computer systems laboratory stanford university 
chou yang chelf hallem engler :10.1.1.112.8742
empirical study operating systems errors 
proceedings eighteenth acm symposium operating systems principles 
clarke 
hardware verification ansi programs 
proceedings asp dac pages 
ieee computer society press january 
corbett dwyer hatcliff laubach pasareanu robby zheng 
bandera extracting finite state models java source code 
icse 
das lerner 
path sensitive program verification polynomial time 
proceedings acm sigplan conference programming language design implementation berlin germany june 
ferguson korel 
chaining approach software test data generation 
acm trans 
softw 
eng 
methodol 
foster aiken 
flow sensitive type qualifiers 
proceedings acm sigplan conference programming language design implementation june 
godefroid 
model checking programming languages verisoft 
proceedings th acm symposium principles programming languages 
godefroid klarlund sen dart directed automated random testing 
proceedings conference programming language design implementation pldi chicago il usa june 
acm press 
botella 
automatic test data generation constraint solving techniques 
issta proceedings acm sigsoft international symposium software testing analysis pages 
acm press 
gupta mathur soffa 
automated test data generation iterative relaxation method 
sigsoft fse proceedings th acm sigsoft international symposium foundations software engineering pages 
acm press 
hastings joyce 
purify fast detection memory leaks access errors 
proceedings winter usenix conference dec 
holzmann 
model checker spin 
software engineering 
khurshid pasareanu visser 
generalized symbolic execution model checking testing 
proceedings ninth international conference tools algorithms construction analysis systems 
larson austin 
high coverage detection input related security faults 
proceedings th usenix security symposium security august 
engler 
model checking large network protocol implementations 
proceedings symposium networked systems design implementation 
necula rahul weimer 
cil intermediate language tools analysis transformation programs 
international conference compiler construction march 
nelson oppen 
simplification cooperating decision procedures 
acm transactions programming languages systems 
lam 
practical dynamic buffer overflow detector 
proceedings th annual network distributed system security symposium pages 
sar yang engler 
discovering malicious disks symbolic execution 
ieee symposium security privacy may 
sen marinov agha 
cute unit testing engine th joint meeting european software engineering conference acm sigsoft symposium foundations software engineering esec fse acm appear sept 
swift bershad levy 
recovering device drivers 
osdi pages dec 
wagner foster brewer aiken 
step automated detection buffer overrun vulnerabilities 
network distributed systems security conference 
san diego ca feb 
xie aiken 
scalable error detection boolean satisfiability 
proceedings nd annual symposium principles programming languages popl january 

