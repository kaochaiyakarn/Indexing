multilevel multidimensional scaling gpu stephen ingram georgia institute technology thesis submitted partial fulfilment requirements degree master science faculty graduate studies computer science university british columbia november stephen ingram glimmer new multilevel visualization algorithm sional scaling designed exploit modern graphics processing unit gpu hard ware 
gpu sf parallel force subsystem mer 
glimmer organizes input hierarchy levels recursively applies gpu sf combine refine levels 
multilevel nature algorithm helps avoid local minima gpu parallelism improves speed computa tion 
propose robust termination condition gpu sf filtered approximation normalized stress function 
demonstrate benefits glimmer terms speed normalized stress visual quality previous algorithms range synthetic real benchmark datasets 
show performance glimmer gpus substantially faster cpu imple mentation algorithm 
propose novel texture paging strategy called distance paging working precomputed distance matrices large fit texture memory 
ii contents 
ii contents 
iii list figures 

vii disclaimer 
viii 
previous 
classical scaling 
distance scaling nonlinear optimization 
distance scaling force simulation 
gpu layout approaches 
glimmer multilevel algorithm 
multigrid multilevel terminology 
multilevel algorithm 
multilevel parameter selection 
gpu considerations 
iii contents iv restriction 
gpu stochastic force 
gpu friendly mds 
stochastic force algorithm 
termination 
average point velocity 
sparse normalized stress 
stochastic force gpu 
scalability distance matrices 
paging feeding performance 
results discussion 
complexity 
performance comparison 
datasets 
layout quality 
speed stress 
summary 
comparing distance classical scaling 
gpu speedup 

bibliography 
list figures mds case studies 
multigrid glimmer diagrams 
pseudocode glimmer algorithm 
stress timing results decimation factor tests 
stress results minimum set size tests 
timing results minimum set size tests 
filtered unfiltered velocity signals 
physical signals comparison 
stress sparse stress iteration 
gpu sf algorithm stages 
gpu sf algorithm textures 
gpu sf texture memory requirements 
gpu sf memory limitations 
graph layout distance feeder 
mds layout comparison 
glimmer versus layout 
grid stress timing graphs 
shuttle stress timing graphs 
list figures vi docs stress timing graphs 
log log stress versus time scatterplots 
classical scaling distance scaling simplex layouts 
glimmer cpu versus gpu speed 
glimmer gpu speedup 
gpu startup overhead costs 
required far labor originally estimated 
personal projects help key indi 
obviously supervisor munzner key development 
rigorous standards efforts importantly hu mor thesis showcase 
credit bringing aboard supervisor marc 
marc sound creative insight repeatedly simplified enriched algorithm thesis 
colleagues info vis group ubc great source ideas constructive criticism friendship 
long suffering companion kelsey daughter eleanor 
transformed adventure 
vii disclaimer material contained thesis submitted publication stephen ingram munzner marc glimmer multilevel mds gpu submitted publication 
viii chapter multidimensional scaling mds technique dimensionality reduction data measured high dimensional space mapped lower dimensional target space minimizing spatial distortion 
mds inherent dimensionality dataset conjectured smaller dimen measurements 
dimensionality reduction commonly information visualization applications low dimensional target space points space drawn directly hopes helping people understand dataset structure terms clusters proximity relationships interest 
mds reduction algorithms 
include isomap locally linear embedding lle gaussian process latent variable models 
mds goal find coordinates points low dimensional space low dimensional distance di points close possi ble corresponding high dimensional distance dissimilarity input consist high dimensional points computed coordinates distance matrix allowing arbitrarily complex distance metric 
example mds produces meaningful results consider dataset wisconsin breast cancer database contains points representing tumors measurements tumor cell uniformity clump taken uci ml repository www ics uci edu mlearn html chapter 
mds layouts may reveal useful structures tumor dataset wisconsin breast cancer database blue represents benign red represents malignant 
typical mds usage color labels exist proximity relationships clusters discern classification 
thickness 
say dataset dimensional distance tumors euclidean distance dimensional points constructed measurements tumor 
shows resulting visualization dataset mds map data dimen sions 
shows points tumors belong tightly clustered low variance group part spread higher variance cluster points 
color points ground truth labels show blue points benign tumors red points malignant tumors 
instance strong correlation spatial observed applying mds latent feature data 
alternatively mds may result loss distortion structure 
exam ple consider dimensional dataset constructed regularly sampling points surface sphere 
embedding dataset di distortion sphere intrinsic dimensionality 
mds algorithms minimizing objective function dis high dimensional embedding distances 
standard stress error metric normalized stress metric chapter 
stress di significant cost compute points dataset 
embedded distances match original distances data stress 
stress larger spatial distortion embedding original data increases 
mds algorithms vary precisely form stress function takes minimize stress function 
approximate exact iterative completely analytical 
diversity algorithms leads diversity quality results speed computed 
section gives brief overview various relevant classes existing mds algorithms underlying characteristics 
class mds algorithms significant influence information visualization class iterative force directed algorithms 
algorithms data points modeled particles space attached particles springs ideal length proportional original distance 
algorithm com simulation integrating forces physical system settles state minimal energy 
point computation halts final positions particles assigned resulting coordinates data 
na implementa tions algorithms computationally expensive prone converge local minima 
substantial improvements iterative class mds algo rithms simulated forces 
improve algorithm speed exploiting modern pc graphics processing unit gpu computational engine 
second introduce cheap reliable linear time termination condition convergence approximation normalized stress function 
chapter 
devise simple multilevel strategy demonstrably helps avoid local minima 
compare resulting algorithm called glimmer wide variety mds algorithms showing advantages approach terms speed accu racy 
algorithm applicable produce output dimensions implementation scales embeddings dimensions 
discuss rich previous chapter core ideas glimmer multilevel algorithm gpu sf algorithm chap ter 
cover gpu considerations chapter providing details gpu algorithms 
chapter propose algorithm handling general case high dimensional distances necessarily euclidean 
chapter compare glimmer mds algorithms terms com plexity speed quantitative accuracy respect stress error metric qualitative accuracy layouts datasets ground truth known shape clustering 
chapter previous foundational ideas multidimensional scaling proposed young householder developed torgerson name mds 
considerable research gone devising faster ro bust solutions 
interests space focus foundational commonly employed categories current techniques classical scal ing methods distance scaling nonlinear optimization distance scaling force directed approaches 
descriptions number points dimensionality low dimensional target space dimensionality high dimensional input space 
classical scaling classical scaling methods compute exact approximate analytical solutions global minimum strain function strain xx matrix coordinates low dimensional configuration called centering matrix centers high dimensional coordinates origin 
underlying distances distance matrix euclidean transformation distance chapter 
previous matrix inner product gram matrix 
minimizing distances stress classical scaling minimizes discrepancy inner products 
strain closely related stress may different minimum 
spectral methods find embedding coordinates computing top eigenvectors sorted decreasing eigenvalue 
classical scaling equivalent principal component analysis popular dimen reduction method coordinates centered origin normalized largest distance equal 
original algorithm classic mds computed costly singular value decomposition matrix 
modern classical scaling methods quickly estimate eigenvectors power method sophisticated iterative methods employ matrix vector products 
host nystr methods proposed avoid computation altogether subset matrix approximate eigenvectors 
include fastmap landmark mds pivotmds 
pivotmds exemplar glimmer performance comparison section shown accurate classical scaling approxima tion algorithm 
techniques achieve dramatic speed improvements reducing complexity classical scaling essentially 
section discuss limitations approaches handling sparse high dimensional datasets visualization glimmer approach distance scaling yields higher quality layouts cases competitive speeds visual quality equal 
chapter 
previous distance scaling nonlinear optimization optimizing stress function gradient descent find low error embed ding pioneered kruskal 
optimization approaches easily rate weights emphasize certain types distances handle missing values gracefully way difficult spectral methods 
clas scaling methods optimization approaches subject local minima 
de leeuw accurate algorithm monotonically converges station ary point minimizing quadratic approximation stress function iteration resulting provably linear convergence large cost iteration 
gansner approach stress ma graphs sparsification edge weighting modifications propose suitable general mds general data topology un known 
computing nearest neighbor topology general datasets naively pre processing procedure 
accelerations technique straight forward apply high dimensions due fact nearest neighbor graph generated trees farthest point sampling may connected 
multigrid mds algorithm employs multigrid method discretized optimization problems relaxation operator terminating small constant number iterations 
hierarchical approach helps avoid local minima substantial speed improvements sma cof scalability limited layout points seconds requiring precomputation data topology 
inspired power hierarchical multigrid approach design glimmer different operators multigrid operations restriction relaxation interpolation described detail section 
chapter 
previous distance scaling force simulation force mds algorithms mass spring simulation optimize stress function generating forces proportion residual low high dimensional distances 
kind nonlinear optimization point computes linear estimate gradient moves fixed length integration time step 
previous underlying ery force simulation approach different standard nonlinear optimization warrant category 
methods intuitive stand easy program support weights interactivity typically pro duce lower stress results classic mds 
drawbacks include numerous parameters physical system damping constants time step size oscillatory minima possibility local minima 
force simulation mds tangentially related particle simulation algorithms 
body particle simulation accelerations barnes hut fast multipole method rely force models forces entirely generated configuration embedding space 
distance scaling forces come difference configurations different spaces original dataset space low dimensional embedding space accelerations proposed methods applicable 
basic force directed approach complexity cost iteration iterations 
discuss lurking assumptions surrounding iterations section 
cpu stochastic force approach introduced chalmers reduces iteration cost total cost 
stochastic algorithm subsystem refinements complexity logn 
glimmer uses gpu variant stochastic approach gpu sf improved termination condition chapter 
previous subsystem 
discuss limitations respect accuracy convergence 
compare glimmer approaches chapter 
gpu layout approaches gpus shown improve speed general purpose algorithms including graph layout classical scaling previously applied minimizing stress function directly 
reina ertl proposed gpu version fastmap algorithm clas scaling approximation algorithm achieving considerable speedup cpu implementation 
technique accelerates mapping low di space 
initial computation high dimensional distances part nystr algorithms sped 
tal take advantage gpu parallelism increase speed dynamic graph layout algorithm 
force directed graph layout deep similarities force directed mds 
edge collapsing coarsen ing stage relies graph topology input require tion nearest neighbor graph general case arbitrary mds data 
energy function compute gpu ignores pairwise distances minimize stress 
cpu initial placement spatial partitioning glimmer runs stages entirely gpu 
discuss suitability previous algorithms speedup gpu parallelism section 
chapter glimmer multilevel algorithm glimmer force mds algorithm uses recursive hierarchical frame improve accuracy reduce computation 
hierarchical mds algorithms glimmer specifically designed exploit gpu parallelism stage algorithm 
multigrid vocabulary inspired methods call algorithm multilevel final formulation differs strict definition multigrid algorithms 
multigrid multilevel terminology description multilevel hierarchy consider highest level input data lower levels nested subsets data reduced size fixed decimation factor 
multigrid methods operators level restriction relaxation interpolation shown 
loosely speak ing restriction performs decimation build hierarchy relaxation core computation operator reduces error specific level tion passes benefit latest relaxation computation level 
typical multigrid methods called cycle restriction relaxation inter repeated times 
glimmer operators designed converge single cycle 
restrict chapter 
glimmer multilevel algorithm interpolate relax multigrid algorithms restrict relax interpolate glimmer algorithm relax reuse gpu sf multigrid glimmer diagrams 
multigrid cycle 
glimmer multilevel algorithm 
restriction operator builds hierarchy sampling points 
gpu sf relaxation operator level points allowed move interpolation operator points newly added level allowed move 
lower levels complex layouts higher levels converge quickly computation lower levels 
multilevel algorithm shows diagram glimmer multilevel algorithm single cycle 
pseudocode 
restriction operator construct multilevel hierarchy simply extracts random subset points current level 
glimmer decimation factor level size lowest level points 
parame ter choices empirically chosen analyzing speed quality behavior decimation factors powers variety minimum set sizes final choices 
traverse upwards top alternating runs current level interpolating results level 
traversal stochastic force relaxation operator form iterations stochastic force mds algorithm gpu sf points particular level system converges 
surprisingly stochastic force algorithm interpolation operator 
fix locations previously relaxed points moving just newly added points fit current configuration 
interpolation step stochastic force sub chapter 
glimmer multilevel algorithm system converges 
continue traversal freeing fixed points relaxation step 
halt running relaxation operator highest level contains points 
low levels small subset points involved com putation system converges quickly 
higher levels converge erations points placed lower levels close final positions 
particular relaxation step highest level running stochastic force points input dataset system converges quickly stochastic force algorithm run points random initial positions 
glimmer terminates completing single cycle 
average total time required levels glimmer multilevel ap proach roughly stochastic gpu sf force algorithm shown 
major difference glimmer gpu sf subsystem accuracy convergence 
multilevel mer approach successful avoiding local minima give rise twisted manifolds low dimensional placement shown 
sus local minima cited weakness force methods multilevel approach atop force subsystem allows accurate global structure point set cheap iterations lower levels 
higher levels local structure refined global context inherited lower levels interpolation 
gpu sf falls local minimum glimmer avoids gpu sf may terminate quickly visually unacceptable results 
chapter 
glimmer multilevel algorithm restrict return return converged glimmer return glimmer emptyset pseudocode glimmer algorithm 
multilevel parameter selection section describes method determining appropriate values dec imation factor minimum set size parameters 
construct sets test values parameter set 
construct cartesian product sets run glimmer element input parameters series cardinalities different datasets recording time final stress run algorithm 
stress timing data directly compare effects ranges multilevel parameters stress time different datasets 
shows effect different decimation factors stress timing range randomly sampled cardinalities real world dataset shuttle described section 
different size samples dataset simultaneously observe sensitivity parameter choice ini tial random configuration dataset size 
parameter choice exhibits noise stress output stress local min chapter 
glimmer multilevel algorithm ima visually different 
observe spikes stress function indicating presence noticable local minima 
stress metric sensible choices parameter relatively stable convergence behavior 
looking timing graph correct choice param eter value clearer 
algorithm suffers noticable time penalty 
likewise significant spikes appear 
related spikes stress 
comparing running times observe performance improvement approximately seconds 
observed behavior parameter independent dataset minimum set size parameter similarly shows effect different minimum set sizes final stress cardinalities dataset docs see section 
add final stress gpu sf data compare stress convergence behavior 
noticeable plateau stress results gpu sf indicates convergence local minimum 
set mini mum set size region suboptimal convergence pattern disappears 
illustrates small possible 
datasets smaller shown noticable perfor mance penalty multilevel approach 
interests maximizing speed smaller datasets useful value large possible 
require user find regions prone local minimum empirically observe gpu sf prone local minima datasets cardinality greater 
chapter 
glimmer multilevel algorithm gpu considerations glimmer algorithm run cpu implemented opti mized java prototype proof concept allow direct timing comparisons 
restriction relaxation interpolation operators carefully designed exploit gpu parallelism 
gpu affect conver gence accuracy brings dramatic speed improvement previous mds approaches 
modern gpus user programmable pipeline highly parallel processing stages called shaders 
stage operates stream vertices second stage operates stream geometry final stage operates stream pixels 
gpu pixel processors considered single instruction multiple data simd unit operating parallel subset pixels stream simd batch size varies gpus 
units random read write access data stored texture memory textures place arrays 
computation occurs textured polygon rendered shader 
typical computations take multiple rendering passes communication channel processing units writing texture pass reading pass 
porting general purpose algorithms graphics hardware subject certain pitfalls 
example memory accesses common bottleneck gen eral purpose gpu programs 
number accesses shader program execution gpus kept relatively small constant avoid performance problems 
discuss pitfall impacts choice mds subsystem section 
glimmer gpu sf general approaches depend specific hardware features particular gpu 
nvidia gpus handle shader types shared set simd clusters programmed chapter 
glimmer multilevel algorithm general purpose parallel called 
algo rithms implemented operate generations gpus generic model gpu processing 
algorithms run card supports pixel shaders compare speeds different generations cards section 
restriction restriction operator creates multilevel hierarchy nested subsets input data randomly sampled enclosing set 
run cessing step randomly permute input data cpu loading texture memory gpu 
easily access nested rectangles texture memory solve sampling problem 
traversing hierarchy bottom top second leg cycle handled enlarging size render ing polygon shader code extra storage required create hierarchy levels 
solution avoids need random sampling gpu slow 
restriction operator require explicit extra computation specifically rely having geometric locality information 
contrast previous multigrid mds approach carry preprocessing step find nearest neighbors high dimensional space 
approach high dimensional neighborhoods point gradually discovered stochastic interpolation relaxation operations 
final normalized stress time chapter 
glimmer multilevel algorithm cardinality cardinality stress timing results decimation factor tests 
graph showing effect decimation factor final stress configuration computed glimmer range random samples dataset 
observe spikes representing local minima 

graph showing effect decimation factor final time range dataset cardinalities 
observe fastest average convergence time 
final stress chapter 
glimmer multilevel algorithm dataset cardinality gpu sf graph shows effect final stress different values glimmer minimum set size parameter range randomly sampled datasets 
included final stress results gpu sf data 
processing datasets points gpu sf regularly terminates local minimum 
setting minimum set size region help avoid problem 
time ms chapter 
glimmer multilevel algorithm cardinality graph shows effect convergence time different values glimmer minimum set size parameter randomly sampled range small dataset 
larger datasets increasing relatively imperceptible datasets effect significant motivates need maximize chapter gpu stochastic force gpu sf gpu friendly stochastic force mds solver subsystem glimmer inspired chalmers algorithm 
gpu acceleration gpu sf algorithm nearly identical runtime characteristics cpu chalmers 
differences new termination criteria propose asymmetric force calculations 
gpu friendly mds glimmer relaxation interpolation operators benefit rapid execution simple mds subsystem propose gpu friendly mds algorithm 
general algorithms iterations exploit form sparseness perform best graphics hardware 
sparse mean limited number computations non local accesses point number far total number points restriction immediately mds algorithms reliance dense matrices submatrices matrix matrix matrix vector operations 
traditional force mds dense point access point compute force 
hand accelerated mds algorithms exploit sparse ness may fail achieve accuracy certain datasets 
example pivotmds landmark mds parent finding approaches accelerated force directed chapter 
gpu stochastic force mds achieve speedups considering subset rows input distance matrix 
distance matrices frequently exhibit considerable re algorithms may discard important information selection rows 
identified stochastic force algorithm especially appropriate requirements 
point small fixed set points iteration step selection fixed set limited subset input 
single iteration stochastic force algorithm point performs constant amount computation accesses constant number points regardless dataset size 
stochastic force algorithm stochastic force algorithm iteratively moves point stable state reached forces acting point stochastic sampling sum pairwise distance residuals 
specifically sets small fixed size maintained point near set random set 
forces acting point computed pairwise distances points associated sets 
set initially contains random points 
iteration members random set high dimensional dis tance point near set swapped near set 
random set replaced new set random points 
iterations near set converge actual set nearest neighbors 
retention nearest known neighbors effect maintaining topology data embedding space random set functions means resolving near set maintaining global structure dataset embedding space 
chalmers proposes random set size near set chapter 
gpu stochastic force size 
size set match element vector types supported gpu 
force simulation algorithm stochastic force integration method parameters 
euler integration time step force velocity 
normalize sum forces size factor near random 
furthermore dampen forces computing relative velocity vector point points near random sets scaling damping factor subtracting force vector vertices 
termination previous iterative mds algorithms explicit termination cri depend user monitor layout progress halt compu tation deemed appropriate 
gpu sf algorithm subsystem glimmer need quickly automatically determine cor rect time terminate computation 
approaches computation run fixed number iterations usually linear convergence proven algorithm generally assumed force directed approaches 
show chapter assumption safe frequently leading overkill wastes time halts computation layout accurate 
standard termination criterion nonlinear optimization terminate gradient function converges zero 
mds criterion implies difference iterations stress error metric equation converges small number 
computing stress configuration requires computations 
producing value iteration far chapter 
gpu stochastic force expensive glimmer algorithm 
remain speed competitive algorithm needs termination condition requiring computations 
devised evaluated different approaches average point ity sparse approximation stress function 
sparse stress approximation proved superior termination condition exhibits monotonic behavior multilevel context 
average point velocity previous algorithms morrison subquadratic mds algorithm termi nate checking change velocity particle system iterations falls beneath fixed threshold 
linear time function returns sum total velocities particle computed part force simulation 
set units velocity number pixels embedding layout traversed second 
strategy inherent problems 
magnitude system velocity dependent pre cise number particles system 
normalize signal dividing total velocity number active particles system 
second velocity system noisy subject oscillations damping 
solve problem low pass filtering signal specifically windowed sinc filter 
third single fixed termination threshold problematic context multilevel algorithm 
appropriate convergence threshold low level algorithm may high low level 
initial stages glimmer algorithm generally highest energy stages see lower changes velocity making just qualitative progress 
solution problem set threshold fraction highest chapter 
gpu stochastic force graph normalized velocity iterations gpu sf algorithm grid dataset 
filtering high frequency noise signal low frequency noise resulting non monotonicity signal 
phenomenon normalized point velocity undesirable choice termination condition 
average velocity observed level 
low algorithm waste time cycles 
high algorithm terminate soon 
useful compromise 
fourth difficult problem system velocity termination criteria low frequency behavior observed signal removed low pass filter 
shows velocity signal behavior 
conjecture large scale oscillation result asymmetry forces applied algorithm randomness neigh bor selection process system ultimately spring forces 
cause non monotonicity termination condition poses difficult chapter 
gpu stochastic force problems detecting system convergence 
eliminating oscillations fil tering require window large algorithm spent computing convolutions far iterations spent stage algorithm computing signal fill window frequently signal converged 
tried heuristic detecting false convergence presence non monotonicity 
detect oscillations checked positive slope exists window smaller window detect convergence 
positive slope exists ignore convergence 
ad hoc solution ultimately proved sensitive heuristic window size parameters required ad different datasets 
examined physical characteristics system hopes finding appropriate inexpensive termination condition 
average force system defined average sum active point forces 
computing involves summing computed force values 
second average displacement 
computing displacement window iterations requires storing set previous iterations layout coordinates subtracting dth oldest set current coordinates summing absolute value results 
shows graph sig respect raw system velocity filtered velocity normalized velocity stages glimmer run 
normalized velocity force displacement exhibit essentially identical behavior making obviously superior termination criterion 
sparse normalized stress approximation stress call sparse normalized stress differences distance values computed 
specifically pixels pixels pixels relax chapter 
gpu stochastic force filtered velocity normalized velocity average acceleration filtered acceleration normalized acceleration displacement interp 
interp interp relax relax relax relax interp iterations behavior physical signals simulation glimmer run 
signals share characteristics useful linear time termination condition 
glimmer relies sparse approximation stress function 
sparse normalized stress defined near random di near random near random union index sets point requiring computations compute stress configuration 
contents sets change iteration sparse stress value noisy making raw function values inadequate convergence 
remove noise treat sparse stress signal apply temporal low pass filter windowed sinc implementation 
resulting smooth sig normalized stress measure chapter 
gpu stochastic force sparse normalized stress normalized stress filtered sparse normalized stress iteration stress sparse stress iteration 
gpu sf uses sparse approximation green normalized stress function orange converges simultaneously requires minimal overhead compute 
lowpass filter red noise unfiltered signal larger convergence threshold 
nal closely mimics behavior true normalized stress function shown 
interested behavior derivative stress function function convolve sparse stress signal derivative low pass filter 
optimization follows theorem deriv deriv deriv convolution operator deriv represents derivative 
algorithm terminates comparing filtered signal directly 
chapter 
gpu stochastic force empirical testing datasets arrived value iterations low pass filter window 
termination criterion controls accuracy layout experiments chose 
linear time termination criteria benefit iterative mds algorithm relying convergence stress including chalmers algorithm subsystem 
stochastic force gpu gpu sf version stochastic force algorithm runs gpu series pixel shaders data storage texture memory 
stage gpu sf updates random index set point 
set high low dimensional distances computed fetched 
information reorganized update near index set 
final series steps uses information calculate proper force apply point move accordingly 
control shifted back step termination condition triggered 
order minimize gpu overhead system constraints gpu sf quite different organization code data original chalmers algorithm 
point stochastic force algorithm maintains fixed size cache state information low dimensional position near set membership 
point state information divided vectors tables stored texture memory textures 
lists textures store information sizes elements stored textures 
smallest unit texture memory pixel containing bit floats number pixels devoted element equal ceiling number floats divided 
point vectors high low chapter 
gpu stochastic force stage passes pixels input textures output textures random update ni perm index distance calc log ni index scratch scratch distance calc log ni index scratch scratch near sort ni index index force calc ni index scratch velocity velocity calc ni scratch velocity position update ni velocity termination check log ni ni scratch scratch gpu sf algorithm stages 
gpu sf algorithm carries single layout iteration stages 
list number rendering passes stage requires number pixels affected pass textures read input arrays textures written output arrays 
stages repeat termination check succeeds 
dimensional position points 
element size floats dimensionality high dimensional space 
size floats element dimensionality low dimensional space glimmer 
velocity texture keeps track point velocities low dimensional space size floats 
tables entries divided chapter 
gpu stochastic force tex name size pixels description high point coords low point coords velocity point velocity index near random set indices high distances pts index low distances pts index perm random number resource scratch holds temporary results gpu sf algorithm textures 
gpu sf algorithm uses textures storage 
table lists texture algorithm size pixels elements dedicated point brief description purpose texture 
equal sections points near random sets 
textures contain high low dimensional distance point question items near random sets 
index table contains pointers items sets 
total size bytes texture element size pixels floats pixel bytes float number points input dataset 
textures resources computation 
perm texture con tains permutation indices precomputed cpu total size hn scratch texture intermediate storage 
information packed dimensional textures follows 
com pute number pixels element 
compute total number pixels required store data best fit number pixels square region compute ceiling square root number pn 
unfortunately may produce texture dimension divisible width element may force wrap element chapter 
gpu stochastic force row texels 
eliminate phenomenon divide width element take floor result 
final width pixels texture 
compute height texture just divide total number points number points row round 
packing remaining textures assume elements wide 
strategy addressing point data uniform textures 
summarizes organization gpu sf showing stages textures update 
single iteration step carried log texture rendering passes 
number pixels ni pro cessed pass approximation total involved 
gpu sf invoked subsystem glimmer memory footprint textures function entire dataset size number pixels processed pass changes depending glimmer level 
stage step gpu sf update random section index set perm 
acquire new random indices sampling location resource determined iteration permutation array cardinality point iteration iteration number 
strategy inspired perlin noise algorithm 
stages need compute euclidean distances high dimensional space 
distance metrics possible distance matrices 
discuss distance matrices glimmer chapter 
indirectly points index set compute dif ferences points current storing scratch texture 
square item scratch sum put square root number 
fast approach summing values chapter 
gpu stochastic force gpu reduction shader takes log passes far cheaper loop ing values 
similar computation produces log passes 
stage updating near set points random closer slightly tricky 
simply sort distance pick near set item appears near random duplicated near set 
sort index mark duplicates having infinite high dimensional distance resort 
sort textures index twice rendering passes combining duplicate marking operation sorting pass 
stage force calculation compute vectors point near random sets index look low dimensional positions 
scale vectors difference velocity texture damping 
damping designed excessive particle oscillation improve convergence 
damping scheme computes relative velocity vector vertex indexed vertices subtracts force vector vertices 
sum damped force vectors save resulting vector scratch texture 
stages integrate scratch forces velocity pass integrate velocity update pass 
integrations done euler integration parameters mentioned section 
stage final step algorithm checks termination condition 
calculate normalized sum squared distance differences minus chapter 
gpu stochastic force termination condition log rendering passes reduc tion shader scratch 
factor pixel size indicates size reduction factor pass total ni pixels processed 
chalmers algorithm forces applied symmetrically points point affected forces near random sets forces points contain near random sets 
gpu sf version forces applied points near random sets point vice versa 
abandon explicit symmetry require scatter random access write operation supported current gpus slow memory intensive workarounds 
effect symmetric forces emerges implicitly near sets neighboring points ally converge include 
chapter scalability distance matrices discussion far assumed input mds algorithm points high dimensional space desired distance metric euclidean 
case high dimensional euclidean distances computed fly part mds algorithm 
calculation high dimensional distances expensive stages mds algorithms euclidean distance straightforward cheap metrics compared possibilities 
applications required distance metric may costly com plex compute doing fly time feasible example earth mover distance images 
cases direct access formulation points high di space available data pairwise distances 
cases mds algorithm accept precomputed distances input data typically precomputed distance matrix 
naive approach store matrix texture graphics card 
texture called replace 
distance matrices symmetric need store entries 
gpu sf algorithm copy proper distances dur ing stage computing high dimensional coordinates making chapter 
scalability distance matrices number passes stage log reduce size elements scratch texture pixels pixels element size required computing low dimensional embedding distances dimension stage gpu sf algorithm 
compare texture memory requirements euclidean case case store distance matrix texture memory 
gives size pixels individual elements texture euclidean case 
element size entries table guide dataset points dimension texture requires allocating texture pixels 
pixel floats float bytes requires bytes texture memory 
proceed multiply texture element size gathered texture glimmer computing total size texture bytes store sizes 
sum sizes bytes textures yields number total number bytes texture memory required glimmer algorithm case computing euclidean distances fly coordinates dimension derive maximum number points dimension glimmer compute card mb texture memory solve equation get 
theoretically fit points texture memory 
computing total texture memory needed case store distance matrix requires changing values 
replace total number bytes required chapter 
scalability distance matrices texture name total texture size bytes velocity index perm scratch sum total gpu sf texture memory requirements 
gpu sf algorithm uses textures storage 
table lists texture algorithm case euclidean distances computed fly respective sizes bytes texture memory 
store floats texture 
second element size scratch changed pixels total size scratch texture bytes 
total number bytes required glimmer points distance matrix case bytes 
derive maximum number points glimmer compute method card mb texture memory solve quadratic equation get theoretical maximum points 
case distances computed fly doubling memory mean doubling number points handled 
card mb texture memory cal maximum points 
clearly storing entire distance matrix graphics card problems 
scalable solution exploits precomputed tions handling stochastic operations 
methods call distance pag chapter 
scalability distance matrices ing distance feeding solve texture memory scalability problem quadratic storage 
implemented proof concept gpu ver sion glimmer idea benefit cpu mds algorithms 
distance paging draws inspiration texture paging texture large fit texture memory application designer knows small region texture visible time 
designer splits texture chunks loaded main memory necessary 
precomputed random number resource updating random set know advance precise sequence high dimensional distances program access iteration 
arrange required distances order access advance online pager running cpu loads blocks main memory texture memory gpu sf iteration 
compute texture memory requirements distance paging case 
replace texture smaller texture dis simply fetched computed 
floats requires storage floats bytes 
case storing entire distance matrix element size scratch changed pixels total size scratch texture bytes 
sum individual terms find texture memory required glimmer distance paging bytes 
theoretical maximum number points card mb memory points 
summarizes memory limitations glimmer algorithm previously discussed cases 
distance feeding allows scalability supporting lazy evaluation 
cause stochastic method pairwise distances needed 
precomputed permutations allows know advance dis required computation 
distance feeder cpu process takes points argument returns distance chapter 
scalability distance matrices method total bytes max points mb card fly euclidean distance matrix distance paging theoretical memory limitations gpu sf algorithm mb card different techniques compute inter point distances 
introduce distance paging solve quadratic storage requirements distance matrices 
loaded textures graphics card 
distance feeding need precompute entire distance matrix 
time required precompute distance matrices significant scalability bottleneck mds applica tions 
precomputation layout runs slower done total unused pairwise distances need computed 
distance pag ing distance feeding glimmer handle distance matrices far larger limits texture memory graphics card 
paging feeding performance compare performance distance matrix pager feeder schemes example graph drawing 
graph named matrix market collection nodes size distance matrix large practically fit available texture memory mb card slightly theoretical limit 
mds lay graph stress closely related kamada force directed placement energy 
graphs example datasets precomputing full distance matrix expensive solving pairs shortest path problem seconds 
pager distance chapter 
scalability distance matrices matrix slowdown performance glimmer fact loading texture cheaper computing high dimensional distances 
computing layout paging took seconds 
contrast feeder layout took seconds total seconds required paging 
shows graph layout produced glimmer distance matrix computed graph 
chapter 
scalability distance matrices graph layout glimmer distances precomputed graph search 
compute entire distance matrix need compute distances stress function converge 
know sequence advance compute distances distance feeder drastically reducing compute time distance paging approach 
chapter results discussion compare approaches previous terms asymptotic complex ity speed quantitative metric normalized stress qualitative visual analysis layouts 
mds algorithms chose compare mix tional algorithms competitive exemplars major approaches 
algorithms matlab version classic mds matlab im plementation java implementation chalmers foundational approaches known speed competitive measures stress layout quality interesting time performance 
ter change normalized stress function falls criterion gpu sf glimmer 
java implementation pivotmds classical scaling ap proach default landmarks noted 
jourdan logn hybrid fastest force directed approach multi grid mds publicly available know speed competitive hybrid pivotmds timings 
classic pivotmds designed minimize strain stress report success layout stress metric 
cobweb ecn purdue edu malcolm interval www lirmm fr mds html software courtesy christian chapter 
results discussion consistency consider stress suitable quantitative metric captures qualitative judgement layout quality visualization purposes 
mds applications outside information visualization direct visual inspection layout required stress may suitable metric 
complexity cost gpu sf iteration proportional number rendering passes multiplied number pixels affected pass 
multiplying values yields iteration cost log log ni ni log 
cost full gpu sf invocation ni log number iterations performed system converges 
discuss section necessarily observed varies depending dataset characteristics ranging constant 
number points ni supplied gpu sf glimmer level decimation factor ranges ni ni number levels log total number nt points processed glimmer levels bounded infinite sum cost glimmer level invocations gpu sf interpolation relaxation 
restriction stage glimmer incur extra costs need consider asymptotic analysis sampling built algorithm 
total complexity glimmer cpu log 
discuss effects gpu parallelism 
asymptotic analysis paral lel programs difficult concisely 
gpu simd size ranges current cards speeds compu chapter 
results discussion tation factor carefully designed shaders render passes avoid conditionals loops actual speedup close theo maximum 
computational complexity glimmer gpu approximately log 
contrast complexity hybrid logn chalmers sma cof classic mds 
pivot mds complexity kn fixed number landmarks large number points typically considered linear 
performance comparison compare glimmer gpu sf previous mds gorithms range real synthetic datasets 
benchmarks run pentium ghz cpu gb memory nvidia gs graphics card mb texture memory timings mer gpu sf run intel core qx ghz cpu gb memory nvidia graphics card mb texture memory 
timings thesis include file loading time rendering time algorithm 
accompanying video timings gpu sf glimmer include render time interactive display 
layout times clude computing high dimensional distances fly 
algorithms approximation stress function finding embedding stress figures reported full normalized metric equation 
datasets chapter 
results discussion mix synthetic real world benchmark datasets 
small cancer dataset uci ml repository points dimensions 
ground truth major clusters malignant versus benign tumors shown color coding orange blue respectively 
shuttle small dataset uci points dimensions shuttle big having structure points 
ground truth clusters shown color coding 
generated known synthetic benchmark nonlinear manifold points embedded dimensions 
generated set synthetic datasets smoothly varying cardinality grid em dimensions 
tested effects adding noise grids specifically noise third dimension 
docs dataset real world exam ple large collection unordered document metadata study document clustering algorithms 
collections represented highly sparse matrices row represents document column represents text feature 
glimmer gpu sf store matrix compactly texture memory value index pair 
points dimensions ground truth clusters shown color coding 
layout quality shows visual quality normalized stress timing glimmer gpu sf hybrid pivotmds layouts datasets known structure 
case grid correct shape known 
cases correct partitions points clusters available benchmark datasets www ics uci edu mlearn html data courtesy aaron 
chapter 
results discussion extent color coding matches spatial grouping created algorithm measure accuracy 
qualitatively cancer algorithms glimmer gpu sf pivot mds indicate color coded groups clearly spatial position 
quanti stress glimmer gpu sf order magnitude lower pivotmds 
hybrid separate groups produces misleading ters orange group 
shuttle big gpu sf fails separate clusters clearly termi nated prematurely 
hybrid produces somewhat readable layout separating red cluster slow 
glimmer pivotmds produce useful qualitatively comparable layouts separating clusters 
pivotmds layout twice fast noticeable occlusion higher stress glimmer layout 
point grid accurately embedded glimmer gpu sf piv comparable times 
hybrid slower terminated soon suffering noticable qualitative distortion higher quantitative stress metric compared layouts 
glimmer layout docs dataset qualitatively better 
shows spatially distinguishable clusters color coded blue red orange green 
blue cluster split parts 
took nearly sec normalized stress 
gpu sf times faster terminated prematurely poor layout points grouped clusters clusters occlude 
hybrid suffers cluster occlusion 
stress nearly twice high spatial embedding clearly separate clusters 
pivotmds fast completely fails show dataset structure 
normalized stress value extremely high 
illustrates noticeable difference visual quality grid chapter 
results discussion layout fast inaccurate gpu sf layout failed converge accu premature termination local minimum correct layout glimmer 
gpu sf get caught local minima low dimensional manifold twisted take time slowly unfold soon accurate solution reached termination condition fulfilled 
glimmer situations unfolding twists highest tiers multilevel hierarchy 
twists layouts small point sets higher energy states relative energy dataset properly resolved termination condition met 
strategy glimmer immune states helps reduce probability 
glimmer multilevel approach succeeds finding global minimum configuration 
speed stress synthetic grid dataset parameterize random permutations shuttle docs compare algorithm speed accuracy large interval dataset cardinalities 
respect speed figures show algo rithms fall main categories 
expected polynomial time tional classic chalmers algorithms scale past thousands points minutes hours compute layouts 
remaining group algorithms scale hundreds thousands points minute shown detail figures 
hybrid slowest 
timing relationship pivotmds versus glimmer gpu sf depends generation graphics card 
pivotmds brown consistently faster glimmer gpu sf older gs card violet red respectively slower chapter 
results discussion glimmer gpu sf newer card grey plum respectively 
exception sparse docs pivotmds fastest yields incorrect results 
stress graphs figures log scale vertical axes critical part story showing speed accuracy trade 
dataset draw dashed black line rough indication stress threshold visual quality affected empirical inspection layouts 
characterize algorithm outperformed competitor accuracy falls line competitor faster 
grid classical scaling algorithms classic pink pivotmds brown produce perfect zero stress layouts 
blue glimmer violet produce excellent layouts stress 
dashed black line shows grid layouts stress higher approxi mately perceivable inaccuracies 
gpu sf red produces accurate low stress layouts points 
cardinalities terminates early layout inaccurate gpu sf outperformed glimmer 
hybrid green chalmers orange inaccurate producing comparable layouts noticable distortion stress order magnitude greater competitive algorithms 
shuttle location dashed black line measured stress algorithms indicates yielded acceptably accurate re sults special case gpu sf 
show second red dashed line indicate gpu sf layouts qualitatively inaccurate 
stress failure cases numerically lower acceptable pivotmds clas sic mds layouts showing direct correlation stress visual quality especially comparing results differing opti mization strategies 
high cardinalities gpu sf terminate chapter 
results discussion soon produce unreadable layouts clusters spatially separated 
argue glimmer outperforms gpu sf case 
approximate pivotmds algorithm brown yields higher stress layouts foundational classic approach pink qualitatively 
blue produces lowest stress layouts followed glimmer violet 
hybrid green falls gap classical scaling methods distance scaling techniques 
docs shown see higher stress levels axis range intrinsic dimensionality data higher 
see considerable separation accuracy algorithms 
magnitude separation gpu sf glimmer stress measurements may large visual difference perceptible seen 
glimmer underneath dashed black line showing qualitatively correct threshold 
produces layouts acceptable quality quite quickly seconds card seconds card point dataset 
provides acceptable quality layouts lower stress glimmer require hours compute 
pivotmds classic produce inaccurate layouts shown high stress values 
illustrates relationship speed stress showing log log scatterplots timing stress algorithms small datasets cancer grid points percent noise 
algorithm represented single colored dot pivotmds show brown line connecting runs pivots 
dots closer lower left corner represent algorithms outperforming upper right 
plots show linear relationship stress timing chapter 
results discussion pivotmds brown hybrid green classic pink blue ing simple speed accuracy tradeoff algorithms 
chalmers orange obvious outlier upper right quadrant slow times high stress 
glimmer violet gpu sf red outliers lower left quadrant fast times low stress 
algorithms break pattern achieving higher speed layouts accuracy penalty 
see gpu sf simply faster chalmers algorithm inspired robust termination condition achieves lower stress 
produces lowest stress layouts unacceptably slow 
hybrid method substantially reduces time required produce layout resulting layout configuration contain substantial artifacts 
gpu sf harnesses gpu converge rapidly terminates prematurely large datasets 
glimmer uses multilevel approach avoid premature termination computes low stress configuration seconds exploiting gpu scaling datasets points 
summary glimmer faster foundational classic chalmers algorithms 
datasets dimensions points improvement order 
glimmer reliably achieves lower stress chalmers higher stress victor stress classic glimmer depends dataset 
glimmer produces results lower stress better visual quality hy 
glimmer faster exception docs gs gpu hybrid faster yields uninformative layouts 
gpu sf glimmer close speed 
cases gpu sf chapter 
results discussion faster glimmer terminated soon yields uninformative layouts 
stress graphs show early termination gpu sf correlated larger dataset cardinality 
glimmer produces results lower stress better visual quality 
glimmer faster pivotmds latest card slower older card 
specific algorithms examples different approaches speeding mds computation 
current hardware trend gpu speeds increasing quickly cpu speeds algorithms glimmer exploit gpu parallelism may increasing speed advantage 
exception docs pivotmds faster glimmer running 
produces visually uninformative re sults 
datasets tested algorithms produce results comparable visual quality 
pivotmds glimmer exemplars different approaches mds discuss tradeoffs ap proaches generally 
comparing distance classical scaling interesting consider advantages disadvantages distance scaling ap proaches stress glimmer gpu sf chalmers hybrid sma cof versus classical scaling approaches strain pivotmds land mark mds classic 
distance scaling individual distances computed embedding space specified dimension contrast classical scaling specifically param embedding dimension 
layout dimensions occurs simply choosing eigenvectors 
intrinsic dimensionality layout chapter 
results discussion eigenvectors contain layout information 
intrinsic dimensionality mean number dimensions needed achieve layout strain zero greater desired embedding dimension thesis classical scaling implicitly uses degrees freedom minimizing objective func tion distance scaling 
resulting layout may occlude points clusters features lower dimensions 
illustrate phenomenon embedding endpoints regular sim plex 
simplex geometric object endpoints distance unit length 
example line segment regular simplex equilateral triangle regular simplex 
shows results embed ding regular simplex dimensions classical scaling distance scaling 
way embed high dimensional object loss information distance scaling constructs layout point sion roughly diameter simplex classical scaling places points region smaller simplex diameter 
called curse dimensionality states majority points sam high dimensional space equidistant 
volume space ex increases function dimension likelihood points close 
data sampled high dimensions exhibit simplicial structure 
intrinsic dimensionality dataset equal em dimension classical scaling methods 
dimensionality greater greater likelihood intra cluster sion may advantageous clusters may easily distin distance gathering techniques isomap may find lower intrinsic dimensionality layouts complex distance metrics euclidean discuss 
arguments apply case 
chapter 
results discussion 
argue sparse high dimensional datasets docs distance scaling probably better choice classical scaling 
pivotmds layout docs dataset shown produced minimization strain objective demonstrates dimensional basis text feature space constructed visually separate relevant clusters 
consider smearing ground truth color coding disparate spatial regions evidence disadvantages minimizing strain dealing sparse datasets 
confirm analysis tested pivot mds algorithm dataset landmarks visual appearance improved 
argue algorithms distance scaling ran dom search stochastic force suited visualizing datasets 
glimmer algorithm scale sparse datasets size produce useful results matter dozen seconds 
gpu speedup shows speedup gpu sf cpu chalmers algo rithm 
provide quantitative measurements gpu speedup mer 
shows running times milliseconds glimmer algorithm different gpus versus completely cpu proof concept imple mentation 
timings shown synthetic grid dataset sample sizes 
implementation performs roughly number computations allowing directly gauge magnitude gpu speedup 
graph cpu timing values divided gpu timings cardinality 
speedup factors converge constant value gpu approximately times faster gs approximately times faster 
speedup factors conform precise number chapter 
results discussion processors gpu respectively 
discrepancy due architectural differences individual cpu gpu processors 
gpu speedup comes startup overhead costs 
include shader compilation shader optimization data initialization upload download 
shows costs milliseconds steps variety sample sizes grid dataset 
gpu sf glimmer layout times include overhead uploading data cpu gpu 
shader com optimization step required number subsequent layouts included performance runtimes 
gpu sf glimmer shader compilation initialization requires seconds dataset independent startup overhead program begins included timings 
similarly count startup times matlab java vm algorithms 
chapter 
results discussion cancer shuttle big grid docs glimmer stress stress stress stress gpu sf stress stress stress stress hybrid stress stress stress stress pivotmds stress stress stress stress mds layouts showing visual quality time stress mer gpu sf hybrid pivotmds algorithms 
dataset name number nodes number dimensions appear column 
time seconds appears bottom left entry normalized stress bottom right 
chapter 
results discussion visual quality differences glimmer gpu sf grid instance cardinality 
glimmer exhibits stable convergence behavior gpu sf frequently yields twisted layout caught local minimum terminates high stress value 
layout corresponds spike gpu sf 
time time normalized stress log scale grid cardinality chapter 
results discussion time grid cardinality grid cardinality glimmer gpu sf glimmer gs gpu sf gs pivotmds hybrid cpu sf classic grid stress timing graphs 
seconds versus cardinality grid points 
chalmers orange blue classic pink orders magnitude slower faster approximation algorithms 
gpu sf appears compute fastest layouts layout quality lower glimmer cases due local minima 
seconds versus cardinality grid points 
chalmers classic visible scale 
gpu sf finishes fastest due local minima glimmer card second fastest higher quality layouts 
normalized stress versus cardinality grid points 
chalmers hybrid gpu sf prone distorted layouts registering heuristic dashed black visible distortion line 
pivotmds classic visible due producing zero stress layouts 
time time normalized stress log scale shuttle cardinality chapter 
results discussion time shuttle cardinality shuttle cardinality glimmer gpu sf glimmer gs gpu sf gs pivotmds hybrid cpu sf classic shuttle stress timing graphs 
seconds versus cardinality shuttle approximately points 
seconds versus cardinality shuttle points 
normalized stress versus cardinality shuttle approximately points 
include dashed black line indicate algorithms produce acceptable results gpu sf 
show gpu sf terminates low quality results local minimum red dashed line 
time time normalized stress log scale docs cardinality chapter 
results discussion time docs cardinality docs cardinality glimmer gpu sf glimmer gs gpu sf gs pivotmds hybrid cpu sf classic docs stress timing graphs 
seconds versus cardinality docs approximately points 
seconds versus cardinality docs points 
normalized stress versus cardinality docs approximately points 
normalized stress normalized stress normalized stress chapter 
results discussion cancer time ms grid noise time ms time ms glimmer gpu sf glimmer gs gpu sf gs pivotmds hybrid cpu sf classic log log scatterplots stress versus time measured mds algorithms cancer grid datasets increasing cardinality 
graphs illustrate stress time tradeoff distinct outliers chalmers orange slower side tradeoff gpu sf red glimmer violet side tradeoff lower stress shorter time 
include dashed black line indicate stress level cluster separation noticable 
chapter 
results discussion distance scaling classical scaling layouts regular simplex produced distance scaling classical scaling 
methods distort simplex 
distance scaling produces point occlusion better preserves diameter simplex 
time glimmer cpu glimmer gs glimmer grid cardinality gpu vs cpu speed seconds 
show glimmer different gpus compared purely cpu implementation 
dataset synthetic grid range cardinalities 
glimmer carefully designed fully exploit possibilities gpu parallelism modern hardware achieving order magnitude speedup points 
chapter 
results discussion glimmer gpu speedup 
dividing time required complete layout glimmer cpu time required gpu directly calculate speedup provided graphics cards 
graph shows cards converge approximately constant speedup factor 
startup ms overhead ms size 
comp 
opt init upload startup costs texture overhead milliseconds 
shader compilation optimization single step startup costs amortized layouts 
texture initialization data upload download costs incurred individual dataset overhead small compared runtime 
chapter glimmer gpu sf provide dramatic speedups compared previous distance scaling approximation algorithms exploiting gpu parallelism stage architectures 
new termination criterion gpu sf detects convergence cheaply approximating normalized stress function 
gpu sf roughly fast glimmer prone getting caught local minima especially large datasets 
multilevel architecture glimmer converge lower stress embedding 
glimmer avoids speed accuracy tradeoff previous distance scaling approximation algorithms shown mix synthetic real world datasets 
distance scaling distance paging avoid disadvantages gpu texture memory restrictions may impose cpu mds algorithms 
competitive previous classical scaling approximations speed yields higher quality results sparse high dimensional datasets 
glimmer straightforward generalize current imple mentation handling target spaces dimension 
force calculation pass stage gpu sf main bottleneck possibly passes dimensionality increases 
force calculation step gpu sf normalized velocity vectors computed damping purposes 
currently optimized shader instructions calculating normalization factors 
number embedding dimensions exceeds instructions longer applicable 
general multipass scheme similar step algorithm calcu chapter 
late velocity vector length increase number passes step log adapted gpu sf algorithm perform force directed graph placement called algorithm 
key changes gpu sf 
fixed size near random index sets dynamic en tries replaced sets different index sets fixed called near landmark 
users control size near landmark sets respectively control local global fidelity graph layout 
second initialize contents cpu preprocess 
third velocity termination condition sparse normalized stress condition chapter 
velocity termination problematic sparse normalized stress condition works context multilevel approach single level algorithm 
computes layouts superior speed comparable quality state art graph placement fm suffers suboptimal results due local minima need tweak velocity termination parameters 
interesting adapt multilevel glimmer approach optimized force directed graph placement exploit robust sparse stress termination criterion avoid local minima 
bibliography barnes hut 
hierarchical logn force calculation algo rithm 
nature 
richard ernest bellman 
dynamic programming 
courier dover tions 
ronald karin richard barrett jack dongarra 
matrix market web resource test matrix col 
ronald editor quality numerical software enhancement pages london 
chapman hall 
ulrik brandes christian 
methods progressive mul scaling large data 
proc 
graph drawing lncs pages 
springer 
kimmel 
multigrid mul scaling 
numerical linear algebra applications march april 
chalmers 
linear iteration time layout algorithm visualising high dimensional data 
proc 
ieee visualization pages 
bibliography de leeuw 
applications convex analysis multidimensional scaling 
developments statistics pages 
de silva tenenbaum 
sparse multidimensional scaling land mark points 
technical report stanford 
christos faloutsos king ip lin 
fastmap fast algorithm indexing data mining visualization traditional multimedia datasets 
proc 
acm sigmod pages 
tal 
online dynamic graph drawing 
proc 
ics ieee symp 
visualization 
emden gansner yehuda koren stephen north 
graph drawing stress majorization 
proc 
graph drawing lncs pages 
springer 
leslie frederick greengard 
rapid evaluation potential fields parti cle systems 
phd thesis new haven ct usa 
ingram munzner 
glimmer multilevel mds gpu 
submitted publication 
ingram munzner 
gpu layout undirected graphs 
technical report tr university british columbia 
fabien jourdan guy 
multiscale hybrid mds 
proc 
intl 
conf 
information visualization iv pages 

initial evaluation automated organization digital library browsing 
proc 
th acm ieee cs joint conf 
digital libraries jcdl pages 
bibliography kruskal 
multidimensional scaling optimizing goodness fit nonmetric hypothesis 
psychometrika 
neil lawrence 
gaussian process latent variable models visualization high dimensional data 
morrison ross chalmers 
hybrid layout algorithm sub quadratic multidimensional scaling 
proc 
ieee symposium informa tion visualization infovis pages 
morrison ross chalmers 
fast multidimensional scaling sampling springs interpolation 
information visualization 
nvidia 
nvidia compute unified device architecture programming guide january 
ken perlin 
image synthesizer 
proc 
acm siggraph pages 
john platt 
fastmap landmark mds nystr algo rithms 
proc 
th intl 
workshop artificial intelligence statistics pages 
society artificial intelligence statistics 
reina ertl 
implementing fastmap gpu considerations general purpose computation graphics hardware 
theory prac tice computer graphics pages 
ross chalmers 
visual workspace constructing hybrid multi dimensional scaling algorithms coordinating multiple views 
information visualization december 
bibliography roweis saul 
nonlinear dimensionality reduction locally linear embedding 
science dec 
yossi rubner carlo tomasi leonidas guibas 
metric distribu tions applications image databases 
iccv proceedings sixth international conference computer vision page washington dc usa 
ieee computer society 
tenenbaum de silva langford 
global geometric frame nonlinear dimensionality reduction 
science dec 
torgerson 
multidimensional scaling theory method 

young householder 
discussion set points terms mutual distances 
psychometrika january 
