mt model transformation language technical report tr department computer science king college london laurence laurie net may contents running example qvt partners model transformations approach overview 
pattern language 
complete example 
issues approach 
inappropriate imperative language 
patterns 
scoping rules 
summary 
mt language basic details 
matching source elements patterns 
pattern language 
producing target elements 
example 
running transformation 
tracing information visualizing tracing information 
alternative visualizations 
standard tracing information creation mechanism 
augmenting overriding standard mechanism 
sophisticated transformations extending running example 
pattern multiplicities 
variable bindings presence multiplicities 
extended example 
pruning target model 
combinators 
implementation mt grammar 
outline implementation 
translating rules 
translating rules source model clauses 
translating patterns 
translating variable bindings 
translating model element patterns 
simplified translation 
ensuring complete evaluation nested pattern expressions 
translating set patterns 
translating converge expressions patterns 
example translated pattern 
translating pattern multiplicities 
standard functions 
embedding converge code dsls 
extending converge grammar 
preventing unintended interaction translated embedded code 
assigning variables outer blocks 
generating tracing information nested model patterns 
summary implementation 
related summary converge grammar simple classes tables transformation 
type classifier name string class attribute primary bool name string name string attrs ordered simple uml meta model 
presents unidirectional stateless model transformation language mt implemented dsl converge 
mt shares aspects common model transformation languages qvt partners approach qvt 
rule system utilising patterns 
number advances significant differences previous approaches 
side effect implementing mt dsl converge result experimentation concrete malleable implementation 
example mt allows normal converge imperative expressions embedded 
wider context mt basis change propagating transformation language 
comes main parts 
firstly running example introduced followed qvt partners model transformation approach 
qvt partners approach basis mt language introduced partly example 
implementation mt language dsl converge discussed detail 

running example simple running example transformation uml modelling language model relational databases 
chief reason example ability compare result implementation model transformation approaches dic qvt 
example virtue easily considered simple advanced variants 
whilst advanced variant exercise reasonable number features model transformation approach appropriate size 
original example defined qvt 
simple variant follows 
meta model simple uml modelling language 
corresponding meta model simplified relational databases 
essence transformation takes class transforms table name 
attribute type string integer transformed column name primitive data type 
attribute type class type refers user class transformed number columns transformation recursively drills class non typed attributes reaches attributes primitive datatypes 
point recursion name current class character appended column name 
net result non primitive data types flattened 
table name string columns ordered column name string type string simplified relational database meta model 
consider source model 
assuming class input class implementation transformation produce relational database model 
attrs attribute name name type class name dog attribute name owner type attribute name name class name person attrs attrs attrs type name string type name int attribute name age example source simple uml model 
columns column name name type string table name dog columns column name owner name type string columns type column name owner age type int example target relational database model core example 
progresses progressively add complexity example 

qvt partners model transformations approach section explain relevant aspects qvt partners approach mt language shares factors common qvt partners approach 
whilst qvt partners approach concept specification implementation transformations known relations mappings respectively purposes transformation specifications largely irrelevant consequently ignored 
qvt partners approach defines diagrammatic syntax transformations similarly ignored 

overview transformation qvt partners approach consists number mappings 
mapping consists source domains analogous function parameter target imperative body 
domain author takes full responsibility decision names multiple overloaded meanings wider field retrospect best possible choices 
consists patterns match 
patterns written language designed expressing constraints models succinct analogous textual regular expressions perl 
imperative bodies consist single expression extended ocl variant capable side effects 
meta models previous section simple mapping transforming class table look follows mapping class table domain class name attrs body columns collect attr columns set columns attr column attr table name columns columns intuitive meaning hopefully fairly straightforward 
table rule match class model element pattern binding name class variable attributes variable imperative body creates corresponding table name matches source class 
noted expression body appears pattern syntactic illusion pattern syntax simply syntactic sugar object creation slot updating 
attr column refers mapping transform attribute source class database columns placed target table 

pattern language context important novel aspect qvt partners approach pattern language 
aim provide concise textual notation expressing constraints models reducing time needed write comprehend transformation 
subsection provide brief background patterns informally explaining qvt partners pattern language 
computer users familiar textual pattern languages operating system commands txt 
obtain crude gauge popularity textual regular expressions fact suitable libraries standard modern programming languages perl python ruby 
whilst pattern languages commonly thought suitable matching text match richer datatypes 
example program transformation patterns match complex ast big 
intuitively designing pattern language involves compromise providing concise notation capturing common constraints providing completely general mechanism cases pattern language express concise 
pattern languages tailored common case opposed general case 
textual regular expressions example typically defined finite state automata express seemingly simple constraint ensuring string contains balanced open close brackets desirable pattern languages expressive limit reached suitable escape mechanism powerful verbose system available 
note implementations regular expressions longer regular formal sense word 
example modern perl contains experimental feature express balanced brackets constraint 
qvt partners approach provides specific pattern language expressing constraints models 
providing benefits known textual regular expressions users problems concerned identifying elements model addressed 
qvt partners approach important respect current model transformation approaches provide pattern languages 
argued graph transformation approaches utilise pattern languages believe lack significant expressive power particularly compared textual regular expressions purposes consider graph transformation approaches pattern languages 
qvt partners approach provides small pattern language expressing constraints models 
slightly simplified version grammar pattern language follows pattern set pattern seq pattern obj pattern expression set pattern pattern pattern set pattern pattern pattern obj pattern var var field pattern field pattern field pattern var pattern var id rule expression rule contains extended ocl variants grammar 
qvt partners approach identifies main types patterns set sequence object patterns 
explicitly noted variables patterns essentially patterns 
ensure consistency rest refer object patterns model element patterns 
types pattern share common thing particular model element succeed fail match 
set sequence patterns similar function parameters functional programming languages haskell 
example set pattern set match successfully set contains items new set containing original sets items bound tor 
intuitively variable names mean match bind henceforth referred variable bindings 
variable name appears scope instances variable name match equivalent objects definition object equality qvt partners approach inherited mof omg 
special variable matches immediately discards result multiple instances need match equivalent objects 
relatively simple model element patterns backbone pattern language 
model element patterns specify type matching model elements conform optional self variable bound element matched 
model element specifies number slots pattern slot model element match 
terse power model element patterns best demonstrated example 
consider model element pattern dog name owner person name fred pattern match successfully model element type dog owner fred 
match point element matched contain dog name 
pattern approximately equivalent converge pseudo code function returns dictionary bindings source element matched successfully failing func match element element conforms dog return fail element element name element owner conforms person return fail element owner name fred return fail return dict may logical ocl express noted expressing creation update bindings ocl require complex encodings 
partly due difficulty qvt partners approach defines new calculus order suitable semantic domain 
calculus operational semantics directly implements pattern matching primitives seen similar imperative object calculus abadi cardelli ac extended pattern matching 
converge pseudo code target translation example pattern avoids need define explain calculus 
example translation clearly shows model element pattern considerably equivalent pseudo code arguably easier comprehend 
pseudo code explicitly embed certain aspects model transformation fail statements important aspects pattern obscured 
simply recasting problem expressing model transformations gpl pattern language simple neatly solves problems 

complete example running example expressed qvt partners approach follows mapping class table domain class name attrs body columns collect attr columns set columns primitive type attr column attr user type attr column attr table name columns columns mapping user type attr column domain string prefix domain attribute name type class name ct attributes body new prefix prefix prefix collect attr attrs set attrs primitive type attr column new prefix attr user type attr column new prefix attr mapping primitive type attr column domain string prefix domain attribute name type name pt body set column name prefix name name prefix type pt feature particular requires explanation theor function table user type attr column mappings 
normal function call built combinator lazily executes mappings passed arguments order succeeds produces value 
note rule systems qvt partners provide function takes element attempts find rule transform 
theor combinator provide functionality repeated tiresome due continuous hard coding mapping names required 
structure transformation fairly simple 
class table top level mapping takes class iterates attributes invoking mappings produce columns 
attributes transformed ways 
type attr column primitive type attr column mappings take arguments string attribute 
string represents current column name prefix built transformation drills user data types 
attributes primitive data type transformed type attr column mapping single column 
attributes user data type transformed type attr columns user type attr column mapping recursive mapping drills user data types 
example section successfully expressed qvt partners approach result verbose may expected 
somewhat surprisingly simple gpl equivalent example smaller 
reasonably expect expressing trans formation qvt partners approach benefits 
mappings allow expression unidirectional stateless transformations potential gain gpl approach possibility automatically created tracing information 
unfortunately qvt partners approach explain explain rules create tracing information practise 
gpl equivalent readily understood far wider range people benefits approach clear cut 
subsection outline issues indicative problems qvt partners approach 

issues approach verbose example section may suggest qvt partners approach number minor flaws limitations hamper practical 
subsection outline approximately descending order areas indicative qvt partners falls short intended goals 
points instructive understanding design decisions mt language section 

inappropriate imperative language imperative bodies mappings written called extended ocl intended allow users familiar ocl chance reuse knowledge imperative setting 
immediate negative effect extending ocl imperative constructs means desirable properties ocl purely side effect free language lost conversely comes acting normal gpl resulting language decidedly unwieldy lacks appropriate constructs common operations 
example explicit sequencing mechanism imperative body consists exactly ocl constraint sequencing achieved expression 

patterns pattern language defined qvt partners approach novel context model transformations potentially useful 
relatively simple definition section may suggest pattern language lacking significant expressive power 
pattern language limited main ways 
model element patterns possible check equality slots 
example possible model element pattern express match object succeed provided slot match particular value 
order sidestep problem users add additional ocl clause 

model element patterns match fixed number elements 
model element pattern example match successfully model element 
note whilst set sequence patterns match sets sequences arbitrary lengths fixed number elements explicitly identified set sequence 
general solution problem 
typically new mapping needs added iteration clause control number times mapping successfully matched 
ocl fact entirely side effect free situations property violated largely irrelevant context 

scoping rules bare variable name slot constitutes variable binding qvt partners approach fragile scoping rules difficult distinguish variable binding variable 
consider simple example section dog dog model class variable binding set self value object matches model element pattern 
means impossible express model element pattern match particular element 
example meta circular system class instance metaclass model element pattern singleton 
create local variable ensuring matches element pointed 
qvt partners approach allows clause scoped domains establishing constraint domains create new variable bindings 
possible introduce similar clause similar approaches scoped domains introduces new variable binding introducing ambiguities 
consider example pattern bind value variable ensure contains value introduced clause 
mapping domain slot qvt partners approach scoping ambiguities avoided disallowing potentially useful features may introduce new variable bindings 
result whilst expressions dog 
statically resolvable confusing users 
effect scoping rules severely limit possibilities extending embedding language 

summary qvt partners approach provides number innovations compared model transformation approaches notably patterns 
practise simplistic nature approach means falls somewhat short aim allow users express model transformations easily gpl section define new model transformation language mt takes elements qvt partners approach adding extra features addressing approaches flaws 

mt language mt language new unidirectional stateless model transformation language implemented dsl converge 
mt transforms instances typed modelling language tm tra new instances tm 
essence mt defines natural embedding model transformations converge declarative patterns match model elements terse powerful way whilst allowing normal imperative converge code embedded rules 
mt implemented dsl converge existed concrete implementation shortly original design sketched 
proved significant practical experience approach rapidly fed back implementation 
rapid development facilitated flexible environment provided converge 
ability experiment implementation ultimately led mt contain number insights distinct differences approaches 
insights range sophisticated pattern language suitable ways visualize model transformations 
wider context mt important basis change propagating language described publication 
section highlight main features mt mt version running example showing mt transformations run practise 
section intended basic features mt advanced features described section 

basic details mt transformation name consists rules ordering significant 
rules effectively functions define fixed number parameters succeed fail depending rule matches arguments 
rules functions mt essentially synonymous approaches txl cor 
rule matches successfully target elements produced said executed fails match successfully produced 
rules comprised source matching clause containing source patterns optional clause source matching clause target producing clause consisting expressions optional clause target production clause 
mt transformation takes source elements referred root set source elements 
transformation attempts transform element root set source elements transformations rules tried order defined 
rule matches element exception raised transformation aborted 
general form mt transformation follows import mt mt mt mt transformation transformation name rule rule name pattern src expr expr tgt expr clauses collectively said form model clauses similarly clauses collectively said form model clauses 
transformations translated mt converge class name transformation rules translated functions name class 
order run transformation transformation class instantiated class instantiated multiple times 
transformation classes additional functions extracting tracing information see section 
transformation rules contain normal converge code expressions expressions variables outside model transformation dsl fragment 
important aspect mt allows users normal converge functions arbitrarily penalty 
words model transformation language inadequate particular respect normal reusable converge function defined outside model transformation called model transformation 
mt transformations hold record tracing information automatically created transformation rules executed 
rule executed adds new trace 
trace tuple encoded converge list form source elements target elements 
source elements stored tracing information necessarily constitute entire universe elements passed parameters transformation 
default elements matched non nested model element patterns recorded tracing information 
section details default tracing creation mechanism explains augmented overridden 
simple example transformation rule follows mt mt transformation classes tables rule class table class name attrs table name cols columns tgt columns attr iterate columns extend self transform attr flatten rule mt analogue rule section 
note normal converge code interspersed mt dsl see section implementation information 
transformations translated converge classes access functions internal transformation self 
prefix 
transform function example takes source elements tries rule transformation succession finds successfully matches elements produces values 
transform function find suitable rule default exception raised 
transform function internally transformation mechanism transform root set source model elements 
section shows example rule guarantee transform rule succeed input 
subsections explain detail rules match produce elements including detailed examination pattern language pattern multiplicities 

matching source elements patterns pattern clause rule corresponds domain qvt partners approach 
arguments passed lists sets whilst tm elements placed converge sets users may wish transform non elements lists 
list contains top level model elements pattern match 
elements exist directly indirectly top level elements reachable graph constitutes model arguments 
order avoid problems noted section variable bindings surrounded angled brackets distinguish normal converge variable 
matching algorithm mt intentionally simple 
pattern turn attempts match top level source elements passed appropriate argument 
time pattern matches produces variable bindings available subsequent patterns 
pattern fails match control backtracks previous patterns order called attempt generate match variable bindings arguments available 
generation alternative match causes new variable bindings produce allows rule attempt match patterns 
clause exists tried patterns matched successfully essentially guard patterns 
fails patterns requested generate new matches exactly failure pattern match 
implementation details behaviour largely hidden user patterns 
order patterns defined clause significant separate reasons 
obviously necessary ensure users sequence variable bindings bound variables correctly 
second reason whilst obvious critical performance larger transformations 
making order patterns significant allows users domain knowledge order efficient way 
consider rule independent patterns tends match source elements 
placing clause means fails try produce values produce multiple matches may executed times unnecessarily 
placed clause fails match input rule fails trying match sensible ordering patterns way lead significant boost performance unnecessary matches evaluated 
pattern translated converge generator provides natural mechanism lazily generating possible matches 
translated patterns joined converge backtracking abilities 
note clause exists single converge expression succeeds fails variable bindings generated patterns clause 

pattern language mt pattern language essentially super set qvt partners approach 
mt defines number pattern expressions model element patterns set patterns variable bindings normal converge expressions 
patterns written language directly translated mt minor syntactic changes 
significant differences pattern languages 
firstly noted section variable bindings mt surrounded angled brackets ensure harmony mt converge scoping rules 
secondly model element patterns mt contain comparisons equality slots henceforth known slot comparisons 
standard converge comparison operators slot comparisons 
model element pattern mt said consist zero slot comparisons 
trivial example slot comparisons take model element pattern example section making necessary minor syntactic modifications change find dogs owner fred dog name owner person name fred example necessitate ocl constraint clause qvt partners approach 
allowing different types slot comparison model element patterns opens new possibilities 
mt allows slot name appear slot comparison test slot multiple conditions model element pattern person age age additional feature mt pattern language 
model elements converge objects slot comparison entirely synonymous attribute comparison slots may contain functions 
mt model element patterns provides support functions shown example person calc wage functions slot comparisons passed arbitrary number arguments passed arguments normal converge expressions 
pattern multiplicities considered part core pattern language significant enhancement mt qvt partners approach detailed section 

producing target elements mt rule executes produces target elements 
exception raised rule executes fails produce elements 
number elements produced determined number expressions clause 
clause single expression rule produces single element contains expression rule produces list length number expressions clause 
expression normal converge expression important addition 
mt dsl admits model element expressions extending converge grammar see section implementation details 
model element expressions differ model element patterns conceptually syntactically 
conceptually model element expression imperative creational action 
concept self variable model expression 
furthermore reinforce notion model expressions imperative actions slot assignments normal converge assignment operator 
expressions optional suffix allows single expression generate multiple values 
ignores obvious syntactic difference relative location keyword suffix works largely normal converge counterpart single expression continuously pumping values fails 
variables defined suffix scoped single expression clause suffixes 
list typical usage feature follows column name col name col cols iterate note example expression result rule list len 
expression rule produce list length element list len 
section suggests possible extension mt allow rule produce number elements solely determined number expressions 
tgt clause exists sequence converge expressions executed clause 
variables tgt clause automatically scoped clause 
clause notion success failure clause simply helper function clause 
note expressions tgt clause contain model element expressions 

example complete converge module implements running example import sys import relational simple uml import mt mt func concat name prefix name prefix return name return prefix name mt mt transformation classes tables rule class table class name attrs table name cols columns tgt columns attr iterate columns extend self transform attr flatten rule user type attr column string prefix attribute name type class name cn attrs ca self transform concat name prefix ca ca ca iterate rule primitive type attr column string prefix attribute name type name pn column name concat name prefix type pn structure transformation deliberately similar version qvt partners approach section 
important difference repetitive code builds column prefix factored normal top level function concat name contributes making transformation approximately smaller qvt partners approach equivalent 
slight difference mt transformation qvt partners approach equivalent user type attr column rule produces list contains list columns 
outer list len entry list arbitrary length 
consequently function call line necessary remove nesting type attr column rule called 

running transformation details run model transformation including details format inputs outputs surprisingly absent descriptions majority model transformation approaches 
important practical aspects model transformations believe important explicit transformations run 
subsection detail process running mt transformation 
running transformation mt involves instantiating transformation class passing model elements 
transformation executes attempting find rule transform element root set source elements 
transformation successful transforming root set elements transformation object returned 
transformation object queried find target model elements produced corresponding tracing information 
format mt inputs outputs simple 
source elements instances elements defined atm model class block note built converge types strings ints defined valid tm model elements 
similarly target elements tm model elements 
example creates simple input model executes classes tables transformation dog simple uml class dog person simple uml class person dog attrs append simple uml attribute name simple uml string dog attrs append simple uml attribute owner person person attrs append simple uml attribute name simple uml string person attrs append simple uml attribute age simple uml integer transformation classes tables dog target elements produced transformation accessed target function 
source target elements tm model elements apply standard tm visualization example 
source model shown target model 
note colours source target models remainder source elements shown blue target elements green 
element passed transform function transformed available rules exception raised showing offending element transformation aborted 
users may catch exception desired may reasonably ask transformation attempt recover gracefully instances 
unfortunately unrealistic general case reason 
function called expectation return result fails find suitable rule transform element unable fulfil callers expectation element returned 
order maintain expectation transform conceivably return dummy target element placeholder 
dummy element satisfy constraints target meta model generally cause exception raised 
class mod id name dog attribute attrs mod id name name type attrs mod id name string attribute mod id name owner type class mod id name person attrs attribute mod id name name type attrs source model 
attribute mod id name age type mod id name integer probably small number situations dummy element cause error clear resulting target model significant user 
section shows example default rule guarantees function fail 

tracing information section describe mt deals tracing information 
show tracing information visualized describe standard mechanism creating showing user augment override default tracing information created 

visualizing tracing information section showed mt transformation run default visualization capabilities tm visualize source target models transformation 
mt transformation instances store tracing information see section relating source target elements 
visualizing tracing information interesting challenge hitherto received scant attention setting model transformations 
mt tm cooperate simple visualization tracing information allows users build detailed picture transformation executed 
order visualize tracing information needs understand information stored 
trans column mod id type string name name cols table mod id name dog cols column mod id type string name owner name cols target model 
column mod id type integer name owner age formation instances contain separate lists equal length related tracing information 
list contains tuples encoded lists relating source target elements 
second list contains name transformation rule created corresponding entry list 
fact stored separately simple implementation detail conceptually lists considered constitute single piece information 
visualizer module defines trace transformation takes transformation instance visualizes complete tracing information 
result visualizing tracing information example model section seen 
original source model left blue target model right green 
black lines source target elements traces source target elements 
individual traces run single source element single target element 
trace name form tn integer starting 
integer values reflect traces position execution sequence trace numbers compared determine rule execution happened earlier execution sequence 
trace names looked tracing table top right 
tracing table contains name rule executed transformation 
rule name names traces trace name represents execution rule 
note single rule execution create trace trace created single execution share name 
visualization tracing information may simple allows infer great deal useful information execution transformation 
information useful analysis debugging transformation 
simple level names tracing information determine rule consumed source elements produced target elements 
example trace source class target table result class table rule 
deduce traces name result rule execution system 
similarly traces share name determine rule type attr column created target element single execution 
subsection talked tracing information stored visualized visualization discussed tracing information created 
section explains tracing information created users control creation 

alternative visualizations tracing information visualized source target models formatted exactly individually figures 
whilst visualization works small trans type attribute mod id name name mod id name string attribute mod id name name class mod id name dog attrs attrs attribute mod id name owner class mod id name person attrs type attrs attribute mod id name age column mod id type string name owner name table mod id name dog type type cols cols cols mod id name integer tracing class table primitive type attr column user type attr column visualizing tracing information 
column mod id type integer name owner age column mod id type string name name formations larger transformations greater volumes tracing information tend unreadable strict formatting source target models forces traces overlap 
alternative form visualization available trace clustered function source target elements formatted directly alongside 
shows alternative visualization 
note diagram colouring critical distinguish source target model elements 
due general lack cluttering generally preferred visualization tracing information involved remainder 

standard tracing information creation mechanism section showed mt tm visualize tracing information automatically created mt transformations 
subsection outline default tracing information created mt model transformation approaches currently somewhat vague subject 
little prior art basis point comparison mechanism 
mt takes simple approach problem ensure behaviour predictable users perspective vital ensure clustered part function name reflects mechanism graphviz enable layout 
column mod id type string name name attribute mod id name name attrs class mod id name dog table mod id name dog mod id name string attrs attribute mod id name owner cols type cols type cols column mod id type string name owner name tracing class table primitive type attr column user type attr column type class mod id name person attrs attribute mod id name name attrs attribute mod id name age column mod id type integer name owner age type mod id name integer visualizing tracing information free layout source target model elements 
users informed choices add override tracing information see section 
standard tracing information rule created source elements matched non nested model element patterns target elements produced model element expressions nested 
non nested model element patterns defined nested model element pattern 
example model element pattern tracing information created instances model class dog name owner person name fred may initially somewhat arbitrary try minimise source elements tracing information whilst maximising target elements 
reason minimising source elements due simple observation individual source elements matched rule execution 
causes source elements source large numbers traces obscure result transformation 
empirical observations mt transformations suggest model elements matched nested model element patterns matched non nested model element pattern separate rule execution 
case target elements different challenge emerges 
trying create optimum amount traces wishes ensure far practical target element trace associated 
target element expressions inherently localised individual rule executions highly unusual element created expression target trace 
important ensure nested target element expressions traces associated 
section shows nested model element patterns contribute tracing information desired section shows large number extra largely uninteresting traces created 
standard tracing information mechanism seen practice comparing visualized trace information transformation created section 

augmenting overriding standard mechanism whilst standard tracing creation mechanism performs cases users may wish augment override default tracing information created 
users may wish add extra tracing information emphasise certain relationships transformation remove certain tracing information unnecessarily transformation visualization 
mt provides simple capability augmenting overriding default tracing information created standard mechanism 
example mt example section base imagine wishes add extra traces source class target columns 
order achieve optional tracing add clause mt rules 
clause contain single converge expression evaluates tuple relating source target model elements 
tuple added tracing information created automatically rule 
table rule looks follows rule class table class name attrs table name cols columns tgt columns attr iterate columns extend self transform attr flatten tracing add columns note single element needs placed list create valid trace tuple 
tuple tracing add clause added tracing information automatically created rule new traces tracing number case default traces rule execution 
shows resulting visualization transformation extra tracing information added 
circumstances users may wish entirely override default tracing information simply augmenting 
override clause rule turns rules default tracing generation replacing tuple returned single converge expression clause 
tracing add tracing override mutually exclusive clauses rule 
whilst maintaining additional tracing information created modified class table rule assume wishes rules transformation prevented generating tracing information 
order achieve tracing override clauses contain tuples relating empty set source elements empty list target elements defined 
modified rules follows rule user type attr column string prefix attribute name type class name cn attrs ca column mod id type string name owner name attribute mod id name owner type class mod id name person attrs attribute mod id name name mod id name string class mod id name dog attrs table mod id name dog column mod id type integer name owner age column mod id type string name name cols attrs attrs type cols attribute mod id name name attribute mod id name age type type mod id name integer augmenting default tracing information 
self transform concat name prefix ca ca ca iterate tracing override rule primitive type attr column string prefix attribute name type name pn column name concat name prefix type pn tracing override cols tracing class table primitive type attr column user type attr column result running transformation rules altered seen 
example shows users completely customise tracing information created mt needs 

sophisticated transformations previous section introduced basics mt language simple version running example 
section delve advanced aspects mt language allow attribute mod id name name type mod id name string attribute mod id name owner class type mod id name person attribute mod id name name type attrs attrs attrs attrs class mod id name dog column mod id type string name name attribute mod id name age type mod id name integer table mod id name dog column tracing class table cols cols cols mod id type integer name owner age column mod id type string name owner name augmenting overriding default tracing information 
complex sophisticated transformations expressed 
order explore aspects fully complex version running example 

extending running example subsection define advanced variant running example 
idea translate uml class models relational database models 
order example challenging simple uml meta model extended ways seen 
extensions extend required transformation follows associations added meta model 
associations add significant degree complexity meta model classes real attributes determined union attributes directly links associations source 
attributes marked part classes primary key having theis primary attribute set true 
note associations play part determining classes primary key 
classes theis persistent attribute set true converted tables classes attribute types associations result classes primary key attributes converted columns foreign key 
classes theis persistent initialize classifier name string initialize association initialize class persistent bool initialize dest src attrs ordered mod id string string initialize type attribute primary bool name string initialize extended simple uml meta model 
attribute set true transformed tables attributes simple transformation 
relational database meta model extended shown 
extended meta model allows tables define primary keys foreign keys 
note tm data model allows nested data types expressed foreign keys defined sequence sequences columns 

pattern multiplicities problems noted section qvt partners approach model element patterns match fixed number elements 
simple transformations naturally consist rules match fixed number elements source model 
non trivial transformations contain rules need match arbitrary number source elements 
expressing transformations qvt partners approach requires cumbersome arounds 
solve problem mt adapts concept multiplicities textual regular expression languages 
source pattern mt optionally multiplicity 
multiplicities specify source pattern match source elements 
multiplicities constraint universe model elements passed parameter corresponding patterns position clause 
pattern clause optionally multiplicity table fkeys seq seq column name string initialize pkey ordered column type string name string initialize mod id string string initialize cols ordered extended relational database meta model 
associated variable binding 
example pattern multiplicity match zero associations assigning result match variable association assoc name syntax multiplicities inspired perl regular expression languages 
multiplicities possible qualifiers defined mt match exactly source elements 
match zero source elements 
match source element 
match minimum possible number source elements 

match source elements 

match minimum number source elements matched exceed matches 

match elements 

match minimum number source elements matched 
perl textual regular expressions multiplicities default greedy matching match pattern maximum number elements causes multiplicity satisfied 
backtracking clause calls multiplicity provide alternative matches returns matches lesser lengths 
concept greedy non greedy matching simpler case textual regular expressions text inherently ordered data type 
length matches calculated determining characters past fixed starting point match extends 
contrast model elements order respect mt take different approach concepts greedy non greedy matches 
mt defines length multiplicities match number times multiplicity matched model elements ordered obvious way returning successively smaller matches 
order resolve problem case greedy matching mt creates powerset matches iterates successively returning sets smaller number elements called 
note whilst mt guarantees greedy matching guarantees order sets equal size powerset returned 

qualifier reverses default greedy matching behaviour attempting match minimum number elements causes multiplicity satisfied successively returning sets greater size powerset called 

qualifier complete qualifier ensures pattern matches successfully model element passed patterns appropriate argument 
whilst 
qualifier slightly different form standard textual regular expression languages 
qualifier specific mt 
variable bindings presence multiplicities variable bindings patterns multiplicities need treated differently variables bare patterns 
multiplicity satisfied associated variable binding assigned list dictionaries 
dictionary contains variable bindings particular match pattern 
need different treatment variable bindings inside outside multiplicities easily shown examining happen treated identically 
consider incorrect mt code association src class name class name glance may suggest rule patterns part runs set class name associations source class 
example nonsensical single value 
value bound zero class names multiplicity attempts match model pattern times possible 
example shows meaning outside multiplicity bound clearly meaning context multiplicity 
order resolve mt takes stage approach 
multiplicities local variable bindings accessed normal 
successful match mt creates dictionary relating variable binding names bound values 
list values assigned variable binding associated multiplicity 
variable bindings individual match accessed 
illustrate reuse original multiplicities example association src class name printing variable lead output lines dict orders dict parts mt module provides convenience function mult extract bindings name iterates list dictionaries generated multiplicity extracts particular dictionary returning list 
standard idiom mt function self variable binding model element pattern allows user determine model elements matched particular pattern multiplicity 

extended example subsection show mt version extended example 
added complexity version transformation original simpler version due considerations 
classes transformed isolation associations class source considered order table results class contains necessary columns 

classes marked persistent transformed substantially different marked persistent 

foreign keys primary keys columns 
important column model elements pointed table appropriate model elements duplicates 
th mt example follows mt mt transformation classes tables rule persistent class table class name attrs attrs persistent association assoc src table name cols cols pkey fkeys fkeys tgt cols fkeys aa attrs mt mult extract assoc iterate cols fkeys self transform aa cols extend cols extend fkeys extend fkeys rule primary primitive type attribute columns string prefix attribute name attr name type name type name primary col col tgt col column name concat name prefix attr name type type name rule non primary primitive type attribute columns string prefix attribute name attr name type name type name primary column name concat name prefix attr name type type name rule persistent user type attribute columns string prefix attribute attr name attr name type class class name class name attrs attrs persistent cols cols tgt cols attr attrs iterate cols fkeys self transform concat name prefix attr name attr cols extend rule non persistent user type attribute columns string prefix attribute attr name attr name type class class name class name attrs attrs persistent cols tgt cols attr attrs iterate cols fkeys self transform concat name prefix attr name attr cols extend cols rule persistent association columns string prefix association name attr name dest class class name class name attrs attrs persistent cols cols tgt cols attr attrs iterate cols fkeys self transform concat name prefix attr name attr cols extend rule association non persistent class columns string prefix association name attr name dest class class name class name attrs attrs persistent association assoc src class cols fkeys tgt cols fkeys aa attrs mt mult extract assoc iterate cols fkeys self transform concat name prefix attr name aa cols extend cols rule default null order run transformation list top level elements classes associations passed 
simple version example need designate particular class start class transformation 
output transformation consist number tables 
feature particular requires explanation sense transformation 
rules patterns arguments passed function 
example non pe rule defines patterns function called arguments impossible rule execute 
mt defines rule passed fewer arguments parameters root set source elements substituted missing argument 
effectively escape mechanism allowing rules access complete source graph mechanism transformations complicated need continually pass root set source elements 
structure transformation hopefully relatively straight forward 
class rule ensures class marked persistent source model transformed table target model 
takes persistent class finds associations class source iterates union classes attributes associations source transforming columns 
rules take string prefix representing column prefix constructed transformation drills user types attribute association case association non persistent class columns rule additional set associations produces things list normal table columns list primary key columns list foreign key columns 
final rule catch rule takes model elements root set matched rules non persistent classes associations transforms object causes mt discard result transformation rule create tracing information 
rule necessary ensure elements root set source elements cause transformation raise transform exception 
shows visualization particular execution transformation 
size source model increased maximum sensibly visualized provide mt cope transformations small handful elements 
note freed space constraints visualization technique easily cope larger source models 

pruning target model thing immediately obvious viewing final target model union model elements produced rule execution 
fact take union model elements produced rule execution target model contain superfluous model elements 
reason seen examining rule association columns 
rule calls transform function effectively discards model elements produced call rule question cares primary key columns ignores non primary key columns 
knowing implementation detail tm assigns new model element unique monotonically increasing identifier see elements discarded due non contiguous model identifiers target model elements 
example lowest identifier target model element highest identifiers missing elements produced rule execution discarded rules 
mt approach achieving final target model involves firstly model elements produced column attribute mod id primary name house mod id type string name address house attribute attrs mod id primary name addr mod id name string attrs class mod id name address persistent attribute attrs mod id primary name addr column attrs mod id type string name address addr attribute mod id primary name county attrs column dest attribute mod id primary name postcode mod id type string name address addr association mod id name address column mod id type string name address county attribute mod id primary name name column src class mod id name customer persistent attrs mod id type string name address postcode table mod id name customer column mod id type string name name tracing persistent class table primary primitive type attribute columns persistent association columns association non persistent class columns non primary primitive type attribute columns column mod id type integer name orders date association mod id name orders src dest attribute mod id primary name name column mod id type string name name column mod id type integer name orders order num attrs table mod id fkeys name part column mod id type integer name id class mod id name part persistent attrs attribute mod id primary name id column mod id type integer name price attrs attribute mod id primary name price mod id name integer attribute mod id primary name date dest class mod id name order persistent attrs attrs attribute mod id primary name order num type type type type cols type type cols cols cols cols cols pkey type fkeys cols cols type type type type fkeys cols pkey pkey cols cols cols example execution extended transformation 
cols column mod id type integer name parts id association mod id name parts src column mod id type integer name date table mod id name order column mod id type integer name order num transforming element root source set 
uses elements root nodes simple graph walking scheme 
target model elements reachable elements considered eventual target model 
note scheme allow eventual target model consist unconnected subgraphs 

combinators interesting features qvt partners approach combinators 
section showed combinator qvt partners approach combinators 
combinators largely expect names 
example combinator takes rule invocations succeeds invocation succeeds 
mt rules able utilise standard converge notions success failure base combinators qvt partners approach encoded directly mt disjunction conjunction operators respectively 
contrived transformation rule match class iff attributes transformed ther orr rules rule class attributes src self self qvt partners approach defines extra semantics combinator automatically merges outputs different rules 
general case believe functionality undesirable merging outputs sensible determined fine grained level transformation writers 
building merging combinator top existing functionality relatively simple merely involves storing merging result expression conjunction 
treatment combinators mt currently simplistic direct encoding features terms primitive converge features interesting 
qvt partners combinators new primitives language mt able directly utilise converge features 
believe fruitful area research investigate powerful combinators view including useful standard library 

implementation section discuss interesting aspects mt implementation 
implementation follows typical structure dsl implementation functions seen concretely tm tra aspects implementation 
section outline novel aspects implementation relative 

mt grammar discussion mt implementation necessarily mt grammar grammar mt rules transformation id newline mt rule newline mt rule mt rule rule id indent mt newline mt mt mt inp mt mt inp indent pt newline pt mt newline src indent pt mt tgt mt mt mt tracing mt indent mt tgt expr newline expr mt newline tgt indent expr newline expr mt tracing newline tracing add indent expr newline tracing override indent expr pt pt expr pt qualifier pt expr pt iobj pattern precedence pt iset pattern precedence pt ivar precedence expr pt qualifier pt multiplicity id pt multiplicity pt multiplicity upper bound expr expr pt multiplicity upper bound pt multiplicity upper bound expr expr pt iobj pattern pt iobj pattern self pt iobj slot pt iobj pattern comparison pt expr pt iobj slot pt iobj pattern comparison pt expr pt iobj pattern self pt iobj pattern self id id id pt iobj slot id id expr expr id pt iobj pattern comparison pt iset pattern set pt iset pattern elems pt iset pattern elems set pt iset pattern elems pt iset pattern elems pt pt pt ivar id mt tgt expr expr mt tgt expr qualifier mt tgt expr qualifier expr expr pt mep pattern pt mep pattern id id expr id expr id 
outline implementation translation mt mt block converge relatively straight forward high level 
mt transformation translated single class number standard functions transform get target seen earlier fields holding tracing information function rule transformation 
translation records names transformation rules list rule names field transformation class list retains rules order source file 
subsections show rules translated definitions standard functions 

translating rules translation rule function conceptually follows path outlined example section 
translated function takes variable number arguments list containing universe elements pattern rule match 
translated source model clauses fail match arguments passed translated function rule fails 
clauses succeed return set model elements matched model element patterns dictionary bindings 
dictionary bindings passed translated clauses produce return list target elements 
matched model element patterns target elements create suitable tuple transformations tracing execution rule returns target elements produced 
simplified version outer translation rule follows func mt rule node mt rule rule id indent mt src newline mt return bound func cei name node value objs mep objects bindings self preorder node apply objs return fail target elements self preorder node bindings raise exceptions exception strings format cei lift failed generate objs str self tracing append mep objects target elements return target elements line translates rules source model clauses note source model clauses fail entire rule fails 
source model clauses succeed translation target model clauses line executed 
failure target model clauses deemed fatal error exception raised 
note concept backtracking target source model clauses source model clause successfully matched target model clauses executed 
final part rule line creates necessary tracing information 
translation rules source model clauses contains subtleties ensure backtracking patterns works correctly explored upcoming subsections 
target model clauses essentially fairly standard imperative code addition model element expressions translation largely uninteresting consequently elided 
translation clauses complicated need embed normal converge code ensure unintended interactions translated embedded code see sections 

translating rules source model clauses rule potentially contains source model clauses clauses optional 
pattern clause translated generator function takes list model elements converge dictionary bindings 
time pattern matches successfully returns list containing items list model elements matched model element patterns dictionary new bindings object pattern evaluated 
largely internal detail needed support nesting patterns 
section contains detail translation patterns 
pattern generator needs placed construct ensure possible matches generated 
pattern clause patterns translated inside nested constructs pattern outermost construct pattern innermost 
slightly complicates translation iterates patterns order parse tree 
order achieve desired effect standard idiom 
patterns translated temporary list 
translated clause exists innermost construct 
temporary list iterated reverse order iteration placing result previous iteration inside construct 
idiom highly useful shows simple example dsl translation translated code directly reflect order source 
noting lists function iterates reverse order list simplified version translation follows translated patterns ordered translated patterns patterns expr self preorder src clause translated pattern translated patterns patterns expr translated pattern patterns expr simple translation deals part problem caused failure pattern causes backtracking earlier clause 
pattern matches returns list containing items list model elements matched model element patterns dictionary new bindings object pattern evaluated 
pattern clause matched rules records matched model element patterns variable bindings grow 
pattern fails list elements matched model element patterns variable bindings created need undone rules records 
failure pattern may cause failure arbitrary number preceding patterns undo mechanism needs arbitrary depth 
mt converge variable capturing scoping rules implement simple reasonably efficient undoing mechanism 
rule defines variables matched mp elems bindings store rules evolving list matched model pattern elements variable bindings 
variables available translated pattern 
translated pattern defines variables private pattern hidden converge scoping rules mp elems backup backup 
names variables may suggest store values mp elems variables pattern matched pattern match successfully required generate new matches restore value 
slightly elided version translation function follows func mt src node mt src mt mt mt indent pt spattern newline pt spattern translated patterns ordered translated patterns node len mt newline src indent expr patterns expr self preorder node return matched mp elems bindings mt patterns expr return matched mp elems bindings translated patterns len patterns expr cei lift args len elements args cei lift elements self 
root set matched mp elems backup matched mp elems bindings backup bindings new matched mp elems new bindings matched elem translated patterns bindings elements matched mp elems matched mp elems new matched mp elems bindings bindings new bindings patterns expr matched mp elems matched mp elems backup bindings bindings backup return func args args len cei lift translated patterns len return fail matched mp elems set bindings dict patterns expr return fail 
translating patterns subsection show patterns translated mt translation pattern multiplicities detailed section 
pattern translated generator function takes list model elements converge dictionary bindings 
time pattern matches successfully returns list containing items list model elements matched model element patterns dictionary new bindings object pattern evaluated 
patterns number pattern expressions model element patterns set patterns variable bindings normal converge expressions 
pattern expressions may arbitrarily nest pattern expressions 
pattern expression translated generator generate zero matches model elements 
translation complicated fact nested pattern expressions generators pattern asked backtracking generate new matches backtracking may need resume levels deep nested pattern expression 
translated pattern expressions contain wrapper iterates objects passed pattern passes time pattern expression 
pattern expression generator result immediately yielded translated patterns caller 
noting yield converge expression outer translation follows func pt spattern node pt spattern pt spattern expr return func bindings elements element elements iterate yield self preorder node bindings element return fail subsections detail type pattern expression translated mt 
translating variable bindings simplest type pattern expression mt translation variable bindings simple func pt svar node pt svar id self pattern vars add node value var str cei lift node value return func bindings element bindings contains var str bindings var str element return fail return set dict var str element element lines check see variable question bound value existing binding compared element matched ensure equality 
original new binding values equal variable binding fails 
behaviour largely redundant mt exactly effect achieved having initial variable binding followed variable 
behaviour maintained sake ensuring backwards compatibility qvt partners approach 
mt translation encounters variable bindings adds set known variable bindings translations pattern vars field line 
information different ways 
firstly set variable bindings determine valid variable subsequent patterns clauses rule necessary variable bindings patterns multiplicities dealt differently see sections 
secondly variables converge expression variable binding need translated dictionary lookup current set known bindings see section 

translating model element patterns translation model patterns largest individual part mt translation split parts matching model element type dealing self variable matching model element slots 
part relatively simple 
part complicated need deal nested pattern expressions 
subsection simplified translation model element patterns deal nested pattern expressions presenting complete translation 

simplified translation order understand translation model element patterns consider simplified variant 
model element patterns simple variant contain self variable slot comparisons nested pattern expressions evaluated 
slot comparison fails entire pattern fails immediately 
interests brevity equality inequality slot comparisons translated 
subset encompasses number interesting useful model element patterns dog name owner person name fred simplified translation follows func pt pattern node pt pattern pt pattern self pt slot pt pattern comparison pt spattern expr pt slot pt pattern comparison pt spattern expr pt pattern self pt pattern self id type match tm type match cei lift node value element return fail slot comparisons node len node conforms list node pt slot slot name node slot comparison node slot pattern node slot comparison type slot condition cei comparison elif slot comparison type slot condition cei ineq comparison slot comparisons append slot element element cei name slot name value new matched mep elems new bindings matched elem self preorder slot pattern bindings slot element return fail slot condition slot element matched elem return fail local bindings new bindings return func bindings element local bindings dict type match slot comparisons return set element local bindings element lines deal ensuring model element matched correct type 
lines shown heart translation slot comparisons 
line extracts value model elements slot 
line evaluates slots pattern slots pattern fails reason entire model pattern fails 
hitherto unused third element hitherto referred object pattern evaluated returned pattern expression compared value model elements slot obtained line slot comparison operator 
comparison operator fails entire model pattern fails 
seen line model element pattern ignores model elements matched nested model element patterns 
clumsy term object pattern evaluated conceptually distinct ways pattern expression evaluates 
converge expressions patterns fred see section simply evaluate object checked model elements slot 
types pattern expressions model element pattern person name fred passed value model elements slot asked match return value model elements slot unchanged 
words types pattern expressions converge expressions evaluate new object whilst return object passed model element patterns 
note case necessary check slot comparison evaluation element patterns functionally equivalent previous example evaluate correctly dog name owner person name fred 
ensuring complete evaluation nested pattern expressions preceding translation model element patterns contains major flaw correctly deal nested pattern expressions may generate match 
consider pattern dog name allowable foods set set pattern set potentially generate match element set matched 
example rule pattern part contains clause lines ofx vital set pattern generates possible matches ensure correct match exists 
previous translation model elements nested set pattern happened stumble correct combination iteration entire rule part fail 
general case pattern expressions may nested arbitrary depth 
mt needs ensure pattern expressions matter deep nested generate possible matches 
model element patterns desirable pattern expressions slot comparisons generate multiple matches predictable fashion 
pattern expressions evaluated deliberately similar fashion patterns clause order defined left right 
model element pattern requested generate matches right pattern expression generate match possible 
pattern expression model element pattern generates possible matches pattern expression left generates new match causes control flow return right causing pattern generate new match 
pattern expressions model element pattern generated matches model element pattern fails 
common patterns clause mt ensures time pattern expression fails appropriate variable bindings undone 
order cope arbitrary levels nested pattern expressions reasonably expect significant degree complexity needed translation indexes lists needing passed stored 
careful converge generators conjunction operator desired effect achieved relatively small amount code 
considering marginally simplified variant model element patterns previously self variable allowed subset slot comparison operators dealt translation follows func pt pattern node type match tm type match cei lift node value element return fail returns vars current bindings var cei ivar cei fresh name conjunction current bindings var bindings node len node conforms list node pt slot slot name node slot comparison node slot pattern node slot comparison type slot condition cei comparison elif slot comparison type slot condition cei ineq comparison bindings var cei ivar cei fresh name return var cei ivar cei fresh name returns vars append return var conjunction append return var func current bindings var conjunction append bindings var current bindings var return var current bindings var bindings var conjunction append set element functional foldl adder functional map element cei ilist returns vars element return func bindings element type match yield cei conjunction return fail func adder return func element return func element return note code adder element element module level functions 
functions translations 
underlying theme translation pattern expressions slot comparisons may generators 
pattern expressions placed single conjunction expression chiefly built lines 
translation places conjunction containing translated pattern expressions construct line yields value time successful match slot comparisons 
translation utilizes converge built goal directed evaluation ensure possible values including nested pattern expressions translated slot comparisons evaluated 
somewhat related aspects translation require explanation 
relates mt treatment variable bindings particularly need undo variable bindings slot comparison fails converge backtracks 
essentially slot comparison added conjunction mt creates new uniquely named variable line assigned union existing variable bindings created pattern expression lines 
pattern expression slot comparison uses union variable bindings set currently valid bindings line 
converge backtracks currently valid bindings implicitly undone union existing new bindings performed translated slot comparisons 
second aspect relates value returned model element pattern created lines 
model element patterns ignore elements matched nested model element patterns section surprising element returned list set containing element matched current model element pattern 
second element returned list initially functions operate lisp counterparts 
tackling directly need investigate vars variable translation list containing quasi quoted variables 
essentially time nested pattern expression evaluated new return var variable created line return value pattern expression assigned line 
return var variable added return vars list line 
return var variable holds standard element list 
call line passed list lists run time sub list list containing elements returned pattern expression 
element function selects variable bindings generated slot comparison adder function creates union variable bindings 
union non strict subset final value current bindings var include bindings passed model element pattern argument 
note whilst may initially appear simpler return vars run time variable pattern expressions return list appended lead complications back tracking require items list removed 
variables vars known compile time possible achieve small optimization moving call compile time left exercise reader 
interesting compare translation patterns clause section 
transformations essentially functionally equivalent earlier translation initially appealing reuses familiar concept nested constructs 
translation section uses familiar conjunction operator results shorter idiomatic marginally efficient translation 
may suggest making common features converge significant advantage translating dsls 

translating set patterns subsection outline translation set patterns delve code translation uses techniques idioms outlined translation model element patterns 
essentially set patterns match single element patterns left character subset patterns right character simultaneously 
single element pattern mt iterates set matched single element patterns matched element simultaneously 
subset pattern mt iterates powerset set match 
intersection subsets including set comprised single element patterns matched 
union subsets including set comprised single element patterns matched equal set matched 
set patterns generate appropriate return value single element pattern subset pattern match successfully 

translating converge expressions patterns outlined section converge expressions pattern expressions act different fashion pattern expressions 
types pattern expressions declarative match model elements converge expressions simply expected evaluate constants situation meaning integers strings model elements 
mt defines converge expressions situation evaluated particular converge expression generator required generate single value 
converge expressions pattern expressions return list consisting empty set represent model elements matched model element patterns empty dictionary bindings constant object expression evaluated 
translation converge expressions instance requires thin wrapping actual expression func pt spattern expr node pt spattern expr pt pattern pt pattern pt svar expr node expr return func bindings elements return set dict self preorder node return self preorder node section details converge grammar embedded mt grammar 

example translated pattern having seen translations variable bindings model element patterns set patterns converge expressions pattern expressions position see result translating particular pattern 
pattern incorporates types pattern expressions dog name allowable foods set result translating pattern unbound func bindings element input pattern creator tm type match dog element return input pattern creator fail yield bindings unbound func bindings slot element element name matched mp elems new bindings matched elem unbound func bindings element bindings contains bindings element return input pattern creator fail return set dict element element bindings slot element slot element matched elem yield matched mp elems new bindings matched elem return input pattern creator fail unbound func bindings slot element element allowable foods matched mp elems new bindings matched elem unbound func bindings element element conforms input pattern creator set return input pattern creator fail element len return input pattern creator fail element iterate unbound func bindings elements return set dict bindings input pattern creator functional 
powerset generator element union set element contains unbound func bindings element bindings contains bindings element return input pattern creator fail return set dict element element bindings yield element return input pattern creator fail bindings slot element slot element matched elem yield matched mp elems new bindings matched elem return input pattern creator fail set element input pattern creator 
functional foldl input pattern creator adder input pattern creator functional 
map input pattern creator element element return input pattern creator fail bindings element despite initial appearance impenetrable named identifiers careful examination input pattern translations section possible identify parts relate specific parts input pattern 
step recursively break input pattern constituent pattern expressions 
determine line numbers pattern expression relates 
simple table showing follows note due recursive breakdown outer pattern expressions line numbers overlap nested pattern expressions pattern lines dog name allowable foods set set 
translating pattern multiplicities order deal patterns multiplicities see section additions need outer translation patterns section 
forms pattern multiplicities requires specific translation follow general form split distinct phases 
order demonstrate translation multiplicity elided view pt spattern function func pt spattern node pt spattern pt spattern expr pt spattern qualifier pt spattern qualifier pt multiplicity id pt multiplicity pt multiplicity upper bound pt multiplicity upper bound self inside multiplicity pattern pattern func bindings elements matches element elements iterate matches append self preorder node bindings element powerset functional powerset matches powerset sort sort powerset func return len len matches powerset matches len continue yield functional foldl adder functional map element matches dict cei lift node value functional map element matches functional foldl adder functional map func return matches return set dict cei lift node value elements self inside multiplicity pattern return pattern phase multiplicities execution involves matching elements 
case multiplicity occurs lines evaluates successful match pattern note pattern match successfully backtracking ensures call executed 
second phase execution successively returns permutations matches 
note case multiplicity multiplicities phases partially intertwined 
lines evaluate powerset matches sorting resulting permutations ascending order number elements 
construct line iterates powerset reverse order yielding permutations lesser size multiplicity called generate new matches 
list yielded multiplicity lines simpler may appear 
line unions elements matched model element patterns match permutation 
lines create single binding multiplicities variable assigning list variable bindings bindings entry match permutation 
lines union objects match permutation evaluated 
translation pattern multiplicities requires small important change translation variable bindings prevent variable bindings multiplicities added pattern vars field 
inside multiplicity pattern field translation tracks translation currently processing pattern multiplicity 
updated pt svar function looks follows func pt svar node pt svar id inside multiplicity pattern self pattern vars add node value var str cei lift node value return func bindings element bindings contains var str bindings var str element return fail return set dict var str element element function returns list lists case passed list set 

standard functions transformation standard functions particular importance functions 
subsection show definition functions 
function outlined section 
takes variable number arguments list 
noting function objects converge function apply takes list values applies function passed individual arguments function looks follows func transform elems elem elems iterate elem conforms list raise exceptions type exception list elem instance elem str rule name self rule names iterate target self get slot rule name apply elems return target raise exceptions exception strings format unable transform elems str action function type check arguments lines 
rule names field transformation records names transformations rule order defined 
iterating rule names field allows translated rule function accessed slot function 
transform function calls rules order defined succeeding soon finds rule executes input 
rules execute exception raised 
function simple highly useful convenience function built top transform function 
list model elements transforms function 
definition simple func transform elems elems conforms list raise exceptions type exception list elems instance elems str target elems elem elems iterate target elems append self transform elem return target elems 
embedding converge code dsls compared model transformation approaches mt novel aspects ability embed gpl code 
possible due converge dsl embedding features 
ability embed converge code dsl benefits dsl users implementers 
users reuse knowledge standard converge whilst dsl implementers reuse tried trusted parts converge compiler 
subsection explain dsl embed converge 
key embedding normal converge code seen expr mt grammar section rule converge grammar appendix 
point note rules mt grammar prefixed mt allows mt grammar merged converge grammar conflicts 
grammars currently defined strings merging grammars simply case adding strings 
currently notion grammar namespaces checks conflicts grammars 
may suggest whilst current implementation feature workable refined parts dsl implementation converge 
dsl grammar merged main converge grammar question converge grammar handle parse tree fragments related converge grammar 
currently translation class mt subclasses generator class converge compiler 
generator contains translation rule converge grammar works exactly way dsl translation class 
mt subclass need add appropriate traversal functions rules specific mt grammar 
subclassing large complex classes thought dangerous generator module specifically designed sub sort mind 
normal converge expressions translated free generator module little interference mt mt subclass fact requires interaction superclass needing override var function 
essentially variable bindings translated dictionary lookups variable see section see section 
elided version var translation function follows func var node var id self pattern vars contains node value return bindings cei lift node value return generator generator var node summary despite need add strings representing grammars subclass complex class residing depths converge compiler process embedding converge code dsls surprisingly simple relatively free complications 
unclear approach scale satisfactorily larger examples 
believe things may need changed improve situation 
firstly grammars need properly modularised ensure naming problems grammars arise relationship grammars clearly stated 
secondly useful loosen coupling dsls generator module possibly removing requirement subclass generator class 

extending converge grammar section far ignored translation rules target clauses presence model element expressions clauses worthy examination 
brief recap model element expressions dog name fido owner person name fred create new model elements syntactically similar identical model element patterns 
section contains details model element expressions 
model element expressions rules target clauses normal converge expression 
may suggest model element expressions top level target clauses fact converge expressions 
example expression shows model element expression converge list person name fred example shows context target clauses model element expressions effectively embed base converge language 
embedding model element expressions currently implemented advantage fact grammars strings production rules alternatives added point grammar 
mt grammar section expr rule converge grammar extended new alternative mt pointing mep pattern rule 
translation function converge compiler immediately hands computation rule named alternatives mt translation class needs provide simple translation function mep pattern 
noted whilst extremely powerful technique generally applicable 
currently requires detailed knowledge converge grammar converge compilers internals order ensure extending rule converge grammar desired effect 
hope versions converge able provide safer support extension sort 

preventing unintended interaction translated embedded code challenges tackled tm dsl preventing unintended variable capture dsl input translated dsl code 
problem arises derived user input placed inside containing dynamically scoped variables 
seen translations section dynamically scoped variables occur frequently chiefly var syntax 
dynamically scoped variables highly useful allowing built piece meal 
whilst statically scoped variables automatically safely renamed converge scoping rules dynamically scoped variables may cause variable capture derived user input 
example variable bindings frequently dynamically scoped translations section mt variable name example clause unexpected results certainly arise 
prevent problem occurring mt performs renaming variables converge expressions 
mt takes advantage fact report free bound variables get free vars get bound vars functions respectively 
essentially rule mt calculates free bound variables converge expressions contained rules clauses 
variable fresh name generated dictionary records mapping original fresh names 
mt encounters converge variables translation translates variables corresponding fresh name 
renaming variables users input mt ensures unintended variable capture 
variables safely renamed rules free variables require extra treatment 
example name function section free variable context tables transformation defined outside transformation 
instances name rule renamed variable lines concat name 
point link value name outside rule value concat name 
mt adds translated rules assignments original value variables fresh name equivalent 
case name function result translation look lines concat name concat name 
concat name bindings 

assigning variables outer blocks renaming mechanism variables user input prevents unintended variable capture introduces problems due disconnect original variable fresh named clone 
leads related problems 
problem relates assigning free variables 
fresh named clone free variable assigning free variables mt block affect value original variable 
mt mirrors normal converge expectation variables assigned block block mt essentially rule local block 
problem arises wishes assignment free variable 
assume mt allows free variables declared nonlocal recall normal converge nonlocal declaration assignment variable create local binds outer block contains assignment 
assignment free variable problematic user assigning variables fresh named clone furthermore way assign original variable prospect variable capture 
partial solution problem mt mirror assignment free variables fresh named clone translated rule assignment fresh named clone free variable equivalent transformation 
whilst possible means execution rule local global values variable may differ 
highlights general problem point execution rule values original variable fresh named clone may diverge assignment original variable fresh named clone 
solution problem moment converge 
devise increasingly sophisticated arounds reduce potential problem arise fundamentally cloning variables flawed mechanism atomically synchronising cloned original variables 
highlights deficiency converge 
possible solution deficiency converge acquire variable alias feature alias variable outer block inner block 
names merely aliases underlying variable synchronization issues 
feature ideally way nonlocal declaration implicit aliased variables nonlocal block renamed 
converge vm provides sufficient support feature compiler language sufficiently extended 

generating tracing information nested model patterns section standard mt tracing information creation mechanism outlined 
default model element patterns contribute source part trace tuples 
asserted empirically appeared sensible compromise created sufficient tracing information overwhelming user 
clear technique may suitable applications easily imagine research determine practical tracing information creation techniques different types transformations 
subsection simple modification mt translation changes default tracing information created allowing nested model element patterns contribute source part trace tuples 
serves separate purposes 
firstly provides evidence default tracing information creation mechanism achieves useful balance terms volume information creates 
second shows dsl implementations converge tend amenable changes mt implementation serve testbed model transformation experimentation 
modification mt necessary allow nested model expression patterns contribute source part trace tuples fact simple 
essentially needed model element patterns return union elements matched nested model element patterns 
default model element patterns return element matched essentially ignoring elements matched nested model element patterns 
required information var associated slot comparison model element pattern 
needed technique union bindings slot comparison 
replacing lines complete translation section achieves desired effect conjunction append set element functional foldl adder functional map element cei ilist returns vars functional foldl adder functional map element cei ilist returns vars element exactly source model transformation result making change mt seen mt tracing information nested model pattern expressions 
note new visualization see target elements tracing information source element result harder read add significantly users understanding transformation particular case 

summary implementation section analysis major parts mt implementation 
demonstrate result mt translation transformation section shows complete result translating simple mt transformation section 
related majority existing systems mt unidirectional stateless model transformation system 
mt obvious ancestor qvt partners approach qvt pioneered patterns model transformations 
mt takes base qvt partners pattern language enriches features pattern multiplicities variable slot comparisons 
furthermore providing concrete implementation detailed explanation implementation vagueness associated model transformations qvt partners approach avoided mt significant difference qvt partners approach mt imperative aspects 
due implementation converge dsl mt embed normal converge code 
contrasts sharply qvt partners approach forced define ocl variant imperative features order usable language 
explained section variant language suffers conceptual practical problems 
believe mt unique able embed gpl 
significant actual language embedded mt transformations ability call naturally normal converge code defined outside transformation 
mt users constrained limitations particular model transformation approach 
may initially appear mere implementation detail differentiates mt virtually existing model transformation approaches typically highly constrained execution environment 
closest model transformation approach commercial language approach essentially qvt partners approach 
means issues noted section section respect qvt partners approach apply equally 
notable sister language allows changes propagated style outlined clark tc 
publication show mt evolved powerful change propagating language 
column association mod id name parts fkeys mod id type integer name parts id table mod id name order column dest mod id type integer name date class mod id name part persistent attribute attrs mod id primary name id cols cols pkey cols pkey src column attrs mod id type integer name order num attribute mod id primary name price type attribute mod id primary name order num type type mod id name integer cols column mod id type integer name price column mod id type integer name id type attrs class mod id name order persistent attrs attrs attribute mod id primary name date table mod id fkeys name part column mod id type integer name orders order num dest cols pkey cols tracing persistent class table primary primitive type attribute columns persistent association columns association non persistent class columns non primary primitive type attribute columns attribute mod id primary name name table mod id name customer class mod id name customer persistent attrs attribute mod id primary name name fkeys type type type type type type type cols cols cols cols cols pkey cols mod id name string cols cols column mod id type integer name orders date association mod id name orders column mod id type string name name src column mod id type string name address addr column src mod id type string name address house attribute mod id primary name addr association mod id name address column mod id type string name name tracing information nested model pattern expressions 
attribute attrs mod id primary name house dest attrs class mod id name address persistent column attrs attribute mod id primary name addr mod id type string name address addr attrs attribute mod id primary name county column attrs mod id type string name address county attribute mod id primary name postcode column mod id type string name address postcode surprisingly simplicity task mt distinctive features automatic creation tracing information 
approaches neglect problem tackle dstc approach dic require user manually specify tracing information created 
patterns defined user automatically derive tracing information best knowledge system 
mt distinguishes simple effective technique reducing superfluous tracing information 
telling mt contains enhancements compared existing approaches shares limitations existing approaches lack rule structuring mechanisms 
section outlines may resolve limitations 

believe mt currently advanced model transformation languages available relative immaturity area means new approach claim definitive solution 
pressing question model transformation approach including mt regards scalability 
mt express transformations order magnitude low tens rules clear order larger transformations feasible new techniques structuring combining rules required 
example currently rules mt transformation exist single namespace notion transformation modules 
similarly moment rules exist level element transform rules tried order 
complex transformations require selective mechanisms determine rules executed structuring efficiency reasons 
moment transformations execution time worst case proportional number rules transformation authors larger transformations may require domain knowledge narrow number rules transform elements 
believe analysing combinators functional languages may lead new insights better structure transformations desirable scalability concrete manifestation nebulous problem surrounding model transformations usability 
whilst advanced tools users vital tools relatively easy 
believe significant done presenting model transformation languages different users 
mt serve useful purpose allowing model transformation languages easily tailored different audiences 
terms details aspects mt usefully improved 
example irritation encountered relates suffix expressions rules clause 
currently rules generally produce top level elements expressions clause 
occasionally lead cumbersome dangerous arounds employed 
useful suffix fold elements produced expression produced top 
new small language similar examples easily mt suggestion partly result conversation bernhard rumpe visit technische universit braunschweig february 

summary mt model transformation language 
started examining qvt partners approach mt partly derived depth 
identifying strengths weaknesses approach explains underlying design decisions taken mt explored mt basic features including novel visualization abilities transformations including automatically generated tracing information 
explored mt advanced features pattern multiplicities allowed sophisticated model transformation concisely expressed 
finished examining depth translation mt transformation mt believe mt model transformation approach detailed analysis implementation 
doing hope mt demonstrates practical idioms implementing model transformation engines 
analysis may serve useful point model transformation engine authors 
source code mt freely available hope analysis allow take mt alter purposes 
way hope mt aids experimentation differing model transformation techniques 
mt implementation notable relative brevity 
careful converge idioms generators goal directed evaluation assert tedious machinery needed mt implemented standard gpl avoided 
outside scope hard numbers back claim believe mt provides compelling evidence seemingly disparate influences converge icon goal directed evaluation data model template haskell compile time meta programming coalesce form natural highly powerful development environment 
converge grammar section lists grammar converge 
extracted directly converge compiler file compiler cv parser cv top level definition newline definition definition class def func def import var var expr splice import import dotted name import dotted name import dotted name id id import id class def class class name class class metaclass indent class fields class name id splice class expr expr class metaclass metaclass expr class fields class field newline class field class field class def func def var expr splice pass func def func type func name func params indent func expr body func type func name func params indent func expr body newline func type func bound func unbound func func name id splice func params func params elems func func params elems func func params elems var func param default var func param default splice func param default expr func var splice func nonlocal id id newline expr body expr newline expr expr class def func def try number var dict set list dict string slot lookup precedence list application precedence lookup precedence slice precedence return yield raise assert break continue conjunction precedence alternation precedence assignment precedence precedence neg precedence binary precedence comparison precedence pass import splice precedence quasi quotes brackets expr indent expr body elif expr indent expr body newline elif elif newline elif expr indent expr body newline elif expr indent expr body newline newline indent expr body newline indent expr body newline expr indent expr body exhausted broken expr expr indent expr body exhausted broken expr try try indent expr body try catch try try catch newline catch expr try catch var indent expr body try catch var var try newline indent expr body exhausted newline exhausted indent expr body broken newline broken indent expr body number int var id id splice string string slot lookup expr id expr splice list expr expr dict dict expr expr expr expr dict set set expr expr set application expr expr expr expr lookup expr expr slice expr expr expr expr expr expr expr expr expr id return return expr return yield yield expr raise raise expr assert assert expr break break continue continue conjunction expr expr expr alternation expr expr expr assignment assignment target assignment target assignment type expr assignment target var slot lookup lookup slice assignment type expr neg expr binary expr binary op expr binary op precedence precedence precedence precedence precedence comparison expr comparison op expr comparison op pass pass splice expr splice block splice expr splice expr block splice expr indent quasi quotes expr quasi quotes defn quasi quotes expr quasi quotes indent expr newline expr newline expr newline expr defn quasi quotes definition newline definition indent definition newline definition newline brackets expr simple classes tables transformation classes tables class classes tables rule names class table user type attr column primitive type attr column bound func init root set self root set root set self transformed cache dict self matched objs set self tracing self tracing rule rule name self rule names iterate self transformed cache rule name dict self output self transform root set bound func get source return self root set bound func get target return self output bound func get conflict objects return bound func transform objs obj objs iterate obj conforms mt list raise mt exceptions type exception mt list obj instance obj str rule name self rule names iterate output self get slot rule name apply objs return output raise mt exceptions exception mt strings format unable transform objs str bound func transform objs objs conforms mt list output objs obj objs iterate output objs append self transform obj elif objs conforms mt set output objs set obj objs iterate output objs add self transform obj raise mt exceptions exception objs instance name return output objs bound func class table objs self self matched objs bindings unbound func args args len return input pattern creator fail matched mp elems set bindings dict args len elements args elements self root set matched mp elems backup matched mp elems bindings backup bindings new matched mp elems new bindings matched elem unbound func bindings elements element elements iterate yield unbound func bindings element input pattern creator tm type match class element return input pattern creator fail yield unbound func bindings element bindings contains bindings element return input pattern creator fail return set dict element element bindings element bindings unbound func bindings slot element element name matched mp elems new bindings matched elem unbound func bindings element bindings contains bindings element return input pattern creator fail return set dict element element bindings slot element slot element matched elem yield matched mp elems new bindings matched elem return input pattern creator fail unbound func bindings slot element element attrs matched mp elems new bindings matched elem unbound func bindings element bindings contains bindings element return input pattern creator fail return set dict element element bindings slot element slot element matched elem yield matched mp elems new bindings matched elem return input pattern creator fail set element input pattern creator functional foldl input pattern creator adder input pattern creator functional map input pattern creator element element return input pattern creator fail bindings element return input pattern creator fail bindings elements matched mp elems matched mp elems new matched mp elems bindings bindings new bindings return matched mp elems bindings matched mp elems matched mp elems backup bindings bindings backup return input pattern creator fail apply objs self matched objs extend matched objs rtn unbound func matched objs bindings id output pattern creator concat id matched objs self transformed cache class table contains id return self transformed cache class table id tracing self tracing len bindings bindings bindings columns attr iterate columns extend self transform attr flatten elems elems append unbound func user args dict name cols columns args args processed attr name output pattern creator tm attrs order output pattern creator tm classes repository table 
iterate args processed user args len break user args contains attr name args append user args attr name args processed args append output pattern creator null return output pattern creator tm classes repository table 
new apply args elem elems self transformed cache class table id elem elem output pattern creator null tracing output pattern creator list matched objs elems tracing output pattern creator trace reduce tracing self tracing insert tracing tracing self tracing rule insert tracing class table return elem matched objs bindings raise mt exceptions exception mt strings format output pattern class table failed generate objs str return rtn return mt fail bound func user type attr column objs concat name concat name self self matched objs bindings unbound func args args len return input pattern creator fail matched mp elems set bindings dict args len elements args elements self root set matched mp elems backup matched mp elems bindings backup bindings new matched mp elems new bindings matched elem unbound func bindings elements element elements iterate yield unbound func bindings element input pattern creator tm type match string element return input pattern creator fail yield unbound func bindings element bindings contains prefix bindings prefix element return input pattern creator fail return set dict prefix element element bindings element bindings set element input pattern creator functional foldl input pattern creator adder input pattern creator functional map input pattern creator element element return input pattern creator fail bindings element return input pattern creator fail bindings elements matched mp elems matched mp elems new matched mp elems bindings bindings new bindings args len elements args elements self root set matched mp elems backup matched mp elems bindings backup bindings new matched mp elems new bindings matched elem unbound func bindings elements element elements iterate yield unbound func bindings element input pattern creator tm type match attribute element return input pattern creator fail yield bindings unbound func bindings slot element element name matched mp elems new bindings matched elem unbound func bindings element bindings contains bindings element return input pattern creator fail return set dict element element bindings slot element slot element matched elem yield matched mp elems new bindings matched elem return input pattern creator fail unbound func bindings slot element element type matched mp elems new bindings matched elem unbound func bindings element input pattern creator tm type match class element return input pattern creator fail yield bindings unbound func bindings slot element element name matched mp elems new bindings matched elem unbound func bindings element bindings contains cn bindings cn element return input pattern creator fail return set dict cn element element bindings slot element slot element matched elem yield matched mp elems new bindings matched elem return input pattern creator fail unbound func bindings slot element element attrs matched mp elems new bindings matched elem unbound func bindings element bindings contains ca bindings ca element return input pattern creator fail return set dict ca element element bindings slot element slot element matched elem yield matched mp elems new bindings matched elem return input pattern creator fail set element input pattern creator functional foldl input pattern creator adder input pattern creator functional map input pattern creator element element return input pattern creator fail bindings slot element slot element matched elem yield matched mp elems new bindings matched elem return input pattern creator fail set element input pattern creator functional foldl input pattern creator adder input pattern creator functional map input pattern creator element element return input pattern creator fail bindings element return input pattern creator fail bindings elements matched mp elems matched mp elems new matched mp elems bindings bindings new bindings return matched mp elems bindings matched mp elems matched mp elems backup bindings bindings backup matched mp elems matched mp elems backup bindings bindings backup return input pattern creator fail apply objs self matched objs extend matched objs rtn unbound func matched objs bindings id output pattern creator concat id matched objs self transformed cache user type attr column 
contains id return self transformed cache user type attr column id tracing self tracing len prefix bindings prefix bindings cn bindings cn ca bindings ca elems elems append unbound func output objs ca ca iterate output objs append self transform concat name prefix ca return output objs elem elems self transformed cache user type attr column id elem elem output pattern creator null tracing output pattern creator list matched objs elems tracing output pattern creator trace reduce tracing self tracing insert tracing tracing self tracing rule insert tracing user type attr column return elem matched objs bindings raise mt exceptions exception mt strings format output pattern user type attr column failed generate objs str return rtn return mt fail bound func primitive type attr column objs concat name concat name matched objs bindings unbound func args args len return input pattern creator fail matched mp elems set bindings dict args len elements args elements self root set matched mp elems backup matched mp elems bindings backup bindings new matched mp elems new bindings matched elem unbound func bindings elements element elements iterate yield unbound func bindings element input pattern creator tm type match string element return input pattern creator fail yield unbound func bindings element bindings contains prefix bindings prefix element return input pattern creator fail return set dict prefix element element bindings element bindings set element input pattern creator functional foldl input pattern creator adder input pattern creator functional map input pattern creator element element return input pattern creator fail bindings element return input pattern creator fail bindings elements matched mp elems matched mp elems new matched mp elems bindings bindings new bindings args len elements args elements self root set matched mp elems backup matched mp elems bindings backup bindings new matched mp elems new bindings matched elem unbound func bindings elements element elements iterate yield unbound func bindings element input pattern creator tm type match attribute element return input pattern creator fail yield bindings unbound func bindings slot element element name matched mp elems new bindings matched elem unbound func bindings element bindings contains bindings element return input pattern creator fail return set dict element element bindings slot element slot element matched elem yield matched mp elems new bindings matched elem return input pattern creator fail unbound func bindings slot element element type matched mp elems new bindings matched elem unbound func bindings element input pattern creator tm type match element return input pattern creator fail yield bindings unbound func bindings slot element element name matched mp elems new bindings matched elem unbound func bindings element bindings contains pn bindings pn element return input pattern creator fail return set dict pn element element bindings slot element slot element matched elem yield matched mp elems new bindings matched elem return input pattern creator fail set element input pattern creator functional foldl input pattern creator adder input pattern creator functional map input pattern creator element element return input pattern creator fail bindings slot element slot element matched elem yield matched mp elems new bindings matched elem return input pattern creator fail set element input pattern creator functional foldl input pattern creator adder input pattern creator functional map input pattern creator element element return input pattern creator fail bindings element return input pattern creator fail bindings elements matched mp elems matched mp elems new matched mp elems bindings bindings new bindings return matched mp elems bindings matched mp elems matched mp elems backup bindings bindings backup matched mp elems matched mp elems backup bindings bindings backup return input pattern creator fail apply objs self matched objs extend matched objs rtn unbound func matched objs bindings id output pattern creator concat id matched objs self transformed cache primitive type attr column 
contains id return self transformed cache primitive type attr column id tracing self tracing len prefix bindings prefix bindings pn bindings pn elems elems append unbound func user args dict name concat name prefix type pn args args processed attr name output pattern creator tm attrs order output pattern creator tm classes repository column 
iterate args processed user args len break user args contains attr name args append user args attr name args processed args append output pattern creator null return output pattern creator tm classes repository column 
new apply args elem elems self transformed cache primitive type attr column id elem elem output pattern creator null tracing output pattern creator list matched objs elems tracing output pattern creator trace reduce tracing self tracing insert tracing tracing self tracing rule insert tracing primitive type attr column return elem matched objs bindings raise mt exceptions exception mt strings format output pattern primitive type attr column failed generate objs str return rtn return mt fail ac mart abadi luca cardelli 
theory objects 
springer 
big ted biggerstaff 
pattern matching program generation user manual 
technical report tr microsoft research 
tony clark andy evans paul sammut james 
applied metamodelling foundation language driven development september 
available www com accessed sep 
cor james cordy 
txl language programming language tools applications 
proc 
acm th international workshop language descriptions tools applications april 
dic dstc ibm 
mof query views transformations revised submission august 
omg document ad 
omg object management group 
meta object facility mof specification 
formal 

response mof query views transformations rfp august 
omg document ad 
qvt qvt partners 
revised submission qvt rfp august 
omg document ad 
qvt qvt partners initial submission qvt rfp 
omg document ad 
tc laurence tony clark 
issues surrounding model consistency qvt 
technical report tr department computer science king college london december 
tra laurence 
converge programming language 
technical report tr department computer science king college london february 
larry wall tom christiansen jon orwant 
programming perl 
reilly third edition 

