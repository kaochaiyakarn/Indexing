model carrying code practical approach safe execution untrusted applications sekar basu sandeep daniel department computer science stony brook university stony brook ny 
email sekar venkat cs sunysb edu presents new approach called model carrying code mcc safe execution untrusted code 
heart mcc idea untrusted code comes equipped concise highlevel model security relevant behavior 
model helps bridge gap high level security policies low level binary code enabling analyses impractical 
instance users fully automated verification procedure determine code satisfies security policies 
alternatively automated procedure sift catalog acceptable policies identify compatible model 
suitable policy selected mcc guarantees policy violated code 
previous approaches mcc framework enables code producers consumers collaborate order achieve safety 
provides support policy selection enforcement 
mcc assumptions regarding inherent risks associated untrusted code 
simply provides tools enable consumer informed decisions risk willing tolerate benefit functionality offered untrusted application 
categories subject descriptors operating systems security protection invasive software computing management computing information systems security protection unauthorized access general terms security verification keywords mobile code security policy enforcement sand boxing security policies research supported mainly onr part nsf ccr ccr afosr 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
sosp october bolton landing new york usa 
copyright acm 

significant growth software sources fully trusted trend accelerated advent internet 
examples untrusted partially trusted software include document handlers viewers real audio games peer peer applications file sharing instant messaging freeware mobile code applets javascript activex 
contemporary operating systems provide little support coping untrusted applications 
support introduced oses technique useful verifying code originated trusted producer 
code originated untrusted unknown producer code signing provides support safe execution code 
users henceforth called code consumers faced choice losing potential benefits provided code running exposing unacceptable level risk running code privileges available code consumer 
lack os level support safe execution untrusted code motivated development number alternative approaches 
approaches divided execution monitoring static analysis :10.1.1.123.8253:10.1.1.40.2507
execution monitoring policy violations detected runtime point consumer prompted see willing additional access rights program wishes simply terminate 
case consumer asked decisions granting additional access program knowing accesses allow program execute successfully simply lead prompt access 
hand terminating program causes inconvenience user may spent significant amount time searching acquiring untrusted code providing input 
addition consumer may perform clean actions deleting temporary files created program rolling back changes important data 
static analysis techniques suffer inconvenience runtime aborts 
practical perspective static analysis techniques effective operating source code programs 
typically code consumers deal binary code difficult impossible statically verify code satisfies policy 
proof carrying code pcc principle allow verification applied binaries practical difficulties limited application primarily type memory safety properties 
vast majority code distributed binary form vast majority safety policies concern resource accesses producer model generator untrusted code model untrusted programs static analysis approaches provide practical solution safe execution 
new approach called model carrying code mcc combines convenience static analysis approaches pcc reduction elimination runtime aborts practicality execution monitoring ability enforce rich class consumer specified security policies 
inspired pcc approach shares high level idea untrusted code accompanied additional information aids verifying safety 
mcc additional information takes form model captures security relevant behavior code proof 
models enable code producers communicate security needs code consumer 
code consumers check policies model associated untrusted code determine code violate policy 
mcc models significantly simpler programs checking fully automated 
models serve important purpose decoupling concerns code producers consumers 
code producers need guess security policies different consumers need expend resources generation proofs response requests consumers 
similarly code consumers longer need tackle difficult problem correctly guessing security needs untrusted application 
need reveal security policies code producers trust 
mcc provides framework code producers consumers collaborate achieve safe execution untrusted code 
contrasts previous execution monitoring approaches place burden security entirely code consumer pcc places burden entirely code producer :10.1.1.123.8253
mcc enables code consumers try different security policies interest prior execution untrusted code select statically proved consistent model associated piece untrusted code 
contrasts purely execution monitoring approaches consumer needs deal repeated runtime aborts associated clean efforts try different policies pcc policies statically checked proofs furnished code producer 
consumer policy violated model mcc provides concise summary violations providing 
capturing policy violations shot mcc helps avoid repeated policy violation prompts associated execution monitoring approaches 
summary considerable help navigating policy space identifying refinement suitable piece code 
mcc provides support policy enforcement policy consumer verifier model enforcement producer side consumer side conflict feedback model carrying code framework policy selection enforcement policy selection problem addressed previous research area 
overview approach key idea approach see program behavioral models help bridge semantic gap low level binary code high level security policies 
models successfully capture security related properties code capture aspects code pertain functional correctness 
model stated terms security relevant operations code arguments operations sequencing relationships 
current implementation operations correspond system calls alternatives function calls possible 
models created manually doing time consuming process affect usability approach 
developed model extraction approach automatically generate required models 
model extraction takes place producer operate source code binary code 
benefit test suites developed code producer test source code 
code consumer receives model program producer 
consumer wants assured code satisfy security policy selected 
security behavior model enables decompose assurance argument parts policy satisfaction check model satisfies policy behaviors captured model subset behaviors allowed policy 
expressed symbolically denotes policy denotes model function maps policy model set behaviors satisfied policy model 
model safety check model captures safe approximation program behavior precisely behavior exhibited program captured model denotes application meaning 
imply application satisfies security policy note model safety necessary step code consumer trust model provided code producer 
particular producer may provide incorrect model due errors omissions model extractor failure account possible program behaviors 
principle policy satisfaction model safety established static analysis verification techniques 
practice resort runtime enforcement ensuring model safety due difficulties verifying properties low level binary code 
policy selection component concerned policy satisfaction enforcement component concerned model safety 
policy selection component uses automated verification model checking 
models simpler programs complete automation verification step possible 
model consistent policy verifier generates compact user friendly summary consistency violations 
consumer discard code point refine policy way permit execution code posing undue security risks 
policy selection step requires consumer knowledgeable security issues 
consumers possess level knowledge rely system administrator pre specify policy untrusted application installation time provide set choices user select prior execution code 
refined policy consistent model model code forwarded enforcement module 
current implementation enforcement system call interception 
enforcement component detects deviation model execution untrusted code terminated 
alternative model enforcement directly enforce consumer security policy discussed section 
execution monitoring drawbacks mentioned earlier mcc entail drawbacks 
note enforcement violation mcc indicates code producer intentionally supplied incorrect model model extractor faulty 
predominance benign code malicious code internet indicates code producers malicious intentionally provide incorrect models 
expect violations due model extractor errors 
vast majority cases mcc enables code consumers untrusted code safely security policy violated conveniently runtime aborts 
small minority cases runtime violation experienced safety retained convenience may lost 
focuses untrusted programs executing unix operating system techniques approach easily adapted different execution environments java microsoft common language runtime clr environment part net initiative 
step direction done preliminary defining security policies terms security relevant method calls java implementing policy enforcement bytecode rewriting 
organization description mcc approach overview mcc policy language section 
section describe approach extracting models programs 
policy selection component described section enforcement described section 
implementation components described section performance results establish practicality mcc 
concluding remarks appear section 
security policies enforcement mcc relies execution monitoring enforceable security policies interest 
policies limited safety properties 
kinds properties involving information flow covert channels enforcement impossible impractical considered 
common examples enforceable policies include access control resource usage policies 
java security model supports standard access control policies handle applications consist code multiple producers 
supports specification access control resource usage policies 
security automaton formalism support safety properties involve sequencing relationships operations 
formalism associated language poet provide ability remember argument values file descriptors subsequent comparisons arguments operations 
shown ability remember arguments enhances expressive power policy language significantly 
accordingly policy language extended finite state automata efsa extend standard fsa incorporating finite set state variables remember argument values 
instance associate write operation file name involved writing recording return value open operation file descriptor comparing argument operation 
describe policy language illustrate examples 
security policy language model behaviors terms externally observable events 
modern operating systems security related actions programs ultimately effected system calls 
reason system calls constitute event alphabet policies 
naturally possible define behaviors terms operations system calls arbitrary function calls 
higher level policies stated easily accurately terms function calls 
instance policy permits program name server queries stated program allowed function complicated precise version program allowed connect ip address xyz port downside enforcement policies require secure interception arbitrary function calls possible general binary code 
term history refer sequence events 
history includes events arguments 
trace history observed single execution program 
behavior program denoted defined set traces may produced execution policies capture properties traces 
expressed efsa 
security automata efsa express negations policies accept traces violate intended policy 
state efsa characterized control state notion state fsa plus values finite set state variables 
state variables take values possibly infinite domains integers strings 
transition efsa associated event enabling condition involving event arguments state variables set assignments state variables 
transition taken associated event occur enabling condition hold 
transition taken assignments associated transition performed 
efsa policies expressed behavior monitoring specification language bmsl 
bmsl permits efsa described defining states start final states transition rules 
list open mode mode open mode mode list add add socket pf local socket domain flags domain pf local access control policy history sensitive policy sensitive file read policy examples ree policies equivalent efsa representation bmsl permits dual representation efsa regular expressions events ree 
just efsa extend fsa state variables rees extend regular expressions state variables 
simple policies rees tend concise text friendly efsa 
practice write policies rees 
bmsl compiler translate policies efsa form verifier 
efsa form may policy enforcement done past purposes intrusion detection :10.1.1.24.5063
establishes equivalence efsa ree notations freely mixed bmsl 
capability bmsl analogous ability mix regular expressions state machine constructs lex 
details rees efsa including formal semantics matching complexity expressive power 
provide short description bmsl 
events 
events may classified follows primitive events primitive events associated system call corresponding system call invocation exit 
invocation event name system call return event exit appended name 
arguments entry event include arguments point call 
arguments exit event include arguments point return plus value return code system call 
events events denote classes primitive events may define event corresponds set events modify files 
generally events may defined notation event args pat event denotes event name pat defined 
patterns 
simplest patterns called primitive patterns form xn cond asg cond boolean valued expression event arguments xn state variables asg contains zero assignments state variables 
scope event arguments limited primitive pattern occurs 
compound patterns obtained composing primitive patterns operators similar regular expressions 
meaning compound patterns best explained definition means history satisfy pattern event occurrence xn cond satisfied event history consisting single event vn cond evaluates true variables xn replaced values vn 
alternation pat pat satisfied pat pat satisfied sequencing pat pat satisfied event history form provided satisfies pat satisfies pat 
repetition pat satisfied iff empty form satisfies pat satisfies pat 
negation pat satisfied iff pat satisfied 
negation permitted bmsl pat involves sequencing repetition 
notion satisfaction extends obvious way state variables included details 
say history matches policy pat provided prefix satisfies pat 
illustrative examples convenient group similar events event 
instance number system calls result creation modification file open creat 
defining event open mode mode creat truncate subsequently denote operations 
readability abstracted test value mode call function returns true mode corresponds opening file writing 
omitted trailing arguments creat truncate interested values 
illustrates simple policy examples ree efsa notation 
note special event stands event stands event matching rest transitions state 
history matches ree prefix satisfies ree ree patterns need transitions occur final state efsa policies 
simple access control policy prevents writes files reads files set 
note operator overloaded represent pattern alternation boolean operation 
prohibited operations performed program automaton transition start state marked symbol final state marked double circle 
operations transition marked taken efsa stays start state 
resource usage policies expressed efsa easily 
instance state variable keep track number open file descriptors deny opens files open 
dwell resource usage examples resource usage properties amenable fully automated verification 
illustrates history sensitive policy allows untrusted application remove files previously created 
policy illustrates list variable remember names files created application 
event previously defined denote successful returns system calls may create file 
file application attempts delete checked list absent policy violation flagged 
example history sensitive policy requires application close files opened executing program 
ree policy expressed open exit fd fd fd fd close fd execve note policy uses single state variable fd nondeterministic nature matching ensure policy violation reported successfully opened file remains open time system call 
shows network accesses file write operations policy 
policy prevents application sending information untrusted remote site write output file 
possible scenario policy case application needs operate confidential information 

model generation problem generating models programs studied researchers software model checking :10.1.1.29.3872
approaches fully automated furthermore generate distinct models customized property proved 
customization greatly simplifies model possible prove complex properties proved 
mcc code producer generating model unaware consumer security policies 
single model generated usable policies 
reason previous works generating program behavior models intrusion detection closely related mcc model generation software model checking approaches 
particular develops approach derive automata models program behavior source code 
approach generate fsa pda push automata models 
principal difficulty applying approach mcc inability systematically reason system call arguments 
clearly know written program need identify object modified write 
reason efsa model appropriate fsa pda model 
model generation step needs capture values system call arguments relationships arguments different system calls 
instance model associate operation file written capturing relationship file descriptor argument write return value previous open operation 
rest section describe new technique generating models context mcc 
model generation approaches mcc models intended capture program behavior defined previous section set possible sequences security relevant operations program 
order capture possible sequences operations model extraction approach preserves looping branching structure programs abstracting away details assignments internal variables 
illustrates model sample program 
note denote system calls 
example shows fsa provide convenient representation mcc models concisely preserving looping branching structures program 
example omits system call arguments sake simplicity 
argument properties incorporated model efsa fsa natural 
possible pushdown automata pda expressing models benefit capturing call return relationships accurate 
added accuracy may fully useful enforcement pda models require secure interception function calls program possible arbitrary binaries 
hand important advantage pda fsa modularity pda model procedure program depend models procedures invoked 
factor enables models different program components libraries extracted independently composed obtain model program 
accurate models synthesized code comes multiple sources common case occurring executable untrusted producer uses dynamically linked libraries resident consumer workstation libc 
approach model extraction program analysis technique described 
main benefit approach model generation process strictly avoids unsound assumptions models conservative case notation section guaranteed application model derived source code analysis 
drawback due limitations source code analysis may include execution sequences fact performed may lead spurious policy violation report verifier 
overcome spurious violation problem models may generated actual program behaviors observed different test conditions 
downside approach program behaviors observed model generation may captured model 
may lead verifier conclude program satisfies policy 
minimize possibility program behaviors possible exercised learning process 
accomplished comprehensive test suite code producer developed testing purposes 
depending comprehensiveness test suite may probability application deviates model 
cases mcc enforcement mechanism terminate program 
note case safety preserved convenience having runtime aborts lost 
fortunately happens hopefully small fraction runs deviate model 
currently pursuing extraction efsa models execution monitoring standard pda extended state variables models source code 
cases main focus research tracking data flow relationships affecting critical system call arguments resource ac 













cessed system call 
currently implementation sourcecode model extraction mature description focuses execution monitoring model extraction 
model generation execution monitoring context intrusion detection number techniques developed extracting program behavior models terms system calls 
techniques learn finite set fixed length strings system calls capable learning finite set variable length strings 
developed new approach capable representing infinite number strings unbounded length finite state automaton 
approach learning fsa developed 
builds develop approach learns pda models fsa models approach incurs significantly higher overheads 
fsa serve starting point mcc models sufficient particular mcc models need capture crucial information file names network addresses referenced security policies 
main focus mcc research model extraction develop fully automated algorithm extracting argument relationships 
contrasts human assisted approaches programmer required identify subsequences execution trace argument relationship attempted 
approach aimed learning relationships involving complex data types file names concerned integer arguments 
describe approach model extraction machine learning execution traces 
provide brief overview approach learning fsa system call sequences proceed describe extensions algorithm learning argument relationships 
overview fsa learning algorithm known learning fsa strings execution traces case computationally hard problem 
primary difficulty strings give clue state automaton 
instance see string determine string correspond state automaton different states 
key insight technique obtain information knew location system call 
call location information fsa constructed follows 
system call program location create new automaton state labeled 
addition previous system call location edge labeled sample program model created previous system call location approach illustrates model learned execution traces 
traces notation denotes system call line 
illustrative purposes line numbers place locations machine instructions example 
note automaton states labeled location system call 
simple description needs extended take account fact programs extensive libraries 
instance system calls usually wrapper functions provided libc 
case note system call exactly location libc automaton capture useful information executable making system calls 
address problem learning algorithm ignores program locations libraries location executable library calls invoked 
requires walk program stack point system call 
describe implementation stack walk linux 
implementations different os architecture typically similar 
linux ebp extended base pointer register chain activation records caller callee functions 
specifically return address current procedure location ebp base pointer caller stored location ebp 
range locations executable reading pseudo file proc pid maps pid denotes process identifier monitored process 
information stack frame traversed point system call return address executable located 
location model location system call 
learning argument values describing algorithm learning system call argument values necessary provide overview implementation architecture model extractor 
model extractor consists online offline component 
online component consists runtime environment intercept system calls logger records system calls arguments file 
logger incorporates level knowledge system call arguments return values useful model extraction preprocessing necessary arguments 
instance logger converts file directory name arguments canonical form recording 
similarly extracts ip address port information sockets records explicitly 
ignores system call arguments return values buffers returned read system call fields structure returned stat system call offline component consists parts efsa learning algorithm log file parser 
extension fsa algorithm learn system call argument values proceeds follows 
may interested absolute values arguments 
instance model capture names specific files opened application 
accomplish algorithm records system call argument values system call fsa 
multiple invocations system call edge fsa model extractor collects argument values invocations 
number values crosses threshold aggregation algorithm employed summarize values listing 
principle learning algorithm support different aggregation operations practice far need operations longest common prefix operation file names union operation sets represented bit vectors file open modes permissions 
system call argument type configuration file specifies threshold point aggregation aggregation operation type 
file name arguments threshold specified function file name prefix 
instance set threshold files form tmp threshold files form 
point basic fsa approach particular program location information crucial success approach 
information potentially forced summarize argument values system calls name 
alternatively may try partition system calls name subsets yield aggregation subset construction algorithms expensive 
algorithm needs incorporate relationships arguments single system call fact certain file name opened read mode subset construction complex 
effect program location information provides efficient effective way construct subsets 
effectiveness stems fact system calls point code program related different program locations 
learning argument relationships interesting aspect model extraction approach learning temporal relationships arguments different system calls 
observed relationships crucial tracking security related properties 
instance order relate write system call file written need associate file descriptor argument write return value system call 
similarly track remote location data read process need associate socket argument recv read return value preceding accept argument connect 
identify child process signal sent parent process needs relate return value fork return value 
main difficulties learning system call argument relationships identifying pairs system calls need considered 
naive approach considers possible pair unacceptably inefficient 
algorithm complexity quadratic size trace typically order events depending comprehensive ness test suites generating traces 
worse approach generate relationships quadratic size trace 
number relationships learned order size fsa typically range states 
overcome difficulties rely observation typically interested specific relationships arguments kind 
instance interested equality relationship file descriptor arguments inequalities relationships 
meaningless compare file descriptors process identifiers 
observation approach specify configuration file kind system call argument relationships interest involving arguments kind 
note return values treated additional arguments system call 
implementation currently support equality relationships integral string types prefix suffix relationships strings 
relationships interest specified learned follows 
distinct efsa state variable associated system call invocation location argument number triple 
note way system calls traced back locations executable multiple system calls library function invoked executable location appear transitions state corresponding 
possible multiple system calls executed location need consider system call numbers addition locations 
means distinct variables corresponding file name argument open system call different locations program 
variable candidate equality relationship stored hash table indexed value 
hash tables different kinds arguments different separate hash table maintained file descriptors process ids 
point learning associated file descriptor value fd list variables file descriptor type value fd 
system call file descriptor variable value fd learning algorithm look fd table obtain associated list variables 
time seen relationship information associated set indicates variable equal time set variables associated time encountered learning 
associate proceed 
means relationships may weaken runs strengthened 
previous value deleted hash table added hash table entry fd prefix suffix relationships trie data structure place hash table 
trie viewed tree structured finite state automaton matching strings 
particular variable encountered trace value traverse path trie matches complete match match takes state trie variables associated candidates equality variable associated descendant state candidate relationship prefix prefix similarly variable associated ancestor state candidate relationship prefix prefix string corresponding state variable associated descendant state ancestor state candidate re socket pf inet 
sd connect sd 
send sd 
open tmp logfile fd open var log httpd access log log fd recv sd 
prefix possibly empty prefix trie treatment similar descendant states mentioned 
candidates relationship current instance identified compared candidates previous occurrence trace common relationships preserved 
point note stored state sold corresponds previous value sold 
deleted sold inserted state sold deleted longer associated variables done ancestors sold 
new state created 
suffix relationships exact algorithm tries constructed reversing strings 
addition improve speed algorithm restrict lengths paths states described 
final step algorithm prune redundant relationships 
suppose program current location opens file performs read operations file different program locations xn corresponding state variables 
algorithm associate set xn xn 
obviously redundant information instance associate 
note pruning difficult perform learning phase 
premature pruning lose information 
instance occurrences may equal subsequent occurrences may equal 
relationship pruned pre possible retained 
case subsequently discovered equal relationship lost left relationships involving 
example shown illustrate model extraction 
program simplified version hypothetical freeware program analyzes web server logs unusual activity 
experience real program analyzes web logs described section 
particular log entries compared signatures known attacks 
signature set constantly updated new attacks discovered better analyzer program download signatures central server encoding analyzer program 
step execution example program connect signature server network download set sig read log fd 
close log fd model efsa close sd read log fd 
write fd 
write fd 
close fd read log fd 
natures 
opens log file matches line log file signatures 
simplify example just single pattern signature 
addition check error cases 
matches written output file 
lines code system calls program marked symbol 
shows abstracted version efsa learned algorithm example program 
abstracted details include 
learning algorithm number system calls program start correspond calls dynamic program loader lib ld linux 
addition need allocate heap storage may lead additional system calls 
details abstracted away argument relationships represented human readable form 
int main int argc char argv 
int sd rc log fd fd flag 
struct 
char sig size request 
char buf read size 
init remote server addr 
sd socket pf inet sock stream 
connect sd struct sizeof 
send sd request strlen request 
recv sd sig size 
sig size 
log fd open var log httpd access log 
fd open tmp logfile creat 
close sd 
flag 


rc read log fd buf 
rc flag 
buf flag 
buf 
strstr buf 
write fd buf buf read size 

close log fd 
close fd 
return 
freeware program web log analysis socket pf inet 
sd socket pf inet 
sd connect sd 
send sd 
open tmp logfile fd open var log httpd access log log fd recv sd 
obtain efsa learned algorithm 
state label corresponds program line 
verification verification concerned determining model satisfies security policy formally need check behaviors captured subset behaviors permitted policy introduced earlier 
noting policy automaton represents negation simply need determine 
verification approach build product automaton accept intersection behaviors accepted feasible paths product automaton lead final violating states policy violated representation violations 
common operations computing product automata checking reachability known solutions case fsa complex case efsa due presence infinite domain variables 
computing efsa product way fsa product construction 
specifically product automaton mp constructed follows state variable set mp union state variables start state mp tuple start states respectively 
similarly final state set fm fm set states denotes set final states exists transition state event condition assignment transition event condition assignment transition mp condition assignment 
transition product automaton said enabled associated condition satisfiable 
efsa defined infinite domain variables representing strings integers problem determining satisfiability arbitrary constraints appearing enabling conditions transitions un open tmp logfile fd read log fd 
product automaton close log fd close sd read log fd 
write fd 
write fd 
close fd read log fd 
decidable general 
focus tractable subset constraints infinite domain variables specifically equality disequality relationships variables 
model checker relies underlying constraint processing system decide satisfiability constraints 
constraint processing system maintains store conjunctions constraints variables 
product transition feasible corresponding enabling conditions satisfiable existing store constraint processing system 
case constraint store updated adding enabling conditions 
transition considered infeasible 
alluded efsa defined infinite domain variables 
model checker empowered constraint solver described incapable inferring satisfiability constraints cases range constraints integer variables prefix constraints strings 
situations handled conservatively follows 
arguments constraint sufficiently defined constraint processing system evaluates 
considers undecided constraints satisfiable adds existing constraint store 
strategy results incompleteness constraint model checker due generation infeasible paths product automaton 
infeasible paths general lead spurious policy violation sequences 
experienced spurious reports programs considered far 
consider example program corresponding model figures respectively 
order verify model conforms policy see socket write operations product model automaton policy automaton constructed 
violating traces obtained model transition model consisting pf inet sd transition sequence state due operation file ino mode 
conflict presentation important aspect verifier give comprehensive view violation policy occurred 
information crucial policy selection 
owing size product order size model presentation product provide clear precise view violations model 
product automaton user projecting policy automaton root cause policy violation leading final state policy automaton attributed sequences policy specified actions model 
note product contains violating paths model 
projection combine common aspects multiple violating paths 
frequently combination requires merging transitions associated different conditions event arguments 
instance open events corresponding opening different files may need combined 
approach similar model extraction algorithm doing combination number different argument values small retain set possible values 
exceeds certain threshold combined appropriate aggregation technique 
instance file names tmp tmp tmp xyz var var may combined tmp xyz var var 
approach produces summary conflicts open operation file tmp logfile write mode socket operation involving domain pf inet refinement violation relatively obvious user simply permit write access files tmp 
second violation relax policy permit network access long accesses completed reading sensitive files 
list sensitive files needs specified assume file consumer consider public classified sensitive 
particular means web log file considered sensitive 
new policy refinements shown 
ability conflict presentation technique summarize violations provides help user identifying suitable policies 
approach provide additional assistance consumer policy selection catalogs acceptable policies 
catalog verifier search catalog identify policy compatible piece code 
conflict summary provide direction search verifier consider policies catalog 

enforcement runtime monitoring consists intercepting system calls obtaining argument values system calls matching models expected behavior untrusted application 
recall enforce models policies large nondeterministic automata 
avoid having simulate nondeterminism lead high overheads simply program counter value transitions 
policy enforcement system call interception understood topic describe 
application violates behavior captured model enforcement module aborts program 
happens possibilities producer intentionally program behavior model capture possible program behaviors 
happen models constructed runtime monitoring test cases runs sufficiently comprehensive 
case termination right choice 
second case indistinguishable consumer case safe response terminate application case 
open sensitive tmp socket domain flags domain pf local refined policy runtime aborts cause inconvenience point safety violated program aborted violates security policy 
cases rare predominance benign software internet fact consumer single run uncover new behaviors code producer poor job testing code 
note mcc framework possible enforce policies models 
model efsa captures subset behaviors permitted policy efsa behaviors violate model efsa go undetected policy enforcement 
questionable consumer wants allow behaviors producer sense identified illegitimate 
instance consider untrusted application reads image files saves back preview image included file 
policy allows execution application needs write access file 
possible third party attacks program causes simply delete image file 
case previous experience applying models intrusion detection suggests attacks prevented model enforcement missed policy enforcement 
possible benefit policy enforcement may simpler model enforcement 
model efsa larger policy efsa deterministic efficiently enforced 
enforcement algorithm simple simply needs keep track encountered value state variable making state transition perform relationship checks associated transition 
policy automata smaller nondeterministic 
factor requires potentially keep unbounded number previous values encountered state variable perform checks respect value 
encountered worst case behavior previous intrusion prevention mere possibility shows policy enforcement necessarily simpler model enforcement 
possible reason favoring policy enforcement model enforcement soundness approach longer depend correctness verifier 
verifier simple believe reduction size trusted computing base achieved result choice compelling 

implementation section summarize status implementation describe results applying mcc common programs instant messengers web log analyzers docu application program model size enforcement overhead verification size kb states transitions relationships interception total time msec 
space mb analyze results generation verification enforcement models ment viewers 
programs range size lines tens thousands lines source code 
security policies 
mentioned previously security policies specified bmsl language :10.1.1.24.5063
compiler language produces efsa bmsl specifications described earlier 
shown policy examples discussed far policy automata tend small states 
model generation 
implemented model generation execution monitoring 
implementation learns system call argument values described section 
argument relationship learning implemented equality relationships arguments file descriptors prefix suffix relationships strings pathnames 
sizes models terms number states transitions relationships shown 
terms time needed learn models note model generation offline process attempted optimize 
currently logging system calls done user level system call interception built ptrace facility linux 
frequent context switches involved approach need fetch system call argument data introduces significant overheads range 
learning offline activity overhead quite acceptable 
logger system call interceptor implemented combined size kloc 
different applications tend generate different volumes system calls 
instance generate large number system calls analyze generates fewer calls run 
factors balance 
training traces range system calls programs 
current implementation model extraction optimized performance model extraction offline process 
reason model extraction relatively slow order minutes traces size order system calls machine mhz pentium iii processor running red hat linux mb memory 
size learning algorithm implementation lines 
verifier 
verifier implemented xsb prolog version prolog supports memoization query results technique called tabling 
tabling avoids redundant subcomputations previously saved results queries reused 
factor greatly simplifies implementation verification program analysis techniques involve called fixpoint computation 
analysis specified set recursive rules leaving tabling technique automatically compute fixpoint 
facility enables verifier implemented lines prolog code 
code implements automata product construction constraint handling operations described section 
constraint processing system interprets equality constraints prolog variable unification mechanism handles disequality constraints storing form list 
verified application models described policies similar ones described section 
brief description policies corresponding applications 
results verification 
pdf viewer application 
conventional sandboxing policies pdf viewer application 
policy prevents application creating new files tmp directory disallows overwriting files restricts network connections prevents executing applications 
violations reported policies 
applications document viewers appears mcc simple sandboxing approaches 
analyze application 
analyze application real application similar log analyzer example discussed earlier 
generated model program learning behavior verified refined policy shown 
recall policy disallows application writing non temporary directories performing network operations reading sensitive files 
second part policy violated model 
part policy violated application creates file html current directory subdirectories called www files subdirectories 
model extraction process summarizes information violations reported verifier attempt create directories attempt write files index html policy refined permit accesses application run successfully 
gnu instant messaging application 
model application verified file access policy disallows reading writing files commonly accessed graphical user interface applications 
policy violated model 
projecting product policy violating trace model obtained open operation performed read write mode read mode write mode files user home directory 
policy relaxed restricting file access user home directory 
refined policy violated model 
experiments conducted redhat linux running ghz xeon gb memory 
shows verification takes milliseconds low memory requirements making practical 
model enforcement 
enforcement system uses kernel module perform system call interposition 
application performs system call enforcement module corresponding transition model automaton keeping track system state 
shows runtime overheads model enforcement moderate 
overhead arises stalk walk required obtain program location system calls 
requires stack frames traversed 
current stack traversal algorithm conservative cross checks return address stack calling instruction 
systematic performance tuning attempted 
factors lead moderate overhead 
improved implementation stack walk performance tuning overheads may cut factor 
variation overheads applications results variations frequencies system calls applications 
analyze application performs system calls large number system calls 
discussion remarks implementation experience far 
usability practicality illustrated application applications amenable sandboxing types policies mcc simple execution monitoring approaches 
added expressive power mcc policies expected allow applications execute raising violations verification runtime stage 
instance consider policy permits untrusted application create new directories overwrite files directory created 
clearly policy requires state variables remember name directories created untrusted application expressed efsa policy languages previous execution monitoring approaches 
analyze example demonstrates effectiveness mcc minimizing policy violation alerts 
naive execution monitoring approach resulted close runtime prompts corresponding file created application 
intelligent system requests write access entire directories number violations say reported files directory result user alerts 
experience users give prompts discard code click mcc improves previous techniques offering guidance policy refinement room improvement 
possibility plan consider having verifier automatically search hierarchy safety policies find suitable particular application 
addition need improve understandability violations security policies involve nontrivial temporal relationships 
comments usability mcc performance results reported validate claim mcc practical 
system complexity system complexity important consideration security complexity leads errors impact security 
careful examination mcc shows realized components including policy language compiler model genera tor verifier model enforcer components relatively simple 
choice simplicity generality usually favored simplicity order able build reasonably robust system modest implementation resources 
verifier considered complex piece software simple mcc lines code written declarative language 
compiler moderate size kloc complexity arises fact bmsl designed general purpose event monitoring language capable monitoring diverse events complex data types network packet data 
separate code needed efsa policies kind described half current size 
model enforcer simple consisting lines code 
model extractor consists implementation learning algorithm logger system call interceptor lines code 
total system size order kloc 
mcc components critical security 
particular correctness model extractor impact safety mcc 
implementation components tightened eliminate features unneeded mcc size security critical components mcc brought kloc 
hand noted safety depends non mcc components including underlying os gcc compiler related tools xsb system 
components considered part trusted computing base addition bmsl compiler verifier model enforcer 
standardization order enable widespread deployment mcc similar approach significant amount standardization required addition technical solutions 
currently policy language uses events closely tied operating system 
choices regarding system call arguments important relationships involving need preserved model 
need standardized achieve interoperability compatibility different oses users 
note policies need parameterized 
instance need express fact certain application may open file consumer home directory 
developing uniform way identify parameters naming important aspect standardization 
parameters standardized simple incorporate mcc logging component model generator needs ensure system call arguments filenames expressed parameterized form 
policies need stated parameterized form 
integration existing systems objective typical users required change ways order benefit mcc 
accomplish objective integrate mcc tools process explicit installation implicit downloading execution untrusted code 
explicit installation code 
incorporated mcc approach tool called enhancement redhat package manager rpm software installation tool 
tool applies mcc approach installation phase ensured installation package files belonging packages installation scripts observe consumer specified policies 
concrete problems addressed enhancement include manually edited configuration files package upgrades execution arbitrary pre post installation scripts 
case untrusted packages scripts cause arbitrary damage 
installation untrusted application associated set allowable policies 
addition flagged indicate policies silently enforced case policy selection took place installation mcc user interface invoked policy selection run 
implicitly downloaded code 
principal mechanisms implicit code downloading email attachments web content 
integrate mcc approach environments defining new content type application mcc corresponding model carrying code 
mcc policy selection user interface invoked handling instances content ensuring smooth integration diverse email readers browsers 
execution untrusted code 
installation downloading process ensures untrusted code executed mcc control 
particular execution occurs secure enforcement environment support policy selection user interface 
untrusted code model 
facilitate adoption mcc user interface supports execution code accompanying models 
cases consumer specified policy silently enforced application 
may convenient suitable applications certainly works applications document handlers 
alternatively third parties generate models programs models downloaded policy selection 

model carrying code promising solution problem running untrusted code 
previous approaches focused mainly malicious code containment mcc assumptions inherent risks posed untrusted code 
simply provides tools consumers order informed decisions risks willing tolerate enjoy functionality provided untrusted code 
demonstrated mcc practical showing small moderate size programs successfully handled 
mcc require users switch new programming language require change ways terms download run untrusted code 
mcc incorporated transparent fashion tools serve conduits untrusted code including software email handlers browsers 
mcc achieves practical balance security related obligations producer consumer avoiding placement undue burden party 
producer generate model application supply consumers different security concerns 
similarly consumers develop enforce policies address security concerns having priori knowledge security needs diverse applications 
mcc provides scalable framework permitting networked distribution user software applications addressing security concerns 
mcc approach complementary existing approaches pcc code signing combined 
instance code producer may provide proof model safety code 
case consumer statically check correctness proof runtime enforcement models unnecessary 
similarly digital signatures may combined mcc having producers digitally sign models indicate certify safety model 
consumer trusts representation producer skip enforcement step 
model safety rely runtime enforcement cases scope expanding classes properties supported mcc include liveness information flow 
runtime aborts avoided 
acknowledgments yow jian lin discussions model extraction verification feedback earlier drafts ramakrishnan scott smolka saha discussions verification ramakrishnan discussions mcc prem discussions regarding policy language compiler wei xu discussions regarding model extraction source code 
acknowledge sun support system call interposition environment model enforcement mohan krishna murthy support policy compiler support model extraction support liang support system call interposition model extraction 
anonymous reviewers insightful comments led significant improvements content organization 

anurag acharya mandar 
parameterized behavior classes confine applications 
usenix security symposium 
ammons bodik larus 
mining specifications 
acm symposium principles programming languages popl 
thomas ball sriram rajamani 
slam toolkit 
computer aided verification cav new york berlin heidelberg july 
bowen chee segal sekar :10.1.1.24.5063
building survivable systems integrated approach intrusion detection damage containment 
darpa information survivability conference discex 
guillaume brat klaus havelund park william visser 
java pathfinder second generation java model checker 
post cav workshop advances verification 
michael ghosh 
simple state approaches program anomaly detection 
acm transactions information system security 
hao chen david wagner 
mops infrastructure examining security properties software 
acm conference computer communications security ccs 
clarke emerson sistla 
automatic verification finite state concurrent systems temporal logic specifications 
acm transactions programming languages systems toplas volume 
james corbett matthew dwyer john hatcliff corina pasareanu robby shawn laubach hongjun zheng 
bandera extracting finite state models java source code 
nd international conference software engineering icse 
daniel iyer 
wolf toolset extracting models programs 
international conference formal techniques networked distributed systems forte 
dawson engler benjamin chelf andy chou seth hallem 
checking system rules system specific programmer written compiler extensions 
usenix symposium operating systems design implementation osdi 
fred schneider 
sasi enforcement security policies retrospective 
new security paradigms workshop 
fred schneider 
irm enforcement java stack inspection 
ieee symposium security privacy 
david evans andrew 
flexible policy directed code safety 
ieee symposium security privacy 
henry feng oleg wenke lee gong 
anomaly detection call stack information 
ieee symposium security privacy 
forrest hofmeyr somayaji longstaff 
sense self unix processes 
ieee symposium security privacy 
timothy fraser lee badger mark feldman 
hardening cots software generic software wrappers 
ieee symposium security privacy 
ian goldberg david wagner randi thomas eric brewer 
secure environment untrusted helper applications confining hacker 
usenix security symposium 
gong mueller 
going sandbox overview new security architecture java development kit 
usenix symposium internet technologies systems 
thomas henzinger majumdar george necula gr weimer 
temporal safety proofs systems code 
computer aided verification cav 
holzmann margaret smith 
software model checking extracting verification models source code 
formal methods protocol engineering distributed systems kluwer academic publ 
analyze application 
available www analyze org 
butler lampson 
note confinement problem 
communications acm 
david david evans 
statically detecting buffer overflow vulnerabilities 
usenix security symposium 
wenke lee sal stolfo 
data mining approaches intrusion detection 
usenix security symposium 
david lie andy chou dawson engler david dill 
simple method extracting models protocol code 
proceedings th annual international symposium computer architecture 
christoph michael ghosh 
finite automata mine execution data intrusion detection preliminary report 
advances intrusion detection raid 
andrew myers liskov 
protecting privacy decentralized label model 
acm transactions software engineering methodology 
necula 
proof carrying code 
acm symposium principles programming languages popl 
pitt warmuth 
minimum consistency dfa problem approximated polynomial 
acm symposium theory computing stoc 
fred schneider 
enforceable security policies 
acm transactions information system security 
sekar 
fast automaton approach detecting anomalous program behaviors 
ieee symposium security privacy 
sekar prem 
synthesizing fast intrusion prevention detection systems high level specifications 
usenix security symposium 
umesh shankar talwar jeffrey foster david wagner 
detecting format string vulnerabilities type qualifiers 
usenix security symposium 
prem 
intrusion detection prevention behavior specifications 
phd dissertation department computer science stony brook university 
ram peri sekar 
empowering mobile code expressive security policies 
new security paradigms workshop 
sekar liang 
approach secure software installation 
usenix system administration conference lisa 
wagner dean 
intrusion detection static analysis 
ieee symposium security privacy 
david wagner paolo soto 
mimicry attacks host intrusion detection systems 
acm conference computer communications security ccs 
andreas wespi herv debar marc dacier mehdi 
fixed vs variable length patterns detecting suspicious process behavior 
journal computer security 
xsb 
xsb logic programming system 
available www cs sunysb edu 
steve zdancewic zheng nathaniel nystrom andrew myers 
untrusted hosts confidentiality secure program partitioning 
acm symposium operating systems principles sosp 
