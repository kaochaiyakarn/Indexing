semantic analysis templates jeremy siek walid taha jeremy siek rice edu taha rice edu rice university houston tx usa 
templates powerful poorly understood feature language 
syntax resembles parameterized classes languages java 
supports template specialization semantics quite different parameterized classes 
template specialization provides turing complete sub language executes compile time 
programmers put power uses 
example templates popular tool writing program generators 
standard defines semantics templates natural language prone misinterpretation 
meta theoretic properties templates studied semantics templates systematically checked errors 
formal account templates including complex aspects template partial specialization 
validate semantics proving type safety verify proof isabelle proof assistant 
formalization reveals interesting issues standard problem member instantiation second concerns generation unnecessary template specializations 
start review templates demonstrating basic examples 
review advanced uses templates perform compile time computations write program generators 
give overview technical contributions section 
definition example class template defines container parameterized element type length template class int class buffer data public void set int data get int return data supported nsf itr putting multi stage annotations texas atp advanced languages techniques device drivers nsf sod synthesizing device drivers 
template specialization provides alternate implementation template concrete template arguments 
example template bool bool may larger single bit 
specialization element type bool uses compressed representation dedicating single bit element 
template int class buffer bool int data bits word bits word public void set int bool complicated bit masking get int complicated bit masking definition called partial template specialization template parameter left 
refer bool specialization pattern 
example full specialization template class buffer bool public void set int bool throw range get int throw range template performs pattern matching template arguments specialization patterns determine specialization specialization needs generated class template partial specialization 
consider program defines objects 
int main buffer int buf buffer bool buf buffer bool buf type buffer int matches specializations buffer generate specialization original buffer template substituting int automatic generation called implicit instantiation 
resulting template specialization shown 
template class buffer int int data public void set int int int get int note definitions implementations members set get generated 
declarations members generated 
definition member generated call member appears program 
example code buf get causes generate member definition buffer int get 
template int buffer int get int return data example member defined separately class 
going back second line main function consider type buffer bool 
matches partial specialization buffer bool full specialization buffer bool generate specialization partial specialization buffer bool 
third line main type buffer bool type matches full specialization buffer need generate specialization 
compile time programming templates buffer bool specialization contains small compile time computation length data array int data bits word bits word ability pass values template parameters evaluate expressions compile time provides considerable computational power 
example power template computes exponent compile time 
template int int struct power static const int power template int struct power static const int int array power static keyword means member associated class object 
const keyword means member immutable 
limitations kinds expressions evaluated compile time arithmetic expressions built integer types 
similar restrictions kinds values may passed template parameters 
example list value passed template parameter 
fortunately possible encode data structures types types passed template parameters 
creates type encoding cons lists 
template class head class tail struct cons struct nil typedef cons int cons float nil list types general templates mimic algebraic datatypes sml haskell 
furthermore templates open ended mimic extensible variants objective caml 
omits value template parameters compile time expressions technically redundant encode computations values computations types 
example types encode natural numbers 
template class struct succ struct zero typedef succ zero typedef succ succ zero power template reformulated types 
definition mult left exercise reader 
template class class struct power template class class struct power succ typedef mult power template class struct power zero typedef metaprogramming templates combination templates member functions enables compile time program generation referred template metaprogramming 
member functions represent run time program fragments templates provide ability compose select fragments 
revisit power example time staged metaprogram takes compiletime parameter generates program run time parameter template class struct power template class struct power succ static int int return power template struct power zero static int int return int main int argc char argv return power atoi argv command line input expert notice missing typename keywords examples 
intentionally avoid confusing readers unfamiliar syntactic clutter 
bodies functions main contain run time code 
type expressions power power represent escapes runtime code back compile time level 
power metaprogram recursive generated program 
generated program static call tree height 
optimizing compiler simplify generated program int main int argc char argv int atoi argv return optimization required standard 
compiler performs inlining preserve call value semantics 
label function inline keyword suggestion compiler 
performance generated programs brittle non portable 
compilers rarely details inlining algorithm algorithms heuristic nature hard predict 
furthermore inlining algorithm vary dramatically compiler 
see alternative approach macros guarantees inlining 
subset study includes just features exhibit compile time run time computations needed write template metaprograms 
contributions formal account templates 
identify small subset called give semantics defining 
template lookup section 
type evaluation section 
expression evaluation typed expressions section 
template instantiation section 
includes partial specialization feature template lookup nontrivial 
maintain clear focus include features orthogonal templates statements imperative assignment object oriented features inheritance 
program valid template instantiation process terminates error 
definition unusual potentially non terminating evaluation type evaluation performed part determining program valid 
particular means determining validity undecidable 
show type safe sense template instantiation succeeds run time execution program encounter type errors theorem section 
wrote proof isar proof language mechanically verified proof isabelle proof assistant 
due space considerations isar proof refer reader accompanying technical report 
formalizing revealed issues standard 
standard rule member instantiation requires point instantiation come soon possibly definition member 
semantics delay member instantiation program corresponds current practice gnu edison design group compilers 

template instantiation process converts program expanded program template specializations 
standard requires generation template specialization member accessed 
specialization needed temporarily compiler allowed omit specialization resulting program analogously way procedure activation frames discarded function returns improving space complexity template programs 
overview formalization contains syntactic categories types expressions terms definitions 
program sequence definitions 
semantics includes compile time run time components 
main semantic definitions compile time aspects type evaluation define big step evaluation function reduces type expressions simpler type expressions 
formed types define type expression valid 
type evaluation expressions types may occur expressions define type evaluation performed expressions 
typed expressions define type checking expressions 
program instantiation instantiation process expands program generating necessary template specializations member function specializations 
program instantiation defined 
valid program program instantiation completes successfully 
run time aspect consists definition expression evaluation cover 
fig 
shows dependencies semantic definitions type evaluation formed types type evaluation expr 
typed expressions program instantiation fig 

semantic definitions dependencies 
expr 
evaluation main technical result valid programs type safe 
program successfully instantiates run time evaluation result value appropriate type provided evaluation terminates 
type safety theorem proved section 
lemmas definitions sections lead result 
types templates syntax types templates defined grammar 
syntax sake conciseness readability unfamiliar template syntax 
syntax types templates type variables tyvar template names member names type expressions int member kind fun type templates type patterns int residual types int type type variable member access template identifier function type int 
variable binders set free type variables ftv type simply type variables occurring type 
type closed contains type variables 
pick subsets type patterns residual types type patterns include member access types 
residual types restricted template identifiers functions int 
applied closed types type evaluation produces residual types 
member access refers type definition template specialization identified 
concrete syntax type member access written template identifier refers specialization template type arguments function type corresponds syntax 
syntax class templates class template specializations name template specialization pattern 
body contains declaration single member name kind type 
patterns variables declaration class template 
patterns contain type variables declaration full specialization class template ftv 
corresponds partial specializations class templates 
referring things general form term template ought say template specialization 
restrict templates contain just single member reduce clutter semantics 
expressiveness lost template multiple members expressed multiple templates 
example split template templates change template class struct typedef typedef foo template class struct typedef template class struct typedef foo type member written type equivalent syntax typedef 
member function declaration written fun equivalent syntax static 
implementation member function written separately syntax introduced section 
type substitution substitution function mapping type variables types acts identity function domain finite number elements 
renaming injective substitution codomain restricted type variables 
renaming define equivalence types injective property needed disallow mapping distinct variables variable 
extend substitution types definition 
simultaneous substitution types 
int int case definition substitution types circular definition 
function type variables building function called type expressions 
proposition 
ftv ftv ftv proof 
induction structure 
template lookup matching ordering mentioned section template lookup non trivial supports partial specialization 
template resolves specialized template matches template arguments section standard 
goal define specific matches 
template arguments matched specialization pattern candidate templates 
standard matching called template argument deduction see section standard 
defines matching 
definition 
type matches type iff exists substitution 
define specialized need define specialized relation types 
relation defined terms matching 
see sections standard 
definition 
matches write say specialized 
relation quasi order reflexive transitive 
identify type patterns renaming type variables antisymmetry relation partial order 
proposition 
exists renaming 
notation type pattern equivalence define notion duplicate template definitions 
symbol means defined 
definition 

template template duplicates 
duplicates templates duplicates 
extend relation templates follows definition 
extension partial order set template definitions valid program allow duplicate templates duplicates cause antisymmetry fail 
definition 
set template definitions ordering specific template exists greatest element written max define lookup function capture rule template resolves specific template matches template arguments 
lookup set lookup max max exists inst function maps set templates type template specialization obtained instantiating best matching template set templates 
condition fully determines action free variables free variables required subset type unique 
inst set inst lookup function maps set templates type member name type 
set inst show member lookup produces closed types 
lemma need define free type variables set template definitions 
definition 
ftv ftv ftv lemma 
member lookup produces closed types 
ftv ftv ftv proof 
straightforward proposition 
type evaluation rules type evaluation complicated need evaluate types underneath type variable binders 
example type int underneath binder evaluated float 
template class struct typedef float template class struct static int foo int return template class struct typedef float template class struct static int foo float return need evaluation variable binders driven rules determining point instantiation template 
section standard says point instantiation specialization precedes declaration contains specialization instantiation context enclosing declaration template dependent template parameters 
point instantiation immediately point instantiation enclosing template 
example type int instantiation context depend template parameter need instantiate int reduce float check type instantiated 
type evaluation judgment form set scope template definitions set scope type parameters 
type evaluation reduces type type evaluation rules include error handling cases important distinguish errors non termination type evaluation 
program invalid instantiation process terminate 
evaluation rules type expressions defined fig 

rule says type variable evaluates provided scope 
rule defines type member access function call 
evaluate 
result form free variables lookup type definition member lookup function takes care substituting type arguments template parameters 
member type evaluated result 
alternative design rules perform lookup substitution template identifier evaluated 
choose delay lookup instantiation possible moment better reflect demand nature instantiation 
rule handles case evaluates type free variables 
case result just rest rules straightforward simply evaluate nested types put type back 
type evaluation rules test type contains free variables constant time operation 
implementation type evaluation keep track types contain free variables returning boolean value addition resulting type 
names function returns set template names set templates 
names fig 

type evaluation 
tmt ftv type ftv names int int proposition 
properties type evaluation 
ftv 
worth mentioning type evaluation may diverge types impossible build derivation types derivation need infinite 
example type 
build derivation int formed types formed types types contain scope type parameters undefined template names 
definition formed types fig 

formed type judgment form wf set scope templates set scope type parameters 
case member access check member name member type require evaluate 
purpose formed type judgment ensure safety property type evaluation merely check uses undefined type variables template names 
fig 

formed types 
wf wf wf wf wf wf wf proposition 
properties formed types 
wf ftv 
wf wf 
names wf wf int wf lemma 
formed types empty type variable environment closed 
wf ftv 
proof 
induction formed type judgment 
expressions functions expressions include variables integers object creation obj static member function access function application 
syntax object creation static member access function application 
syntax expressions 
expressions obj values obj member functions errors error abort answers ans static member function definition form 
type owner function name function 
function parameter type return type 
expression body function 
member function instantiated types member function evaluated including occurring body expression 
definition 
type evaluation inside expression iff type occurring expression replaced produce expression substitution expressions expression variables defined 
variable binders inside expressions substitution straightforward 
extend type substitution expressions 
substitution expressions obj obj obj obj defines type defined type complete notions evaluation semantics 
definition 
type defined iff type complete iff defined big step semantics run time evaluation expressions judgment form ans defined fig 

set member function definitions set template definitions 
evaluation produces answer value error abort 
limit derivation depth aborting reaches 
lets distinguish erroneous programs versus nonterminating programs strengthen statement type safety ensure cases handled evaluation rules 
main computational rule app evaluates function application expression 
expression evaluates member function expression operand evaluates 
body member function argument substituted parameter body evaluated 
parameter return types required complete types pass value semantics need know layout types perform copy 
similarly obj rule type object complete know construct object 
semantics includes error propagation rules distinguish non termination errors 
rule states function application results error evaluates error 
strictly speaking force implementation interleave evaluation non termination prevent encountering error 
intended semantics precise treatment verbose 
type safety result holds sequential implementation behavior differs programs rejected type system 
fig 

run time evaluation 
ans int obj mem app error rules error complete obj obj complete error error propagation rules 
ei complete obj error abort 
complete error typed expressions defined judgment form shown fig 

judgment type check expressions body member functions templates specializations 
expression contains type type variable type expression determined typing judgment returns 
unknown 
type checking template definitions incomplete sense guarantee instantiating member function result typed body 
member function instantiated type variables replaced closed types body type checked see section 
lemma 
substitution preserves typed expressions 
proof 
induction typing judgment 
lemma 
environment weakening typed expressions 
proof 
induction typing judgment 
cases obj mem proposition 
follows give formal definition means member function expression set function definitions 
definition 
subexpression member function function defined iff defined lemma 
subset 
proof 
induction evaluation judgment 
case application relies fact functions subset functions 
definition 
typed function environment write full member specializations 
fun 

complete fig 

typed expressions 

var var int obj obj mem mem app app ftv ftv int complete obj ftv obj wf ftv fun ftv 

lemma type safety expression evaluation 
appearance ans lemma premise normally naive mistake programs terminate 
depth evaluation construct judgment regardless program non terminating 
placing ans lemma proves evaluation rules complete analogous progress lemma small step semantics 
learned technique ernst 
lemma 
type safety expression evaluation 

function defined 

duplicates ans ans abort exists ans 
proof 
strong induction followed case analysis final derivation step typing judgment cases application including cases error propagation rely assumptions function defined duplicates application cases proposition formed types empty type variable environment closed lemma substitution preserves typed expressions lemma 
cases object construction rely requirement complete type typing rule obj 
cases straightforward 
programs instantiation process program sequence template function definitions 
review templates defined section functions defined section 
syntax programs definitions programs program instantiation judgment form set templates set member function definitions program 
result instantiation updated set templates member functions program instantiation judgment performs type evaluation template instantiation type checking definition 
auxiliary definitions definition program instantiation 
definition 
write iff obj subexpression notation stands member function processing program instantiation places member function definitions processed user defined function definition encountered member function instantiated 
member function processing judgment form single rule 
rule evaluates type expressions occur member function records types need instantiated set results template lookup type placed set instantiated set listof function converts set list 
type check body function environment extended 
free type variables template pattern type checking may result 
type body identical return type 
process member function ftv ftv ftv defined inst inst listof ftv ftv program instantiation definition program instantiation judgment fig 
describes rule 
nil program instantiation finished definitions functions program 
symbol empty list 
entire program processed instantiate member functions defined 
find best matching template corresponding member function definition 
matching substitution applied type parameters body function 
process instantiated member function rule 
tm template definition check template defined evaluate template member 
insert evaluated template process rest program 
fun member function definitions check template defined member declaration function 
check definition function 
apply rule member function process rest program 
nil fig 

program instantiation 
lookup fun tm fun type safety defined ftv defined fun purposes proving type safety need show semantics program instantiation establish appropriate properties needed lemma type soundness evaluation 
lemma captures invariants maintained program instantiation achieve goal 
lemma 
instantiation produces typed program 

duplicates 
ftv 


duplicates 
ftv proof 
induction instantiation case template definitions uses proposition properties type evaluation lemma environment weakening typed expressions 
cases member function definitions member function instantiation proposition lemma 
addition lemma member lookup produces closed types 
proof type safety theorem straightforward lemma instantiation produces typed program lemma type safety expression evaluation 
theorem 
type safety 

main main int int 
main main int int main main ans ans abort exists ans int 
proof 
main main int int main main int 
lemma know functions defined duplicates free type variables main main int int know function main main defined apply lemma obtain 
discussion semantics defined instantiates fewer templates mandated standard 
particular standard says member access int causes instantiation int 
semantics member access obtain definition member generate template specialization int 
generate template specializations types appear residual program contexts require complete types object construction function parameters return types 
type safety result shows produce fewer template specializations produce ensure proper run time execution program 
benefit semantics compiler allowed space efficient 
semantics member function instantiation point controversy 
section standard says point instantiation member function immediately follows enclosing declaration triggered instantiation caveat dependent uses templates 
problem rule uses member function may legally precede definition definition needed generate instantiation 
member function come declaration member function template specialization 
general standard formulated allow compilation single pass current rules member instantiation require passes 
disconnect standard current implementations 
edison design group gnu compilers delay instantiation member functions program translation unit 
discussed issue committee opinion defect standard instantiation member functions allowed occur program 
places instantiations member functions program 
related stroustrup dos reis proposed formal account type system 
define semantics evaluation study template specialization 
focus stroustrup dos reis enable type checking template definitions separately uses 
siek describe extension improve type checking template definitions uses 
wallace studied dynamic evaluation static aspects template instantiation 
templates widely program generation 
considerable research language support program generation resulting languages metaocaml template haskell 
languages provide class support program generation including hygienic quasiquotation mechanism 
advanced type system metaocaml guarantees generated code typable 
guarantees 
formal semantics defined facilitate comparing languages metaocaml help finding ways improve 
standards committee begun investigate improved support metaprogramming 
presents formal account templates 
identify small subset named includes templates specialization member func post committee email reflector september response john 
tions 
define compile time run time semantics including type evaluation template instantiation type system 
main technical result proof type safety states program valid template instantiation succeeds run time execution program encounter type errors 
process formalizing encountered interesting issues standard instantiates member functions soon generates unnecessary template specializations 
point view language semantics program generation research interesting see involves form evaluation variable binders level types level terms 
evaluation open terms allowed 
plan investigate affects expressivity templates mechanism writing program generators 
acknowledgments anonymous reviewers careful reading 
emir ronald garcia reading drafts suggesting improvements jaakko rvi doug gregor todd veldhuizen helpful discussions 
especially john vandevoorde edison design group help interpreting standard 
bibliography haskell language libraries revised report december 
www haskell org index html 
metaocaml compiled type safe multi stage programming language 
available online www metaocaml org 
david aleksey 
template metaprogramming concepts tools techniques boost 
addison wesley longman publishing boston ma usa 
andrei 
modern design generic programming design patterns applied 
addison wesley longman publishing boston ma usa 
krzysztof czarnecki ulrich eisenecker 
generative programming methods tools applications 
acm press addison wesley publishing new york ny usa 
erik ernst klaus ostermann william cook 
virtual class calculus 
popl conference record rd acm sigplan sigact symposium principles programming languages pages new york ny usa 
acm press 
steven ganz amr sabry walid taha 
macros multi stage computations type safe generative binding macros 
icfp proceedings sixth acm sigplan international conference functional programming pages new york ny usa 
acm press 
international organization standardization 
iso iec programming languages 
geneva switzerland october 
xavier leroy 
objective caml system documentation user manual 
damien doligez jacques didier vouillon 
robin milner mads tofte robert harper 
definition standard ml 
mit press 
tobias nipkow 
structured proofs isar hol 
types proofs programs types number lncs 
tobias nipkow lawrence paulson markus wenzel 
isabelle hol proof assistant higher order logic volume lncs 
springer 
gabriel dos reis bjarne stroustrup 
formalism 
technical report iso iec jtc sc wg 
gabriel dos reis bjarne stroustrup 
specifying concepts 
popl conference record rd acm sigplan sigact symposium principles programming languages pages new york ny usa 
acm press 
tim sheard simon peyton jones 
template meta programming haskell 
haskell proceedings acm sigplan workshop haskell pages new york ny usa 
acm press 
jeremy siek douglas gregor ronald garcia jaakko rvi andrew lumsdaine 
concepts 
technical report iso iec jtc information technology subcommittee sc programming language january 
jeremy siek walid taha 
formalization isar 
technical report tr rice university houston tx december 
vandevoorde 
reflective metaprogramming 
technical report iso iec jtc information technology subcommittee sc programming language april 
todd veldhuizen 
template metaprograms 
report may 
reprinted gems ed 
stanley lippman 
charles wallace 
specification validation methods chapter semantics programming language pages 
oxford university press new york ny usa 
markus wenzel 
isabelle isar manual 
tu nchen april 
