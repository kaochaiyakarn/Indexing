finding application errors security flaws pql program query language michael martin benjamin livshits monica lam computer science department stanford university livshits lam cs stanford edu number effective error detection tools built years check program conforms certain design rules 
important class design rules deals sequences events associated set related objects 
presents language called pql program query language allows programmers express questions easily application specific context 
query looks code excerpt corresponding shortest amount code violate design rule 
details target application precise implementation abstracted away 
programmer may specify actions perform match recording relevant information correcting erroneous execution fly 
developed static dynamic techniques find solutions pql queries 
static analyzer finds potential matches conservatively context sensitive flow insensitive inclusion pointer alias analysis 
static results useful reducing number instrumentation points dynamic analysis 
dynamic analyzer instruments source program catch violations precisely program runs optionally perform user specified actions 
implemented techniques described errors large real world open source java applications containing total nearly classes 
errors important security flaws resource leaks violations consistency invariants 
combination static dynamic analysis proves effective addressing wide range debugging program comprehension queries 
dynamic analysis especially suitable preventing errors security vulnerabilities runtime 
categories subject descriptors software engineering testing debugging tracing supported part national science foundation 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
oopsla october san diego california usa 
copyright acm 
general terms languages security reliability keywords program traces pattern matching web applications sql injection resource leaks bug finding 
advanced program analysis applied fruitfully find large numbers errors software :10.1.1.14.2994:10.1.1.161.222
program checkers carefully crafted experts targeted finding patterns common application programs 
fact techniques effectively find error patterns specific individual applications 
exploit full potential approach need easy application developers create custom checkers 
presents program query language pql language allows developers express large class applicationspecific code patterns 
system automatically generates query pair complementary checkers static checker finds potential matches application dynamic checker traps matches precisely occur initiate userspecified logging recovery actions match 
developed prototype ideas java find repair numerous security resource management errors large open source applications 
simple example pql focuses important class error patterns deal sequences events associated set related objects 
example security reasons password received user written disk encryption 
patterns hard express conventional techniques program assertions 
objects interest may stored passed local variables passed parameters passed generic collections 
sequence events may scattered different methods guarded various predicates 
pql express kinds patterns simplest prototypical code exhibits sequence events interest 
pql system automatically finds matches program equivalent behavior abstracting away irrelevant control flow disregarding objects named code 
example consider sql injection vulnerabilities ranked top external threats corporate systems 
applications user controlled input strings directly database query commands susceptible sql 
consider code fragment java servlet hosting web service con execute request query code reads parameter request passes directly database backend 
supplying appropriate query malicious user gain access unauthorized data damage contents database cases execute arbitrary code server 
catch kind vulnerability applications wish ask generally exist object object type connection object code result invoking yields string string eventually parameter invocation execute replace call execute custom routine util validates query ensure matches permissible action 
query deemed invalid request 
note events application need happen consecutively string passed parameter stored heap eventually 
express query pql shown 
input tor immaterial represented don care symbol 
call additional matching required trapping final substitution 
note sql injections subtle general require sophisticated patterns 
full sql injection problem discussed section 
input pattern pql system automatically produces sound static checker finds potential matches program 
checker uses state art context sensitive inclusion points analysis 
results respect query query static checker report cases argument call execute point object returned call 
static checker ensure calls occur order 
combined intrinsic undecidability statically matching query possible runs means static results generally false positives 
note currently available static techniques static checkers sound produce false negatives possible match reported 
dynamic checkers hand find matches occur runtime precise permit online recovery actions triggered 
dynamic tool pql creates instrumented version input program reports runtime match object instances match query 
query example pql instrument code remember object instances returned check parameters supplied execute rou query uses object object connection object string matches replaces execute util simple sql injection query 

match occur intercept call execute run routine 
static results sound false negatives point static analysis decides irrelevant possibly contribute match 
dynamic matcher free ignore 
pql combines analyses results static analysis remove unnecessary instrumentation 
example calls returned potential matches static analysis need instrumented 
contributions pql permits easy specification large class patterns related sequences events objects 
developer needs mine information program run produce targeted instrumentation 
just discovered bug suspects code quickly create checker search similar problems 
pql contributes static checkers leverage powerful analyses 
important result placed sophisticated program analyses hands developers 
developers express simple queries static checkers context sensitive pointer alias analysis automatically generated 
analysis sound answer guaranteed include points may relevant query 
allows results optimize dynamic matcher 
optimized dynamic instrumentation 
pql automatically generates specialized matcher query weaves instrumentation target application perform match runtime 
matchers differ previous techniques ways 
pql transcends traditional syntax approaches matching history events witnessed object instances 
second higher level semantics pql possible static analysis reduce overhead dynamic checking 
system combines dynamic matcher sound static systems produce checkers 
dynamic error recovery 
pql queries may specify functions execute match optionally replacing event user specified function 
functionality recover error conditions defend attempts breach application security 
experimental evaluation approach 
techniques implemented prototype system works java programs 
written tens queries course developing tool part ongoing 
explicitly test ability find bugs large programs applied technique large real life applications nearly classes combined errors 
security vulnerabilities object persistence errors web applications permit database corruption denial service attacks 
resource management errors eventually lead memory exhaustion 
queries find errors derived reading descriptions error patterns apis java libraries exploring application code pql 
runtime overhead experiments ranged heavily instrumented case 
situations overhead greatest static analysis applicable removed instrumentation cut overhead 
performed tests standard benchmarks extreme nearly event significant slowdown peaks approximately times 
experimental result suggests language covers important class program error patterns 
familiar benchmarks able find errors large code base relatively little effort 
organization rest organized follows 
section gives overview pql language 
sections describe dynamic static checkers respectively 
section provides detailed experimental evaluation analysis approaches section discusses applications analyses general terms 
section describes related section concludes 

pql language overview focus pql track method invocations accesses fields array elements related objects 
keep language simple pql currently allow variables primitive data types integers floats characters primitive operations additions multiplications 
acceptable object oriented languages java small methods encapsulate meaningful groups primitive operations 
ability match primitive objects may added pql extension 
conceptually model dynamic program execution sequence primitive events checkers find subsequences match specified pattern 
describe execution trace define patterns describing subsequences trace 
execution traces program execution trace primitive events contains unique event id event type list attributes 
objects named unique identifiers 
pql focuses objects matches instructions directly dereference objects 
need able detect program order match queries demand event occur 
result event types abstracted away field loads stores 
attributes event types source object target object field name 
array loads stores 
attributes event types source target objects 
array index ignored 
method calls returns 
attributes event types method invoked formal objects passed arguments returned object 
return event parameter includes id corresponding call event 
object creations 
attributes event type newly returned object class 
program 
event type attributes occurs just java virtual machine terminates 
example 
execution trace 
illustrate concept execution trace code int len names length int len string request names con execute code runs array names element reads parameter request executes 
shows execution trace code case names array elements 
event trace listed id id caller case return event caller call event id id return call return call execute return execute call return call execute return execute call execute return execute execution trace example 
information event type attributes 
execution names bound object elements array precise index abstracted away request bound object bound object second iteration respectively 
execution yields matches query 
match satisfied second satisfied matched values pql queries pql query pattern matched execution trace actions performed match 
match query set objects subsequence trace satisfy pattern 
grammar pql query shown 
query execution pattern specified set primitive events connected number constructs including sequencing partial sequencing alternation 
named subqueries define recursive patterns 
primitive events described java syntax readability 
query may declare typed variables matched values type subtypes 
query variable multiple events indicates object events 
section discusses variables context query section outlines statements defined combined section describes pql subquery mechanism section discusses options pql provides reacting match 
query variables query variables correspond objects program relevant match 
declared inside subqueries local query declared 
common variables represent objects represent individual objects heap object variables class name restricts kind object instances match 
name prefixed object type 
object variable appears multiple times query matched object instance 
contents object need multiple matches 
queries query query query qid decl decl returns uses matches replaces executes methodname idlist decl object 
typename id member id object 
typename id id member id id stmt id id id id id id id methodname idlist id new typename idlist stmt stmt id id idlist qid idlist typename id id idlist id id id id methodname typename id id qid za za za za bnf grammar specification pql 
member variables represent name field method 
member variables declared textual pattern member name match 
pattern match method name 
member variable occurs multiple times pattern represent field method name event 
convenience introduce wildcard symbol different occurrences matched different member names objects 
values matched wildcard symbols examined returned 
query variables arguments passed query invoked return values acted query action returned invoking query internal variables inside query find match isolated rest system 
statements primitive statements query language correspond directly event types execution trace 
method invocations exception match events call method matching return event 
objects primitive statement declared object query variables special variable wildcard placeholder object relevant query 
members may literals declared member query variables 
field method event need declared type associated base variable cases match occur subclass defines 
primitive statements may combined compound statements shown grammar 
sequence specifies followed ordinarily means events may occur primary focus individual objects sequences default contiguous 
event may forbidden occurring point match prefixing exclusion operator 
sequence matches followed occur 
wildcards permissible excluding possible events force sequence contiguous trace desired 
alternation operator wish match events compound statements statements statement matching match multiple statements independently partial order statements separate statements matched commas 
statement match statements order 
clause statement sequence sequencing clause enforced normal 
combination operators alternation highest precedence partial order lastly sequencing 
braces may enforce desired precedence 
construct introduced allow specification pattern fully match dynamic invocation method 
translates matching method call event matching pattern insisting return method occur point call full match pattern 
queries excluded events represent liveness properties 
query embedded clause return match invocation method reached excluded event occurring 
main query ends excluded events match confirmed program exits 
example 
forcing closing stream resources 
java automatic resource management features system wide resources file handles manually released system risks resource exhaustion 
methodologies demand resources allocated method deallocated method ends 
query uses object inputstream matches new inputstream close executes close checking potential leaks file handles 
shown query finds methods resources methodology 
match invocation method creates inputstream closed method ends 
escape allocating method call close inserted 
note close need invoked directly invoked method called ordinarily clause specifies particular method interest problem pattern applies methods base object method name wildcards 
subqueries subqueries allow users specify recursive event sequences recursive object relations 
subqueries defined manner analogous functions programming language 
return multiple values bound variables calling query 
recursively invoking subqueries set variables queries match unbounded number objects 
values input return query variables transferred subqueries unifying formals actuals return values caller variables 
unification context pql match involves ensuring unified variables bound value match 
variable bound previous event undefined variable bound value 
bound different variables match possible 
writing recursive subqueries necessary base case force return value equal arguments 
pql provides unification statement express statement correspond program event unifies example 
recursive subqueries 
recursion useful matching common idiom wrappers java 
java exposes higher level functions providing wrappers base input streams 
wrappers subclasses top level interfaces reader character streams inputstream byte streams 
example read java objects socket wrap stream cache incoming data parse objects stream new new obj general arbitrary levels wrapping 
capture need recursive pattern shown 
base case subquery declares stream considered derived captures single wrapper re invokes recursively 
query object inputstream returns object inputstream uses object inputstream matches new inputstream tmp query main returns method uses object socket object inputstream object object matches executes util recursive query tracking data sockets 
natural ask developer go writing pql query 
cases sql injections studying api relevant methods sufficient 
useful locate objects interest see objects program 
pql explorations easy 
example query shown finds methods invoked objects read network socket 
query finds streams derived input stream socket objects read derived streams 
matches method represented method parameter invoked objects read 
reacting match matches pql correspond notable undesirable program behavior 
pql provides facilities log information matches perform recovery actions 
simplest version executes clause names method run query matches 
pql subqueries may clauses 
name statement watch method representing action executed place 
method may take query variables arguments 
passing special symbol argument package variable binding match collection handled generically 
basic actions defined methods class util part base system frequently util takes argument dumps information variable values stack trace final event occurred util abort takes arguments terminates program immediately 
intended clause 
implementing actions method return void executes clauses value type replaced event replaces 
argument action represented array objects 
arrays necessary multiple matches may complete single event 
index argument array corresponds single match completed 
expressiveness pql pql pattern language fundamentally concerned objects 
seeks find set heap objects disregarding named syntactically code parameterize contextsensitive pattern events execution trace 
events patterns refer primitive values integers individual characters pql capable tracking 
subquery mechanism introduces call chain permits matcher match context free grammars 
production grammar considered independently existentially quantified respect objects heap 
means despite fact query refer finite number variables number objects may involved match recursive query 
pql directly provide kleene star operator 
facility may simulated tail recursive queries 
practice useful queries loops need refer different objects chains objects cases simple kleene star insufficient capture precise semantics 
partial order operator specifies execution stream able match clauses equivalent specifying intersection languages specified clause 
pql class languages closure context free languages combined intersection class superset context free languages 
default semantics sequencing operator pql require patterns unduly permissive permit arbitrary blocks statements occur events interest 
due object centric focus language usually precisely behavior desired 
occasions desired exclusion events forbid intervening events 
permits language express arbitrary patterns execution trace keeping generally useful patterns simplest express 

dynamic matcher direct na approach finding matches pql queries dynamically consists steps 
translate subquery non deterministic state machine takes input event sequence finds subsequences match query reports values bound returned query variables match 
main query simple finite state machine 
complicated queries require additional machinery described section 
instrument target application produce full execution trace 

query recognizer interpret state machines execution trace find matches 
procedure described quite inefficient 
reduce instrumentation overhead perform optimizations 
instrumentation code inserted program points generate event interest specific query 
simple type analysis excludes operations types related objects query 
results static analysis described section reduce instrumentation excluding statements refer objects involved match query 
collecting full traces system tracks partial matches program executes takes action immediately recognizing match 
translation queries state machines state machine representing query composed set states includes start state fail state accept state set state transitions set variable parameters 
partial match current state set bindings mapping variables pql query objects heap run time 
state transition specifies event current state current bindings transition state new set bindings 
event may interpreted different ways different transitions state machine may nondeterministically transition different states input 
represent partial order statements states join points cases state machine determine incoming transition compatible partial match 
outgoing match state combination incoming match transition possible consistent combination formed 
combination consistent matches define variable different values 
extreme case incoming transition binds variable bound transition outgoing matches cartesian product incoming matches 
state transitions generally represent single primitive statement corresponding single event execution trace 
special kinds transitions skip transitions 
query specifies subsequence events match 
noted exclusion statement arbitrary number events kind allowed con start call inputstream init return inputstream init return inputstream init subquery derived state machine query 
matched statements 
represent notion skip transition connects state back event doesn match set excluded events 
note accept state skip transition matches reported 
label skip transitions indicate may match event event indicate transition match event listed 
null transitions 
null transition correspond event taken immediately encountered 
state outgoing transitions outgoing transitions 
may optionally carry predicate transition may taken predicate true 
matcher transitions directly fail state 
subquery invocation transitions 
behave ordinary transitions correspond matches entire possibly recursive queries 
preprocess queries ease translation 
subquery may directly indirectly invoke intervening events 
eliminate situations process analogous elimination left recursion context free grammar 
second excluded events propagated forward subquery calls returns set excluded events immediately primitive statement 
syntax directed approach constructing state machine query 
associated statement query states denoted bef aft refer states just matched 
query statement start accept states query states bef aft respectively 
example query translated state machine shown 
array field operations 
primitive statements correspond single events trace 
primitive statement type transition bef aft predicated getting input event type attributes unifiable statement current bindings 
attribute value unifiable current bindings 
corresponding attribute literal value 
refers parameter variable unbound bound value attribute refers unbound variable pair added set known bindings 
exclusion 
excluded primitive statement form bef aft 
default skip transition modified predicated matching sequencing 
bef bef aft aft aft bef 
alternation 
bef provides transitions bef bef similarly aft aft transition aft 
partial order 
partial orders resemble alternation statements bef provides transitions bef finish bef similarly aft aft transition aft 
primary difference aft state join point 
method invocation 
method invocation statement match call return events method events 
create fresh state new event variable create transition bef matches event bind id event 
create transition aft matches areturn event id skip transition back modified exclude match return event 
call return events unified manner analogous array field operations 
creation points 
object creation handled java invoking method init translated method invocation 
context 
clause represented nesting automaton representing body pair matching call return event pairs 
skip transitions modified match return forcing failure match complete call 
unification statements 
unification statement represented predicated transition requires variables left right value 
unbound acquire value 
subquery invocation 
subquery invocations treated subquery match primitive event right 
recognizer handles subquery calls returns 
details discussed section 
instrumenting application system instruments instructions target application match primitive event exclusion event query 
instrumentation point pending event relevant objects sent query recognizer 
recognizer update state pending matches return control application 
recognizer interfere behavior application completed matches instrumentation point statically proven contribute match need instrumented 
particular optimize away instrumentation referenced objects statically declared types conflict query 
sophisticated optimization techniques discussed section 
query recognizer recognizer begins single partial match main query values variables 
receives events instrumented application updates currently active partial matches 
partial match transition current state unify event produces new possible partial match transition taken 
single event may unifiable multiple transitions state multiple new partial matches possible 
skip transition predicates pass match persist unchanged 
skip transition predicate fails match transitions fail state 
skip transition predicate value unknown variables refers unbound variable bound value representing object violate predicate predicates accumulate objects unified unification object satisfies predicates replaces predicates object 
new state transitions processed immediately 
transition representing subquery call available new state new partial match subquery state machine generated 
partial match begins subquery start state initial bindings corresponding arguments subquery invoked 
unique subquery id generated subquery call associated subquery caller partial match subquery callee partial match partial match results transitions subquery callee 
join points handled finding latest state dominates join point treating split point 
incoming transition join point representing paths split point transition 
split point reached matched independently manner similar subqueries 
join point collects combines matches complete propagates combined matches completed 
partial match transitions accept state begins wait events named replaces clauses 
targeted event encountered instruction skipped substituted method run 
clause runs immediately accept state reached 
subquery invocation completes subquery id locate transition triggered subquery invocation 
variables assigned query invocation unified return values subquery invocation transition completed 
original calling partial match remains active accept additional subquery matches may occur 
order matcher scale long input traces critical able quickly acquire relevant partial matches event 
hash map quickly access partial matches affected kind event 
map keyed specific transition variables known values point query 
queries partial matches consist variable value pair binding implementation efficient needs perform single hash lookup 

static checker optimizer pql easy developers take advantage contextsensitive points analysis results 
developed algorithm automatically translate pql queries queries pointer analysis result shielding user need directly operate program representation context sensitive results 
translation approach flexible checkers currently flow insensitive flow sensitivity added improve precision needing modify queries 
accurate interprocedural pointer alias analysis critical precision pql static checkers events relevant particular query may widely separated program 
analysis pql sound false negatives mean results unusable optimization 
contrast developed practical static checkers unsound analyses produce false negative warnings 
checkers pointer information sound context sensitive inclusion pointer alias analysis due whaley lam 
analysis computes points relations distinct call path programs recursion 
call paths recursive programs reduced treating strongly connected component single node 
pointsto information stored deductive database called bddbddb 
data compactly represented binary decision diagrams bdds accessed efficiently queries written logic programming language datalog 
bddbddb program database inputs results static analyzer stored relations bddbddb database 
domains database include bytecodes variables methods contexts heap objects named allocation site integers context domain represents various call chains occur program qualify pointer information 
pointer relations true calling context associated value treatment see 
source program represented number input relations actual ret represent parameter passing method returns field loads field stores array loads array stores respectively 
correspondence attributes primitive statements query language relations 
say predicate 
xn true tuple 
xn relation show definitions relations remaining ones defined similarly 
means bytecode executes 
actual actual means variable zth argument method call bytecode ret ret means variable return result method call bytecode context sensitive points analysis produces numbering calling contexts invocation graph context sensitive call graph points results context sensitive invocation relation 
means invocation site context may invoke method context 
vp variable points relation 
vp means variable context may point heap object datalog query consists set rules written notation predicate defined conjunction predicates 
example datalog rule 
says true true example 
statically detecting basic sql injections 
express flow insensitive approximation basic sql injection query follows ret vp execute actual vp 
datalog rule says object cause injection call call execute return result context points heap object parameter call context 
translation pql datalog perform static analysis translating pql queries datalog bddbddb resolve queries 
datalog highly expressive language including ability recursively specify properties meaning pql queries may translated datalog approximation simple syntax directed approach 
translation process normalize input pql queries part query alternation sequence statements words top level statement clause clauses mentioned top level 
event affected replaces clause treated process possible final event query 
equivalent appending alternation statements clause normalization 
pql query datalog relation defined bytecodes field method names heap variables bytecode program point longest possible sequence events query field method name member variable pql query heap variable object variable pql query 
literals wildcards translated pql datalog change 
summarize handling individual pql constructs primitive statements 
primitive statement query translated datalog predicates 
syntax directed translation pql queries datalog shown 
left side table lists pql primitive statement right hand side shows datalog translation 
translations basic form 
pql statement refers heap object hi 
bddbddb system represents instructions terms actual program variables 
extract program variables fresh datalog variable query vp relation determine possible values hi 
field method name refers pql member variable may referenced directly statement 
alternation 
input queries normalized alternation statements top level clause alternative represented separate datalog rule head goal 
sequencing 
static analysis flow insensitive track sequencing directly merely demand events sequence occur point 
done simply replacing sequence operator datalog conjunction operator 
guarantee program variables event sequence vx datalog variables fresh event 
hx variables correspond pql constructs keep name 
event includes bytecode event occurs bytecode bound bytecode attributes subquery relation 
bytecode parameters left unbound example base case query unused bytecode parameters set null representing program location 
partial order 
similarly static analysis translation partial order statement simply treat clauses part sequence 
exclusion 
flow insensitivity guarantees ordering 
means deduce excluded event denoted occurs points sequence result excluded events ignored 
source imprecision current analysis conservative approximation maintains soundness 
primitive statement datalog translation vp vp vp vp vp vp vp vp hn ret actual vp actual vn vp vn hn new typename hn ret typename init actual vp actual vn vp vn hn translation primitive statements pql left datalog right static analysis optimization 

construct handled requiring matching bytecodes methods transitively called involves querying call graph call graph available part pointer analysis 
unification 
unification objects translated equality heap allocation sites 
subqueries 
invocations pql subqueries represented referring equivalent datalog relation 
program points variables parameters pql subquery matched wildcards projected away 
shows full translation query datalog 
rule translation query path 
involves events member variable object variables 
pql statements translated turn combined form core main query 
query somewhat interesting possible sequences different length 
base case simply asserts equality arguments unification statement returns immediately 
event path bytecode argument set null 
second rule handles recursive case similar translation 
relations express bytecodes part final solution explained detail section 
extracting relevant bytecodes bddbddb system resolves query independently result subquery finds program points heap variables set arguments regardless subquery invoked arguments 
necessary extracting list relevant bytecodes extract bytecodes participate match full query 
step process 
step determine subquery invocations contribute final result second project relevant subqueries bytecode domain 
finding relevant subquery matches 
relevant subqueries determined inductively members relation relevant member query relation appears clause relevant relation result translating subquery invocation relevant 
translates rule invocation statement additional rule express results main relevant 
single rule declares solution main relevant 
invocations subquery gets rule 
handles recursive subquery inside second deals call main 
extracting relevant program locations 
gathering relevant program locations straightforward previous step performed program location occurs relevant solution query relevant 
special case main query need check relevance solutions main query relevant 
uses relevant relation express rule says bytecode relevant part relation proven relevant final project bytecode involved main set relevant bytecodes 

experiences pql error patterns literature expressed easily pql 
selected important representative error patterns illustrate pql 

serialization errors data corruption bug web servers exploited mount denial service attacks 
main mm hs hv hx hy actual vs ret vx vp vx hx vp vs hs hx hy actual vy ret vv vp vv hv vp vy hy mm actual vv vp vv hv 
hx hd hx hd null 
hx hd ht inputstream 
init actual vx ret vt vp vx hx vp vt ht ht hd 
mm hs hv hx hy main mm hs hv hx hy 
ht hd hd ht ht hd 
hx hy hx hy hx hy 
relevant hx hd ht hx hd ht 
relevant main 
relevant main 
relevant main 
datalog translation 
errors instances simple pattern store object type 

sql injections major threat security database servers discussed section 
instance taint analysis data obtained manner restricted 

mismatched method pairs apis require methods invoked certain order 
matching pairs methods follow pattern call method followed call method install followed common large systems 
failing properly match method calls leads resource leaks data structure inconsistencies 
patterns kind simple specify difficult check statically large applications 

listeners common memory leakage pattern java may lead resource exhaustion crashes long running applications 
listeners follow complex pattern event invoked object required followed event invoked related different object 
examples considered show complementary nature static dynamic analysis 
static analysis solve simple problems serialization error query precisely dynamic analysis useful complex queries matched method pairs listeners 
experimental setup experiments large open source java applications characteristics summarized 
test application designed demonstrate potential security flaws java 
road test program exercises large object persistence library major component jboss suite 
roller widely deployed weblog wiki applications 
eclipse current premier open source java ide eclipse experiments run version 
static analyses done amd opteron machine gb memory running linux 
dynamic tests performed ghz amd athlon xp mb memory running linux 
apply context sensitive pointer analysis benchmarks 
shown takes minutes represent program bdd relations compute points results 
fortunately preprocessing step needs performed queries 
note road consists lines code preprocessing time dominated analysis large libraries uses 
show characteristics checkers queries experiment 
static analysis show time taken just resolve datalog query total time taken considerably higher includes loading saving large relations 
dynamic analysis run warnings static analysis immediately obvious errors 
times web applications reflect average amount time required serve single page measured standard profiling tool 
road command line program time simple start finish timing 
performance numbers indicate approach real applications quite efficient 
unoptimized dynamic overhead generally noticeable optimization longer measurable may high heavily instrumented code 
likewise static analysis times line expectations context sensitive pointer analysis run tens thousands classes 
serialization errors year study production software reimer large class high impact coding errors violate design rules form store objects type objects type 
rules easily expressed pql 
serialization error study instance pattern 
specifically runtime representation web session supposed persistent object allow web server save restore sessions load high 
consequence objects implementing interface serializable stored method 
pql query corresponding design rule shown 
violations rule cause persistence operation fail exceptions data corruption 
may exploited malicious user mount denial service attack may cause intermittent problems hard test session objects written high load 
problem enterprise java code reportedly took team engineers close weeks detect 
source source library total benchmark description loc classes classes classes sample web application known security flaws blogging application ee road test application object persistence library blogging application ee roller blogging application ee eclipse open source java ide gui application program relation pointer total benchmark generation analysis time road roller static preprocessing time seconds 
shown total calls method benchmarks 
optimizer run remain potential matches query 
shows pointer analysis useful suppressing false warnings static checker able deduce concrete types instances stored implement serializable cases declared type 
remaining calls obvious errors immediately seen correct run 
dynamic checker applied contains unconfirmed warnings runtime match suspicious sites confirming error 
finding security flaws shown realistic example sql injection vulnerability mentioned section 
having control username pwd variables user cause arbitrary sql code run bypass access restrictions 
sql injection instance taint analysis requires tracking flow data set sources set sinks 
applications written ee framework examined ee apis identify sources sinks case sql injections 
sources listed query include return results methods 
sinks enumerated replaces clause include arguments method java sql statement execute string sql java sql connection string sql forth 
user controlled string may incorporated strings main query asks user controlled string subquery query main returns object java io serializable obj object servlet session matches session obj query finding serialization errors 
summary information benchmark java programs 
total static stat 
dynam 
benchmark calls warnings confirmed confirmed errors errors roller total results serialization error query 
calls refer invocations 
indicates dynamic checking unnecessary 
propagated times subquery create string sql query actions clauses main query 
unsafe database accesses replaced routines quote instance user string sql command transforming possible attacks legitimate commands 
note string propagation query specific sql injection variety taint queries involve propagation strings 
invokes query handles ways string derived 
pql developed runtime security protection system web applications called system address problem sql injection vulnerabilities cross site scripting path traversal attacks described 
performed detailed experimental study runtime overhead sql injections 
commonly dynamic techniques application firewalls rely pattern matching monitor traffic flowing application poor solution sql injection 
contrast detect attacks observes data flows application 
secu gracefully recover vulnerabilities harm tainted input necessary 
inherent advantages dynamic approach static 
integrated server new web application added instrumented automatically 
removes related deploying unfamiliar potentially insecure web applications 
obviates issue static tools code changed tool rerun 
particularly important analyzing web applications statically prove difficult issues handling reflection 
name comes idea providing security fly static analysis time instrumentation points runtime overhead query total opti opti benchmark resolution time mized mized mented mized mized mized mized bad stores roller sql injections road roller summary static analysis times runtimes dynamic overhead number instrumentation points optimizations 
indicate dynamic run necessary static solution sufficient 
times seconds 
require changes original program need access final bytecode 
especially advantageous dealing applications rely libraries source unavailable 
dynamic checker sql injection query match user controlled string flows way suspected sink regardless user input harmful particular execution 
react replace potentially dangerous string safe 
errors located tool involved applications building sql strings data sent command line generated parameters request 
exploited program executed malicious user 
vulnerable common crafted request attacks 
importance static optimization static optimization program locations need instrumented 
routines cause string derived common 
heavily processed user inputs reach database carefully tracked runtime introducing significant overhead analysis 
fortunately static optimizer effectively removes instrumentation calls string processing routines path user input database access 
exploiting pointer information dramatically reduces number instrumentation points overhead system shown 
reduction number instrumentation points due static optimization high roller 
shown reduction number instrumentation points results smaller overhead 
instance overhead cut half optimized version 
public void authenticate request string username request user java sql statement stmt con string query select users username username password pwd stmt execute query 
process result select classic example sql injection 
note query direct checking value provided user harmless data passed feasible injection vector trigger match query 
result drastic responses aborting application suitable outside debugging context 
applying input sanitization seen operation tainted data receives replaces clauses query main 
possibly relevant sink reached matches completed consistent instruction gathered matches replacing method executed 
methods find substrings sink variable match possible values source 
produce new sql query string identical old quotes sql 
forces treated literal characters instance string terminator 
new safe query passed respectively 
technique able defend sql injections derived effective attacks road 
matching method pairs eclipse apis methods invoked pairs order remain internally consistent prevent resource leaks 
implies set rules take form call followed call developers required ensure calls followed calls execution paths highly error prone task especially presence exceptions 
problem complicated calls occur different classes subclass overrides method calls calls result process error prone difficult debug traditional techniques 
eclipse large open source java ide uses windowing toolkit called swt examples method pairs 
programming guides bug reports directed examples paired initialize methods violated 
example calls followed call object 
instrumented eclipse search instances corresponding call second 
done query body form liveness queries rely critically excluding second event static analysis flow insensitive query main returns object object source sink uses object java sql connection con object java sql statement stmt matches source sink source replaces con sink sql con source sink replaces stmt sink sql stmt source sink query object object returns object object matches append new string new stringbuffer tostring query object object returns object object uses object object temp matches temp temp query returns object object tainted uses object req matches tainted req tainted req 
full sql injection query 
optimize dynamic matcher 
optimization relatively instrumentation points interesting events confined creation destruction gui elements 
approach powerful line query pick handful points nearly mb classfiles need instrumented query directly 
results running instrumented ide method pair summarized number instrumentation points dynamic violations patterns 
number dynamically discovered errors reported table number concrete types object violated pattern 
total types eclipse pattern violations due missing calls 
extended runs bugs lead resource leaks 
memory leaks listeners paired method queries useful require pql features perform 
demonstrate ability pql correlate objects widely spaced events formed query discover memory leaks eclipse 
despite garbage collected java programs memory leaks 
java program maintain link object causing garbage collector reclaim object 
finding kinds memory leaks difficult important find gradually cause resource exhaustion long running applications web servers leading instability crashes 
event listeners java gui programs common source memory leaks 
event listeners common way specify actions occur user interface event mouse click occurs gui component 
achieved registering listener gui component component destroyed listener unregistered 
listener unregistered preserve link gui component 
swing swt listener reachable global listener table making gui component reachable considered live garbage collector 
referred literature listener problem 
listeners eclipse eclipse gui library vulnerable listener problem 
listener errors featured eclipse bug tracking system 
usual technique finding errors spend lot time inspecting code heap debuggers 
api eclipse works follows 
components created destroyed dispose methods 
listeners registered unregistered dispose 
query 
actual query possibilities registration listeners simplicity example uses representative method 
paired methods query relies heavily excluded events static analysis currently ignores 
result static analysis simply report presence calls register listeners disposed useful 
apply unoptimized dynamic analysis eclipse 
overhead perceptible runs instrumented application 
results shown line 
matches collected type 
performing java resource cvs perspectives component listener type triples disposed model 
experiment demonstrated pql queries effectively extremely large programs find properties resist forms analysis 
summary section described applications representing spectrum far amenable static dynamic analysis 
serialization errors addressed statically high degree precision high quality pointer information 
sql injection static analysis reduce amount instrumentation generally fully precisely addressed static technique match dynamic monitoring optimized help static results 
liveness properties paired methods listener problems eclipse lend naturally dynamic analysis 
furthermore instrumented executables produced pql provide protection query violations run time 
discovered total serialization errors sql injections nearly errors eclipse previously unknown 
query creation object vp returns object object obj object object listener vp matches obj listener query instrumentation dynamically method method points discovered errors register install start startup shutdown total query destroy object vp object object obj object object listener vp dispose matches obj listener query main returns object vp object object obj object object listener matches obj listener creation vp obj listener destroy vp obj listener result summary running matching pair queries eclipse 
listener query 

applications pql topics covered section focused narrowly specific types errors 
section move higher vantage point discuss general uses pql 
debugging testing primarily envision pql development debugging conditions 
developer finds bug code suspect similar bugs code base 
time collection rules encodes developers knowledge system specific rules grows 
essence bug patterns simple mistakes manifest single lines serialization errors section ensuring private data members modified escape ordering constraints life entire program demonstrated sections directly expressible simple pql query 
large projects multiple authors finding similar instances error trivial task system help considerably 
instrumentation points dynamically discovered errors result summary listeners eclipse 
general automatically discovering system specific rules challenging problem represented literature 
outline queries gleaned literature programming experience 
taint queries sql injection problem discussed section instance general class tainted data problems data originates source propagated various techniques sink 
practical security problems fall class 
web application domain cross site scripting splitting attacks techniques data order mount attack 
discuss applications taint queries security 
unsafe manipulation password strings 
uncommon methods java apis take char arrays representing passwords parameter 
functions publicly available apis listed table 
character arrays recommended way reduce window vulnerability character arrays zeroed function returns 
way duration time password memory minimized reducing window opportunity hacker combing memory looking clear text passwords 
practice developers apis unaware security hazard construct password strings calling string 
character array representing internals string remains memory return result zeroed defeating point passing char place 
security issue instance tainted data problem set sources taint problem return results string sample set sinks password parameters functions table 
leaking sensitive data 
data user login password financial information credit card numbers need protected unauthorized access 
data saved cookies application logs properly encrypted eavesdroppers may able gain access potentially sensitive data 
output sanitization removes sensitive data required saving 
common error pattern involves reporting sensitive data back user showing extra information exception trace 
crucial find data obtained databases propagates output functions pertaining file socket output streams api specific functions ee routines manipulating cookie data 
example expressed taint problem similar queries section 
crypto spec char password gnu crypto authenticate char password edu util char password com security pkcs char password 
fault injection far event replacement situations discussed involve replacing unsafe arguments safe ones ensure security 
deliberately attempt insert unsafe values test robustness system 
fault injection testing technique injects unexpected data application order cause logical security errors crashes 
pql event replacement functionality allows user easily describe fault injection rules create fully functional testing frameworks 
example java applications may compromised passing potentially unexpected parameters native java calls 
hundreds native calls public java apis take object array parameters 
methods typically implemented platform apis ported creating potential buffer overrun attacks native code 
past fault injection attacks pass large arrays objects native methods successfully compromise jdk implementations multiple vendors 
attacks result java virtual machine crashing result obtaining root privileges hacker manages craft appropriate array parameter 
program exploration developers large existing project usually daunting task ahead 
determining pieces large system fit code inspection difficult time consuming 
pql extract information objects program runs 
approach developing testing pql determine perceived program invariants held reliably 
finding application entry points modern middleware systems designed support multiple user provided components include plugins eclipse servlets ee modules apache 
cases underlying structure complex unclear way user provided code gets called system 
analyzing modules statically generally requires information application entry points prime analysis 
strategies follow find information dynamically pql 
instrument framework look calls pointer type defined target module log information 
trap calls application examine stack trace control transfers framework application 
discovering data validation strategies web applications sort validation scheme prevent user provided data program unsafe ways described section 
typically data checked regular expressions encoded url encoding similar schemes 
furthermore data stored passed encrypted format 
pql help discover perturbations occur data entered application 
preliminary experiments reveal cases url encoding regular expression pattern matching applied user provided data means cleansing 
public api functions password parameters 
finding instantiated types java libraries frequently export types application layer varying library implementations may connected class 
design unclear precisely classes application 
complicates interprocedural static analyses readily find useful call graph 
problem particularly presence reflection call graph information contained configuration files code 
convenient extract runs program precisely classes loaded construct analysis call graph 
java method class forname string classname get object type class represents type named classname newinstance method constructs object 
result typically cast class interface application uses 
wishes focus instances specific supertype query may focused easily 
example process exploring sql injection issue section necessary find subclasses java sql statement instantiated program 

related model extraction done automatically inferring state models components software systems 
strauss system uses machine learning techniques infer state machine representing proper sequence function calls interface 
redux studies program runs builds tree value dependencies capture essence computation 
whaley restricted model paradigm probable models object oriented interfaces easily automatically extracted 
alur generalize automatically produce small expressive finite state machines respect certain predicates object 
lam type system approach statically extract interfaces 
concerned high level system structure low level life cycle constraints 
daikon able validate correlations values runtime able validate patterns 
weimer exceptional control flow paths guide discovery temporal error patterns considerable success provide comparison existing specification mining 
uses cvs history mining combined dynamic analysis discover patterns detect pattern violations 
contrast pql system places burden model generation user 
partial models may develop queries provide information suggests extend model 
suitable actions attached queries pql query implement specialized model extractor directly 
aspect oriented programming pql attaches user specified actions subquery matches capability puts pql class aspect oriented programming languages 
maya aspectj attach actions syntactic properties individual statements source code 
dj system defines aspects traversals graph representing program structure 
system may considered aspect oriented system defines aspects respect dynamic history sets objects 
extension aspectj include dataflow pointcuts proposed represent statement receives value specific source pql represent statement query permits complex concepts data flow 
walker introduce concept declarative event patterns regular expressions traditional pointcuts specify advice run 
allan extend permitting pql free variables patterns 
primary focus aspectj extensions permitting developer specify application development concerns finely 
result devote great deal ensuring properties guarantees memory allocated matching machinery eventually available collection 
pql genesis focusing detecting application errors pays attention 
example patterns warn involves paired methods objects patterns intrinsically leaky 
class includes listener example 
pql differs systems matching machinery recognize nonregular languages exploiting advanced pointer analysis prove points irrelevant eventual matches 
program defect detection vast amount done bug detection 
code particular prone buffer overrun memory management errors tools prefix representative examples systems designed find specific classes bugs pointer errors object ownership violations respectively 
dynamic systems include purify traps heap errors eraser detects race conditions 
analyses implemented standard uses valgrind system 
bug classes outside purview pql language focusing individual pointer variables synchronization primitives 
pql targets java means web applications carry set security risks 
various systems developed help secure web applications 
static tool detects large number common design errors instantiations number error pattern templates 
nguyen dynamic systems detects failures validate input output php applications 
pql handle php principle analyses perform sequencing type tainting analysis easily amenable representation pql queries directly 
project suitable tracking taintedness finer granularity 
configurable express alternate patterns 
event analysis queries system defined respect conceptual execution trace consisting stream events 
implications paradigm debugging covered extensively system tools expanded basic concept provide additional power 
dalek debugger defines compound events simpler ones permits breakpoints occur compound event executed 
pql follows dalek building queries patterns simple events builds permitting events recursively mutually recursively defined 
program query languages systems jquery permit patterns matched source code liu extend concept include parametric pattern matching 
systems generally check source level patterns match widely spaced events 
key contribution pql pattern matcher combines object parametric matching widely spaced events 
developed interactive debugger queries heap structure 
analysis approach orthogonal previous systems named section pql pql query language explicitly designed resemble code language debugged 
system uses sql syntax extract individual elements execution stream 
directly combine complex events smaller ones placing boolean constraints primitive events select sets directly 
variables primitive types handled easily paradigm nearly arbitrary constraints placed easily strict ordering constraints require clauses express 
reliance individual predicates language easy extend unusual primitives particular system capable trapping events characterized amount absolute time passed capability systems discussed 
systems quantify finite number variables 
pql recursive subquery mechanism possible specify arbitrarily long chains data relations 
comparison purposes reproduced experiment pql query performed operates solely objects 
pql query single sequence calls chained times applied query number specjvm benchmarks including extensive string processing 
overhead expressed ratio instrumented uninstrumented runtime 
worst case scenario pql matcher instances pattern appear producing large number partial matches track 
query begins matching time stringbuffer created common operation 
highest overhead case jack benchmark complete match occurs execution inner loop code reading input file 
loop reads single character iteration producing thousands matches course run 
cases string clear amenable static pointer analysis contribute matches jess compress static optimization able lessen overhead dramatically point overhead lost instrumentation noise 
programs string processing simply rare db measurable cost imposed 
analysis generators pql follows tradition powerful tools take small specifications automatically generate analyses 
benchmark mtrt jess compress db jack javac unoptimized optimized overhead ratios string concatenation query specjvm 
metal slic define state machines respect variables 
machines configure static analysis searches program situations error transitions occur 
metal restricts finite state machines flexible event definitions handle pointers albeit unsound manner 
language uses definitions dataflow facts combined temporal logic operators permit definition analyses correctness may readily automatically verified 
focus significantly different systems intent easier directly implement correct compiler passes determine properties find bugs existing applications 
likewise primarily intended vehicle predefined analyses valgrind presents general technique dynamic analyses binaries 
model checkers model checking systems spin powerful widespread tools capturing complicated program properties 
model checkers generally operate languages promela bandera project abstracts java code form amenable spin model checkers 
systems represent queries models ltl formulas predicates bandera ties predicates expressions defined code 
paradigm lend direct comparison pql predicates implied pql query relate object identity statements histories objects sets objects 
possible consider individual pql query temporal logic equation describing events existentially quantified objects heap 
arbitrary ltl equations set predicates directly translatable pql 
ltl model checkers quantify universally paths ensure specified formula holds paths pql quantifies existentially paths heap find set objects pattern matched path 
pql subquery mechanism permits determined matches treated atomic propositions higher level recursive queries expressing properties easier 
research bandera group utility ltl program analysis resulted catalogue specification patterns idioms ltl particularly prevalent useful queries idioms correspond presence absence sequencing individual events 
patterns directly representable pql sequencing operator match exclusion 
pql language viewed complementary systems capable expressing natural practical queries application programs underlying concepts different ltl concept predicates changing truth values time compared pql concept objects evolving various states time system generalizes different sets applications 

new language called pql users pose application specific questions events patterns runtime 
language intuitive application developers provides bridge powerful analysis techniques 
systematically convert pql queries efficient online checkers combination static dynamic techniques 
doing demonstrate application pointer analysis bug finding soundness analysis critical 
pql numerous previously unknown security vulnerabilities resource leaks large open source java applications 
experience suggests synergistic combination static dynamic checking powerful 
static analysis find potential errors cases prove pattern match 
difficult cases dynamic monitoring guarantee applications trap instance certain class errors 
static analysis useful reducing dynamic analysis overhead 
static optimizations dynamic checking low overhead incorporated production code 

aho sethi ullman 
compilers principles techniques tools 
addison wesley 
allan christensen hendren de moor 
adding trace matching free variables aspectj 
oopsla proceedings th acm sigplan conference object oriented programming systems languages applications 
alur ern nam 
synthesis interface specifications java classes 
popl proceedings nd acm sigplan sigact symposium principles programming languages pages 
ammons bodik larus 
mining specifications 
proceedings th acm symposium principles programming languages pages 

advanced sql injection sql server applications 
baker 
parameterized pattern matching boyer moore type algorithms 
proceedings sixth annual acm siam symposium discrete algorithms pages 
baker hsieh 
runtime aspect weaving metaprogramming 
proceedings international conference aspect oriented software development 
ball rajamani 
slic specification language interface checking 
technical report msr tr microsoft research january 
bates 
debugging heterogeneous distributed systems event models behavior 
proceedings acm sigplan sigops workshop parallel distributed debugging pages 
bush pincus 
static analyzer finding dynamic programming errors 
software practice experience spe 
corbett dwyer hatcliff laubach robby zheng 
bandera extracting finite state models java source code 
icse proceedings nd international conference software engineering pages 
corbett dwyer hatcliff robby 
language framework expressing checkable properties dynamic software 
spin proceedings th spin workshop pages 
crew 
language examining syntax trees 
proceedings usenix conference domain specific languages pages 
du mathur 
vulnerability testing software system fault injection 
technical report coast purdue university west lafayette april 
du mathur 
testing software vulnerability environment perturbation 
proceedings international conference dependable systems networks dsn workshop dependability versus malicious faults pages new york city ny june 
ernst griswold notkin 
quickly detecting relevant program invariants 
icse proceedings nd international conference software engineering pages limerick ireland june 
goldsmith callahan aiken 
relational queries program traces 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla 
hallem chelf xie engler 
system language building system specific static analyses 
proceedings acm sigplan conference programming language design implementation pldi pages 
hastings joyce 
purify fast detection memory leaks access errors 
proceedings winter usenix conference pages december 
heine lam 
practical flow sensitive context sensitive memory leak detector 
proceedings acm sigplan conference programming language design implementation pldi pages 
holzmann 
model checker spin 
software engineering 
pugh 
finding bugs easy 
proceedings onward 
track acm conference object oriented programming systems languages applications oopsla 

huang yu hang 
tsai 
lee 
kuo 
securing web application code static analysis runtime protection 
proceedings th conference world wide web pages 
de 
navigating querying code getting lost 
proceedings nd annual conference aspect oriented software development aosd pages 
kiczales hilsdale hugunin kersten palm griswold 
overview aspectj 
lecture notes computer science 
klein 
divide conquer response splitting web cache poisoning attacks related topics www org papers general whitepaper pdf 

sql injection attacks oracle developers 
lam rinard 
type system analysis automatic extraction enforcement design information 
proceedings th european conference object oriented programming pages darmstadt germany july 
lzle singh 
query debugging object oriented programs 
oopsla proceedings th acm sigplan conference object oriented programming systems languages applications pages new york ny usa 
acm press 
lerner millstein rice chambers 
automated soundness proofs dataflow analyses transformations local rules 
popl proceedings nd acm sigplan sigact symposium principles programming languages pages 
liu yu stoller hu 
parametric regular path queries 
proceedings acm sigplan conference programming language design implementation pldi pages 
livshits zimmermann 
framework finding common bugs mining software revision histories 
proceedings acm sigsoft symposium foundations software engineering fse sept 
livshits lam 
finding security errors java programs static analysis 
proceedings th usenix security symposium aug 

password masking java programming language 
java sun com developer security july 

mailing list 
vulnerability scanner sql injection 
www com mailing lists securityfocus focus ms html 

dataflow pointcut aspect oriented programming 
asian symposium programming languages systems pages 
web application firewall stops classes web application threats www com products whitepapers cfm nc whitepaper pdf 
nethercote mycroft 
redux dynamic dataflow tracer 
viswanathan editors electronic notes theoretical computer science volume 
elsevier 
nethercote seward 
valgrind program supervision framework 
viswanathan editors electronic notes theoretical computer science volume 
elsevier 
nguyen greene shirley evans 
automatically hardening web applications precise tainting 
proceedings th ifip international information security conference 
wilson 
swt standard widget toolkit volume 
addison wesley professional 
olsson ho 
dataflow approach event debugging 
software practice experience 
orleans lieberherr 
dj dynamic adaptive programming java 
reflection meta level architectures separation crosscutting concerns kyoto japan september 
springer verlag 
pages 

critical web application security vulnerabilities 
reimer schonberg srinivas srinivasan alpern johnson 
smart analysis error reduction 
proceedings international symposium software testing analysis 
savage burrows nelson sobalvarro anderson 
eraser dynamic data race detector multithreaded programs 
acm trans 
comput 
syst 
schach 
object oriented classical software engineering 
mcgraw hill science engineering math 

hunting flaws jdk 
europe 
patterns projects cis ksu edu 

cross site scripting web applications vulnerable 
www com support whitepapers pdf 
tate 
bitter java 
manning publications 
vernon 
top threats 
com www com article htm april 
voas mcgraw 
software fault injection programs errors 
john wiley sons 
wagner foster brewer aiken 
step automated detection buffer overrun vulnerabilities 
proceedings network distributed systems security symposium pages 
walker 
implementing protocols declarative event patterns 
sigsoft fse proceedings th acm sigsoft international symposium foundations software engineering pages new york ny usa 
acm press 
web application security consortium 
threat classification 
www org tc tc pdf 
weimer necula 
mining temporal specifications error detection 
proceedings th international conference tools algorithms construction analysis systems pages apr 
weimer necula 
finding preventing run time error handling mistakes 
th annual acm conference object oriented programming systems languages applications oopsla oct 
whaley lam 
cloning context sensitive pointer alias analysis binary decision diagrams 
proceedings acm sigplan conference programming language design implementation pldi 
whaley martin lam 
automatic extraction object oriented component interfaces 
proceedings international symposium software testing analysis pages 
whittaker thompson 
break software security 
addison wesley 
xie aiken 
scalable error detection boolean satisfiability 
proceedings nd acm symposium principles programming languages 
