ieee transactions large scale integration vlsi systems vol 
may multiple clock voltage island design style power aware processors enabled continuous advancement fabrication technology day synchronous microprocessors include transistors clock speeds excess ghz mark 
distributing low skew clock signal frequency range areas large chip task growing complexity 
solution problem designers suggested frequency islands locally clocked externally communicate mixed clock communication schemes 
design style fits nicely proposed concept voltage islands addition potentially enable fine grain dynamic power management simultaneous voltage frequency scaling 
proposes design exploration framework application adaptive multiple clock processors provides means analyzing identifying right interdomain communication scheme proper granularity choice voltage frequency islands case superscalar order processors 
addition design exploration framework allows comparative analysis newly proposed published application driven dynamic power management strategies 
design exploration framework accompanying results help designers computer architects choosing right design strategy achieving better power performance tradeoffs multiple clock high processors 
index terms clocking strategies low power design superscalar processor designs simulation 
decades dominated moore law performance primary driving force processor design 
trend lead vast increase number transistors modern microprocessors pushing clock frequencies higher values 
unfortunately trend resulted huge increase power dissipation current processors increase power dissipation directly impacts cpu lifetime system power delivery costs system thermal design needed keeping operating temperature specified limits 
addition major design bottlenecks today high performance vlsi systems clock distribution network 
large clock nets perform long signal paths making hard designers keep clock skew tolerable limits 
clock frequencies manuscript received april revised august 
supported part ibm sur src hj 
authors electrical computer engineering department carnegie mellon university pittsburgh pa usa mail ece cmu edu ece cmu edu 
digital object identifier emil diana marculescu member ieee ieee range long wires needed driving clock signal increasingly large processor dies significant bottleneck complex clocking synchronization schemes needed 
furthermore clock skew getting worse technology shrink due increasingly high process system parameter variation nm technology 
case studies show circuitry needed driving frequencies dominant source power consumption 
adding transistors single die tends worsen problem larger clock nets require power 
address problems approaches possible 
option fully asynchronous designs 
tried successfully isolated cases design methodologies asynchronous design far mature far widespread acceptance 
asynchronous designs usually hard test validate impossible generate possible timing combinations 
furthermore impossible reproduce signal timings cause particular error debugging designs complicated 
alternative globally asynchronous locally synchronous gals architectures attempt combine benefits fully synchronous asynchronous systems 
gals architecture composed synchronous blocks communicate demand asynchronous mixed clock communication scheme 
locally generated clock signal individual domain architectures possible take advantage industry standard synchronous design methodology 
requiring global clock distribution network circuitry systems important advantages compared fully synchronous counterparts 
overhead introduced communicating data clock domain boundaries may fundamental drawback limiting performance systems 
choice granularity synchronous blocks islands carefully done order prevent interdomain communication significant bottleneck 
time choice interdomain communication scheme fly mechanisms domain dynamic speed voltage scaling dvs critical analyzing power performance trends 
contribution proposed twofold 
ieee transactions large scale integration vlsi systems vol 
may approach allows design space exploration application adaptive multiple clock high processors analyzing available power performance tradeoffs 
parameters consideration include choice microarchitecture level granularity frequency islands choice mixed clock communication scheme choice application adaptive mechanisms fine grain power management 
second introduces new type dynamic control strategy application adaptive multiple clock processors closely matches voltage speed various frequency voltage islands ones required application workload 
newly proposed dynamic control mechanism relies better matching front back throughputs dependency information clock domains take better global decisions 
analysis shows baseline gals processors necessarily better terms power consumption fully synchronous designs 
characterized decrease performance due asynchronous communication overhead adverse effects energy consumption 
energy savings obtained eliminating global clock cases offset additional power consumed due longer execution times 
dynamic voltage scaling gals microprocessors appealing applications providing additional power savings 
organized follows 
section ii details motivation lies investigation minimally clocked processors 
sections iii design exploration framework microarchitecture consideration various design choices designing gals microprocessor 
section vi presents theoretical aspects scaling frequency clock voltage algorithms 
section vii details simulation framework experimental setup results tests section viii 
section ix presents previous related aspects addressed including global clock distribution asynchronous communication dynamic control strategies 
conclude analysis trends observed experimental results directions research 
ii 
motivation transistor minimum feature scaled nm clock speed enters range problems related distributing clock signals increasingly complex die tend surface 
designers alpha microprocessor problems encountered migrating design nm copper process wire delays affecting migration process 
long wires required driving logical signals chip affecting performance shortened possible allow frequency increases negative impact ability driving global clock signals 
example complex clock fig 

example hierarchical clock distribution network 
design commercial processor intel pentium iv 
delivering clock signal excess ghz entire processor core intel developed special circuitry programmable clock 
clock distribution generating high frequency clock signal distributing large die low skew challenging task demanding lot design effort die area power 
cases phase lock loop pll generates high frequency clock signal slower external clock 
combination metal grids tree buffers distribute clock chip 
trees low latency dissipate power wiring need rerouted logic modified slightly custom designed processor requires lot effort 
trees clock load uniform chip area unfortunately microprocessors widely varying clock loads 
metal grids provide regular structure facilitate early design characterization clock network 
minimize local skew providing direct interconnections clock pins 
clocking processors today hierarchical 
fig 
shows example hierarchical distribution network major clocks derived global clock grid local clocks turn derived major clocks 
approach serves modularize design minimize local skew inside block 
advantage clock drivers functional block customized skew drive requirements block drive global clock grid need designed worst case clock loading 
high clock frequencies driving increasing number transistor available chip power burned clock distribution network starts limitation 
instance alpha clock distribution network consumed processor total power budget high power issue mobile devices desktops servers instance case generation alpha processor single line driver clock grid led thermal management problems continuous switching driver led high temperature chip center high temperature gradient 
power class constraint clock system design 
apart power burned large distribution networks problem quality clock signal 
argued clock skew arises mainly due process variations tree buffers driving clock 
marculescu multiple clock voltage island design style device geometries continue shrink clock frequencies die sizes continue increase global clock skew induced process variations get worse 
argue may far point clock skew significant proportion cycle time directly affect performance 
instance release intel itanium core clock skew cycle time traditional clock distribution techniques network active elements clock skew reduced cycle time 
techniques active help push envelope clocked systems come additional cost terms die area power dissipation 
point pushing limits global clock distribution networks lead diminishing marginal returns 
aspect local clocks promising increasing variation process operating parameters various regions core 
variations affect maximum sustainable clock speed 
show variations temperature different microarchitecture components 
process variations difficult quantify microarchitectural level obvious parts core support lower maximum frequency 
gals microarchitecture able take advantage variations clocking domains faster fully synchronous counterpart 
fine grain dynamic voltage scaling applications running core processors high embedded application specific exhibit wide range run time profiles applications 
mainly manifested nonuniform resource usage bursty communication patterns various parts pipeline 
example fetch stage cache accessed instructions brought fetch queue 
cache resolved issue execution stages pipeline may proceed pace instructions advance pipeline due pending dependencies 
similar situation may appear case nonblocking cache misses 
case multiple outstanding cache misses resolved instructions may proceed normally pipeline 
addition instructions noncritical performance infrequent floating point operations integer applications execution may proceed lower speed significantly affecting performance 
multiple clock domains offers flexibility comes additional potential power savings 
locally synchronous blocks speed may gracefully scaled run lower voltage providing additional power savings 
iii 
design exploration framework start fairly typical order superscalar architecture analyze impact various microarchitecture design decisions power performance tradeoffs available multiple clock processor 
assume stage pipeline implements way fig 

baseline microarchitecture 
superscalar order processor 
pipeline significantly longer ones studied feel increased length resembles accurately pipelines projected generation commercial processors 
underlying microarchitecture organization shown fig 

groups aligned instructions brought level instruction cache fetch stages current program counter pc address pc predicted share branch predictor 
instructions decoded pipeline stages named decode registers renamed rename stages 
dispatch stages instructions steered type integer floating point memory clusters pipeline 
ordering information needs preserved order retirement added 
register read read operation completes source operand values sent execution core instruction opcode 
instructions placed distributed issue buffer similar alpha reordered data dependencies 
independent instructions sent parallel order execution core 
execution take clock cycles depending type functional unit ieee transactions large scale integration vlsi systems vol 
may fig 

total clock skew alpha function interconnect parameters dielectric thickness interconnect thickness technology parameters threshold voltage transistor channel length oxide thickness system parameters supply voltage load capacitance temperature 
executes instruction results written back register file write back stages 
instructions reordered order retirement tags received dispatch 
branches resolved write back providing minimum mispredict penalty cycles 
extreme importance design exploration choice various design knobs impact power performance tradeoffs gals processors 
primary focus microarchitecture level chose omit lower level issues study 
areas dealt detail follows 
local clock generation clock domain gals system needs local clock generator ring oscillators proposed viable clock generation scheme 
assume ring oscillators synchronous block gals processor 
failure modeling system multiple clock domains prone synchronization failures attempt model probabilities small communication mechanisms considered nonzero target mission critical systems 
focusing microarchitecture design knobs choice communication scheme frequency islands granularity chosen frequency islands dynamic control strategy adjusting voltage speed clock domains achieve better power efficiency 
detail microarchitecture level design decisions may potentially impact power efficiency performance profile gals architecture 
iv 
choice clock domain granularity assess impact introducing mixed clock interface performance baseline pipeline assume pipeline broken synchronous blocks 
natural approach minimize communication synchronous blocks boundaries necessarily 
instruction pass pipeline stages order completed 
find criteria determining synchronous islands 
fig 

performance increase domain speedup 
possible criterion placing asynchronous interfaces minimize clock skew allowing faster local clocks 
authors propose model skew chip clock signal 
applying model alpha microprocessor evaluate contribution different microarchitectural physical elements increasing skew limiting clock frequency 
seen fig 
main components affecting clock skew system parameter variations supply voltage load capacitance local temperature especially variations microarchitecture described fig 
exhibits large variation number pipeline registers clocked possible placement asynchronous interfaces shown dotted 
evaluate partitions enable higher performance sped independently show fig 
speedup coefficient characterizes amount speedup achieved domain local clock frequency increased 
seen set benchmarks significant speedup achieved increasing clock speed fetch memory followed integer fp partitions 
modules placed separate clock domains possible individually provide significant performance increase sped 
break execution core partitioning scheme proposed 
starting processor separate clusters integer floating point memory execution units alpha design naturally separate clusters synchronous modules 
drawback scheme increases significantly latency forwarding result asynchronous interface functional unit 
effect seen mainly load operations executed separate clock domains imposing significant penalty performance programs 
limit latency reading writing data registers register read write back stages placed synchronous partition register file 
rationale rename retire stages need access rename table placed partition 
design choices split pipeline clock regions 
composed fetch stage branch prediction instruction cache logic 
decode stages included marculescu multiple clock voltage island design style fig 

timing diagram 
synchronizers 
plausible clocks 
arbiters 
clocking region second instructions pass fetch decode passed pipeline rename 
intend limit clock skew possible limiting load capacitance variations considering bitwidth increase pipeline decode introduce asynchronous boundary 
second clocking region organized renaming mechanism contain reorder buffer retire logic 
variation register width rest pipeline asynchronous boundary introduced dispatch 
third clocking region organized register file including register read write back stages 
order part pipeline issue logic execution units split separate clusters amount different clock regions 
forwarding paths internal unit type placed clock region external clock regions 
choice interdomain communication scheme important aspects implementing gals microprocessor choosing asynchronous communication protocol 
high performance processors bandwidth latency internal communication important tradeoff harder identify 
mechanisms proposed asynchronous data communication synchronous modules larger design 
conventional scheme tackle problems extensive synchronizers double latching mechanism conservatively delays potential read waiting data signals stabilize shown fig 

data produced time step synchronizer enforces availability consumer time step 
classical synchronizers unattractive decreases performance probability failure system rises number synchronized signals 
clocks fig 
proposed scheme relies stretching clock periods communicating blocks data available receiver ready accept 
greater arbitrary threshold read proceed active edge consumer clock delayed 
latency better approach assumes asynchronous communication infrequent 
stretching clock reflected performance synchronous block effective blocks similar clock frequency 
effective mechanism block wait anyway data available 
approach arbiters detecting timing violation condition fig 

case data produced time step may available time step larger certain threshold 
mechanism conceptually similar synchronizers offers smaller latency 
asynchronous fifo queues proposed synchronizers arbiters 
approach works assumption fifo completely full completely empty 
scheme retains extra latency introduced synchronizers improves bandwidth pipelining 
nominal operation structure fifo empty full potential read serviced different cell handling write performed synchronization 
mechanisms reduce error probability low levels ensure occur 
showed error rate reduced desired 
typically mean time failure order hundreds years order magnitude higher time soft error occurrences expected life product 
vi 
choice dynamic control strategy main advantages offered gals approach ability run synchronous module different clock frequency 
original pipeline stages perfectly balanced synchronous blocks obtain partitioning naturally clocked different frequencies 
example longest signal path belongs register renaming module gals approach potentially run execution core higher clock frequency fully synchronous design 
furthermore start perfectly balanced design resize transistors order speed longer signal paths slow synchronous blocks critical path keeping running nominal speed 
slower clock domains operate lower supply voltage producing additional power savings 
energy consumption quadratically dependent reducing lead significant energy benefits latency increased accordingly technology dependent factor current technologies threshold voltage 
provide theoretical results efficiency fine grained dynamic voltage scaling multiple clock dynamic voltage cores 
assume hold 
consider case pipelined cores clock domain pipe stages total load critical path clock domain 
ieee transactions large scale integration vlsi systems vol 
may switched capacitance clock domain voltage clock speed associated clock domain lemma assuming linear pipeline organization feedback paths synchronous design achieves better energy savings corresponding design slowdown factor computation switched capacitance clock domain proportional total load critical path proof assume base pipeline run voltage latency computation dvs enabled gals pipeline clock domains running voltage assume clock domains exists load overhead due synchronization voltage level conversion 
achieve latency hold consider function convex 
function monotonically decreasing proportionality clock domains get shows synchronous pipeline performs better energy wise gals version slowdown factor performance penalty assumptions lemma 
result fact generalization optimal voltage scheduling problem applications hard real time constraints 
showed single voltage level dynamic voltage scheduling environment achieves best energy savings performance constraints 
general problem far simple 
fact designs relationship load critical path corresponding switched capacitance clock domain 
show necessary condition fine grained dynamic voltage assignment different clock domains achieving better energy savings gals compared synchronous pipelines special case clock domain implementation 
lemma case clock domain pipeline ratio switched capacitance clock domain load critical path different clock domain gals pipeline achieve better energy savings synchronous counterpart slowdown factor lower voltage applied stage satisfies relation proof lemma satisfied gals better terms energy synchronous counterpart need get result confirms intuition order achieve energy savings gals versus dvs enabled synchronous design slowdown factor lower voltages applied power consuming clock domains contributing latency computation 
results extended linear pipelines feedback paths lumping strongly connected components component graph single nodes applying results single linear pipelines 
theoretical results multiple computations executed parallel case high processors computations critical path executed lower voltage affecting performance slowdown factor 
exploit nonuniform program profiles various workloads different schemes previously proposed selecting optimal frequency voltage supply gals processor 
simple threshold algorithm selecting best operating point modules normal low power mode 
algorithm monitors average occupancy issue window decide switch module low power mode occupancy drops predefined threshold ramp voltage high threshold exceeded 
issue window integer floating point memory algorithm follows 

occupancy module threshold module speed aa low speed 
module speed high speed 
occupancy module threshold module speed aa high speed marculescu multiple clock voltage island design style 
module speed low speed complex model proposed 
attack decay algorithm assumed selecting best operating point processors offer wide range frequencies supply voltages 
algorithm monitors instruction window occupancy variation decides frequency increased decreased 
significant variation triggers rapid change clock frequency order counter 
small variations clock frequency decayed continuously monitoring performance 

prev occupancy occupancy old ipc ipc threshold 
module speed attack 

occupancy prev occupancy threshold 
module speed 

module speed aa high speed counter max limit 
module speed attack 

module speed aa low speed counter max limit 
module speed 

module speed decay 
module speed low speed 
module speed low speed 


module speed ba high speed 
module speed high speed 


prev occupancy occupancy looking superscalar order microarchitecture note instruction window occupancy significant aspect considered deciding switch 
instruction window high occupancy due bottleneck cluster 
load operations delayed instructions accumulate integer cluster 
speeding clock integer domain improve performance 
case decisions local issue queue occupancy help number interdomain data dependencies number pending dependencies clock domain may significant issue window occupancy 
furthermore allow dynamic voltage scaling just execution core assuming clock speed front critical performance reduced 
large portions core usable parallelism defined terms instructions committed clock cycle ipc significantly smaller theoretical pipeline throughput 
cases sense reduce speed front produces instructions processed back 
order study efficiency observations propose modify previously described methods include information number interdomain dependencies dynamic voltage scaling algorithm front pipeline 
applying modification threshold algorithm execution modules obtain 

inter domain module threshold module speed aa low speed 
module speed high speed 
inter domain module threshold module speed aa high speed 
module speed low speed front clock domain algorithm follows 
front throughput back throughput front threshold 
module speed high speed 
front throughput back throughput front threshold 
module speed low speed similarly modified algorithm derived attack decay approach combined metric allowing variations front frequency 
study compare methods proposed modified counterparts take consideration interdomain dependencies 
vii 
simulation framework measure impact performance power required gals microarchitecture implemented cycle accurate simulation model original pipeline fig 

simulator simplescalar reflects target pipeline accurately 
opposed simplescalar uses normal pipeline registers separate instruction windows execution clusters retire buffer 
register renaming mechanism chosen similar mips processor 
moved execution decode done simplescalar execute stage better reflect behavior pipeline 
order model gals environment global synchronization point developed event driven simulation engine 
events associated frequency island synchronized clock signal randomly started ieee transactions large scale integration vlsi systems vol 
may table temperature clock speed variations simulation 
event driven simulation engine allows mixture clocks running different speeds different starting phases 
wattch framework include power models design exploration framework 
power models including ones asynchronous communication integrated baseline gals simulator versions provide energy statistics 
assumed component clock gated cycle basis overhead leakage current 
leakage power obtained methodology proposed sohi 
model estimation total number devices entire processor type 
normalized leakage current device estimated 
addition modeling switching capacitance memories buses inside processor modeled switched capacitance clock grids 
assumed clock distribution hierarchy resembling alpha processor 
modeled global clock grid local clock grids corresponding synchronous domains 
area metal density clock grid ones published alpha processor 
difficult model process variations microarchitectural level model effect die temperature maximum clock frequency 
results show temperature variation different modules table 
computing relative speeds various clock domains model proposed temperature logic depth assume identical different pipeline stages original balanced pipelined implementation 
effects impact maximum clock speed provide idea usefulness having independent clock grids domain 
parameters microarchitecture consideration table ii 
experiments integer floating point benchmarks spec spec suites 
experiments skipped instructions continued simulation instructions 
gals case local clock signals randomly staggered simulations case run times averaging results 
compare various dynamic control strategies arbiter table ii microarchitecture parameters asynchronous fifo communication 
similar synchronous pipeline assume active clock edge producer signals moment data available reading consumer cycle start 
subsequent active edge consumer accepted valid request setup time observed producer cycle 
viii 
experimental results assuming modules clocked frequency synchronous design analyzed impact granularity asynchronous communication choice impact dynamic control strategy performance power 
arbiter asynchronous fifos interdomain communication clock domain case performance penalty observed 
shown fig 
performance hit increases number asynchronous interfaces average clock domains case clock domains 
terms power consumption gals processor efficient due lack global clock grid 
due increased execution time power cycle significantly improved total energy task required gals processor slightly decreased fig 

clock domain microarchitecture allow independent speedup register file clock domain fig 
significant impact marculescu multiple clock voltage island design style fig 

performance degradation gals microarchitecture 
cases baseline fully synchronous microarchitecture clock frequency gals domains 
fig 

energy reduction gals design partitions 
performance best choice clock domain design allow fetch execution cores run possibly different speeds 
setup gals processor requires energy completing task 
order evaluate effectiveness asynchronous communication scheme considered arbiter synchronizer fifos clocks 
clocks approach effectively delays active clock edge synchronization done effective producer consumer latency approach minimal 
arbiters failed attempt read data followed normal consumer cycle active edge completely asynchronous respect producer clock 
introduces additional average delay cycles 
reasoning cycle latency associated synchronizers observed cycles average coupled random starting phases producer consumer clocks 
expected largest drop performance observed synchronizer fifos 
case performance decrease observed clock domain design average fig 

smallest hit performance achieved clocks average 
better understanding results looked instruction latency varies number asynchronous interfaces communication mechanism 
latency increases fig 

performance degradation different mechanisms asynchronous communication 
cases baseline fully synchronous microarchitecture clock frequency gals domains 
fig 

latency increase various gals configurations 
fig 

energy reduction gals design different asynchronous communication mechanisms 
clocks arbiters instructions spend time fetch retire communication synchronizers fig 

additional latency increases mispredict penalty bypass latency affecting performance 
terms energy requirement mechanisms brings significant improvement 
small improvement noticed clocks arbiters average case synchronizer fifos leads increase energy demands 
energy results experiments fig 

expected results show mechanisms introducing smallest additional latency clocks ieee transactions large scale integration vlsi systems vol 
may fig 

performance dvs enabled gals design clock domains arbiter fifos 
cases baseline fully synchronous microarchitecture maximum clock frequency supported gals modules 
synchronizer fifos performing terms performance power consumption 
arbiter fifo behaves close offers better bandwidth expense slightly increased latency 
fifo mechanisms introduce additional load clock generation network increasing number latches 
effect limited tests showing average increase clock power translates increase entire core 
essentially blocking clock signal consumer observe synchronization latency clocks difficult different speeds domains 
implementing dynamic control local speeds voltages chose arbiter fifos 
important advantages gals microarchitecture ability independently scale voltage clock frequency dvs synchronous partitions 
evaluate performance power requirements processor previously proposed algorithms threshold select best operating points attack decay algorithm assumes larger set operating points 
test efficiency focusing average instruction window occupancy threshold attack decay number interdomain dependency threshold dependency attack decay dependency 
dynamic control mechanisms evaluated introduce average drop performance compared synchronous baseline architecture fig 

interesting aspect introducing interdomain dependency information automatically improve performance 
cases performance slightly worse dependency information 
behavior caused decision allow dynamic voltage scaling front 
additional drop performance offset better energy efficiency fig 

terms energy requirement dvs enabled gals design saves compared baseline synchronous case 
average dvs algorithms study offer energy savings expense drop performance 
fig 

energy consumption dvs enabled design clock domains arbiter fifos 
fig 

performance degradation gals microarchitecture 
cases gals domains faster clock speed table ii baseline fully synchronous microarchitecture 
second advantage gals microarchitecture clock domain comes independent clock distribution network able take advantage higher frequencies fully synchronous processor 
gals microarchitecture take advantage slight design adapt different operating conditions 
evaluate response gals microarchitecture conditions consider die temperature variation rationale correlating clock speeds operating temperatures 
shown table exists significant temperature variation different modules variation translates different maximum clock frequencies 
probably pessimistic assumption take consideration potential process variation system parameter factors may affect local clocking speeds 
offers idea effects faster clock domains 
allowing clock domain run maximum frequency table performance increases significantly 
effect asynchronous communication offset gals microarchitecture performs fully synchronous baseline 
cases parser bzip performance gals microarchitecture better fig 

interesting aspect results show regular pattern 
cases version clock domains faster 
effect marculescu multiple clock voltage island design style fig 

performance degradation gals microarchitecture 
cases gals domains faster clock speed table ii baseline fully synchronous microarchitecture 
fig 

performance dvs enabled gals design clock domains arbiter fifos 
cases gals domains faster clock speed table ii baseline fully synchronous microarchitecture 
caused fact clock domains combined resulting speed slowest 
example obtaining clock domain version combine rename dispatch register file resulting domain works speed register file hottest slowest tests 
see similar picture looking different communication mechanisms 
performance reduction smaller maintains similar trend lower latency mechanisms performing better 
results fig 

enabling dynamic voltage scaling assumed clock frequency levels scaled ratio table performance gap narrows dvs enabled gals microarchitecture performing fully synchronous baseline fig 

tests assume clock speed improvements domain obtained resorting increases corresponding voltage level 
energy level remains fairly similar reductions range 
results fig 

final analysis includes breakdown energy budget baseline dvs enabled gals cores 
seen fig 
significant savings clock distribution network lead better energy efficiency 
second important source energy reduction leakage linearly dependent voltage supply 
additional savings obtained issue queues fig 

energy consumption dvs enabled design clock domains arbiter fifos 
cases gals domains faster clock speed table ii baseline fully synchronous microarchitecture 
fig 

energy breakdown dvs enabled design clock domains arbiter fifos 
benchmarks included left gcc right mesa 
breakdown starts energy values rename branch predictor bottom vertical bar ends values clock energy leakage top bars 
alus execution clusters remains unused application offer parallelism gcc 
case mesa right bars fig 
processor utilizes better integer floating point execution clusters 
front clock speed infrequently scaled energy savings modules marginal 
ix 
related address problems introduced need global clocking large fast circuit approaches proposed years 
option fully asynchronous designs 
tried successfully isolated cases design methodology asynchronous design far widespread acceptance 
asynchronous systems eliminate clock altogether industry ready switch completely asynchronous design style design tools area mature synchronous design 
approach exploits trend making functional blocks autonomous maintaining synchronous design methodology globally asynchronous locally synchronous clocking style 
case studies shown benefit technique ieee transactions large scale integration vlsi systems vol 
may proposed 
observation specific cases communication performance different building blocks critical 
technique mentioned studies possible solution dealing global clock problems high performance processors 
studies focused assessing viability gals clocking strategy superscalar order processor 
performance power consumption processor evaluated 
performance worse fully synchronous case average identifies ability gals processor different clock frequencies supply voltages synchronous islands 
simple threshold algorithm select best possible voltage levels shows gals processor provide power benefits expense performance loss 
idea scaling clock frequency supply voltage block basis studied 
acknowledging drop performance authors find processors power efficient fully synchronous counterparts 
propose complicated algorithm attack decay strategy select optimum voltage clock frequency large number possible levels 
related area research addresses mixed clock asynchronous interface design robust speed independent communication frequency islands 
number mechanisms avoiding potential race conditions evaluated asynchronous wrappers clock generators demand ports poll ports 
designs ensure proper behavior system provide worse communication characteristics synchronous counterparts 
address issue asynchronous queues proposed 
mechanism improve latency increases communication bandwidth allowing data transfers clock cycle clock domains 
propose simulation framework allows rapid evaluation different design choices available implementing gals processor microarchitecture 
framework evaluate power performance achieved gals implementations superscalar order processor 
results show asynchronous interfaces introduced synchronous modules significant effect varying clocks synchronizers 
clocks better choice allow communicating modules run different clock frequencies 
gals design attractive take consideration process system parameter variations 
sense assume resulting partitions faster original fully synchronous pipeline results show gals microarchitecture take advantage 
considering temperature variations performance drop significantly limited 
terms power consumption gals design paradigm offer significant benefit dynamic voltage scaling implemented 
reduced clock power offset cases additional runtime needed finish computation 
significant advantage offered gals methodology allows frequency voltage levels changed independently module 
dvs average energy reduction achieved expense reduction performance 
performance gap significantly narrowed independently setting maximum speed domain significant effects power consumption 
case results show reduction expense reduction performance 
acknowledgment authors anoop iyer contribution initial version gals simulation environment 
fletcher multi ghz clocking scheme intel pentium microprocessor int 
solid state circuits conf feb 
clay design migration challenges alpha microprocessor um copper process int 
solid state circuits conf feb 
garside gilbert amulet high performance self timed arm microprocessor int 
conf 
computer design sep 
stevens rotem myers yun kol dike asynchronous instruction length decoder th int 
symp 
advanced research asynchronous circuits systems apr 
martin lines nystrom cummings lee design asynchronous mips microprocessor th conf 
advanced research vlsi sep 
kumar evaluating benefits globally asynchronous locally synchronous vlsi architecture th conf nov 
felber globally asynchronous locally synchronous architectures simplify design chip systems th ieee int 
asic soc conf sep 
iyer marculescu power performance evaluation globally asynchronous locally synchronous processors int 
symp 
computer architecture may 
power efficiency multiple clock multiple ieee acm int 
conf 
computer aided design iccad san jose ca nov 
semeraro dwarkadas scott dynamic frequency voltage control multiple clock domain microarchitecture th int 
symp 
microarchitecture nov 
semeraro dwarkadas scott energy efficient processor design multiple clock domains dynamic voltage frequency scaling symp 
high performance computer architecture feb 
preston high performance microprocessor design ieee solid state circuits pp 
may 
clock distribution network microprocessors ieee solid state circuits vol 
pp 
may 
marculescu multiple clock voltage island design style tam desai kim zhang young clock generation distribution ia microprocessor ieee solid state circuits vol 
pp 
nov 
mcfarling combining branch predictors dec western res 
lab palo alto ca tech 
rep dec wrl tech 
note tn 
ronen mendelson lai 
lu pollack shen coming challenges microarchitecture architecture proc 
ieee vol 
pp 
mar 
practical design globally asynchronous locally synchronous systems th int 
symp 
advanced research asynchronous circuits systems apr 
brooks tiwari martonosi wattch framework architectural level power analysis optimizations int 
symp 
computer architecture jun 
ha mule characterization modeling clock skew process variations proc 
ieee custom integrated circuit conf may pp 

robust interfaces mixed systems application latency insensitive protocols design automation conf jun 
burger austin bennet evaluating microprocessors simplescalar tool set univ wisconsin madison tech 
rep jul 
chen hu performance scaling deep cmos ieee solid state circuits vol 
pp 
oct 
voltage scheduling problem dynamically variable voltage processors int 
symp 
low power electronics design islped 
asynchrony parallel computing question scale int 
conf 
massively parallel computing systems apr 
bengtsson globally asynchronous locally synchronous simd processor int 
conf 
massively parallel computing systems apr 
stan huang tarjan temperature aware microarchitecture th int 
symp 
computer architecture jun 
sohi static power model architects proc 
int 
symp 
microarchitecture dec pp 

rao liu su burns leakage leakage sensitivity computation combinational circuits proc 
int 
symp 
low power electronics design aug pp 

fourteen ways fool synchronizer int 
symp 
asynchronous circuits systems 
niyogi marculescu speed voltage selection gals systems voltage frequency islands acm ieee asian south pacific design automation conf 
shanghai china jan 
shivakumar kistler burger alvisi modeling effect technology trends soft error rate combinational logic int 
conf 
dependable systems networks 
basu lin mehrotra banerjee simultaneous optimization supply threshold voltages low power high performance circuits leakage dominant era design automation conf jun 
emil received degree computer science university bucharest bucharest romania ph degree carnegie mellon university cmu pittsburgh pa respectively 
currently postdoctoral researcher cmu 
research interests include computer architecture energy aware computing 
diana marculescu received degree computer science university bucharest bucharest romania ph degree computer engineering university southern california los angeles 
currently assistant professor electrical computer engineering carnegie mellon university pittsburgh pa research interests include energy aware computing cad tools low power systems emerging technologies electronic textiles ambient intelligent systems dr marculescu recipient national science foundation faculty career award acm sigda technical leadership award 
ieee circuits systems society distinguished lecturer member executive board acm special interest group design automation sigda 
