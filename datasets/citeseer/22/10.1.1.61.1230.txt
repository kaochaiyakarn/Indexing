composition inference uml class diagrams knowing associations compositions important tool reverse engineering uml class diagrams 
firstly recovery composition relationships bridges gap design code 
secondly composition relationships explicitly state requirement certain representations exposed important determine requirement met component code 
verifying compositions implemented properly may prevent serious program flaws due representation exposure 
propose implementation level composition model ownership novel approach identifying compositions java software 
approach static ownership inference parameterized class analysis designed incomplete programs 
empirical results instantiation approach 
experiments average examined fields account relationships identified compositions 
precision evaluation shows code base analysis achieves perfect precision misses composition relationships 
results indicate precise identification relationships done simple inexpensive analysis easily incorporated reverse engineering tools support iterative model driven development 
categories subject descriptors software engineering distribution maintenance enhancement restructuring reverse engineering reengineering logics meanings programs semantics programming languages program analysis general terms algorithms keywords uml points analysis reverse engineering ownership 
modern software development design recovery reverse engineering performed typical iterative development process reverse engineering performed ana milanova department computer science rensselaer polytechnic institute milanova cs rpi edu iteration recover design previous iteration 
uml class diagrams describe architecture program terms classes relationships scalable informative widely design models 
uml concepts class inheritance corresponding class concepts object oriented programming languages uml concepts association aggregation composition corresponding language concepts 
reverse engineering classes inheritance hierarchies straightforward reverse engineering associations presents various challenges 
uml associations model relatively permanent relationships conventionally implemented instance fields type association class class implemented field type class 
reverse engineering tools infer associations examining instance fields type inference non trivial 
challenge recovery associations implemented pseudo generic containers vector 
challenge recovery compositions 
modern reverse engineering tools rational rose address challenges produce inconsistent class diagrams see gu detailed examples 
clearly leads gap design class diagrams reverse engineered class diagrams hinders understanding roundtrip engineering identification design patterns 
goal bridging gap proposes methodology inference binary associations uml class diagrams 
major focus inference composition relationships believe challenging inadequately addressed previous 
uml concept aggregation strictly meaningless chapter defined semantics association uml concept composition defined semantics emphasizes notion ownership composition strong form part association strong ownership parts composite coincident lifetime parts composite 
part may belong component time chapter 
composition relationship design level states requirement ownership representation exposure implementation level owned component object exposed outside composite owner object composition implemented correctly ownership preserved 
important investigate techniques recovery composition relationships 
firstly helps bridge gap design class diagram reverse engineered diagram 
secondly composition relationships explicitly state requirement certain representations exposed important determine requirement met component code 
verifying compositions implemented properly may prevent serious program flaws due representation exposure wellknown signers bug java 
goals define implementation level ownership model captures notion composition design ii design analysis algorithm infers ownership composition model 
definition implementation level composition owners dominators ownership model model owner object composite dominate owned object component access paths owned object pass owner :10.1.1.23.2115
owners dominators model defines ownership boundary owner intuitively owned object may accessed owner objects boundary owner owned object stored instance field may passed owned container 
pointed clarke observed empirical study owners dominators model captures notion composition modeling :10.1.1.23.2115
propose novel static analysis ownership inference 
ownership inference determines objects stored field owned enclosing object analysis identifies composition field 
approach works incomplete programs 
important feature context reverse engineering tools essential able perform separate analysis software components 
example typical analyze component having access clients component 
ownership inference analysis parameterized class analysis determines classes objects variable object field may refer 
class analysis solution approximate possible accesses run time objects 
defines general framework ownership composition inference encompasses wide range analyses different degrees cost precision 
implemented instantiation framework known andersen style points analysis java :10.1.1.25.1069
empirical results components 
experiments average examined fields account relationships identified compositions 
precision evaluation shows code base analysis achieves perfect precision misses composition relationships identified model 
results indicate precise identification relationships done simple inexpensive analysis easily incorporated reverse engineering tools sup java security system function class returned pointer internal array allowing clients modify array compromising security system 
port iterative development 
contributions propose implementation level ownership composition model captures notion composition modeling 
propose general analysis framework static inference ownership composition relationships accordance model analysis framework works incomplete programs 
empirical study evaluates instance framework 
results indicate precise identification composition relationships achieved relatively inexpensive analysis 

problem statement reverse engineering tools typically infer associations examining instance fields type code 
model association relationship field refined composition proven objects referred owned enclosing object 
suitable definition implementation level ownership composition goal design static analysis answers question set java classes component analyzed instance fields observe implementation level composition possible executions arbitrary client code built top classes 
output set fields relationship guaranteed composition arbitrary clients 
input analysis contains set cls interacting java classes 
classes denote java classes interfaces difference irrelevant purposes 
subset cls designated set accessible classes classes may accessed unknown client code outside cls 
client code access fields methods cls declared accessible class accessible fields methods referred boundary fields boundary methods 
sections describe ownership model notion implementation level composition 
section discusses constraints model allow precise detection ownership composition 
ownership model ownership model notion owners :10.1.1.23.2115:10.1.1.59.6498
essentially model proposed potter modifications allow precise handling popular object oriented patterns iterators composites factories 
model execution represented object graph shows access relationships run time objects instance field run time object edge object graph field refers point program execution 
require newly created objects appear object graph explicitly 
point creation new object stored new local variable change program semantics 
public class vector protected object data public vector int size data new object size public void addelement object int data public object elementat int return data public enumeration elements return new final class implements enumeration vector vector int count vector vector count object object data vector data int count count return data main vector new vector new addelement enumeration elements simplified vector iterator 
edge element array refers point program execution 
edge instance method constructor invoked receiver local variable refers static method called instance method constructor invoked local variable refers edge kind edge kind run time object accessed context iff edge object graph 
start program execution expressed special node root 
context root represents context main objects referenced static fields 
example executing main results object graph 
node vector corresponds object created new site line node object corresponds array created site line node corresponds iterator created site line node corresponds object created site line 
owners dominators model states owner object immediate dominator ob root vector data object vector original object graph root vector vector data object relaxed object graph object graphs 
ject graph 
model object owned enclosing vector object execution due access relationship temporary object 
model restrictive introduce relaxed object graph omits edges due certain temporary access relationships 
consider kinds temporary access relationships 
kind arises object created context immediately passed context relationship creating object new object temporary shown graph restrict ownership 
notion captures situations object created immediately returned return new method elements object created immediately passed context new new filename 
situation occurs popular object oriented design patterns factories decorators composites cases temporary relationship creating object newly created matter safety flexibility implementation intention design 
second kind temporary access relationships arises field read statements assigned passed implicit explicit argument returned 
notion captures situation arises iterators consider statement data vector data iterator objects temporary representation collections allows efficient access collection elements collection object scope 
accesses context due temporary access relationships edge shown relaxed object graph 
relaxed object graph execution main shown 
edge vector omitted due temporary access relationship kind edge object omitted due temporary access relationship node dominates node path root graph reaches node pass node root dominates nodes 
node immediately dominates node dominates node dominates dominates second kind 
owner immediate dominator relaxed object graph 
root owns vector vector owns object 
implementation level composition class cls field type declared type class interface array type 
ownership property holds possible executions arbitrary clients cls instance owns instances field refers 
consider case collection field objects stored field arrays instances standard java util collection classes java util vector 
instance owns corresponding instances stored collection composition relationship lowest common supertype instances stored collection regular association 
collection fields ownership property holds attribute association owned collection indicates collection owned enclosing object 
consider case collection field 
ownership property holds association composition regular association 
example 
consider package 
example classes standard java library package java util zip modifications simplify presentation better illustrate problem approach 
cls contains classes plus class 
accessible classes boundary methods public methods declared classes component accessed client code public methods declared classes 
clearly crc objects owned enclosing streams 
composition relationship class class crc field crc 
similarly composition relationship crc field crc 
regular association field entry easy construct client code top classes instances created objects leaked client code 
similarly regular association entry objects passed client code 
associations fields names entries regular associations attribute owned collection 
instance trivially owns hashtable instance 
owns vector instance vector instance referred context iterator recall example iterator local object owned enclosing object ensures vector instance dominated enclosing may accessed note java unique non trivial non object common supertype may exist 
detailed discussion appears 
package zip public class protected inf protected byte buf public inf int size inf inf buf new byte size public inf inf methods read fill contain instance calls inf public class extends private entry private crc crc new crc public super new true public crc reset inf reset entry null return null return entry private new code reads writes fields return public class extends private entry private vector entries new vector private hashtable names new hashtable private crc crc new crc public super new public void code reads writes fields names put name null 
entries addelement entry public void entry code reads writes fields crc reset entry null public void finish enumeration enum entries elements enum hasmoreelements 
sample package zip 
boundary 
discussion order allow precise detection composition employ constraint standard problem definitions require analysis incomplete programs 
consider executions invocation boundary method leave cls transitive callees cls 
particular consider possibility unknown subclasses instance calls cls potentially redirected unknown external code may affect composition inference 
example field may identified composition current set classes unknown subclass may override method overriding method may leak field passing static field 
cls augmented include classes provide component functionality classes transitively referenced 
experiments section included classes transitively referenced cls 
approach restricts analysis information currently known world information may invalidated new subclasses added cls 
approach change analysis worst case assumptions calls may enter unknown overriding methods 
case analysis overly conservative report fewer compositions 
believe useful restrict analysis known world course analysis user aware information valid set known classes 

class analysis object graph construction class analysis determines set objects variable object field may refer 
information wide variety uses software tools optimizing compilers 
class analysis information needed construct graph approximates possible object graphs happen arbitrary client code built top cls subsequently approximation object graph infer ownership composition relationships 
large body class analysis different trade offs cost precision :10.1.1.30.8177:10.1.1.136.9764:10.1.1.1.3636:10.1.1.25.1069
propose general framework class analysis encompasses large number analyses varying degrees cost precision 
framework instantiated relatively inexpensive imprecise analyzes rta relatively expensive precise analyses object sensitive points analysis call string context sensitive analysis 
object graph construction uses output class analysis precision cost constructing object graph subsequently inferring ownership composition depend precision cost underlying class analysis 
generalized class analysis java major dimensions precision class analysis flow sensitivity context sensitivity 
flow insensitive analyses take account flow control program points precise expensive flow sensitive analyses 
context sensitive analyses distinguish different calling contexts method precise expensive context insensitive ones 
note term context section describing notion object graph different meaning 
warranted distinction term section term current section 
sense object graph context refers receiver method intuition receiver controls method objects referenced method referenced receiver objects accessed context receiver object 
sense contextsensitive flow analysis context characterizes particular invocation method typically analysis keeps copy method relevant context invocation method 
popular context sensitivity schemes sequence enclosing call sites receiver object cartesian product set classes invocation site 
certain context sensitivity schemes flow analysis receiver object context outlined related meaning term sense object graph context flow analysis stands general concept purposes regard uses term independent 
rest carefully clarify term context 
dimensions precision include field sensitivity directionality call graph construction scheme representation scheme object naming scheme 
field sensitive analyses able distinguish flow different object fields field insensitive analyses merge flow different fields object field sensitive analyses precise field insensitive ones 
directional analyses referred propagation analyses process assignments direction bi directional analyses referred unification analyses process assignments directions example directional analysis processes assignment propagating set classes contrast bi directional analysis propagates set classes set classes respect call graph construction analysis may construct call graph fly propagating classes pre compute call graph inexpensive technique class hierarchy analysis cha 
typically analyses construct call graph fly significantly precise ones pre compute call graph 
dimension precision representation scheme 
dimension refers number analysis variables represent variables term sense object graph standard term ownership type literature similarly standard widely term flow analysis literature :10.1.1.23.2115
class hierarchy analysis cha examines declared type receiver variable class hierarchy computes set possible run time targets 
precise analyses variables precise ones variables merge information different variables 
typical representation scheme analysis variable variable program 
object naming scheme refers number object names represent heap objects 
precise analyses object names precise ones names merge distinct run time objects 
popular naming scheme represent object class 
popular naming scheme represent object allocation site 
note representation object naming schemes related context sensitivity degrees context sensitivity context sensitive analysis typically defines representation variables objects demonstrated may vary object naming schemes context insensitive analysis 
detailed examination wide variety class analyses dimensions precision 
consider analyses flow insensitive field sensitive directional construct call graph onthe fly 
analysis designer may vary context sensitivity scheme representation object naming scheme order achieve analysis desired precision cost 
generalized class analysis defined terms sets 
set set locals formals static fields type 
set set object allocation sites objects created allocation site si represented object name oi set contains instance fields program classes set cl contains program classes 
analysis parameters 
set represents set method contexts cm set contexts valid method example represent context insensitive analysis single context method program 
function set variable representatives defines representation scheme example typical context insensitive representation scheme uses analysis variable variable program 
expressed follows 
function oi set heap object representatives defines object naming scheme analysis example objects represented allocation site oi oi oi 
analysis solution pointsto graph edges represent may refer relationships edge points graph denoted means run time variable represented may refer object represented instance field objects rep resented edge denoted means run time field object represented may refer object represented represents array objects denoted shows element array si new foreach context cm add oi foreach context cm add foreach context cm add foreach context cm add si foreach context resolve resolve mj ret dispatch si add cm add add add generalized class analysis 
represented may refer run time object represented generalized class analysis algorithm propagates may refer relationships analyzing program statements 
majority statements effects analysis straight forward 
consider statement new 
analysis processes statement separately context enclosing method applies finds representative context similarly applies oi finds representative objects allocated site enclosing method invoked context subsequently creates points edge oi 
similarly statement analysis infers context enclosing method representative may refer objects representative refers 
virtual calls analysis performs resolution object current points set receiver variable constructs call graph fly current class analysis information 
finds runtime target mj class receiver object compile time target subsequently analysis finds new context target method mj context sensitivity scheme example cfa analysis distinguishes context enclosing call site new context call site cfa analysis distinguishes context enclosing call sites formed extracting call site attaching forming string enclosing call sites 
new context added set contexts cm analysis appropriately propagates values actuals formals return variable left hand side call account context caller context callee 
instances generalized analysis generalized analysis outlined ated existing class analyses ranging inexpensive rta analysis relatively expensive precise context sensitive analyses 
representative instantiations order increasing precision cost rta cfa andersen style points analysis object sensitive points analysis 
class analysis information output analysis construct object graph subsequently infer ownership compositions 
points graphs example computed cfa andersen style points analysis object sensitive points analysis discussed section shown 
rapid type analysis rta rta popular form class analysis primarily call graph construction 
intuitively starts main method program keeps set currently instantiated classes set currently reachable methods 
rta analyzes kinds program statements call sites allocation sites 
encounters call site currently reachable method examines potential edges cha edge records classes trigger edge 
class triggers edge set instantiated classes edge valid target method reachable 
rta encounters allocation site instantiates class adds set instantiated classes valid previously visited edges triggered order instantiate framework need define set contexts sets functions 
clearly rta context insensitive analysis single context 
rta regarded keeping single variable represents variables 
function 
rta represents objects class 
function class object class instantiated allocation site cl easy see instantiation generalized analysis equivalent rta 
cfa cfa known class analysis low cost precision spectrum propagates sets classes variables object fields 
context insensitive maintains set variable represents heap objects class 
example statement new analysis adds class set variable similarly statement analysis propagates set variable set variable framework cfa achieved instantiating class cl clearly cfa precise rta keeps separate analysis variable variable program terms dimensions uses representation rta 
consider analyses low cost precision spectrum analyses inspired style analyses 
analyses vary representation scheme singleton representation rta representation cfa keeping rta cfa precision analyses varies rta cfa 
instance referred mta maps variable representative valid enclosing method vm set program methods 
second instance referred cta maps variable representative valid enclosing class vc cl rta precise analysis followed cta mta cfa 
andersen style points analysis far considered analyses represent heap objects class 
group class analyses typically referred points analyses represents heap objects precisely usually allocation site 
points analysis java known flow context insensitive analysis :10.1.1.25.1069
uses analysis variable variable represents heap objects allocation site 
terms framework analysis heart implementation ownership composition inference believe suitable purpose 
object sensitive points analysis consider context sensitive points analysis referred object sensitive analysis 
object sensitivity instance method constructor analyzed separately object method constructor may invoked 
precisely method constructor may invoked run time objects represented object name object sensitive analysis maintains separate contextual version method constructor corresponds invocation context static methods analysis uses special context 
terms framework analysis defined follows 
set contexts equals set contexts set object allocation sites 
map context copy corresponds invocation enclosing method context case receiver object represented 
similarly map set context sensitive object names intuitively represents objects allocated site enclosing method invoked context virtual calls analysis resolves call heap object compile time target new context run time target mj set pointsto edge added points graph 
points edges added pointsto set order account flow actuals formals 
similarly edges added points set ret note analysis maintains context depth allocation site variables heap objects 
trivial define maintain contexts higher depths 
fragment class analysis class analyses typically designed program void main ph ze ph zis ph zos ph ze new ph zis new ph zos new ph ze ph ze ph zis ph zos ph ze ph zos ph zos finish placeholder main method zip 
analyses take input complete program produce points graphs reflect relationships entire program 
problem considered requires class analysis information partial program 
input set classes cls analysis needs construct approximate object graph valid possible executions arbitrary client code built top cls 
address problem general technique called fragment analysis due rountev 
fragment analysis works program fragment complete program case fragment set classes cls 
initially fragment analysis produces artificial main method serves placeholder client code written top cls 
intuitively artificial main simulates possible flow objects cls client code 
subsequently fragment analysis attaches main cls uses program class analysis engine compute points graph summarizes possible effects arbitrary client code 
fragment analysis approach wide variety class analyses purposes consider fragment analysis class analyses described previous section cfa andersen style points analysis object sensitive points analysis 
placeholder main method classes shown 
method contains variables types cls accessed client code 
statements represent different possible interactions involving cls order irrelevant program analysis flow insensitive 
method main invokes public methods classes cls designated accessible 
details fragment analysis discussed 
purposes analysis discuss object reachability property results computed fragment analysis 
consider client program built top cls execution program program satisfy constraints discussed section 
variable declared cls point execution start chain object leads heap object 
fragment analysis solution chain points edges starts representative leads object name represents run time object 
similar property holds declared outside cls 
case fragment analysis solution starting point chain representative variable main type property relevant ownership composition analysis described section points graph approximate possible object graphs possible accesses taken account 
illustrate analyses described section 
consider example figures 
allocation sites main method denoted names ze zis zos 
name byte corresponds allocation site class 
allocation sites class denoted names crc ze 
allocation sites class denoted vector hashtable crc 
addition consider allocation sites vector recall transitively reachable denoted object 
brevity relevant classes denoted similar abbreviated fashion example ze denote class zis denote zos denote 
points graphs computed code figures generalized class analysis algorithm instantiated cfa andersen style points analysis object sensitive points analysis shown 
variable denotes variable local variable method similarly stands stands stands vector addelement variable enum denotes finish enum 
heap object names underlined 
simplicity implicit parameters objects byte hashtable shown 
points graph computed generalized class analysis algorithm instantiated cfa shown 
case objects represented corresponding classes 
result single name crc objects allocation sites allocate crc objects similarly single name objects 
points graph computed generalized algorithm instantiated andersen style points analysis shown 
case separate object names crc crc allocation sites instantiate crc objects 
similarly object names ze ze allocation sites instantiate objects 
points graph computed generalized algorithm instantiated object sensitive pointsto analysis shown superscripts variables object names denote object contexts 
placeholder main method analyzed special static context single set variable placeholder variable single objet name object allocated main object names zis zos ze variables ph zos ph zis ph ze superscripts 
remaining object names crc zis ze zis denote objects created context zis annotated subscript zis 
simi ph zis ph zos ph ze crc crc zos entry ze entries entry vector vector data object enum points graph cfa analysis ph zis ph zos ph ze zis crc crc zis zos crc zos crc entry entry entries zos vector zis vector ze ze data zis zos vector object zos vector points graph object sensitive points analysis ph zis ph ze ph zos crc crc zis crc zos crc entry entry entries vector vector ze ze data object enum points graph andersen style points analysis vector enum zos points graphs computed fragment points analysis 
crc zos vector zos denote objects created context zos 
vector denotes iterator created vector object vector denotes data array created vector methods elements vector respectively 
variables zis denotes context copy enclosing method invoked receiver zis 
similarly zos zos enum zos denote context copies enum enclosing methods invoked receiver zos 
vector denotes context copy enclosing method addelement invoked receiver vector 

approximate object graph output fragment class analysis needed construct approximate object graph ag approximates possible run time object graphs happen client code built top cls 
subsequently ag ownership inference 
nodes ag taken set object names edges represent relationships 
outlines construction ag points graph pt algorithm parameterized class analysis 
recall set represents contexts invocation method purposes class analysis generalized class analysis algorithm may instantiated different context sensitivity schemes clarity consider empty contexts receiver object contexts 
analysis processes statement may contribute object graph edges appropriate context 
words analyses contextinsensitive rta cfa andersen style points analysis statement processed 
analyses context sensitive object sensitive points analysis example statement method processed context cm 
set cm denotes set object names represent contexts invocation method context note cm contexts sense object graph described section receivers invoked context clearly cm approximated class analysis information 
instance method constructor cm points set points set context copy implicit parameter context 
static method cm includes union points sets instance methods constructors may call directly sequence static calls includes root main may called main 
lines account edges due flow contexts callee contexts caller term context sense object graph 
input stmt set statements pt output ag foreach statement method new 
immediately passed immediately returned context 
assigned variable foreach context cm add hj cm hj pt ag add access edges due flow callees callers foreach statement method new foreach context cm add hi hj hi pt hj pt ag add access edges due flow callers callees foreach hi hj pt label hi hj ag foreach method new immediately passed immediately returned context 
foreach context cm add hi hi hi pt ag add self loop edges due access construction ag 
denotes power set ag initially empty 
example constructor call new edges added ag context call name representing newly created object 
similarly instance call new edges added context call returned object 
note newly constructed object immediately passed context new new immediately returned context return new iterator new edges added object contexts enclosing constructor call 
indirect read statements edges added variable assigned passed explicit implicit argument access instance array fields 
consistent definition relaxed object graph section 
lines account edges due flow contexts caller contexts callee 
example instance calls edges added object points set argument object points set receiver 
line labels edges appropriate field identifier line creates self loop due implicit parameter 
clarity omit detailed discussion static fields 
actual implementation creates edges root object points set static field case handled correctly algorithm algorithm section 
discuss reachability property approximate object graph 
consider client program built top cls execution program program satisfy constraints discussed section 
context sense object graph root heap object point execution start chain relaxed object graph leads heap object ag chain edges starts representative leads representative shows approximate object graphs computed code figures points graphs object names shown fields omitted clarity 
consider detail object graph resulting points graph computed andersen points analysis 
object graphs computed analogously reachability property holds 
analysis context insensitive statement processed algorithm empty context majority edges inference straight forward 
example edges root zis root zis root ze due constructor calls main edges zis crc zis ze due constructor calls class 
edge zos due call enum entries elements method finish 
edge vector due statement return new method elements note edge vector due statement 
edge root ze due statement ph ze ph zis 
main edges zos ze zos ze due statement ph zos ph ze main 
edges object ze object ze due flow statement data addelement 

identifying composition relationships propose novel analysis ownership inference 
analysis uses ag identify boundary subgraph rooted object name subgraph contains paths guaranteed represent flow ownership boundary edge appears boundary source edges labeled relationship identified composition 
ownership boundary procedure takes ag object name hi input outputs subgraph hi 
subgraph hi contains paths guaranteed represent flow ownership boundary instance represented hi 
denote run time time objects corresponding analysis representatives denoted hi hj precisely lemma 
heap object represented hi 
edge hj hi dominates represented dominates represented hj refers 
run time path representative hi dominates consider object graph 
boundary zos includes nodes zos crc vector object edges 
paths zos crc zos zos vector zos root zis crc zos crc zis zos crc ze vector object object graph cfa points graph root root ze ze vector crc zis zos crc zis zos object object graph andersen style points graph ze zis zos vector ze vector vector object object graph object sensitive points graph approximate object graphs computed algorithm 
vector zos vector object zos vector object 
easy see example run time zos vector zos dominates vector briefly outline algorithm correctness argument 
algorithm uses fact flows object object true handle due reachability property ag contains edges hk hi hk hj hi hj handle ag contains edges hi hk hi hj hk hj 
observation helps identify encapsulation precisely 
suppose running example input stream object created root denoted name zis 
relationship zis crc object represented edge zis crc 
naive algorithm may identify root dominator crc objects fail identify composition relationship crc 
fact crc object created dominated enclosing zis object hk hk handles zis crc zis handles hk crc crc object created zis object flow context 
algorithm builds boundary object name hi adding edges 
partitions edges reachable hi appropriate closure sets auxiliary procedure 
intuitively closure set edge hj contains edges hk hj transitive closure hi refer example closure set zos vector zos vector vector closure set zos ze zos ze vector ze object ze 
role parent set prt discussed ensure relevant paths hj stay boundary 
hi grows zero edge hi hj hk handles hi hj ii hk hi handles hk hj hk handle hj 
condition guaranteed check closure set hi hj forbidden second condition guaranteed check prt set hi hj empty checks performed line 
edge hi hj added empty boundary hi guaranteed hi object accesses hj object exclusively object handle 
examples edges zis crc zos crc 
clearly lemma holds case 
consider edge hj added hi line 
consider client program built top cls execution program program satisfy constraints discussed section 
run time object represented hi object dominated need examine hk referred may flow edge relaxed object graph 
dominated dominated object flows procedure hj hi input ag hj hi int output closure hi prt hi initialize wl closure hi prt hi mark hj add closure hi wl empty remove hj wl foreach hk hj hk hk reachable hi hk hj unmarked mark hk hj add wl closure hi add hk prt hi foreach hk hj hk hk hj unmarked mark hk hj add wl closure hi add hk prt hi procedure hi input ag hi output hi initialize foreach unmarked edge hj reachable hi hj oi foreach hi hj hk hk hi hk hj mark closure set hi hj forbidden empty prt hi closure hi forbidden add closure hi hi foreach closure hi remove rt remove rt oi closure hi ownership analysis :10.1.1.59.6498
conditions true 
handles may returned method invoked may passed argument method invoked 
dominates dominates case examined lines hk hj added worklist examined subsequent iteration loop order find representatives objects may flow addition hk hj added closure hi closure set hj 
second may flow handles clearly case hk hi hk prt set hj recall edge removed prt set added boundary lines 
may assume lemma holds hk hi dominates dominates referred dominates case examined lines appropriate hk hj added worklist closure set 
briefly illustrate algorithm running example 
consider boundary zis 
single closure set forbidden closure zis zis crc corresponding parent set prt zis edge zis crc added zis line 
consider boundary zos 
result lines closure sets forbidden closure zos zos crc closure zos zos closure zos zos vector vector closure zos vector object 
corresponding parent sets prt zos prt zos prt zos zos prt zos 
algorithm processes closure set adds edge zos crc zos 
adds second closure set edge zos boundary deletes edge third parent set 
third parent set empty zos vector vector added boundary 
edge vector object added boundary 
boundary graphs zis zis crc vector vector object zos zos crc zos vector zos vector object vector 
corollary lemma edge hi hj hi owns instances may refer 
edge labeled analysis identifies implementation level composition collection ownership 
pointed earlier major focus inference ownership compositions 
methodology handles inference relationships order keep focus discussed addressed 
analysis complexity discuss complexity analysis terms sets emphasize framework instance andersen style points analysis believe suitable purposes provides best trade analysis cost analysis precision purposes composition inference 
size program analyzed cls placeholder main number statements number object allocation sites number variables order reason complexity generalized class analysis consider standard set constraint solution procedure 
set constraint analyses solution divided constraint generation constraint resolution complexity clearly dominated constraint resolution 
example algorithm instantiated andersen style points analysis constraint generation processes statement generates constraints form vr vl constraint denotes points set flows points set 
solving andersen analysis requires propagating object names oi vr clearly dominates linear generation 
reason constraint resolution terms sets consider object names need propagated variables constraints form vi vi vj 
complexity propagation generalized analysis clearly constraint oi vj may discovered intermediate variables 
result cfa cl andersen style points analysis object sensitive points analysis note number classes cl order number classes cl substantially smaller number allocation sites practice 
complexity construction approximate object graph statements statement processed contexts statement algorithm performs due lines 
cfa cl andersen style points analysis object sensitive points analysis 
consider procedure 
code partitioning edges transitive closure hi closure sets lines examines edge edge performs edge hj may nodes hk hk hk hj examined lines similarly may nodes hk hk hk hj examined lines 
complexity lines 
loop adds edges boundary lines examines edge edge removed parent sets 
complexity lines 
conclude complexity analysis dominated computation boundary sets worst case 
andersen style points analysis complexity 

experimental study implemented instance framework particular considered class analysis points analysis object graph construction ownership inference 
believe instance framework suitable purposes inference compositions program fragments 
goal empirical study address questions 
analysis discover implementation level composition 
second imprecise analysis misses implementation level composition 
performed experiments java components listed table 
analysis implementation soot framework 
components standard library packages java text java util zip 
components described briefly columns table 
component contains set classes cls classes provide component functionality plus classes directly transitively referenced functionality classes 
number classes cls number classes implement component functionality shown column 
considered instance fields classes implement component functionality number column 
results applied andersen style points analysis object graph construction andersen style points analysis composition inference described earlier order determine fields accounted composition relationships 
column table shows fields column identified compositions column shows identified owned collections arrays standard java util collections 
average analysis reported compositions owned collections instance fields account representation exposed outside enclosing object 
analysis precision issue analysis precision crucial importance software tools 
analysis imprecise may report relationship classes composition reality collection owned reality owned analysis reports certain representation may exposed fact 
information useful may confuse user render tool unusable 
example user attempts ensure consistency code composition relationships uml design class diagrams imprecision mean large chunk code examined manually 
imprecision results waste human time analysis designers carefully precisely identify evaluate sources imprecision 
experiments examined fields identified compositions owned collections 
attempted prove possible write client code object stored field exposed owned enclosing object accordance ownership model section 
cases able prove exposure 
analysis achieves perfect precision 
field component date accounted case imprecision 
object stored field comes call method creates immediately returns date object 
date object stored flow enclosing object date objects created returned edges ag object representative date 
imprecision may resolved instance framework employs precise object naming 
case may distinguish date objects different call sites example cfa analysis distinguishes context enclosing call site produce precise results case target edge separate date object flow ownership inference algorithm correctly identify composition relationship field 
remains seen precise context sensitive points analysis result substantial benefits ownership composition analyses 
results indicate ownership model captures conceptual composition relationships appropriately encountered cases values private fields stored parts object representation 
model exclusive ownership model requires owned object referenced owner sufficient 
results show composition relationships occur 
analysis provide useful information reverse engineering component functionality classes fields compositions cls functionality owned collections analysis perfect analysis perfect gzip gzip io streams zip zip io streams checked io streams checksums text date date formatting number number formatting boundary iter 
boundaries text average table java components implementation level compositions 
tools 
important precise results obtained practical analysis combined running time points object graph construction composition inference analyses exceed seconds component executed mhz sun fire 
clearly threat validity results relatively small code base experiments 
components study representative program fragments results need confirmed components 
plan investigate impact framework instances especially context sensitive ones components 

related gogolla gu presents definitions identification algorithms implementation level association composition aggregation relationships 
focuses compositions differs definition implementation level composition identification algorithm 
definition composition exclusive ownership 
may sufficient model commonly patterns iterators decorators factories common situation instance fields refer owned objects temporarily accessed parts representation owner 
definition owners dominators model require exclusive relationship owner observed researchers model captures notion composition modeling :10.1.1.23.2115
identification algorithm may appropriate 
gu propose dynamic analysis point serious disadvantages 
dynamic analysis slow second requires complete program third results obtained may incomplete particular runs particular clients component 
gogolla dynamic analysis 
detection algorithm practical static analysis works incomplete programs produces solution valid unknown clients component 
addresses issue recovering associations containers reverse engineering tools typically loose association enclosing class class instances stored container field recall entries field vector type 
identification composition addressed papers 
ownership type systems disallow certain accesses object representation 
systems require type annotations typically include automatic inference algorithms empirical investigations 
contrast infer ownership automatically empirical study effectiveness approach believe analysis usefully incorporated software tools reverse engineering class diagrams java code 
type annotation inference analysis aware aldrich purposes alias understanding 
similarly owned annotation analysis able prove exclusive ownership majority cases infers alias parameters 
focuses different problem composition inference infers ownership model captures better notion composition modeling 
clarke tools checking confinement package class respectively 
define confinement rules tools check code conforms rules 
focuses different problem composition inference takes different approach semantic analysis points analysis 
believe analysis may appropriate confinement rules purposes identification object ownership composition example rules handle pseudo generic containers 
formalize uml relationships defining sets characteristics association aggregation composition address implementation level relationships problem reverse engineering 
contrast consider relationships propose methodology reverse engineering empirical investigation 

analysis identifies composition relationships java components 
define implementation level composition model static analysis framework inference composition relationships incomplete programs 
experimental study indicates ownership model captures notion composition modeling ii implementation level compositions occur compositions identified relatively simple inexpensive analysis 
clearly definitive drawn limited experiments 
plan focus empirical investigation placing special emphasis framework instances context sensitive class analyses 

author grateful rountev providing component data ase reviewers valuable comments improved enormously 

agesen 
cartesian product algorithm simple precise type inference parametric polymorphism 
european conference object oriented programming pages 
aldrich chambers 
alias annotations program understanding 
conference object oriented programming systems languages applications pages 
bacon sweeney 
fast static analysis virtual function calls 
conference object oriented programming systems languages applications pages 
henderson sellers parc 

formalization part relationship unified modeling language 
ieee transaction software engineering 
qian hendren 
points analysis bdd conference programming language design implementation pages 
boyapati liskov shrira 
ownership types object encapsulation 
symposium principles programming languages pages 

henderson sellers parc france 
improving uml metamodel rigorously specify aggregation composition 
international conference object oriented information systems pages 
clarke drossopoulou :10.1.1.59.6498
ownership encapsulation disjointness type effect 
conference object oriented programming systems languages applications pages 
clarke potter noble 
ownership types flexible alias protection 
conference object oriented programming systems languages applications pages 
clarke richmond noble 
saving world bad beans deployment time 
conference object oriented programming systems languages applications pages 
dean grove chambers 
optimizations object oriented programs static class hierarchy analysis 
european conference object oriented programming pages 
hndrich foster su aiken 
partial online cycle elimination inclusion constraint graphs 
conference programming language design implementation pages 
fowler 
uml distilled third edition 
addison wesley 
gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley 
gosling joy steele bracha 
java language specification 
addison wesley nd edition 
palsberg vitek 
encapsulating objects confined types 
conference object oriented programming systems languages applications pages 
grove chambers 
call graph construction object oriented languages 
acm transactions programming languages systems nov 
grove defouw dean chambers 
call graph construction object oriented languages 
conference object oriented programming systems languages applications pages 

gu 
recovering binary class relationships putting uml cake 
conference object oriented programming systems languages applications pages 
hind 
pointer analysis haven solved problem 
workshop program analysis software tools engineering pages 
jackson 
lightweight extraction object models bytecode 
ieee transaction software engineering 
gogolla 
application uml associations design recovery 
working conference reverse engineering pages 

applying uml patterns 
prentice hall nd edition 
hendren 
scaling java points analysis spark 
international conference compiler construction pages 
liang harrold 
extending evaluating flow insensitive context insensitive points analyses java 
workshop program analysis software tools engineering pages 
milanova 
precise identification composition relationships uml class diagrams 
technical report rpi dcs rensselaer polytechnic institute 
milanova rountev ryder 
parameterized object sensitivity points side effect analyses java 
international symposium software testing analysis pages 
milanova rountev ryder 
parameterized object sensitivity points analysis java 
acm transactions software engineering methodology 
noble vitek potter 
flexible alias protection 
european conference object oriented programming pages 
palsberg schwartzbach 
object oriented type inference 
conference object oriented programming systems languages applications pages 
plevyak chien 
precise concrete type inference object oriented languages 
conference object oriented programming systems languages applications pages 
potter noble clarke 
ins outs objects 
australian software engineering conference pages 
rountev 
dataflow analysis software fragments 
phd thesis rutgers university 
rountev 
precise identification side effect free methods 
international conference software maintenance pages 
rountev milanova ryder :10.1.1.25.1069
points analysis java annotated constraints 
conference object oriented programming systems languages applications pages 
rountev milanova ryder 
fragment class analysis testing polymorphism java 
ieee transaction software engineering june 
ruf 
effective synchronization removal java 
conference programming language design implementation pages 
rumbaugh jacobson booch 
unified modeling language manual 
addison wesley nd edition 
ryder 
dimensions precision analysis object oriented languages 
international conference compiler construction pages 
sharir pnueli 
approaches interprocedural data flow analysis 
muchnick jones editors program flow analysis theory applications pages 
prentice hall 
snelting 
points java general framework comparison 
technical report passau sept 
su hndrich aiken 
projection merging reducing redundancies inclusion constraint graphs 
symposium principles programming languages pages 
sundaresan hendren rai lam gagnon godin 
practical virtual method call resolution java 
conference object oriented programming systems languages applications pages 
tip palsberg 
scalable propagation call graph construction algorithms 
conference object oriented programming systems languages applications pages 
tonella 
reverse engineering uml class diagram code presence weakly typed containers 
international conference software maintenance pages 
vall rai gagnon hendren lam sundaresan 
optimizing java bytecode soot framework feasible 
international conference compiler construction lncs pages 
whaley lam 
efficient inclusion points analysis strictly typed languages 
static analysis symposium pages 
whaley lam 
cloning context sensitive pointer alias analysis binary decision diagrams 
conference programming language design implementation pages 
