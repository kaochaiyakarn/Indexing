computational approach reflective meta reasoning languages bindings aleksey nogin alexei kopylov xin yu jason hickey department computer science california institute technology pasadena ca nogin kopylov cs caltech edu september foundation computational meta theory languages bindings implemented computer aided formal reasoning environment 
theory provides ability reason abstractly operators languages open ended languages classes languages theory ideas higher order syntax appropriate induction principle parameterized language set operators 
approach bound free variables treated uniformly uniform treatment extends naturally variable length bindings 
implementation reflective natural mapping meta language theorem prover object language theory 
object language substitution operation mapped meta language substitution need defined recursively 
approach require designing custom type theory describe implementation foundational theory general purpose type theory 
fully implemented metaprl theorem prover pre existing nuprl martin style computational type theory 
implementation lay outline framework programming language experimentation exploration general reflective reasoning framework 
includes short survey existing approaches syntactic reflection 
reflection generally reflection ability system self aware way 
specifically reflection mean property computational formal system able access internalize properties 
areas computer science reflection plays play major role 
exploring properties programming languages languages realizes languages kinds properties semantic properties meaning language constructs express syntactic properties language 
extended version accepted merlin workshop september estonia 
merlin copyright acm 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings suppose example exploring language contains arithmetic operations 
particular language write polynomials 
case number roots polynomial semantic property valuation polynomial 
hand degree polynomial considered example syntactic property natural way define property expression represents polynomial 
course syntactic properties semantic consequences especially important 
example number roots polynomial bounded degree 
area reflection plays important role run time code generation cases language supports run time code generation essentially reflective capable manipulating syntax 
order reason run time code generation express semantics properties natural reasoning system reflective 
different flavors reflection 
syntactic reflection seen examples ability system internalize syntax just flavors 
important kind reflection logical reflection ability reasoning system logic internalize reason logical properties 
example logical reflection reasoning knowledge result reasoning knowledge knowledge logic knowledge naturally reflective art 
cases natural reflection iterated 
case syntactic reflection care syntax language syntax expressing syntax syntax expressing syntax expressing syntax forth 
case logic knowledge natural iterations form know knows know 
formal system reason properties programming languages iterated reflection magnifies power system making natural reason just individual languages classes languages language schemas 
generally reflection adds lot additional power formal reasoning system gs art 
particular known mos em par reflection allows super exponential reduction size certain proofs 
addition reflection useful mechanism implementing proof search algorithms acu cfw 
see har survey reflection theorem proving 
uniform reflection framework examples previous section ad hoc ways achieving specific benefits specific flavor reflection 
aims creating unifying reflective framework allow achieving benefits uniform manner having reinvent re implement basic reflective methodology time 
believe framework increase power formal reasoning tools may invaluable tool exploring properties novel programming languages analyzing run time code generation formalizing logics knowledge 
establishes foundation development framework new approach reflective meta reasoning languages bindings 
theory syntax natural way provides higher order syntax hoas approach bindings de bruijn style approach bindings easy natural translation provides uniform hoas style approach bound free variables extends naturally variable length vectors binders permits meta reasoning languages particular operators languages open ended languages classes languages class objects reasoned abstractly concretely comes natural induction principle syntax parameterized language aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings provides natural mapping object syntax meta syntax free exotic terms allows mapping object level substitution operation directly meta level reduction fully derived pre existing type theory theorem prover designed serve foundation general reflective reasoning framework theorem prover designed serve foundation programming language experimentation framework 
structured follows 
inherits large number ideas previous efforts start section brief survey existing techniques formal reasoning syntax 
section outline approach reasoning syntax section formal account theory martin style computational type theory cab implementation account metaprl theorem prover hic hic hic hnc 
section outline plan building uniform reflection framework syntactic reflection 
section resume discussion related started section 
notation terminology believe approach reasoning syntax fairly general rely special features theorem prover 
implement theory metaprl introduce basic knowledge metaprl terms 
metaprl term consists 
operator name sum unique name indicating logic component term 
list parameters representing constant values 
set subterms possible variable bindings 
syntax describe terms nuprl definition operator name pn parameters vm tm subterms addition metaprl meta syntax somewhat similar higher order syntax pfenning elliott pe 
metaprl uses second order variables style huet lang hl describe term schemas 
example second order variable arity schema stands arbitrary term top level operator 
meta syntax requires time binding occurrence explicitly specified schema corresponding bound occurrences specified 
requirement easy specify free variable restrictions example second order meta variable arity schema stands arbitrary term top level operator body free occurrences variable bound 
particular schema matches term term addition meta language allows specifying certain term transformations including implicit substitution specifications 
example beta reduction transformation may specified schema substitution specified implicitly 
second order notation denote arbitrary terms stated write mean arbitrary term form term containing concrete second order variable named 
lf hhp assume object level variables variables language syntax expressing directly mapped meta theory variables variable language aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings express syntax 
similarly assume object level binding structure mapped meta level binding structure 
words object level notion binding bound occurrence subset meta language 
consider equal terms object level meta level identical assume substitution avoids capture renaming 
sequent schema language nh contains number advanced features addition outlined 
purposes presentation basic features outlined sufficient 
previous models reflection del reflection prove famous incompleteness theorem 
express arithmetic arithmetic assigned unique number del number arithmetic formula 
del number formula essentially numeric code string symbols represent formula 
modern version del approach aitken ac acu con implement reflection nuprl theorem prover cab ace 
large part effort essentially reimplementation core nuprl prover inside nuprl logical theory 
del approach variations including aitken general mechanism formalizing logical theory applied formalizing logical theory 
convenient reasoning reflection purposes turns extremely impractical 
formalizing theory generic means identity theory formalized formalization happens obfuscated impossible relate reflected theory back original 
second theorem proving system implements logical theory question creating completely new implementation logical theory inside tedious redundant effort 
practical disadvantage del numbers approach tends blow size formulas iterated reflection cause blow iterated making exponential worse 
practical approach programming languages lisp scheme 
common solution implementation expose internal syntax representation user level code quote constructor quote prevents evaluation expression 
problems outlined solved instantly approach blow repetition structure definitions need verifying reflected part equivalent original implementation identical 
scheme implementations take eval function internal function evaluating scheme expression exposed user level smith smi showed approach achieve infinite tower processors 
similar language quotation antiquotation operators introduced gmo 
approach violates congruence property respect computation terms computationally equal substituted context 
instance equal expressions syntactically different substitute expression quote 
congruence property essential logical reasoning systems including nuprl system mentioned metaprl system hnc group uses 
possible way expose internal syntax violating congruence property socalled quoted shifted operators aa bar bar quoting expression 
operator op original language add quoted operator denoted op represent term built operator op 
example original language contains constant presumably represents number reflected language stand term denotes expression 
generally quoted operator arity original operator defined syntactic terms semantic objects 
instance binary operator numbers binary operator terms 
syntactic terms stand expressions respectively new syntactic term stands expression 
quotation expression 
aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings general formedness typing rule quoted operator term 
tn term op tn term term type terms 
note quotations iterated arbitrarily times allowing quote quoted terms 
instance stands term denotes term denotes numeral 
problems arise quoting expressions contain binding variables 
example quotation possible ways answering question 
commonly approach pe dh dfh acm acm logical frameworks elf pfe lf hhp isabelle pn pau construct object logic concrete operator type term term term var term term 
approach quoted look quoted look 
note examples quoted terms syntactic quoted operator semantic operator 
exotic terms 
na implementations approach suffer known problem exotic terms dh dfh 
issue general allow applying operator arbitrary function maps terms terms variables terms expect result application proper reflected term 
consider example term relatively easy see real syntactic term obtained quoting actual term 
comparison consider quotation 
ensure denotes real term exotic 
equal result quoting actual term object language 
possibility require substitution function words equal expression form composed entirely term constructors quoted operators destructors case analysis operator example prohibited 
number approaches enforcing restriction 
usage logical frameworks restricted function spaces pe hhp terms may contain constructors 
formalize larger type include exotic terms define recursively predicate describing validity formedness term dh dfh removing exotic terms consideration 
approach create specialized type theory combines idea restricted function spaces modal type operator dps dl dl 
case analysis disallowed objects pure type allowed objects special type allows expressing restricted function space unrestricted single type theory 
way regarding problem exotic terms caused attempt give semantic definition primarily syntactic property 
syntax oriented approach barzilay ba bac bar 
barzilay approach quoted version operator introduces binding shape number subterms binding structure original variables binding bound occurrences unaffected quotation 
instance quotation just advantages approach include approach simple clear 
quoted terms structure original ones inheriting lot properties object syntax 
aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings approaches equivalence relation quoted terms inherited free 
example automatically considered term 
substitution easy need re implement substitution renames binding variables avoid capture free variables substitution original language 
prune exotic terms barzilay says valid term substitution function 
demonstrates possible formalize notion purely syntactical fashion 
setting general formedness rule quoted terms bindings xk zl op xk zl term xn proposition substitution function variables xn words syntactic version predicate dh dfh 
proposition defined syntactically rules xn 
xi xn yk xn zl xn op yk zl approach operators essentially untyped nuprl type theory computational properties untyped terms core semantics types added top untyped computational system 
recursive definition structural induction principle 
difficulty shared straightforward implementations term term term approach barzilay problem recursively defining term type 
want define term type smallest set satisfying rules 
note rule rule monotonic sense xk depends non monotonically term type 
example say term check substitution function means term term 
need define type term produces logical circle 
type term term term hard formulate structural induction principle terms built term constructor 
variable length lists binders 
barzilay approach number considered separate operator way quantify way express variable length lists binders 
issue expressing unbounded length lists binders common approaches 
meta reasoning 
difficulty especially apparent barzilay approach allows reasoning concrete operators concrete languages 
approach provide ability reason operators abstractly particular way state prove meta theorems quantify operators languages classes languages 
higher order syntax inductive definitions possible solve problems outlined previous section return discussion solutions section desire avoid difficulties start 
propose natural model reflection manages difficulties 
show give simple recursive definition terms binding variables allow construction exotic terms allow structural induction terms 
section provide conceptual overview approach details section 
aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings bound terms key ideas approach deal terms containing free variables 
extend free variables principle variable names really matter 
fact model free variables bindings arbitrarily renamed 
write bterm xn term variables xn 
example term term bterm considered variables bterm considered variables free occurrences xi considered bound bterm xn equal bterm expressions considered identical 
bterm necessarily formed 
define type terms way eliminate exotic terms 
consider example definition lambda terms 
example define set reflected lambda terms smallest set bterm xn xi lambda term variable bterm xn xn lambda term lambda term abstraction bterm xn xn bterm xn bterm xn lambda terms lambda term application 
bterm xn apply way understood explicit coding barzilay substitution functions 
basic definitions quite similar 
notion similar local variable contexts 
terminology proceed need define terminology 
definition change notion subterm subterms bterm 
example immediate subterms bterm bterm bterm immediate subterm bterm bterm 
definition call number outer binders bterm expression binding depth 
binding depth bterm bterm xn definition rest notion operator shape 
shape operator list natural numbers stating new binders operator introduces corresponding subterm 
length shape list arity operator 
example shape operator shape operator 
mapping operators shapes called binding signature language plo 
definition op operator shape dn btl list bm 
say btl compatible op depth 

binding depth bterm aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings operators expressions form bterm op express syntax concrete operators 
words expression form contains specific constant operator op 
reason operators abstractly particular want possible variables type op quantified manner operator constants 
order address explicit term constructors addition bterm op constants 
expression mk bterm op btl op encoding quoted operator op stands bterm binding depth operator op subterms btl 
mk bterm op bterm xn bterm xn yk tk yk nil bterm xn op yk tk yk 
nil empty list list cons operator expression bn nil represents concrete list bn 
note know shape operator op know mk bterm expression formed specifically know btl compatible op depth normally possible deduce value difference binding depth element list btl corresponding element shape op list 
reasons supplying explicitly btl empty words arity op value deduced way needs supplied 
consider arity operators special case results significant loss uniformity 
know mk bterm expression necessarily formed see useful allow happen lot definitions proofs greatly simplified binding depth mk bterm expressions explicitly specified 
mk bterm constructor similar constructors introduced easy reason abstractly operators 
second argument mk bterm arbitrary expression just constant 
cost making certain definitions slightly complicated 
example notion compatible op depth important part theory need explicitly formalized 
small price pay ability reason abstractly operators easily extends reasoning abstractly languages classes languages forth 
inductively defining type formed equivalent approaches inductively defining general type set formed 
follows idea example bterm xn xi formed bterm mk bterm op btl formed bterm op formed quoted operator btl list formed compatible op depth denote bterm xl zr var restate base case definition var arbitrary natural numbers formed bterm 
apparent definition lot similarities de bruijn style indexing variables db 
call numbers left right indices variable var 
possible provide alternate definition closer pure hoas bnd formed substitution function formed bterm bnd operation increases binding depth adding list outer binders 
mk term op btl op formed quoted operator btl list formed compatible op depth formed bterm binding depth 
aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings better capturing idea hoas definition easier express reflective correspondence meta syntax syntax express theory syntax includes operators mk bterm bnd meta meta syntax syntax express theory syntax underlying theory words syntax includes second order notations 
provided define subst bt operation compute result substituting closed term outer binder bterm bt state subst bnd literal second order variables 
words state substitution operator subst implicit second order substitution meta meta language equivalent 
downside alternate definition requires defining notion substitution function 
approach try combine advantages approaches outlined 
section theory includes hoas style operations bnd mk term de bruijn style ones var mk bterm 
theory allows deriving equivalence 
theory definition basic syntactic operations hoas style operators recursive definition type wellformed syntax de bruijn style operations 
theory includes support variable length lists binders 
formal implementation theorem prover section describe foundations theory formally defined derived computational type theory metaprl theorem prover 
brevity slightly simplified version implementation full details available appendix 
computations types heavy usage fact type theory allows define computations stating upfront knowing relevant types 
nuprl style type theories dubbed untyped type theory may define arbitrary recursive functions potentially nonterminating ones 
proving function belongs particular type may prove termination 
see semantics justifies approach 
formal definition syntax terms consists parts definition untyped term constructors term operations includes hoas style operations de bruijn style operations 
turns establish reduction properties explicitly giving types operations 
definition type terms 
define type terms type contains terms legitimately constructed term constructors 
hoas constructors core term syntax definition basic hoas style constructors bnd meant represent term free variable intended semantics explicit bnd considered formed substitution function 
aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings internally bnd implemented simply pair definition truly internal prove properties destructors outside section section 
mk term op ts pairs op ts 
intended usage operation explicit represents closed term bterm binding depth operator op subterms ts 
considered formed op operator ts list terms compatible op depth 
example mk term bnd internally mk term op ts implemented nested pair op ts definition outside section 
implement destructors subst bt meant represent result substituting term variable bterm bt 
internally subst bt defined simply application bt bt second element pair bt 
derive property substitution operation subst bnd computational equality relation may absolutely arbitrary 
derivation place internal definition subst bt 
note equality exactly reflective property substitution design goals theory 
weak dest bt op ts mkt case op ts designed provide way find bt bnd mk term op ts extract op ts case 
rest pretty printed form weak dest match bt bnd mk term op ts mkt case op ts 
internally defined bt mkt case bt bt 
internal definition derive properties weak dest match bnd bnd mk term op ts mkt case op ts match mk term op ts bnd mkt case op ts mk term mkt case vector hoas operations mentioned section approaches reasoning syntax hard impossible express arbitrary length lists binders 
approach address challenge allowing operators single binding meta language stands list object level bindings 
particular allow representing bnd bnd 
bnd xn xn nth nth nth th element list function 
define vector style operations nuprl style type theories computational equality relation called equality denoted finest grained equality relation theory 
true may replaced arbitrary context 
examples computational equality include beta reduction arithmetical equalities definitional equality abstraction considered computationally equal definition 
aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings represents telescope nested bnd operations 
defined induction natural number follows nil bnd introduce simplified notation free occurrences bt ts vector substitution operation meant represent result simultaneous substitution terms ts list ts variables bterm bt length list 
bt ts defined induction list ts follows bt nil bt bt ts subst bt ts derived properties operations bnd hd list 
list bt hd list head operation list append operation list type arbitrary lists elements list belong particular type type natural numbers variables explicitly constrained specific type stand arbitrary expressions 
equivalence allows merging splitting vector bnd operations 
equivalence vector variant equivalence 
equivalence similar equivalence applied context require member special type 
de bruijn style operations hoas constructors defined previous sections define de bruijn style constructors 
var defined bnd 
easy see definition corresponds informal bterm xl zr definition section 
mk bterm op ts meant compute bterm binding depth operator op ts subterms 
operation defined induction natural number follows mk bterm op ts mk term op ts mk bterm op ts bnd mk bterm op map subst ts note ts list bnd expressions intended usage mk bterm operation bnd map subst ts effect stripping outer bnd members ts list moving single merged bnd outside 
presentation inductive definitions slightly simplified omitting minor technical details 
see appendix complete details 
aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings define number de bruijn style destructors operations compute various de characteristics bterm 
var mk bterm constructors defined terms hoas constructors destructors defined terms hoas operations 
definitions far straightforward 
important emphasize tricky definitions needed establish basic properties operations defined 
basic theory complete raise level abstraction usage theory require definitions aware definitions performing similar tricks 
bdepth computes binding depth term defined recursively combinator match bnd subst mk term mk term effect recursive function strips outer binders bterm substitution note arbitrary mk bterm expression second argument substitution function arguments mk bterm correct type counts number times needs outermost mk term exposed 
derive properties bdepth bdepth var bdepth mk bterm op ts note equivalence requires correct type op ts may arbitrary 
bdepth operator needed defining type term formed point able express correct type ts 
left designed compute left index var expression 
defined match bnd subst mk term mk term effect recursive function substitutes mk term binding mk term second mk term forth 
binders stripped mk term exposed index looking 
note intentionally supply mk term argument wrong type op avoided definition significantly complicated 
expected derive left var 
right computes right index var expression 
trivial define terms previous operators right bdepth left 
get op op operation definition similar left 
get op mk bterm op ts op op get op var op op aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings subterms designed recover argument mk bterm expression 
definition technical complicated omit see appendix details 
main property subterms operation derive btl list 
subterms mk bterm op btl map btl right hand side equivalence quite plain btl hoped see 
btl list binding depths necessarily case formed mk bterm op btl equivalence allow simplifying right hand side desired btl 
operators basic theory exact representation details operators essential define type operators op abstractly 
require operators decidable equality exist function type op nlist computes operators shapes 
shape function bdepth function section trivial formalize ts compatible op depth predicate definition 
denote predicate shape compat op ts define type terms shape op btl btl bdepth nth btl nth shape op section define type terms formed term type terms constructed de bruijn constructors section 
term type contains expressions forms var natural numbers mk bterm op ts natural number operator op list terms ts compatible op depth term type defined fixpoint function types types iter image dom mk image type constructor image type formed formed type free variables dom type defined op op ts list shape compat op ts mk presumably member type dom defined fixpoint iter reached defining match inl var inr op ts mk bterm op ts 
aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings term void empty type iter term derive intended rules term type var term op op ts termlist shape compat op ts mk bterm op ts term structural induction principle derived term type 
show prove property holds term sufficient prove base case holds variables var holds natural numbers induction step mk bterm op ts true natural number operator op list terms ts compatible op depth provided true element list ts 
note type terms variables corresponds closed terms may trivially defined term type subset type constructor term bdepth 
sections basic theory syntax fully implemented theorem prover 
mentioned approach natural expressive provides foundation reflective reasoning classes languages logics 
consider theory step building user accessible uniform reflection framework user accessible uniform framework programming language reasoning experimentation tasks similar ones challenge abf performed easily naturally 
section provide outline plans building frameworks top basic syntactic theory 
higher level user interface obvious shortcoming theory sections provides basic low level operations bnd var subterms presents low level account syntax way fail away details irrelevant user 
address problem planning provide user interface functionality capable mapping high level concepts low level ones 
particular going provide interface allow instantiating general theorems specific collections operators specific languages 
user able write reflect language apply system create components outlined example create definition type language apply reflected lambda terms language general definition language list operators aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings state derive rules type state derive elimination rule type induction principle 
planning support complicated language declarations int apply cause system create mutually recursive type definitions appropriate rules 
planning support pattern bindings needed natural encoding ml pattern matching sketched challenge abf 
far underlying theory goes believe mechanisms similar vector bindings section sufficient 
dereferencing quoted terms barzilay quoted operator approach easy define dereferencing operator unq 
syntactic term unq value represented definition op tn unq op unq tn unq 
instance unq 
order define terms bindings need introduce guard operation unq arbitrary expression unq defined follows op xk xk zl zl unq op xk xk unq zl zl unq 
example unq unq unq unq unquote operation establishes identity original syntax reflected syntax making true reflection 
note type theory ensures particular terminating functions may shown belong function type keep unq operation introducing logical paradoxes 
notion quoted operators fully open ended new language added system automatically get unq operation newly introduced operators 
logical reflection defining syntactic reflection easy define logical reflection 
consider proof system logical reflection trivial quotation proposition regard unq meaning true 
normal modal rules unq modality trivially derivable 
example modus ponens unq unq unq trivially true evaluate unq remember unq unq unq definition unq get obvious tautology unq unq unq unq 
order consider closed proof system words want able induction derivations need define provability predicate system 
planning provide user interface functionality allow users describe set proof rules system generate appropriate proof predicate definitions derive appropriate rules style similar outlined section case language descriptions 
obviously proper argument 
proper argument outside scope particular 
aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings related section discussed number approaches consider inheriting 
revisit mention related efforts 
lot common hoas implemented coq despeyroux hirschowitz dh 
cases general space terms include exotic ones restricted recursive manner 
cases higher order analogs order de bruijn operators defined part formedness specification terms 
despeyroux hirschowitz functions infinite lists variables define open terms similar vector bindings 
number significant differences 
approach sufficiently syntactical allows eliminating exotic terms extensionally equal formed ones semantic approach dh dfh accept exotic terms solution problem consider object term represented equivalence class extensionally equal terms generally dh states problem extensionality recurrent lemmas establish identity just equality avoiding issues extensional equality 
implementation substitution object terms mapped directly reduction despeyroux dfh define recursively 
addition provide uniform approach free bound variables naturally extends variable length vector bindings 
approach quite different modal calculus dps dl dl similarities intuition 
despeyroux dps says intuitively interpret type closed objects type iterate distinguish cases closed objects constructors statically known provided intuition approach part canonical model nuprl type theory type mapped equivalence relations closed terms type 
gordon melham gm define type terms quotient type terms concrete binding variables equivalence 
michael builds replacing certain variable freshness requirements variable swapping 
approach number attractive properties believe level abstraction provided hoas style approaches hoas style convenient accessible 
ambler crole acm combined hoas induction principle approach sense opposite 
define hoas operators top de bruijn definition terms higher order pattern matching 
acm described notion terms infinite context quite similar approach vector binding 
vector bindings section finite length exact approach infinite length vectors 
acknowledgments authors grateful eli barzilay ideas inspiration lead 
grateful comments early draft 
grateful merlin anonymous reviewers thorough fair feedback helpful suggestions 
appendix appendix printout relevant metaprl theories generated automatically metaprl system 
metaprl notation appendix partially explained nh 
rules rewrites marked derived provide measure proof size aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings 
marker means rule rewrite axiom 
operators forms 
itt hoas base module hoas base module defines basic operations higher order syntax hoas 
parents theory fun union prod terms expression represents bound term bterm potentially free variable order formed substitution function 
op subterms expression represents term operator op subterms subterms 
order formed length subterms equal arity op subterm binding depth number outer binds equal corresponding number shape op remember shape operator list natural numbers length list operator arity 
expression bt represents result substituting binding bt 
weak dest bterm operator allows testing term bind mk term get op subterms case 
bind itt hoas base bind displayed inl mk term itt hoas base mk term op subterms displayed op subterms inr op subterms hoas base illegal subst displayed illegal subst subst itt hoas base subst bt displayed bt match bt inl inr opt illegal subst wdt itt hoas base weak dest bterm bt bind case op sbt 
case op sbt displayed match bt bind case aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings op sbt case op sbt match bt inl bind case inr opt op sbt opt case op sbt rewrites subst reduce bt bt wdt bind reduce match bind case op sbt case op sbt bind case wdt mk term reduce match op subterms bind case sbt case sbt case op subterms itt hoas vector module hoas vector module defines vector bindings extensions basic itt hoas 
parents hoas base nat list fun terms expression natural number represents telescope nested bind operations 
stands 

provide input form bind important case vector binding introduces variable occur freely bterm body 
bt expression represents result substituting term st binding bterm bt 
bt ltl expression represents result simultaneous substitution terms tl tl list tl bindings bterm bt 
aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings itt hoas vector bind displayed ind ind ind ind ind itt hoas vector subst bt displayed bt ind ind ind bt bt ind bt ind bt bt itt hoas vector bt tl displayed bt ltl match tl bt define itt hoas vector bind displayed bind rewrites base reduce reduce hd bind sum reduce base reduce bt bt case reduce bt bt subst reduce bt bt bind bt bt bt insert aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings reduce bt bt insert base reduce bt bt step reduce bt lh bt lt step reduce bt lh bt lt step reduce bt lh bt lt reduce list bt ll bt list bt ll bt bsb reduce bt lv bt bsb reduce bt lv bt bt lv bt lv itt hoas debruijn module itt hoas debruijn module defines mapping de bruijn representation syntax hoas 
parents hoas base hoas vector nat list aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings terms de bruijn representation syntax de bruijn representation bound terms consists operators 
var left right represents variable bterm left index left right index right 
represent term 
left 
right 
mk bterm op btl represents compound term depth words mk bterm op bt bt op bt bt 
var itt hoas debruijn var left right displayed var left right left right mk bterm itt hoas debruijn mk bterm op btl displayed mk bterm op btl ind ind ind btl op btl ind btl ind map bt bt btl btl basic operations syntax bt binding depth number outer bindings bterm bt 
way computing 
op bt op returns bt operator bt mk bterm returns op bt variable 
subterms bt computes subterms bterm bt 
bdepth itt hoas debruijn bdepth bt displayed bt bt match bt bt bt left itt hoas debruijn left bt displayed bt bt match bt bt op op bt right itt hoas debruijn right bt displayed bt bt bt get op itt hoas debruijn get op bt op displayed op bt op bt match bt bt op op op bt hoas debruijn displayed ound aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings define get op itt hoas debruijn get op bt displayed get op bt op bt ound num subterms itt hoas debruijn num subterms bt displayed num subterms bt bt match bt bt btl btl bt nth subterm itt hoas debruijn nth subterm bt displayed nth subterm bt bt match bt bt btl bt subterms itt hoas debruijn subterms bt displayed subterms bt list un nth subterm bt num subterms bt rewrites mk bterm base reduce mk bterm op btl op btl mk bterm step reduce mk bterm op btl mk bterm op map bt bt btl mk bterm empty reduce mk bterm op op bdepth mk term reduce op btl bdepth bind reduce bdepth var reduce dvar bdepth mk bterm reduce bterm op btl var reduce op op aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings reduce bterm op btl op op subterms id reduce btl list num subterms mk bterm op btl btl subterm id reduce nth subterm mk bterm op list un lv id reduce btl list bterm op btl map bt bt lv btl id reduce lvar id reduce var reduce var var reduce var var reduce bdepth mk bterm bdepth op btl mk bterm bdepth op map bt bt btl var reduce var var reduce btl list map bt bt map bt bt btl btl reduce bdepth btl list aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings mk bterm bdepth op btl mk bterm bdepth op map bt bt btl itt hoas operator module hoas operator module defines type operator operators 
parents nat list terms type type decidable equality 
require operator fixed shape 
case concrete quoted operators shape operator list numbers stating number bindings operator adds corresponding subterm length list arity operator 
hoas operator operator displayed operator hoas operator shape op displayed shape op hoas operator op op op displayed op op op rules operator type 
univ intro operator type intro equal operators identical 
nth hyp op op operator op op op decides equality operator 
op wf intro op operator op operator aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings op op op op eq intro op op operator op op op op rev eq wf op operator wf op operator op op op op op operator op elim elim op op op op operator op op op op operator main 

op op op 
op op operator 
op op op operator shape list natural numbers meant represent number bindings arguments 
length list operator arity 
define arity itt hoas operator arity op displayed arity op arity op nat list intro op operator shape op list list intro op operator shape op list nat list eq intro op op operator shape op shape op list int list intro op op operator shape op shape op int list nat intro op op operator arity op arity op int intro op op operator arity op arity op int int list sq intro op op operator shape op shape op aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings itt hoas module hoas module defines destructors extracting bterm components corresponding de bruijn representation bterm 
parents hoas base hoas vector hoas operator hoas debruijn terms var operator decides bterm var mk bterm 
order implement var operator assume exist distinct operators concrete notion operators course trivially derivable keep operators type point 
dest bterm operator generic destructor extract components de bruijn representation bterm 
hoas op displayed op hoas op displayed op isvar itt hoas var bt displayed var bt bis op op bt op try get op bt op dest bterm itt hoas dest bterm bt var case bdepth op subterms 
op case bdepth op subterms displayed match bt var var case mk bterm bdepth op subterms op case bdepth op subterms var bt var case bt bt op case bt op bt subterms bt rules op intro aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings op operator op intro op operator rewrites reduce op op op alse op id reduce op operator op op op true var var reduce var var true var mk bterm reduce op operator var mk bterm op btl alse bterm var reduce var var case mk bterm op case var case bterm mk bterm reduce op operator subterms list bterm op subterms var var case mk bterm bdepth op subterms op case bdepth op subterms op case op map bt bt lv subterms itt hoas bterm module hoas bterm module defines inductive type bterm establishes appropriate induction rules type 
parents hoas image aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings terms compatible shapes itt hoas bterm compatible shapes bdepth op btl displayed compatible shapes bdepth op btl arity op btl int index btl bdepth shape op int dom itt hoas bterm dom bt displayed dom bt depth op operator subterms bt list compatible shapes depth op subterms mk itt hoas bterm mk displayed mk match inl left right left right inr op st bterm op st dest itt hoas bterm dest bt displayed dest bt match bt var inl mk bterm op ts inr op ts iter itt hoas bterm iter displayed iter img dom mk bt itt hoas bterm bt displayed bt ind ind ind oid ind iter ind bterm itt hoas bterm bterm displayed bterm bt rules reduce base reduce bt oid reduce step reduce bt iter bt elim squash elim base var step 


depth 
op operator aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings 
subterms bt list compatible shapes depth op subterms mk bterm depth op subterms bt wf bdepth wf intro bt type bt 
wf intro bt type wf intro wf intro bterm shapes wf intro bdepth op operator btl bterm list compatible shapes bdepth op btl type shapes btl list compatible shapes bdepth op btl compatible shapes bdepth op btl subtype bterm intro bt bterm monotone intro bt bt wf intro var bterm bterm bt wf intro depth op operator subterms bt list compatible shapes depth op subterms mk bterm depth op subterms bt bterm wf intro depth op operator subterms bterm list compatible shapes depth op subterms mk bterm depth op subterms bterm elim squash elim base var aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings step 



depth 
op operator 
subterms bt list compatible shapes depth op subterms mk bterm depth op subterms bt elim squash elim var 


depth 
op operator 
subterms bterm list compatible shapes depth op subterms mk bterm depth op subterms bterm eta reduce bt bterm bt bt bt reduce gamma reduce gamma var var reduce gamma mk bterm op btl mk bterm op btl vec eta reduce bt bterm bt gamma bt bt lemma reduce subterms bterm list aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings index subterms 
map bt bt lv subterms subterms bterm mk bterm reduce op operator subterms bterm list compatible shapes op subterms bterm op subterms var var case mk bterm bdepth op subterms op case bdepth op subterms op case op subterms dest reduce reduce bterm mk dest bterm wf intro bt bterm var case 

bdepth 
op operator 
subterms bterm list compatible shapes bdepth op subterms op case bdepth op subterms 
match bt var var case mk bterm bdepth op subterms op case bdepth op subterms wf intro bterm dest dom bterm elim elim var 


bdepth 
op operator 
subterms bterm list compatible shapes bdepth op subterms mk bterm bdepth op subterms bterm aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings aa eric aaron stuart allen 
justifying calculational logic conventional metalinguistic semantics 
technical report tr cornell university ithaca new york september 
abf brian aaron bohannon matthew fairbairn nathan foster benjamin pierce peter sewell dimitrios geoffrey stephanie weirich steve zdancewic 
mechanized metatheory masses challenge 
available fromhttp www 
cis upenn edu group proj mmm 
ac william aitken robert constable 
reflecting nuprl lessons 
technical report cornell university computer science department ithaca ny 
ace stuart allen robert constable richard eaton christoph kreitz lori 
nuprl open logical environment 
david mcallester editor proceedings th international conference automated deduction volume lecture notes artificial intelligence pages 
springer verlag 
stuart allen robert constable douglas howe william aitken 
semantics reflected proof 
proceedings th symposium logic computer science pages 
ieee computer society press june 
acm simon ambler roy crole alberto 
combining higher order syntax tactical theorem proving induction 
tphols proceedings th international conference theorem proving higher order logics pages london uk 
springer verlag 
acm ambler crole alberto 
definitional approach primitive recursion higher order syntax 
proceedings workshop mechanized reasoning languages variable binding pages 
acm press 
acu william aitken robert constable judith underwood 
metalogical frameworks ii reflected decision procedures 
journal automated reasoning 
stuart allen 
non type theoretic definition martin types 
gries editor proceedings nd ieee symposium logic computer science pages 
ieee computer society press june 
stuart allen 
non type theoretic semantics type theoretic language 
phd thesis cornell university 
art sergei 
explicit reflection theorem proving formal verification 
ganzinger gan pages 
art sergei 
evidence common knowledge 
technical report tr cuny ph program computer science technical reports november 
ba eli barzilay stuart allen 
reflecting higher order syntax nuprl 
victor zar mu oz ne editors theorem proving higher order logics track proceedings th international conference theorem proving higher order logics tphols hampton va august pages 
national aeronautics space administration 
bac eli barzilay stuart allen robert constable 
practical reflection nuprl 
short th annual ieee symposium logic computer science june ottawa canada 
aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings bar eli barzilay 
quotation reflection nuprl scheme 
technical report tr cornell university ithaca new york january 
bar eli barzilay 
implementing reflection nuprl 
phd thesis cornell university 
preparation 
cab robert constable stuart allen bromley cleaveland cremer harper douglas howe knoblock mendler panangaden james sasaki scott smith 
implementing mathematics nuprl proof development system 
prentice hall nj 
cfw lu 
hierarchical reflection 
slind pages 
con robert constable 
reflection explain enhance type theory 
helmut schwichtenberg editor proof computation volume nato advanced study institute international summer school held marktoberdorf germany july august nato series pages 
springer berlin 
db de bruijn 
lambda calculus notation nameless dummies tool automatic formula manipulation application church rosser theorem 
mathematische 
appeared proceedings akademie van amsterdam series 
dfh jo lle despeyroux amy felty andr hirschowitz 
higher order syntax coq 
dezani ciancaglini plotkin editors proceedings international conference typed lambda calculus applications volume lecture notes computer science pages 
springer verlag april 
appears inria research report rr 
dh jo lle despeyroux andr hirschowitz 
higher order syntax induction coq 
lpar proceedings th international conference logic programming automated reasoning volume lecture notes computer science pages 
springer verlag 
appears inria research report rr 
dh james davis daniel huttenlocher 
shared annotations cooperative learning 
proceedings acm conference computer supported cooperative learning september 
dl jo lle despeyroux pierre 
modal lambda calculus iteration case constructs 
altenkirch reus editors types proofs programs international workshop types germany march volume lecture notes computer science pages 
dl jo lle despeyroux pierre 
recursion objects functional type 
mathematical structures computer science 
dps jo lle despeyroux frank pfenning carsten sch rmann 
primitive recursion higher order syntax 
hindley editor proceedings third international conference typed lambda calculus applications tlca volume lecture notes computer science pages 
springer verlag april 
extended version available technical report cmu cs carnegie mellon university 
em andrzej ehrenfeucht jan 
abbreviating proofs adding new axioms 
bulletin american mathematical society 
solomon feferman editors 
kurt del collected works volume 
oxford university press oxford clarendon press new york 
aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings marcelo fiore gordon plotkin daniele turi 
syntax variable binding 
proceedings th ieee symposium logic computer science pages 
ieee computer society press 
gan harald ganzinger editor 
proceedings th international conference automated deduction volume lecture notes artificial intelligence berlin july 
trento italy 
gm gordon melham 
axioms alpha conversion 
von wright grundy harrison editors theorem proving higher order logics th international conference turku finland august proceedings volume lecture notes computer science pages 
springer verlag 
gmo jim grundy tom melham john leary 
reflective functional language hardware design theorem proving 
technical report prg rr oxford computing laboratory 
kurt del ber formal tze der principia mathematica und systeme mathematik und physik 
english version vh 
del ber die nge von 
ergebnisse eines mathematischen 
english translation pages 
gs giunchiglia smaill 
reflection constructive non constructive automated reasoning 
abramson rogers editors meta programming logic programming pages 
mit press cambridge mass 
geuvers wiedijk 
equational reasoning partial reflection 
harrison editors theorem proving higher order logics th international conference tphols volume lecture notes computer science pages 
springer verlag 
jason hickey brian alexei kopylov aleksey nogin xin yu 
listing metaprl theories 
metaprl org theories pdf 
har harrison 
metatheory reflection theorem proving survey critique 
technical report crc sri international cambridge computer science research centre yard cambridge uk february 
hhp robert harper furio honsell gordon plotkin 
framework defining logics 
journal association computing machinery january 
revised expanded 
hic jason hickey 
nuprl light implementation framework higher order logics 
william mccune editor proceedings th international conference automated deduction volume lecture notes artificial intelligence pages 
springer july 
extended version www cs caltech edu papers cade nl default html 
hic jason hickey 
fault tolerant distributed theorem proving 
ganzinger gan pages 
hic jason hickey 
metaprl logical programming environment 
phd thesis cornell university ithaca ny january 
hl rard huet bernard lang 
proving applying program transformations expressed second order patterns 
acta informatica 
aleksey nogin alexei kopylov xin yu jason hickey computational approach reflective meta reasoning languages bindings hnc jason hickey aleksey nogin robert constable brian eli barzilay richard eaton adam alexei kopylov christoph kreitz vladimir lori stephan schmitt carl witty xin yu 
metaprl modular logical environment 
david basin burkhart wolff editors proceedings th international conference theorem proving higher order logics tphols volume lecture notes computer science pages 
springer verlag 
jason hickey aleksey nogin alexei kopylov metaprl home page 
metaprl 
org 
mos andrzej mostowski 
sentences undecidable formalized arithmetic exposition theory kurt del amsterdam north holland 
nh aleksey nogin jason hickey 
sequent schema derived rules 
victor zar mu oz ne editors proceedings th international conference theorem proving higher order logics tphols volume lecture notes computer science pages 
springer verlag 
michael 
recursive function definition types binders 
slind pages 
par parikh 
existence feasibility arithmetic 
journal symbolic logic 
pau lawrence paulson 
isabelle generic theorem prover volume lecture notes computer science 
springer verlag new york 
pe frank pfenning conal elliott 
higher order syntax 
proceedings acm sigplan conference programming language design implementation pldi volume sigplan notices pages atlanta georgia june 
acm press 
pfe frank pfenning 
elf language logic definition verified metaprogramming 
proceedings th ieee symposium logic computer science pages asilomar conference center pacific grove california june 
ieee computer society press 
plo gordon plotkin 
illative theory relations 
cooper perry editors situation theory applications volume number csli lecture notes pages 
centre study language information 
pn paulson nipkow 
isabelle tutorial user manual 
technical report university cambridge computing laboratory 
konrad slind annette ganesh gopalakrishnan editors 
proceedings th international conference theorem proving higher order logics tphols volume lecture notes computer science 
springer verlag 
sch carsten sch rmann 
recursion higher order encodings 
fribourg editor computer science logic proceedings th annual conference volume lecture notes computer science pages 
springer verlag 
smi smith 
reflection semantics lisp 
principles programming languages pages 
vh van heijenoort editor 
frege del source book mathematical logic 
harvard university press cambridge ma 

