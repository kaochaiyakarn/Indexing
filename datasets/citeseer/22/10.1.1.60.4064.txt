cryptographically sound theorem proving christoph michael backes david basin birgit pfitzmann michael waidner eth zurich switzerland basin inf ethz ch ibm zurich research lab switzerland backes cs uni sb de bpf wmi zurich ibm com 
describe faithful embedding dolev yao model backes pfitzmann waidner ccs theorem prover isabelle hol 
model cryptographically sound strong sense reactive simulatability uc essentially entails preservation arbitrary security properties active attacks arbitrary protocol environments 
main challenge designing practical formalization model cope complexity providing strong soundness guarantees 
reduce complexity abstracting model sound light weight formalization enables concise property specifications efficient application proof strategies supporting proof tools 
yields tool supported framework symbolically verifying security protocols enjoys strong cryptographic soundness guarantees provided reactive simulatability uc 
proof concept proved security needham schroeder lowe protocol framework 
security proofs cryptographic protocols known difficult automation proofs studied soon protocols developed 
start actual cryptographic operations proofs idealized called dolev yao models see 
idealization simplifies proof construction freeing proofs cryptographic details computational restrictions probabilistic behavior error probabilities 
dolev yao model cryptographic justification arbitrary active attacks introduced backes pfitzmann waidner extended :10.1.1.3.4629:10.1.1.4.5735
model henceforth called bpw model implemented sense reactive blackbox simulatability real cryptographic systems secure standard cryptographic definitions :10.1.1.4.5735
security notion means system cryptographic realization plugged arbitrary protocols system bpw model retaining essentially arbitrary security properties called uc universal composition properties 
bpw model currently constitutes dolev yao model known fulfill strong security notion soundness results restricted specific security properties protocol classes 
bpw model constitutes deterministic symbolic abstraction comprehensive set cryptographic operations allows prove security arbitrary protocols partially supported zurich information security center 
represents views authors 
built operations respect cryptographic definitions means symbolic reasoning techniques see pencil proofs :10.1.1.125.9156
order relate bpw model cryptographic realization sense uc bpw model maintains certain non standard aspects compared dolev yao models 
example ciphertexts bpw model hide length respective plaintexts signature specific message transformed adversary signature message protocols built top bpw model directly manipulate messages pointers called handles refer messages manipulated respective operations 
aspects prevent direct existing tools symbolic protocol analysis necessary achieve cryptographic soundness bpw model respect strong soundness notion uc 
complexity bpw model raises question answer initially unclear possible reason efficiently protocols model theorem prover sacrificing strong soundness guarantees 
main obstacle efficient mechanization complex state space includes message buffers messages handles representation messages pointer data structure 
standard techniques reasoning state systems hoare logics weakest precondition calculi scale poorly complex state spaces pointer structures 
helpful distinguish types complexity bpw model inherent complexity required uc cryptographic soundness eliminated complexity due particular modeling choices 
fortunately able reduce kind complexity employing series carefully chosen abstractions point positively answer question raised 
contributions main contribution simplified version bpw model formalization theorem prover isabelle hol higherorder logic hol instance generic logical framework isabelle 
isabelle hol theories conservative extensions hol proofs rely axioms hol constitute framework combines machine assisted symbolic reasoning security protocols strong cryptographic soundness provided notion uc 
contribution parts 
support reasoning state programs embedded program logics isabelle hol including weakest precondition calculus wpc hoare logic pre postcondition properties linear time temporal logic ltl temporal properties 
standard techniques proofs temporal properties reduced pre postcondition assertions hoare logic turn reduced wpc 
general purpose reasoning tools reused contexts 
general proof strategy employ wpc uses rewriting efficiently compute weakest preconditions automatically prove lemmas lower layers model functions bpw model 
lemmas combined hoare logic proofs higher layers protocol 
second weaker cryptographic soundness results consider restricted security properties restricted protocol classes maintain aspects accessible existing proof tools cf 
paragraph related literature details 
produced formalizations bpw model abstracts different features original model faithfully represent non standard aspects 
formalization called indexed bpw model component communication model abstracted light weight shallow embedding isabelle hol machines message buffers simplified state manipulating components providing set interface functions communicating function invocation 
data representation closely follows original bpw version messages represented pointer structures sharing different protocol participants 
unfortunately abstraction step insufficient attempt prove security needham schroeder lowe protocol indexed bpw model failed essentially due lack abstraction model complex pointer structures specifications complicated invariants 
consequence wpc slow useful produced large expressions difficult understand 
simplified appropriate equational theory available 
resort hoare logic reasoning low layers model required substantial user interaction complicated intermediate preconditions 
second formalization called term bpw model address problems replacing pointer messages simple inductive data type messages 
new representation eliminates message sharing users handles asymmetric key pairs message lengths differently equivalence indexed model non trivial 
ensure correctness step proved isabelle hol formalizations strongly bisimilar 
bisimilarity preserves uc safe replace indexed model term model protocol security proofs 
term model efficient automatic reasoning possible ways 
provides messages simple inductive structure enables standard structural induction 
possible indexed model 
second enables concise property specifications functional dy closure operators paulson analyze parts close set messages cryptographically accessible respectively 
fact able transfer paulson corresponding isabelle hol theories term setting 
equational theories associated operators enable efficient isabelle term rewriter simplification 
combination enhancements drastically improves usability performance wpc term bpw model compared indexed version 
second contribution specification verification security needham schroeder lowe protocol term bpw model br sim uc actual cryptographic implementation protocol 
consider proof concept formalization proof techniques 
note regard sound pencil proofs nsl protocol sound tool supported proofs exploiting soundness result restricted protocol classes properties exploiting soundness result compositionality guarantees specific protocol classes :10.1.1.125.9156
proof demonstrates relatively efficient cryptographically sound proofs sense uc possible provides evidence formalized framework successfully applied reason commonly studied protocols 
related early linking dolev yao style symbolic models cryptography considered passive attacks general statements protocols 
holds :10.1.1.116.571
security notion defined generally simulatability definitions secure step function evaluation 
extended called uc universal composability widely applied prove individual cryptographic systems secure derive general theoretical results 
cryptographic justification dolev yao model sense uc extensions :10.1.1.3.4629:10.1.1.4.5735
papers considered extent restrictions weaker security properties general protocol classes allow simplifications compared laud cryptographic foundations dolev yao model symmetric encryption specific certain confidentiality properties surrounding protocols restricted straight line programs :10.1.1.2.8678:10.1.1.4.5735
herzog micciancio warinschi cryptographic underpinnings dolev yao model public key encryption result relies stronger assumption restricts classes protocols protocol properties analyzed primitive :10.1.1.116.571:10.1.1.4.5735
cortier warinschi considered secrecy aspects showing symbolically secret nonces computationally secret indistinguishable fresh random value view cryptographic adversary :10.1.1.117.6018
baudet cortier kremer established soundness equational theories dolev yao model passive attacks :10.1.1.142.1557
stress imposed restrictions protocol classes protocol properties aforementioned works eliminated complications necessary soundness stronger sense uc desired dolev yao models accessible existing verification tools major adaptations 
canetti herzog shown dolev yao style symbolic analysis conducted framework universal composability restricted class protocols mutual authentication key exchange protocols additional constraint protocols expressible loop free programs public key encryption cryptographic operation 
concentrating specific protocol class permitted direct automatic verification tool symbolically analyze secrecy aspects needham schroeder lowe protocol considering exchanged nonces secret keys 
closest achieves universal composition guarantees case protocol class composed larger protocols contrast aforementioned results 
results restricted functionalities noted provide soundness guarantees dolev yao model sense uc guarantees soundness composing arbitrary protocols 
extending achieve stronger notion require augmenting model non standard aspects bpw model raising need tailored verification framework 
efforts way formulate syntactic calculi dealing polynomial time considerations particular second step encode proof tools :10.1.1.8.7994
datta derek mitchell shmatikov proposed promising comprehensive logic enables prove computational security properties logical deduction system 
laud designed type system proving security protocols bpw model 
aware mechanized implementations frameworks 
blanchet automated tool proving secrecy properties cryptographic protocols relies directly cryptographic approach transforming cryptographic games expressed probabilistic polynomial time calculus :10.1.1.135.8642
approach appears highly promising due ability analyze security protocols relying abstractions cryptography potential complement line proving soundness dolev yao models formally validating existing pencil proofs soundness 
organization sect 
briefly review bpw model describe encoding component communication model underlying bpw model isabelle hol 
formally introduce indexed term bpw models sect 
sketch proof strong bisimilarity 
sect 
formally define composition protocol bpw model isabelle 
yields flexible template instantiated arbitrary protocol specifications 
specify needham schroeder lowe protocol sketch proof security sect 

sect 
draw discuss 
overview bpw model formalization section review bpw model discuss principal abstractions design choices formalization 
cryptographic realization bpw model details proof cryptographic soundness necessary understanding contributions original papers 
bpw model bpw model constitutes library cryptographic operations keeps track controls access terms known party 
bpw model provides local functions operating terms send functions exchanging terms arbitrary fixed number users adversary 
functions reflect distinguished attack capabilities offered adversary 
interface terms referred indirectly handles called pointers local names terminologies 
indirection necessary cryptographic soundness proof bpw model strong sense uc bpw model cryptographic realization vastly different objects terms bitstrings respectively 
handles syntactically different objects uniform manner users avoid bpw model trivially distinguished realization different interfaces 
analyze security protocol bpw model reasons system user runs protocol component pu implemented invoking respective functions bpw model fig 

protocol component maintains local state store nonces generated provides interfaces communicating user bpw model 
fig 
depicts typical control flows system user may give input initiate protocol constructs term corresponding protocol message series local interactions bpw model 
local means term construction involve un 
symbolic bpw model user adv fig 

system components control flow interaction adversary terms arbitrarily nested revealing structure contents subterms adversary construction 
term constructed may sent network adversary 
second adversary may decompose terms construct new ones local interactions bpw model send terms users 
bpw model delivers terms sent adversary protocol component respective user processed protocol description 
isabelle hol preliminaries isabelle generic theorem prover variety logics implemented 
implementation higher order logic hol roughly seen logic top functional programming 
assume reader basic familiarity logic typed functional programming 
proof automation isabelle supported powerful simplifier performs term rewriting tableau reasoner 
invoked isolation combination different proof tactics 
isabelle notation denotes term type expression defines constant parameter term definitions constitute principal mechanism producing conservative extensions hol 
type variables identified leading types type total functions product type set type sets elements type type unit contains single element 
mechanisms define new types 
datatype declaration introduces inductive data type 
example option type defined datatype option polymorphic type variable functions type option model partial functions declaration types merely introduces new name type possibly parameters types option 
isabelle hol includes package supporting extensible record types 
example record point nat nat defines record type points record element 
records extensible record cpoint point color extends points color field 
scenes definition record type creates record scheme scheme extends declared type polymorphic field type type derived unit scheme 
record extensibility instantiation record scheme parameter additional fields 
im portant formalization extensions compatible scheme scheme 
example cpoint compatible point scheme point 
overview formalization summarize abstraction steps design choices employed simplify component communication model operational semantics underlying bpw model 
simplifications enable sound light weight formalization bpw model protocols properties 
component communication model typed perspective bpw model protocol components represented deterministic machines transition functions type option machine state space inputs outputs respectively 
types seen nonrecursive inductive data types constructor corresponds port name arguments correspond values communicated port 
output optional usually absence output indicates error occurred 
general communication framework underlying bpw model stores messages transit called buffers messages scheduled designated scheduler respective connection 
important special case machines charge outgoing connections schedule outgoing messages immediately messages passed directly sender recipient 
case communication bpw model protocol components buffers safely omitted formalization leading substantial simplification 
essentially machine transition seen function call parameters passed input port producing return value output port exception 
formalization replaces machine description bpw model components consisting set interface functions manipulating common state communication ports replaced function calls 
state exceptions play crucial role bpw model handled appropriate abstractions formalization 
purely functional context isabelle hol abstractions provided monads 
generally speaking monad type constructor equipped unit composition operations enjoying unit associativity properties respectively 
monadic interpretation operation input type output type function type different monads represent wide range computational phenomena including state exceptions non determinism 
deterministic state exception monad datatype result exception value result type types result monad type return monad unit return 
value bind monad composition bind case exception exception value note monad polymorphic type values type states 
unit called return embeds value monad bind sequential composition passes results values exceptions function calls 
write bind monad specific operations state assignment throwing catching exceptions 
set monad operations forms simple imperative language formulate models 
runs observations communication framework underlying bpw model system run defined sequence local transitions form names machine making transition local state input local state producing output 
corresponds small step semantics transitions individual machines considered 
user view derived projecting runs transitions performed honest users 
formalization uses big step semantics internal transitions communication hidden 
transition consists pair states reached calling interface function 
formally transition relation monadic function defined tr 
transition relation component union relations derived components interface functions 
run sequence states arising component transitions triggered external input 
big step semantics arises naturally procedural view communication clearly preserves uc system internal transitions affect user view 
importantly big step semantics facilitates proofs supports topdown case analysis system interface functions invariant proofs need show invariant preserved internal transition 
design choice leading simpler proofs model user events part transition record traces global history variable extended event 
seen observer component logs communication users 
advantage having entire trace available state precedence properties past expressed simple invariants sets states 
definition reactive simulatability users adversary constitute probabilistic polynomially bounded machines 
formalization model universal quantification possible inputs single unbounded machine nondeterministically produces arbitrary input system transition 
safely approximates original setting unbounded machine weakly simulate set probabilistic polynomially bounded users adversary 
bpw model includes polynomial bounds length handled messages number steps machine perform 
formalized enforcement message length bound uninterpreted function security parameter bound 
comprises particular polynomial functions constitutes safe approximation 
step bounds dealt similarly 
program logics verification tools conclude section brief overview specification proof machinery constructed verifying protocol properties 
concentrates modeling bpw model isabelle hol companion devoted proof tools techniques 
program logics proof systems specify verify security properties weakest precondition calculus wpc pitts evaluation logic hoare logic top tailored state exception monad second lineartime temporal logic ltl specify temporal behavior invariants precedence properties :10.1.1.116.2392
derived set proof rules similar reduce ltl properties pre postcondition statements hoare logic hoare triples 
prove hoare triples rules hoare logic unfolding statements wpc 
wpc allows automate proofs large extent hoare logic gives manual control automation fails 
logics tools problem independent reused different contexts 
formalization bpw model building simplified modeling framework outlined sect 
formalizations bpw model isabelle hol 
called indexed bpw model closely adheres original data representation bpw model 
second called term bpw model abstracts representation messages inductively defined terms 
describe bisimulation relation proof equivalence 
versions share types parties knowledge maps datatype party user user adv types party hnd user denotes type honest users isomorphic set 
hnd type handles isomorphic set natural numbers 
knowledge maps keep track knows 
serve access control mechanism mediating handles interface internal representation messages generic type 
shared messages indexed bpw model formalization bpw model remains close original bpw model pointer structure represent messages 
state consists database storing messages referred indices type ind isomorphic natural numbers knowledge map instantiated indices 
record db ind entry database ind knowledge map database seen heap entries allocated 
knowledge map records entries known parties 
say database index defined known party 
database entries content length field 
presentation covers public key encryption omits signatures brevity 
datatype content nonce garbage ind public encryption key private encryption key idata payload data ind ind pair ind ind valid ciphertext ind invalid ciphertext record entry cont content content len nat length entry elements data type content correspond message constructors polymorphic type payload messages depends application 
constructor arguments type ind point entries database corresponding 
example term pki mi represents valid encryption argument points public key second message encrypted 
public key points matching secret key key pair 
contrast commonly dolev yao models adversary may create garbage entries constructor invalid ciphertexts constructor 
formed database defined index determines directed acyclic graph indexed bpw model representation message 
call payload data pairs non cryptographic messages cryptographic messages 
length field entry enforce bound message length 
bpw model interface functions manipulate knowledge map database 
examples local interface functions main operations public key cryptography types gen enc party hnd hnd scheme party hnd hnd hnd scheme function gen enc returns public secret key pair takes public key cleartext returns ciphertext takes secret key ciphertext returns cleartext 
message arguments results referred handles 
argument invalid exception raised 
note functions operate record scheme scheme plain state record stands extensions state example protocol state sect 

extensible records invariants proved bpw model automatically carry extensions state explicit lifting 
apply technique term bpw model 
main differences model dolev yao models encryption message public key referred handles results different ciphertext new database entry pointed fresh handle 
reflects fact secure encryption necessarily probabilistic shows role indices modeling idealized randomness 
fact functions constructing cryptographic messages produce fresh database entries invocation 
situation different non cryptographic messages allocated shared users 
dolev yao models freshness introduced side conditions cryptographic messages example requiring nonce occurred far message network 
important difference dolev yao models adversary honest users learn length cleartext underlying ciphertext separate function adv parse shown modeling length revealing crypto system 
proved basic invariants indexed bpw model needed bisimulation proof sect 
express definedness conditions knowledge map finite domain user injective domain arguments entries defined indices defined 
respect original bpw model number simple abstractions formalization 
factored access control lists entries original version isomorphic representation knowledge maps isolating common element formalizations 
second replaced lists pairs loss generality 
pairs sufficient modeling concrete protocols recursively defined simplify reasoning obviating need certain inductive arguments 
third abstracted allocation new objects indices handles counting scheme arbitrary deterministic allocation scheme consequence public key pairs linked explicit pointer public secret key allocating successive indices 
abstraction pays simplifying reasoning extra invariant making link key pairs explicit obsolete 
explained abstractions turned insufficient practically useful verification framework 
main problems arose lack inductive message structure supported standard structural induction complicated ad hoc property specifications expressed knowledge subterm derivation operators paulson analyze parts 
operators defined indexed model fact messages indexed bpw model exists independently state complicate definition derivation application associated equational theories 
problems addressed second term formalization bpw model 
inductively defined messages term bpw model fortunately sharing messages different users indexed bpw model inessential eliminated 
representation messages obtained inductive data type messages 
isabelle automatically generates induction scheme inductive data type 
signatures omitted brevity 
datatype msg tag nonce tag len adversary garbage key public encryption key key private decryption key data item msg msg pair messages tag key msg valid ciphertext tag key len invalid ciphertext data type definition replaces previous index arguments content fields database entries recursive message arguments 
notable changes moving representation 
role played indices allocating fresh database entries cryptographic messages taken elements new isomorphic type tag thought abstraction random coins 
type key just name tag 
matching key pairs simply form 
replacing argument encryption constructors recursive message argument directly record corresponding key avoiding unnecessary formedness conditions messages 
second determine hilbert operator 
picks fresh 
length messages partially interpreted recursive function len ofm msg len allows remove redundant length information state 
length fields required garbage invalid ciphertexts adversary choose arbitrary length atomic message types 
abstraction step substantially simplifies structure states eliminating need database largely length fields state term bpw model simply consists knowledge map storing messages record msg economy state variables ability reason inductively messages leads quite dramatic improvement proof automation 
second substantial improvement leads concise specifications improved proof automation stems adapting setting closure operators parts analyze equational theories developed paulson 
term parts denotes closure set messages analyze closes cryptographically accessible 
expression analyze ran denotes set messages party derive knowledge state ran denotes range partial function 
analyze parts define secrecy follows secret scheme msg party set bool secret parts analyze ran ran adv proposition secret means message secret shared set parties state note require secrets atomic 
definition non atomic secrets need synthesize operation corresponding message construction top analyze secrets possibly built known messages 
inclusion adversary knowledge strengthens definition exploited invariant proofs see sect 

bisimulation indexed bpw model establish bisimilarity formalizations bpw model 
result versions yield identical views honest users trivially preserves uc 
due close correspondence described bisimulation statebased properties easily translated term indexed version 
bisimulation proof shows pairs interface functions transform bisimilar states bisimilar states identical output possible inputs 
interface functions deterministic sufficient establish bisimulation versions shallow embedding bisimulation notion bisimulation formalized explicitly 
message abstraction relation message ind msg set central element bisimulation associates database indices messages parametrized state indexed bpw model function mapping indices tags 
witnesses fact tags assume role indices message formally explained instance coalgebraic bisimulation :10.1.1.37.1418
freshness 
note relation defined independently states term bpw model 
inductive definition message contains rule constructor type content 
example rule valid ciphertexts reads contains pki mi tg pki message mi message tg message rule states fixed state index abstracts ciphertext message tg index contains pki mi index pki abstracts public key message index mi abstracts message tag tg image main property proved message functionality 
bisimulation relation essentially consists pairs states domains knowledge maps identical message defined abstraction index ind tag scheme scheme set 
bij dom dom dom 
message defined family relations parametrized function type ind tag required bijection order map different database entries different messages 
proper bisimulation relation union family members second order property 
indices tags freely allocated indices associated tag payload data untagged parameter determined statically 
defining union parameters allows update mappings tg fresh index tg fresh tag 
resulting map bijection achieve update swapping values tg 
proof bisimulation uses set derived proof rules similar hoare logic involving components just invariant proofs 
rules rely basic invariants proved indexed term bpw model 
generic protocol modeling verification framework term bpw model model generic framework specification cryptographically sound verification security protocols 
instantiate framework concrete protocols study 
protocols observer global state extends bpw model state local state protocol component trace observed user interface 
record loc user local state user trace trace observed user trace setup polymorphic types type payload data bpw model type local states types user input output respectively 
concrete protocols instantiate type parameters concrete types 
observer trace history variable user events recorded 
type lists pairs user name input output event datatype uio uin user input output types trace user uio list define interface protocol components 
protocol component provides user network input handler may produce output user network fig 

datatype proto protocol output record proto comp proto user handler proto proto net handler user hnd proto types protocol user proto comp protocol defined function users protocol components 
observer single interface function log simply adds event trace 
standard alice bob notation paulson isabelle protocol specifications centered protocol messages transmitted different roles 
bpw model formalization take process oriented view specifying reaction protocol user network input 
particular protocol run initiated terminated explicit observable user events possibly user interaction 
user interaction enables formulation cryptographically meaningful properties user traces 
complete system compose bpw model protocol observer yielding complete system 
system types interface functions system user network handlers local functions provided bpw model adversary 
restrict presentation system user network handlers types sys user handler protocol user sys sys net handler protocol sys handlers produce system output type sys just system level version type proto user handler takes input user type network handler takes network message argument 
network messages triples supposed sender receiver message handle 
bpw model provides send functions users adversary send adv send scheme invoking send uh user sends message denoted handle uh adversary intended user 
result network message send ah ah adversary handle message 
handle created exist 
call adv send ah similar effect time message sent adversary user note adversary free falsify name originator 
gives adversary complete control network dolev yao models 
order illustrate message flow system cf 
fig 
consider system network handler detail sys net handler proto mh adv send get message network pout proto net handler proto mh handle message case pout log log output return output user unm send unm output network return input network message adversary sends receiver send function adv send resulting network message contains message fed protocol network handler receiver protocol component 
output handler intended user case output logged observer returned user reply message sent back network adversary user send function send specifying concrete protocol framework need provide user network handlers protocol 
determines concrete types user payload data local state protocol components instantiating type variables done ready specify verify protocol properties 
cryptographically sound proof nsl protocol model verify known message version nsl protocol nsl 
nu kv nsl 
nu nv ku nsl 
nv kv assume user generated asymmetric key pair authentic public keys users known party 
introduce formal specification nsl protocol 
describe invariants verified sketch proof invariant 
discuss benefits gained abstractions 
protocol specification specify nsl protocol framework defining protocol component user 
component pu records set nonces generates protocol sessions user local variable nonces name user record nonces user hnd set set nonce handles initiate protocol run indicating name responder 
protocol terminated returning name initiator responder 
user input output type user 
payload data nsl protocol user names 
abbreviation states protocol types user user user nsl protocol specified instantiating user network handlers user user user protocol proto user handler initiate protocol avoid talking self mk msg message proto net handler emh 
respond protocol messages avoid talking self pm parse msg emh case pm msg vid mk msg second message msg unh vid mk msg third message msg return terminate protocol user handler user initiates protocol run user constructing protocol message 
network handler takes name sender message handle emh parses message depending result replies producing reply message terminating protocol indicating user supposedly authenticated 
statements prevent protocol component talking throwing exception stated condition satisfied 
example show definition mk msg constructs protocol message nsl mk msg user user user proto mk msg nh gen add nonce generate register nonce uih store user mh pair user nh uih emh encrypt user pke user mh return emh send st message definition pke user denotes handle user refers user public key 
statement gen add nonce generates fresh nonce adds nonces loc nonces user sessions user subsequent calls incrementally construct message 
verified properties main property proved responder authenticates initiator 
formulated property observed user trace transfers cryptographic level 
fig 

invariants nsl protocol set commit set trace init set trace init nicer syntax uin commit 
require initiator responder distinct 
observer history variable trace entire trace events available state express authentication property sufficient consider set trace unordered set events state history variable record traces advantage reducing temporal precedence properties past simple invariants sets states 
actual theorem states invariant 
formulated isabelle ltl property theorem invariant pred theorem says states runs transition system derived nsl protocol system satisfy 
proof invariant auxiliary invariants listed fig 
dependencies 
basic invariants state properties local variable nonces handles stored variable denote nonces nonce recorded variable created unique user protocol session unique responder 
invariants express initiator nonce message nsl responder nonce nsl uniquely determine fields respective message 
invariants prove protocol nonces remain secret invariant protocol participants set nonces secret user user nonces set nonces denoted handles stored variable nonces nonces user user tag set nonces user nonces loc notion secrecy defined sect 

authentication property derived conjunction auxiliary invariants going message back protocol indicated dashed line fig 

typical invariant proof protocol invariant usually proved showing preserved system interface functions 
example consider proof 
point interesting cases defer discussion general proof strategy sect 

proceed bottom showing invariant preserved bpw model interface functions 
unsurprisingly interesting cases send functions messages exchanged parties 
lemma user send function send reads follows lemma send ns send pre send hoare triple states send called state satisfying precondition terminates normally resulting state satisfies 
note previously proved invariants strengthen precondition 
basic auxiliary invariants sufficient establish preservation bpw model interface functions send need additional precondition ns send pre ns send pre user hnd set ns send pre ua va user nonces ua va analyze ran ran adv user ua user va note similarity definition 
intuitively predicate states message sent referred handle added knowledge adversary compromising secrecy protocol nonces 
precondition formulated largely protocol independent manner 
remains shown concrete protocol messages satisfy condition 
interestingly strengthening definition secrecy obtained adding adversary knowledge analyze operator essential 
effect nonce secrecy trivially preserved adversary send function adv send strengthening predicate ns send pre arise precondition adv send case unprovable control messages adversary may send users 
strengthening shifts precondition user side protocol determines messages sent 
invariants show protocol messages satisfy precondition ns send pre bpw model invariant guarantees secret keys leak adversary 
example preservation system user handler proved proto user handler establishes postcondition stating message nsl constructed fresh nonce 
invariant fact implies ns send pre message nsl 
cases messages nsl nsl similar require additional respectively 
preservation results bpw model level easily lifted protocol functions calling send mk msg repeated application hoare proof rule sequential composition pulling invariant individual function calls 
discussion evaluation reasoning bpw model inherently stateful originally proposed involves complex pointer data structures 
observed main task formalizing model develop abstractions proof strategies supporting proof tools allow reduce complexity reason efficiently state state transitions result calls interface functions 
strategies automate reasoning possible wpc 
main enabling factors strategy model abstraction provided moving indexed term model property abstraction introduced operators analyze parts equational theories 
routinely wpc level bpw model interface functions switch hoare logic protocol system levels 
precisely adopted proof strategy systematically proving invariants illustrate nsl protocol hypothetical invariant example 
explain step strategy top manner practical proceed bottom 
apply ltl proof rule reduce temporal statement nsl invariant expressed pred set hoare triples form triple system interface function stating preserves inputs ltl proof rule achieving reduction embodies induction positions system runs uses auxiliary invariants represented order strengthen induction hypothesis 
second rules hoare logic decompose preservation statements similar statements bpw model interface functions 
illustrated sect 
preservation invariant interface functions may require auxiliary preconditions pre pre ensure derive auxiliary precondition pre interface function called protocol handler postconditions functions called order minimize ad hoc lemmas prove characteristic hoare triples auxiliary functions appearing protocol handlers parse msg mk msg nsl protocol 
hoare triples auxiliary invariants precondition strong postcondition characterizing effect respective function 
idea collect information need prove pre characteristic postconditions 
difficulty step depends number bpw interface functions requiring auxiliary preconditions generally send 
third step prove preservation lemmas bpw model interface functions unfolding wpc applying automatic proof tools including simplifier tableau reasoner 
heavy equational theories analyze parts 
automatic tools may require additional lemmas consequences auxiliary invariants complete proof 
abstracting non inherent complexity bpw model obtained framework cryptographically sound protocol verification sense note adversary interface functions system level interface functions allowed auxiliary preconditions system invariant 
uc possible 
due pointer nature handles constrained fine grained bpw interface functions handle messages manner 
main remaining intrinsic complexity model 
contrast complexity added non standard aspects cryptographic operations ciphertexts signature transformations complicate proofs significantly 
paulson security protocol proofs isabelle hol provide natural benchmark proofs judging cost remaining complexity 
ideally cost zero 
construct proofs cryptographically sound abstractions effort comparable required considerably simpler abstractions provided dolev yao model 
moment distance ideal proofs roughly orders magnitudes larger paulson uses lines prove invariant need entire isabelle theory lines 
similar picture arises global level nsl proof needs roughly pages counting automatically generated isabelle documentation occupies pages 
length proof poor measure complexity 
substantial part difference attributed fact show preservation invariant bpw model interface functions start reasoning protocol level 
explained lemmas derived systematically largely automatically wpc 
typical proof script preservation lemma invariant proof requires lines tactics variation small 
think complexity property specifications proofs invention invariants comparable paulson optimistic able reduce gap 
developed abstraction bpw model strategies proof tools enables practical protocol security proofs strong soundness guarantees 
doing substantially reduced non inherent complexity bpw model way brings closer considerably simpler abstractions provided standard dolev yao model inductive proof techniques paulson 
see number directions 
develop methods reduce impact inherent complexity 
possibility investigate changes model building higher level interface protocols changing model necessitate new soundness proof 
example simplify proofs reduce number interface functions functions building parsing sending messages 
enable compact protocol specifications shorter proofs general results functions 
second built basic proof tools developed systematic strategies constructing proofs general automated reasoning tools provided isabelle mainly rewriting tableau theorem proving 
developed specialized proof tactics tailored strategies 
mentioned sect 
see considerable potential improvement 
intend carry case studies order broaden experience formalization proof strategies 
useful incorporate features formalization symmetric encryption macs 
technical details worked await implementation :10.1.1.3.4629

abadi gordon 
calculus cryptographic protocols spi calculus 
proc 
th acm conference computer communications security pages 

abadi 
formal eavesdropping computational interpretation 
proc 
th international symposium theoretical aspects computer software tacs pages 

abadi rogaway 
reconciling views cryptography computational soundness formal encryption 
proc 
st ifip international conference theoretical computer science volume lecture notes computer science pages 
springer 

andrews 
mathematical logic type theory truth proof 
academic press 

backes 
cryptographically sound dolev yao style security proof otway rees protocol 
proc 
th european symposium research computer security esorics volume lecture notes computer science pages 
springer 

backes 
cryptographically sound dolev yao style security proof electronic payment system 
proc 
th ieee computer security foundations workshop csfw pages 

backes pfitzmann 
cryptographically sound security proof needham schroeder lowe public key protocol 
journal selected areas communications 

backes pfitzmann 
symmetric encryption simulatable dolev yao style cryptographic library 
proc 
th ieee computer security foundations workshop csfw pages 
full version iacr cryptology eprint archive feb eprint iacr org 

backes pfitzmann 
relating symbolic cryptographic secrecy 
transactions dependable secure computing 

backes pfitzmann waidner 
composable cryptographic library nested operations extended 
proc 
th acm conference computer communications security pages 
full version iacr cryptology eprint archive jan eprint iacr org 

backes pfitzmann waidner 
symmetric authentication simulatable cryptographic library 
proc 
th european symposium research computer security esorics volume lecture notes computer science pages 
springer 
extended version iacr cryptology eprint archive jul eprint iacr org 

backes pfitzmann waidner 
general composition theorem secure reactive systems 
proc 
st theory cryptography conference tcc volume lecture notes computer science pages 
springer 

basin 
symbolic model checker security protocols 
international journal information security 

baudet cortier kremer 
computationally sound implementations equational theories passive adversaries 
proc 
nd international colloquium automata languages programming icalp volume lecture notes computer science pages 
springer 

beaver 
secure multiparty protocols zero knowledge proof systems tolerating faulty minority 
journal cryptology 

blanchet 
automatic proof strong secrecy security protocols 
proc 
th ieee symposium security privacy pages 

blanchet 
computationally sound mechanized prover security protocols 
proc 
th ieee symposium security privacy 

canetti 
security composition multiparty cryptographic protocols 
journal cryptology 

canetti 
universally composable security new paradigm cryptographic protocols 
proc 
nd ieee symposium foundations computer science focs pages 
extended version cryptology eprint archive report eprint 
iacr org 

canetti herzog 
universally composable symbolic analysis cryptographic protocols case encryption mutual authentication key exchange 
cryptology eprint archive report 
eprint iacr org 

canetti rabin 
universal composition joint state 
advances cryptology crypto volume lecture notes computer science pages 
springer 

church 
formulation simple theory types 
journal symbolic logic pages 

cortier warinschi 
computationally sound automated proofs security protocols 
proc 
th european symposium programming esop pages 

datta derek mitchell shmatikov 
probabilistic polynomial time semantics protocol security logic 
proc 
nd international colloquium automata languages programming icalp volume lecture notes computer science pages 
springer 

dolev yao 
security public key protocols 
ieee transactions information theory 

goldreich 
security multi party ping pong protocols 
proc 
th ieee symposium foundations computer science focs pages 

goldreich micali wigderson 
play mental game completeness theorem protocols honest majority 
proc 
th annual acm symposium theory computing stoc pages 

goldwasser levin 
fair computation general functions presence majority 
advances cryptology crypto volume lecture notes computer science pages 
springer 

gordon melham editors 
hol theorem proving environment higher order logic 
cambridge university press 

guttman thayer zuck 
faithfulness protocol analysis message authentication 
proc 
th acm conference computer communications security pages 

herzog liskov micali 
plaintext awareness key registration 
advances cryptology crypto volume lecture notes computer science pages 
springer 

hoare 
axiomatic basis computer programming 
communications acm october 

impagliazzo 
logics reasoning cryptographic constructions 
proc 
th ieee symposium foundations computer science focs pages 

jacobs rutten 
tutorial algebras induction 
eatcs bulletin 

kemmerer meadows millen 
systems cryptographic protocol analysis 
journal cryptology 

laud 
semantics program analysis computationally secure information flow 
proc 
th european symposium programming esop pages 

laud 
symmetric encryption automatic analyses confidentiality active adversaries 
proc 
th ieee symposium security privacy pages 

laud 
secrecy types simulatable cryptographic library 
proc 
th acm conference computer communications security 

liang hudak jones 
monad transformers modular interpreters 
nd acm symposium principles programming languages popl pages new york ny usa jan 
acm press 

lincoln mitchell mitchell scedrov 
probabilistic poly time framework protocol analysis 
proc 
th acm conference computer communications security pages 

lowe 
breaking fixing needham schroeder public key protocol fdr 
proc 
nd international conference tools algorithms construction analysis systems tacas volume lecture notes computer science pages 
springer 

manna pnueli 
completing temporal picture 
theoretical computer science 

manna pnueli 
temporal logic reactive concurrent systems 
springer verlag 

manna pnueli 
temporal verification reactive systems safety 
springer verlag 

merritt 
cryptographic protocols 
phd thesis georgia institute technology 

micali rogaway 
secure computation 
advances cryptology crypto volume lecture notes computer science pages 
springer 

micciancio warinschi 
soundness formal encryption presence active adversaries 
proc 
st theory cryptography conference tcc volume lecture notes computer science pages 
springer 

mitchell mitchell scedrov 
linguistic characterization bounded oracle computation probabilistic polynomial time 
proc 
th ieee symposium foundations computer science focs pages 

mitchell mitchell scedrov 
probabilistic time process calculus analysis cryptographic protocols preliminary report 
electronic notes theoretical computer science 

moggi 
notions computation monads 
information computation 

nipkow paulson wenzel 
isabelle hol proof assistant higher order logic volume lecture notes computer science 
springer verlag 

paulson 
inductive approach verifying cryptographic protocols 
journal cryptology 

pfitzmann waidner 
composition integrity preservation secure reactive systems 
proc 
th acm conference computer communications security pages 
extended version matthias ibm research report rz may www org publ ps 
gz 

pfitzmann waidner 
model asynchronous reactive systems application secure message transmission 
proc 
nd ieee symposium security privacy pages 
extended version model michael backes iacr cryptology eprint archive eprint iacr org 

pitts 
evaluation logic 
birtwistle editor higher order workshop banff workshops computing pages 
springer verlag berlin 

schneider 
security properties csp 
proc 
th ieee symposium security privacy pages 

warinschi 
computational analysis needham schroeder lowe protocol 
proc 
th ieee computer security foundations workshop csfw pages 

