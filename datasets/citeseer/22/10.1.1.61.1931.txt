submitted review mechanizing metatheory standard ml internal language equivalent expressive power standard ml discuss formalization lf machine checked verification type safety twelf 
internal language intended serve target elaboration semantics standard ml style harper stone 
includes programming mechanisms necessary implement standard ml including translucent modules abstraction polymorphism higher kinds exceptions recursive types recursive functions 
successful formalization proof involved careful interplay precise formulations various mechanisms required invention new representation proof techniques general interest 

formal definition programming language provides rigorous implementation independent description semantics formed programs 
giving precise meaning programs formal definition provides foundation building community users ensuring compatibility implementations proving properties language programs written 
formal definition stand supported body metatheory establishes internal consistency coherence external expectations 
formal definition full scale programming language easily run hundreds pages exemplified definition standard ml 
verifying metatheory language taxes exceeds human capabilities 
absent complete verification best alternative employ established methods type systems operational semantics supported small case studies expose pitfalls 
best practices errors inconsistencies arise easily discovered 
languages evolve metatheory supports introducing opportunities error 
promising approach reducing error mechanized verification tools ease burden proving properties language definitions 
ideally language definition come equipped body metatheory mechanically checked supported national science foundation itr sy si graduate research fellowship alfred sloan foundation 
copyright notice appear daniel lee karl crary robert harper carnegie mellon university crary cs cmu edu definition extended need interest demands 
development powerful tools mechanical theorem provers logical frameworks feasible put idea practice 
example klein nipkow isabelle theorem prover formalize large part java programming language prove type safety 
report twelf implementation lf logical framework verify type safety full standard ml programming language :10.1.1.21.5854
knowledge mechanical verification safety language scale 
earlier attempt hol partially successful ran difficulties formalism definition standard ml immaturity verification tools methodology time unsoundness language 
approach draws intervening experience logical frameworks formalizing language definitions type theoretic techniques :10.1.1.21.5854
significant lesson drawn experience language definitions formulated mechanical verification metatheory mind 
formulation definition provides framework verification demands verification permitted influence definition 
just programs ought written conjunction proofs key properties language definitions developed hand hand verification 

overview approach type theoretic definition standard ml harper stone 
harper stone semantics divides definition language aspects 
elaboration translates external language syntax standard ml internal language wellbehaved type theory translucent sums formalism harper lillibridge 
elaboration performs type reconstruction overloading resolution equality compilation pattern compilation coercive signature matching resulting typed term internal language 

typing evaluation enforces type constraints imposes operational interpretation programs 
internal language behaved explicitly typed calculus equipped transition operational semantics states machine 
refer general structure definition elaboration semantics harper stone semantics standard ml particular 
note utility semantics limited ml drossopoulou rigorous accounts semantics java 
submitted review 
context standard ml semantics successfully foundation tilt compiler standard ml basis language extensions recursive modules modular type classes 
purposes cited utility semantics accrues isolation internal language operational meaning assigned standard techniques external language meaning elaboration internal form 
permits formalize type safety internal language conjunction preservation formed states transition formed states progress formed states final transition 
type safety external language follows fact elaboration yields typed program internal language 
outline proof mechanization type safety standard ml internal language leaving formalization elaboration proof typing elaboration 
fact safety proof internal language represents bulk effort internal language expressive power standard ml lacking conveniences type inference pattern matching handled separately 
discuss elaboration appropriate motivate internal language design 
natural ask carry similar mechanization definition standard ml 
results direct bearing question may informative explain choose approach 
mind earlier attempt entirely successful due part errors definition language studied type safe part complications handling machinery definition considerable array ad hoc semantic objects finite maps generative stamps realizations forth 
second drew previous experience semantics implementation tilt compiler studies language extensions supported belief utility type theoretic methods language design 
third intended twelf implementation lf logical framework provides strong support formalizing proving properties type theoretic languages purely syntactic notions binding scope 
machinery definition amenable formalization twelf precisely machinery obviate advantages afforded twelf 
fourth definition evaluation semantics support direct proof type safety 
extend semantics spurious wrong transitions prove spurious 
definition relies number informal conventions handling overloading dynamic significance signature matching formalization suspect require layer elaboration fully developed 
short structure definition poses problems general proving safety particular proving safety mechanized form 
utilize semantics se variation informed subsequent type theory modularity failed attempt verification verbatim 
internal language extension harper lillibridge translucent sums formalism support recursive types mutable extensible datatypes exceptions 
language endowed operational semantics transition system machine explicit control stack store cells generated tags 
attempts verification conducted second third authors michael philip ashley uncovered numerous minor flaws internal language expected formal verification effort ran apparently insurmountable technical difficulties proving type safety corrected language 
effort dreyer variant semantics 
dreyer internal language stone harper singleton kind formalism translucent sums employs phase separation propagate type information properly respecting phase distinction language dependently typed modules 
addition treats data abstraction computational effect permit supporting applicative functors consider 
formulate operational semantics transition system plotkin method structured operational semantics 
supports direct statement type safety avoids complications arose initial attempt semantics 
verification safety internal language presents number challenges 
may divided broad categories mathematical challenges formalization challenges 
mathematical challenges posed proof independently mechanization effort 
include delicate matters staging key technical lemmas functionality validity may proved logical progression 
challenges generally typical arising metatheories module calculi 
novel challenges arising demands formalization language lf verifying metatheory twelf theorem prover 
previous experience logical frameworks important 
internal language carefully formulated ensure straightforward representation lf higher order syntax judgements types full advantage :10.1.1.21.5854
methods ensures avoid complications encountered treatment binding operators machinery binding scope provided free lf 
example section dreyer correlated module variables underlying type constructor variables naming convention untenable higher order syntax 
maintained correlation hypothetical judgement 
resolve issue results elegant language 
cases issue variable correlation lf formalization pushed cleaner development 
fortunate 
formalized proof functionality independent staging theorems deals context manner difficult represent lf 
consequently proving functionality required development new proof device twelf adds detour proof 
issue discussed section 
issue fits categories 
progress preservation essential establish inversion properties function type equal non function type equal function types equal domains equal codomains 
obvious facts far trivial prove languages rich notion type equality 
standard ml type system relies formulation type equality things propagates type sharing information module boundaries 
declarative formulation type equality presence singleton kinds captures properties naturally expense making difficult verify inversion properties 
hand algorithmic formulation implementation easy establish inversion space limitations prevent detailing difficulties traced conflict definition formed machine states side conditions typing rules restricting certain terms values 
submitted review 
properties difficult establish key properties including ones apparently simple transitivity 
crucial ingredient canonical forms lemma proof equivalence declarative algorithmic formulations type equality 
result established stone harper proof currently expressed twelf due limits twelf relational metatheory 
consequently necessary develop new syntactic proof watkins technique hereditary substitutions 
issue discussed section 
discussion informal presentation internal language il section 
purposes mean informal presentation english mathematical notation machine checkable form 
follow informal sense account il metatheory section 
discuss il formalization lf section safety proof formalization twelf section 
assume familiarity lf twelf section 
sections assume familiarity methodology lf encoding elementary familiarity twelf meta logic helpful 
full twelf code formalization available www cs cmu edu crary papers 
internal language internal language il semantics explicitly typed calculus dreyer modules formalism enriched variety features encompass full expressive power standard ml 
simplification compared dreyer language eliminate support applicative functors necessary modeling standard ml 
il research contribution nearly construct appears form prior 
consequently discussion summary thorough discussion 
purpose convey scope language set scene discussion formalization 
full technical details included companion technical report 
il structured levels core level consists constructors classified kinds terms classified types constructors kind module level consists modules classified signatures 
layers linked projections extract type term components module 
language designed enforce phase distinction ensures type equality independent term equality arranging admissible type projection immediately determined core language type 
type definitions type sharing relationships managed singleton kinds separable modules contrast translucent sums formalism harper stone semantics 
formalism isolates issues type equality aspects language independent interest application 
particular complications related type equality mentioned overview cleanly isolated rest metatheory 
type abstraction managed effects techniques dreyer crary harper imposition abstraction regarded akin computational effect 
contrast formalism need basic distinction pure impure modules sophisticated classification considered 
reason simply serious difficulties accommodate model languages objective caml 
constructors unit constructor pairs left projection right projection abstraction application unit unit type products functions sums ref tag generative tags tagged tagged expressions recursive types kinds unit kind types singleton kind dependent functions dependent pairs 
constructor kind syntax additional sophistication required semantics standard ml 
core language constructors kinds grammar constructors kinds 
kind classifies types classify terms 
types constructors familiar 
tag tagged types implement standard ml exn type 
singleton kind classifies constructors definitionally equivalent constructor model type definitions type sharing specifications 
singletons create dependencies kinds constructors function product kinds take dependent form respectively 
judgement forms govern constructors kinds formed kind kind 
equivalent kind equivalent kinds 
grammar typing contexts 
constructor equivalence induced rules application projection rules introducing eliminating singleton kinds 
rule singletons called assigns constructor kind singleton evidently precise kind elimination rule singletons permits deduction 
consequently constructor equivalence addition constructs formalization supports orthogonal constructs standard ml anticipation development 
terminology ml type system monotypes arise formalism special case functor signatures 
submitted review 
st ss def def def def sk def sk dom 
higher order singletons extensionality context sensitive 
example kinding assumption 
dependencies constructor equivalence induces non trivial kind equivalence 
addition relation forget type equivalences due singletons 
contains constructor equality closed axiom usual variance rules product sum kinds 
constructor formation equivalence closed kind subsumption 
consequently constructor equivalence kind sensitive 
example identity operator constantly operator equivalent kind kind singleton kinds formed constructors kind lift higher kinds 
give definition higher order singletons extensionality rules key introducing 
example extensionality rule show st 
terms syntax term language 
language terms includes tuples variants isomorphisms recursive types generative tags tagged values 
includes primitives raising handling exceptions tag checking projection dynamic component module 
terms include locations literals tag literals arise execution user programs 
typing judgments terms written context store typing assigns types locations tags 
module level chief technical novelty il module level due dreyer projection operations fst snd 
judgement extracts constructor portion pure module 
dynamic operation projects term portion appropriately typed module 
important note snd ordinary operation fst semantics appear syntax programs 
addition static semantics meta operation signatures mirroring fst written fst extracts kind portion signature 
appear syntax programs 
signatures syntax signatures 
basic forms signature trivial signature signature modules containing single constructor kind locations terms variables unit term pairs left projection right projection fun recursive function application sum intro sum intro case case loc locations ref new dereference assignment tag literals new tag tag tag injection tag check raise raise exception try try handle recursive type intro unroll recursive type elim snd module projection 
term syntax signatures unit signature constructor signature kind signature dependent functions dependent pairs fst fst fst fst fst 
signature syntax def def def def def fst fst 
static part signature fst submitted review 
signature modules containing single term type signatures closed formation dependent functions dependent products 
represent functors sub structures standard ml respectively 
consequently functor signatures partial generative applications regarded impure 

astute reader noticed function product signatures bind constructor variables module variables 
reflection phase distinction standard ml precludes constructors depend terms indirectly modules 
general modules consist static part type constructor dynamic part term 
syntax expresses fact result signature functor depend static part arguments similarly module scope sub module depend static part sub module 
certain forms module modules static part determined type checking 
class modules discussed detail shortly 
static part exists constructor kind determined module signature 
meta level operation fst defined determines kind static part module signature 
rule fst note static part functor signature trivial 
reflection fact standard ml functors generative statically computable static part 
support pure applicative functors static parts functional kinds 
judgement forms governing signatures follows formed signature 
equivalent signatures 
subsignature 
signature equivalence induced constructor kind equivalence 
subsignature relation induced relation usual fashion functor signatures invariant contra covariant left right 
reflect fact intended elaborator employs explicit coercions functor applications il require points 
difficult standard rule il different elaborator 
modules syntax modules consists introductory forms form signature plus additional constructs shall describe shortly 
introductory forms atomic signatures 
elimination form static semantics aforementioned fst 
atomic term modules eliminated snd 
modules product signature introduced pairing eliminated projection modules function signature introduced abstraction eliminated application 
syntax abstraction unusual introduces variables standing argument module static part 
variables sense reason turn happen standard ml signature coercion just dropping type information 
example dynamic fields may dropped polymorphic functions specialized 
modules unit module term module constructor module pairs left projection right projection functor application sealing binding fst 
module syntax fst fst fst fst fst fst fst fst fst fst 
static part module fst implicit correlation face 
shall see section represented lf explicit judgement form 
typing contexts extended accordingly declaration form 
additional constructs sealing module signature impose abstraction written form binding modules syntax reminiscent abstractions 
explicit signature information necessary circumvent avoidance problem 
abstraction enforced effects system classifies modules categories pure impure non 
sealed modules impure functors generative functor applications 
hand module variables pure pairs pure modules 
name suggests modules permit projection type components 
module expression signature fst constructor kind fst representing static part just signatures fst meta level operation constructor forming construct language 
definition case module variable define fst correlated constructor variable note snd may modules having signature fst may module 
meta variable stands purity class module module pure lambda abstractions may considered pure turns importance standard ml functors order generative way incurring effect 
submitted review 
contexts constructor binding value binding module binding heap types type tag typings tag type store types 
contexts store typings heaps stores states 
states stores impure 
typing judgment modules class 
classes ordered pure module may regarded vacuously impure 
states stores standard ml imperative language terms considered store assigns meanings locations 
locations ways il identify cells identify tags implement exn constructors standard ml 
identify cell location mapped value contained cell identify tag location mapped type expected tag 
stores components heap serving purpose tag typing serving 
state il machine consists term module evaluated accompanying store 
syntax states stores figures 
heaps classified heap types stores store types 
tag typings require classifier merely require formed case tag type formed kind judgement forms governing states stores follows formed tag typing 
type 
type 
formed state 
state formed exists store type classifying type similar rule exists typing states module evaluated 
dynamic semantics dynamic semantics core level involves main judgement forms expression value val 
expression raises exception 
transition states 
defined simultaneously analogous judgements module level 
progress theorem proves typed state judgements hold 
note values defined explicit predicate val 
somewhat common define values sub syntactic grammar requires subtyping syntactic classes supported lf 

informal metatheory prove type safety theorem il usual manner 
proof complications arise due dependent typing constructors due stores due interaction evaluation type abstraction modules significantly due singleton kinds 
outline interesting lemmas path proving type safety 
preliminaries baseline property metatheory validity states static semantics deals wellformed entities 
example equal kind individually kind wellformed 
direct proof validity asymmetry definitional equality rules 
example kind follows immediately induction appropriate formation rule true 
need additional fact equal 
induction inversion kind formation gives desired fact appears follow functionality principle 
principle stage carefully state proven validity 
lemma functionality 


third fourth premises dropped validity established lemma validity constructors kinds 






preservation theorem necessary know typing terms modules disturbed allocation new submitted review 
tags 
require lemma expresses weakening respect heap types lemma weakening respect heap types 

dom 
dom 
similar lemma expresses weakening respect tag typings 
aside weakening respect context comes free formalization lf weakening respect store type constituents requires explicit proof 
see formalization treats store type context handled implicitly lf explicit argument term module formation judgement 
modules usual preservation theorem requires substitution lemmas term module values 
term substitution standard statement module substitution account fst lemma module substitution 

fst 
fst note module substitution requires pure constructor component extracted 
construct permits module bound impure require lemma saying module values necessarily pure 
words time ready substitute module permissible effects resolved 
lemma module values pure 
value 
module language dependently typed issue typical dependently typed systems arises cases preservation theorem pertaining application projection pair 
signature depends fst similarly steps need show constructor portions equal 
lemma evaluation preserves fst 
fst fst fst 
inversion case language supporting non trivial notion definitional type equality safety proof requires number inversion properties function type equal non function type equal function types equal domains equal codomains 
example canonical forms lemma key lemma progress states value type form fun difficult prove provided vital feature types type components impure modules 
rule case say pair placed function type virtue 
similarly preservation considering case beta reduction function application need know fun type 
difficult show provided may employ inversion equality function types 
quite number inversion results required quadratic number type primitives 
typical instances follows lemma 
inversion contradiction 
case unit 
case unit 
case 
forth 
lemma 
inversion injectivity 


forth 
il includes transitivity rule constructors obtain results direct inductive proof 
require strategy taming complexity definitional equality 
solution employ equivalent syntax directed presentation type equality 
refer alternative presentation algorithmic equality 
difficult show functional types algorithmically equal non functional types function types algorithmically equal exactly equal domains equal codomains 
remains show algorithmic equality coincides definitional equality 
far story typical languages non trivial notions type equality 
il definitional equality context sensitive recall section making far clear typical reduction account 
satisfactory algorithm devised proven equivalent definitional equality stone harper 
unfortunately stone harper algorithm satisfactory purposes proof currently formalized twelf 
discuss section consequently necessary develop entirely new proof somewhat different algorithm 
space considerations preclude complete discussion new proof 
summarize salient points 
proof watkins technique hereditary substitutions 
formulate canonical presentation singleton kind calculus 
singleton kinds calculus mean kind constructor portions il 
purposes proof remainder il neglected 
canonical presentation requires constructors written canonical form 
key property canonical presentation constructor written way alpha equivalence 
words definitional equality identity 
substitution defined usual manner canonical presentation produce non canonical construc fact fst meta operation syntactic construct key 
canonical forms beta normal eta long include subterms natural kind sense stone harper singleton 
submitted review 
tors 
notion hereditary substitution defined simultaneously substitutes re 
obvious usual properties substitution hold hereditary substitution properties established 
measuring coarsely lines twelf code half 
properties substitution established may show induction derivations equivalence classes constructors singleton kind calculus mapped unique canonical form 
immediately provides equivalence algorithm completeness proof 
soundness remains show constructor equal canonical form proven induction structure canonical form 
type safety inversion established prove canonical forms lemma lemma canonical forms 

val form 
val form 
val ref form loc 

forth 
need prove progress preservation 
theorem progress 

val 
val theorem preservation 

exists extension 
exists extension concludes informal safety proof il 

formalization lf encode il lf usual lf methodology :10.1.1.21.5854
syntax represented higher order syntax semantics judgements types 
basic lf methodology unfamiliar readers referred summaries harper pfenning harper :10.1.1.21.5854
establish notation give declarations type families syntactic classes judgements declarations context blocks 
formalization goes smoothly leaving little worth remarking 
points raise interesting issues shed light presentation 
points store type static semantics kd type 
kinds cn type 
constructors sg type 
signatures tm type 
terms md type 
modules ht type 
heap type tt type 
tag typing st type 
heap pty type 
purity level kd wf kd type 
cn kd type 
kd deq kd kd type 
kd sub kd kd type 
cn deq cn cn kd type 
fst sg sg kd type 
fst def fst md md cn type 
fst sg wf sg type 
sg deq sg sg type 
sg sub sg sg type 
ht tt tm cn type 
ht tt pty md sg type 
st ht tt type val tm tm type 
val val md md type 
val raises tm tm tm type 
raises md md tm type 
step tm tm st tt tm st tt type 
step md md st tt md st tt type 
heap type tag typing repeated times informal system 

encoding lf type families terms modules matter variables arising formalization fst operation modules 
store types term module typing informal system follow standard practice write store type left turnstile term module typing judgements 
store typing truly context sense collection alpha convertible assumptions 
store typing indicates world discourse relative term module considered 
accordingly il context identified lf context usual store type included explicitly typing judgements terms modules 
account morrisett suggests attempted adapt approach 
submitted review 
block block kd block cn da 
block block cn block tm dx assm tm 
block block sg kd block md ds assm md cn da fst md 

encoding lf context blocks technical convenience heap type tag typing supplied separate parameters 
explicit store type term module variable assumptions 
typical il store evolves monotonically assumption ref provides usable value just current store stores 
put concretely variable assumptions specific store types lemma hold 
terminology modal logic variable assumptions necessary 
consequently judgement terms modules left variable assumptions different right 
left assumption judgement store type parameter assm tm tm cn type 
assm md md sg type 
assumption judgements tied typing judgements hypothesis rules var ht tt assm tm var ht tt pty assm md note store type rules unconstrained 
sound invariant type system value substituted variable value typed relative current store 
invariant typical type systems ml languages rarely considered explicitly 
variables key technical point design il constructor kind language may considered independently 
particular syntactic class modules 
clearly necessary constructors able refer module assumptions 
harper resolved apparent contradiction allowing constructors refer directly module variables 
constructor module variable written refers constructor portion module represented device borrowed dreyer type theory il 
device poses problem formalization license lf take variable type md type cn 
hand explicit construct adding md cn 
introduce exactly dependence constructors modules wish avoid 
decided binding module variable introduces variables module variable constructor variable representing fst part 
maintain connection variables convention spelling harper dreyer spelling convention violence alpha convertibility incompatible lf 
discussed earlier section explicitly binding occurrences bind distinct variables may freely alpha varied 
signatures care module constructor portion bind constructor variable 
design obvious retrospect took pressure formalization lf lead 
example functors module lambdas encoded md lam sg cn sig md cn md md argument functor domain second codomain depend constructor portion argument third body depend argument constructor portion 
introduced cleanly maintain pairing module constructor variables hypothetical judgement 
type fst md recall represents judgement fst expressing relationship module constructor portion 
introduce variables simply introduce fst md hypothesis time 
example typing rule functors md lam ht tt pty md lam sg pi fst sg sg wf md assm md cn fst md ht tt 
typing body functor addition introducing variables signature kind introduce assumption type fst md indicating constructor portion resulting block assumptions added context typing body block 

verification twelf verified il metatheory twelf meta logical framework 
twelf methodology unfamiliar readers referred summaries crary sarkar harper pfenning increasing order detail 
developed il metatheory devised appropriate formalization il lf process verifying metatheory twelf went smoothly part 
interesting issues arise discuss 
possible typing rule ensure module variables twelf subordination relation affected unclear advantage receive separation 
case better idea 
submitted review 
functionality explicit contexts functionality lemma lemma expressed twelf takes form funct kd wf cn kd wf cn deq outputs kd deq type 
mode funct kd wf 
difficulty appears argument 
argument refers derivation kd wf permitted depend cn furthermore refer variables residing context 
note variables context refer variable entire scope argument 
words implicit theorem statement fact appears context 
satisfactory uses lemma strong induction hypothesis proof go 
rule adds new assumption context break invariant new assumptions general moved constructors dependently kinded 
consequently necessary strengthen induction hypothesis variable interest need appear 
expressing strengthened hypothesis lf requires novel device call explicit contexts 
idea formulate alternative formalization il contexts explicit identified lf context usual 
precisely reformulate static semantics constructors kinds signatures terms modules bearing require functionality lemma right 
importantly alternative formalization changes static semantics syntax remains unchanged 
explicit system talking objects original system 
example constructor formation formalized explicit system judgement cxt cn kd type 
contexts formalized simply lists assumptions cxt type 
cxt nil cxt 
cxt cons cxt cn kd cxt 
explicit system prove functionality direct proof induction 
prove explicit system equivalent standard implicit context system 
explicit system wish little possible 
certainly wish entire verification 
consequently judgement prove implication explication theorem 
example implicate closed cxt nil type 
mode implicate closed 
explicate closed cxt nil type 
mode explicate closed 
note explication theorem produces derivation empty explicit context 
access lf context 
need functionality non empty contexts 
explicit context system formulated refer implicit lf context explicit 
practice explicit context bindings accumulated proof implicit context pre existing bindings 
evaluation contexts course proving preservation modules need establish lemma regarding beta reduction module pairs lemma 


proof lemma complicated extensionality rule modules recall section similar rule constructors rule possible module question grow addition projections consider smaller derivations 
consequently necessary strengthen induction hypothesis lemma 
evaluation contexts defined 




exists 
evaluation contexts lf observation evaluation context simply lf function type md md judgement restrict attention members type represent evaluation contexts psi md md md type 
psi md eps psi md 
psi md pj psi md md pj psi md psi md pj psi md md pj psi md definition hand may state induction hypothesis 
example clause module beta pj psi md ht tt md pj md pair outputs ht tt type 
mode module beta pj 
subderivations various places proof utilize subderivation lemmas judgement asserted derivable subderivation input derivation 
example lemma arises proving canonical forms modules submitted review 
lemma 
derivable exist derivable subderivation 
arises module value signature sum wish show pair 
prove directly induction extensionality rule mentioned possible ascribe signature virtue ascribing signatures 
lemma show exists subderivation gives sum signature proceed induction 
subderivation requirements expressed twelf reduces directive md pj ht tt md pj outputs ht tt sg sgm pty sub type 
mode md pj 
proof 
reduces md pj 
reduces directive causes twelf check output derivation subderivation input 
information automatically twelf theorem checker checks inductions valid 
inversion discussed section crucial component metatheory collection inversion lemmas constructors proved algorithmic presentation definitional equality 
core inversion arguments proof algorithm sound complete definitional equality 
prior stone harper gave algorithm singleton kind calculus proved sound correct 
unfortunately possible utilize proof relied crucially logical relation 
twelf theorem takes form logic program accompanied mode declaration indicating parameters inputs outputs 
twelf theorem simple implication universally quantified collection inputs existentially quantified collection outputs 
particular possible nest implications left right 
method logical relations requires arbitrary nesting implication left right way express logical relations argument twelf meta logic 
consequently necessary develop syntactic proof correctness algorithm singleton kind calculus 
proof summarized previously section 
proof formalization heavy explicit context technique section establishing properties hereditary substitution reasons similar motivated functionality 

establishes new high water mark verification safety programming languages 
safety proofs sch rmann suggested logical relations argument formulated twelf reflecting logical relation object language technique appear generalize stone harper proof 
exist various core calculi existed full scale programming language due daunting complexity languages 
languages settled general agreement language core aspects studied carefully errors exist language minor 
unsurprising numerous minor errors uncovered supposedly type safe languages 
aim place standard ml solid footing core calculus techniques semantics mechanical verification twelf deal complexities full scale programming language 
proof type safety internal language equivalent expressive power standard ml 
remains ongoing define elaboration standard ml internal language lines suggested harper stone 
acknowledgments michael ashley sarkar help mechanization harper stone il derek dreyer advice design internal language kevin watkins suggesting applying hereditary substitutions metatheory singleton kinds 
barendregt 
lambda calculus syntax semantics 
elsevier 
karl crary sarkar 
foundational certified code metalogical framework 
nineteenth international conference automated deduction miami florida 
extended version published cmu technical report cmu cs 
luis damas robin milner 
principal type schemes functional programs 
ninth acm symposium principles programming languages pages albuquerque new mexico january 
derek dreyer 
understanding evolving ml module system 
phd thesis carnegie mellon university school computer science pittsburgh pennsylvania may 
derek dreyer karl crary robert harper 
type system higher order modules 
thirtieth acm symposium principles programming languages pages new orleans louisiana january 
derek dreyer robert harper manuel chakravarty gabriele keller 
modular type classes 
technical report tr university chicago april 
sophia drossopoulou susan eisenbach 
operational semantics proof type soundness java 
formal syntax semantics java 
springer verlag march 
sophia drossopoulou susan eisenbach 
java type soundness revisited september 
technical report imperial college london 
michael gordon tom melham 
hol theorem proving environment higher order logic 
cambridge university press 
robert harper 
simplified account polymorphic 
information processing letters 
follow note information processing letters 
robert harper furio honsell gordon plotkin :10.1.1.21.5854
framework defining logics 
journal acm january 
robert harper daniel 
mechanizing language definitions 
submitted publication april 
robert harper mark lillibridge 
type theoretic approach higher order modules sharing 
acm symposium submitted review 
principles programming languages pages portland oregon january 
robert harper john mitchell eugenio moggi 
higher order modules phase distinction 
seventeenth acm symposium principles programming languages pages san francisco january 
robert harper chris stone 
type theoretic interpretation standard ml 
proof language interaction essays honour robin milner 
mit press 
extended version published cmu technical report cmu cs 
klein tobias nipkow 
machine checked model java language virtual machine compiler 
technical report national ict australia sydney march 
daniel lee karl crary robert harper 
mechanizing metatheory standard ml 
technical report cmu cs carnegie mellon university school computer science 
xavier leroy 
manifest types modules separate compilation 
acm symposium principles programming languages pages portland oregon january 
xavier leroy 
applicative functors fully transparent higherorder modules 
second acm symposium principles programming languages san francisco january 
robin milner mads tofte robert harper david macqueen 
definition standard ml revised 
mit press cambridge massachusetts 
greg morrisett matthias felleisen robert harper 
models memory management 
conference functional programming languages computer architecture pages la jolla california june 
lawrence paulson 
foundation generic theorem prover 
journal automated reasoning 
leaf petersen 
compilation standard ml type analysis framework 
phd thesis carnegie mellon university school computer science pittsburgh pennsylvania 
leaf petersen perry cheng robert harper chris stone 
implementing tilt internal language 
technical report cmu cs carnegie mellon university school computer science december 
frank pfenning 
computation deduction 
lecture notes available electronically www cs cmu edu twelf 
frank pfenning carsten sch rmann 
twelf user guide version 
available electronically www cs cmu edu twelf 
brigitte frank pfenning 
termination reduction checking logical framework 
workshop automation proofs mathematical induction june 
benjamin pierce martin steffen 
higher order subtyping 
theoretical computer science 
benjamin pierce 
types programming languages chapter 
mit press 
gordon plotkin 
structural approach operational semantics 
technical report daimi fn university aarhus 
jeffrey carsten sch rmann 
proof theoretic account logical relations 
submitted publication 
christopher stone 
singleton kinds singleton types 
phd thesis carnegie mellon university school computer science pittsburgh pennsylvania august 
christopher stone robert harper 
extensional equivalence singleton types 
acm transactions computational logic 
appear 
earlier version appeared symposium principles programming languages 
tarditi morrisett cheng stone harper lee 
til type directed optimizing compiler ml 
sigplan conference programming language design implementation pages may 

machine assisted proof programming language properties 
phd thesis university pennsylvania philadelphia pennsylvania may 
kevin watkins cervesato frank pfenning david walker 
concurrent logical framework propositional fragment 
berardi coppo damiani editors types proofs programs volume lecture notes computer science pages 
springer verlag 
papers third international workshop types proofs programs april torino italy 
submitted review 

