effects context program slicing jens krinke hagen fachbereich und hagen germany context sensitive program analysis effective context insensitive analysis ongoing discussion 
evidence context sensitivity matters complex analyses pointer analysis program slicing 
empirical data shows contextsensitive program slicing precise circumstances faster context insensitive program slicing 
article add discussion examining context matters context leads precise slices context 
experiments show strongly dependent structure programs 
experiments require backward slices return call sites specified call stack 
call stacks seen poor man dynamic slicing concrete execution call stack captured static slices restricted captured stack 
experiments show recursive programs large increase precision restricted form slicing compared unrestricted traditional slicing 
experiments show large part half average slice due called procedures 
key words program analysis program slicing slice extracts statements program potentially influence specific statement interest slicing criterion 
originally slicing defined weiser approach compute slices iterative data flow analysis 
main approach slicing uses reachability analysis program dependence graphs pdgs 
program dependence graphs mainly consist nodes representing statements program control data dependence edges article appears journal systems software 
original publication available dx doi org jss preprint submitted elsevier science june control dependence statement nodes exists statement controls execution statements 
data dependence statement nodes exists definition variable statement reach usage variable statement 
slice computed simple steps map slicing criterion node find backward reachable nodes map reached nodes back statements 
extension pdg interprocedural programs introduces nodes edges procedure procedure dependence graph constructed basically pdg formal nodes formal parameter procedure 
procedure call represented call node actual nodes actual parameter 
call node connected entry node call edge actual nodes connected matching formal nodes parameter edges actual nodes connected matching formal nodes parameter edges 
graph called interprocedural program dependence graph 
system dependence graph sdg summary edges actual actual added representing transitive dependence due calls :10.1.1.50.4405
slice programs procedures perform reachability analysis sdgs 
resulting slices accurate calling context preserved algorithm may traverse parameter edge coming call site procedure traverse edges traverse edge going different call site 
sequence traversed edges path unrealizable path impossible execution called procedure return call site 
consider interprocedural slice precise nodes included slice reachable criterion realizable path 
precise interprocedural slices efficiently computed pass algorithm relies summary edges :10.1.1.50.4405
section discuss empirical results related contextsensitive program slicing compares context insensitive slicing 
section contains new form program slicing restricts slice follow specified calling context 
approach experiments section argue context sensitivity context 
results experiments explained section draws 
previous results debate increased precision worth increased complexity context sensitive program analysis 
final program analysis differs 
pointer analysis context sensitive contextinsensitive analyses exist authors claim context sensitive pointer analysis expensive small increase precision 
case different program slicing large experiments pdg program slicing shown context sensitive slicing precise faster context insensitive slicing 
done agrawal guo results stating context sensitive slicing faster precise context insensitive slicing 
results doubtful approach shown incorrect slices small second large study performed krinke :10.1.1.20.2969
krinke experiments showed context sensitive slicing style horwitz precise context insensitive slicing 
average slices computed context insensitive slicing algorithm larger ones computed context sensitive algorithm 
context insensitive algorithm slower average needs time 
third large scale study performed binkley harman similar results large set test cases 
algorithm pdgs uses original pass algorithm implemented codesurfer slicing tool :10.1.1.50.4405
results showed context insensitive slices average larger context sensitive counterparts 
results directly comparable krinke results different ways measure slice sizes results similar 
results pdg slicing contradict ones weiser style slicing 
weiser style algorithm data flow equations contextsensitive slicing expensive 
experiments atkinson mock show unlimited context sensitive weiser style slicing affordable mock limit depth considered context 
means slicing algorithm returns chain call sites correct call site context insensitive 
limited conducted experiments show large increase precision 
results contrast experiments done pdg slicing 
krinke experimented pdg slicing algorithms rely explicit context sensitivity handle similar weiser style algorithms :10.1.1.20.2969
performed experiments limit depth context similar approach mock analysis context sensitive stack frames context insensitive rest 
assess results limited context krinke compared size computed slices ones computed contextinsensitive unlimited context sensitive algorithm 
considered size slices computed context insensitive algorithm precision size slices computed unlimited context sensitive algorithm precision 
experiments done different limits reported increasing numbers precision 
example limit analysis context sensitive current stack frame results average precision limit reaches precision 
krinke results experiment sup ports mock atkinson results slicing algorithms handle calling context explicitly expensive large contexts procedure analyzed calling context procedure 
pdg slicing uses algorithms similar horwitz procedure analyzed twice :10.1.1.50.4405
binkley defines calling context slices include statements influence criterion specific calling context calling context 
algorithm regression test selection optimization 
binkley report empirical data algorithms 
algorithm similar imprecise shown section 
context restricted slicing results pdg slicing studies suggest context matters slicing algorithms context sensitive algorithms enhanced precision decreased computation time 
may lead assumption context reason precision 
leads creation poor man dynamic slicer 
debugging programmer interested possible executions specific want find program crashed certain point 
static slicing consider specific execution possible executions suit debugging tasks 
dynamic slicing developed computes slices specific particular execution 
restriction dynamic slices precise static slices 
computation dynamic slices expensive necessary information computed execution statement time needed compute dynamic slices dependent length execution size program static slicing 
ready dynamic slicer available 
rely available static codesurfer sprite unravel 
results scenario crashed program debugged normally extract current call stack leads crash 
simple adaptation slicing algorithm force computed slice follow extracted call stack requiring called procedures return calling procedure call stack 
revisit formal definitions interprocedurally realizable paths adapt definitions context restricted interprocedurally realizable paths 
program analysis context sensitive considers interprocedurally realizable paths 
way describe paths context free language reachability done reps intraprocedural program dependence graph seen finite automaton realizable paths words accepted language 
reachability program dependence graph instance regular language reachability 
problem interprocedural reachability proper matching call edges return edges 
achieved defining context free language top 
assume call actual parameter nodes marked label call site edges marked source target nodes call edges call node call site node procedure marked 
parameter edges actual parameter node call site formal node procedure marked 
parameter edges formal node procedure actual node call site marked 
edges marked 
set edge labels path induces word concatenating labels edges path 
path interprocedurally matched path word context free language defined mm cm grammar assures proper matching calls returns simulating call stack 
interprocedurally matched paths require start node procedure 
interprocedurally realizable paths start node different procedures partially matching calls returns dependent node lower higher call stack paths right balanced left balanced 
path interprocedurally right balanced path word context free language defined rr properly matched left converse need hold 
path interprocedurally left balanced path word context free language defined ll interprocedurally realizable path starts left balanced path ends right balanced path lr interprocedural reachability nodes pdgs context sensitive slices defined interprocedurally realizable paths definition interprocedural reachability node interprocedurally reachable node iff interprocedurally realizable path exists denoted noted earlier consider interprocedural slice precise nodes included slice may reach criterion interprocedurally realizable path definition slice backward slice node consists nodes transitively depends interprocedurally realizable path definitions algorithm directly impractical check paths interprocedurally realizable 
accurate slices calculated modified algorithm sdgs benefit sdgs presence summary edges represent transitive dependence due calls :10.1.1.50.4405
summary edges identify actual nodes reachable actual nodes interprocedurally realizable path called procedure analyzing 
idea slicing algorithm summary edges slice criterion ascending calling procedures traverse paths slice visited nodes descending called procedures 
restrict interprocedurally realizable path call stack call stack represented list call sites ci 
ck path matches call stack word context free language induced 
ck ck ck ck 
ck requires path return chain call sites call stack matching call 
definition context restricted slice backward slice node restricted call stack consists nodes transitively depends interprocedurally realizable path matches call stack denotes exists interprocedurally realizable path matching note context restricted slice requires criterion procedure called topmost call site ck 
ck algorithm computes context restricted slice 
variant krinke context sensitive slicing algorithm variant horwitz algorithm utilizes summary edges :10.1.1.20.2969
pass computes slices stopping parameter call edges changed repeated call site ci specified call stack 
iteration node reachable intraprocedural edges added list parameter edge traversed reached node added list processed second pass 
parameter call edges traversed reached node part current call site ci 
case reached node added list initial list iteration processes call site ci 
intraprocedural edges traversed current iteration 
passes matched definition context free language restricted interprocedurally realizable paths pass basically traverses paths ck ck ck skips summary edges 
second pass traverses paths horwitz algorithm 
algorithm fig 
computes context restricted slices defined identical binkley calling context slices 
algorithm basically computes slice ascending pass call input sdg slicing criterion ci 
ck call stack output slice criterion pass ascending slice 
handle calling context site site list empty remove element list foreach parameter edge po delay traversal second pass elsif parameter call edge pi cl call site ci traversal continue iteration second pass descending slice list empty remove element list foreach parameter call edge pi cl return set visited nodes fig 

context restricted slicing sdgs site calling context starting criterion descending second pass slice computed ignoring edges lead calling procedure traversing edges lead called procedures 
reached formal nodes extracted computed slice mapped corresponding actual nodes call site current calling context ascending step 
call site removed calling context set actual nodes slicing criterion iteration repeated calling context empty 
algorithm imprecise mixes descending ascending steps 
consider example int main return int 
return corresponding pdg shown 
compute backward slice variable line node calling context represents invocation runtime system 
binkley algorithm starts computing slice traverses parameter edge nodes due recursive call function nodes 
extracts formal node line maps actual node line current call site 
subsequent iteration adds nodes line slice 
line slice line influence line 
algorithm starts iteration node context encounters parameter edge nodes due recursive call delays traversal second pass 
encounters call edge nodes delays traversal second iteration 
iteration inserts nodes slice 
iteration call site continues node adds nodes slice 
interprocedural edges encountered calling context completely traversed pass complete 
second pass starts node adds nodes slice 
encountered interprocedural edges ignored second pass complete 
final slice consists nodes 
include line node 
evaluation call int main call int 
intraprocedural control dependence intraprocedural data dependence summary transitive dependence edge main interprocedural dependence control data fig 

pdg example implemented algorithm fig 
slicing infrastructure performed initial experiment validate approach context restricted slicing :10.1.1.20.2969
initial experiment 
larger evaluation follows contrasts results initial experiment 
ctags patch unique stacks slices average size context sensitive slice average size context restricted slice average size context sensitive slice average size context restricted slice average size reduction table average sizes context sensitive restricted slices initial experiment initial experiment performed case studies programs ctags patch 
programs performed characteristic execution debugger 
execution procedure dumped extracted current call stack 
ck call main runtime system ck call site called currently executing procedure 
produced set call stacks program execution 
computed backward slices formal parameter node intercepted procedure call stack 
computed slice twice context restricted slicing traditional context sensitive slicing 
results shown table test cases ctags left column patch right column 
rows show number unique call stacks extracted test execution number computed slices 
remaining rows show average slice size measured sdg nodes percentage sdg 
results confirm expected effect context restricted slices higher precision context sensitive slices scenario 
context restricted slice smaller ctags context sensitive slice percentage complete program just decreases 
test patch average size context restricted slice just smaller difference percentage complete program negligible 
question just small size reduction 
hypothesis related unrestricted called procedures 
context restricted slices restrict calling context calling procedures call stack active procedures 
context called procedures restricted long called procedures handled context sensitively calls happened formal nodes omit effects current procedure maximize differences restricted non restricted slices 
ctags patch average size context sensitive slice average size context restricted slice average size context sensitive slice average size context restricted slice average size reduction table average sizes truncated slices current call stack called procedures longer active 
believe large part average slice due called procedures 
investigate repeated experiment truncated backward slicing 
truncated backward slice contain nodes called procedures descend 
compute second pass slicing algorithm left computes exactly nodes 
truncated backward slice computed ignoring parameter edges process called procedures backward traversal 
algorithm adapted truncated version accordingly remove second pass branch elsif cascade 
modification repeated experiment table shows result 
see average truncated slice smaller non truncated slice 
ctags size went nodes sdg reduction patch went nodes reduction 
illustrates majority nodes slice nodes called procedures experiment section support observation 
numbers context restricted slices support hypothesis ctags context restricted slice average half size context sensitive slice patch smaller 
expected larger reduction observation ctags determined average procedure called different call sites patch measured different call sites 
measured average size call stacks ctags patch 
numbers suggest context sensitive truncated slice visit procedures context restricted 
values suggest alternative call stacks lead specific point execution 
examine effect detail performed larger evaluation 
loc proc 
nodes edges summary agrep assembler bison cdecl compiler ctags diff flex football patch simulator average table details test programs second experiment initial experiment performed larger evaluation programs previous evaluations 
details analyzed programs shown table 
programs stem different sources ctags patch diff gnu programs 
rest benchmark database analysis framework 
loc column shows lines code measured wc proc column amount procedures number entry nodes pdg nodes edges columns show number nodes edges 
summary column contains number summary edges corresponding sdg give impression effect calling context 
column gives percentage edges summary edges 
goal check validity results initial experiment slicing 
larger scale evaluation possible approach initial experiment evaluation done differently 
extracting call stacks executions generated possible call stacks static call graph programs 
recursive programs causes problem depth assembler stacks slices avg 
rest 
avg 
size reduction cdecl stacks slices avg 
rest 
avg 
size reduction patch stacks slices avg 
rest 
avg 
size reduction simulator stacks slices avg 
rest 
avg 
size reduction table context restricted vs traditional slicing non recursive programs infinite number possible call stacks 
limit depth generated call stacks calls ignored predefined depth reached 
selected formal nodes procedure reached current call stack slicing criteria 
tables show results evaluation non truncated slicing groups 
program rows row contains number generated call stacks depths 
second row shows number computed slices 
third row gives bison ctags flex table context restricted vs traditional slicing simple recursive programs average size context restricted slices fourth row average size traditional slices 
fifth row gives size reduction percentage 
football possible compute slices depth due combinatorial explosion call stacks numbers approximations computed fraction possible slices depths 
set programs separated groups group non recursive pro agrep mio mio mio mio mio compiler mio mio mio mio diff mio table context restricted vs traditional slicing complex recursive programs grams assembler cdecl patch simulator group recursive programs 
second group split subgroups group consists programs recursive component contains single recursive call recursive component may consist multiple procedures procedure called outside component identified source recursion 
group consists programs complex recursion structure 
separation important group properties football mio mio mio mio mio mio mio mio table context restricted vs traditional slicing complex recursive programs continued influence evaluation 
group non recursive programs generate possible call stacks depth limit large 
effects certain depth number generated call stacks constant assembler maximal depth cdecl patch simulator 
group recursive programs single recursive call recursive component called simple recursive programs possible generate call stacks 
certain depth reached increase number call stacks linear added level depth adds constant number call stacks 
group consists bison ctags flex 
group complex recursive structures called complex recursive programs problematic analysis increase polynomial 
reason added level depth number call stacks multiplied number recursive calls 
group consists agrep compiler diff football 
non recursive programs group non recursive programs fig 
shows gain precision context restricted slicing comparison non truncated unrestricted slicing dependent predefined depth call stacks 
axis shows smaller average restricted slice percentage average unrestricted slice 
axis predefined depth ranging call stack depth depth 
depth difference fig 

size reduction non recursive programs call stack consists single call runtime system main procedure 
programs increasing size reduction constant predefined depth exceeds largest possible call stack depth programs assembler maximal depth cdecl patch simulator 
programs small gain assembler patch simulator 
fourth program cdecl larger gain 
interesting see patch initial experiment gain larger 
shows program parts patch executed initial part program sensible context restricted slicing executed parts 
simple recursive programs fig 
shows gain precision simple recursive programs 
interesting see programs identical gains size reduction flex bison 
interesting note programs similar applications scanner generator parser generator 
programs large gains size reduction larger depths 
recursive components dominate numbers number non recursive call stacks small comparison recursive call stacks programs contain recursive components average restricted slice smaller average unrestricted slice 
different programs 
program ctags slow increase size reduction 
call stack depth average size reduction 
note larger initial experiment 
notable simple recursive program 
steep decrease size reduction larger call stack depths similar size reduction ctags large depths 
indicates small difference size re fig 

size reduction simple recursive programs fig 

size reduction complex recursive programs unrestricted slices ctags recursive components 
effect recursive components dominate 
complex recursive programs fig 
shows gain precision group complex recursive programs 
polynomial number generated call stacks possible analyze programs certain predefined depth 
analyses take time larger depths 
results quite similar results simple recursive programs 
programs decreasing size reduction dominating effect recursive struc tures causes size reduction increase 
possible predict diff larger smaller size reduction larger depths 
interpretation results data suggests previous results initial experiment contrast results larger evaluation 
things consider initial experiment programs turned small average size reduction anyway 
programs patch ctags smallest average size reduction group 
second large evaluation clearly shows strong effect chosen call stack slicing criterion results restricted slicing 
suggests call stacks criteria practice different properties artificially generated call stacks criteria 
example program contains function pointers artificially generated call stacks occur practice 
research study effects differences artificially generated really occurring call stacks 
truncated slicing larger evaluation confirms second part initial experiment drawn 
table shows comparison average sizes non truncated truncated slices 
computed program non truncated truncated slices formal parameter criterion 
columns shows name program second number nodes sdg third number computed slices 
columns show average size non truncated slice number nodes slice percentage nodes 
truncated slices columns 
columns presents absolute relative difference 
easy see truncated slices smaller non truncated slices 
size reduction ranges football simulator 
large size reduction truncated slicing claim large share half average slice due called procedures calling procedures holds 
approach context restricted slices efficiently implemented current static slicing tools pdgs 
debugging slicing poor man dynamic slicer 
cases nodes slices non truncated truncated abs 
rel 
avg 
size avg 
size agrep assembler bison cdecl compiler ctags diff flex football patch simulator average table comparison non truncated truncated slices context restricted slice significantly smaller traditional slice 
truncated slices size reduction larger 
plan integrate experiment light weight approaches approximate dynamic slicing captures statement corresponding node pdg executed call mark slicing captured procedure executed 
experiments add aspect discussion contextsensitive context insensitive program analysis 
program slicing earlier studies showed evidence context sensitive slicing algorithms precise faster context insensitive counterparts 
experiment shows restricting slices specific contexts leads significant smaller slices 
additionally results valid context plays different role object oriented programming languages expect stronger results languages 
acknowledgments 
david binkley provided valuable comments 
weiser program slices formal psychological practical investigations automatic program abstraction method ph thesis university michigan ann arbor 
weiser program slicing ieee trans 
softw 
eng 

ferrante ottenstein warren program dependence graph optimization acm trans 
prog 
lang 
syst 

horwitz reps binkley interprocedural slicing dependence graphs acm trans :10.1.1.50.4405
prog 
lang 
syst 

hind pointer analysis international symposium software testing analysis pp 

hind pointer analysis haven solved problem acm sigplan sigsoft workshop program analysis software tools engineering paste 
agrawal guo evaluating explicitly context sensitive program slicing workshop program analysis software tools engineering pp 

krinke evaluating context sensitive slicing chopping proc :10.1.1.20.2969
international conference software maintenance pp 

reps horwitz sagiv speeding slicing proceedings acm sigsoft symposium foundations software engineering pp 

binkley harman large scale empirical study forward backward static slice size context sensitivity international conference software maintenance pp 

anderson teitelbaum software inspection codesurfer workshop inspection software engineering cav 
atkinson griswold design program analysis tools proceedings th international conference software engineering pp 

mock atkinson chambers eggers improving program slicing dynamic points data proceedings th international symposium foundations software engineering 
binkley semantics guided regression test cost reduction ieee trans 
softw 
eng 

korel laski dynamic program slicing information processing letters 
lyle wallace unravel program slicing tool evaluate high integrity software proceedings software quality week 
reps program analysis graph reachability information software technology 
krinke snelting validation measurement software application slicing constraint solving information software technology 
krinke advanced slicing sequential concurrent programs ph thesis universit passau apr 
krinke context sensitivity matters context proc 
ieee international workshop source code analysis manipulation pp 

ryder landi philip stocks zhang schema interprocedural modification side effect analysis pointer aliasing acm trans 
prog 
lang 
syst 

agrawal horgan dynamic program slicing proceedings acm sigplan conference programming language design implementation pp 

inoue call mark slicing efficient economical way reducing slice international conference software engineering pp 


