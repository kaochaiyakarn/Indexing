efficient evaluation xquery streaming data growing popularity xml emergence streaming data model processing queries streaming xml important topic 
presents new framework set techniques processing xquery streaming data 
compared existing supporting xpath xquery data streams contributions 
propose series optimizations transform xquery queries correctly executed single pass dataset 

methodology determining xquery query possibly transformations introduce correctly executed single pass dataset 

describe code generation approach handle xquery queries user defined aggregates including recursive functions 
aggressively static analysis generate executable code require query plan interpreted runtime 
evaluated implementation xmark benchmarks xquery queries driven real applications 
experimental results show compared open saxon galax system faster xmark queries small datasets significantly faster xmark queries larger datasets order magnitude faster queries driven real applications systems permission copy fee part material granted provided copies distributed direct commercial advantage vldb copyright notice title publication date appear notice copying permission large data base endowment 
copy republish requires fee special permission endowment 
proceedings st vldb conference trondheim norway li agrawal department computer science engineering ohio state university columbus oh agrawal cse ohio state edu transform execute single pass executes queries efficiently large datasets systems memory overflows 
xml flexible exchange format gained popularity representing classes data including structured documents heterogeneous semi structured records data scientific experiments simulations digitized images 
result querying xml documents received attention 
time new model data processing emerged database community 
data model data arrives form continuous streams usually data collection instruments long running computer simulation 
data needs analyzed real time single pass data 
important applications classes protecting network security monitoring critical infrastructure analyzing stock business data monitoring climate environment involve analysis streaming data 
developments processing querying xml streams important topic 
believe important trends contribute need processing xml streams 
related distributed grid processing 
rapid improvements technologies wide area networking wan evidenced example national lambda rail nlr effort 
result data transmitted faster stored accessed disks cluster streaming model gaining popularity 
time xml widely adapted web distributed grid computing 
second development popularity virtual xml xml logical view low level data formats flat file bioinformatics data network data query process virtual xml data streams xquery designed ideal language declarative nature powerful features 
please see www org slides pdf xquery high level language sql supports advanced complex features types recursive functions 
xquery allows user defined functions key specifying type processing required streaming data 
currently limited query evaluation xml streams handles xpath fragments :10.1.1.9.2861
compared xpath xquery significantly expressive challenging handle 
techniques proposed processing xquery queries streaming data :10.1.1.10.6782
transducer networks handle small subset xquery join node creation operations allowed 
flux hand uses static analysis optimize buffer size 
important limitations efforts 
handle aggregation functions believe critical specifying type analysis done streaming data 
second query transformations techniques reduce number traversals important enabling larger number queries executed correctly streaming data 
presents new framework set techniques processing xquery streaming data 
compared existing supporting xpath xquery data streams contributions cases direct translation xquery query requires multiple passes data query transformed correctly execute single pass 
techniques enabling transformations 
model dependencies query representation refer stream data flow graph 
apply series high level transformations including horizontal vertical fusion 
techniques enable larger number queries evaluated correctly streaming data efficiently large dataset 
furthermore transformations reduce workload query programmer rewrite query manually execute correctly streaming data 
stream data flow graph methodology determine query evaluated correctly single pass 
enables avoid generating query evaluation plan going fail user feedback sooner 
best knowledge system xquery engine streaming data support aggregates including user defined recursive functions 
intermediate representation called generalized nested loops gnl propose low level transformation techniques aggregation rewriting recursion analysis optimize aggregations 
propose new technique generate efficient streaming code gnl representation 
implemented framework techniques 
evaluated implementation xmark benchmarks xquery queries driven real applications 
experimental results show compared open saxon galax system faster xmark queries small datasets significantly faster xmark queries larger datasets order magnitude faster queries driven real applications systems transform execute single pass executes queries efficiently large datasets systems memory overflows 
rest organized follows 
motivating application described section 
problem described section 
high level analysis including stream data flow graph horizontal vertical fusion techniques analysis determine query executed correctly streaming data section 
low level analysis code generation section 
experimental evaluation section 
compare related research efforts section conclude section 
motivating application unordered minx maxx miny maxy stream data pixel return pixel accumulate summary pixel declare function accumulate double summary inp inp band inp band div inp band inp band return fn empty fn max accumulate fn subsequence satellite data processing expressed xquery section describe application refer satellite data processing 
show expressed xquery issues involved transforming executing correctly streaming data 
application involves processing data collected continuously satellites creating composite images 
satellite orbiting earth collects data sequence pixels 
pixel characterized spatial coordinate latitude longitude time coordinate 
satellite contains sensors different bands 
pixel captured satellite stores latitude longitude time bit measurements bands 
typical computation satellite data follows 
portion earth specified latitudes points 
point earth specified area available pixels corresponding different time values scanned application dependent output value computed 
produce value application perform computation input bands produce output value input value multiple output values point planet combined reduction operation 
instance normalized difference vegetation index computed bands correlates position surface earth 
combining multiple values consists execution max operation finding value particular position 
xquery specification processing shown 
code iterates dimensional space output desired 
order points processed important directive unordered 
iteration nested loop statement create sequence pixels correspond spatial coordinates 
desired result involves finding pixel best value 
xquery reduction computed recursively 
computations performed obtain output value spatial coordinate associative commutative 
cases computations performed correctly streaming data 
pixel received find spatial coordinate corresponds update output value spatial coordinate 
direct translation xquery specification shown require multiple scans entire dataset 
clearly desirable streaming xquery processor transform query execute correctly single pass entire dataset 
challenges 
systematically correctly transform xquery query executed streaming data possible 
determine xquery query possibly transformations executed correctly single pass entire dataset 
generate efficient code query shown view user defined recursive function involves 
address challenges rest 
preliminaries section describes data evaluation model 
introduce notion progressive blocking operators describe problem 
evaluation model assume length incoming xml stream exceeds capability storing 
investigate possibility obtaining exact query results single pass 
approximate processing queries single pass streaming data extensively studied researchers consider possibility 
limit number input streams 
assume duplicate preserving xpath expressions query 
incoming tuple available fetched evaluation series internal computations performed 
result computation output tuple may dispatched 
limited amount memory available internal buffering smaller entire length data stream 
internal computations viewed series linked operators 
operator receives input parent performs operation input sends output tuples children 
operator pipeline operator blocking operator described babu widom 
pipeline operator pipeline operator immediately dispatch output tuple processing input tuple 
system assume input operator output stream pipeline operator property monotonically increasing bounded size buffered synopsis example pipeline operator selection operation 
blocking operator blocking operator receive input generating output 
notation input output blocking operator example blocking operator sort operation 
analysis introduce special type blocking operator refer progressive blocking operator 
observation blocking operators require buffering entire input generating output 
conditions hold true blocking operator progressive blocking operator 
cases operator evaluated follows 
step need buffer temporary results discard input 
equation ensures input longer necessary computations 
equation ensures temporary results buffered evaluation model 
example operator count operation 
problem overview analysis perform key observation 
system limited memory query evaluated single pass entire data stream obtain exact answer conditions holds true blocking operator unbounded input involved query progressive blocking operator unbounded put involved output pipeline progressive blocking operator 
condition straight forward 
consider second condition 
final output progressive blocking operator referred operator pipeline progressive blocking opera tor wait computation finishes 
blocks pipeline progressive blocking computation defines 
queries satisfy referred correlated aggregates cases evaluated approximately single pass 
dependence blocking operators pipeline progressive blocking operators prevents query evaluated single pass control dependence data dependence 
control dependence operators involved correlated sub queries result sub query predicate filter tuple selection 
research efforts focused de correlating queries various unnesting techniques context relational object oriented databases 
data dependence occurs operator computes value uses result previous operator operand 
query referred query example data dependence operators involved 
pixel contains elements query count stream pixel stream pixel return analysis focuses dependencies 
possible approach analysis algebras 
due expressive power flexibility xquery approach model interdependencies operators 
especially true user defined aggregations recursive functions simple complete algebra proposed 
rest propose static analysis expression level model data flow dependence information xquery 
static analysis guiding query transformation efficient code generation query evaluation 
static analysis techniques extensively programming language community optimization imperative languages quite successfully analyzing optimizing xquery :10.1.1.10.6782
high level analysis section describes high level analysis done system 
goal correctly transform query processed single pass possible recognize single pass analysis possible 
low level analysis facilitate code generation xquery user defined aggregates recursive functions discussed section 
initially give overview framework 
overview analysis relational algebra proposed characterize memory usage sql queries continuous streams 
focus xquery algebra approach reasons 
stated earlier developing algebra fully exploit expressive power xquery hard 
example existing xquery engines handle language expression time allow aggressive optimizations 
second sql data dependence frequently introduced xquery code binary expressions computations 
dependence relationships traditionally represented dependence graphs optimizing compilers 
specifically subsection introduce representation called stream data flow graph 
discussed previous section cases query processed single pass 
involves blocking operator unbounded input 
second involves progressive blocking operator unbounded input output pipeline progressive blocking operator 
case simple detect 
analysis section assume pipelined progressive blocking operators query blocking operator evaluated progressively 
shows key phases system 
construct stream data flow graph representing data dependence information query 
apply series high level transformations prune merge stream data flow graph 
techniques simplify analyses importantly rewrite queries enable single pass processing 
pruning graph single pass analysis algorithm applied resulting data flow graph check single pass data flow graph construction high level transformations horizontal fusion vertical fusion single pass analysis low level transformations gnl generation analysis aggregation rewrite stream code generation overview framework evaluation possible 
answer processing performed 
apply low level transformations code generation algorithm efficient single pass execution code generated 
stream data flow graph introduce stream data flow graph represent dependence information enable high level analysis optimizations xquery 
definition pair variables definition uses value value impacts evaluated considered dependent definition stream data flow graph directed graph node represents variable original query directed edges implies dependent introduce nodes variables defined original query defined clauses output value function xpath expression explicitly defined original query 
distinguish nodes represent sequence nodes represent atomic values 
dependence relationships sequences atomic values particular importance 
represent nodes sequence type unbounded length rectangles nodes atomic type sequences bounded length circles 
stream data flow graph query described previous section shown 
implicit variable represents xpath expression stream pixel 
similarly represent stream pixel 
output aggregate function count represented clause treated atom variable represent item binding sequence 
lemma stream data flow graph valid xquery query acyclic 
proof proof directly follows single assignment feature xquery 
assume cycle stream pixel stream pixel count original dependence graph example stream data flow graph conditions hold true variable defined variable referred definition 
allowed valid xquery query 
distinguish types dependence relationship nodes 
definition variables say aggregate dependent dependent sequence variable atomic variable iterator variable expression 
case denote aggregate dependence typically exists progressive blocking operator output 
definition variables say flow dependent dependent aggregate dependent case denote reconsider 
dashed arrows represent aggregate dependence solid arrows flow dependence 
high level transformations consider stream data flow graph 
graph contains multiple rectangle nodes corresponding query evaluated single pass strictly follow original syntax allow pipelined execution 
rectangle node represents sequence may infinite length buffered main memory 
applying query transformation graph pruning techniques including horizontal vertical fusion queries evaluated single pass 
graph pruning horizontal fusion consider query involves multiple traversals data stream 
traversals share common prefix corresponding xpath expressions merge traversal enable processing single pass 
example consider query query count stream pixel return sum stream pixel stream pixel stream pixel count sum original dependence graph dependence graph fusion stream pixel count sum example horizontal fusion original query involves traversals entire stream processed directly buffering stream 
xpath expressions share common prefix stream pixel computation count sum carried single traversal stream pixel 
fuse multiple traversals generate new node representing common prefix 
original sequence node representing traversal label changed subexpression obtained removing common prefix 
new edge added linking node new node 
subexpression obtained removing common prefix empty corresponding node deleted children edge parent node 
stream data flow graph query horizontal fusion shown 
example new sequence node generated corresponding common prefix stream pixel 
label original sequence node changed remaining xpath expressions respectively 
new node linked horizontal fusion query may lead incorrect results inter dependence traversal sequences 
example consider query 
data flow graph horizontal fusion shown 
combine traversal compute count final output iteration output computed partial result correct 
method just apply horizontal fusion irrespective inter dependence 
single pass analysis dependence detected query eliminated processing 
nested queries pre defined iteration space common scientific data processing applications horizontal fusion applied unrolling 
unrolling commonly technique traditional compilers 
consider simple query unordered stream pixel return count unrolling expression generate intermediate query unordered stream pixel stream pixel return count count stream pixel count query fusion stream pixel count dependence graph vertical fusion horizontal vertical fusion query xpath expressions generated unrolling share common prefix horizontal fusion applied sequence node corresponding different iterations 
graph pruning vertical fusion stream data flow graph pruned technique called vertical fusion 
vertical fusion exploits benefits pipelined processing remove unnecessary buffering simplify data flow graph 
consider example 
query stream pixel return return count query contains tuples original stream positive value coordinate 
pipelined fashion process tuple soon available buffering entire sequence required unbounded streams 
described need check dependence progressive blocking operator pipeline operator dependence pipeline operators ignored 
vertical fusion try merge multiple pipeline operations traversal path single cluster stream data flow graph 
cluster obtained fusion referred super node 
super node represented data flow graph dashed box enclosing merged nodes 
doing pipeline operation progressive blocking operations separated number isolated nodes data flow graph reduced 
significantly simplifies analysis dependence relationships 
algorithm top traversal root node flow dependence edges 
node visited traversal fused current super node supernode 
note sequence nodes merged vertical fusion 
sequence flow dependent sequence node sequence node normally occurs result join merge 
details algorithm shown 
set nodes graph incoming edge 
denotes set nodes stream pixel avg original dependence graph stream pixel avg dependence graph pruning example vertical fusion query inserted super node 
denotes compliment nodes graph set algorithm picks sequence node follows flow dependence edges denoted find nodes fused super node nodes put set node fused supernode inserted data flow graph query vertical fusion shown 
data flow graph query vertical fusion shown 
vertical fusion input data flow graph root set foreach node sequence node nd fuse super node algorithm vertical fusion vertical fusion simplifies stream data flow graph analysis optimization 
vertical fusion queries processed single pass rectangle node data flow graph 
single pass analysis horizontal vertical fusion analyzing query evaluated single pass simpler 
discussion treat nodes super node vertical fusion single sequence node 
stream data flow graph contains sequence node evaluated single pass 
node represents traversal se quence length fused vertical fusion apply pipelined execution traversals 
theorem 
sequence nodes theorem query dependence graph contains sequence node ver stream data flow graphs require multiple traversals tical fusion may evaluated correctly single pass 
queries stream data flow graph contains sequence node single pass evaluation may possible 
types dependence relationship may prevent query executed single pass 
examples cases shown 
theorem set atomic nodes aggregate dependent sequence node stream data flow graph elements path query may evaluated correctly single pass 
proof computed sequence depends fully scanned 
assume path value computed follow scan scan implies query processed single pass 
addition condition associated theorem condition need check 
lemma stream data flow graph contains cycle formed horizontal vertical fusion 
proof lemma cycle original stream data flow graph 
cycle formed horizontal fusion vertical fusion 
theorem cycle stream data flow graph corresponding query may evaluated correctly single pass 
proof lemma cycle formed horizontal vertical fusion 
cycle formed right horizontal fusion path tween implies dependence case horizontal fusion generate incorrect results single pass evaluation impossible 
cycle formed vertical fusion supernode involved cycle 
assume cycle super node 
true aggregate dependent node fused vertical fusion 
valid pipelined execution completed 
cycle exists pipelined ex result value ecution requires value pipelined execution possible query evaluated single pass 
vertical fusion stream data flow graphs query query contain cycles queries executed single pass 
conditions corresponding theorems hold true query process query single pass ensure correct results 
original graph vertex conditions corresponding theorems applied theorem shows conditions corresponding theorems hold false query processed correctly single pass 
time respectively 
theorem results progressive blocking operator unbounded input referred pipeline operator progressive blocking operator unbounded input stream data flow graph conditions holds true 
multiple sequence nodes 

cycle involved 

sequence node atomic nodes aggregate dependent path proof assume progressive blocking operation represented sequence node atomic node aggregate dependent assume sequence node condition holds true 
value referred progressive blocking operator compute sequence node aggregate dependent uses value path third condition holds true 
suppose value referred pipeline operator 
super node graph path aggregate dependent cycle graph 
second condition holds true 
noted static analyses analysis conservative nature 
cases query processed single pass analysis determine 
consider example stream pixel max return query redundant predicate 
predicate returns true impact results query introduces cycle graph disallows processing single pass 
analysis extended recognize remove redundant predicates expect arise frequently real situations 
low level analysis code generation section focuses analysis optimizations perform generating efficient streaming code xquery codes 
compared existing evaluating xquery streaming data significant contributions section 
show generate process xquery user defined aggregates 
second new optimization called control aware optimization improve efficiency streaming code 
achieving efficiency handling general class xquery codes generate executable query directly decomposing query operator level interpreting query plan 
similar nature optimized codes generated compiler specified underlying architecture 
comparison interpreted codes generally suffer efficiency shown languages example matlab 
furthermore operators model features xquery effectively recursive functions 
gnl representation described previous section generate stream data flow graph xquery code 
stream data flow graph represents high level view dependencies variables expressions details processing involved modeled 
facilitate generation streaming code introduce representation called generalized nested loops gnl 
representation helps exploit imperative nature xml parsers sax current implementation carried top sax code generation techniques general 
definition gnl definition gnl tuple 
index variable bound 
location path corresponding xpath expression 
predicate expression 
loop body ordered sequence operations performed tuple bound index variable semantic meaning gnl similar foreach loop iterator iterates tuples specified xpath expression 
element target xpath expression filtered bound variable statement executed order definition tuple stream gnl operates specified path expression aggregation operations specified statement sequence body 
syntax structure code generation www org stream pixel return stream data flow graph example java functions triggered sax events easier 
furthermore describe low level optimizations techniques rewriting recursive functions userdefined aggregates facilitated gnl representation 
gnl formation single pass analysis queries stream data flow graph super node sequence node left processing 
query sequence node easy map query gnl representation 
sequence node represents traversal path expression directly map sequence node gnl empty loop body gnl denoted addition introduce gnl corresponding main query denoted gnl atomic nodes stream data flow graph inserted statements loop body order statements loop body needs consistent order original query 
super node data flow graph gnl formation process complex 
create gnl corresponding main query 
create gnl corresponding sequence node super node associated xpath expression 
gnl corresponding root sequence node super node inserted statement loop body consider node super node 
find closest ancestor node gnl associated denote node gnl associated sequence node xpath expression gnl inserted statement loop body gnl statement corresponding node inserted loop body gnl consider atomic node super node 
statement corresponding node inserted loop body multiple statements inserted loop body sequence consistent sequence original query 
gnl query shown 
aggregation rewrite gnl representation generated stream data flow graph aggregation functions including defined users typically placed outside root gnl 
stream pixel formation gnl follow edge represents aggregate dependence 
need recognize aggregation functions rewrite operations applied tuple time return move aggregation corresponding gnl 
assume aggregation operation tuple stream performed function gnl aggregation user defined internal 
rewrite aggregate function easily recognized finding atomic nodes aggregate dependent sequence node super node 
node move corresponding function call gnl function inlining 
internal functions sum count average easily rewritten iterative fashion 
example rewrite sum temporary variable tuple 
user defined function including recursive functions apply previously developed static analysis technique extract associative operation definition function 
basic idea examine syntax tree leaves apply tree pattern matching retrieve desired sub tree 
algorithm deal linear recursive functions 
gnl query aggregation rewriting shown 
code generation discuss details evaluation query streaming xml 
achieve better performance generate executable code query query evaluation engine interpret query runtime 
specifically generate java binary code xerces sax xml parser executed jdk runtime system 
similar peng chawathe processing assumes incoming data tuple types attr start event node attribute list character content node event node gnl sax event handling gnl generated query serves convenient intermediate representation code generation 
gnl uses nested loop structure commonly supported imperative languages java 
sax parser internally supports streaming traversal generates series streaming events document order explicit traversal defined gnl appear final code 
specifically strategy evaluate gnl 
gnl event triggered body executed 
nested nested inside processing performed processing code generated evaluation query shown 
goal process queries fly certain xml elements may need buffered 
example node may issued output condition involving children nodes evaluated 
clearly buffering requires memory want buffer elements possible 
filtering projection technique similar described 
technique simpler process blocking operators join sort 
specifically buffer node entire subtree output 
buffer leaf node value referred query 
case subtree node output buffer immediately dispatched finished 
gnl representation check location path filter gnl mark node buffering referred body gnl 
details buffering query shown 
example node output buffering values 
nodes dispatched handling event 
foreach switch node buffer add buffer add foreach switch node buffer dispatch buffer dispatch root return evaluation code query experimental results evaluate implementation framework techniques conducted series experiments 
compared implementation known xquery processors publically available 
specifically galax version saxon version open version 
query processors implemented sax parser believe comparison reasonable 
note transformations enable queries executed single pass systems may require multiple passes 
advantage framework may allow execution limited memory unbounded streams systems may simply fail execute query scenarios 
comparison focus execution times memory requirements ability system process query streaming data 
sets queries experiments 
set comprised queries xmark benchmark set 
queries chosen processed single pass directly transformations 
datasets different sizes generated xmark data generator factors respectively 
second set comprised real applications involve streaming data 
satellite data processing described earlier section 
virtual microscope application support interactive viewing processing digitized data arising tissue specimens 
frequent element counting known data mining problem pass algorithm karp find superset frequent items data stream 
applications uses recursive functions perform aggregations 
applying techniques optimizations including analysis recursive functions aggregate rewriting horizontal vertical fusion processed correctly single pass entire data stream 
generated synthetic datasets varying sizes evaluate performance applications 
results experiments shown 
experiments conducted mhz pentium iii workstation mb ram running linux version jdk 
systems compared executed environment 
tables denotes basic framework 
compiled java byte code running time shown tables excludes compilation time xquery systems 
available options fast execution optimization turned system 
specifically galax disable sorting duplicate removal path expressions set option projection 
results show consistently outperform systems 
xmark queries small datasets quite close system faster 
reasons 
static analysis technique produced operations elements referred query 
second generate imperative code directly efficient compared interpreted execution engines 
xmark queries larger datasets system significantly faster systems memory overflow 
noted systems designed deal large datasets streaming data 
require memory processing 
example saxon builds dom tree retrieving data memory process large datasets streaming data 
real streaming applications implementation outperforms systems order magnitude 
systems able execute applications single pass data techniques transformations enabled execution 
xmark query size saxon galax mo mo mo mo mo xmark query size saxon galax mo mo mo mo mo xmark query size saxon galax mo mo mo mo mo virtual microscope size saxon galax mo mo mo mo mo xmark query size saxon galax mo mo mo mo mo xmark query size saxon galax mo mo mo mo mo mo mo mo satellite processing size saxon galax mo mo mo mo mo karp frequent item size saxon galax mo mo mo mo mo mo unable produce result hours mo memory experiments results xmark queries real streaming applications execution times seconds related currently research efforts xquery focuses evaluation disk resident xml documents 
techniques query xml views relational database engines include approaches native xml datasets include 
various evaluation optimization strategies proposed specially designed handle continues xml streams 
research efforts efficient evaluation xpath expressions streaming data 
regularity xpath expressions automaton approaches popular predicates 
deal predicates features closures buffering certain elements necessary transducers xsq 
compared xpath xquery expressive involves additional challenges 
currently limited processing xquery queries streaming data 
transducer networks handle subset xquery join node creation operations investigated 
query transformations rewriting techniques streaming data queries strictly written execute streaming data 
flux intermediate representation ir extends xquery new constructs event processing 
xquery translated event ir buffer size optimized analyzing dtd query syntax 
fusion expressions discussed flux algorithms perform optimizations provided 
comparison systematic powerful techniques optimizing transforming queries specifically written single pass processing 
code generation sax events similar approach enable efficient buffering 
stated earlier additional contribution code generation handling user defined aggregations 
bea processor supports pipelined processing streams implementing iterator model expression level 
query optimizations specially designed xml streams limited system large documents processed 
algebraic approach deciding sql query evaluated single pass continuous streams proposed babu widom 
approach handle user defined aggregates computations described binary expressions frequently xquery 
sql developing algebra handle complete xquery hard 
example user defined functions allowed part xquery hard model algebra aware existing effort able 
optimization nested queries investigated context sql object oriented database programming languages 
xquery powerful expressive language involves additional challenges efficient evaluation translation 
merge path navigations reported lorel query language xml limited paths bound variable 
comparison loop fusion techniques data dependence information powerful 
horizontal loop fusion technique separate lists xml ql quite different fusion optimizations developed 
new framework set techniques processing xquery streaming data 
compared existing supporting xpath xquery data streams contributions 
developed series optimizations transform xquery queries correctly executed single pass dataset 
second methodology determining xquery query possibly transformations introduce correctly executed single pass dataset 
developed code generation approach handle xquery queries user defined aggregates including recursive functions 
open open source implementation xml query java 
www net 
alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley 
george alm si david padua 
compiling matlab speed responsiveness 
proceedings acm sigplan conference programming language design implementation pldi pages 
mehmet michael franklin 
efficient filtering xml documents selective dissemination information 
proceedings th international conference large data bases pages 
arvind arasu brian babcock babu jon jennifer widom 
characterizing memory requirements queries continuous data streams 
acm transactions database systems 
babcock babu datar motwani widom 
models issues data stream systems 
proceedings acm symposium principles database systems pods invited 
acm press june 
babu jennifer widom 
continuous queries data streams 
sigmod rec 
chamberlin fernandez florescu robie simeon 
xquery xml query language 
working draft available www org tr xquery november 
box layman mendelsohn nielsen thatte 
simple object access protocol soap 
world wide web consortium note may 
chan felber garofalakis rastogi 
efficient filtering xml documents xpath expressions 
vldb journal large data bases december 
chang moon anurag acharya carter shock alan sussman joel saltz 
titan high performance remote sensing database 
proceedings international conference data engineering pages 
ieee computer society press april 
chen jagadish laks lakshmanan 
tree patterns generalized tree patterns efficient evaluation xquery 
proceedings th international conference large data bases pages 
sophie cluet guido moerkotte 
nested queries object bases 
workshop database programming languages pages 
deutsch mary fernandez dan suciu 
storing semistructured data stored 
proceedings acm sigmod international conference management data pages 
fischer franklin 
filter efficient scalable filtering xml documents 
proceedings th international conference data engineering 
leonidas fegaras 
query unnesting object oriented databases 
proceedings acm sigmod international conference management data pages 
mary fernandez sim byron choi am lie marian sur 
implementing xquery galax experience 
vldb proceedings th international conference large data bases september berlin germany pages 
ferreira moon humphries sussman saltz miller 
virtual microscope 
proceedings amia annual fall symposium pages 
american medical informatics association hanley belfus october 
available university maryland technical report cs tr umiacs tr 
chris ferris joel farrell 
web services 
communications acm cacm pages june 
daniela florescu chris donald kossmann paul lucas fabio riccardi till michael carey arvind agrawal 
bea streaming xquery processor 
vldb proceedings th international conference large data bases september berlin germany pages 
ian foster carl kesselman jeffrey nick steven tuecke 
physiology grid open grid services architecture distributed systems integration 
open grid service infrastructure working group global grid forum june 
johannes gehrke flip korn divesh srivastava 
computing correlated aggregates continual data streams 
proceedings acm sigmod international conference management data pages 
ozsu 
issues data stream management 
sigmod record vol 
pages june 
jagadish lakshmanan srivastava thompson 
tax tree algebra xml 
dbpl 
jagadish chapman lakshmanan patel srivastava wu yu 
timber native xml database 
vldb journal 
richard karp scott shenker christos papadimitriou 
simple algorithm finding frequent elements streams bags 
acm trans 
database syst 
michael kay 
saxon xslt xquery processor 
saxon sourceforge net 
won kim 
optimizing sql nested query 
acm trans 
database syst 
koch 
schema scheduling event processors buffer minimization queries structured data streams 
proceedings th international conference large data bases 
li renato ferreira agrawal 
compiler support efficient processing xml datasets 
proceedings international conference supercomputing ics pages 
acm press june 
hartmut 
horizontal query optimization ordered semistructured data 
proceedings acm sigmod workshop web databases 
daniel david dewitt 
transformation approach optimizing loops database programming languages 
proceedings acm sigmod pages 
papakonstantinou 
transducer xml query processor 
proceedings th international conference large data bases 
ioana manolescu daniela florescu donald kossmann 
answering xml queries heterogeneous data sources 
proceedings th international conference large data bases pages 
marian jerome simeon 
projecting xml documents 
proceedings th international conference large data bases 
jason mchugh jennifer widom 
query optimization xml 
proceedings fifth international conference large databases edinburgh scotland uk september pages 

improved unnesting algorithms join aggregate sql queries 
th international conference large data bases pages 
bry 
evaluation regular path expressions qualifiers xml streams 
proceedings icde session 
feng peng sudarshan chawathe 
xpath queries streaming data 
proceedings acm sigmod international conference management data pages 
re suciu 
distributed xquery 
proceedings workshop information integration web august 
schmidt waas kersten carey manolescu busse 
xmark benchmark xml data management 
proceedings th international conference large data bases vldb pages 
shanmugasundaram jerry eugene shekita fan john 
querying xml views relational data 
vldb journal pages 
igor tatarinov kevin beyer shanmugasundaram eugene shekita chun zhang 
storing querying ordered xml relational database system 
proceedings acm sigmod international conference management data pages 
xin zhang steffen christ brian murphy elke rundensteiner 
rainbow mapping driven xquery processing system 
proceedings acm sigmod international conference management data page 
zhu shasha 
efficient elastic burst detection data streams 
acm sigkdd 
