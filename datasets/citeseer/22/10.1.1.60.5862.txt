linear regions need matthew greg morrisett amal ahmed cornell university ithaca ny cs cornell edu harvard university cambridge ma greg eecs harvard edu amal eecs harvard edu 
type effects system tofte talpin region calculus possible safely reclaim objects garbage collector 
requires regions lifo lifetimes block structure language 
introduce rgnul core calculus powerful encode tofte talpin languages eliminates lifo restriction 
target language extremely simple substructural type system 
prove power language sketch tofte talpin style regions firstclass dynamic regions unique pointers cyclone programming language encoded rgnul type safe languages rely garbage collector reclaim storage safely 
domains device drivers embedded systems today garbage collection algorithms result unacceptable space latency overheads 
settings programmers forced languages memory management tailored application lack type safety lead numerous bugs 
address concerns developing cyclone type safe dialect intended give programmers control memory management possible retaining strong static typing 
initial design cyclone region type system tofte talpin 
data allocated lexically scoped regions objects region deallocated region scope 
unfortunately lifo lifetimes lexically scoped regions place severe restrictions data effectively reclaimed programs resulted unbounded leaks compared garbage collected implementation 
address concerns added number new features cyclone including dynamic regions unique pointers provide control memory management 
dynamic regions restricted lifo lifetimes treated class objects 
particularly suited iterative computations cps computations event servers lexical regions suffice 
unique pointers essentially lightweight dynamic regions hold exactly object 
ensure soundness dynamic regions unique pointers depend notion linear capabilities carefully threaded program 
alleviate tedium cyclone provides convenient mechanisms temporarily open dynamic region unique pointer treat freshly allocated lexically scoped region 
efficacy new memory management features detailed previous papers analyzed range applications including streaming media server space conscious web server scheme runtime system copying garbage collector 
soundness cyclone lexical regions type effects system established model justifies soundness new features grasp due sheer complexity 
goal provide simple model easily encode key features cyclone uniform target language type soundness may easily established 
step encoding detailed previous gave translation type region language monadic variant system called rgn calculus summarized section 
meat picks translation left translating rgn substructural polymorphic lambda calculus internals indexed monad exposed section 
target language translation extremely simple yielding relatively straightforward proof soundness lexically scoped regions 
section sketch features target language allow encode cyclone dynamic regions unique pointers interactions lexically scoped regions 
intention target calculus serve compiler intermediate language vehicle formal reasoning high level programming language 
source calculus rgn launchbury peyton jones introduced st monad encapsulate stateful computations pure functional language haskell 
key insights give rise safe efficient implementation stateful computations 
stateful computation represented store transformer description commands applied initial store yield final store 
second store duplicated state type opaque primitive store transformers store single threaded manner stateful computation update store place 
third parametric polymorphism safely encapsulate run stateful computation 
insights carried region case interpret stores stacks regions 
introduce types operations associated rgn monad 
rgn ref hnd pf return 

rgn 

rgn rgn rgn new 

hnd rgn ref read 

ref rgn write 

ref rgn 

rgn 


pf hnd rgn rgn 

pf rgn rgn 
pf 
pf pf pf type rgn type computations transform stack indexed deliver value type 
type ref type mutable allocated region top stack indexed containing value type 
type hnd type handles region top stack indexed require handle allocate region require handle read write 
operations return unit bind operations rgn monad lifting value computation sequencing computations 
operations primitive stack transformers 
new takes region handle initial value yields stack transformer applied stack regions allocates initializes fresh appropriate region delivers augmented stack 
similarly read write yield computations respectively query update mappings values current stack regions 
note operations require stack index rgn ref equal 
operation encapsulates stateful computation 
takes stack transformer argument applies initial empty stack regions returns result discarding final stack empty 
note apply instantiate type result returned supply stack transformer polymorphic stack index 
effect universal quantification stack transformer assumptions initial stack existence pre allocated regions 
furthermore instantiation type variable occurs outside scope stack variable prevents stack transformer delivering value type mentions 
computations depending final stack escape encapsulation 
suffice encode region languages 
difficulty region language critical allocate variables read variables outer older region scope inner younger region 
accommodate essential idiom include powerful operation similar sense encapsulates stateful computation 
operationally transforms stack creating new region top stack applying stack transformer augmented stack yield transformed stack destroying region kinds stack type level variables stack indices types 
rgn ref hnd pf type level terms type level contexts rgn monad operations ops return new read write expressions ops 

expression level contexts fig 

syntax rgn top transformed stack yielding bottom transformed stack 
ignoring moment argument type pf see may apply exactly reasoning applied computation assumptions newly augmented stack newly augmented stack leaked return value 
role pf 
answer lies fact stack index denote arbitrary stack denote stack related addition newly created region 
fact may consider subtype region stack stack values type pf witnesses relationship 
operation applies subtyping witness stack transformer yield stack transformer intuitively operation sound stack transformer may simply ignore extra regions 
operations combinators witnessing reflexivity transitivity subtyping relation 
gives complete syntax rgn natural extension system introduce simple kind system support abstraction types stack indices 
text omit kind annotations convention stands type level variable stack kind 
adopt standard type system system typing judgement interest meaning expression type records free type level variables kinds records free variables types 
types rgn monad operations text 
previous gave operational semantics rgn proved type soundness rgn operational semantics rgn somewhat cumbersome due intertwining contexts pure evaluation monadic evaluation 
setting define operational behavior rgn translation target language section 
target calculus rgnul line introduced ural core substructural polymorphic calculus extended adding rich collection mutable 
providing sorts substructural qualifiers unrestricted relevant affine linear allowed encode study interactions different forms uniqueness appear high level programming languages 
notable features include deallocation strong type varying updates storage unique objects shared 
augment adding region primitives simplify language removing features relevant affine qualifiers play part translation 
call resulting language rgnul contrast operation rgn encapsulates creation destruction region primitives rgnul include newrgn freergn separately creating destroying region 
access region allocating reading writing mediated linear capability produced newrgn consumed freergn 
noted rgnul substructural polymorphic calculus 
substructural type system provides core mechanisms necessary restrict number order uses data operations 
calculus types variables qualified unrestricted linear 
essentially unrestricted variables allowed arbitrary number times linear variables allowed exactly 
gives syntax rgnul excluding intermediate terms appear operational semantics 
types expressions traditional polymorphic calculus 
structure types qualifier applied pre type yielding sorts types noted 
qualifier type dictates number uses variables type pre type dictates elimination forms 
pre types correspond unit product function types polymorphic calculus 
quantification qualifiers region names pre types types provided pre types 


text omit kind annotations convention stands type level variable qual kind rgn 
pre types ref hnd similar corresponding types rgn type mutable allocated region type handles region pre type cap type capabilities accessing region named shall shortly see linear capabilities effectively mediate access region 
space precludes giving detailed description type system rgnul major features entirely standard substructural setting 
order ensure correct relationship data structure components extend lattice ordering constant qualifiers arbitrary qualifiers types contexts 
second introduce judgement splits assumptions kinds qual rgn type level variables constant qualifiers quals qualifiers constant region names region names 

ref hnd cap types type level terms type level contexts region primitives prims newrgn freergn new read write expressions prims 

en 
xn 
pack pack expression level contexts fig 

syntax rgnul contexts 
splitting context necessary ensure variables appropriately sub expressions 
note ensure assumption appears exactly sub context assumptions may appear sub contexts 
main typing judgement form gives typing rules expression forms rgnul assign types region primitives rgnul newrgn 
cap hnd freergn 
cap hnd new 

cap hnd cap ref read 

cap ref cap write 

cap ref cap purposefully streamlined type primitives order simplify exposition 
example note may allocate read write contents unrestricted 
fundamental difficulty adopting richer set primitives la allow contain arbitrary values 
space precludes giving detailed description operational semantics rgnul entirely standard region language 
small step operational semantics defined relation configurations form global heap mapping region names regions regions mappings pointers values 
primitives newrgn freergn perform complementary actions creating destroying region global heap 
note type newrgn qual 
en 
en 

pack 

xn 
xn fig 

static semantics rgnul 

pack specifies returns existential package hiding name fresh region 
primitives new read write behave precisely counterparts region language 
additionally types specify thread cap values evaluation capability simply access region returned allow access 
semantics capability represented dummy token run time significance 
expected type system rgnul sound respect operational semantics theorem rgnul safety 
exists exists 
formally verified result rich superset rgnul twelf system metatheorem checker 
mechanized proof obtained www cs cornell edu people research regions 
translation rgn rgnul having introduced source target calculi position consider type preserving translation rgn rgnul giving details discuss high level issues 
note rgn notion linearity syntax type system 
variables types implicitly considered unrestricted 
expect translation rgn expressions yield rgnul expressions qualified type 
hand claimed stateful region computation interpreted stack transformer 
recall type rgn type computations transform stack indexed deliver value type 
key characteristic rgn primitive stack transformers meant stack single threaded manner stateful computation update stack place 
single threaded behavior precisely sort resource management may captured substructural type system 
expect representation stack regions rgnul value qualified type 
particular represent stack regions sequence linear capabilities formed nested linear tuples 
third mindful slight mismatch hnd ref types rgn corresponding types rgnul recall rgn hnd ref handles allocated region top stack indexed rgnul hnd ref explicitly name region handle 
subtle distinction region implicit explicit need handled translation 
bearing issues mind turn attention translation rgn type level terms 
translates rgn term stack kind rgnul term kind 
stack kind rgn inhabited variables translation trivial rgnul considered variable kind 
translate rgn term kind rgnul terms kinds respectively 
observed translate rgn type rgnul type ensure result qualified type 
translation straightforward functional types 
note rgn variable kind translated rgnul variable kind ensures type corresponding rgn type manifestly qualified 
interesting translations types associated rgn monad 
translation rgn type see familiar store stack passing interpretation computations 
representation stack regions linear resulting store value pair qualified consider translation pf type 
recall type witnesses fact stack indexed subtype stack indexed 
translate type expresses isomorphism slack 
note types may linear pair functions witnessing isomorphism unrestricted 
corresponds fact proof subtype persistent existence stacks ephemeral 
rgn stack rgnul rgn rgnul rgn rgnul functional types 
stack 
rgn rgnul rgn monad types rgn pf iso hnd rgn 
iso cap hnd ref rgn 
iso cap ref rgnul type level macros iso fig 

type level translation translation hnd ref types similar 
existentially bound region name fixes region rgnul handle isomorphism witnesses fact may stack 
translation rgn type level terms place translation rgn expressions follows directly 
elide translation elimination forms functional types rgn simply homomorphic mapping expression translations focus translation rgn monad operations 
readability give translations fully applied region primitives assuming partially applied primitives eta expanded 
translation return follow directly store stack passing interpretation rgn types return res stk stk res rgn rgn stk stk res stk res stk translation complicated breaks conceptually simple components 
bracket execution inner computation newrgn freergn pair creating destroying new region 
construct representation new stack stk inner computation pairing old stack stk new region capability cap 
construct isomorphisms witnessing relationships new region capability new stack old stack new stack 
carefully chose isomorphism types identity function suffices witness 
putting pieces stack 
pf hnd rgn stk pack rgn cap hnd newrgn id stk cap 
stk ppf pack cap id id pack rgn pack id id hnd stk stk cap stk res cap ppf stk stk cap stk freergn cap hnd stk res see isomorphisms action translation ppf pf rgn stk pack spl cmb ppf stk stk spl stk stk res stk stk cmb stk stk stk res note stack slack stk split combined bracketing execution rgn computation 
final example see empty stack represented value provided initial stack translation stack 
rgn res res translations remaining rgn monad primitives 
strongly believe mechanically verified translation type preserving 
extensions primary advantage working target level expose capabilities regions class objects indirectly manipulating stack regions 
turn allows avoid lifetimes dictated lexically scoped 
example explain semantics cyclone dynamic regions unique pointers concepts target language 
dynamic regions cyclone dynamic region represented key key treated linearly type system 
target level key represented pair capability region handle key cap hnd creating new key accomplished calling newrgn destroying key accomplished calling freergn 
new hnd stk pack rgn pack prj inj hnd stk cap prj stk cap ref new cap hnd pref pack rgn pack prj inj ref stk inj stk cap stk pref read pref ref stk pack rgn pack prj inj ref pref stk cap prj stk cap res read cap ref stk inj stk cap stk res write pref ref stk pack rgn pack prj inj ref pref stk cap prj stk cap res write cap ref stk inj stk cap stk res spl stk su stk su cmb su 
stk su stk pack spl cmb ppf pf ppf pf pack spl cmp ppf pack spl cmp ppf spl stk stk stk spl stk stk stk spl stk sss stk stk stk sss cmb sss 
stk stk stk sss stk cmb stk stk stk cmb stk stk stk pack spl cmb fig 

translation rgn monad operations access value allocated dynamic region allocate value dynamic region cyclone requires region opened presenting key 
similar conceptually pushes dynamic region stack regions executes body pops region stack 
execution body key inaccessible ensuring region deallocated 
scope key back 
programmer able destroy region re open 
primitive implemented higher order function signature eliding qualifiers source level rgn abbreviate store passing translation key hnd rgn cap rgn key function takes key computation handle expects run stack form cap 
applied returns computation run stack opens key get capability handle pushes capability stack passes handle computation runs extended stack produce value 
pops capability returns linear pair result re packaged key 
leave definition exercise reader 
furthermore keys class objects placed data structures 
example space conscious web server list dynamic regions holds data corresponding particular connection 
receive data connection find corresponding key open place data region 
connection terminated pull corresponding key queue perform deallocate data associated connection 
price paid flexibility list keys treated linearly avoid creating multiple aliases keys 
unique pointers cyclone unique pointers anonymous dynamic regions handle 
keys dynamic regions destroyed time type system treats linearly 
target level unique pointer object represented term type 
cap cap ref note actual unrestricted capability linear handle available allocations caught function closure may applied free region 
encoding allows open unique pointer just dynamic regions limited scope freely access duplicate underlying 
course scope open temporarily lose capability deallocate object regain capability exit scope 
practice ability open dynamic regions unique pointers proven crucial integrating facilities language 
relatively easy access data structure mitigate pain threading linear resources program 
furthermore possible write re usable libraries manipulate data allocated lexically scoped regions dynamic regions unique objects 
phase splitting target language represented capabilities proof witnesses explicit terms 
crafted language translation values needed run time 
instance witnesses manipulate products capabilities operationally irrelevant 
objects desired safety properties easy check statically 
principle able erase capabilities witnesses running program 
realize goal introduce phase distinction modality treat capabilities proof witnesses static objects terms dynamic 
modality demand usual static computations depend dynamic values 
furthermore sure witness functions proof objects fact total effect free functions applications capabilities may safely erased 
sort phase splitting effectively settings mix programming languages logics xi applied type system sheard omega 
promising approach suggested walker harper developed level language reasoning effectful programs 
primary reason introduce phase splitting complicates translation target language obscures relatively simple straightforward encoding 
secondary reason demonstrated cited domains benefit general solution problem type relevant operationally irrelevant values 
related open issues prior aimed relaxing stack discipline imposed region lifetimes tofte talpin tt approach 
ml kit uses storage mode analysis determine safe deallocate data region known region resetting prior deallocation region 
safety storage mode analysis established formally 
aiken eliminate requirement region allocation deallocation coincide scope region variables introduced letregion construct 
late allocation early deallocation approach delays allocation region just access deallocates region just access 
believe results analysis encoded explicitly target language 
previous approaches build tt henglein region system replaces letregion primitive explicit commands create free region 
ensure safety region type system consequently support higher order functions 
provide inference algorithm annotate programs region manipulation commands intend system serve target language programs annotated tt region inference written languages cyclone 
calculus capabilities intended target tt annotated programs rgnul defined terms continuation passing style language support class regions 
region system walker watkins closely related 
target require linear capability access region 
provide primitive similar letregion allows capability temporarily treated unrestricted convenience sake 
shown primitive needed 
combination monadic encapsulation thread capabilities coupled unrestricted witnesses achieve flexibility 
particular open construct dynamic regions unique pointers achieves effect walker primitive 
related body regions low level primitive build type safe garbage collectors 
approaches requires non lexical regions copying collector spaces non nested lifetimes 
hawblitzel introduce low level language single linear array words construct lists arrays basic linear memory primitives introduce type sequences building regions nonlinear data 
foundational approach large semantic gap high level language target 
rgnul serves useful intermediate point may envision translation rgnul low level language 
vault language includes features described target including linear capabilities accessing resources mechanism called adoption temporarily transferring ownership capability capability limited scope 
vault includes support strong type changing updates linear resources features temporarily treating unrestricted resource linear 
hand best knowledge exists formal model justifies soundness mechanisms 
believe may possible combine rgnul previous strong updates achieve 

cyclone version 
www eecs harvard edu greg cyclone 

tofte talpin region memory management 
information computation 
hicks morrisett grossman jim experience safe manual memory management cyclone 
proc 
international symposium memory management 

wang implementation performance evaluation safe runtime system cyclone 
proc 
space workshop 

grossman morrisett jim hicks wang cheney regionbased memory management cyclone 
proc 
programming language design implementation 

morrisett monadic regions 
proc 
international conference functional programming 

launchbury peyton jones state haskell 
lisp symbolic computation 
ahmed morrisett step indexed model substructural state 
proc 
international conference functional programming 

walker substructural type systems 
pierce ed advanced topics types programming languages 
mit press cambridge ma 
pfenning sch rmann twelf meta logic framework deductive systems 
proc 
conference automated deduction 

sch rmann pfenning coverage checking algorithm lf 
proc 
theorem proving higher order logics 
lncs 

chen xi combining programming theorem proving 
proc 
international conference functional programming 

sheard meta programming built type equality extended 
international workshop logical frameworks meta languages 

walker harper effective theory type refinements 
proc 
international conference functional programming 

tofte birkedal elsman olesen sestoft programming regions ml kit version 
technical report university copenhagen 
aiken hndrich levien better static memory management improving region analysis higher order languages 
proc 
programming language design implementation 

henglein niss direct approach control flow sensitive region memory management 
proc 
principles practice declarative programming 

walker crary morrisett typed memory management calculus capabilities 
acm transactions programming languages systems 
walker watkins regions linear types 
proc 
international conference functional programming 

wang appel type preserving garbage collectors 
proc 
principles programming languages 

saha shao principled scavenging 
proc 
programming language design implementation 

hawblitzel wei huang low level linear memory management 
proc 
space workshop 

deline hndrich enforcing high level protocols low level software 
proc 
programming language design implementation 

hndrich deline adoption focus practical linear types imperative programming 
proc 
programming language design implementation 

morrisett ahmed linear language locations 
proc 
typed lambda calculi applications 

ahmed morrisett linear language locations 
technical report tr harvard university 
