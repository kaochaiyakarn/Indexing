efficient versatile query engine topx search martin theobald ralf gerhard weikum max planck institute informatics germany weikum mpi inf mpg de presents novel engine coined topx efficient ranked retrieval xml documents semistructured data collections 
algorithm follows paradigm threshold algorithms top query processing focus inexpensive sequential accesses index lists judiciously scheduled random accesses 
difficulties applying existing top algorithms xml data lie need consider scores xml elements aggregating document level combination vague content conditions xml path conditions need relax query conditions results satisfy conditions selectivity estimation content structure conditions impact evaluation strategies 
topx addresses issues precomputing score path information appropriately designed index structure largely avoiding postponing evaluation expensive path conditions preserve sequential access pattern index lists selectively scheduling random accesses cost beneficial 
addition topx compute approximate topk results probabilistic score estimators speeding queries small controllable loss retrieval precision 
motivation non schematic xml data comes different sources inevitably exhibits heterogeneous permission copy fee part material granted provided copies distributed direct commercial advantage vldb copyright notice title publication date appear notice copying permission large data base endowment 
copy republish requires fee special permission endowment 
proceedings st vldb conference trondheim norway structures annotations xml tags adequately searched database query languages xpath xquery 
queries return results 
paradigm called search conditions quantitative relevance scoring 
note need ranking goes adding boolean text search predicates xquery 
research applying ir techniques xml data started years ago gained considerable attention :10.1.1.2.3071:10.1.1.11.8097
emphasis current efficiently supporting vague search element names terms element contents combination xpath style path conditions 
typical example query phrased language inex benchmark follows book information retrieval xml affiliation stanford page rank 
twig query find best matches books contain terms information retrieval xml descendants tagged affiliation content terms stanford page rank respectively 
challenge lies processing queries efficiently 
method choice top similarity queries family threshold algorithms developed related various heuristics processing index lists ir :10.1.1.112.869:10.1.1.31.9882
methods scan index lists terms attribute values descending order local term scores aggregate scores data item global score monotonic score aggregation function weighted summation 
clever bookkeeping score intervals thresholds top candidate items index scans terminate early top items determined algorithm scan short prefixes inverted lists 
contrast heuristics adopted web search engines threshold algorithms compute exact results provably optimal terms asymptotic costs 
xml specific difficulties arise issues scores index lists refer individual xml elements content terms want aggregate scores document level return documents xml subtrees results facing different granularities top query processing 
ir scoring models text documents directly carried consider specificity content terms combination element attribute tags 
example term transactions viewed specific occurring elements type section non informative 
relevant intermediate results search conditions tested satisfy path conditions query may incur expensive random accesses disk resident index structures 
enforcing conjunctive query processing desirable relax path conditions rank documents combination content scores number structural query conditions satisfied 
efficient query evaluation strategy pruning result candidates take consideration estimation aggregated scores selectivities path conditions 
viable solution reconcile local content search conditions score aggregation path conditions 
key factor efficient performance careful random accesses index structures random accesses orders magnitude expensive amortized cost sequential access 
exploit precomputations possible may utilize technology trend fast growing disk space capacity disk latency transfer rates improving slowly 
redundant data structures attractive selectively accessed query run time 
related efficient evaluation xml path conditions fruitful research area 
solutions include structural joins multi predicate merge join staircase join index structures pre postorder encoding elements document trees holistic twig joins probably efficient method twig queries sequential scans index lists linked stacks memory 
extends xquery support partial knowledge schema 
papers considers result ranking finding top results 
information retrieval xml data popular years 
approaches extend traditional keyword style querying xml data 
introduced full fledged xml query languages rich ir models ranked retrieval 
developed extensions vector space model keyword search xml documents 
addressed vague structural conditions combined theme full text conditions 
introduced query algebra xml queries integrates ir style query processing 
best knowledge systems provides efficient support finding top results keyword queries 
top queries tackled various application settings multimedia similarity search spatial data analysis information retrieval digital libraries web preference queries product catalogs kinds structured databases :10.1.1.133.2764:10.1.1.112.869
ta threshold algorithm family evolved efficient versatile method discuss detail section :10.1.1.112.869:10.1.1.31.9882
making xml ranked retrieval efficient carried 
uses path index operations basic steps invoked ta style top algorithm 
scoring model incorporate scores experiments limited db style queries xml ir style inex benchmark 
focuses efficient evaluation approximate structural matches lines 
considers primarily structural similarity means outer joins disregards optimizations content term search 
prior closest topx engine performance studies section compare topx 
prior xxl top algorithm topx radically different query processing architecture outperforms xxl large margin 
contributions presents topx algorithm implementation prototype search engine ranked retrieval xml supporting language inex benchmark extending search xpath axes ir style search conditions 
salient properties topx novel contributions efficiently processes xml ir queries support xpath axes carefully designed index structures efficient priority queue management topk candidates judicious scheduling expensive random accesses 
supports probabilistic pruning candidates lines considerably extending prior techniques xml setting gain additional speed expense small loss precision top results 
uses novel techniques estimating aggregated scores candidates selectivities tag term content conditions structural path conditions drive scheduling decisions random accesses index lists 
xml specific scoring model takes consideration statistics tag term combinations underlying xml corpus compactness subtrees satisfy search conditions 
provides extensive performance evaluation various real life fairly large datasets inex benchmark imdb structured movie database trec terabyte track 
computational model consider simplified xml data model idref xlink xpointer links disregarded 
document forms tree nodes tag content 
treat attributes children corresponding node 
node additionally associate full content defined concatenation contents node descendants 
query processing methods precomputed index lists sorted descending order appropriately defined scores individual tag term content conditions algorithmic rationale top queries follows family threshold algorithms ta :10.1.1.112.869:10.1.1.31.9882
finding matches multiple search conditions multiple tag term conditions scoring ranking ta scans relevant index lists interleaved manner 
scan step algorithm sees score data item list combines score scores data item previously seen index lists global score monotonic aggregation function weighted summation 
ta family algorithms comes flavors random accesses data items addition sorted scans index lists sorted access 
hybrid methods aim schedule random accesses appropriate points query execution proposed topx proposes cost model schedule random lookups content related structural query conditions 
sorted access benefits sequential disk asynchronous prefetching high locality processor cache hierarchy lower amortized costs random access 
threshold algorithms eager random accesses look scores data item query relevant index lists see data item list 
immediately compute global score item need keep memory current top items scores 
algorithms focus sorted access eagerly look candidates global scores need maintain candidate pool memory candidate data item seen list may qualify final top result information denote score data item th index list si assume simplicity score aggregation summation set evaluated lists seen worstscore si known scores si bestscore worstscore highi possibly achieve worstscore upper bounds highi scores unvisited parts index lists 
algorithm terminates worstscore algorithm baseline top algorithm min index lists li si scan highi si worstscore si bestscore worstscore highi worstscore min replace min worstscore top remove candidates bestscore min candidates candidates drop candidates min min worstscore top candidates consider random accesses cost model update bestscore current highi bestscore min bestscore min drop candidates candidates max bestscore candidates min return top rank current top result coined min high highest bestscore candidates 
literature contains various extensions baseline algorithm 
discuss efficiently implement candidate pool priority queues judicious queue maintenance 
proposes replace conservative threshold test probabilistic test approximative top algorithm probabilistic precision recall guarantees 
flexible implementation uses histograms capture score distributions individual index lists computes convolutions histograms order predict probability item global score min threshold si sj min sj sj denotes random variable score list probability candidate document drops threshold set discarded candidate set 
special case corresponds conservative threshold algorithm 
shows pseudo code algorithm 
current builds method 
pseudo code option making random accesses assessing candidate reducing uncertainty worstscore bestscore interval desired cost beneficial point 
idea gives rise family hybrid algorithms allow random accesses aim minimize postpone latest possible point 
candidates potential relevance final top result collected hash table cache main memory data structure full information elements addition priority queues merely containing pointers cache entries maintained memory periodically updated 
top queue uses priorities organize current top documents candidate queue uses priorities maintain condition threshold termination 
employ strategy queue management coined smart strategy 
periodically rebuild candidate queue bound length entries account highi values index scans index scans top priority entry longer qualify topk result high probability score predictor 
system architecture query language topx engine supports variant xpath extended ir style conditions dialect inex benchmark see section 
topx currently supports full specification 
xpath query expressed location path consists location step 
location step set qualifying nodes restricted predicates boolean combinations keyword conditions denoted called operator movie title matrix actor reeves 
content scores content scoring statistical measures view content full content node tag bag words term frequency tf term node number occurrences content full term frequency term node number occurrences full content tag frequency na tag number nodes tag entire corpus element frequency efa term regard tag number nodes tag contain full contents entire corpus 
consider content condition form 
tm tag name tm terms occur full contents subtree 
score node tag condition reflect monotonic aggregation values terms tm tf values child self descendant axis reflecting relevance terms node content specificity search terms regard efa ti na statistics node tags compactness subtree rooted contains search terms full content 
focus self descendant axis full content case important case xml ir vague search case child axis follows analogously 
scoring node regard condition tm uses formulas type score 
tm compactness reflects values derived na efa ti values compactness considers subtree element size length normalization 
note specificity xml specific considering combined tag term frequency statistics global term statistics 
serves assign different weights individual tag term pairs common technique probabilistic ir 
important lesson text ir influence term frequency element frequency values sublinearly avoid bias short elements high term frequency rare terms 
address considerations adopted popular empirically usually superior okapi bm scoring model originating probabilistic ir text documents xml setting leading scoring function score 
tm ti na efa ti log ti efa ti full content tag background theoretical underpinnings okapi bm see 
modified okapi function applied xml collections experiments parameters set respectively element types 
regard retrieval quality formula allow elaborated parameter optimization individual element types go subject 
scoring functions xml statistical language models active research issue okapi scoring model achieved result quality inex benchmark 
structure conditions efficient testing structural conditions transitively expand structural dependencies 
example query element tag content term descendant elements 
way query forms directed acyclic graph tag term conditions elementary tag conditions nodes transitively expanded descendant relations edges 
branching path expressions expressed analogously 
transitive expansion structural constraints key efficient path validation allows incremental testing path satisfiability 
example valid descendant may safely prune candidate document priority queue bestscore falls current min threshold looking condition 
non conjunctive aka 
retrieval result document subtree satisfy structural constraints may tolerate tag names path conditions matched 
useful queries posed information possible typical tags paths xml corpus federation datasets highly diverse schemas 
scoring model essentially counts number structural conditions tags oj satisfied result candidate assigns small constant score mass condition matched 
structural score mass combined content scores aggregated candidate worstscore bestscore interval 
setup set content scores normalized emphasize structural query conditions 
database schema indexing index lists implemented database tables lists corresponding schema definitions 
nodes xml documents identified combination document id pre order pre 
navigation xpath axes supported pre post attributes indexing technique 
actual index lists processed top algorithm various tree indexes created base tables 
full content index tag term pairs create table number document id tag varchar element name term varchar term element pre number pre order element post number post order element score number full content score tag term pair number max score tag term pair doc sorted access tag term desc create index features tag term score pre post random access tag term create index features tag term score pre post navigational elements index create table elements number document id tag varchar element name pre number pre order element post number post order element random access elements tag create index elements tag pre post tables topx index structures table contains actual node contents indexed row tag term pair document local scores referring simple content full content scores see section pre postorder numbers 
tag term pair provide maximum score rows grouped tag term document id extend previ ous notion single line sorted accesses notion sorted block scans 
topx scans list corresponding key tag term descending order score index 
sequential scans prefetch pairs shot keep memory processing refer sorted block scans reason discussed section 
random accesses content scores document tag term performed range scans index triple tag term key 
structural tests elements performed random accesses index key tag 
fully precompute materialize features table efficiently support self axis 
propagate term occurs node tag local tf value upwards ancestors compute values nodes obviously may create redundancy factor high length path root 
topx query processing query processor decomposes query content conditions refers tag term pair additional elementary tag conditions navigation branching path queries plus path conditions constrain way matches tag term pairs elementary tag conditions connected 
concentrate content conditions refer self descendant axis full contents elements 
way term connected preceding tag location path order merge tag term pair single query condition corresponding list inverted index 
content condition sorted index scan index started 
note tag term pairs inverted index lookups immediately benefit selective combined tag term features shorter index lists 
hypothetical combinatorial bound tags terms rows far reached collections 
key issues addressed efficiency 
random accesses tag conditions expensive minimized 

path conditions test partial results connectivity specified xpath axes inexpensive evaluate 

achieve fast convergence candidate items prune candidates terminate index scans early possible 
issue topx random accesses possible point random os cost beneficial scheduling approach see section candidate 
candidates content bestscore quantiles probabilistically estimated quantiles low dropped candidate queue structural conditions need evaluated 
results major savings random accesses 
second requirement met adding pre post order values entries main index lists table see section xpath accelerator 
gives efficient memory test element ancestor element document evaluating pre pre post post 
analogous tests xpath axes including child preceding axes extending schema level information 
pre post information hand fetch entries index lists test path conditions candidates high local scores additional index accesses 
element fails path test simply drop exclude structural join 
third requirement fast convergence entire documents met eagerly eliminating uncertainty matches elements document subset elements seen far index scans 
problem may keep document candidate queue long time find low score elements satisfy content conditions violate path conditions 
keep unnecessarily high render candidate pruning ineffective 
efficiently fetch tag term pairs connected content condition query perform sorted block scans fetch elements relevant content condition respective index list inexpensive series sequential disk document 
materializes block grouping elements descending order score tag term condition helps 
analogously single line sorted accesses model attribute basis highi values index list estimate upper bestscore bounds candidates 
note highi values serve generous upper bound score candidate achieve experiments indicate pruning remains effective 
ab bbb abb ccc abc bb aaaa xml example documents query processing example acc bb xyz illustration query processing consider example data twig query 
shows excerpt respective index 
simplicity show okapi scores pretend scores mere values normalized number terms subtree tag term pair element document score term occurs twice terms 
topx evaluates query opening index scans tag term pairs block fetches best document conditions 
example lines index list belong document fetched sorted 
gives pseudo code topx algorithm 
index scans proceed baseline round robin fashion index lists li connected content condition tag term pairs algorithm continuously computes worstscore bestscore intervals candidate fetched sorted access periodically updates bestscore values candidates current highi values score mass evaluated structural constraints oj round block scan fetches yields different documents algorithm needs continue fetching second best document condition 
second round happens relevant elements conditions memory point 
random access elements triggered cost beneficial see section 
efficiently test path conditions element descendant element element descendant element comparing pre postorder numbers respective element pairs 
way detected element triples satisfies path conditions bestscore values converged final value score mass missed condition 
test performed document point path conditions element element descendants 
second condition connecting tested matches encountered index list 
valid element pairs vs test recompute worstscore bestscore interval 
worstscore min put top results bestscore min put candidate queue optionally perform probabilistic threshold test chance qualify top 
score selectivity predictors score prediction probabilistic candidate pruning lines histograms score distributions stored separate database table histograms relevant content li tag term score pre block index example algorithm structure aware top algorithm min index lists li 
score pre post block scan highi elements incrementally test path constraints pre post pre post match connected drop worstscore max score bestscore worstscore highi oj min min worstscore top continue baseline top algorithm shown fig related query dimension loaded demand single database prefetch prior query execution 
chose single dimensional equi width histograms tag term pairs simplicity default cells histogram 
predicting score summation multiple index lists requires convolution histograms performed demand query run time 
histogram tag term pair full content scoring model see section 
way capture joint tag term distribution scores important terms high scores combination particular tags term transactions elements named vs elements named section 
convolution needed score predictions dynamically performed query execution priority queue candidates rebuilt 
note merely need precompute histograms frequent tag term pairs collection pruning step applied sorted accesses 
approach yields histograms inex imdb tag term pairs ai efa ai 
necessity maintain histograms non frequent combinations scanned batch scan steps anyway 
consider perform random accesses look tag term scores particular candidates topx needs selectivity estimators combines score predictor 
introduce bernoulli random variables xi ith tag term condition satisfied candidate estimate combined probability satisfies conditions seen index scans eventually sufficiently high total score qualify top result sj min sj xi assuming independence sj xi variables tractability 
perfectly analogous approach estimate candidate high total score satisfies certain structural conditions come back aspect section 
estimate xi separately ratio xi li li ni pi length ni index list li minus current index scan position pi list total number documents corpus 
assume independence xi variables lead crude selectivity estimator 
capture covariance ti tj pairs appear prior query histories strong correlation data collection 
equality xi xj xi xj chain rule derive xi xi xi xi set conditions satisfied 
random access scheduling rationale topx postpone expensive random accesses possible perform best top candidates 
beneficial test path conditions earlier eliminating candidates satisfy conditions high 
query model violated path condition leads score penalty positively testing path condition increases worstscore candidate potentially improving min threshold leading increased pruning subsequently 
topx consider random accesses specific points priority queue rebuilt 
point consider candidate decide random accesses test unresolved path conditions look missing scores content conditions 
scheduling decision developed different strategies 
scheduling strategy coined aims minimum number random accesses probing structural conditions promising candidates 
perform sorted scans elementary tag conditions treat structural conditions expensive predicates sense 
schedule random accesses candidates worstscore oj min oj number untested structural conditions static score mass earns satisfied structural condition see section 
scheduling second strategy coined uses analytic cost model 
denote number documents priority queue batch size round sorted accesses index lists probability document seen tag term index lists encountered lists qualifies final top result estimated combined score predictor see section denoted 
estimate selectivity oj remaining path twig conditions precomputed frequencies ancestor descendant twig patterns pairs triples tag names 
simple form xml synopsis replaced advanced approaches 
robe compares cost making random accesses tag term index lists indexes structural path conditions versus cost proceeding sorted access index scans 
cost categories consider expected wasted cost expected number random sorted accesses decision incur optimal schedule 
looking unknown scores candidate index lists incur random accesses wasted qualify final top result considering additional score mass 
computing convolution histogram estimate probability current min threshold final top min si min worstscore 
random accesses resolve missing scores expected wasted cost ew ra ra 
path conditions random accesses resolve oj path conditions wasted cost candidate final top happens number satisfied conditions large accumulate score mass probability qualifies final top estimated conditions 
io satisfied si min worstscore sum ranges subsets oj conditions 
satisfied estimated assuming independence tractability 
independence assumption relaxed covariance technique mentioned section 
efficiency summing full amount subsets lower bound approximation 
random accesses path twig conditions expected wasted cost ew ra oj ra 
candidate sorted accesses wasted learn new information total score encounter lists 
probability seeing ith list steps li li assuming independence probability seeing round index scan steps 
analogously considerations structural selectivities improve accuracy considering covariance estimates 
total costs batch sorted accesses shared candidates incurs expected wasted cost ew sa sa 
initiate random accesses tag term score lookups structural conditions ew ra ew sa ew ra ew sa respectively ra weighted times higher sa perform random accesses time ascending order expected score gain tag term score lookups selectivity path twig conditions 
candidates longer qualify top eliminated early possible random accesses canceled 
experiments setup implemented topx collection java classes 
performed experiments ghz dual pentium pc gb memory 
index lists stored oracle server running pc 
index lists accesses multi threaded mode prefetched batches tuples index list cached jdbc driver 
scan depth invoking periodic queue rebuilds synchronized prefetch size 
queue bound set candidates 
different datasets experiments 
inex collection consists full articles ieee computer society journals conference proceedings complex xml format 
chose queries inex topics official relevance assessments available 
example query article qbic image retrieval 
imdb collection generated xml document movies available internet movie database www imdb com 
document contains movie title plot summaries information people name date birth birth place interesting issue collection mixture elements rich text contents categorical attributes genre yielding ties local scores 
asked colleagues create meaningful queries structural keyword conditions examples queries kind movie cast casting role casting actor name henry looking movies henry arbitrary actor role 
inex imdb exactly large dataset terms documents included experiments trec terabyte corpus stress test xml 
trec terabyte collection trec benchmark consists crawled web pages gov domain 
collection contains html pdf files 
benchmark queries mere keyword queries train station security measures aspirin cancer prevention 
note experimental studies literature xpath xquery xml ir system performance xmark synthetic dataset mb version fits memory really appropriate setting 
inex main benchmark xml ir 
table shows sizes test collections table shows disk resident sizes including index structures required sorted random accesses described section 
index creation times minutes inex hours terabyte standard ir techniques stemming word removal scoring model described section 
docs el feat size inex mb imdb mb tb gb table sizes test collections inex imdb tb features gb gb gb elements gb gb histograms mb mb mb paths kb kb total gb gb gb table index sizes test collections competitors experiments compared strategies top query processing topx minimum probing strategy random accesses explained section 
topx cost strategy beneficial random accesses explained section 
topx text sorted access inverted term index lists unstructured data 
random lookups clarify final ranking top results worstscore bestscore intervals 
join sort strategy query relevant index lists completely fetched main memory top algorithm works memory hash tables cheap random access 
algorithm developed uses structure index candidates satisfy path conditions uses ta random access compute top result 
optimized version top algorithm extent chaining technique 
join sort competitor corresponds traditional dbms style query processing lower bound amount index list accesses non ta implementation 
inspired holistic twig join probably best known method twig queries scoring ranking non ir xpath 
competitor driven assumption structure conditions quite selective 
uses data guide structure index evaluating structural skeleton query 
provides compact representation result candidates element combinations satisfy path constraints concisely encoded combinations extent identifiers 
identifiers stored additional attributes entries inverted index lists quickly test element encountered index scan tag term condition belongs document satisfies structure conditions 
algorithm performs immediate lookups missing tag term scores original ta fagin generally follows eager strategy random accesses 
optimized method assumes elements tag term index list extent identifier structure index path tags root elements form forward linked chain 
evaluation structure conditions groups resulting candidate elements extent identifier conceptually invokes sorted index scan extent 
implementation merges cursors index scan sequential perform skips 
approaches optimized fit full content scoring 
comparison okapi bm scores simple element contents shown major benefits scoring model terms result quality 
furthermore uses hash cache structure avoid redundant random accesses 
baseline runs table gives detailed results comparing different topx configurations competitors varying inex imdb terabyte 
table lists statistics batch queries parameter amount queries sum sorted accesses sum random accesses entire batch query average process cpu times seconds sum queue operations inserts deletes updates topx maximum number cached items hash structure numbers documents macro averaged precision mean average precision map top official relevance assessments inex terabyte 
imdb official benchmark setting omit map values imdb results range queries 
report detailed wall clock elapsed times measure sufficient statistical confidence testbed exclusively dedicated single process 
wall clock times typically factor higher cpu times disk oracle server yielding user perceived response times range seconds inex query seconds terabyte probabilistic pruning proportion fairly consistent algorithms parameter settings 
table shows conservative topx method probabilistic pruning reduces number expensive random accesses factor compared competitors inex factor imdb rates inexpensive sorted accesses 
sa ra join sort performance function inex minp robe scheduling outperforms robe inex terms saving random accesses 
imdb hand robe superior different structural characteristics data 
distinct twig distinct path structures inex compared distinct distinct path structures imdb 
low document level selectivity path conditions imdb structural constraint tests range scans elements table get pre post codings expensive inex random access scheduling crucial 
cost robe method showed benefits 
reason techniques competitive topx large small minp robe robe won large margin 
generally sorted access shows drawbacks categorical attributes genres birth places yield long lists ties local scores 
note sorted access cost join sort values query relevant index lists completely fetched anyway 
report map value depends top case 
large higher top approaches degenerate lose advantage database style join sort approach due overhead 
surprising large values longer case top algorithms 
note return inex documents query results 
approaches index accesses join sort different index structures topx fewer index accesses join sort 
run join sort nr inex nonredundant scoring model okapi bm weights document statistics performs poorly terms precision map values top results 
demonstrates severe shortcomings standard document scoring approaches xml retrieval 
note map captures precision recall key metric relevance assessment benchmarks inex trec 
terabyte served stress test engine 
relatively high values indicate relevance sets huge 
map values lower suffer returning top originally proposed trec consider meaningful top engine 
terabyte run join sort merely report lower bounds index access costs relevant index lists sizes 
runs probabilistic pruning studied influence performance query result quality 
results minp robe scheduling shown table 
additional quality measure report macro averaged relative precision rp rec max compared conservative algorithm 
probabilistic pruning reduces amount index accesses overhead queue operations predictor overhead negligible 
performance gain factor access rates factor run times compared conservative topx orders magnitude compared join sort collections high precision values 
shows performance gains inex terms accesses rates function value 
minor reductions user perceived quality measures precision map probabilistic pruning hardly affects result quality 
shows relative precision value rp rec degrades higher rate 
means different results returned top ranks equally user perspective official relevance assessments inex trec 
sa ra performance function terabyte inex imdb topx engine combines extended ta style algorithm focus inexpensive sorted accesses run queries sum sa sum ra avg cpu inex sum ops max cache map join sort join sort nr topx robe topx minp robe imdb join sort topx robe topx minp robe terabyte join sort topx ext table baseline runs inex imdb terabyte various run queries sum sa sum ra avg cpu sum ops max cache map inex topx minp robe imdb topx minp robe terabyte topx ext table topx runs probabilistic pruning various number novel features carefully designed precomputed index tables cost model scheduling helps avoiding postponing random accesses highly tuned method index scans priority queue management probabilistic score predictors early candidate pruning 
performance experiments demonstrate efficiency practical viability topx ranked retrieval xml data 
addition xml ir techniques topx efficiently integrates ontology thesaurus query expansion relaxing example search tag book find documents tag statistically focused efficiently computed manner 
features include efficient phrase matching flexibility handling query conditions mode hard conjunctions mandatory terms tags paths 
generally aim combine best methods structured xml querying non schematic ir precision function inex terabyte inex terabyte map inex map terabyte address sophisticated techniques scheduling accesses different kinds content structure indexes 
naughton 
estimating selectivity xml path expressions internet scale applications 
vldb pages 
agrawal automated ranking database query results 
cidr 
structural joins primitive efficient xml query pattern matching 
icde pages 
yu jagadish 
querying structured text xml database 
sigmod pages 
amer lakshmanan pandit 
flexible structure full text querying xml 
sigmod pages 
anh de moffat 
vector space ranking effective early termination 
sigir pages 
bruno gravano marian 
evaluating top queries web accessible databases 
icde pages 
bruno koudas srivastava 
holistic twig joins optimal xml pattern matching 
sigmod pages 
buckley 
optimization inverted vector searches 
sigir pages 
carey kossmann 
reducing braking distance sql query engine 
vldb pages 
carmel searching xml documents xml fragments 
sigir pages 

chang 
hwang 
minimal probing supporting expensive predicates top queries 
sigmod pages 
kushmerick 
expressive retrieval xml documents 
sigir pages 
cohen xsearch semantic search engine xml 
vldb pages 
de vries nes kersten 
efficient nn search vertically decomposed data 
sigmod conference pages 
fagin lotem naor 
optimal aggregation algorithms middleware 
comput 
syst 
sci 
fuhr gro johann 
xirql query language information retrieval xml documents 
sigir pages 
grabs 
schek 
xml scalable xml processing database cluster 
intelligent search xml data pages 

accelerating xpath location steps 
sig mod pages 

balke kie ling 
optimizing multi feature queries image databases 
vldb pages 
guo ranked keyword search xml documents 
sigmod pages 
papakonstantinou 
keyword proximity search xml graphs 
icde pages 
rank aware query optimization 
sigmod pages 
initiative evaluation xml retrieval 
inex informatik uni duisburg de 
jiang holistic twig joins indexed xml documents 
vldb pages 
kaushik integration structure indexes inverted lists 
sigmod pages 
li yu jagadish 
schema free xquery 
vldb pages 
lim wang padmanabhan vitter parr 
line self tuning markov histogram xml path selectivity estimation 
vldb pages 
long suel 
optimized query execution large search engines global page ordering 
vldb pages 
marian bruno gravano 
evaluating top queries web accessible databases 
acm tods 
marian adaptive processing top queries xml 
icde 
ramakrishna 
query processing issues image multimedia databases 
icde pages 
persin zobel sacks davis 
filtered document retrieval frequency sorted indexes 
ja sis 
robertson walker 
simple effective approximations poisson model probabilistic weighted retrieval 
sigir pages 
schlieder meuss 
querying ranking xml documents 
am 
soc 
information science technology 
theobald weikum 
adding relevance xml 
webdb pages 
theobald weikum 
index xxl search engine querying xml data relevance ranking 
edbt pages 
theobald weikum 
topk query evaluation probabilistic guarantees 
vldb pages 
text retrieval conference 
trec nist gov 

narrowed extended xpath 
available www cs 
ac nz andrew pdf 
zhang supporting containment queries relational database management systems 
sig mod pages 
