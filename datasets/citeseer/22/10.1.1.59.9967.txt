management configuration issues sensor networks pedro jos marr andreas daniel minder matthias olga kurt rothermel institute parallel distributed systems university stuttgart germany marron minder rothermel informatik uni stuttgart de short define key issues related efficient management configuration sensor networks distribution management roles network efficient code distribution algorithms efficient fly code update algorithms 
results issues dealt tinycubus project 
full define key issues need solved order provide efficient management configuration applications system software sensor networks distribution management roles network efficient code distribution algorithms efficient fly code update algorithms sensor networks 
issue motivated increasing heterogeneity sensor network applications need complex non homogeneous network topologies structures 
second motivated intrinsic energy constraint issues general resource limitation sensor networks 
third needed due nature monitoring applications optimization needs applications able efficiently incorporate code updates network adapt surroundings fly 
related results issues dealt tinycubus project 
corresponding author marron informatik uni stuttgart de university stuttgart universit 
stuttgart germany phone fax preprint article published international journal network management vol 
pp 

copyright john wiley sons sensor networks envisioned consist large number possibly thousands sensor nodes communicate wireless technology 
network management perspective important nodes manage configure autonomously 
configuration management numbers nodes handled effectively 
today sensor networks consist tens nodes applications complex configuration reconfiguration normal operation play important role 
problem configuring sensor networks formulated follows 
software individual sensors set efficiently network fulfill tasks resource constraints typically sensor networks 
configuration process repeated initial deployment nodes call reconfiguration 
example configuring sensor networks assignment specific tasks individual sensor nodes 
configuration done manually feasible case large networks having network assign tasks 
example distribution code updates network 
potentially thousands nodes impracticable human network administrator install new software version node hand 
system implemented supports automates process order distribute code updates network multi hop capabilities 
addition energy extremely scarce resource new software versions disseminated energy efficient manner transmission packets possible 
furthermore code sent radio link complete replacement code images complex applications software update inefficient packets transfer code part previous version network 
describe relevant research problems need solved order support autonomous configuration efficient fly reconfiguration sensor networks show results 
challenge deals assignment roles sensor nodes properties network 
roles represent task specific node supposed fulfill 
example node aggregator role aggregates data received neighbors single result node role datasource just collects data sensors forwards aggregator node 
second challenge deals update code running nodes energy efficient way 
current approaches send code image network 
leveraging knowledge topology specific role assignment available network number messages sent node significantly reduced sending code updates nodes really need 
third challenge deals minimization size code updates providing flexibility needed dynamically adapt software running nodes 
replacing complete code images just small changes requires lots unnecessary transmissions 
parts code changed transmitted number sent packets reduced significantly 
addition pieces code providing functionality different implementations node node dynamically adapt application current requirements 
issues combination dynamic adaptation issues main focus project university stuttgart 
tinycubus flexible adaptive cross layer framework sensor networks goal ease development broad range sensor network applications providing necessary infrastructure deal complexity systems 
remainder organized follows 
section describes main challenges configuration management gives overview related 
section presents architecture approach solving problems 
section concludes 
challenge description related mentioned identified main challenges involved configuration sensor networks assignment roles network efficient code distribution techniques fly code update algorithms 
discuss problem detail 
role assignment current sensor network research assumes nodes equal 
practice sensors fulfill different tasks 
example sensor node act cluster head neighbors act slaves gateways clusters 
example sensor networks network aggregation 
nodes just collect data sensors transmit aggregator nodes 
nodes aggregate data sources order reduce number messages required increase accuracy values 
sink node consumes aggregated data 
examples show tasks individual nodes network differ considerably 
assignment roles represent tasks gateway datasource sink needs addressed 
approaches solve problem current sensor networks 
solution human network administrator manually assign role node 
clearly approach works network small possible obtain global knowledge topology network 
example sustainable bridges application uses sensor networks cost effectively monitor bridges order detect structural defects network small nodes static engineers want strict control network 
case approach viable 
nodes move fail system adapt new situation human intervention obviously disadvantage 
widely spread solution differences software functionality assign different roles 
hardware nodes different software loaded implicitly different roles 
example tinyos demo applications rely special program loaded motes just forwards messages received radio pc serial cable 
actual application reads sensor values sends radio runs nodes 
related approach implicitly differentiates roles hardware capabilities nodes 
hardware properties differ distinction identify roles 
example sustainable bridges project nodes sensing capabilities 
vibration sensors affixed near edges nodes center bridge just monitor environmental conditions temperature sensors 
approach role distribution easy adaptation roles interchangeable 
years algorithms self configuration sensor networks proposed 
solutions sure nodes divide tasks 
example distributed placement aggregation operators 
placement operators incrementally adjusted minimize network traffic 
obviously solution focuses specific part self organization problem providing generic solution 
similarly describe protocol self organization uses roles describe tasks specific nodes 
approach provide generic solution fixed set roles 
approaches truly supports self configuration generic way 
solution able assign role representing task capabilities sensor node neighbors topology network 
propose specification language distributed role assignment algorithm assign arbitrary roles nodes properties 
properties change role assignment dynamically updated reflect new situation 
code distribution new software version installed sensor network node plugged programming board connected pc serial parallel cable 
code distribution techniques proposed transmit code images node node radio links 
schemes extremely useful installation new software large network having deployed field 
typically code image mica motes running tinyos consists kilobytes data 
having mind radio communication needs limited energy resources main challenge minimize number packets sent node delivering code updates reliably nodes need 
simple solution flooding technique blindly sends code update nodes 
approach possible install code updates selectively nodes network efficient way 
nodes forward packets assigned role require specific code update fulfill task 
presence roles approach particularly efficient 
techniques proposed improve previous method checking node needs install code update 
example ripple reduces number messages sent publish subscribe scheme single node neighborhood sends code updates subscribers 
example trickle periodically broadcasts meta data software version nodes 
trickle uses technique called polite gossip inform neighbors available software round nodes repeat version information overheard neighbors 
approaches require nodes forward code update distribute code updates nodes installed new software version sending update nodes need role 
considerable amount unnecessary communication 
better solution transmit code updates nodes need nodes routers necessary reach target nodes 
example mobile ad hoc networks manets multicast algorithms maodv purpose 
sensor networks severe resource limitations standard algorithm 
roles assigned nodes information knowledge network topology efficiently distribute code updates network see sections 
fly code update capabilities limited energy sensor nodes size code images energy costs packet transmission way updating parts code change order support adaptation reconfiguration 
adaptation possible replace parts code node having retransmit part code image previous transmission 
current code update algorithms transmit complete code image including operating system usually amounts kilobytes blindly divide code image blocks considering structure code 
examples approaches deluge 
included tinyos 
lacks ability forward code multi hop network simply broadcasts complete code image single hop network 
deluge included tinyos releases replace 
allows incremental updates dividing code fixed size pages 
addition includes functionality disseminate update multi hop network keeping number network packets low 
possible solution code update problem compare new code previously installed software version transmit differences 
langendoen approach compute edit script transforms installed code image new 
likewise incremental network programming protocol jeong culler uses rsync algorithm find variable sized blocks exist code images transmits differences 
approaches just compare bytes code knowledge application structure 
cases lead inefficient behavior 
approaches nodes eventually installed code image support adaptation 
order reduce number packets desirable install required components nodes need store ones received adaptation free part flash memory typically constrained program memory 
solution uses knowledge application structure grouping code packages components 
offers flexibility simply replacing arbitrary pieces code possible dynamically change current set installed packages adaptation 
way sensor nodes possess components need current role 
role changes factors necessary node easily exchange currently component 
network management tinycubus discuss specific approaches tinycubus project university stuttgart address challenges role assignment code distribution code update capabilities 
overview tinycubus tinycubus project focuses configuration management adaptation issues sensor networks 
architecture tinycubus developed goal creating generic reconfigurable framework sensor networks 
shown fig 
tinycubus implemented top tinyos nesc programming language allows definition components sense tinyos 
applications register requirements tinycubus executed framework 
implementation tinyos tinycubus generic framework concepts applied underlying operating systems 
addition tinyos ported hardware platforms attracted large community users considered de facto standard sensor network operating systems 
tinycubus consists parts tiny data management framework tiny cross layer framework tiny configuration engine 
parts briefly described sections refer previous details 
tiny cross layer framework state repository app 
req 
opt 
param 
sys 
param 
tinyos 
am tiny data mgmt 
framework hardware abstraction layer 
topology manager tiny configuration engine application components tinycubus operating system hardware system components data mgmt 
components user defined components fig 
architectural components tinycubus tiny data management framework tiny data management framework provides set data management system components 
type widely data management component replication caching prefetching hoarding aggregation type system component time synchronization broadcast strategies expected implementations exist 
tiny data management framework responsible selection appropriate implementation current information contained system 
cube fig 
called combines optimization parameters energy communication latency bandwidth application requirements reliability consistency level system parameters mobility network density 
component type algorithms classified dimensions 
example tree routing algorithm energy efficient highly mobile scenarios high reliability requirements 
tiny data management framework selects best suited set components current system parameters application requirements optimization parameters 
adaptation performed dynamically lifetime system crucial part optimization process 
currently investigating different strategies determine necessary beneficial select different component 
tiny cross layer framework tiny cross layer framework provides generic interface support parametrization components cross layer interactions 
described goldsmith wicker strict layering practical wireless sensor networks possible apply certain desirable optimizations 
example application components link layer component need information network neighborhood information gathered components system provided 
state repository store cross layer data components components interact directly 
architectural properties modularity better preserved cross layer interactions 
examples cross layer interactions callbacks higher level functions ones provided application developer 
tiny cross layer framework supports form interaction 
deal callbacks dynamically loaded code tinycubus extends functionality provided tinyos allow dereferencing resolution interfaces components 
tiny configuration engine cases parametrization provided tiny cross layer framework 
installing new components swapping certain functions necessary example new functionality new processing aggregation function sensed data required application 
tiny configuration engine addresses problem distributing installing code network 
goal support efficient configuration system application components assistance topology manager 
topology manager responsible self configuration network assignment specific roles node 
role defines function node properties hardware capabilities network neighborhood location previous describe generic specification language role assignment algorithm outlined section 
cases network heterogeneous assignment roles nodes extremely important nodes need component receive install 
show section information configuration engine distribute code efficiently network 
role assignment sensor networks overview described need generic self configuration algorithm assigns roles sensor nodes 
case clustering assign roles clusterhead gateway slave 
cluster exactly cluster head slaves communicate node communication clusters routed gateway nodes 
additionally roles hardware capabilities node 
instance node role vibration received role equipped vibration sensor role temperature characterizes nodes temperature sensors 
examples identified core elements systems support role assignment property directory role specification role assignment algorithm basic services 
property directory contains information hardware characteristics individual nodes dynamic properties remaining battery power location node 
tinycubus properties retrieved cross layer framework 
change role assignment adjusted dynamically 
role specification topology manager uses generic specification language 
specification language role defined rule 
example rule assigns role clusterhead node role hop neighborhood clusterhead count hop role clusterhead simplification rule real system cluster heads may change dynamically 
rules include parameters amount energy available number times node cluster head 
nodes share role specification 
copies specification nodes distributed role assignment algorithm executed 
triggered property role changes nodes neighborhood algorithm evaluates rules contained role specification 
rule satisfied associated role assigned 
possible rule uses local knowledge 
information network neighbors required number nodes neighborhood role node retrieve information neighbors avoiding conflicting role assignments see section details 
basic services needed role assignment include algorithms time synchronization node localization neighbor discovery 
purpose existing algorithms placed data management framework 
role assignment algorithm role assignment algorithm works follows 
node evaluating rules locally broadcasts request message 
nodes share set rules receivers know data neighboring nodes need 
receiving node request message currently evaluating rules conflicting role assignments arise 
example neighboring nodes send request messages concurrently role assigned 
detect clusterhead adopt role 
avoid conflicts receivers request messages evaluating rule ensure atomic rule evaluation sending back abort message aborting evaluation depending ids 
conflict receivers locally evaluate expressions requested send back outcome reply message 
initiating node receives abort messages aborts rule evaluation 
uses results reply messages complete evaluation select role 
allow neighboring nodes react changing roles node broadcasts confirm message neighborhood changes role abort messages properties change 
message contains new role information changed properties 
node receives confirm message receivers start rule evaluation aborted earlier role sender changed properties sender changed 
addition rule evaluation started nodes turned nodes properties change 
reduce number abort messages nodes randomly delay start rule evaluation 
algorithm straight forward solution issues correctness robustness efficiency 
regarding correctness main problem ensure stable role assignment reached 
means property changes nodes eventually assigned role lead role changes nodes 
generally characteristics depend particular role specification 
ensured programmer defining roles 
cases heuristics preventing nodes returning earlier roles applied runtime system detect patterns illegal behavior 
addition possible detect stable role assignment reached application react appropriately 
example role considered stable changed amount time 
respect robustness node failures lost messages main issues 
node fails algorithm outside role assignment process assignments absence automatically considered longer report properties 
restart role assignment remaining nodes way detect node failures example periodically re evaluating rules 
reply messages lost role assignment properties respective nodes ignored lead assignment wrong roles 
addition confirm messages lost aborted nodes know re evaluate rules 
problems timeouts ignore late replies start evaluation process aborted nodes 
having mind resource constraints sensor networks essential role assignment algorithm works efficiently 
message overhead minimized 
knowing nodes share rules nodes forward information necessary reevaluate rules node affected role change 
addition data cached receivers making unnecessary re send change 
algorithm tries reduce number messages broadcasting information locally neighborhood 
derived specification hops included neighborhood 
summary role assignment algorithm provides generic solution self configuration sensor networks 
issues need addressed real world deployments 
efficient code distribution section describe algorithm code distribution 
cross layer information topology role assignment efficiently distribute code data sensor network 
define network model algorithm describe algorithm detail evaluate performance describe advantages 
network model purposes network consists set inner nodes ni set gateway nodes gj messages outside sensor network code updates inserted system 
set nodes network 
set roles defined rm defines complete relation assigns roles nodes 
nr set nodes assigned role define hop neighborhood node ni set nodes single hop broadcast range ni follows ni nj nj broadcast range ni hop neighborhood defined recursively expression hk ni nj hk ni nj 
set nodes role hop distance node ni simply hr ni hk ni nr say node ni hop connected node nj role iff ni nj connected nodes nl nlm role nl nlm nr path consecutive nodes set ni nl nlm nj involves nodes nr 
equations define transitive closure reachable nodes hop connected ni particular role note ni role included ni 
ni ni ni nj ni hr nj cr ni ni iff ni ni assuming messages inserted gateway nodes equation defines set nodes role reached hop connectivity ncr gi cr gi role smallest calculated nodes network role hop connected kr min ncr nr 
value kn nodes roles network connected calculated kn max kr detailed description code distribution algorithm uses network model previous section information role assignments provided tiny cross layer framework efficiently disseminate code updates specific roles 
approach particularly effective role assignments stable example roles depend fixed hardware properties 
node role changes necessary code node request neighbors code repository available outside network 
remainder assume role assignments stable sustainable bridges project 
algorithm starts gateway nodes broadcasting data kr hop neighborhood 
nodes role forward data kr hop neighbors flooding nodes role nodes roles necessary reach 
algorithm parametrized selecting kr role 
topology network crucial 
network kr hop connected role kr possible reach target nodes maximum efficiency 
general case especially topologies random kr nodes roles different need involved process forwarding information 
addition reliability necessary case providing code updates distribution algorithm implicit acknowledgments 
neighbor forwards message sent node ni ni treats message acknowledgment 
certain amount time neighbor forward message ni retransmits 
algorithm node ni waits random time tmax retransmitting message 
just possible way avoid broadcast storm problem mentioned tseng reliability component replaced scheme avoids collisions 
course choice tmax directly related delay observed evaluation algorithm 
assumptions implementation algorithm assume roles assigned dynamic reassignment roles code dissemination algorithm runs 
means connectivity kr network role determined upfront 
furthermore assume nodes stationary fail determined neighborhood hr respect role network connectivity communication assumed performed bidirectional local broadcasts transmission failures occur permanent 
evaluation order show feasibility approach implemented role code distribution algorithm motes running tinyos 
set experiments show analytically means experiments worst case average results computation kr connectivity role structured random grid topologies sensor networks 
second set experiments compare efficiency algorithm flooding approach modified provide reliability collision avoidance 
results experiments obtained tinyos simulator provided uc berkeley 
computation kr set experiments deals computation reasonable kr connectivity network role seen perspective gateway nodes 
case applications sustainable bridges project computation kr performed hand application developer structure network location sensor nodes known 
structure network random known priori way determining values kr desirable 
fig 
shows worst case average percentile values kr network random role assignments choose kr node reached 
graph see starting ratio vibration temperature nodes kr achieves completeness average percentile cases worst network connectivity worst case average percentile ratio vibration temperature sensors fig 
kr completeness random avg 
completeness flooding ratio vibration temperature sensors fig 
avg 
completeness kr random case indicates value kr 
curves fig 
obtained choosing random role assignments grid varying number vibration nodes measuring value kr needed achieve completeness 
worst case curve possible compute general expression gives values kr arbitrary grid structures size assuming nodes communicate immediate horizontal vertical diagonal neighbors gateway node located corners analytical formula worst case scenario kr nr nr mn nr nr mn nr mn algorithm applications code distribution situations completeness required 
cases fig 
shows average completeness achieved kr 
graph determine smallest value kr needed achieve desired completeness assuming ratio nodes target role known 
example ratio target roles equal achieve completeness fig 
tells kr achieve average desired results 
performance evaluation second set experiments focused evaluating performance role distribution algorithm compared flooding approach 
selected flooding standard multicast algorithm sensor networks flooding approach forms basis algorithm 
approach combined advanced distribution schemes trickle see section dynamically selects nodes forwarding code update 
experiments sensor nodes laid evenly spaced grid rectangle vibration sensors enclosing temperature nodes 
gateway node located corners inject messages network 
distance nodes meters radio model set lossless disc model communication range meters 
packet losses occur due collisions 
focus structured grid topology known roles assigned nodes represents topology sustainable bridges application 
simulations assume presence roles vibration represent types sensors network 
evaluate code distribution algorithm sending fictitious code updates gateway node vibration sensors 
fig 
shows number messages sent average node sustainable bridges scenario 
graph compares messages sent flooding role distribution algorithm maximum retransmission delay tmax ms ms respectively 
role assignments axis vary original configuration described nodes assigned vibration role 
measurements shown average runs 
graph avg 
messages node flooding flooding role role ratio vibration temperature sensors fig 
avg 
number messages node structured avg 
messages node flooding flooding role hop role hop role hop role hop ratio vibration temperature sensors fig 
avg 
number messages node random avg 
delay ms avg 
delay ms flooding avg flooding avg role avg role avg ratio vibration temperature sensors fig 
avg 
delay structured flooding avg flooding avg role avg hop role avg hop role avg hop role avg hop ratio vibration temperature sensors fig 
avg 
delay random see flooding tmax ms requires messages node tmax ms requires little average 
flooding algorithm retransmits messages presence collisions nodes reached average number messages sent greater varies length tmax 
addition graph shows number messages sent independent ratio vibration temperature sensors flooding distinguish distribute data 
contrast role algorithm performs better flooding especially ratio vibration temperature sensors low vibration sensors required forward messages 
expected number messages node increases ratio vibration temperature sensors increases 
extreme case nodes network vibration nodes algorithm behaves just flooding 
fig 
depicts average delays needed algorithms reach vibration nodes structured scenario 
maximum delays shown graph algorithm worst case twice long delay needed average 
addition average delays flooding times better role algorithm 
reason flooding uses vibration nodes forward data allows parallelism fact network vibration nodes located square vibration node chooses long random delay avoid collisions data distribution delayed 
choosing example tmax ms possible keep number sent messages low see fig 
achieving delays just slightly flooding compare flooding avg role avg fig 

just seen role distribution algorithm efficiently recall network topology scenario exhibits hop connectivity vibration role 
structured topologies expect topologies exhibit hop connectivity 
tested algorithm random distributions roles show effectively scenarios 
fig 
shows number messages sent random role assignments flooding different versions role algorithm kr kr respectively 
flooding behaves expected just structured case 
algorithm hand sends far fewer messages flooding topology network exhibits say hop connectivity role algorithm reach nodes 
shown fig 
flooding obviously reaches completeness algorithm guarantee completeness cases 
example hop algorithm network exhibits hop connectivity required nodes reached 
contrast value chosen kr greater actual connectivity network unnecessary messages sent algorithm behave flooding 
reason fig 
slopes curves hop algorithm greater hop algorithm especially near fig 
hop version probabilistically reaches nodes 
analogously structured case fig 
shows average delays needed flooding hop hop algorithms reach target nodes 
different random role assignments tested algorithm lower delays flooding low ratios vibration sensors shown fig 
values algorithm average reach target nodes clear unfair advantage 
soon number vibration sensors reaches point saturation algorithm probabilistically reach nodes ratio hop algorithm see fig 
behaves similarly flooding 
ratio values hop algorithm slower flooding correlates results fig 

case differences delay noticeable 
reason random assignments roles placed arbitrarily number neighboring nodes role average higher bridge scenario vibration sensor direct neighbors 
delays fig 
represent worst case scenario message reaches exactly target data sent serially vibration sensor 
advantages role code distribution role code distribution algorithm advantages 
general algorithm distribute kind data destination varies certain information roles 
furthermore assume roles assigned role connectivity kr network determined estimated algorithm efficient plain flooding 
assume network topology change static time overhead computation kr small penalty pay continuously sending data times overhead reliable flooding approaches 
fact algorithm parametrized respect properties network allows select appropriate version depending desired result 
tradeoff latency number messages framework adapt requirements application network 
experiments deal distinct roles results valid number roles 
difference definition ratio generally determined number nodes role divided sum nodes roles different fly code update describe techniques tinycubus tackle efficient fly code update problem 
call approach flexible code update updating code image adds flexibility needed support adaptation 
flexible code updates chosen implementation platform tinyos motes dynamically updating parts code image challenging 
reason nesc compiler statically combines application system code single binary object 
separation nesc components preserved compiled code way distinguish different modules binary representation 
addition memory statically allocated reallocated runtime 
order allow reallocation functions global variables nesc compiler needs modified 
normally nesc compiler creates large file contains complete source code system application components needed application 
file compiled platform specific version gnu compiler avr gcc 
break file separate files called packages contains logically associated nesc components 
compile packages separately link pc support exchange individual packages motes 
packages exchanged individually new provides interfaces external previous 
new version package installed addresses need patched new package rest application 
reason position functions variables memory may change size functions variables change version version 
mere code additional information metadata sent nodes order perform changes 
metadata linking performed motes pc 
exchanging packages arbitrary blocks update process follows natural view programmer 
package contains code logically belongs expect changes application local single package 
motes functions adjusted 
contrast change part program leads address shifts parts block algorithms transfer block cases fixed size single change address 
obviously inefficient cases complete code image transmitted 
approach tiny data management framework see section feasible 
complete packages associated metadata component type exist dynamically exchanged adaptation process intervention outside node 
flexibility key advantage solution compared protocols compute difference code images considering structure code 
create separate object files package 
just package needs replaced corresponding object file transmitted 
data needed motes integrate file application code symbol table relocation table 
symbol table contains id symbol address current package 
similarly relocation table contains entry access symbol 
reduce size tables inlining internal functions package 
addition compress size relocation table combining similar entries 
example relocation entries symbol grouped identifier symbol 
furthermore plan strip function symbols locally symbol table reduce size 
relocation table storage access complex 
global variables accessed package variables grouped memory regarding package contained possible distinguish variables internal package accessed externally 
identifier symbol required 
addition types relocations differ way addresses stored 
similar relocation table function symbols group entries type referenced symbol offsets command accessing memory package 
furthermore try minimize effects changes placing packages intelligently memory 
example system package accessed ones change 
placed position memory 
application specific package updated changes size system package modified 
exact version installed sensor nodes known advance basic scheme called basic optimized combining langendoen diff algorithm leading diff 
way differences new code size bytes original code image code symbol table relocation table fig 
size original packetized application motes package previous need transmitted 
computation differences easier approach addresses set zero compiler inserted package linked motes 
changed addresses main things need fixed diff produces edit scripts fewer entries pure diff algorithm 
evaluation evaluated application included tinyos distribution 
sample application periodically reads sensor data light sensor transmits base station radio link 
pc oscilloscope java application visualize sensor readings 
divided application packages components belong 
created radio package sensor package timer package application package system package 
radio package contains components associated radio communication sensor package access light sensor 
timer package includes components provide timing service 
application package contains actual application components main functions 
system package contains hardware specific components basic functions provided operating system 
usually nesc compiler heavy inlining optimize applications 
possible package 
functions called package inlined 
stack consumes memory runtime 
addition size code image increases slightly steps needed call small function prevail code function 
application size program image increases bytes bytes packages described see fig 

addition order able link applications motes application bytes metadata stored motes 
bytes metadata symbol table bytes relocation tables storage accesses 
compared size application size metadata quite large 
flexibility gained data reduced size code updates considered amount metadata acceptable 
exploring ways reduce size tables stored motes transmitted radio communication 
example approach applied transfer symbol relocation tables 
note metadata stored ram limited sensor nodes 
kept flash memory loaded necessary installation new component 
evaluate effectiveness code changes performed typical changes application sensor package 
minor change calling function initialization twice 
real benefit modification shows network traffic small require 
small change size application package increased bytes 
approach transmit symbol relocation table package bytes 
basic update requires size bytes langendoen basic code meta data diff fig 
bytes transfer simple bug fix size bytes langendoen basic code meta data diff fig 
bytes transfer complex change bytes total see fig 

contrast implementation langendoen diff approach mica motes transmits bytes change 
diff apply algorithm just package changes approach sends bytes code bytes metadata bytes total 
pure diff approach addresses inserted code 
fewer changes necessary 
comparison approaches transmit complete code image send kilobytes code 
complex change adding code light sensor computes moving average sensor readings 
introduces additional global variables adds lines code modifies 
modification size sensor package increased bytes bytes 
size corresponding metadata bytes sum basic transmits bytes 
shown fig 
langendoen pure diff algorithm sends bytes diff bytes 
results evaluation promising 
cases basic transmits bytes langendoen diff algorithm think overhead acceptable considering flexibility gained approach 
addition combining approaches done diff overhead reduced combination produces better results pure diff solution preserves possibility perform adaptation motes 
increasing complexity sensor networks sensor network applications management configuration techniques clearly needed 
identified major research problems field briefly described solutions 
challenge assignment tasks sensor nodes address specification language role assignment algorithm allows network dynamically adjust current situation 
described algorithm works shown possibilities improve 
second research problem efficient distribution code updates network 
evaluated algorithm leverages role information distribute code updates data network 
third challenge reduction size code updates adding flexibility supporting adaptation 
approach called divide code image separately updateable packages adjust code motes 
techniques configuration management sensor networks efficient practical energy aware 
shown developing technology tinycubus project 

challenge development efficient distributed role assignment algorithm resilient node failures 
addition plan extend role code distribution algorithm support highly mobile sensor nodes add functionality related projects trickle 
regarding code updates working reducing overhead metadata required motes increasing speed component transmission fly adaptation possible 
implementation tinycubus way prototypes cross layer framework configuration engine partially functional 
bonnet 
adaptive decentralized operator placement network query processing 
zhao guibas editors proc 
nd intl 
workshop information processing sensor networks pages 
gay levis von behren welsh brewer culler 
nesc language holistic approach networked embedded systems 
proc 
acm sigplan conf 
programming language design implementation pages 
goldsmith wicker 
design challenges energy constrained ad hoc wireless networks 
ieee wireless communications 
hill szewczyk woo hollar culler pister 
system architecture directions networked sensors 
proc 
th intl 
conf 
architectural support programming languages operating systems pages 
hui culler 
dynamic behavior data dissemination protocol network programming scale 
proc 
nd intl 
conf 
embedded networked sensor systems pages 
jeong culler 
incremental network programming wireless sensors 
ieee comm 
soc 
conf 
sensor ad hoc communications networks 
jeong kim broad 
network reprogramming 
webs cs berkeley edu tos tinyos doc pdf 
accessed 
gupta 
role hierarchical self organization wireless ad hoc sensor networks 
proc 
nd acm intl 
conf 
wireless sensor networks appl pages 
levis lee welsh culler 
accurate scalable simulation entire tinyos applications 
proc 
st intl 
conf 
embedded networked sensor systems pages 
levis patel culler shenker 
trickle self regulating algorithm code propagation maintenance wireless sensor networks 
proc 
st usenix acm symp 
networked systems design implementation 
marr minder rothermel becker 
adaptation cross layer issues sensor networks 
proc 
intl 
conf 
intelligent sensors sensor networks information processing pages 
marr minder sauter rothermel 
tinycubus flexible adaptive framework sensor networks 
proc 
nd european workshop wireless sensor networks pages 
langendoen 
efficient code distribution wireless sensor networks 
proc 
nd acm intl 
conf 
wireless sensor networks appl pages 
mer frank marr becker 
generic role assignment wireless sensor networks 
proc th acm sigops european workshop pages 
royer perkins 
multicast operation ad hoc demand distance vector routing protocol 
proc 
intl 
conf 
mobile computing pages 
heidemann estrin 
remote code update mechanism wireless sensor networks 
technical report tr university california 
sustainable bridges web site 
www net 
accessed 

tseng 
ni 
chen 
sheu 
broadcast storm problem mobile ad hoc network 
wireless networks 
yeh yamamoto 
air reprogramming wireless sensor nodes 
ucla ee project report 
cs ucla edu ee final 
pdf 
accessed 

