duce xml centric general purpose language benzaken lri cnrs universit paris sud orsay france benzaken lri fr 
functional language duce discuss design issues show adequacy working xml documents 
distinctive features duce powerful pattern matching class functions overloaded functions rich type system arrows sequences pairs records intersections unions differences precise type inference patterns error localization natural interpretation types sets values 
outline important implementation issues particular dispatch algorithm demonstrates static type information obtain efficient compilation schemas 
categories subject descriptors programming languages general programming languages language classifications applicative functional languages general terms languages keywords xml xml processing type systems 
duce general purpose typed functional programming language design targeted xml applications 
duce started years ago attempt overtake limitations xduce directions type system 
xduce demonstrates adequacy specific features regular expression types type patterns xml applications believe features integrated specific language 
interface xduce language mainstream language necessarily looses type information aim minimizing interactions duce external languages allowing define complex applications directly duce 
extended xduce type system introducing xml specific type constructions products records general boolean connectives union intersection difference arrow types class functions continuing semantic approach define subtyping initiated xduce 
practical side implemented type checker gives precise localization error messages exhibits samples demonstrate type checking failure 
language design 
added language constructions believe useful xml general purpose processing overloaded functions allow code sharing code reuse iter permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
icfp august uppsala sweden 
copyright acm 
giuseppe castagna cnrs partement informatique cole normale sup rieure rue ulm paris france giuseppe castagna ens fr alain frisch partement informatique cole normale sup rieure rue ulm paris france alain frisch ens fr sequences trees extensions pattern algebra particular allow extraction non consecutive subsequences 
studied precise typing constructions 
small design decisions turn practical 
instance xml tags duce class expressions allows computing tags strings sequences characters allows regular expression types patterns strings concatenating sequences containing characters xml elements strings boundary automatically concatenated 
run time system 
tackled problem executing duce programs efficiently 
key issue implementation pattern matching 
new kind deterministic tree automata combination top bottom automata developed compilation schema patterns automata uses static type information avoid unnecessary computation runtime 
allows programmer declarative style patterns degrading performances 
article focuses language design shows adequacy write applications handle transform query xml documents sketches solutions implementation issues 
keep presentation short just highlights language 
homepage duce includes online interactive prototype reader test duce check examples user manual duce programs larger compelling ones duce distribution site generated loc duce program transforms xml content description xhtml complete source code included duce distribution 
theoretical foundations duce type system 
related closest course xduce duce borrows key features regular expression types type pattern matching semantic inclusion xml types type inference patterns recursive patterns 
previous section mentions directions duce extends xduce 
core definition duce published languages evolved parallel 
independently haruo hosoya implemented xduce support exact typing variables different approach automata 
makoto murata defined extended xduce types handle xml attributes quite different way defined duce extensible records 
believe expressive power solutions comparable hosoya murata solution able express compactly dependencies attributes elements expand dependencies union types addressed mic issues avoid exponential explosion 
algorithm evaluating pattern sequence uses rewriting pass automaton requires fully materializing automaton compatible current efficient compilation algorithm likewise hosoya remove pattern optimization xduce incorporate new attribute support 
ongoing xduce constant influence plans include adapting duce hosoya insightful ideas sequence transformations 
duce project started deeply influenced xduce 
projects inspired xduce closest duce xtatic xquery 
goals xtatic duce similar try integrate xduce features larger design xml specific language duce builds functional flavour xduce extends full fledged functional language xtatic goes oo principles combines xduce types class hierarchy host language 
integration xduce xtatic smooth elegant language side special seq class clever treatment concatenation implementation side resorting encoding technique reminiscent pizza homogeneous translation 
xtatic duce face problem combining xduce semantic definition subtyping richer type algebra 
xtatic solution simpler relies named typing classes duce tackle classical issues dealing set theoretic interpretation arrow types 
theoretical side duce xtatic share design decisions including syntactic choices small decisions mentioned class xml tags strings sequences characters 
duce xtatic designs noticeable differences duce avoid stratification type algebra xml types non xml types permits pattern matching non xml data structures pairs records 
concerns implementation issues levin studied efficient pattern matching implementation xtatic 
concentrates definition generic kind matching automata target language suitable back ends pattern matching 
quite orthogonal focus optimization possible static type information 
possible express compilation algorithm term matching automata 
expressivity algorithm supports addition ambiguous patterns disambiguated match policy non linear capture variables repetition operators xml attributes implemented records duce 
xquery mainly aimed performing queries xml documents 
xquery type system took inspiration xduce surprising find lot similarities duce 
perform queries xquery adds xduce loop simulated duce transform iteration sequences support xpath removes complex pattern matching regular expression patterns structural typing replaced named typing xml schema avoid tree automata check subtyping validate documents 
supporting xpath upward axis yields copy semantics unusual functional languages element created xquery content copied duce xml subtree shared different documents 
rapidly growing importance xml rise works related xml processing 
due lack space decided focus projects closest duce 
overview works thorough comparison xduce duce approach refer reader 

sample session write comment sample duce program 
declare types type parentbook parentbook person type person type person gender name children tel email type person gender name children tel email type name name pcdata type children children person type tel tel kind home 
type type email email type parentbook describes xml documents store information persons 
tag tag attr 
attr 
followed sequence type denotes xml document type 
sequence types classify ordered lists heterogeneous elements denoted square brackets enclose regular expressions types note regular expression types type just describes content sequence type enclosed square brackets meaningless 
definitions state parentbook element formed possibly empty sequence persons 
person type value gender attribute 
equivalent definition person person gender name children tel email 
person element composed sequence formed name element children element zero telephone mail elements order 
name elements contain strings 
encoded sequences characters 
pcdata keyword equivalent regexp char string char pcdata pcdata pcdata 
equivalent notations 
children composed zero person elements 
telephone elements optional indicated 
string attribute value home formed single string non empty sequences numeric characters separated optional dash character 
wanted state phone number integer digits course meaningful phone number starts interval type tel kind home denotes type characters mail addresses 
regular expression defining email precisely constrain form addresses 
xml document satisfying constraints shown left column 
document stored file loaded built operator load xml assigned local variable parents immediately checked parentbook type parents match load xml parents xml parentbook raise wrong type 
declaration entered interactively system answers parents parentbook indicates type checker remembers parents type parentbook 
obtain value resulting load operation matched pattern parentbook 
pattern denotes simultaneous application sub patterns succeeds sub patterns 
example value matched variable succeeds binds value type parentbook succeeds value type 
pattern fails result load type parentbook value matched pattern succeeds denotes type values duce distribution includes dtd program translate dtds duce types 
support xml schema validation implemented alpha testing see 
xml version parentbook person gender name clara name children person gender name andr name children person children email clara lri fr email tel tel person person gender name bob name children person gender name alice name children person person gender name anne name children person gender name charlie name children person children person children tel kind tel tel kind home tel person parentbook xml duce parents parentbook parentbook person gender name clara children person gender name andr children email clara lri fr tel person gender name bob children person gender name alice children person gender name anne children person gender name charlie children tel kind tel kind home value matched succeeds raises exception caught try construction 
right column represents binding variable parents document written directly duce value 
type annotation 
parentbook optional general allows earlier detection type errors 
sequence values denoted list elements enclosed square brackets separated blank spaces 
purpose example different notations denote strings duce xyz xyz xy yz define string literal see 
note andr string accepted duce supports unicode characters 
example transformation names extracts sequences names parents parentbook element names parentbook name parentbook map person name transformation followed interface states names function parentbook elements possibly empty sequences name elements 
obtained matching argument function pattern parentbook binds sequence person elements forming parentbook 
operator map applies transformation defined subsequent pattern matching element sequence case 
map returns sequence obtained replacing person name element 
note pattern person match person elements matches captures name element element sequence matches discards sequence elements follow person matches tag person contains attribute 
interface type definitions ensure tags expected ones optimize code defining body skips check tags map 
optimization useless done implementation see course code readable 
extracting list parents wanted extract sublist containing parents exactly children replace transform map names parentbook name parentbook transform person children person person map applicable elements sequence transform filters pattern succeed 
righthand sides return sequences concatenated final result 
case transform returns names persons match pattern person children person person 
implementation compiles pattern exactly particular avoids checking sub elements children type person static typing enforces property 
examples show essence duce patterns pattern decompose values subcomponents captured variable checked type 
previous functions return names outer persons parentbook element 
want capture name elements recursively apply names sequence children names parentbook name parentbook transform person children names parentbook denotes concatenation sequences 
note order recursively call function sequence children include parentbook element 
elegant way obtain behavior specify names applied parentbook elements children elements union types denoted parentbook children names parentbook children name transform person names note pattern body possible function parentbook children elements 
functions pattern match discard rest sequence 
particular regular expression types 
type patterns match subsequences value 
instance pattern person tel matches person elements specify email element tel element 
may useful bind sequence captured pattern regular expression variable 
regexp type write say tel 
introduce special notation bind sequence matched type regular expression 
instance domain email string 
returns parts domain mail 
version see 
captures inside scope regular expression operators variable appears times regular expression variable bound concatenation corresponding matches 
distinctive powerful characteristics duce allows define patterns single match capture subsequences non consecutive elements 
instance type name string phones string person person name tel name phones map tel transforms person element record value fields containing element name list phone numbers 
obtained pattern tel binds sequence tel elements appearing person 
rationale pattern tel kind tel kind home email partitions tel email sequence subsequences binding list phone numbers list numbers list mails alternative patterns follow match policy second pattern matched fails 
write shorter pattern applied tel email sequences equivalent tel kind tel 
patterns compiled tel kind tel checking tag suffices determine element type tel 
storing phone numbers integers strings requires minimal modifications 
suffices pattern regular expression strip possible occurrence dash person name string phones int person name tel name phones map tel int case extracts subsequence formed numerical characters int fail type system issued warning consider type phonebook phonebook 
add new pattern matching branch definition function names parentbook phonebook elements 
yields overloaded function names parentbook name phonebook string parentbook map person phonebook map name overloaded nature names expressed interface states function applied parentbook element returns list names applied phonebook element returns list strings 
factorize branches unique alternative pattern names parentbook name phonebook string map person name interface ensures representations mix 

presentation duce language type algebra duce type algebra specific constructor sequences regular expression types 
constructions previous section encoded shown core type algebra formed types native scalar types int char atom atoms symbolic constants form arbitrary identifier type constants empty written especially patterns denote respectively empty smallest universal largest type types constructors record types product types functional types xml types specify respectively possible tags attribute sets element contents boolean connectives intersection union difference singleton types scalar constructed non functional value type instance nil denotes type empty sequences type integer type system deduces type subtype digits 
recursive types defined recursive toplevel declarations syntax type identifiers identifiers starting capital letter 
duce types set theoretic interpretation type set values closed irreducible expressions roughly expressions applications field selections matching expressions word result value type 
example type set expressions value type similarly set closed functional expressions fun 
type 
interpretation types basis duce type system programmer rely understand type constructions type equivalences system 
example difference types contains values contained type second union types formed values type intersection say arrow record equivalent sense interpretation empty type 
particular subtyping just set inclusion type subtype contains values details see 
records 
different kinds record types open record type denoted classifies records fields labeled prescribed type fields may appear closed record type denoted forbids label possible open closed record types specify optional fields syntax states field may absent type 
lot natural subtyping equivalence relations hold record types instance deduced set theoretic interpretation record types sets record values 
scalars 
took special care definition implementation scalar types integers arbitrary precision believe xml applications important exact results optimize intensive numerical computations char represents unicode character set 
subtypes int char intervals form integer literals character literals accordingly 
specify instance month attribute xml element integer 
encoded types sequences 
lisp sequences encoded pairs atom nil representing empty sequence sequence values written duce syntactic sugar nil 
subtlety singleton record types 
instance type open contains records field fields 
singleton type corresponding value written 
chosen notation record values open record types believe open record types useful programming closed ones 
sample section saw regular expressions types define new sequence types 
just syntactic sugar sequence types reality defined combining boolean type connectives recursive types 
instance int type function defined int nil 
strings 
strings special case sequences intensive datatype xml documents worth special care 
main design choice strings string native basic type encoded char 
necessary dealing real world xml documents strings alternate xml xhtml elements simply consider example 
having string basic type problematic automatic concatenation performed 
considering strings sequences characters simply consider example equivalent simply consider example equivalent sequence characters separated 
course sequences formed character literals allow classical double quote notation values xml attributes fall case 
paid special attention implementation strings compact representation long possible convert sequence characters necessary transparently user see 
xml elements duce type primitive range types practice working xml documents usually atom record type sequence type 
xml types conceptually encoded terms atoms records pairs new type constructor justified need avoid possible interferences 
said important notice type system restrict possible values tag position atoms 
instance possible pairs simulate namespaces namespace denoted atom namespace normalization string namespace uri xhtml li li syntax specific namespaces surely needed current definition duce handle xml namespaces 
xml element tag elem seq tag written duce tag elem seq 
appearing tags back quote atoms curly brackets records may omitted href click htm target top click applied convention examples sample session notations apply types shown examples 
xml element construction holes tag attribute record content filled arbitrary expression tag link href 
click tag link functions del target link link target add target link link target top classical problem xml parsers usually guarantee text nodes represent maximal textual portions documents free split adjacent characters text nodes version duce plan introduce specific notation xhtml li adapt xml primitives load xml 

respectively remove add target attribute html element removes field denotes destructive addition fields 
possible restrict authorized attribute names closed record type default open type instance element type type tel tel kind home 
may kind attribute 
similarly specify specific attribute absent type tel kind empty 
read attribute kind value type empty value means attribute kind 
overloaded functions simplest form toplevel function declaration body function formed single branch pattern fun matching 
seen previous sections body function may formed branches complex patterns 
interface specifies constraint behavior function checked type system applied argument type function returns result type 
general interface function may specify constraints names example 
general form toplevel function declaration vertical bar fun keyword optional 
function accepts arguments type types intersection 
arrow types interface serves give function precise type 
roughly distinguish different uses multiple arrow types interface 
arrow type specifies behavior different piece code forming body function compound interface serves specify overloaded behavior function 
case function add int int int string string string int int string string arrow type interface refers different branch body 

arrow types specify different behavior code compound interface serves give precise description behavior function 
example function names 
clear separation situations general overloaded function body branches specify behaviors different arrow types interface share common portions code 
examine complex example 
want transform representation persons introduced different tags man woman gender attribute conversely attribute element name 
want distinguish children person different sequences sons composed men elements tagged man daughters composed women 
course want apply transformation recursively children person 
practice want define function split type person man woman man woman types type man man name string sons daughters type woman woman name string sons daughters type sons sons man type daughters daughters woman possible way implement transformation split man woman gender children mc fc tag match woman man map mc split map fc split tag name sons daughters function split declared overloaded function applied returns element type man applied returns element type woman 
body composed single pattern matching pattern binds variables bound gender argument function bound name mc bound sequence children type fc bound sequence children type 
line define tag man woman value apply split recursively elements mc fc 
overloading mc type overloaded type split deduce type man similarly deduce type woman 
type checker deduces expressions sons daughters type sons daughters returns split function type man woman 
note overloading critical split type person man woman split type man woman subtype declared split type function type checked recursive calls able deduce type man woman type check result 
example wanted define transformation xduce need apply filter transform children separate male females duce obtain simply pattern resort auxiliary functions nearly definition differ type type man type woman 
transformation elegantly defined xslt moderate increase expense loosing static type safety type optimization see section preliminary benchmarks 
higher order functions duce functions including overloaded ones class expressions 
means function fed returned called higher order function 
syntax local function toplevel function declaration fun difference omitted function recursive 
note ing function function type say expected 
higher order functions improve code reusability sharing common code providing specialized parts functional arguments 
setting xml applications typical parameterize generic printing function displays documents dtd xhtml providing specialized functions print various subparts documents instance functions charge displaying dates format chosen user 
class functions mind going implement web application server runs duce scripts 
producing xhtml pages scripts generate variant xhtml duce code replacing input elements 
instance input type submit scripts directly generate function seen class value triggered user clicks button function identifiers bound form fields normal duce variables 
web application server transform pseudo xml document embedded duce functions real xml document sending client storing internal tables duce functions called 
request call function corresponding button user pressed 
advantage approach twofold static typing know value handled transformation correct type importantly web administrator longer maintain cgi programs consistent html pages done server 
example demonstrates class functions embedded xml documents particular addresses problems aspects extends approach 
uses xml templates valid documents embedded gaps filled templates propose embed higher order function duce expression relies global data flow analysis statically enforce validity generated xhtml correspondence generated forms received fields plan current duce type system check 
advantages higher order programming known functional programming language community space limited elaborate 
lack class functions xml languages identified papers semantic approach subtyping succeeded mixing classical arrow types xml types 
pattern matching pattern matching duce key features 
resembles ml powerful allows express single pattern complex processing dynamically check structure type matched values 
saw examples pattern matching forming body function declaration 
ml duce standalone pattern matching expression match 

local binding just syntactic sugar match pattern matches rejects value matches binds capture variables corresponding parts value computation continues body branch 
control passed branch 
simple description behavior pattern matching actual implementation uses naive efficient algorithms simulate 
instance designed algorithm uses single partial traversal value dispatch correct branch benefits static typing information avoid redundant checks see 
capture variables 
ml variable say pattern accepts binds value pair pattern accepts value form matches 
variable appears pattern binds value semantics bind pair pattern 
instance pattern matching branch equivalent 
similarly equivalent 
interesting examples showing expressiveness construction presence recursive patterns 
record patterns form matches record fields content matches matches records formed exactly fields content matches 
convention types allow omitting curly brackets open records occurring tags 
contrary pair patterns allow multiple occurrences variable record pattern 
type constraint conjunction 
type pattern 
semantics pattern accept values type creates binding 
particularly useful duce type may reflect precise constraints values structure content 
note scalar constants patterns special case type constraints singleton type 
wild card type simply alternative notation type constant matches value 
combine type constraint capture variable conjunction operator patterns int 
semantics conjunction pattern check sub patterns merge respective sets bindings 
patterns conjunction disjoint sets capture variables conflict arise merging 
alternative default value 
alternative disjunction operator match policy tries match pattern fails tries patterns set capture variables 
alternative patterns conjunction pattern arbitrary scalar constructed constant provides default value capture variable 
recursive patterns 
recursive patterns syntax recursive types variables ranging pattern identifiers identifiers starting capital letter 
recursive patterns allow express complex extraction information matched value 
instance consider pattern int extracts sequence element type int recall sequences encoded pairs 
order important pattern int extracts element type int 
pattern may extract reconstruct subsequence convention described capture variable appears sides pair pattern values bound variable paired 
instance int nil extracts elements type int sequence bound sequence containing pattern int int extracts pair consecutive integers 
regular expression patterns 
duce provides syntactic sugar defining patterns working sequences regular expressions built patterns usual regular expression operators sequence capture variables form pattern regular expression 
conversely pattern capture variables type moti choice notation constructors common types patterns 
instance term pattern position interpreted type constraint type constructed constant type constraint type product type scalar constants pair pattern formed type constraints 
interpretations yield semantics 
constructors types patterns reduces number possible denotations semantic viewpoint pattern different syntax product types say denotations 
pattern 
reason motivates choice denoting record types common 
regular expression operators greedy sense try match times possible 
versions 

provided difference compilation scheme just matter order alternative patterns 
instance int compiled int 
int compiled int 
detail compilation example sequence capture variable 

step propagate variable simple patterns 
compiled recursive pattern nil nil pattern double purpose checks matched sequence reached binds nil create new sequence 
note difference int int 
patterns accept sequences formed single integer binds second binds sequence 
mix greedy operators match policy alternate patterns allows definition powerful extractions 
instance define function person returns phone number mail telephone number string contact preferred contact person string 
tel kind email tel contact note tel need preceded wildcard pattern possible remaining case 
extra support sequences queries special support sequences core type pattern algebras regular expression types patterns just syntactic sugar duce provides language constructions support 
map transform 
duce features construction map 

expression evaluate sequence elements go pattern matching get transformed matching branch 
static typing ensures existence branch 
typing map precise working heterogeneous sequences keeps track order elements input sequence shown example uses function split defined section man woman map split type system able infer result map type man woman 
argument type 
type inferred result man woman 
precision typing reach user definable polymorphic map function ml parametric polymorphism incorporated duce started studying built map probably user definable precise typing closely characterizes complex behavior 
map construction affect length sequence element mapped single element 
useful map elements sequence filter duce provides variant map written transform branch pattern returns possibly empty sequence returned sequences element source sequence concatenated 
implicit default branch added unmatched elements discarded 
transform similar generic loop return simply translated transform 
special sequence operator works sequences xml trees 
matches patterns root element xml tree fails recursively applies sequence sons root 
function puts boldface links xhtml document simply defined bold xhtml xhtml note variable preserve attributes href rel target 
link 
note obliged iterate dtd xhtml 
short combines flexibility xslt template programming precise static typing efficient compilation duce transform 
queries 
duce designed recasting xml specific features xduce general setting higher order overloaded functional languages 
turns small set extra constructions endow query facilities standard database world projection selection join 
mentioned transform generalizes iteration 
projection operator denoted defined construction duce sequence expression type syntactic sugar transform transform new syntax obtain notation close xpath parents parentbook person children person tel kind home returns sequence home phone numbers children parents base static typing path parentbook person ambiguity possible 
function names implements exactly query 
transform somewhat freezes implementation declarative nature path expressions spots places code query optimization instance equivalences similar mentioned applied 
generally currently adding algorithmic constructions duce set declarative query constructions amenable optimization techniques 
particular currently adding classical select expressions clause take advantage powerful duce pattern algebra 
order clauses left unspecified system free apply algebraic cost model optimizations available indexes implement joins efficiently 

types type system core duce 
language conceived designed 
practical point view interesting useful characteristic type system semantic interpretation described type set values denoted syntactic expression fact duce implement constructions surprising turing complete language 
point defining fixed implementation constructions semantic foundations duce obtain different implementations natural insofar semantic transformations pave way query optimization 
take advantage fact duce single pattern extract elements type define compact encoding transform course type system induces set theoretic interpretation types sets values 
point duce type system built interpretation 
result subtyping relation duce sound complete set inclusion type systems soundness holds type subtype values simple intuition needed grasp semantics duce type system particular subtyping subtyping defined inclusion sets values type subtype value type type hold type system exhibit sample type type 
boolean connectives boolean connectives type algebra interpreted simply set theoretic counterpart sets values intersection union difference usual set theoretic operations 
type equivalences types equivalent values values vice versa 
example int string int int string int 
important understand types pervasive duce 
particular pattern matching basically seen dynamic dispatch types combined information extraction gives duce type driven semantics reminiscent object oriented languages overloaded functions mimic dynamic dispatch method invocations 
note class approach mapping xml element type class infeasible standard dispatch mechanism oo languages powerful pattern matching look extract information deep inside value 
keeping methods separate objects get equivalent multi methods dispatch type arguments just type distinguished self 
dynamic function types play major role static counterpart language 
type correctness duce transformations statically ensured 
important point type systems proposed xml documents dtd xml schema relax ng 
xml applications written languages xslt xduce duce ensure program produce xml documents expected type 
furthermore xduce duce pattern matching exact type inference sense typing algorithm assigns capture variable exactly set values may capture 
yields precise static type system provides better description dynamic behavior programs 
types play important role compiler back 
type driven computation raises interesting issues execution model duce opens door type aware compilation schemas type driven optimizations hint 
highlights type system duce type system relies interpreting types sets values important explain values typed 
apart function values straightforward focus typing rule functions 
order simplify presentation split rules subrule typing function bodies lists pattern matching branches derivation typing rule functions 
empty pattern matching function bodies 
denote sequence branches 

rule derives typing judgment meaning matching value type sequence branches succeeds possible result type 
converse hold 
look rule detail 
matched value type 
left premise checks pattern matching exhaustive pattern type represents exactly values matched 
exhaustivity condition states value belongs accepted pattern 
type check branch 
runtime branch considered knows value rejected previous patterns branch succeeds knows value type type checking expression th branch knows value type say type type types 
type check body branch collect type information variables bound 
purpose typing environment associates variable type collects values bound matching value type 
evident magic type inference resides operators 
operators introduced 
definition reflects intuitive semantics derive algorithms compute 
section examples illustrate complex computations performed algorithms 
result pattern matching result branches potentially 
expressed union result type branch empty notation stands empty branch fun selected corresponding included union 
functions 
useful unused branches empty pattern matching answer typing rule functions type system simply checks constraints interface function call recursively typing body record type environment function type interface 
body type checked times type may case branch 
illustrate simple example fun int int string string int string type checking body constraint string string branch return type empty type assigned constant taken account check constraint 
minor point considering return type unused branches main difference dynamic overloading type case equivalently types 
returns union result types branches able discriminate different input types 
point view programmer quite easy determine type function value simply intersection types specified interface 
pattern type inference examples saw core type system 
defined smallest solution set equations may solutions considering recursive patterns 
definitions quite straightforward reflecting intuitive semantics operators 
example defined set equations simply states pattern formed variable matches type formed values pattern type matches values contains alternative pattern matches union types matched pattern 
recursive patterns handled considering infinite unfolding regularity generate equations finite systems 
data constructors records xml elements treated pairs 
intuition guides definition 
example states match pattern values ranging type values captured exactly 
similarly match values ranging alternative pattern values captured variable captured pattern matched values accepted captured second pattern matched values accepted see appendix rest definitions 
important result definitions equations define algorithms compute 
going details algorithms prefer give examples show subtlety computation required perform 
consider pattern int nil extracts integers occurring sequence table show types values captured variable pattern matched values ranging different types 
typing patterns pattern matching functions essentially needed understand type algorithm works remaining rules straightforward 
exception typing constructions map transform need compute transformations regular expressions types techniques 
int string int int int int string int 
int string int int int string int int int string int string int 
implementation section briefly highlight important implementation issues solutions specific approach 
developed prototype objective caml compiles needed pattern matchings internal automaton representation justin time 
despite interpretative overhead exhibits satisfactory performances 
typing duce programs theoretically complex subtyping relation exponential size involved types possible find short programs kill type checker case ml instance 
designing duce put emphasis expressiveness language efficiency produced code accepting theoretical complexity type checking 
xduce proved type systems precisely matched sequence bound subsequence containing integers order appear 
xml programs regular expression types workable prototype gives confidence duce new features 
plan develop compiler duce perform serious benchmarking performance tests 
preliminary benchmarks prototype see encouraging 
localization error messages 
formalized static type checking duce programs classical presentation type system bottom inference rules 
known type checking failure direct implementation rules provide localized error messages 
instance consider fun turns type 
typing rule triggers error abstractions 
sees body branches black boxes localize error function expression 
different example application function type say xhtml xhtml document html head 
typo tag typing application fail bottom algorithm precise track misspelled 
solution type check programs mixed top bottom algorithm 
particular adopted technique types expressions propagating constraint syntax tree root leaves 
constraint gives upper bound resulting type sub expressions catches errors earlier localizes precisely 
solution highly effective coupled duce typing precise quite interestingly unexpectedly typing precision induces similar precision error localization 
example prototype localizes error depending error second localizes tag highlighted red screen emits error message stating body 
precision error localization combined duce capacity exhibit value expected type matching definition produces informative error messages 
invite reader test issue online prototype duce distribution 
formally type system propagation constraint defined typing relation typing environment expression type check constraint resulting type subtype 
instance typing rule pairs represents set theoretic projection smallest solution represents best refinement constraint knowing precise type defined largest solution 
instance error localized type checked constraint 
implementation typing algorithms 
defined high level specification subtyping algorithm notion coinductive simulation characterizes empty types subtype difference type empty 
optimizations subtle implementation techniques applied order move specification practical algorithm including mentioned informed reader note algorithm easily improved caching negative results destructive structure invalidated different assumptions 
algorithm uses top approach avoid exponential explosion due presence union types requires backtracking suboptimal respect theoretical complexity backtracking prevents persistent data structure 
implementation uses efficient local solver monotonic boolean constraints developed occasion 
efficient backtracking top approach theoretically practice implemented 
conjecture guarantees optimal theoretical complexity 
set theoretic rule denotational foundation duce primary source studying implementation issues quite simple set theoretic observations allow important optimizations 
instance type appears execution typing algorithm 
naive development consisting repeated systematically yield terms 
avoid exponential explosion noticed result written provided pairwise non intersecting formula simplified erasing empty terms 
possible enforce condition splitting types 
general case fall back practice closer linear case 
checking enforcing condition requires applications subtyping algorithm results shown worthwhile 
kind split distribute technique places implementation reminiscent analogous techniques mentioned boolean algorithms 
pattern matching compilation type driven optimizations 
duce type checking just preliminary verification 
believe static typing key designing efficient execution model duce xml languages general 
grasp idea consider types function fun int naive compilation schema yield behavior 
check pattern matches argument 
check xml element form run verify non empty sequence elements type checking element type may expensive represents instance complex dtd 
fails try second branch tests argument may run completely times 
useless tests known statically argument necessarily xml element tag need check 
content non empty sequence elements type type determine situation simply look element perform tests discriminate instance 
looking head tag sufficient match compiled 
optimizations small part argument looked just 
general naive approach compiling pattern matching may yield multiple runs backtracking matched value 
forgetting moment functions records values seen binary trees types simply represent regular tree languages 
known fact tree languages recognized deterministic bottom tree automata indicates backtracking eliminated 
possible adapt theory tree automata handle full range duce patterns capture variables values 
determinization may create huge intractable automata number states transition function due fact automata perform uniform computation disregarding current position tree 
matching pair different computations performed smaller automaton classical bottom tree au flexibility 
help pattern matching want take static type information matched value account 
combined previous matching start example result computation get information dynamic type matched value simplify instance statically know type non intersecting types computation tells type know necessarily type check required 
static type information possible avoid backtracking avoid checking parts matched value 
particularly useful working tag coupled document types dtd types tag xml element provides lot information content 
designed implemented efficient compilation schema incorporates optimizations 
lack space complexity algorithms keep describing publication see online extended version outline 
just state interesting property compilation schema semantic respect types sense produced code depend syntax types appear patterns interpretation 
need simplify types instance applying type equivalences producing code simplifications internalized compilation schema 
representation run time values 
duce patterns check runtime value specific type 
able distinguish efficiently representation say pair value integer value record value 
prototype values implemented ocaml sum type type value pair value value char int integer 
gives possibility introduce derived forms runtime values order optimize specific cases easily detected compile time 
derived form inspected dynamically coerced canonical representation 
instance duce character strings conceptually sequences unicode characters value ab represented pair char pair char xml 
order avoid allocation sequence cells pairs long strings added sum type values special form strings forms corresponding different internal encodings type value 
string int string value integer points string buffer characters second argument third argument corresponds rest sequence nil atom case sequence characters 
value represented compactly string ab xml value inspected pattern seen pair char string ab xml ocaml string buffer ab copied 
idea compact representation long string inspected 
example special form lazy version concatenation operator sequences unusual build long sequence extending repeatedly right 
canonical representation sequences requires copying argument may yield quadratic behavior linear expected 
solution delay computation result inspected binary tree nodes efficiently linearized 
course derived forms completely transparent programmer affect semantics language 
benchmarks 
performed preliminary benchmarks evaluate duce performance validate type driven approach compiling pattern matching 
section comparison duce xslt processor program gnome library 
tables display execution time seconds user time reported unix command sizes input xml documents implementations transformation 
execution times give duce programs include times xml parsing type checking validation input documents times xslt programs include xml parsing time xslt untyped 
transformation simple filtering flat xml documents 
order test effectiveness duce type driven optimization performed auto benchmarking testing different duce programs implementing transformation 
particular considered different versions transformation uses explicit recursion implement traversal document second uses transform construction furthermore version considered variant denoted opt optimized hand replacing dynamic type checking minimal tests tags 
mb mb mb mb mb duce duce opt duce duce opt xslt second transformation considered simplified version function 
duce version uses standard pattern person gender name children mc fc 
second uses hand optimized pattern gender mc gender fc 
third duce version duplicates main function avoid overloading useless computations tags 
xslt versions slightly different styles templates single template computations tag 
kb mb mb mb mb duce duce duce xslt xslt preliminary benchmarks allow draw 
duce exhibits performances duce programs usually faster equivalent xslt transformations quite efficient xslt processor written files tests show execution times linear size data 
compiling duce programs remove interpretative overhead type checking runtime expect improvements 
real usage scenario transformations composed single duce program avoid parsing validating printing intermediate xml documents 
secondly negligible difference execution times normal hand optimized versions duce programs demonstrates effectiveness type driven compilation approach hand coded optimization 
means duce runtime avoids burden coding optimizing patterns allows programmer declarative robust style pro test machine athlon mbytes ram 
code benchmarks available 
gramming 
want stress examples benchmarks exploits full power duce type optimization examples possible gain brought duce optimization came avoiding useless tests tag names examples compact duce optimization ignore subtrees input documents 
case duce runtime system expected succeed best expect real case advantage duce evident terms pure performance 
include benchmark section comparison xduce xduce optimized runtime 
type checking aspect compare xslt complex transformations type checked significantly faster duce xduce instance simplified version xduce distribution takes duce versus xduce xduce xduce pattern optimization turned 
currently performing extensive benchmarking comparing performances respect xslt xquery 
plan report complete results duce site benchmark pages 

ongoing duce extension xduce richer set basic types char string int intervals constructed types open closed records intersections differences singletons adding language overloaded higher order functions powerful sequence extracting patterns records tags class expressions 
important notice obtained smoothly small core semantically defined key features duce relies theoretic construction quite different xduce construction deep impact implementation language typing subtyping algorithms 
separate article preparation 
begun formally studying security issues duce preliminary results available duce web site 
language just finished implementing presently testing xml schema integration validation 
obtained importing schemas duce types validating duce expressions 
greatly simplifies typed import xml documents treated duce data model xquery choice directly xml schema data model 
implementing query language hinted section developing simple logical optimizations benchmarking bell labs xquery implementation xquery cases www org tr cases testbed 
expect results merge cvs branch main duce branch year 
currently studying module system supports incremental programming cross module specialization 
basic idea understood considering toplevel definition function add section 
new fun declaration add hide older 
experimenting specializing declaration method add char string string new definition specializes definition add sense defined add follows fun add char string string int int int string string string char string int int string string definitions smoothly encoded core duce combination dynamic scoping technique similar java parasitic methods incremental programming style obtained allowing cross module specialization form method add 
studying module system query language extensions hinted plans include study polymorphic lazy types exploration interactions languages type systems typically existing libraries development tools better interfacing duce xml tools standards 
acknowledgments 
want dario haruo hosoya vouillon philip wadler useful constant feedback pietro di lena help xslt stefano xml schema abigail pope proof reading icfp referees remarks greatly contributed improve presentation article 
special go pierce useful suggestions discussions inputs topics 
abadi cardelli pierce plotkin 
dynamic typing statically typed language 
acm toplas april 
bell labs 
galax 
chamberlin fernandez florescu robie sim stefanescu 
xquery xml query language 
working draft 
boyland castagna 
parasitic methods implementation multi methods java 
oopsla pages 
christensen ller schwartzbach 
extending java high level web service construction 
acm toplas 
appear 
clark derose 
xml path language xpath 
recommendation 
mary fern ndez sim philip wadler 
algebra xml query 
fst tcs lncs pages 
frisch castagna benzaken 
semantic subtyping 
th ieee symp 
logic computer science pages 
pierce 
regular object types 
proceedings th workshop fool 
hosoya 
regular expressions pattern matching simpler design 
unpublished manuscript february 
hosoya pierce 
xduce typed xml processing language 
acm toit 
appear 
haruo hosoya 
regular expression types xml 
phd thesis university tokyo 
haruo hosoya makoto murata 
validation boolean operations attribute element constraints 
plan 
hosoya vouillon pierce 
regular expression types xml 
proc 
icfp sigplan notices 
michael levin 
matching automata regular patterns 
tech 
rep 
odersky wadler 
pizza java translating theory practice 
proc 
th acm popl 
sim wadler 
essence xml 
proc 
th acm popl 
patterns capture names type constraint names complying xml recommendation starting upper case literal pattern variable conjunction variables alternative names complying xml recommendation pair starting colon underscore lower case literal xml pattern fun xml friendly integer open record literal closed record sequences base types fun default recursion functions string int char bool types base types expressions constant atom variable singleton function union application tt intersection pair difference xml element functions xml friendly xml tree prefix operator xml friendly op infix operator type variable recursion open record record field select field remove closed record sequences sequences projection coercion empty empty type values coerced values attribute list raise try match map raise exception empty attribute list trap exception mandatory attribute match optional attribute map list attributes transform filter interval limit op xml tree transf prefix operators load xml load html load file load file utf type regular expressions po print print xml print xml utf po dump file dump file utf int string atom flatten pattern regular expressions infix operators po div mod sequence content postfix operators www org tr rec xml nt name conventions write pcdata char write xy yz xyz xyz write 

fun 
allowed fun 
types string bool defined char true false respectively 
syntax duce constants atoms singleton types interval 
