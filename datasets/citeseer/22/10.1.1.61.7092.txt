automatic generation assumptions modular verification software specifications claudio de la riva javier computer science department university campus gij spain phone fax claudio es 
model checking powerful automated technique mainly verification properties reactive systems 
practice model checkers limited due state explosion problem 
modular verification assume guarantee paradigm mitigates problem divide conquer technique 
unfortunately approach automated reason user specify environment model 
novel technique automatically generating component assumptions behaviour environment remainder components systems 
phase environment component computed state space exploration techniques assumptions generated association rules component environment interface 
approach presents number advantages 
firstly user assistance specify assumptions necessary assumption discharge avoided 
secondly component assumptions restrictive real reduce resources needed model checker 
technique applied specification steam boiler system 
keywords assume guarantee reasoning model checking modular verification component verification 
model checkers powerful useful automated tools verification finite state systems clarke 
property model system model checker performs exhaustive state space exploration system returns true property holds system counterexample scenario illustrating violation property 
techniques traditionally verification hardware devices 
researchers started apply model checking techniques software systems ranging specifications chan source code chaki 
main drawback tools state space explosion problem general size state space model checker handle grows exponentially number processes states constitute 
case reactive systems composed parallel concurrent processes maintain continuous interaction environment 
introducing techniques partial order reductions peled symbolic representation states transitions mcmillan model checking procedures systems large state spaces verified 
techniques limitations realistic systems tractable 
promising natural approach avoid state explosion problem divide conquer techniques system broken components verified separately rest 
problem verification global system analysis individual components compositional modular verification 
issues modular verification difficult 
deciding partition system trivial significant impact resources needed verification 
second model checking component isolation model environment interacting component introduced 
environment supplied universal environment general final preprint version published journal systems software vol 
pp 

elsevier doi jss environment considered component receive send event order environment 
obviously approach real components designed operate concrete environment 
approach considered pessimistic alur giannakopoulou 
mcmillan mcmillan calls problem environment problem 
focuses second problem employing assume guarantee framework jones pnueli abadi lamport 
style reasoning addresses environment problem specifying environment assumptions manually provided engineer 
property verified component assumptions environment guarantee assumptions verified remaining components system environment 
modular verification assume guarantee rules extensively studied application large scale problems scarce shankar due fact partly needs user guidance 
general assumptions incorporated component user knowledge feedback obtained counterexamples giannakopoulou 
firstly component checked assumptions universal environment 
model checker returns unrealistic counterexample false positive user number attempts define set appropriate assumptions eliminate false positive turn reflect adequate behaviour environment 
approach various weaknesses 
firstly verification model checker fully automatic modular verification aforementioned process 
engineer provide assumptions difficult task assumptions discharged environment 
secondly process error prone manual assumptions sufficiently restrict environment produce false positives 
short approach time consuming human effort computational resources manual specification assumptions discharge environment 
develop novel technique providing automated support modular verification assume guarantee reasoning software specifications 
component verify state space environment computed composition step set possible configurations environment obtained 
second step extraction event relations component environment assumptions computed association rules 
component verified assumptions obtained model checker 
applying process component system system verified modular automatic fashion substantially reducing state space explosion side user guidance user required partition systems components local properties 
fig 
illustrates approach 
environment composition assumptions fig 
assumption generation 
component property model checker true false counterexample technique applied software specifications modeled state transition systems synchronized events semantics time levels external interactions internal interactions microsteps harel leveson :10.1.1.20.5519
rest article organized follows 
underlying computational model section 
composition extraction steps approach detail sections respectively 
section showing results obtained application method various components steam boiler control program 
results topics relative applicability approach discussed section 
related outlined section section 
background section describe syntactic semantic framework system approach review foundations modular verification assume guarantee reasoning 
finite state machines fsms model individual processes system 
fsm contains states process may reach transitions may perform 
formally fsm tuple set states initial state set input output events process respectively transition relation states fsm 
transition means process executes transition receives input event changing state producing set events fsm implicitly control state represents local state process initially 
transition enabled evaluation input events condition true 
set enabled transitions state denoted enabled 
composition processes synchronous reactive systems fsm captures basic behaviour process 
component reactive system formed set processes interacting parallel 
synchronous reactive systems srs model behaviour communicating components concurrent reactive system 
intuitively srs set fsms interacting environment set external input output events 
events internally communicate fsms named internal events 
fig 
shows simple system modelled srs composed processes 
receives external input events environment init finish sends internal events start 
depending local state produces external output events open close 
init start finish fig 
srs example closed start open close opened describe behaviour srs adopt step semantics described rsml language leveson statecharts tool statemate asynchronous mode harel naamad 
macrostep starts external input events arrive 
internally macrostep formed chain microsteps 
microsteps system reacts input events executing locally enabled transitions fsms producing external output events internal events may initiate microstep 
macrostep completed transitions executed 
point output events generated macrostep sent environment time 
fig 
depicts concepts 
environment change micro steps input events output events macro step environment change environment change fig 
microsteps example srs fig 
supposing processes initial states environment produces init external input event starts macrostep 
process executes local transition generates internal event start microstep initiates second microstep executing transition closed opened 
transitions executed configuration macrostep finishes sending external output event open environment 
specifically srs tuple ge oe set fsms ge set internal events communicate fsm oe external input output events respectively transition relation describes semantics outlined define 
initial state srs set initial states fsms 
global state composed control states fsms 
denote configuration srs state srs values internal external input external output events system respectively 
set possible configurations denoted global 
provide semantics basis definition transition relation global global inference rules 
start rule represents commencement macrostep microstep execution 
environment changes new external input events enter system 
applies fsm mi enabled transition state si initial configuration macrostep 
mi multiple enabled transitions configuration taken non deterministically 
various fsms enabled transitions initial configuration macrostep executed simultaneously ai enabled ci ai ge ai oe internal external output events respectively generated consequence microstep execution 
advance rule represents execution microstep consequence internal events ge generated previous microstep 
start rule various fsms enabled transitions executed simultaneously ai enabled ci si stuttering rule fsm mi state current configuration microstep enabled transitions consumes events produce events ai enabled ci si rule represents macrostep 
rules apply fsm show srs execution microstep level rule applies srs defines macrostep concludes 
process execute stuttering rule srs reached stable configuration macrostep ends sending environment output events produced chain microsteps 
synchronous reactive components order perform modular verification global system broken components may verified separately 
point view component formed set fsms modeled srs 
perform local verifications components internal events communicate treated differently rest take value microstep 
define synchronous reactive component component short srs set internal events divided internal events component ge input interface events ge internal events produced components output interface events ge internal events components 
denote inti configuration component inti values internal input output interface events respectively 
microstep start input interface event reaches component advance rule srs slightly modified define execution microstep component ai enabled inti ci inti rule states microstep activated values internal events generated preceding microstep values input interface events inti received preceding microstep 
remaining rules srs directly translated component 
assume guarantee modular verification mentioned main problem automatic tools model checkers verification realistic system state space explosion problem 
natural approach solving problem divide system components perform local verifications separate components deduce number global properties system compositional modular verification de roever 
assume guarantee reasoning handles modular verification environment component assumptions environment subsequently guarantee 
abadi lamport compositional theorem abadi lamport components global system perform verification local properties component assuming kind behaviour components 
instance prove true component assuming behaviour component verify behaviour assumed true assumption discharge commitment 
process applied way property may conclude true system context computational model assumptions specified component related input interface 
instance suppose system formed components respective input interface events 
assumptions component formulated terms events component terms event specified order logic formula 
example assumption occurs occur relative component encoded 
composition step goal stage obtain set configurations environment step generating assumptions section 
system component verify component represents environment 
step computes set global global operator erases global output interface events environment part input interface component 
reachability depth search algorithm starting initial configuration component possible value input events new configurations generated microstep operator rules defined section section 
process continues new reachable state concludes configurations stable microsteps executed reachable states 
microstep operator applied new microstep configuration generated approach non deterministic situations guaranteeing configurations explored 
fig 
summarizes approach 
shaded nodes represent stable configurations reachable states rest configurations corresponding microstep 
arrows stable configuration represent execution microstep combination input event values start rule 
arrows connect configurations represent execution microsteps start advance rule dashed arrows execution stuttering rule 
path stable configurations defines macrostep 
graph computed top bottom left right different constructed entirety 
fig 
shows example component fig 

fig general strategy compute configurations open systems closed init closed start opened finish opened fig 
sample reachability graph fig 
previous basic composition step considers environment closed component constructed basis set values input events means microstep sequence fig 

compositional framework components considered open systems interact components physical environment 
reachability graph component system may independently derived complete system graf cheung kramer 
terms semantics defined component section means events components may arrive microstep due fact global system events internal events 
alter semantics complete system consider system component isolation 
illustrate observations affect process configuration generation consider component fig 
processes subsequently modified fig 
input interface event failure component shown process reachability graph fig 

order compute configurations component take account fact event failure may microstep 
produces new microstep configurations shown graph microstep corresponding execution transition state opened closed opened closed stuttering transitions state 
init start finish start open closed opened close failure fig 
open component example processes failure failure closed closed failure closed failure init start opened failure finish failure opened failure closed fig 
reachability graph fig 
computation configurations open systems increments length new microstep needed decide enables transition 
example consider microstep configuration closed corresponding macrostep fig 

implicitly microstep exits closed check new transitions enabled consequence appearance event failure previous microstep 
new microstep stabilization microstep transition executed control macrostep completion 
microstep counter order able reason instant environment reacts information assumptions microsteps visible 
aim possible generate assumptions extraction step concrete explicit microsteps example microstep event open 
explicit microsteps enable obtain detailed real view behaviour environment better performance model checker limits values interface events 
include new variable ms associated configuration performs function microstep counter incremented microstep reset new macrostep stable configuration initial configuration 
configurations microstep respectively ms ms 
example fig 
configuration related transition closed closed consequence appearance external input event init closed start failure init finish open close ms configuration reflects microstep execution means microstep counter ms internal event start 
rest events take value 
think components open systems able reason environment compilation synchronous component carried prior analysis order eliminate microsteps obtain compact state space 
explicit representation microsteps allows state adequate assumptions prove distortion semantics global model 
microstep visibility chan different purposes directly applicable approach 
authors microstep counter optimise analysis statechart specifications making macrostep equal length prune backward searches bbd model checking 
microstep short circuiting microstep visibility microstep counter environment model open system produce similar effect state space explosion call configuration explosion 
failure alleviate potential problem take account consideration 
state space configurations computed sequentially depth search strategy reachable state microstep configuration computed generation remaining chain microstep interrupted configuration microstep short circuiting due remainder microstep equal computed previous macrostep 
fig 
illustrates idea microstep short circuiting resulting microstep short circuiting optimisation 
substantially reduces size state space configurations 
obviously effect may greater system executes higher number microsteps 
macrostep macrostep problem discovering association rules attributes databases general sets transactions introduced agrawal typical problem knowledge discovery databases 
set transactions transaction set items association rule implication form sets items 
notions establishing strength rule defined confidence rule fraction transactions containing contain support fraction transactions contain goal find associations large sets transactions satisfy user specified minimum support minsup user specified minimum confidence minconf 
initial idea itemset approach follows 
initial stage combinations items fractional transaction support minsup generated 
combinations large itemsets 
large itemset generate rules type rules generated rules minconf may retained 
short circuiting macrostep macrostep macrostep macrostep fig 
calculated macrostep left right microstep short circuiting decision apply microstep short circuiting microstep comparing generated microstep configuration previously computed configurations 
improve configuration comparison process compare enabled transitions microstep configuration table indexed microstep counter record stores set enabled transitions microstep 
enabled transitions computed microstep compared transitions stored record corresponding microstep 
sets equal microstep short circuited 
transitions compared explored possible different configurations computed 
consequence microstep short circuiting affect nondeterminism 
extraction step goal step build assumptions sets configurations component computed previous stage 
compute assumptions set association rules adapting apriori algorithm agrawal srikant discovering association rules 
briefly describe algorithm go spell adaptations purposes 
association rules apriori algorithm fast popular algorithm determining large itemsets called apriori agrawal srikant 
algorithm includes number passes database finds set frequent itemsets satisfy minimum support requirement 
assumptions association rules system assume model checking component process automatically generate assumptions component environment problem re formulated basis discovering association rules considering set transactions set possible configurations computed composition phase global set ms items set output interface events environment communicates component ms microstep counter 
assumption association rule input interface events instant microstep whichever occurs 
process automatically derive assumptions stated large determine global set events support greater minsup large 
apriori algorithm 
assumption generation large generate association rules confidence factor greater minconf 
rules assumptions component assumptions conceive explain behaviours environment minimum confidence factor minconf 
similarly minimum support minsup assumption significant assumption obtained configuration component assumption valid 
erasing minconf minsup enables full automation simplifies assumption generation process 
considerations important effect process modular verification 
obtain assumptions respect component component necessary verify obtained assumptions assumption discharge assumptions generated association rules confidence factor 
obtained assumptions guaranteed generation method 
explain process detail section 
assumption generation method previous section stage consists computing large sets events support threshold minsup 
shown factor significant process assumption generation 
sets events occur configuration large 
direct consequence consideration permits determine large just pass set configurations avoiding multiple explorations original algorithm agrawal srikant 
importantly counting support performed fly computation configurations 
ideas summarized algorithm 
input configuration global output set large procedure subsets configuration support support update support new configuration created global set possible subsets events configuration computed subsets 
subsets function defined power set excluding empty set 
time corresponding support incremented 
applying algorithm generated configuration global process set supports 
illustrate approach table displays set configurations component fig 
considering open close events output interface events 
set corresponding configuration respective cumulative support table 
table configurations component fig configuration configuration open close ms support cum 
closed open closed close opened ms opened open close opened open ms closed close ms open close ms similar observation respect assumption generation 
confidence factor assumption necessary condition form assumption support 
avoid computation ratios support test minconf multiple phases obtain rules events consequent section 
algorithm produces assumptions starting set shown 
input set environment output assumptions procedure support support generate assumption table displays generated assumptions related microstep obtained applying algorithm set table 
table generated assumptions table ms open ms close ms open close macrostep normalization assumptions general computed component number microsteps macrostep length 
situation affect assumptions generated introducing false behaviours environment 
suppose component environment executes length microsteps respectively goal observe behaviour output interface event suppose set computed configurations macrostep ms ms macrostep ms ms ms direct application assumption generation algorithm produces assumption ms indicates third microstep environment produces event 
easily observed assumption real macrostep event take value third microstep 
way solve problem impose condition computed length 
call process macrostep normalization consists generating stuttering configurations fill affected macrostep 
events stuttering configurations value microstep counter actual value corresponding microstep 
example macrostep normalization consists adding stuttering configuration third microstep ms 
configuration macrostep false assumption ms obtained 
application order evaluate approach algorithms applied nontrivial case study frequently formal methods literature general formal verification particular steam boiler specification problem abrial 
set tools experimentation go describe case study components system broken 
automatically generated assumptions described detail 
analysis results modular verification components assumptions compared verification assumptions manual assumptions 
experimentation framework basic common integrated environment specification modular verification specified 
complete including new support automatic assumptions explained fig 

declarative specification properties component local properties case tool operational specification parser component local properties components assumption generator assumption translator assumption generation semantic parser manual commitments component local properties fig 
tools integration assumption generation counterexample visualization spin model checker specification system divided operational declarative modes 
operational model performed case tool 
declarative specification consists properties system achieve 
order perform modular verification system broken separate parts compiled synchronous reactive components including local properties syntactic parser 
goal obtain intermediate format independent case modelchecking tool de la riva 
components properties translated language model checker semantic parser 
assumptions generated automatically components means techniques algorithms detailed translated language model checking tool 
component verified respect local property automatically generated manually specified assumptions 
debug specification case false property counterexample may visualized original graphical language component specification 
verification tool spin model checker holzmann version 
steam boiler system steam boiler specification problem abrial classical example verification specification literature different notations tools 
behaviour control program steam boiler trivial requirements lay emphasis fault tolerant behaviour system 
system fig 
consists elements steam boiler valve evacuate water device measure amount water steam boiler pumps inject water boiler respective controllers device measure output steam boiler emergency switch message transmission system steam boiler control program 
controller pump valve control program fig 
steam boiler steam boiler steam sensor normal operating cycle control program consists reception messages sent physical units analysis processing messages transmission messages physical units main task maintain water level levels 
system enters fault state emergency activated desk operator 
security levels 
reached system inject evacuate water 
way control water level steam opening closing pumps 
control program runs operational modes initialisation represents start control program normal standard operating mode maintaining water level devices correctly degraded control program tries maintain satisfactory level boiler failure exists physical unit water measurement devices rescue similar degraded mode failure detected water measurement unit emergency water levels reach failure detected vital unit 
specification verification high level subsystem diagram illustrated fig 

external events messages sent received control program represented uppercase labels 
remainder internal events communicate subsystems 
steam steam steam boiler waiting physical units ready steam steam repaired ack steam repaired steam failure ack steam failure valve program ready error emergency control level water level risk level failure ack level repaired emergency shutdown level range water start pumps fig subsystems steam boiler control program level failure level repaired ack pump state pumps pump control state close pump open pump pump control repaired ack pump control failure pump control failure ack pump control repaired control subsystem maintains different operational modes launches commands initiate opening closing pumps events respectively accordance water level event detected 
enables disables remaining processes events labelled process process respectively 
subsystem controls behaviour pumps corresponding controllers responsible sending opening closing messages physical pump 
water subsystem determines amount water boiler detects internal failures unit 
steam subsystem controls steam output boiler 
turn behaviour component detailed set primitive processes specified fsms 
declarative specification obtained textual description system abrial requirements stated relation operational mode steam boiler 
translated requirements properties specify propositional logic total declarative specification consists properties 
pumps identical instances planned perform verification properties system incremental fashion 
firstly considered system formed single pump go incrementally add pump specification 
verification possible property considering system composed pump system composed fsms 
fact spin produced memory situation stopped verification time greater days 
component verification assumption generation avoid state explosion divide steam boiler specification components perform local verifications assume guarantee paradigm 
modular verification conducted partitioning system components corresponding subsystem specification fig 

turn global properties modularised local properties enabling verified proposed components 
example consider global property translation process component spin language promela states properties checked macrostep 
reason spin supports ltl properties necessary specify temporal logic 
encoded spin promela sentence assert 
normal mode water level permitted limits control program start emergency mode encoded normal level level property elements component control processes component water event level 
property broken level level normal clear properties analysed separately component 
properties original specification modularised procedure 
table shows components number processes properties modular verification 
table components modular verification component number fsms number properties pump control water steam check component assuming universal environment environment model provided manual assumptions engineer knowledge automatically generated assumptions algorithms described 
control component component maintains operational modes control program basis events received component water sending corresponding events component 
initialisation mode control enables remainder components 
performed verification component assuming universal environment input interface events take value microstep 
properties false 
relate initialisation mode 
states water level high valve opened valve second level low component send event pumps 
analysis counterexamples returned model checker shows input interface events indicate water level received time component may react opening pumps fact opening evacuation valve 
obviously environment behaviour unrealistic error removed performing environment assumption water level events received instant 
verifying component manual assumption properties true discharging assumption true environment water component 
similar situation produced third false property relative interface input events 
assumption indicates events value instant resolves problem true water 
false property indicates control mode normal failure water level event received preceding instant control program immediately evolve state 
counterexample analysis help determine cause error 
interpretation difficult previous cases attempts simulations able fix error manually specify correct assumption 
solve situation help decide error false positive effectively specification mistake automatically generate assumptions table observe behaviour input interface events 
table automatically generated assumptions control component water component ms assumptions manually specified solve false positives 
indicate input interface events sent microstep 
assumption states behaviour environment concrete microsteps input interface events sent third microstep 
executing model checker new assumptions properties component control true 
specifically fourth property returned false universal environment true fifth assumption 
conclude initial error false positive caused incorrect system specification incorrect specification component environment 
note assumption difficult obtain manually involves semantic concepts easily accessible user 
components component maintains state pumps respective controllers sending open close orders physical devices 
related component control means events fig 

component environment considering pumps moment take component formed pump 
furthermore provide additional considerations verification pumps 
previous component verified assumptions manually specified assumptions related incompatible reception input interface events 
cases property false pump controller failure state component send opening closing orders physical devices 
counterexample shows pump failure state close pump event sent physical device 
initially result surprising transitions process responsible enabling respective open close orders condition failure 
automatically generate assumptions component component control table 
table assumptions component control component ms ms ms assumptions show incompatible reception microstep component input interface events 
remaining assumptions related specific microsteps indicate microstep start events occur assumption enable event sent microstep assumption start events disable event sent fifth microstep assumption 
component checked set generated assumptions properties returned true 
water component determines amount water boiler steam component controls amount output steam 
components properties true assumptions automatic assumptions computed improve result verification process 
performance section show results verification component system 
perform verification considering universal environment assumptions manual assumptions automatically generated assumptions 
experiments performed compaq mhz 
gbyte main memory spin model checker version 
control component table displays results spin performance terms time column seconds space column mem mbytes verification local properties component control universal environment assumptions manual assumptions automatically generated assumptions specified table 
shaded performance data represents false positive property 
rows summary total verification time improvement factor respect universal manual assumptions respectively brackets case automatic assumptions number assumptions number false positives obtained cpu time assumption discharge assumption generation 
table results verification control component universal environment manual assumptions automatic assumptions table property mem mem mem total verification sec 
number assumptions number false positives assumption discharge sec 
assumption generation sec 
general cpu time memory model checker decreases incorporation new assumptions verification property 
result expected priori 
due fact environment limited assumptions model checker handle smaller state spaces 
example verification universal environment model checker explore possible combinations interface events microsteps order 
assumptions events limit possible values order microsteps occur 
automatically generated assumptions substantially improved performance model checker factor respect universal environment respect manually specified assumptions 
case due greater number assumptions fact represent real behaviour environment better 
possible verify properties component producing false positives automatically generated environment 
result important number properties verify incremented perform regression verification previously verified component 
new property added necessary compute environment environment changed 
noted manual time assumption specification included case manual approach 
obviously effort difficult measure discovery adequate assumption engineer complicated task requires significant mental effort 
point view automatic approach useful tool reduces computational resources user guidance 
components perform experiments component pump summarized table 
table summarized results component pump universal environment manual assumptions automatic assumptions table total verification sec 
number verified prop 
number assumptions number false positives assumption discharge sec 
assumption generation sec 
component control model checking time properties lower automatic environments improvement factor respect universal environment manual assumptions respectively properties verified false positives 
order check approach affects performance model checker verification systems greater size complexity scaled component incrementing number pumps specification 
summarized results pumps table 
table summarized results component pumps universal environment manual assumptions automatic assumptions table total verification sec 
number verified prop 
number assumptions number false positives assumption discharge sec 
assumption generation sec 
verify component assumptions manual assumptions need machine time approximately respectively 
automatic approach time reduced hours approximately 
speed obtained factor respectively 
important consideration related number properties verified 
automatically generated assumptions properties verified 
universal manual approaches property returns memory spin message 
property verified automatic approach approximately component pumps verified properties model checker returns memory response different partition components performed order verify component 
result expected consider results obtained table pumps table due combinatorial state explosion 
case water steam components resource consumptions model checker small mbyte similar respect universal environment manual automatic assumptions 
due components having reduced input interface enable disable events consequently obtained assumptions contribute restricting component environment 
discussion approach enables assumptions obtained automatically component making feasible assume guarantee modular proofs 
owing fact perform exhaustive exploration microsteps environment computation including derived non determinism obtained assumptions explain environment behaviours input interface events difficult engineer guess avoiding need manual specification 
results approach may noted main advantage technique removes time consuming error prone task manual specification assumptions necessary modular verification 
consequently necessary perform assumption discharge environment reducing effort needed verification process 
important feature permits discovery false positives properties fact true returned false model checker due incorrect unrealistic specification environment 
technique generate possible assumptions ensure detects possible false positives totally complete 
technique sound assumptions insert additional behaviours ensure component errors appear 
result state space model checker deal smaller performance improved 
cases analysed performance model checker automatic assumptions superior number factors respect assumptions specified engineer universal environment considered assumptions 
assumptions represent behaviour environment exactly limiting arrival interface events certain microsteps avoiding reception inconsistent combination events reducing non determinism component verify 
problem assumption generation addressed approach automated procedures giannakopoulou 
method employed independent component property verify 
approach computes assumptions independently component property analysis 
component property change add new properties verify necessary calculate assumptions 
point view method especially adequate incremental regression verification practices 
fact normal component verification property false incorrect component specification 
case component adequately modified properties verified regression verification 
necessary compute assumptions property verification ones obtained verification 
similar observation case new properties added completed interactive incremental fashion 
environment previously computed new assumptions needed new property 
method applied spin model checker easily adapted finite state verification tools 
assumption generation independently verification tool changes related component assumption coding target tool focus state transition systems assume guarantee reasoning may applied formalisms example process algebras rehof 
context approach imposed restriction underlying finite state model specified terms reactive semantics 
experiments experience gained automatically generated assumptions application assume guarantee reasoning opens interesting lines research improvements technique 
cite 
main bottleneck approach composition phase due possible configuration explosion computational resources consumptions 
proposed heuristic reduce state space adoption new methods state space coding example bdd bryant state space exploration example partial order reductions peled useful 
method applied verification safety properties 
general approach appropriate liveness properties due independence component property 
greater expressive power needed assumptions order apply method verification certain types liveness properties livelocks 
able detect undesired behaviour need generate assumptions way interface event appears microstep 
context interesting line research search new methods coding assumptions example temporal logic expressive power greater association rules 
automatic reduction generated assumptions general assumptions produced redundant sense certain assumptions included derived 
extraction step detected similar methods association rules techniques aggarwal yu 
related modular compositional approach natural effective technique solving problem verification large complex systems 
decades various authors proposed theoretically founded sound frameworks modular reasoning reactive systems 
traditionally compositional modular analysis verification carried compositional minimization obtain reduced version environment component exactly characterized visible behaviours component analysis interface process perform composition component interface process 
interface process complex concrete removed component verification may feasible minimizing state space explosion 
clarke 
clarke interface process constructed removing transitions component alphabet environment component 
graff 
develop method includes said technique interface process specified user 
methods produce large state spaces states systems equivalent 
approach developed partially automated cheung means algorithm automatically construct interface process 
automatically generated environments completed user stubs sufficiently limit behaviour environment 
grumberg long describe framework compositional verification temporal model checking assume guarantee reasoning environmental assumptions explicitly manually provided component 
sufficient space describe pertinent studies refer reader book de roever colleagues de roever provides excellent state art compositional methods verification 
practical application techniques evolved speed underlying theories 
shankar observes shankar inference systems compositional verification studied applied 
point view due lack adequate automated support style reasoning 
developments oo design component software engineering provided new advances automated formal techniques specification verification 
respect studies de alfaro henzinger alur 
contribute automating modular verification 
theories techniques implemented mocha toolkit alur provides automated support modular reasoning specifications temporal logic 
assume guarantee modular reasoning way needed specify adequate environment assumptions henzinger sufficiently limits environment producing false violations false positives 
reason research techniques methods automatically generate component environment helpful 
problem novel fact old assume guarantee reasoning automated assumption generation limited 
approach assumption generation inverardi restricted checking compatibility components modular checking deadlock freedom properties 
field shared memory communication models henzinger framework thread modular abstraction refinement thread assumptions refined iterative fashion applied detection race conditions 
flanagan qadeer focuses programs communicate shared variables abstractions 
closest approach described algorithm automatically generate weakest assumption 
method restricts environment necessary component satisfy property 
specifically proposed technique returns results component satisfies property environments component violates property environment assumption returned precisely characterizes environments component satisfies property 
framework performing assume guarantee incremental fully automatic fashion 
assumptions computed learning algorithm 
initially obtained assumptions approximated progressively precise means analysis information obtained counterexamples 
main difference respect previous approach computation runs memory due state space component large assumptions computed moment valid 
automated support incremental framework described 
extends previous approach employing symmetric assume guarantee rules 
chaki 
applied similar learning paradigm automate assumption guarantee reasoning simulation conformance finite systems specification 
relation system decomposition modular verification addressed authors examine advantages assumption verification monolithic verification way decompositions system assumption generation technique 
approach methods dependent property component verify 
reason algorithms applied property verify change component property needs new verification 
approaches interesting environment unknown 
method model checking components assume guarantee reasoning automatically generated assumptions 
approach generates set environmental rules explain behaviour interface events assumptions components avoiding manual specification consequently reducing user guidance needed modular verification 
technique especially relevant detecting false positives due obtained assumptions 
ability generate assumptions significantly affects performance model checker 
assumptions reflect behaviour environmental events precisely number states related events model checker explore limited 
due way assumptions generated basis environment behaviour component property changes assumptions need computed 
aspect important regression verifications environment computed 
application non trivial system shows viability approach detecting false positives reducing consumption resources model checker particular complete verification process general 
experience opens possible improvements approach particularly regards expressivity generated assumptions aimed reducing blow computation environment configurations 
funded ministry science education spain projects test tin argo tic 
abadi lamport 
conjoining specifications acm transactions programming languages systems 
abrial borger langmaack 
formal methods industrial applications specifying programming steam boiler control volume lncs 
springer verlag 
aggarwal yu 
online generation association rules 
proceedings international conference data engineering pp 

agrawal imielinski swami 
mining association rules sets items large databases 
proceedings acm sigmod conference management data pp 

agrawal srikant 
fast algorithms mining association rules 
proceedings international conference large databases pp 

alur henzinger mang qadeer rajamani 
mocha modularity model checking 
proceedings th international conference computer aided verification volume lncs pp springer verlag 
alur de henzinger mang 
automating modular verification 
proceedings th international conference concurrency theory volume lncs pp 

springer verlag 
barringer giannakopoulou pasareanu 
proof rules automated compositional verification learning 
proceedings 
second workshop specification verification component systems pp 
bryant 
graph algorithms boolean function manipulation ieee transactions computers 
chaki clarke ouaknine 
efficient verification sequential concurrent programs formal methods system design 
chaki clarke sinha 
automated assume guarantee reasoning simulation conformance 
proceedings th international conference computer aided verification volume lncs pp 

springer verlag 
chan anderson beame burns notkin reese 
model checking large software specifications ieee transactions software engineering 
chan anderson beame jones notkin 
optimizing symbolic model checking statecharts ieee transactions software engineering 
cheung kramer 
context constraints compositional reachability analysis acm transactions software engineering methodology 
clarke long 
mcmillan compositional model checking 
proceedings th symposium logic computer science pp 

clarke grumberg peled 
model checking mit press cambridge 
ma 
pasareanu cs 
learning assumptions compositional verification 
proceedings th international conference tools algorithms construction analysis systems volume lncs pp 

springer verlag 
avrunin clarke 
breaking hard investigation decomposition assume guarantee reasoning 
technical report um cs university massachusetts department computer science 
de alfaro henzinger 
interface automata 
proceedings th european software engineering conference pp 

de alfaro henzinger 
interface theories component design 
proceedings embedded software volume lncs pp 

springer verlag 
de la riva de diego 
translating sa rt models synchronous reactive systems approximation modular verification smv model checker 
th international conference perspectives system informatics volume lncs pp 

springer verlag 
de roever de boer lakhnech 
concurrency verification compositional non compositional methods 
cambridge university press 
flanagan qadeer 
thread modular model checking 
proceedings th spin workshop volume lncs pp springer verlag 
giannakopoulou pasareanu barringer 
component verification automatically generated assumptions automated software engineering graf steffen 
compositional minimization finite state systems interface specifications 
formal aspects computing 
grumberg long 
model checking modular verification 
acm transactions programming languages systems 
harel pnueli schmidt sherman 
formal semantics statecharts 
proceedings symposium logic computer science pp 

harel naamad 
statemate semantics statecharts acm transactions software engineering methodology 
henzinger qadeer rajamani 
assume 
guarantee methodology case studies 
proceedings th international 
conference computer aided verification pp 

henzinger majumdar qadeer 
thread modular abstraction refinement 
proceedings th international conference computer aided verification 
volume lncs pp 

springer verlag 
holzmann 
spin model checker primer manual 
addison wesley 
inverardi wolf 

static checking system behaviours derived component assumptions acm transactions software engineering methodology 
jagadeesan 
formal approach reactive systems software telecommunications application esterel formal methods system design 
jones 
tentative step development method interfering programs 
acm transactions programming languages systems 
leveson heimdahl hildreth reese 
requirements specification process control systems ieee transactions software engineering 
mcmillan 
symbolic model checking approach state explosion problem 
kluwer academics 
mcmillan 
compositional methods systems 
verification digital hybrid systems volume nato advanced summer institutes pp 
springer verlag 
peled 
combining partial order reductions fly model checking 
proceedings th international conference computer aided verification volume lncs pp 
springer verlag 
pnueli 
transition global modular temporal reasoning programs 
logic models concurrent systems volume lncs pp 

springer verlag 
rehof 
behavioral module system pi calculus 
proceedings analysis symposium volume lncs pp 
springer verlag 
shankar 
lazy compositional verification 
compositionality significant difference international symposium volume lncs pp 
springer verlag 

feasibility model checking software requirements case study 
proceedings th annual conference computer assurance pp 
ieee 
dwyer pasareanu 
automated environment generation software model checking 
proceedings th ieee international conference automated software engineering pp 

de la riva de diego 
case support modular verification synchronous reactive systems 
proceedings nd international workshop formal methods industrial critical systems 
pp 

de la riva de diego 
dynamic analysis sa rt models spin modular ation 
dimacs series discrete mathematics theoretical computer science vol 
pp 

claudio de la riva assistant professor department computer science university spain 
received ph degree department computer science university spain 
research interests include software verification validation software testing 
javier associate professor department computer science university spain 
received ph degree department electrical engineering university spain 
member acm ieee computer society 
research interests include software quality assurance process improvement verification validation software testing 

