intelligence design principles modularity coordination engineering complex adaptive agents joanna joy bryson submitted department electrical engineering computer science partial fulfillment requirements degree doctor philosophy massachusetts institute technology september massachusetts institute technology 
rights reserved 
author 
department electrical engineering computer science june certified 
lynn andrea stein associate professor computer science thesis supervisor accepted 
arthur smith chairman department committee graduate students intelligence design principles modularity coordination engineering complex adaptive agents joanna joy bryson submitted department electrical engineering computer science june partial fulfillment requirements degree doctor philosophy intelligence relies search example search intelligent agent action 
search succeed resource bounded agents biased finding right answer 
artificial agents primary source bias engineering 
dissertation describes approach behavior oriented design bod engineering complex agents 
complex agent arbitrate potentially conflicting goals behaviors 
behavior oriented design builds behavior hybrid architectures agents object oriented approach software engineering 
primary contributions dissertation 
bod architecture modular architecture module providing specialized representations facilitate learning 
includes pre specified module representation action selection behavior arbitration 
specialized representation underlying bod action selection parallel rooted ordered slip stack hierarchical posh reactive plans 

bod development process iterative process alternately scales agent capabilities optimizes agent simplicity exploiting tradeoffs component representations 
ongoing process controlling complexity provides bias behaving agent facilitates maintenance extendibility 
secondary contributions dissertation include implementations posh action selection procedure identifying useful idioms agent architectures distribute knowledge agent paradigms examples applying bod idioms established architectures analysis comparison attributes design trends large number agent architectures comparison biological particularly mammalian intelligence artificial agent architectures novel model primate transitive inference examples bod agents bod development 
thesis supervisor lynn andrea stein title associate professor computer science acknowledgments kinds pages short formal safe ones long ones 
long ones leave half people intended acknowledge stick people randomly talked yesterday 
feel obliged best 
yesterday new john talked brian anthony jesse hong robert irie mark core lucas matsuoka greg huang shared office 
pearl tsai elizabeth eva mit 
people keep sane 
special krzysztof gajos virtual really worked door 
dissertation things 
making contribution requires understanding things gone really worked isn easy papers 
terms ai agent architectures enormous numbers conversations years couldn possibly remember properly acknowledge 
people particularly insightful supportive kris th risson paolo petta push singh mark ian horswill michael mateas gerry sussman leslie pack kaelbling 
rob chris wright floyd olin shivers lynn stein henry brendan mcgonigle john hallam greg sullivan johanna moore mark steedman lisa dan dennett rene lola ca simon perkins pattie maes luis luc steels john hallam michael thomsen hayes nuno andrew fitzgibbon chris malcolm chris mellish tony prescott dave yannis demiris 
especially rob dahl helped understand architectures worked 
simon lane sandy pentland jimmy lin helped defense stage 
understanding things mit important understanding ai 
advisor committee got help lynne parker maja matari anita flynn oded maron sweeney david greg greg holly yanco tina kapur carlo romano lily lee mike brian scassellati jerry pratt bill smart jeremy brown marilyn pierce jill fekete annika lisa dan henry minsky marvin minsky michael coen phil hal abelson patrick winston nick pete dilworth marc raibert hugh leg lab 
kozierok nick matt williamson lisa erich prem ashley walker phil geraint wiggins alan smaill 
trevor darrell peter exam boards bruce walton dan ron jack leigh petr jonathan chris johnston toby blake making stuff 
cold especially ron weiss david evans kah kay sung daniel rao mike charlie kemp 
matter louis philippe mike halting problem people 
special gill pratt lynn andrea stein supportive 
tech report special cover picture tech report photo blue performing task described chapter see pictures page 
pictures reproduced kind permission dr brendan mcgonigle 
tech report differs original dissertation rewrite chapter clarity partial rewriting chapters reason feedback marc hauser lab harvard 
smaller pages nick stephen peters helping 
kris th risson asked seen making constructive criticisms architecture ymir 
record bother think write things interesting people fail realize preceeding criticisms sincere 
acknowledge kris particular worked closer ai particularly months lego 
similarly rod brooks subsumption architecture changed life 
intelligence reason introduced modular distributed intelligence convinced phd brought mit 
lynn stein cog project started thinking specialized learning 
reread intelligence reason month finishing phd extent dissertation just expansion despite conspicuous differences 
met toby tyrrell amazing piece phd deeply indebted research making code publicly available internet archives 
deep respect john laird group soar project general particularly way document failures successes 
responsive email 
spend time people spend time thinking 
family blood relatives tom bryson donna barb kevin rebecca bird new members martha bryson brian scott patricia david lowe carolyn kate davies 
hilary till amy gill kendon chris angel johnston practically family 
dedicate dissertation aunt dorothy bryson programmed satellites ge got paid third boys grandfather roy wanted best pretty thought regardless 
team created vr project chapter dent de lion du midi th risson christian tang petersen victor dan claude julian mez 
artists engineers gratefully acknowledged 
ai dialogue directed kris th risson included addition mentioned christian george 
claude responsible animations mentioned section victor guard character 
van leeuwen assisted child psychology pearce assisted concept development jacob buck michael nielsen contributed technical implementation 
castle project developed silicon graphics equipment expertise 
team dialog project chapter johanna moore claus zinn peter hastings mark core mark helped write 
massimo poesio 
alf christian achilles computer science bibliography web site ira uka de bibliography index html 
readers olin shivers gill pratt bruce blumberg 
gave time comments support 
biggest dissertation lynn andrea stein 
ideas support emotional financial patience determination happened 
lowe belongs category mentioned 

contents contributions 
behavior oriented design bod 
design artificial intelligence 
ai software engineering 
learning planning useful 
evidence engineering dissertation 
dissertation structure motivation 
chapter list 
road maps 
motivation 
bod basics monkey smart building monkey 



bod methodology 
behaviors saying 
simplest behavior 
behaviors state 
behaviors perception 
behaviors triggers processes 
behaviors aren objects 
plans saying 
simplest plan 

basic reactive plans 
making complete agent 
drive collections 
bod methodology choosing 
principle iterative design 
revising specification 
behavior oriented design agent architecture 

background critical components agent architectures 
features trends complete agent architectures 
approach 
thesis 
traditional approach 
behavior architectures 
society mind 
subsumption architecture 
diversification behavior ai 
multi layered architectures 
prs beliefs desires intentions 
soar act 
discussion recommendations 

parallel rooted ordered slip stack hierarchical posh reactive plans 
basic issues 
reactive planning really mean 
isn having kind plans bad 
basic elements reactive plans 
simple sequences 
basic reactive plans 
posh plan elements 
action patterns 
competences 
drive collections slip stack 
example complete posh hierarchy 
managing multiple conflicting goals 
exploiting slip stack hierarchy 
inner workings posh action selection 
early history caveats 
simple implementation posh control 
posh control action scheduler 
summary critical features posh action selection 

architectural idioms posh action selection architectures 
brp reactive architectures 
architectures idioms progress agent design 
identifying valuable idiom 
expressing architectures 
ymir 
prs cl 
jam um prs 
soar 
architecture methodology tool 
discussion 
modularity specialized learning 
behaviors 
learning 
learning animals 
reactive behavior modeling intelligence 
state learning bod 
types state 
choosing representations bod 
trading control learning 
control state 
deictic state 
specialized deictic state 
state meta learning 

learning design 
control state 
deictic representation 
examples deictic representation 
grab green 
green green 
copy demo 
perceptual state 
edmund examples perception specialized learning robot robot 
example modular learning perception 
example episodic memory navigation 
learning robot experiments 
meta state learning learn 
meta learning distributed representations 
summary designing learning 
behavior oriented design 
basic bod development process 
initial decomposition 
iterative development 
making 
revising specifications 
competences 
prioritization drive collections 
supporting development maintenance 
document agent specification program code 
revision control 
debugging tools 
bod relates similar approaches 
behavior ai 
object oriented design ood 
agent oriented design aod 
behavior oriented design 

design process example modeling transitive inference primates 
biological background learning ordered behavior 
characteristic transitive inference effects 
training subject transitive inference experiments 
standard models 
modeling errors transitive inference 
binary sampling model 
production rule stack model 
proposed model 
components novel model 
learning model 
behavior oriented design model agent 
initial decomposition 
modeling expert 
learning ordering 
learning ordering rules 
real training regimes 
results 
learning colors rules 
rule learning results 
discussion 
example modeling social interactions primate colonies 
biological background de waal theory primate societies 
extending bod multi agent simulation 
bod model drives emotions 
modeling conventional emotion drive theory 
representing emotions bod 
model showing grooming oscillating privacy 
preliminary results 
discussion 
extending bod modeling neural systems 
modularity nature 
mapping bod features mammal brain structure 
skill modules 
action selection 
environment monitoring 
discussion 
adaptivity modular systems 
requirements behavior learning system 
directions neuroscience complex agent architectures additional humanoid subsystems 

extending bod industrial applications 
bod tutoring dialog systems 
bod dialog project 
building behavior library drive structure 
scaling system 
specialized learning dialog agent 
bod integration ai characters vr entertainment 
character architecture constructive narrative 
spark life 
adapting bod sol constructive narratives 
responsibilities ai developers 
case study creating characters adventure narrative 
high level design 
encoding personality 
developing perception action primitives 

design key success new ai 
learning important sufficient 
bod new ai better 
bod doesn require changing architectures 

posh code basic posh classes 
running posh 
reading posh scripts 
utility functions 
gui 
transitive inference behavior library interface 
scripts 
behavior library 
primate society behavior library interface 
scripts 
behavior library 
list figures actions behavior oriented architectures 
traditional architecture 
soar layer architecture 
priorities beast contradictory goals tyrrell se 
brp prioritization implemented function prs cl meta reasoning 
different time courses dialogue processes 
blind insect progress 
edinburgh nomad encounters invisible obstacle 
plan moving forward 
behaviors moving forward 
behaviors true navigation 
plan picking direction 
actions behavior oriented architectures 
phases training testing transitive inference 
transitive choice competence 
modeling experienced monkey 
learning priorities boxes 
different experienced monkey 
learning priorities rules colors 
educating rule learning monkey 
results prior learn 
prior learn vs fair prior learn 
result rule learn 
blue squirrel monkey test apparatus 
results educate monkey 
emotional behaviors 
plan colony primates 
indicators gui primate colony simulation 
sample observation log simulated primate colony 
bnn ann bod 
ambiguous image 
modules learning behaviors plans 
possible trains behavior library 
castle project 
chapter intelligence relies search particularly search agent chooses act 
search succeed resource bounded agents biased finding right answer 
artificial agents primary source bias engineering 
engineering key artificial intelligence 
dissertation describes approach behavior oriented design bod engineering complex agents 
complex agent arbitrate potentially conflicting goals behaviors 
common examples include autonomous robots virtual reality characters problems shared ai systems intelligent tutors monitors environments 
behavior oriented design builds hybrid architectures agents object oriented approach software engineering 
chapter describes contributions dissertation high level detail 
preliminary behavior oriented design argument importance design artificial intelligence ai explanation forms evidence provided dissertation 
chapter level description rest dissertation including road maps readers various interests description core motivations 
contributions primary contributions dissertation 
bod architecture 
bod development process 
bod architecture consists adaptive modules specialized representations facilitate learning 
includes pre specified module representation action selection arbitration expressed behavior modules 
specialized representation underlying bod action selection parallel rooted ordered slip stack hierarchical posh reactive plans 
bod development process iterative alternately scales agent capabilities optimizes agent simplicity exploiting tradeoffs component representations 
ongoing process controlling complexity provides bias behaving agent facilitates maintenance extendibility 
bod provides rules initial decomposition agent modules plans 
decomposition anticipated adaptive state requirements 
iterative improvement agent design 
rules take form heuristics simplifying agent recognizing current decomposition faulty 
due bod modularity new decompositions switching intelligence modules plans achieved minimal disruption 
secondary contributions dissertation include analysis comparison attributes design trends large number agent architectures implementations posh action selection procedure identifying useful idioms agent architectures distribute knowledge paradigms examples applying bod idioms established architectures comparison biological particularly mammalian intelligence artificial agent architectures novel model primate transitive inference examples bod agents bod development 
analysis design trends chapter conclude intelligence complex agents requires features modularity decomposition intelligence simplify agent design structured control way focus attention arbitrate modules bring coherence agent behavior environment monitoring low computation means change focus agent attention 
biological comparison chapter show mammalian intelligence shares features 
features provide basis bod architecture 
behavior oriented design bod behavior oriented design methodology constructing complex agents 
designed applicable number languages popular agent architectures 
gathered name bod derivative behavior artificial intelligence brooks maes matari informed object oriented design ood coad 
behavior ai design approach decomposes intelligence terms expressed behaviors walking eating generic processes planning sensing 
behaviors modules described terms sets actions sensory capabilities necessary inform 
sensing inform actions expressed 
words really forms sensing sensing detecting context sensing parameters feedback motor actions 
central observation behavior oriented design mere sensing seldom sufficient detecting context controlling action 
abilities require full perception turn requires memory 
memory adds bias recording experience creating expectations 
perception exploits expectations perform discriminations reliably possible 
observation consequences bod methodology 
memory essential part behavior 
fact memory requirements serve primary cue behavior decomposition process determining divide intelligence set modules 
strategy analogous central tenet object oriented design modular decomposition system best determined adaptive state requirements 
second consequence determining context sufficiently important sufficiently difficult requires representation 
control context decisions generally driven environment retained original trigger longer apparent sensing 
bod uses hierarchical reactive plan structures ensure environment monitoring keep track control decision context 
influence ood bod begins analogy behavior object 
behaviors fact coded objects primitive elements bod reactive plans encoded methods behavior objects 
equally important emphasis design process 
ood bod emphasizes cyclic design rapid prototyping 
process developing agent alternates developing libraries behaviors developing reactive plans control expression behaviors 
bod provides guidelines making initial behavior decomposition recognizing decomposition proven inadequate heuristic rules improving 
iterative development process results ongoing optimization bod agent simplicity clarity scalability correctness 
design artificial intelligence hand design programming dominant means creating ai systems 
intrinsic difficulty hand coding lead deal research alternate strategies machine learning automated planning 
techniques successful limited domains 
problem complexity intractable machine implemented resource bounded algorithms human design 
chapman proved planning impossible time resource bounded agents 
wolpert similar demonstrations machine learning 
free lunch learning requires structure bias succeed 
wooldridge dunne demonstrate determining agent chance bringing goal state np complete problem 
importantly strong evidence average case utility hand design utility machine learning planning 
evidence research trends planning 
ai users working different paradigms turned repeatedly designing plans hand see chapter 
machine learning automated planning techniques successful domains 
point design approach bod achievements facilitate creating systems strategies reliably succeed 
ai software engineering reiterate thesis dissertation machine learning constructive planning useless 
thesis strategy complete solution developing complex agents 
ai form software engineering primary considerations fields 
frederick brooks lists concerns software engineering design build set programs system design build program system robust tested documented supported product maintain intellectual control complexity large doses 
brooks emphasis brooks dissertation addresses questions 
behavior oriented design building incorporating useful modules agent capable coherent behavior 
specifies procedures developing modules coordination 
specifications include recommendations program structure documentation highly maintainable 
bod ai methodology takes account fact design development maintenance inseparable parts process modern software engineering 
consequently developed system document design provide maintenance 
bod provides making clear rational decompositions program code 
decompositions functioning system reflected structure program code 
simplify coding execution 
learning planning useful referring back frederick brooks agenda page learning planning programs need incorporated intelligent system 
nearly examples dissertation incorporate learning capacity generalize applicability program helps control complexity system see chapter 
example discussed demonstrated dialog system section incorporates constructive planner similar purpose time bod system reduces simplifies planner task relative comparable systems 
learning planning supported provided structure probability success increases computational cost decreases 
evidence engineering dissertation engineering design process critical artificial intelligence easy topics research dissertation 
assertions ease usually proven mathematically 
statistically valid scientific evidence demonstrating significant ease improvement difficult expensive come requires large sample programmers variety methodologies comparisons terms time effort quality final product programming 
intractable average phd program architecture theses resort combining plausible arguments demonstration impressive system systems constructed methodology 
case dissertation employed strategies attempted add version scientific approach 
hiring large number programmers examine history agent design available literature 
practitioners various paradigms ai research converged particular methodology take evidence viability method 
particularly true paradigm began stated opposition particular methodological aspect adopts methodology subjected substantial application significant results 
cases selection methodological aspect reasonably attributed forces personal belief social bias 
analysis appears chapter 
chapter includes similar look structure naturally evolved complex agents 
combination uncertain evidence lead perfect certainty lead increased probability correctness 
sense approach similar scientific dissertation particularly employing arguments evolution history 
dissertations theses controversial theses conclusively proven approach better leaving important areas research unexamined 
dissertation structure motivation dissertation represents different sorts potentially interest different sorts readers 
content categories development ai methodology review integration literature organizing intelligent control artificial natural development number artificial agents 
activities deeply interdependent possible readers interested particular aspects 
section includes list chapters road maps sections reflecting particular interests 
section concludes brief description personal interests 
chapter list begun dissertation brief description contributions methods importance software design issues artificial intelligence 
introductory material chapter gives gentle bod architectural components design process 
useful big picture gives number toy examples 
chapter provides background material ai architectures complex agents 
explained earlier chapter critical validating emphasis design general structure bod architecture 
behavior oriented design chapters primary attributes bod detail 
chapters give detailed description action selection bod 
chapter describes parallel rooted ordered slip stack hierarchical posh reactive plans formally 
discusses introduce posh planning structures architectures 
bod implement agents object oriented language agent architectures 
chapter introduces concept architectural idioms insights derived research program best distributed entire agent community 
includes specific examples adding key feature posh action selection existing architectures 
chapter goes detail specifics posh implementations examples pseudo code performance statistics 
chapters describe role learning modularity 
architectures exploit reactive planning bod maintains concept behaviors semi autonomous programs agendas specialized representations 
chapter classifies demonstrates different types state agent architecture 
chapter continues discussion detail multiple examples working systems 
system robot blocks world simulation second real autonomous mobile robot 
chapter describes bod development process proper 
bod methodology critical maximizing simplicity correctness bod agent 
chapter describes ongoing process trading possible bod representations keep agent code structure clear scalable 
gives practical instructions keeping bod project organized including discussing maintenance debugging tool 
chapters demonstrate bod methodology 
chapter provides extended example relatively simple modeling task 
agents constructed model primate learning reactive plans 
pedagogical utility chapter advances current models primate learning illustrates theoretical interface plans behaviors 
chapter provides example bod 
fills gaps previous example real time agents demonstrating bod multi agent system mas setting showing interaction traditional emotional drive theory models action selection posh reactive plans 
model social interactions primate colony 
utility bod final chapters exhibit summarize bod usefulness describe 
chapter relates hypotheses implicit structures explicit bod agents biological agents particularly mammals 
discusses possible creating adaptive biologically correct agent architectures 
chapter describes utility bod artificial life psychology research problems industrial applications artificial intelligence 
applications include intelligent environments monitoring systems 
extended examples possible applications real industrial applications natural language tutoring undergraduates virtual reality entertainment young children 
chapter concludes summary 
road maps going read chapter thesis read chapter 
trying learn choose 
different agent architectures start chapter 
read chapter familiar terminology rest dissertation 
read chapter discusses varying levels reactiveness different architectures implement features architecture 
want read chapter gives arguments specialized representations important 
probably read gives detailed perspectives bringing methods large scale ai projects 
interested natural intelligence start chapter quick 
skip chapter 
may want read primate modeling chapters 
possible chapters lead want skim chapter see alternative ways represent intelligence ai 
familiar bod talk just want get implementation details want read chapter appendices 
may want look chapters examples agents get developed chapter alternative implementations posh action selection 
really ought read chapter methodology 
motivation primary personal motivation research creation methodology rapidly reliably constructing psychologically plausible agents purpose creating platforms scientific testing psychological models 
am motivated socially improving human productivity clean design 
complete bod methodology underlying architecture supports personal goal demonstrated experimental shown chapters 
addition various attributes help considerations 
chapter offers bridge bod architectures neurological models intelligence natural artificial 
pursuing general productivity utility particularly motivates chapters 
ai project fact software project benefits practical methodology facilitating design long term maintenance 
theme strong dissertation particularly nuts bolts chapters 
chapter bod basics monkey smart chapter gentle behavior oriented design bod 
designed tutorial 
rest dissertation contains technical descriptions concepts introduced 
building monkey tutorial designing constructing behavior artificial intelligent agent agent term borrowed philosophy meaning actor entity goals intentions brings changes world 
term agent applied person animal nation robot 
applied program 
tutorial example provide opportunities introduce major problems agent design illustrate bod approach solving 
example building robot monkey live take party 
designing intelligence agent requires things determining 
bod agent controlled set modular programs called behaviors 
building monkey scratch level take care individual component doing instant time 
problem easier break pieces write different program piece 
different behaviors sitting jumping playing eating screeching 
ways monkeys intelligent things interesting doesn involve issues animal welfare 
mean time powerful general say circumstances problem action selection 
time need able say monkey right 
bod solve problem providing structured list circumstances actions reactive plan 
formal definitions terms chapter share vocabulary 
problem terminology abstraction level granularity determine monkey act 
detail give 
assume right want monkey stay trouble decide 
tell monkey wait 
sit 
put legs body put hands knees look room approximately minute intervals normal distribution standard deviation seconds interval randomly select situation appropriate deliver 
problem choosing comes chose determines hard write 
making program easier write describing execute harder vice versa 
example decide create world peace go buy banana programming complicated 
hand easy program move little finger inch lot 
parts problem 
behavior decomposition 
problem deciding behavior module 
worked artificial perception vision speech recognition recognize behavior decomposition somewhat analogous problem segmentation 
problem determining interface 
architectures bod treat problem behavior decomposition interface 
example may single sitting behavior different interfaces sit wait quietly get 
plans aren just 
plans actions behaviors know 
bod methodology trick designing agent choose set easy build possible 
making educated guess think 
develop iteratively 
turns wrong guess ok change replace 
development iterative ongoing process 
try build simple doesn try fix 
try build bigger better interesting 
mistakes people project complicated careful sure maintain 
bod methodology reminds developers development ongoing process 
critical continually look agent simplified clear possible agent works 
complicated decompose simpler pieces new 
example wait turns complicated thing build split sit scratch look play need recombine 
example want say re tired look minutes play listening scratch aren doing complicated develop new support simplify decision process 
example may want build new monkey tell tired anybody listening 
bod exploits traditional software engineering tools hierarchy modularity things simple possible 
heavily exploits advances object oriented design development methodologies 
uses new representations understandings intelligent processes artificial intelligence ai 
behaviors saying way say bod object oriented programming methodologies 
particular language isn important development general methodology particular goes faster untyped languages lisp perl smalltalk typed ones java 
course typed languages run relatively quickly general time spent developing agent significantly important speed best case execute commands 
finding best case harder making agent run fast 
simplest behavior bod decompose modules called behaviors code objects 
behaviors responsible perception action 
perception interpretation sensory input information useful controlling effectors 
effectors affects external world 
include motors robot nodes model virtual reality character speaker screen personal computer agent trying pass turing test 
behaviors responsible governing effectors perform learning necessary perception control 
objects software engineering consist program code built variable state informs 
simplest possible behavior requires perception state 
assume monkey sound card attached speaker effectors 
ultimately simple behavior screeching behavior sends sound card instruction go time 
ll call screeching behavior 
ll draw name underlined behaviors state screeching unfortunately constant screeching appeal communicative power 
want screeching behavior little sophisticated 
give bit state action communicated bit high 
screeching behavior interesting want pulsed 
requires state keep track pulse 
screeching sound function pulse current duration need accumulator keep track long monkey screeching 
screeching behavior looks screeching screeching 
pulse duration draw state inside behavior box name 
behaviors perception relatively little behavior operates regard events environment controlled open loop feedback 
example want monkey able modulate volume screeching just loud heard ambient noise room 
monkey louder party sitting quiet house 
requires monkey access sound input microphone kind able process information determine volume 
include part screeching behavior 
screeching screeching 
pulse duration noise hand perception useful screeching require states processes generally unrelated screeching 
situation sense additional perception handled behavior set behaviors 
example real monkeys start screeching see enter room 
different depending person friend enemy stranger 
visual recognition fairly complicated task useful things just determining screeching want part behavior 
replicating state generally bad idea software engineering possible copies synch better screeching behavior uses state visual recognition behavior help select formants particular 
drawing behaviors screeching screeching 
pulse duration known liked recognize familiarity levels affinity levels method calls relate put arrow 
direction arrow indicates flow information responsibility making information flow 
fact normally receiving behavior actively observes information behaviors 
behaviors triggers processes mentioning multiple behaviors brings possibility conflicts behaviors 
example monkey surprise party sees main guest walk room 
monkey inhibit screeching gives signal start 
similarly polite monkey shouldn start screeching exactly new comes eating bite cake 
swallow 
bod conflict resolution handled allowing action selection mechanism determine things expressed 
interface called 
coded method object underlying particular behavior 
screeching behavior want add inhibit lets plans specify exceptional situations monkey stay quiet 
deciding viewed deciding release trigger action particular behavior 
inhibit screeching screeching 
pulse duration known liked recognize familiarity levels affinity levels hand actions behaviors learning perceptual processing may run continuously spontaneously interference part intelligence 
long interfere behaviors reason coordinate 
example reason build monkey control selection formants system 
screeching behavior continuously choosing appropriate regardless currently screeching having process constantly resetting state basis identity lack known identity person monkey observing 
behaviors aren objects may easier build means coding scratch 
example may available external packages may easier learn program 
ok case inter behavior methods just interface programs packages 
cases useful conventional behavior maintains state determined external behavior 
example monkey face recognition commercial package returns identity individual vector 
coded object behavior learns experience categorize vectors friend enemy familiar neutral unfamiliar 
inhibit screeching screeching 
pulse duration known liked plans saying recognize familiarity levels affinity levels identity face recognizer consideration programming chapter real examples working systems shown chapter 
turn problem deciding 
bod controlled structures read special behavior action selection 
ai structures control action selection generally called plans 
bod uses hand coded flexible plan structures 
plans called reactive plans agent react immediately thinking situation 
simplest plan simplest plan just list instructions example get banana peel banana eat banana list called simple sequence action pattern 
course specifying complete behavior entire lifetime monkey sequence tedious 
provably impossible 
common way specify associate particular context agent perceive 
pairing called production rule 
context called rule precondition called action 
example plan changed set rules hunger get banana banana peel banana peeled banana eat banana put contents precondition parentheses indicate really question 
question answered rule fire action executed 
look new plan better old plan 
thing specified new critical execute plan 
somebody hands monkey peeled banana able execute rule eat banana executing sequence plan 
unfortunately easy 
sequence wanted monkey know 
say intend monkey dinner party want able pass bananas guests original sequence translate rules get banana left pass banana right left neighbor offers banana get banana left banana pass banana right rules operate context banana 
monkey 
try help monkey adding piece context precondition rules 
example rules plan include precondition hunger rules plan condition party 
monkey party hungry 
poor monkey 
problem programmer worse monkey 
want determine monkey add exception rules written 
assuming think polite important eating writing party rules ll go back fix plan include party 
fix behavior runs monkey rules know party rules higher priority eating rules 
want monkey eventually eat party 
production rule structure powerful useful doesn critical things sequence 
sequence maintains removes ambiguity storing control context 
monkey keeps steps plan sequence takes banana left knows try pass right 
circumstance banana needs think passing 
don try real monkeys 
basic reactive plans summarize previous section production rules useful facilitate flexible behavior tying action context 
rapidly difficult manage amount context needed differentiate rule firing 
sequences carry context 
embedded sequence carries disambiguating information things occurred just just 
sequence represents implicit decision monkey disambiguates monkey policy time 
combine attributes features structure basic reactive plan brp 
try rewrite plan full goal hunger peeled banana eat banana banana peel banana get banana notation indicates rules relevant particular activity clustered brp 
brp sequence limits attention small fixed set behaviors 
encodes ordering time strict temporal 
records prioritization 
priority increases direction vertical arrow left 
monkey peeled banana ll eat 
banana ll peel 
ll try get banana 
brp powerful structure simple sequence 
monkey eats banana isn full ll get 
case highest priority step brp special rule called goal 
goal detects brp task finished 
brp ends rules fire achieved goal 
notice sequence brp reverse order 
highest priority item goes top precondition gets checked 
notice rule doesn need precondition guarded low priority 
fire monkey action selection attention context brp rules fire 
information chapters 
making complete agent drive collections plans contain elements plans called hierarchical 
natural questions hierarchy start know plan hierarchies behaviors specification 
start principle plan 
plan ends agent intelligence just 
sense certain kinds software agents called existence just perform certain job 
interested making monkey 
lasts time decides set motivations principles 
call sort agent complete agent 
start root plan hierarchy put brp specially designed 
special designing just involves blocking ways 
brp goal succeeds completes 
second brp element run fails 
brp govern monkey building party obligations exist polite life hungry eat banana friends friends comfortable wait notice added sense perceiving obligations 
way monkey eat party long aware social obligations 
didn specify goal included low priority behavior run life 
drive collection special name top root brp 
bod agent drive collection works environment monitor agent architecture needs see chapter 
drive collections special features help agent particularly reactive explained chapter 
bod methodology choosing previous parts chapter talked elements bod agent architecture 
bod methodology constructing agents 
parts creating initial specification iteratively building agent 
describing ordering motivations complete agent section part specification process 
need entire specification 
high level description agent 

collections actions sequences perform functions agent needs able 
reactive plans 
list including questions senses occur reactive plans 
primitive interface 

objects collecting state needed primitives program code acquiring state 
behavior library 

prioritized list high level goals agent need attend 
drive collection 
need build agent 
choose piece specification 

code test debug plans behaviors build piece 

revise specification 

go back 
keep doing part agent want 
principle iterative design important things bod iterative design general realizing specifications changed 
really understand problem try solve 
tempting started working agent try specification 
tends get messy tack fixes program parts get bigger complicated parts stay small really get finished 
kind program gets harder harder add get hard debug 
bod methodology emphasizes change keep happening 
take time iterative cycle revise specification 
want sure keeping agent simple possible specification clear possible 
part job building agent 
revising specification tricks revising specification specific bod architecture 
fact bod architecture designed help process easy 
section introduces basics detail chapter 
main design principle bod doubt favor simplicity 
things equal better sequence brp 
better single primitive sequence 
better control state variable state behavior 
rules thumb question violate 
heuristics knowing violate rule thumb brp elements sequence repeated skipped 
sequence primitive want reuse part primitive plan 
add variables behavior control state unnecessarily redundant complicated triggers 
talked rule heuristic sections 
second heuristic basic principle software engineering code thing twice generic function 
simple reason 
hard get code written correctly fully debugged 
doing asking trouble 
third rule principle reactive intelligence third heuristic helps explain don want fully reactive agent 
having memory control easier worth 
example 
consider primitive get banana plan 
monkey get banana 
lets suppose coded monkey go kitchen climb counter look fruit bowl 
bunch break loose take throw fit 
clearly deal coded plan behavior 
principle bod behavior programmer pieces 
example decide want monkey able get glass water motivation write plans get banana go kitchen take banana get glass water go kitchen pour glass water notice plans guarded question plan element 
changed particular get banana simple method behavior sequence 
don need change old plan 
just update part specification 
behavior oriented design agent architecture fields autonomous robots virtual reality come dominated hybrid layer architectures 
process dominance documented chapter 
hybrid architectures cross 
behavior ai decomposition intelligence simple robust reliable modules 
reactive planning ordering expressed actions carefully specified program structures 
optionally deliberative planning may inform create reactive plans principle learn new behaviors 
engineering easier exploiting modularity 
reactive planning easier engineer simplifying arbitration behaviors 
deliberative planning generally included reorganize existing plan elements case unanticipated changes world 
example planner choose alternative route office complex door shut 
best description layered hybrid systems know layer architecture arises empirical observation effective algorithms controlling mobile robots tend fall distinct categories 
reactive control algorithms map sensors directly actuators little internal state 
algorithms governing routine sequences activity rely extensively internal state perform search 
time consuming relative rate change environment algorithms planners 
gat gat view layer architectures particularly close view agent intelligence puts control firmly middle reactive plan layer 
deliberative layer operates prompted requests 
differ believe primitive actions defined simply mapping sensors directly actuators little internal state consideration past 
said chapter nearly perception ambiguous requires expectations rooted experience discriminate 
experience may extremely example phoneme speech easier recognize remember phoneme immediately preceded speech production affected starting position mouth 
useful experience may fairly example remembering set banana answered phone 
may result life long learning learning recognize face learning way house town 
primitive actions governed reactive plans may dependent information 
action dependent completely stateless primitive modules information utilized having higher level state primitive level defeats purpose generic parameter stream communicate layers removes specialization 
solution 
bod recommend fully embracing modularity 
primitive act interface semi autonomous behavior module maintains state possibly performs time consuming processes memory consolidation search parallel main activity complete agent 
bod reactive time action primitive look current state minimal computation 
view agent control similar gat behavior oriented systems multiple semi autonomous skill modules behaviors 
generate actions 
perception derived sensing indicated eye icon left 
actions affect state outside generating behavior internal agent external indicated hand icon right generally subject arbitration action selection system 

increase number importance specificity potential simplicity modules composing top layer 
call behavior library 

replace notion bottom layer interface module agent behavior modules 
words tutorial gat high level translates middle layer translates reactive layer reduced simply interface 
bod dealing shut doors domain particular behavior knows maps general purpose reasoning system 
simple diagram bod architecture seen 
important points drawing behaviors controlled action selection 
semi autonomous 
may act independently update state change physical world provided interfere behaviors 
action selection may considered just specialized behavior 
reactive plans specialized representation 
chapter introduced basic elements behavior oriented design bod 
architectural elements semi autonomous behaviors hierarchical reactive plans methodological elements initial task decomposition procedure incremental development 
chapter motivate bod looking evidence ai literature utility certain architectural features 
chapters follow go considerably detail aspect bod 
parts planning reactive plans behaviors specialized learning design process 
eventually monkeys 
chapter background critical components agent architectures working examples dissertation implemented control software written thesis claims principles behavior oriented design general contributions broadly applicable 
chapter supports claim different ways 
documents architectures different paradigms ai research agent development 
documentation indicates general utility features bod introduced previous chapters 
second uses principles predictions suggestions directions architectures paradigms 
suggestions lead shown chapters demonstrate extending existing architectures projects features bod 
chapter attempt full review related architecture literature 
concentrate architectures architectural traditions widely known 
increases amount selective pressure architectures 
changes architecture time particularly telling architectures long documented period research particularly interesting 
features trends complete agent architectures approach agent architectures design methodologies 
assortment architectures autonomous agents community reflects collective knowledge methodological devices useful trying build intelligence 
consider perspective derived maes wooldridge jennings significantly useful thinking architecture uniform skeletal structure specified particular program 
definition agent architecture collection knowledge methods provides better understanding single architecture evolve laird rosenbloom myers architectures combined cf 
chapter 
design knowledge expressed agent architectures types knowledge derived reasoning knowledge derived experience 
knowledge derived reasoning explicit early papers architecture ideas viewed hypotheses implemented architecture evidence 
knowledge derived experience may subtle recognized reported explicitly may hidden skill sets group developers 
worse may buried unpublished record failed projects missed deadlines 
premise chapter facts building intelligence history progress agent architectures 
words architectures tend include attributes proven useful time experience 
unfortunately selective processes simple matter determine particular expressed attribute proven useful 
useless feature may closely associated useful attributes consequently propagated community part known established architecture 
similarly dominating architectures may lack particular useful elements survive due combination sufficient useful resources sufficient communal support 
reasons expect particular architecture serve ultimate authority design methodology ignores arguments niche specificity various architectures 
assume architectural trends evidence utility particular design approach 
identifying design advantage trends useful allows research community develop exploit new methodology 
particular architecture architectural paradigm trend emerged benefit autonomous control community general 
extent architectures face problems supporting design intelligence development effort may benefit emphasizing strategies proven useful 
architectures larger number features communities typically utilize 
words architectures specified design methodologies 
consequently established design efforts may able exploit new knowledge design strategy changing architectural software tools 
may able simple additions established design processes 
chapter demonstrate approach evaluating enhancing agent architectures 
survey dominant paradigms agent architecture technology behavior design layer architectures prs belief desire intention architectures soar act 
looking historic concerns architectural approach shaped differentiated communities 
review paradigm systematic changes taken place years 
conclude discussion architectures terms lessons derived review making recommendations stages development paradigm 
thesis chapter clearer results introduced chapter 
analysis indicates architectural attributes necessary producing agent reactive capable complex tasks 
explicit means ordering action selection particular mechanism exploiting hierarchical sequential structuring 
system allows agent large skill set focus attention select appropriate actions quickly 
contentious issue agent architectures controversy reviewed 
utility hierarchical control obscured fact sufficient 
necessary components include parallel environment monitoring system agents dynamic environments modularity benefit architectures 
modularity substantially simplifies design process substantially simplifying individual components built 
dissertation define modularity decomposition agent intelligence part intelligence number smaller relatively autonomous units 
mean imply fully encapsulated modules fodor state functionality module strictly unavailable 
useful form modularity decomposed lines ability module formed perception action routines necessary ability required associated state 
fully modular architectures create new design challenges 
sequential hierarchical control avoided action selection interacting modules difficult 
architecture allow specialized action selection system focus attention appropriately may fail notice dangers opportunities unexpectedly 
agents existing dynamic environments architectural support monitoring environment significant changes order complete agent remain responsive 
environment monitoring may part main action selection system separate system priority ordinary action selection 
traditional approach review brief review traditional ai approaches agent organization 
traditional architecture psychology artificial intelligence shown 
architecture indicates problems intelligence transform perception useful mental representation apply cognitive process create representation desired actions transform necessary motor neural effects 
model lead intelligence researchers feel free concentrate single aspect theory intelligence process transformations considered key element intelligence 
model may sufficiently general necessarily correct uninformative fact number assumptions known wrong 
assumes perception action separated successfully cognitive process 
perception known guided expectations context perceptual experiences explained neely environment percepts actions sensors effectors agent traditional ai architecture russell norvig 
macdonald 
brain lesion studies limb control shown actions require constant perceptual feedback control require cognitive contribution initiation matheson bizzi 
second problem architecture hypothesis intelligence separation representation cognitive process necessarily coherent 
neural theories postulate assembly neurons processes information perception mcclelland rumelhart port van gelder 
processing continues recognized configuration settled 
configuration involves reaching critical activation fire motor neurons process running perception activity 
levels activation various neurons taken representation process continuous chain re representation 
notice concept stopping point cognition artificial provision perceptual information processing activity continuous dynamic agent 
activations motor system incidental consummatory 
behavior architectures society mind traceable philosophy far back hume psychology far back freud notion decomposing intelligence semi autonomous independent agencies popularized ai minsky 
minsky model promotes idea multiple agencies specialized particular tasks containing specialized knowledge 
minsky proposes control units easier evolve species learn individual single monolithic system 
argues model better describes diversity inconsistency human behavior 
minsky agents mind hierarchical semi autonomous 
example postulates child separate agencies directing behavior involving sleeping eating playing 
compete control 
agent emerges subsidiary agencies turn compete 
playing chosen blocks compete books blocks chosen building compete episode 
agency charge eating may overwhelm agency charge playing coherent behavior may interrupted mid stride different agencies swap take control 
cost theories successfully explain incoherence human thought activity fail explain coherence 
minsky addresses postulating modular completely distributed system thought 
explains coherent behavior output single agency suite agents incoherence consequence competing agencies 
recognizes coherent transitions apparently modular behaviors 
address postulates type structure line 
lines connect modules associated time space parts entity 
posits fairly traditional elements knowledge representation frames knowledge hierarchies maintaining databases knowledge various agents 
subsumption architecture brooks took modularity greater extreme established movement ai 
brooks model subsumption architecture module computationally simple independent 
modules referred behaviors originally consist finite state machines 
explicit number states behavior characteristic predefined output 
finite state machine completely specifies new states reached state transitions dependent input machine 
brooks intent constraining intelligence finite state machines simplify engineering behaviors force intelligence reactive 
fully reactive agent advantages 
behavior linked directly sensing able respond quickly new circumstances changes environment 
turn allows opportunistic 
conventional planner continue execute plan oblivious fact plan goal presumably agent intention fulfilled rendered impossible events opportunistic agent notices opportunity fulfill goals exploits opportunity 
traits robots built subsumption architecture highly reactive 
individual behavior exploit opportunities avoid dangers arise 
consequence behavior having sensing running continuously parallel behavior 
second behavior executes result date information 
information stored information reflection current environment 
useful reasons expressed traits create problems designing agents capable complex behavior 
behaviors pursuing different goals impossible opportunistic simultaneously 
consequently agent sophisticated potentially conflicting goals eat escape danger form behavior arbitration 
subsumption architecture provides behavior arbitration mechanisms 
behaviors organized layers pursues single goal walking 
behaviors goal assumed contradict 
higher layers added lower layers capability observe input suppress replace individual behaviors output necessary 
actions occur communications channels behaviors wires originally literal sense behaviors 
interference designed part layer affect inner workings behavior expressed consequences workings 
experimentation third mechanism behavior selection introduced subsumption architecture 
description behavior changed finite state machine finite state machine augmented timer timer set external behaviors result behavior deactivated timer runs 
timer mechanism added subsumption architecture problem development herbert retrieving robot connell 
herbert began pick arm blocked camera making impossible robot see 
allow robot search behavior dominate pick behavior successfully retrieved 
timer pick behavior able effectively pause behaviors action selection moment 
diversification behavior ai reactive behavior approach widespread particularly academic robotics character virtual reality 
single architecture percent researchers 
subsumption architecture described far best known architectures relatively agents built adhere strictly 
example matari bryson include adaptive extensions steward behaviors nearly completely independent called agents 
brooks laboratory inspired develop architecture develop code completely specified architecture attend details subsumption horswill steels marjanovic parker tu stone veloso 
steels goes far claim behaviors built require action selection subsumption simply run continuously parallel behavior architectures inspired subsumption turn told strategy abandoned engineering reasons feasible considered lab valid hypothesis biological intelligence 
tends require behavior model sufficient extent interfere 
modeling overhead programmers abandoned favor inter behavior communication 
attracted attention maes spreading activation network maes 
maes architecture consists number nodes including action nodes perception nodes goal nodes 
nodes connected way system links 
link specifies extent second node requires node executed specifies extent node enables second node fire 
conduits allow activation spread bottom starting perception nodes top starting goal nodes 
single node gets sufficient activation threshold node executed 
maes greatest explicit hypothetical difference subsumption architecture belief agents multiple manipulable goals see maes 
maes claim subsumption architecture allows encoding single goal agent mistaken strictly stacked goal structure subsumption sufficiently rigid arguments valid 
implicit hypothesis need way specify sequential behaviors weighting connections allows 
hand maes explicitly opposed notion hierarchical behavior control maes 
maes states hierarchical methods behavior arbitration creates bottleneck necessarily system incapable sufficiently reactive control agents dynamic environment 
hypothesis disputed tyrrell showed flaws maes approach notably insufficiently directed words adequately focus attention 
appears means set weights behaviors way nodes composing particular plan action behavior sequence chain order 
unrelated behaviors may alternate firing creating situation known dithering 
bias consummatory goal behavior performed preceding nodes enabled goal terminating position typically connected fewer sources activation 
tyrrell competing hypothesis hierarchy exploited action selection providing behaviors allowed fully active parallel final decision combining computation 
tyrrell refers strategy free flow hierarchy attributes rosenblatt payton 
tyrrell gives evidence hypothesis comparing maes architecture directly hierarchical ones free flow traditional hierarchies purpose built artificial life environment 
tyrrell test world small animal needs balance large number conflicting goals different types 
example eat maintain body temperature sleep home night avoid different types predators mate frequently possible 
simulations cover days life involve thousands decision cycles day 
extensive experimentation tyrrell demonstrates substantial advantage hierarchical architectures modeled maes approach 
tyrrell shows statistically significant superiority free flow hierarchy nearest strictly hierarchical competitor fact simple model control 
claims free flow hierarchy optimal action selection mechanism able take account needs behaviors 
sorts cooperative rules refined 
example suggests choosing course minimizes maximum disapproval elements tends lead optimal solutions 
thoroughly distributed approaches challenged 
bryson suggests simplicity finding optimal design programmer learning process evolution outweighs advantage cooperative negotiation 
action selection system uses hierarchical controller small subset nodes corresponding number elements top layer hierarchy actively vie control agent 
nodes compete basis relative activation levels activated threshold strictly prioritized 
particular cycle highest priority node threshold activation takes control 
winner branch hierarchy competitions take place 
similar traditional hierarchy excepting parallel roots details execution bryson shows statistically significant improvement tyrrell results system evaluation 
blumberg presents architecture takes considerable inspiration maes tyrrell extends control trend conventional hierarchy 
blumberg system tyrrell organizes behaviors hierarchy allowing activated parallel 
blumberg system highest activated module wins locks critical resources requires legs module regulates walking 
nodes active require locked resources allowed express 
dog walk wag tail time different reasons 
hierarchy exploited focus attention voting system 
behavior participates vote fact initially blumberg stated feature system kline blumberg 
blumberg architecture research groups including brooks breazeal scassellati major commercial animation development significant interest 
rcs albus uses hierarchy organize behaviors case strict precedence layers hierarchy 
number predetermined layer membership determined temporal extent actions 
layered decomposition behaviors terms temporal subsequently incorporated ymir th risson layers 
architectures large real time projects multiple developers 
rcs particular military projects modularization action selection behavior probably facilitates development 
way architectures utilize hierarchy ways layered architectures discussed section distributed action selection similar behavior systems 
summary behavior systems modular modular design strategy large part defines paradigm 
behavior systems rely modularity source reactiveness particular behavior may express opportunistically needed 
lead difficulties action selection limited complexity tasks addressed systems 
action selection mechanisms vary widely individual architectures indicating field settled stable solu tion 
architectures incorporating hierarchical sequential elements 
multi layered architectures achievements behavior reactive ai researchers influential outside communities 
fact universal acceptance amount intelligence best modeled terms relatively agree cognition described way 
researchers attempted establish hybrid strategy behavior system designed traditional ai planner deduces action searching knowledge base act bring closer goal 
traditionally planners micro managed scripting individual motion 
making elements semi autonomous behaviors react adapt limited uncertainty planners simplified 
account project late behavior plan execution implemented bottom useful capability possible useful capability looked simplify design planner 
similarly planner designed top interface clarifying nature useful capabilities behavior system aim 
design method greatly reduced complexity planner increasing complexity agent reduction reduced system complexity 
produced robust system capable executing novel plans reliably despite uncertainty 
malcolm section malcolm system seen layer system behavior foundation controlled planning system 
popular late layer systems introduced section 
layer systems similar middle layer consists plan fragments referred implicit knowledge contrast explicit reasoning top level planner 
distinction middle layer considered reactive create plans selects situation top layer traditional constructive planner 
systems top layer planner manipulates generates intermediate representation level acting directly behavior primitives 
currently successful layered robot architecture bonasso features reactive action packages raps firby middle layer 
raps system creating reactive flexible situation driven plans uses lower layer behavior primitives 
integrates system constructive planner 
numerous robots academic mobile robots robotic arms manipulating hazardous substances previously controlled teleoperation maintenance robots nasa planned space station 
leon uses simulation run entire space station including farming environmental maintenance 
kortenkamp provide fairly reviews layer architectures 
may tool modeling human intelligence behavior models discussed earlier approximating logical competence 
planning mathematically proven unrealistic model intelligence relies search chapman 
search combinatorially explosive behaviors complex task leads exponentially difficult search 
doubt animals search certain contexts seeking food human choosing gift search space tightly confined strategy successful 
better model sort process atlantis gat controlled middle layer operates top planning layer demand 
model fact quite similar norman shallice model human action selection conscious control essentially interrupt driven triggered particularly difficult dangerous situations 
alternative model top level main controller typical bonasso albus malcolm gat model natural extension behavior approach 
notable bonasso report number projects completed lower layers 
incompatibility early behavior layered system approach behavior systems emphasis emergence 
hybrid system emergent behavior useless malcolm 
emergent behavior definitionally name handle system consequently planning layer 
humans acquired skills recognized deliberately smith 
attempts model development skill element middle layer actions performed deliberately planned top layer acquisition deliberate control skills 
hypothesis requiring forms learning probably valid actual representations mechanisms relatively unproven 
group researching issue learning behaviors assigning levels stone veloso 
veloso group series highly successful entrants various leagues robot soccer architecture selective pressure 
converging modularity areas specialized communication learning having directed acyclic graph dag general action selection preset plans 
summary layer architectures succeed complex tasks real environments 
generally simplified behavior modules lowest layer reactive plans second layer 
plan layers carefully organized order maintain reactivity architectures rely bottom level behaviors function operate dynamic environments 
modularity generally limited lower level architectures top level planner seen specialized module 
current research indicates open questions concerning optimal kind planning top layer manipulate shift information representations particularly learned skills 
prs beliefs desires intentions robotics dominated layer architectures late field autonomous agents dominated single architecture procedural reasoning system prs georgeff lansky inverno 
prs began robot architecture proven sufficiently reliable extensively tasks defense simulations 
originally developed roughly time subsumption architecture part follow program longest running robot experiment shakey nilsson 
prs designed fix problems traditional planning architectures exposed shakey project 
problems include constructing complete plan action 
necessary part search process underlying constructive planning planner determine plan viable complete 
plans fact formed backwards selecting action needed reach goal second 
issues opportunism discussed details real problem known plan executed 
example crossing room full people locations people determined time actual crossing 
long create plan ignoring demands moment 
standard example trying cross road robot time replan suddenly spots car needs reactively move way 
unable create plans contain elements primitive acts take advantage skills learned procedures 
unable manipulate plans goals 
plans may need abandoned multiple goals pursued simultaneously 
obviously list similar problems behavior programmers attempted solve 
main differences approach 
prs layered architectures maintains priority ability construct plans action 
architecture allows incorporating specialized planners problem solvers 
second difference prs development couched psychological terms opposite brooks conscious impact intelligent processes 
prs referred bdi architecture built concepts beliefs desires intentions 
researchers appreciate belief desires intentions approach concept embracing prs 
example sloman logan consider notions belief desire intention emotion central agent propose expressing layer architecture 
sloman top layer reflective middle deliberative bottom layer reactive 
similar malcolm third layers bonasso additional layer dedicated manipulating goals malcolm bonasso top layers considering current effectiveness 
particular role assignment layers layer architecture proposed 
prs architecture consists main components connected interpreter called reasoner drives processes sensing acting rationality 
component database beliefs 
knowledge outside world sensors agent internal states possibly knowledge introduced outside operators 
includes memories built previous knowledge 
second component set desires goals 
take form behaviors system execute descriptions external world state traditional planners 
third prs component set plans known knowledge areas 
plan necessarily completely specified list subgoals useful achieving particular somewhat bod posh action selection 
may include means manipulate database beliefs construct action new knowledge 
final main component stack intentions 
intentions simply set plans currently operating 
stack indicates plan driving command system time multiple plans may stack 
typically ordering stack changed plan interrupted new information may trigger reorganization 
multi layer architectures prs works hypothesis system needs ability plan situations navigation ability execute skilled acts situations search reasonable avoiding trucks 
sense plan behavior behavior ai 
behavior ai essentially retreat allowing programmers solve advance hard important problems agent going face 
procedure solve individual problem usually relatively easy design 
modularity design knowledge areas plan library 
hand prs see specialized state representations dedicated particular processes worth tradeoff having access general information 
moved procedural element traditional planners closer behavior ideal state 
allows specialized modularized data tagging 
interpreter goal list intention stack action selection device prs 
prs variants exist planning engine set development tools 
industry government research 
prs gone number revisions fact original project dying 
large change basic structure original prs adoption act formalism plan libraries conventional constructive planner wilkins 
move seen part general trend current prs research attempt system easier idea planner allow plan libraries generated automatically 
prs lite myers uses easily combinable fuzzy behaviors 
number labs worked formalizing prs plans order planning provably correct inverno 
efforts difficulty reactive element architecture meta reasoning 
original development lab prs sri focusing effort modularized ai architecture built multi agent paradigm wilkins myers 
prs systems active derived um prs huber 
modification systems providing prioritization reactive plans order simplify meta reasoning 
pre history prs shakey project relevant evolutionary trends nilsson 
shakey traditional planner called strips term project concept triangle tables developed 
triangle table decomposes plan steps assumptions creates contingency table allowing plan restarted point 
perception determine element plan executed 
allows action selection reactive confines plan relying memory steps executed 
approach leads naturally reactive plans nilsson developed form storage skilled behaviors developed planners 
benson describes basis system learns fly airplanes flight simulators architecture number research laboratories 
shakey project moved having multiple world models implementation having single storage place predicates observed data 
predicate form new plan observation 
development selective pressure experimentation lends credence mandate reactive ai simplify stored models 
summary prs related bdi architectures popular behavior systems academic settings 
may easier program 
provide significant support developing action selection mechanism hierarchical library plans separate specialized mechanism agent attention response environment 
particularly taken long term history architectures converged important principles simplified representations specialized ones modularization plan libraries 
current research trends indicate designing agent critical problem see chapter 
soar act soar newell act anderson ai architectures currently largest number researchers ai psychology particularly cognitive science 
soar cognitive architecture typically department defense simulations extensively due high computational overhead 
architectures fundamentally different previously reviewed architectures 
older dating late early original versions active development laird rosenbloom anderson 
soar community particular responded behavior revolution participating directly competitions approach kitano architecture layers see 
soar act characterize knowledge coming types data procedures 
characterize data traditional computer science ways labeled fields reflective level arbitrary subgoal processing deliberation deliberative level sequential selection application operators states reactive level parallel productions matching working memory input output level fixed transduction input output subgoals decision procedure production memory working memory faster cycle time processing soar layer architecture laird rosenbloom 
procedures form production rules 
soar system learns solve problems 
normal procedure match production rules current state world find applicable apply 
automatic roughly equivalent middle bottom layer layer architecture 
production production fire changed previous application production soar considers impasse 
soar encounters impasse enters new problem space trying solve impasse current goal 
new problem space may means available solve problem including planning searches 
soar built general purpose problem solving approaches uses powerful approach possible current amount information 
process way atlantis gat invokes top level 
soar allows process recurse meta reasoner hit impasse new reasoning process begun 
soar includes built learning type information 
impasse resolved original situation taken precondition solution procedure new rule created takes priority possible solution situation met 
creating automatic skills declarative procedures happens quickly exemplar 
learning system cumbersome add new rules high rate speed system inversely related number rules 
soar addresses combinatorics productions ways 
soar concept problem space discrete set productions involved solving particular goal working particular context 
system roughly hierarchical non impasse solving mode 
soar carefully crafted optimizations rete algorithm forgy optimizing production firing 
industrial users system choose exploit learning built soar 
act essentially simpler soar impasse mechanism learn new skills way 
act extensively cognitive modeling replicate psychological studies decision making categorization anderson 
act faces difficulty combinatorics takes significantly different approach attempts mimic human memory modeling probability particular rule data recalled 
sets symbolic knowledge shares soar act keeps bayesian statistical records contexts information frequency recency utility anderson 
uses information weight productions fire 
noise factor included statistical sub symbolic system result alternatives chosen occasionally giving better replication unpredictability human behavior 
alternatives useful exploring learning new strategies result suboptimal performance experiments prove useful best currently known strategy 
soar prs industrial level 
fact losing popularity cognitive science research community act attributed researchers largely fact act significantly easier 
largely soar designed primarily learn researchers compared programming soar teaching brain surgery 
simplification act proved extreme 
originally problem spaces course research hierarchical focusing attention necessary doing nearly complex modeling human mathematical competences primary goal act development team anderson 
act industrial real time situations 
soar evolved significantly laird rosenbloom 
particular moving solve problems dynamic real world domain critical allow programmers specify chains sequences events explicitly terms simple productions see section 
encoding time duration major challenge overcome soar moved robotics problem needed addressed early versions prs rap middle layer myers 
act adapted problems operating dynamic world representing noisy contradictory data reasoning events time 
summary despite coming significantly different paradigms research communities long documented histories soar act exhibit trends paradigms previously examined 
systems simulate extreme dis tribution control entirely production rules necessarily reactive 
fact soar compromise feature able provide real time control 
modularity control data provided problem spaces hierarchical soar provides explicit sequential action selection 
soar generic representations entirely satisfactory 
forced specialization procedure types due new benchmark tasks particularly mobile robotics 
soar suffers extreme overhead programming difficulty widespread 
act exploits niche research community simpler similar form learning system specialized improve ability model human cognition 
discussion recommendations complaints autonomous control community overgeneration architectures wanted users improvements systems familiar continuous diversification 
argument contains truth 
overlooks perspective stated agent architecture design methodology design methodology simply piece software 
architectural features conflict cases reason architectures combined architecture implemented 
discuss demonstrate chapter 
behavior architectures began advantages modularity reactive systems development complex control software hampered lack specific control architectures supporting hierarchical sequential ordering action selection 
largely due theoretical opposition system truly autonomous forced carry plan 
centralized control biologically plausible 
answer questions certainly see example barber martin bryson respectively discussion 
regardless observed empirically autonomous agents require action selection mechanisms 
behavior systems systems distributed behaviors 
may lead improvement robustness considerable cost programmability ease debugging 
shift layered architectures may natural progression ai reservations model 
systems deliberate constructive planner ultimate control may intuitive demonstrated desirable 
frequent lack layer research tradition success prs soar middle layer primary control action selection indications primary action selection probably emphasize reactive planning deliberation 
concern layered systems systems hap bates reilly free flow hierarchy architectures reviewed concept behavior mere pro gramming language primitive losing advantage modularity behaviors originally designed essentially autonomous entities closely couple perception action achieve particular competence 
unfortunately conceived finite state machines internal variable state 
nature perception universally accompanied memory learning development mammals dedicated learning categorize discriminate 
believe behaviors contain state appropriate competence state learning center behavior decomposition center modern object decomposition object oriented design 
primary suggestion behavior ai attention easing design action selection 
suggest experimenting limited functional modules abilities operating sequential plans smoothing motor output 
development parallel nearly universal reductionist state paradigm 
recommendation layered architectures look ways increase support modularity systems follow lead atlantis focusing action selection control middle layer 
clear better idea system separate action selection goal manipulation soar prs system behavior architectures 
bod example approach 
prs ways similar layer architecture emphasis middle layer building plan library 
particular software version prs distributed sri fairly impressive gui supporting editing debugging level intelligence 
gathered discussion layer architectures consider type support useful 
unfortunately prs leaves important levels abstraction largely unsupported difficult manage 
construction primitives left user done language prs implementation case sri implementation reduced set common lisp 
suggestions behavior layer architectures applies equally primitives ordered modularly 
fact built methods objects proprietary state shared prs database system 
recognize prs particularly consequences theoretical proving program correctness relies database 
stand claim state part perception 
having state proprietary module difficult having external sensor proprietary primitive function fact exactly equivalent 
design level surprisingly neglected hierarchical organization prioritization various elements plan library 
possible organize plans file space collection plans may saved single file lisp placing packages gui tool allows viewing plan time 
tool ordering plans clusters agents 
consequently visual idiom prioritizing plans simultaneously able fire 
prioritization handled poorly documented lisp code triggered blumberg partially addresses creating clusters behaviors 
believe clusters closer appropriate level abstraction behavior refers behaviors 
meta rule section main processing cycle 
providing tool address far simpler program reactive plan structure brp see section chapter 
prs lite addresses complaints manner recommended 
supports fuzzy behaviors primitives design methodology attempts eliminate need meta reasoning prioritization combination simplifying task increasing power goal descriptions myers 
solutions prove adequate fact areas focus change indicates agreement areas difficulty prs 
paradigms reviewed personal experience soar act having experienced tutorials anecdotes programmers 
different background structure appear remarkably similar design issues experienced early behavior architectures 
unsurprising systems thoroughly distributed 
parallel story augmenting subsumption architecture story augmentation soar time sequencing order facilitate robot control laird rosenbloom striking 
suggestions improving soar consequently essentially recommendations agent architectures general focus making agents easier design enhancing ease modular decomposition pre programmed action selection maintaining soar provision reactivity opportunism 
autonomous agent architecture need modular structure approach developing agent basic behaviors including perception action learning 
means easily engineer individual competences complex tasks 
evidently requires means order action selection sequential hierarchical terms situation triggers agent priorities derived task structure 
mechanism reacting quickly changes environment 
generally takes form system operating parallel action selection monitors environment salient features events 
addition technical requirements just listed central theme chapter agent architectures foremost design methodologies 
advantages strategy largely consequence effectively programmers working approach specify develop behavior agent attempting build 
stance necessarily concerns biological plausibility machine learning natural evolution automatic learning mechanisms face problems managing complexity human designers 
sorts bias help designer may help processes 
similarly understood natural intelligence serves knowledge source just successful agent 
discussed chapter 
chapters explain bod provides characteristics structured action selection 
chapter parallel rooted ordered slip stack hierarchical posh reactive plans behavior oriented design consists equally important elements iterative design process parallel modular behaviors determine agent behaves action selection determines behavior expressed 
chapter describes detail parallel rooted ordered slip stack hierarchical posh reactive plans underlie action selection bod agents 
chapter describes implement posh action selection directly standard programming language 
chapter discusses implementing key elements posh control agent architectures 
behaviors bod methodology covered succeeding chapters 
aside theorists may doubt planning necessary behavior architecture 
basic issues motivated reactive planning argument chapter induction history agent architectures chapter 
section tie loose ends researchers object term planning principle 
reactive planning really mean 
terms reactive intelligence reactive planning reactive plan appear closely related signify development different ideas 
reactive intelligence controls reactive agent respond quickly changes situ ation 
reactive intelligence equated association exaggerated 
reactive intelligence associated minimal representations lack deliberation brooks agre chapman wooldridge jennings 
said chapter reactive intelligence essentially action selection look 
reactive planning 
reason term exists early ai systems conventional constructive planning action selection planning synonymous action selection 
researchers generally considered reactive ai hate term reactive planning refuse apply 
really just means reactive action selection 
reactive planning supported architecturally distinct structures structures called reactive plans 
documented chapter reactive intelligence uses reactive plans 
embrace term reactive planning reasons 
wide spread acceptance general ai community 
second problems action selection sufficiently universal planning workshops interesting reactive planners 
similarly common representational issues constructed reactive plans 
move explicit reactive plans term reactive planning somewhat natural misleading 
isn having kind plans bad 
addressed length bryson concerns researchers sort hierarchically structured plan insufficiently reactive biologically plausible 
belief prevalent particularly practitioners behavior new ai maes hendriks jansen dynamical hypothesis cognitive science kelso van gelder 
hierarchical plans centralized behavior arbitration biologically plausible dawkins hallam byrne prescott appear 
sufficiently reactive control robots complex dynamic domains bryson mcgonigle kortenkamp shown experimentally reactive non hierarchical de centralized systems tyrrell bryson 
provide single failure point addressed standard multi agent system mas techniques bansal accepted characteristic critical systems power supply brain 
demonstrated coordinated mas bod chapter necessarily preclude existence semi autonomous behaviors operating parallel 
point significant respect contributions dissertation 
modularity critical simplicity design parallelism critical reactive agent 
bod supports attributes 
basic elements reactive plans reactive plans provide action selection 
time step agents number actions potentially expressed expressed simultaneously example sitting walking 
architectures centralized action selection subsumption architecture brooks agent network architecture ana maes designer fully characterize action determine expressed 
engineers generally easier describe desired behavior terms sequences events characteristic conscious planning temporally oriented memories 
posh plans contain element describe simple sequences actions called action pattern 
action patterns supply quick simple control situations actions reliably follow 
course control complicated non determinism environment agents capabilities 
types events may interrupt completion intended action sequence 
events fall categories 
combination opportunities difficulties may require current sequence reordered elements may need repeated skipped 

event hazard opportunity simply request may practical pursue different sequence actions finishing current 
posh action selection addresses forms non determinism fundamental reactive planning idiom basic reactive plan brp 
brp formally described section relevance reactive planning general examined chapter 
posh situation described handled brp derivative called competence 
competence allows attention focussed subset plan steps applicable particular situation 
competence action pattern address second requirement agent architectures modularity described chapter see page structures facilitate appropriate focus action selection attention 
second situation addressed variant brp drive collection 
drive collection constantly monitors environment indications agent switch plans 
addresses third requirement chapter need environment monitor alarm system 
posh drive collections continuous rest action selection forms root agent plan hierarchy 
remainder section provides formal descriptions sequences 
section detail posh elements refining basic idioms 
simple sequences structure fundamental reactive control simple sequence primitive actions including sequence element type useful reasons 
allows agent designer keep system simple possible succeed communicates clearly subsequent designer expected behavior plan segment 
second allows speed optimization elements reliably run order particularly useful sequences preconditions fine motor control 
executing sequential plan involves priming activating sequence releasing execution primitive act 
completion releases active elements remain 
notice equivalent process chaining element essentially independent production precondition set firing prior element 
sequence additional piece control state elements may occur different orders sequences see section rules bananas houghton hartley 
depending implementation fact sequence elements released termination prior elements significant real time environments fact actively existence prior element increase plan robustness 
definition sequence derived biological models serial ordering henson burgess 
basic reactive plans element type supports case changes circumstance affect order plan executed 
idiom characteristic reactive planning refer generic idiom basic reactive plan brp brp step tuple priority releaser action 
brp small set typically plan steps associated achieving particular goal condition 
releaser conjunction boolean perceptual primitives determine step execute 
priority drawn total order necessarily unique 
action may primitive action brp sequence described 
order expression plan steps determined means releaser priority 
step operable priority determines step executed 
step released priority winner determined arbitrarily 
normally releasers steps priority mutually exclusive 
step fire brp terminates 
top priority step brp necessarily goal condition 
case releaser recognizes brp succeeded action terminates brp 
details operation brp best explained example 
control complex systems mobile robots flight simulators nilsson steiger gar benson 
clarity draw example blocks world 
assume world consists stacks colored blocks agent wants hold blue block possible plan occur architectures bod see section 
example due whitehead 
perceptual operations plan visual routine theory ullman implemented horswill 
example discussed chapter 
priority releaser action holding block block blue goal holding block drop held lose fixation fixated blue grasp top stack blue scene fixate blue case priority strictly ordered represented position highest priority step top 
refer steps priority 
case world consists stack red block sitting blue block 
agent fixated blue block plan activated holding operation performed element releaser satisfied 
part previous plan agent fixated blue skipped higher priority step releaser satisfied 
fixation established element trigger 
grasp successful followed element repeated 
assuming red block eventually grasped discarded successful operation element result blue block held point element recognize goal achieved terminate plan 
single reactive plan generate large number expressed sequential plans 
context red block blue block expect plan execute 
agent fixated blue fails grasp red block successfully attempt expressed plan look 
unsuccessful grasp knocked red block blue expressed plan 
reactive plan identically robust opportunistic changes caused agent 
significant feature brp relatively easy engineer 
build brp developer imagines worst case scenario solving particular goal ignoring redundant steps 
priorities step set inverse order steps executed 
preconditions set starting highest priority step determine fire 
process setting preconditions simplified facts programmer assume agent context current brp higher priority step able fire 
example step need precondition block blue step needs say trying find blue block important happened action fails repeatedly grasp top stack brp lead infinite loop 
prevented means 
competence described allows retry limit set step level 
related systems soar newell generic rules check absence progress change 
soar determines lack progress monitoring database 
complete agent level rules modeled motivations pertaining boredom impatience 
section demonstrates bod agent specialized episodic memory keep track progress chapter demonstrates modeling agent motivations sort bookkeeping 
posh plan elements previous section explained basic elements reactive planning sequence brp 
chapter discuss fundamental architectural concepts identified generally discuss extending existing architectures 
chapter concentrates brp details existing architectures don support 
describe implementing brp architectures capable supporting 
chapter devoted explaining posh action selection context bod 
action patterns posh call simple sequence action pattern ap 
ap doesn differ significantly sequence described 
current implementation posh action selection allows action patterns contain parallel unordered elements 
change introduced structures ubiquitous literature serves documentation developers fact particular reason ordering 
reason feature 
competences competences form brp 
ap competence focuses attention particular set elements suited performing particular task 
competence useful elements ordered advance 
competences archetypical 
difference posh competence formal definition brp described competence allows specification limit number retries 
limit set individually competence step 
competence step really quadruple optional maximum number retries 
negative indicates unlimited retries 
initially experimented optional habituation recovery values operated priority level competence step 
inspired neural spreading activation maes models action selection considered desirable biological plausibility 
difficulty managing design strategies convinced biologically plausible different level abstraction 
competences return value terminate due goal trigger firing terminate steps fire 
values irrelevant posh action selection implemented version drive collections described 
occasionally relevant section 
drive collections slip stack reactive agent able change current focus action selection attention deal context changes environmental internal require switching plans reordering steps 
hybrid architectures control highest level considering problem domain deliberation introspection 
bod treats problem continuous general problem action selection terms constraints need reactiveness solution 
third element type bod drive collection elaboration brp 
step case drive element elements drive priority releaser brp actions different 
root brp hierarchy currently active element drive 
drive collection element triggered fired just standard brp 
competence triggers child posh element competence action pattern drive collection assigned value 
hand competence action pattern terminates time drive element fired replaced root hierarchy 
policy having active posh element assigned step drive collection key features posh plans slip stack hierarchy 
slip stack defeats overhead hierarchy bottleneck maes warns 
cycle action selection drive collection compound posh element priorities examined slip stack hierarchy improves reaction time eliminating stack produced traversing plan hierarchy 
slip stack allows agent occasionally re traverse decision tree notice context change 
balance persistent reactive particularly urgent matters checked cycle drive collection 
slip stack allows hierarchy contain cycles oscillations 
stack obligation chain competences terminate 
fifth member drive element optional maximum frequency element visited 
convenience clarity retry limit competence steps controlled preconditions 
frequency real time system sets temporal limit frequently drive element may executed 
example mobile robot highest priority drive element check robot battery level execute minutes 
highest priority checking robot sensors happen times second 
lower priority processes remaining interspersed cycles see section 
non real time system frequency specified actual number cycles see section 
characteristic discriminates drive collections competences 
element competence expected operating time basic form slip stack 
current version holds bit context state described section 
drive collection multiple drives may effectively active simultaneously 
high priority drive takes attention action selection mechanism program state active lower drive preserved 
case robot navigation drive process selecting destination battery needs checked attention returns selection process exactly left battery drive finished 
remember action primitives system stand acts interfaces semi autonomous behaviors may operating parallel see chapter 
action move robot plan merely confirm transmit current target velocities active controllers 
moving robot need rolling executive attends batteries sensors 
example complete posh hierarchy section illustrates workings posh system example 
section show implementation system explains current enhanced version drive collection extended examples dissertation 
managing multiple conflicting goals tyrrell created extensive artificial life alife test bed action selection called simply se simulated environment 
tyrrell se postulates small rodent trying live plagued dangers passive active driven find shelter reproductive opportunities 
rodent limited sensing abilities seldom certain immediate environment 
see day standing hind legs increases visibility predators 
list goals tyrrell specifies agent se 
finding 
addition water forms nutrition satisfied varying degrees different types food 

escaping predators 
feline avian predators different perceptual motion capabilities 

avoiding hazards 
passive dangers environment include wandering herds cliffs poisonous food water temperature extremes darkness 
environment provides various forms shelter including trees grass den 

grooming 
grooming necessary homeostatic temperature control general health 

sleeping home 
animal blind night den provides shelter predators hazards helps animal maintain body temperature conserving energy 

reproduction 
animal male reproductive task reduced finding mates 
attempting mates hazardous 
problems vary axes homeostatic vs non homeostatic dependency external vs internal stimuli periodicity continual vs occasional expression degree urgency prescriptive regard particular actions 
addition problems environment highly dynamic 
food water quantities temperature light vary animals move 
sensing action uncertain 
perception particular extremely limited severely corrupted noise animal usually immediately chooses spend time expose looking uncovered area 
success rodent considered number times mates lifetime 
highly correlated life length long life guarantee reproductive opportunities 
life flee sniff predator mate sniff mate freeze see predator covered hawk hold run away see predator pick safe dir go fast look observe predator mate triangulate getting lost pick dir home go home late home court mate pursue pick dir mate go pick dir home go check look exploit day time sleep home home day time resource needed res avail exploit resource leave pick dir go sleep priorities beast contradictory goals tyrrell se 
plan demonstrated adequate environment significantly better action selection mechanisms tyrrell tested bryson 
am different notation plan order full hierarchy apparent 
vertical lines priority directly related height page usual 
indicates drive collection competence 
branch labeled name priority lists plan green green 
followed preconditions branch 
drive collection elements scheduling factor discrete time step alife system real time system scheduling cycles means element highest priority fired past cycles fire 
boxes indicate action patterns implementation control system structure hold primitives element long 
tyrrell focussed action selection environment provides primitives action perception roughly keeping track location relative den 
senses noisy animal get lost spends long away home time learn landmarks 
additional behaviors added choosing direction motion avoid hazards possible particular context exploiting benefits particular location ate opportune useful 
initially part control hierarchy proved sufficiently specific goals relating hunger thirst proved unnecessary complications 
difficult part decision process rodent determining attend predators sensed 
vague sensing attended animal gets done particularly mating multi step process dependent staying near roaming agent 
wrong sightings ignored animal gets eaten 
solution animal attempt escape fairly certain predator try increase certainty marginally certain 
relationship variables nonlinear separate pair kinds predators sort generation genetic algorithm set variables set variables randomly large number animals got life span took top performers ran lifespans see performed consistently best 
example having developer doing learning agent 
complete account development process agent see bryson 
exploiting slip stack hierarchy slip stack hierarchy exploited plan nested competences plan response time saved currently active competences priorities examined 
slip stack designed enable cyclic graphs posh hierarchies 
admit strictly necessary capacity 
alternate competences pilot study emulating rat navigation run robot simulator 
method creating oscillation gratuitous done drive hierarchy see chapter example 
believe reason competence cycles combination considerations sorts domains working deliberately shallow level control complexity 
example natural language domain complex control occurs redundant structures far done serious natural language applications 
alife simulations tyrrell allow complexity masked single primitive 
realistic simulation probably chained competences multiple sorts indications transitions behavior patterns agent partner 
main reason chained competences single master competence separate drive elements force ordering competences 
competences drive element executed time 
chains competences way analogous sequences production rules see section complex elements 
aps generally sequence actions take longer couple milliseconds action selection agent reactive 
actions long uncertain duration represented competences see section 
aps course sub components flexible brp ordering 
brp needs sequenced sequenced competence chaining 
inner workings posh action selection section begins pre history posh control 
describe simple implementation posh described experiments described chapter 
describe elaboration posh structure examples chapters 
section concludes summary early history caveats chapter argue record changes architecture important source information fundamental nature problem designing intelligent agents 
reason section includes documentation history architectures implementing posh design 
subsection critical understanding current posh systems 
implementations leading current version posh action selection 
common lisp object system clos second objectoriented perl ver 
third fourth clos 
called third edmund 
fourth simplified version sol described section 
language shifts partly motivated circumstances partly fact changing languages rewrites forces complete rewrite rethinking assumptions shift programming paradigms 
source code implementations described available line 
please see appendix strongly dislike strong typing slows development significantly inhibits creativity 
despite fact version perl buggy initial research platform mobile robot perl versions architecture programmed professionally years development behavior libraries slowed factor approximately switched 
fortunately difficult libraries constructed change translation relatively simple 
action pattern divided sub sections nil 
subsections triggering perceptual checks perceptual actions changed attention environment pre motor perceptual checks motor actions 
simplified single homogeneous sequence terminated element failed perception check action 
proved poor idea scheduling 
sequences broken parts trigger sequences elements checked atomically scheduler action patterns allow control cycle execution element 
obvious extension current system creation primitive class trigger actions kind actions occur triggers constrained operate quickly 
stated earlier dislike unnecessary typing left timing issues matter heuristics 
initially drive collections competences 
competence elements fixed priority 
value priority reduced element tried repeatedly allow strategies tried eventually allow entire competence fail 
introduced drive collections similar system recovery factor time drive element operated 
competence elements recover time competence invoked drive elements start original set priorities 
development edmund systems simplified 
habituation competence element discrete simply fire fixed number attempts 
scheduling drive collections terms frequency 
reason simplifications simpler design manage 
shifting priority order lead unnecessary complications situations 
variable motivation levels useful drive system tu grand easily modeled behavior system see chapter 
simple implementation posh control section documents pseudo code implementation drive collection described section 
final version third implementation posh mentioned previous section referred edmund bryson mcgonigle 
cycle action scheduler code executed 
de means drive element defined section 
drive elements priority sort elements drive root forever return called result nil de drive elements trigger de frequency de goal de return succeed primitive get fail succeed posh element execute time 
result execute de typeof result competence action pattern de slip stack replace alpha 
local copy control state see executable instance result result fail succeed de de restart root execute thing time triggers result nil triggered return fail executable instance posh composite type just instance disposable state keeping track things element executed action pattern times element executed competence element 
executing action pattern just result execute element instance counter instance counter result fail instance counter sequence length return result return continue competence looks drive collection simpler assume elements pre sorted ce elements trigger ce number tries ce goal ce return succeed typeof ce competence action pattern return ce return execute ce return fail triggered maximum cycle rate architecture gnu running linux primitive actions doing disk writes hz 
hand primitive takes time obviously slow arbitrarily 
robot example section sonar sensing done hz cycle rate hz 
operate robot plans shown chapter plans indicates robot heavy thinking sonar update task moved process 
posh control action scheduler experiences programming robots architecture documented section eventually motivated change way drive collections operate 
particular plan assumes competence element fail competence calls fails time 
architecture clearly isn true 
motivation behavior action patterns 
robot suspends rapid sonar check speech act action pattern continue left posh action selection simulate pseudo parallelism 
robot attention long activity impact restarting action pattern middle may irrelevant 
isn disastrous action pattern fails needed restarted 
evidence solution problem simply increasing fixed size slip stack allowing posh element persist fixed amount time action selection attention 
solution longer strictly guarantees maximum number compound elements checked 
psychologically models sort priming activation remains period decision 
device allowed implement form action selection ymir th risson 
see sections current version posh action selection retain ymir elements schedule bulletin board 
bulletin board form short term episodic memory action selection 
useful debugging discussed section 
ymir control cycle essentially phased 
cycle add needed schedule pass schedule executing pending execute deleting pending timed 
modified version posh takes advantage scheduler drive elements priority sort elements drive root forever return called result nil de drive elements trigger de frequency de goal de return succeed result execute schedule de result nil add schedule executable instance de result indicate happened result nil happens triggered return fail notice drive longer needs keep track current action maintained action scheduler 
hand competences action patterns need new bit state timeout indicate long kept schedule 
put action pattern schedule put schedule executable instance element iii iii action pattern length iii temp executable instance element iii add precondition temp succeeded element iii put schedule temp assume executable instance put schedule reads timeout action pattern computes time limit current time 
element fails elements sit cleaned time 
fire drive element may restarted root 
competence significantly different 
simply puts elements schedule invoked 
executed ce elements trigger ce number tries ce goal ce record succeed temp el executable instance ce add schedule temp el temp comp executable instance add precondition temp comp terminate element iii add schedule temp comp record fail triggered notice outcomes recorded bulletin board returned 
notice parent waits child terminate automatically go process 
child competence terminate parent cleaned 
case continue drive element needing restart 
disadvantage system execution nearly actions dependent searching short term memory bulletin board 
performance system highly dependent duration short term memory 
debugging short term memory set minutes production set seconds 
maximum cycle rate architecture mmx pii actions wrote disk hz bulletin board entries minutes runs hz trimming half second 
half second trimming checking bulletin board takes nearly lisp system time 
rates doubtless optimized 
example closely follow example ymir th risson bulletin board different sorts events 
drop bulletin board search time order magnitude 
speed hasn high priority issue am running real time multi agent simulations 
currently value building debugging tools reducing cycle time 
summary critical features posh action selection different implementations posh action selection section 
valid different strengths 
faster cleaner slightly biologically plausible handles debugging 
support bod process 
critical aspects posh supports brp limits stack growth allows cycles hierarchy supports pseudo parallelism changing attention higher priorities restarts plan hierarchy root terminates 
expedient solution design problem reactive planning categorize action selection categories things need checked regularly things need checked particular context things get checking 
categories correspond types posh plan elements drive collections competences action patterns 
chapter detailed description posh action selection including formal descriptions fundamental elements extended example control hierarchy implementation details design history 
chapter discuss relationship posh control architectures particular focus brp 
generally chapter demonstrates transfer technological advances agent architectures 
chapters address aspects bod modular behaviors specialized learning agent development process 
chapter architectural idioms posh action selection architectures order field advance key discoveries communicated field research community 
chapter demonstrated cross paradigm analysis procedure time consuming omitted architectures 
chapter propose meta methodological strategy problem incorporating advances new architectures established development efforts 
proposal simple researcher having developed new architecture express major contributions terms current standard architectures 
result process set differences rapidly understood absorbed established user communities 
chapter discussed general applicability principles bod methodology 
bod modularity rests object oriented design impediment fully applying bod particular architecture usually lack posh action selection 
chapter demonstration general meta methodology transmitting information architectures example implementing key fundamentals posh control 
specifically describe experiences implementing different architectures ymir th risson prs cl myers jam huber java extension um prs discuss hypothetical implementation soar chapter begins discussion extent exist architectures 
concludes discussion roles architecture methodology toolkit problem intelligent agent design 
chapter frequent architectures introduced described chapter 
brp reactive architectures operation brp central reactive planning expect expressible reactive architectures 
brp developed times varying levels independence fikes nilsson steiger gar bryson mcgonigle 
presumably nilsson inspired part previous fikes considerable lag developments 
personally aware fikes read shakey nilsson nilsson reactive plans nilsson action selection system shortly 
despite fact implementations considerable influence ai common attribute planning systems calling reactive chapter demonstrate feature surprisingly lacking architectures totally inexpressible 
effect architectures plan scripting languages prs georgeff lansky rap firby expect behavior sequenced advance reactive necessary dealing external interruptions switching plans 
hand architectures subsumption brooks ana maes expect little regularity arbitration behavior actions considered execution times 
architecture established research community works similar level reactiveness posh reactive architecture nilsson 
architectures idioms progress agent design argued chapter development production quality agents requires employment human designers high cost associated switching architectures project 
fact high cost making changes architecture 
engineers responsible building systems upgraded architecture require time learn new structures paradigms libraries existing solutions ported rewritten new version 
problems deter adoption new architectures 
exacerbated cost architect creating documentation maintaining production level architecture project manager evaluating new architectures 
new architectures hold important insights problems designing intelligence 
section discuss somewhat formally circumstances insights architecture transfered 
consider problem expressing feature architecture 
possible outcomes 
feature architecture may completely expressible leslie pack kaelbling saw similarity fikes triangle tables recommended read nilsson 
triangle tables essentially automatically expanded sequential plans 
effectively new shorter plan generated starts step initial sequence continues goal 
allows plan restarted juncture action fails accounts tables triangular shape 

assuming expression trivial line code constrains way 
hand expressed altering architecture extends 
conditions mutually exclusive architectures generally constrain extend multiple ways 
identifying points difference allows architecture described terms 
speak relative expressive power architectures am really comparing linguistic expressibility classical sense 
agent architectures turing complete universal computing machine constructed agent architecture 
universal computing machine implementation substrate agent architecture 
formal sense agent architectures inter reducible 
am concerned kinds computational idioms expressible particular architecture 
sense architecture may considered extend way express reasonably succinctly attributes 
hand feature translated coding reasonable efficiency coding idiom 
explained existence idiom means constrains 
notion constraint may counterintuitive new features architecture usually thought extensions 
argued extending capabilities developer means reducing expressibility architecture order biases search correct solution problem designing agent 
example constrained relative due feature adding idiom constrain 
retains full expressive power long mandatory 
example consider object oriented programming 
strictly object language smalltalk oop considerable constraint consequently lead effective elegant program design 
contrast added features objects allows full expression programmer elegance oop option requirement 
idiom compact regularized way expressing frequently useful set ideas functionality 
borrow notion idiom natural language computer science computer science term idiom design pattern rigorous mapping mean imply 
architecture expressed set idioms programming languages architectures 
researchers seeking demonstrate architecture contribution agent design express architecture terms idioms familiar architectures 
way architecture readily understood examined 
demonstrate approach sections 
important observe meta methodology different related computational complexity theory notion reducibility augmented asymptotic worst case complexity reduction 
example theory np completeness polynomial time reducibility plays crucial role 
notion expressibility rely criterion sharply defined computational complexity reduction computation intended evoke similar spectrum reduction complexity 
practice publishing extensions architectures 
discourage practice building entirely new architectures 
architecture built entity significant variation standard architectures potentially including vastly different emphases specializations particular tasks 
specializations may turn generally useful contributions critical particular set problems 
second idiomatic approach emphasizes search generally applicable strategies 
generality necessarily mean possible problems mean idiomatic solution relevant number different underlying architectures 
idiom developed context known architecture useful publication researcher describes terms general applicability 
identifying valuable idiom find useful architectural feature distinguish worth expressing idiom 
features distinguished methodology described section comparison reduction architecture 
features idioms expressed architectures 
idioms valuable architecture perform useful functions valuable community regular features existing architectures methodologies 
section illustrate process identification going history identification brp research 
give counter examples source 
introduced chapter described chapter structural elements bod posh reactive plans action patterns competences drive collections 
illustrate search valuable idioms consider reduction features context subsumption architecture sa brooks agent network architecture ana maes procedural reasoning system prs georgeff lansky soar newell 
deceptively simple action patterns required extensions original versions architectures prs 
sa sequence expressed single behavior part fsm 
described chapter need behavior sequencing discovered mechanism suppressing behavior developed connell 
ana explicitly represents links plans chains pre post conditions privileged activation particular plan elements 
sequencing strategy inadequate tyrrell improved derivative architectures rhodes blumberg 
soar initially represented sequences production chains 
mechanism insufficient real time applications 
problem addressed dedicated sequencing mechanism monitors durations laird rosenbloom 
prs hand reactive plan structure act allows coding sequences partial plans 
action pattern seen idiom act strong reason argue particular reduction power useful 
evidence history multiple architectures action pattern important feature 
easily imple mented idiom generally extends constrains architectures lack trivial way express 
parallel mechanism allowing attention shifts implementation feature ubiquitous reactive architectures see chapter 
sa assumes behaviors operate continuous parallel grasp attention 
ana similar behavior evaluated possible act 
prs addresses control reactivity cycle persists currently active plan engages metareasoning check different plan deserves top priority 
soar struck balance persistence reactivity 
production naturally distributed reactive similarly sa ana 
persistence encouraged new mechanism mentioned primarily clustering productions problem spaces 
problem space somewhat brp focuses attention subset possible productions 
architectures means monitoring environment switching attention introducing drive collections top mechanisms clear utility 
brp different matter despite examples planning literature mentioned earlier single feature architectures 
implement sa ana require extensions reason implementation sequences requires extensions 
intrinsic way favor order set expressed actions architecture manipulating environment 
prs soar hand contain sufficient ordering mechanisms implementing brp idiom tractable 
summary value idiom dependent things 
expressible trivially interesting set architectures useful 
utility may indicated experience existence similar features architectures 
respect brp architectures literature independently programming advantages sufficient lead implement architectures bod 
section documents efforts 
expressing architectures explained chapter brp sequence fundamental posh action selection 
previous section showed brp basic form candidate idiom providing architecture viable mechanism support simple sequencing 
section document implementation feature idiom number architectures 
section discuss best exploit new architectural features 
fact drive collections fact irrelevant point 
eliminated previous paragraph due function mechanism 
ymir effort generalize benefits posh action selection widely standard architecture relatively ymir th risson see bryson th risson 
ymir designed build complex agents capable engaging multi modal dialog 
typical ymir agent hear human conversant observe gestures 
agent speaks provides non verbal feedback animated character interface large number degrees freedom 
ymir reactive behavior architecture 
technical emphasis supporting interpretation responses human conversant number different levels time abstraction 
levels reactive layer process related back channel feedback low level functional analysis 
effective layer able operate millisecond constraints process control layer deals reconstruction dialogue structure monitoring process related behaviors user content layer choosing recognizing determining success content level dialogue goals 
ymir contains key feature action scheduler autonomously determines exact expression behaviors chosen various layers 
serves reduce cognitive load accelerate response rate ensure expressed behavior smooth coherent 
ymir excels handling complexity multimodality human conversations built capacity motivation long term planning 
ymir purely reactive forming sentences turn prompted human user 
ymir action scheduler implementation drives action patterns significantly different current implementation posh action selection see section 
scheduler relied clean behaviors triggered expressed timeout signaled allow lifetimes renewed 
detailed ultimate solution implementing context see section 
ymir lacked sequences bit implemented simply posting elements schedule unique tag precondition requiring predecessor complete began operating 
brp implemented ymir behavior object posted 
executed brp selects step section adds step scheduler 
brp adds scheduler termination child precondition 
original copy brp terminates cleaned scheduler 
child descendents maintain control length time new parent brp cleaned see section 
brp persists selecting plan elements terminates terminated decision process 
implementation posh action selection ymir clean feature apparently useful wound adopting features back posh implementation finishing ymir documented section 
prs cl implementation came project exploring reactive planning dialogue management 
relatively large scale project wellestablished architecture prs chosen reactive planning 
legacy code language project lisp 
consequently sri implementation prs prs cl myers 
prs cl provides implementation prs documentation set gui tools developing debugging prs cl agent systems 
tools useful creating debugging main plan elements act graphs 
acts roughly equivalent action patterns described significantly powerful allowing parallel alternative routes plan space cycles 
initially thought brp best expressed single act 
elegant way express inhibition lower priority elements act choice node 
implemented brp collection acts activated response brp name asserted goal 
results activation acts steps preconditions met 
prs cl built priority attribute selecting acts 
selection handled meta rules operate second half prs control cycle mentioned section 
created special function meta rule selects acts triggered cycle allowed persist 
function shown 
brp function built prs cl depends list priority lists priority list associated name brp 
somewhat unfortunate creates redundant information 
act graphs contain similar information implicitly 
replication leads bugs caused inconsistencies long term maintenance 
ideally priority lists edited maintained framework acts edited maintained consistency checked automatically 
fact prs cl associated tool set emphasize construction complex plan elements form acts provide relatively little support construction meta rules manipulation plans hierarchies reflect expectation switching attention plans unusual exception 
normal behavior execution elaborate act plans 
puts prs cl near opposite reactive planning spectrum architectures subsumption sa 
described chapter sa assumes unpredictability action scheduling norm predictably sequenced actions exception 
brp reflects moderation extremes 
brp expects handles unexpected provides specification solutions require multiple ordered steps 
defun brp list acts comp list consult db prs speaker competence prs current brp brp name comp list current priorities priorities name current brp loop priorities order terminate available fire indicated presence list acts priorities current priorities rest priorities result condition lisp loop true returns list containing result setf result brp find act priorities list acts list result priorities return random priorities list acts return set randomly list acts defun brp brp prioritization implemented function prs cl meta reasoning 
relative priority situation dependent brp function query database determine current competence context 
priorities maintained list act names associated brp name 
jam um prs entirely happy prs cl began exploring architectures dialogue project 
jam java extension um prs turn version prs developed prs cl control cycle languages similar 
jam um prs somewhat simplified analog act longer allows cycles powerful posh action patterns 
jam act analog called simply plan clarity refer jam plans 
jam plans notion priority built default select jam plans activated particular cycle 
current implementation jam consequently simplified version brp prs cl jam brp consists primarily set jam plans respond achieve goal name brp 
jam priority step brp specified hand coding priority values jam plans 
simpler prs cl solution described works reliably 
hand losing list structure results loss single edit point priorities particular competence 
creates exposure potential software bugs competence needs rescaled element priority omitted 
prs implementations lack elegance ymir bod solutions acts jam plans contain local intelligence plan contents information parent intelligence priority goal activation 
posh plans local information reused number different potentially different relative priorities 
ymir brp implementation allows brp sequence information wrapper objects plans 
added extra level complexity prs cl jam improvement possible principle 
find advantages working architectures sufficient compensate difficulties returned maintaining action selection system 
soar implemented brp soar completeness relation previous section include short description expected mechanism 
prs expect currently operable member element brp trigger response mutual goal 
achieved preconditions exploiting problem space mechanism 
soar procedure triggers results impasse solved meta level reasoning 
assume relatively simple add meta level reasoning system recognize highest priority element operable soar intended easily extendible adapt various reasoning systems 
operate correctly chunking 
avoid problem prs including priority information individual steps 
soar impasse mechanism set monitoring lack progress plans useful feature mentioned section 
posh competences retries limited setting habituation limits number times particular plan step fire single episode see section 
ymir supplies monitoring system addressed problem prs cl jam implementations 
architecture methodology tool 
agent architecture defined methodology agent constructed wooldridge jennings 
purpose discussion narrow definition closer common usage term 
discussion architecture piece software allows specification agent executable format 
moves definition architecture closer original definition agent language collection right primitives programming intelligent agent wooldridge jennings 
methodology set practices appropriate constructing agent 
tool gui software device creates code suitable architecture defined code may edited 
words output architecture agent output tool code agent 
methodology output governs architectures tools 
chapter emphasizes idioms communicate new concepts community regardless architecture 
natural language idiom recognized phrase meaning deduced meanings individual words 
idiom built directly architecture feature may analogous loss 
features may impossible express architecture brp fully autonomous behavior modules 
features implemented directly part architecture reduce flexibility 
feature implemented idiom overridden direct access underlying code problem conflicting idioms dealt project management level architectural revision 
accessibility different idioms may explain architectures sa ana despite wide interest established communities industrial users soar prs 
soar prs sufficiently general allow expression number methodologies 
said earlier generality necessarily desirable characteristic agent development approach 
dominant agent architectures lisp bias development practices proven useful accelerates development process 
believe gui toolkits useful ways communicate information 
essentially encoded methodologies output generalized variety architectures see wood 
toolkit assemblage tools chosen project manager 
tool seen supporting particular idiom related set idioms 
gui tool support brp need able parse files listing primitive functions existing sequential plans 
new brp created assembling items prioritized list preconditions 
assemblage named encoded stored new brp 
tool facilitate editing new primitive elements preconditions native architecture 
course idioms necessarily support require gui interfaces 
ymir action scheduler discussed section structure easily useful idiom number reactive architectures employed handling large numbers degrees freedom 
case tool stand module serves api agent body 
function simplify control smoothing output system cerebellum mammalian signals sent muscular system 
belongs architecture 
believe architectures contain structures extremely general utility 
program structures best expressed architectural attributes professional coding attribute assists efficiency produced agents 
follows discussion agent languages meyer 
examples general structures interpreter cycle prs production system rete algorithm soar 
structures brp implemented idioms tools developed facilitate correct generation idioms 
discourage development novel architectures 
architecture may useful level abstraction developing specialized ideas applications 
distributing inventions discoveries wider community tools idioms may useful device 
note specialist particular tool employed number projects different languages architectures learning overhead provided tool underlying idioms expressed languages architectures 
discussion chapter argued methodology main currency agent design 
novel architectures useful platforms developing methodology useful communicating advances community large 
features architecture distilled process reduction standard architectures 
allows discovery extensions idioms 
idioms particularly useful allow methodological advances absorbed established communities developers 
aim consider development tools efficiently composing idioms better time attempting bring architecture production quality 
ancillary point discussion reactivity section demonstrates process reduction way analyze describe differences architectures 
process analogous process embedding described see comparisons done chapter 
reductions chapter particularly rigorous 
doing precision illuminating particularly reductions fully implemented tested 
particularly valuable unification bdi architecture um prs jam soar large communities agent researchers little overlapping 
agent community search agent methodology analogous hopefully directed evolution search genome 
find strategy set sufficiently powerful expect explosion complexity utility agents 
searching need large variety novel innovations powerful methods recombination solutions 
chapter focussed means recombination 
definition idiom explained process determine brp important described experiences implementing brp architectures 
discussed issue publication top priority communicating advances engineering recommend distributing descriptions advance preferably different architectures languages paradigms toolkits adapted variety languages architectures particular architecture 
chapter modularity specialized learning chapter focussed organization behavior actions occur order motivations met circumstances 
argued best means address issues hand crafted reactive plans 
plans created human design automated planning social learning evolutionary search construction problems combinatorics complexity 
regardless representation chosen method construction plausibility generating useful reactive plans depends size space searched appropriate plan 
ways limit search space 
limit complexity full task specification 
building nut cracker require understand natural language instructed find open deliver nut just sized rock 
power simple approaches simple agents thoroughly explored reactive planning literature brooks flynn 
discussed length dissertation believe critically useful insight supported bod process 
way limit required complexity reactive plan increase power plan primitives 
essentially delegation course comes trade 
order easy possible create particular agent strike balance complexity building reactive plans complexity building plan primitives 
behavior oriented design helps ways 
making easy possible design powerful plans 
making easy possible design powerful primitives 
developing plans primitives simultaneously 
developing plans primitives encourages designer necessary tradeoffs apparent 
topic chapter 
chapters focus designing powerful primitives simply possible 
bod exploiting principles modular software engineering 
chapter explains roles modularity specialized learning bod agent 
propose decomposition possible roles adaptation intelligent control illustrate toy example 
chapter chapter goes detail type representation presents working systems examples 
blocks world assembly simulation second map building autonomous mobile robot 
behaviors fundamental capabilities bod agents constructed behavior library 
behaviors software modules expressing particular capacity agent terms actions needed execute capacity perceptual information needed inform actions variable state required support perception action 
behaviors normally encoded objects object oriented language java python common lisp object system clos 
independent processes software packages long simple interface built reactive planning system 
types interface action selection behaviors action primitives actions behaviors able express sense primitives perceptual state behaviors maintain 
perception built behaviors major functions bod agent 
directly behavior determine action expressed indirectly action selection determine aspect behavior expressed 
perception trigger action directly behavior provided interfere workings behavior see page 
posh action selection wait primitive returns 
allows primitive duration reflect duration act necessary feature action patterns see section 
duration pause action selection sets limit granularity reactiveness entire agent 
consequently act significant duration better action primitive simply prompts possibly engaged activity behavior 
complemented sense primitives allow posh system determine action finished finished 
examples approaches seen mobile robot controller shown section 
robot hits obstacle engages extended action pattern may take minute 
higher level drives checked items action pattern 
hand normal navigation action primitive move merely adjusts confirms target velocities 
forward motion behavior expressed continuously progress blocked action selection operates normally behavior expression 
learning chapter talks role specialized learning simplifying specification agent 
important understand engineering perspective distinctions learning forms adaptation somewhat arbitrary 
consequently mean term learning broader sense conventional 
learning denotes meaningful persistent change computational state 
meaningful mean affecting expressed behavior 
persistent mean lasting longer transition control states 
learning sense encompasses just lifetime learning semantic category acquisition persists lifetime agent 
includes transient knowledge acquisition short term memory perceptual processes 
time scale human action face face interaction scale time units system world levels sec theory months weeks social band days hours task minutes task rational band minutes task sec unit task conversation sec operations cognitive band turn ms deliberate act back channel ms neural circuit ms neuron biological band different time courses different behaviors involved dialogue 
conversations take seconds hours turns take seconds back channel feedback subliminal happens msec 
th risson categories newell 
example shows large number different time scales events happen memory required order respond appropriately 
shows different time scales constituent behaviors human conversation including gestures 
processing level requires information reason memory information persist significantly longer process attends 
reasons capacity limiting duration memories 
nature language processes certainly reflects evolutionary optimizations face capacity limits kirby 
section motivates bod highly specialized representations wide variety time durations 
intend clear learning significant part natural artificial intelligence 
sections discuss state learning bod 
relationship bod models natural artificial intelligence discussed greater length chapters respectively 
learning animals animals primary working example consider intelligence brooks mcgonigle 
autonomous agent research branches artificial intelligence acknowledged extent exploits solutions natural intelligence see example meyer dautenhahn nehaniv 
earlier century psychologists animal researchers concentrated laboratory experiments proposed animals learn general process able create associations 
general process assumption position learning capacity form associations general laws learning apply equally domains stimuli responses reinforcers frequent pairings elements associated stronger associative strength proximate members association pair learning 
gallistel learning association called conditioning appear general learning mechanism parameters hold species presumably indicating common underlying mechanism 
research eventually demonstrated animals learn associate arbitrary stimulus arbitrary response 
pigeons learn peck food learn peck avoid shock 
conversely learn flap wings avoid shock food 
related experiments rats bad water learned different cues badness depending consequences drinking 
drinking lead shocks learned visual auditory cues drinking lead poisoning learned taste smell cues garcia 
examples demonstrate highly specific constrained ecologically relevant learning mechanisms 
example content associations rats able biases learning information relevant poison indicated smell taste acute pain consequence seen heard 
results originally interpreted constraints placed general learning avoid dangerous associations research indicated inverse 
specialized systems exist form important associations roper 
example poison avoidance rats handled specific shot learning mechanism olfactory section 
current ethological hypothesis learning individual organism serves resort evolution roper gallistel 
introduced behavior fully predetermined competence involved requires flexibility evolutionary time scale 
learning necessarily associative 
barn owl learn calibrate acoustically precise location prey necessary dependent shape individual bird head bees learn sun navigation dependent season latitude 
rats learn navigation unfamiliar environments regardless presence explicit reward tolman tolman adams 
examples suggest animals may born limited units variable state instantiated development observing world 
variable instantiation take form perceptual learning categorization 
monkeys distinctive warning cries predators require different defensive action 
cries dedicated martial eagles 
baby cries early age general objects 
example may give eagle cry sky cry animal python cry stick ground 
born attending sorts stimuli need aware learn fine discrimination 
noted animal learning quite clean short admittedly biased review implies 
example evolutionary modeling research baldwin effect suggests little selective pressure genetically hard code things consistently universally learned individuals species hinton nowlan 
animal learning specialized individual elements necessarily constrained single purpose behavior 
single adaptive solution mechanism may leveraged multiple processes established 
dominance specialized learning theory ethology sufficient elicited description de waal popular science audience mind start tabula rasa checklist spaces allotted particular types incoming information 
de waal bod system spaces variable state heart behaviors 
reactive behavior modeling intelligence convincingly animal artificial agents typically produced reactive behavior approaches artificial intelligence blumberg tu sengers 
systematically supported exploitation multiple interacting forms specialized learning previous section suggests animals 
section reviews history reactive behavior approaches order explain 
reactive approach ai requires agent respond directly situation intervention detailed deliberation planning sensation action 
approach runs counter intuitive notions rationality intelligence proved effective problems ranging navigation robot tasks connell horswill playing video games agre chapman modeling human perception problem solving ballard 
behavior ai small relatively simple elements intelligence act parallel handling area expertise brooks matari 
theory simpler elements easier design evolved 
apparent complexity intelligent behavior arises sources interaction multiple units running parallel complexity environment units reacting 
central design problem behavior systems behavior arbitration determining parallel module controls physical behavior time 
problem design development 
difficult determine faulty behavior result behaviors operating simultaneously 
central problem reactive planning somewhat different 
called external markov assumption fully reactive planning expects action entirely determined external state 
unfortunately false recall monkey holding banana section 
intelligent agents find experiencing identical environments result different original initiatives require agent select different behaviors 
example offices laboratory robot operates may connected single hallway 
hallway essentially environment whichever office robot needs enter 
situations different may appear limited perception robot problem referred perceptual aliasing 
behavior systems necessarily reactive 
minsky intended planning complex representation parts elements society agencies 
reactive systems hand partly behavior 
decomposing intelligence large units decreases number actions selected 
reacting easier 
practice behavior systems tend reactive 
widely known example behavior ai strongly reactive confounded paradigms 
subsumption architecture brooks 
brooks specialized learning early brooks pp 
states claim need explicit representation world intentions system generate intelligent behaviors creature 
local level traditional ai representations 
tokens semantics attached 
variables need instantiation reasoning processes 
rules need selected pattern matching 
choices 
large extent world determines action creature 
brooks world best model mantra behavior ai 
view largely agree extreme quotation extreme interpreted 
problem behavior ai struggle minimize state early architects reactive systems brooks maes complicated learning control unnecessarily confounding flow information flow control 
bod divides issues control behavior expressed perception action expressed 
significant contributions dissertation integration behavior control systematic support developing specialized learning representations 
integration deceptively obvious perspective object oriented design significant advance stateof art behavior architectures 
state learning bod autonomous agent dynamic environment reactive possible 
learning applied programming control prohibitively complex 
example triggers discriminate set elements competence convoluted multiple dependencies multiple steps find dependencies easier reduce triggers statements new perceptual state 
general learning little possible 
particular obvious indication agent learn required perceptual information reliably 
bod thesis intelligent agents best developed specialized learning modules really restatement established result learning dependent bias kaelbling 
attempt maximize bias minimizing learning constraining necessary adaptive element individually 
learning performed reliably constraint needed 
notice additional information constraint may take form perceptual state control 
new perceptual state implies new behavior needed keep state continuously updated appear value available demand 
bod approach emphasizes separate flow control flow data continuous flow data eliminated 
remember page shows behaviors autonomous units action selection filter expressed acts 
reactive hierarchical control architecture developed conjunction behaviors triggers 
new perceptual requirements driven action selection turn motivate new state learning requires new behavior modules 
types state learning knowledge expressed different types state divide categories control state state form currently active behavior behaviors paths activation follow 
control state analogous program counter records immediate past terms action selection determines combination sensory information agent act 
conventional ai systems hold control state plan program pointer determines step 
plan behavior architectures brooks hold similar state finite state machines fsms information distributed behaviors 
deictic variables simple pointer variables refer particular object agent currently attending 
deictic variables allow system generalize cases particular plans embodied control state may operate 
example ethology classic lorenz gosling follow learn mother shaped thing sees possibly baby buggy critical period hatching 
reaching male goose try mate similar objects 
considerable evidence humans similar strategies ballard horowitz wolfe 
rhodes shown deictic representation significantly extends purely reactive architectures 
perceptual motor memory specialized systems representations information accumulate 
perceptual memory may fraction second lifetime agent 
perception requires memory little information available snapshot sensory information 
motor control may require memory fine tuning specified advance 
meta state state internal state learning learn 
distinction learning learning learn may obscure supported biological research 
example demonstrates maze learning ability intact mice lost hippocampal learning provided prior experience learning mazes 
researchers suggested ability critical developing human intelligence elman 
choosing representations bod decomposition state roughly analogous decomposition control state section 
case favoring simplicity favoring reactive representation 
intelligence reactive relies simpler representations 
control state simplest element typology 
necessarily reactive reactive systems element control state reactive constant sensory monitoring determine branches state 
control state represent world indirectly 
deal environment 
consequently information environment deduced control structure 
deictic variables set represent particular object aspect environment 
restrict attention control manageable 
control structures replicated 
replication control state cumbersome unreliable terms evolving system multiple instantiations may need updating 
consumes program space programmer time 
excessive control state may indicate need perceptual memory 
determining appropriate context behavior require control steps system complicated slow 
situation indicates sensory information determining context consolidated representation 
representations updated processes parallel control structure interface control system reduced single sensory check 
determining need adaptive state motor control similar 
perceptual state serves basis behavior decomposition bod see section 
state needed motor control may stored behaviors 
experiments described dissertation strategy examples ai literature learned control bod agent 
examples include learned passing kicking behaviors stone veloso soccer playing agents schaal atkeson learned arm control models learned video agents baumberg hogg brand 
related includes fuzzy behaviors robot konolige myers vector maps 
discussed including self contained algorithms bod agent see section 
chapter describe integrating bod architecture ymir th risson special behavior micro managing motor control 
meta state necessary agent learn experience alter processes 
smith proposes knowledge central human development 
example ability learn skill unit rote decompose components reuse different strategy 
norman shallice argue deliberation way bring increased attention bear routine processes increasing precision reliability 
bod really support meta state modeled essentially perceptual state 
main purpose bod replace long frequently arcane process development organism long hopefully orderly process development engineer 
emphasis simple heuristic determining meta learning necessary preferable new phase human design 
possible extensions bod support meta learning discussed briefly section extensively chapter 
trading control learning demonstrate differences representational styles think insect robot bump sensors way sensing environment 
insect robot long range sensors eyes needs find way box 
control state plan notation chapter words bits control state primitive actions bold face 
assume walk primitives take time say seconds move insect couple centimeters diagram 
assume turning traces arc happening place way legged robots 
probably simplest program written entirely control state 
left hit avoid obstacle left walk right hit avoid obstacle right walk straight avoid obstacle left walk backwards walk right walk left avoid obstacle right walk backwards walk left walk right deictic state willing include behavior just bit variable state simplify control state program 
avoid hit hit compensate avoid deictic avoid hit left 
info behavior bit hit left 
serves deictic variable side just hit 
avoid hit compensate avoid turn appropriate direction accessing variable 
allows reduction redundancy plan including elimination action patterns 
walk hit avoid obstacle walk straight avoid obstacle walk backwards avoid hit compensate avoid specialized deictic state simple complicated representation say allocentric representation obstacle relative bug updated automatically bug moves forgotten bug moves away location impact 
strategy requires state updated continuously bug moves walking method find way behavior 
back find way store obstacle specialized avoid local map info walk hit react bump find way react bump store obstacle walk backwards really navigation ability bug vast increase complexity behavior justify savings control state 
hand bug kind allocentric representation sensible piggyback information top 
example bug vector created multi faceted eye representing approximate distance visible obstacles bumped hard see window parsimonious store bump information vision vector providing updating information bug motion isn trouble 
insects able hartmann wehner robots come primitive odometric senses easy providing precision important 
fact model bump detection extended real robot model described section 
state meta learning bug control look representation suitable meta reasoning 
honestly sufficiently different control specialized robot worth drawing 
primary difference representation wouldn kind simple allocentric map universal representation logic predicates homogeneous neural representation 
allow operators act knowledge bug happens store 
problem universal representations roughly problem production rules see section 
order information useful tagged great deal information context 
strategy demonstrated feasible newell georgeff lansky loses advantages modularity 
programmer loses localization related state program code machine learning algorithm loses specialized biased representation 
data stored neural network problems apply 
developing modularity neural networks open question wermter 
essentially universal representations problems combinatorics 
bod addresses combinatorics modularity hierarchy 
chapter discussed fundamental role behaviors state learning bod system 
shown state appear variety forms facilitating highly specialized learning variety degrees persistence kinds representation 
chapter illustrates uses types state identified related literature working examples implemented bod 
chapter learning design chapter introduced explained modularity specialized learning behavior oriented design 
decomposed variable state agents categories control state deictic representations perceptual motor learning meta reasoning 
chapter explores depth extended examples deictic perceptual learning particular 
control state myths artificial intelligence early experimenters reactive planning advocated stateless systems 
fact fundamental units subsumption architecture brooks augmented finite state machines 
moment behavior records particular state execution state helps determine behavior 
reactive behaviors respond directly continually factors environment 
example vehicles braitenberg motor speed directly correlates light heat intensity 
polly vision algorithm determines speed direction apparent distance obstacles individual visual frame 
horswill 
simple behaviors may require kind stored internal state sequential control 
example insect robots built subsumption architecture back turn away obstacles detected bumping antennae environmental state robot reacts detected antenna bent behavior determined state period backing antenna disengaged 
variety solutions problem described section previous chapter section varying combinations control deictic perceptual meta state 
best known just tried lift front leg obstacle angle brooks 
problem holds 
conventional ai system initial collision resulted persistent internal representation collision point assumed obstacle registration knowledge resulted planner selecting new behavior exploring obstacle new trajectory 
fully reactive agent collision registered temporarily control state 
behavior forced different state results different expressed actions agent 
normal behavior resumed event forgotten 
information may appear wasteful practice information difficult record accurately transient 
superiority reactive approach local navigation shown empirically maes bonasso 
significant criticism approach exchanges complexity adequately representing environment complexity designing agent control 
chapter documents ai developers largely moved away systems rely purely control state 
deictic representation problems traditional representation number items system needs represent represents complete world model 
solution problem gaining acceptance deictic variables see ballard horswill 
deictic variable permanent memory structure changeable external incorporated plans 
example representing blocks world problem conventionally require individually labeling block 
deictic variables provide restricted set labels block holding green block saw 
deictic variables popularized agre chapman agre chapman chapman write reactive system successfully plays computer games 
ideas deictic variables minsky minsky visual attention ullman apparently philosophical heidegger dreyfus 
whitehead uses deictic variables simplify reinforcement learning 
horswill uses combination live visual image produce system answers prolog queries green block red block scene representation visual signal 
benefits deictic representations bring reactive architectures similar brings traditional representations possibly substantial 
common criticisms reactive planning transfers complexity data representation control complexity 
reduction complexity brought deictic variables reactive system terms amount data size control architecture number behaviors number reactive plans horswill rhodes 
examples deictic representation deictic representation requires things 
requires state allocated variable 
necessarily added code 
real robot variable may hand camera centered vision system tracking fixated 
real robot deictic variable state may situated external world place right front robot robot mechanism ram may refer state peripheral system visual routine processor 
second thing deictic representation requires primitives setting sampling variable 
examples whitehead 
whitehead worked simulated blocks world attempted simulated robot arm learn pick green block stack 
whitehead time experiments leading pieces leading machine learning algorithms reinforcement learning rl 
access beta version advanced vision system visual routine processor vrp horswill performed sensing primitives assumed whitehead thesis 
system connected vrp observing lego blocks unfortunately functioning robot hand 
results section primarily simple blocks world simulator wrote interim solution 
code follows bold face represents names program structures 
primitive action whitehead mapped primitive actions vrp 
grab green grab green produces behavior produced whitehead dissertation 
looks stands false grab green action frame color green action frame hand goal object hand lose block attn frame color green frames vertically aligned move action frame green attn frame color green grasp stack top green scene move attn frame green grasp stack top lose block move action frame stack top grasp object action frame move action frame table action frame place object action frame obviously elaboration brp explained detail chapter original code 
original code competence contains longer sequences whitehead originally attention markers deictic variables visual system hypothesized ullman 
ullman believed visual system limited number markers countable determining independent objects person track usually 
whitehead constrained marker purely visual attention governs action hand 
constraining types primitives applied marker reduced size search space rl algorithm severely tasked order primitives appropriately 
markers moved attractive pop attributes color compared moved relative 
markers follow object attending 
example plan attention frame block grasped moves robot hand 
notice program effectively uses hand third deictic variable external mind requires variables directed order analyze 
program works succeeded grasping green block initial block configuration long green block terminated green block 
green green program illustrates simple brp hierarchy 
early dissertation whitehead said goal pile red block green block problem demonstrated revisited 
logical test action selection system 
implemented grabbing green blocks started green green 
preconditions plan long fit single line 
guard means continued line 
astute programming competences 
fact debugging code concept competence developing plan 
consequently redundant checks example hand grasping fact separate steps grasping top block stack depending green 
green green attn frame home attn frame shape block attn frame color green action trace attn action frame shape block action frame color green frames goal object hand attn frame home attn frame color green place green green object hand attn frame home attn frame table place green object hand attn frame home attn frame shape table look away grab green object hand attn frame home attn frame shape block attn frame color green look away grab green attn frame home move attn frame home object hand attn frame home attn frame shape block clear home object hand lose block information brp notation represents 
element labeled name easier see element 
elements equivalent priority 
list elements names elements shared priority line 
notice elements order simply representation different information 
green green goal place green green place green check home get green get green clear home lose block plan green block green block goal reached 
holding green block places green block exists goal location 
agent grasping green block check status home get green block 
wrong block goal location pick block 
holding block green point drops block 
plan requires sub elements grab green action frame color green action frame hand goal object hand lose block attn frame color green attn frame home move action frame green attn frame color green grasp stack top attn frame color green frames vertically aligned move action frame green green scene move attn frame green grab green goal lose block veto green green synch green find green additional element plan attention frame popped block home pile looks 
necessary stochastic nature low level visual routines way constrain search forcing home tower different visual field source piles robot 
place green green move attn frame hand move action frame attn move attn frame home action frame color green action frame hand move action frame attn action trace attn place object action frame place green move attn frame hand move action frame attn move attn frame home action frame hand action frame color green attn frame table move action frame attn place object action frame clear home move action frame attn move action frame stack top frames vertically aligned grasp object action frame coding plan things evident 
managing attention variables important 
easy build plans iterated rules simply shifted visual attention check home look 
emphasizes utility sequences 
visual pointers moved established context left canonical locations 
notice added primitive look away simply ensured markers focussed blocks second stacking takes state simple grab green 
external deictic variable added home place critical pile 
state block stack home location indicates task robot pick green block red block stack complete 
may explain whitehead returned task reinforcement learning system challenged number free variables original task 
ballard cite whitehead difficulties possible explanation small number visual markers pieces free visual state humans evolved 
addition stack location visual markers mechanism subgoal fourth marker necessary 
order gauge state stack marker check contents 
marker detects stack contains encountered difficulty domain rest domains conventionally reactive animal problems 
problem getting caught loop frequent children trying master complex procedures seen chimpanzees 
am certain characterizes sorts problems generate loops unnatural regularity perceptual stimuli blocks discrete nature possible acts 
green block trigger competence grasp green block uses visual markers 
separate competence marker needed regular comparisons top home stack 
demonstrates interchange control state deictic state considerable combinatorial ramifications 
copy demo copy demo famous early experiment robotics conducted mit horn winston chapman 
principle simple robot sees stack blocks try replicate stack 
code task slightly simpler green green discounts replications account colors 
extra complexity tracing stacks compensated having represent goal entirely control structure 
competence simulation mechanism time fully debugged original replication demo took hours write debug 
copy demo frames horizontally aligned attn frame goal action frame home attn frame color action frame color goal frames horizontally aligned frames color attn frame goal action frame home check goal frames horizontally aligned attn frame color red action frame color look away grab red frames horizontally aligned attn frame color blue action frame color look away grab blue frames horizontally aligned attn frame color green action frame color look away grab green object hand lose block object hand attn frame home attn frame shape block clear home start priorities copy demo goal check goal add blue add red add green place block lose block clean home start stack replicated check goal done get appropriately colored block holding case drop need clear goal stack previously error worst case reset visual pointers reasonable place start action 
requires couple sequences check goal move action frame attn action trace attn move attn frame action move action frame home synch start move attn frame goal move action frame home copy demo task required special place goal stack 
requires grab color lose block small new competence horizontally synchronizing visual markers 
sync action frames horizontally aligned attn frame goal action frame home goal action frame color attn frame goal move action frame home frames horizontally aligned action frame home attn frame goal move action frame sync action redundant response bugs beta vrp 
main purpose simply move action frame level attention frame 
replications color consequence staying faithful possible original constraints whitehead project additional state requirements clear 
replaced single extra deictic variable color 
example consequently shows clearly way internal external control state trade compensate 
plans longest action patterns sequences built 
constraints project building natural operators impossible nature constraints situations extremely perceptually ambiguous 
bod normally behaviors supporting primitives powerful simplify control 
programs illustrate clearly perceptual ambiguity block color compensated control state 
perceptual state perception psychological abstraction level processed sensory information cognition 
abstraction clearest humans perceive remember report 
open illusion distortion 
sense environment light sound 
perception driven expectation dependent learning context carlson 
learn discriminate differences having explicit knowledge differences 
cases learning requires feedback simply exposure appropriate stimulus 
perception similar contribution reducing plan complexity deictic representation 
reduction collapsing similar plans substantially increasing power information content plan elements 
arguably main contribution reactive behavior ai change basis action selection intelligent agent 
plans relying complex internal models world replaced distributed actions relying directly fast cleverly specialized perceptual routines 
perceptual state definitionally reduces reactivity relies old information 
plays important role structured control state preserves information experienced disambiguate control decisions 
edmund examples perception specialized learning robot problems perception intuitively obvious agent working physical sensors animals 
examples taken bod system control mobile robot shown 
conducted laboratory cognitive neuroscience intelligent systems university edinburgh 
example deals determining multiple inaccurate sensors robot best proceed forward 
conducted previously reported bryson mcgonigle bryson 
second deals combining multiple strategies learning navigating complex space 
conducted previously reported 
robot robot shown commercially available nomad 
robot different drive velocities control speed direction rotation sensing turret 
sensing turret faces sonar located top meter ground infrared sensor near bottom quarter meter ground 
turret wheel base surrounded bump sensors staggered rings sensors 
infrared sensors useful cm cm away robot sonar sensor useful distances greater cm 
sorts sensors difficulties 
infrared works bouncing light gives stronger readings look nearer light reflective objects 
sonars bouncing sound may fooled number factors including refraction away robot prior reflection sensor reflection different sensor emitted initial signal 
sonar readings erratic infrared readings systematically distorted 
sensor necessarily provides coverage entire height facet robot 
bump sensors relatively accurate require hitting obstacle hard register fairly strong rubber bumper 
point robot usually thoroughly engaged obstacle bumper effectively needs move directly opposite impact extract 
robot odometric sensors nomad robot running laboratory university edinburgh 
picture just encountered desk surface low sonar sensors detect proximate leg dark infra red sensors robot learn desk bumpers 
determine far direction moved inaccurate great distance slippage robot tends slowly rotate rate degrees meters 
example modular learning perception plan reactive plan controlling robot moves forward 
uses representation plan real time agent scheduling hertz 
section concentrating primitives sense competence continue action pattern walk competence 
briefly introduce plan 
aspects bump action pattern representation underlying compound sense move bears strong resemblance simpler plan 
talk provides information battery level charge level fallen increment time talk called life talk hz worth talking sense hz walk speak bump bumped look compound sense halt direction move view blocked start direction wait sleep reg bump back clear bump lose direction lose direction pick open dir continue move narrow move view clear correct dir plan just keeping nomad moving crowded environment 

wait trigger debugging purposes called number times 
having lowest priority drive announces case saying robot speech card keeps program running debugger check internal state 
element drive collection triggers brp drive collection simply terminates 
behaviors support sense continue shown 
bold face indicates primitives occur posh action selection scripts 
main behaviors direction determines speed orientation motion sense represents robot best estimate free space 
sense state simple vector integer values face representing inches obstacle direction 
time compound sense called roughly times second representation updated 
sense combines information robot sensor systems essentially shortest value 
exception infra red reading maximum value inches 
infrared readings greater inches ignored 
sonar readings accurate greater distance inaccurate inches 
sonar situated top robot infra red near base systems report different obstacles occur different heights 
sonar susceptible number confounding effects readings grossly inaccurate 
simple fairly robust solution employed robot believe reading changes radically persists half second 
sensing occurs hz requires event perceptual memory 
represented direction current correct dir lose dir move move view 
action preferred narrow dir pick open dir selection directions move move view 
direction direction reg bump sense ring mask compound sense bumped memory sense bump fuse bump sonar history sonar expect sensor ring vector bumps sonar infra red bumpers bump fuse bump robot behaviors involved moving forward 
notation section 
see text explanation 
processed memory 
bumps difficult problem 
described section touch sensors necessarily require storing state obstacle successfully navigated 
reasons described just section take minutes 
behavior bump retains records impacted obstacles robot moved feet away fixed time 
calculates original location bump bumper number robot radius face distance appropriately represent object location 
course bumps necessarily points obstacles robot tendency move distance known obstruction generally clears full obstacle 
may represented multiple impacts 
robot libraries written took advantage concepts class instance variable state 
number bump instances representing actual impacts bump keeps track 
similarly direction face robot 
direction behaviors include state representing mask applied sense vector direction controlling behavior 
velocity determined distance nearest obstacle obstacles sides direction motion discounted rear ignored 
similar discounts apply steering corrections obstacles 
direction keeps track current intended direction motion actual direction 
actual direction may changed move order avoid obstacle 
view clear correct dir gradually transfers current direction back preferred 
example episodic memory navigation dp map untried near neighbor untried far neighbor 
action landmarks pick near neighbor pick neighbor selection add neighbor dp entered dp dp land continue untried dir keep going dir odometry done memory directions times direction time robot sense behaviors supporting plan informed navigation 
plan allows robot fully autonomous control standpoint easy herd room practice 
ambition robot able learn tours laboratory simple demonstrations instructions 
achieved goal relatively small tours scaling long term navigation entire multi room laboratory space required perceptual routines recognizing locations orientation 
location recognition proved straight forward sonar signatures completed due lack development time 
section shows additions changes wandering agent architecture allowed robot learn follow short route 
behaviors developed small tour version shown 
bod standpoint behaviors compositionally 
state changes slowly persists longer adaptations coincide better conventional definition learning 
robot learns map lifetime agent short term episodic recall help select appropriate direction 
new behavior dp land recognizing decision points locations clearly directions forward back robot move 
plan shows robot loses direction time finds longer move approximately currently intended direction enters new decision point 
robot direction attempts remember direction previously worked nearby location 
hasn walk halt direction move view blocked route pick direction start direction lose direction enter dp dp entered dp leave dp dp entered dp look untried near neighbor keep going continue untried desperate look untried far neighbor ask directions lose direction greet dp dismiss dp pick near neighbor pick previous direction pick neighbor continue move narrow move view clear correct dir changes walk competence informed navigation 
see section comments slip stack operation competence 
tried moving direction failed direction chosen 
robot clear record stopped may halted sonar transient problem may try continuing current direction 
may try afield neighbor 
pick direction competence fails robot asks instruction 
time robot selects direction records direction current approximate location current time memory episodic memory 
trimmed fixed number events greater number tries robot attempt scenario asking directions 
decision instruction successful persists inches motion stored long term memory located behavior dp map 
learning robot experiments argued bryson robots rated experimental platform particularly relative generally accessible complex platforms virtual reality standardized simulations 
impossible deny power engaging demonstrations intuition pumps dennett 
key insights dissertation working robot 
perceptual learning behavior decomposition robot examples illustrate different motivations behavior decomposition element memory may distinct 
original signal different light vs sound vs impact 
memory needs record events occur different rates 
old memories needs decay forgotten different rates 
patterns memory emerge different rates 
different representations simplest minimal 
posh architecture perl came fully equate persistent variable state perception representation 
suggested different rates adaptation key behavior decomposition years earlier bryson importance fully organizing behavior library lines intimate relationship learning perception struck reimplementing robot sensor fusion 
substantial difference bod perspective transient perceptual state lifetime learning 
term learning arbitrarily applied continuum involving frequently extent state changes time 
maintaining action selection context plan strictly stack version posh slip stack documented section 
version posh running nomad plan 
fact route pick direction competences wrapped inside dp map behavior 
pick direction example expressed perceptual primitive reported successfully viable stored direction dummy action formally picked selected direction 
intuition fact competence able quickly fail elements fire element parent competence fire 
year mechanism action scheduler ymir th risson inspired current implementation posh action selection described section 
leading insight described section 
meta state learning learn final form state state state 
context reactive hierarchical control architecture modularized behavior meta state reduced forms state control state state perceptual memory 
stated earlier bod gives special support form learning 
development falls outside dissertation focuses engineering autonomous approaches development 
fairly obvious area research 
chapter demonstrate modeling process learning control structures similar brp 
section chapter discuss possible extensions capable meta learning 
social cultural learning closely related specialized learning approach 
bod bias enables learning derives engineering social learning derives behavioral facilitate absorbing products cultural evolution 
bod substitute genetic evolution obvious goal autonomous agents able absorb mimetic evolution directly surrounding culture humans animals whiten de waal 
control state divided elements structure indicates flow activation activation 
great deal done varying way activation levels spread behaviors 
particular ethological literature describes modules competing attention evaluating activation level inspired architectures precisely maes steiger gar blumberg cooper 
blumberg achieved probably coherent behavior genre combining strategy resource intelligent constraints mutual inhibition competing behaviors 
blumberg provides mechanism flow control order implement conditioning 
typology strategy meta learning conditioning implemented perceptual level 
unfortunately strategies extremely difficult control hand machine learning tyrrell 
general learning successful constrained spaces behaviors 
developing bod experimented flexible priorities eventually replaced structures scheduling drive collections fixed retry limits competence elements 
easier control simulation continuous valued internal drive levels lorenz tu perceptual state 
section demonstrate model 
actual structure action sequences competences posh control originally designed support form meta learning 
hoped evolutionary programming style processes find new control sequences 
see similar theory calvin 
easy problems approach generate new thoughts test store winning solution 
hard problems tell new plan needed recognize solution wins 
problems case learning community researching time see example hammond ram 
consider due size search space strategy practical useful complex agents 
consider social learning wm compare page 
system capable learning behaviors represent common substrate allow modified 
behaviors represented special long term memory plastic working memory wm modified 
consolidation dashed lines modifications may alter original behaviors create new ones 
productive area research 
areas meta level learning interesting productive explore include implementing norman shallice notion deliberate action 
norman shallice theory holds deliberate control triggered special circumstances 
deliberation monitors modifies routine processes possibly slowing providing additional sensory information 
possibly related area consolidation episodic memory usable skills see smith wilson mcnaughton 
meta learning distributed representations behavior oriented design requires complex algorithms specialized representations 
argued agent behavior best developed object oriented languages 
representation may limit autonomous learning new behaviors 
learning new skill modules clearly desirable focus significant research see demiris hayes example review 
date efforts lines qualify specialized learning single representation system skill module behavior perspective bod 
represent behaviors homogeneous distributed substrate artificial neural networks ann easily able produce sort learning 
consider 
representation skill modules split functional modules behavior long term memory working memory wm 
working memory allows rapid short term changes perceptual memory representation behaviors 
provides relatively stable source modules appear activated 
skill representations modified due particular circumstances compensating high wind responding novel situation chopsticks slippery rice time 
model adjustments plastic short term memory affect long term memory 
sort dual multi rate learning receiving deal attention ann currently see french mcclelland 
depending long term experience consolidation possible effects 
imagine modified working memory order provide appropriate expression 
modifications prove useful near consolidation protracted period effect permanent representation 
modifications applicable new behavior established 
process trigger perceptual learning behaviors discriminate appropriate context purpose action selection 
free specialize away 
unfortunately practical constraints model similar described just evolving control structures 
ann research supporting modularity infancy wermter 
difficult predict strategy practical sooner 
summary designing learning summary developing complex intelligent behavior requires modularized behavior modularized learning 
agent programs constrain specialize learning task possible 
control state records static knowledge procedure dynamic decisions current approach 
deictic variables simplify control state providing point procedures generalized contexts 
perceptual motor memory allows control determined factors appear time immediate environment 
meta state allows agent learn change behavior 
bod little difference meta state perceptual learning 
designed supported exactly way 
see extended example chapter 
chapter behavior oriented design chapters described elements bod agent architecture detail 
discussed trade offs need build simplest agent possible 
simpler agent successful 
means limiting possible developer search correct code maintenance bugs agent search correct solution activity learn plan 
bod methodology introduced chapter chapter formally 
describe essential procedures initial process specifying decomposing agents goals bod architecture representations ongoing iterative process building maintaining complex agent 
discuss practical aspects bod development documentation tool 
briefly discuss approach relates high level approaches 
chapter provide detailed example bod development process 
basic bod development process initial decomposition initial decomposition set steps 
executing correctly critical main development strategy includes correcting assumptions stage process 
stage greatly facilitates rest process 
steps initial decomposition 
specify high level agent intended 

describe activities terms sequences actions 
sequences basis initial reactive plans 

identify initial list sensory action primitives previous list actions 

identify state necessary enable described primitives drives 
cluster related state elements primitives specifications behaviors 
basis behavior library 

identify prioritize goals drives agent may need attend 
describes initial roots posh action selection hierarchy 

select behavior implement 
sections contain extended examples process 
lists compiled process kept important part documentation agent 
documenting bod agents done primarily organized source code covered section 
selecting behavior idea choose simple low level priority continuously active agent doesn die immediately 
example mobile robot section bottom priority main drive hierarchy wait function keeps track time seconds 
sort behavior gives developer clear indication robot control crashed interesting behaviors currently trigger 
depending project may sense start competence worrying drive collection 
examples projects started blocksworld experiments section transitive inference experiments chapter 
projects required building simulation truly basic behaviors needed tested built conjunction debugging new implementation posh control emphasized cognitive capacity expressed isolation balancing conflicting goals period time 
iterative development heart bod methodology iterative development process 
select part specification implement 

extend agent implementation code behaviors reactive plans test debug code 

revise current specification 
bod iterative development cycle thought sort hand version em expectation maximization algorithm dempster 
step elaborate current model second revise model find new optimum representation 
course regardless optimizing process agent continue grow complexity 
growth carefully monitored guided pruned resulting agent elegant easier maintain easier adapt 
behaviors simply coded directly standard object oriented language reactive plans generally stored script files 
plan normally read agent initialized comes life theory new plans added execution 
reactive plans agent grow complexity course development 
frequently multiple reactive plans developed single ai platform set behavior modules creating agents different characteristics goals personality 
radically different plan scripts platform domain generally behavior library set code 
course agent instance instances behavior objects running may potentially save run time state persistent object storage 
worth making effort support scripts single library behavior code 
testing done frequently possible 
languages require compiling strong typing lisp perl significantly speeds development process may slow program execution time 
optimize modern software engineering applies programming languages 
experience time spent developing ai agent generally far outweighs time spent watching agent run 
particularly interactive real time agents robots vr characters bottle caused motor constraints speech recognition intelligent control architecture 
making revising specifications interesting part bod methodology set rules revising specifications 
general main design principle bod doubt favor simplicity 
primitive preferred action sequence sequence competence 
similarly control state preferred learned state specialized learning general purpose learning planning 
bias heuristics indicate simple element broken complex 
guiding principle software engineering reduce redundancy 
particular plan behavior reused 
ood part plan primitive action change decomposition called 
case action primitive primitive decomposed primitives original action replaced plan element 
new plan element name functionality original action 
allows established plans continue operating minimal change 
sequence needs contain cycle need elements fire really competence action pattern 
competence deterministic nearly executes fixed path elements simplified sequence 
heart bod strategy rapid prototyping 
approach trouble giving debugging problems try 
important remember programmer experience key selective pressures bod keeping agent simple 
bod provides paths simplicity clarity modularity hierarchical reactive plans 
cyclic development trial error programmer determine path best particular problem parnas clements boehm 
modularity maintainability key bod programmers encouraged change architecture agent find better solution 
changes easy 
transparent easy follow understand team member encounters 
competences significant feature competence forms reactive planning relatively easy engineer 
build competence developer imagines worstcase scenario solving particular goal 
priorities steps set inverse order steps executed 
preconditions set starting highest priority step determine fire 
step preconditions simplified assurance agent context current competence higher priority step fire 
competences really basic level operation reactive plans learning write debug may take time 
indications provided competences specification agent needs redesigned complex triggers reactive plan elements require long complex triggers 
perception handled behavior level skill 
large number triggers may indicate requirement new behavior new method existing behavior appropriately categorize context firing competence elements 
new behavior simply new method called determined state needed categorization new state generally implies new behavior 
elements competences usually need elements may contain fewer 
competences get cluttered triggers complicated really different solutions problem 
case competence split 
paths lead way goal competence really siblings discriminated level current competence parent 
dual pathway part competence competence contain children 
effectively step competence highest priority subgoal 
way achieve subgoal trying express competence split attention resources lead dithering trigger flipping plan elements serve activate precondition 
purpose competence focus attention solution time 
nilsson emphasizes formally reactive action expected achieve condition prerequisite higher plan step 
defines regression property holds plan element true 
defines completeness brp true conjunction brp plan steps releasers tautology 
bod considers chaining competences reasonable design pattern necessarily recommend regression property 
bod emphasizes relying posh control hierarchy specialize particular plan circumstances strongly recommend maintaining completeness plans 
concepts useful keep mind particularly debugging 
complex trigger heuristic brings back question trading control complexity behavior state discussed chapters particularly section 
reiterate fairly easy tell deictic representation useful typically simple variable stored order remove redundant control code 
determining build full fledged categorizing behavior add control code complicated 
prioritization drive collections getting priorities right posh system non intuitive 
clear cut priorities run see cat chasing fairly simple case alife rodent section things aren necessarily clear cut 
certain need cat 
look cats 
standard brp prioritization works fine prioritization strictly ordered 
quickly obvious needs mechanism attending things aren important spare cycles 
explanation scheduling system provide drive collection see section 
scheduling posh implementations inexact current ones course grained best effort scheduling 
things may scheduled second direct indication failing execute 
extent artifact reactive nature system expect events behaviors arrest attention agent 
initial schedule computed help simple benchmarking 
facilities benchmarking built control posh implementation clos version commercial profiler 
profiling helps determine constraints number elements run second allows estimates rate various numbers drives executed 
example nomad robot section sensing fairly expensive limits number cycles architecture hz 
robot stops moving reduces sense sample rate cycle rate increases order magnitude 
suggests robot engage phased periods activity example switching sense intensive exploration compute intensive map learning 
strategy mammals wilson mcnaughton motivations slip stack competence chaining facility posh action selection 
ways correct prioritization problems 
switching elements competences drives control script level 
elements drives scheduled reliably 
element required particular context may waste cycles scheduled drive 
ap handling bumps plan initially added competence motion walk overlooked fact competing brp steps walk long bumpers checked elements triggered 
consequently bump moved top level drive 
compound sense subsequently moved drive limited hz hardware checks involved sensing relatively long durations proving bottleneck 
hand perceptual routine watching landmarks switched walk needed context motion rely perceptual memory called frequently 
problem scheduling entire drive triggered scheduled rate problem really wanted able switch attention drive problem solved 
problem ap robot bumped plan expressed trigger action triggers executed atomically aps terminate sense action fails 
researchers systems inspired hormone levels effectively latch particular priority ordering period time grand ca breazeal scassellati frankel ray 
strategy bod creating behavior hormone emotion level sense preconditions behaviors see section example 
supporting development maintenance entire point bod easy possible designer agent correctly 
means leveraging strategies tools reliably increase productivity 
reliably means tools strategies correctly properly ways programmers 
strategies highlight section really worth effort implementing cost low negligible payoff high 
document agent specification program code importance documentation concept self documenting code established 
primary argument incorporating documentation functioning code way ensure documentation get synchronization rest software project 
primary argument strategy code really easy read concisely summarized 
bod somewhat overcomes problem having types summary built agent software architecture 
reactive plans summarize aims objectives agent 
interface plan primitives behavior libraries documents high level expressed actions various behaviors 
information documentation adaptive state agent code behavior modules 
bod structure documentation straight forward doing requires discipline attention 
strongly advise guidelines 
document plan behavior interface program file explained earlier remember chapter 
primitives posh reactive plans defined terms methods behavior objects 
behavior library code file creates interface 
implementations posh action selection primitive wrapped object act sense 
code executed object triggered usually lines long typically method call behavior object 
cluster primitives behaviors support program comments divisions behaviors clear 
main documentation specification file current intended specifications listed 
list names behaviors primitives determined decomposition implemented 
intended reactive plans usually written scripts see 
behavior program file behavior commented automatically really implemented object 
easily see state representations class definition 
languages don require methods defined class declaration style include methods class source file class definition 
keep comment reactive plan scripts suggestion really requires discipline having documented history development agent critical understanding nuances 
remember history doomed repeat old mistakes 
keeping complete set working scripts documenting stages agents development provides test suite useful major changes behavior libraries 
script contain comment name 
necessary order obvious plan copied changed updating comment 
case name won match file name 
script derived 
scripts improvements older working scripts shortened versions script needs debugged 
date created 
date started working significantly different 
writing scripts part specification process scripts ambitious plans working code 
date reasons abandoned abandoned 
possibly dates explanations changes 
normally changes shouldn happen script works abandoned new scripts old ones kept record 
tempted save old scripts remember forget history doomed repeat 
documenting plan scripts effectively documents history agent development 
single historic script current interface file easy reconstruct behavior library contained time script constructed 
revision control practiced see direct access behavior files appropriate dates 
old script histories great source material papers documenting project history see chapter 
revision control revision control systems established software tools covered depth 
strongly recommend system particularly multi programmer projects single programmers 
particular recommend cvs allows easily create directory containing latest working version agent version demo moment notice interfering current development directory 
helps handle situation version source code altered simultaneously 
works size project working multi national firewalls 
really worth time takes install system 
debugging tools tools worth time learn build 
prefer starting languages language packages provide decent level debugging relying customized agent toolkits 
minimum developer profiler find guess bottlenecks happening code 
ideally interruptible debugger show program state preferably allow stepping program execution 
class browsers extremely useful tools help developer quickly find code functions language program 
concurrent versions system org 
know successful complex agent research projects logging actions multiple discrete levels high level decisions mid level decisions low level actions absolutely critical debugging code 
ymir multi modal dialog agent project th risson cmunited cup soccer teams riley 
rudimentary versions logging system personally find real time notification events stepping control useful 
certainly building guis help automate time consuming needed aspects development maintenance worth time 
entire literature agent toolkits try summarize see bryson 
section outlined consider minimum amount support useful develop intelligent agents 
bod relates similar approaches give quick high level summary relationship design design techniques extent inspired 
approaches high level methodologies algorithms 
cases possible build agent approaches 
important question easy consequently solve particular problem particular strategy 
behavior ai main benefits bod standard bod hierarchical reactive plans bod methodology behavior decomposition 
argued frequently earlier having explicit reactive plans built part architecture greatly simplifies control 
particular set behaviors active say robot trying pick need worry interactions unrelated behaviors 
robot decide sit relieve go see movie reasonable juncture tea cup 
hand may drop cup truly important happens example attack large dog trying knock 
easier express information reactive plan build complex mutual inhibition systems new behavior time behavior added necessary conventional 
mutual inhibition reinforcement systems control problem scales exponentially explicit plans problem scales linearly 
bod offers terms behavior decomposition methods better place start 
trying determine units behavior developer determines information agent going need 
chief insights ood 
better way fix things 
approaches bod necessarily assume decomposition done correctly attempt 
provides cyclic development neat interfaces behaviors control 
object oriented design ood bod extent ood fully object oriented approach 
ood tends useful passive reactive systems frequently designing systems actively internally motivated 
addition bod provides ood reactive plan component 
allows expression motivation priority part organization behavior 
separates problem organizing behavior time problem representing information behavior conducted 
bod applies techniques building plans decomposing behaviors analogous identical ood methodologies designing object hierarchies 
equivalent ood notions inheritance bod class hierarchy 
bod behaviors hierarchical reactive plans 
agent oriented design aod hand object motivations intentions system called multi agent system mas 
programming mas called agent oriented software engineering wooldridge ciancarini 
believe aod overkill creating single complex agent people modular agent architecture 
problems aod context arbitration done voting distributed algorithm 
potentially slow involves able determine entire system relative value individual agent goals sandholm 
complex agent fixed number component modules time prioritization done essentially done creating posh plan presumably operate quickly 
communication agents emphasized relies homogeneous representation 
favor customizing interface part design complex agent 
aod approach sense fluctuating number agents running different hardware owned different people trying negotiate solution defined problem set problems 
far developing intelligence single complex agent goes instance overly homogeneous representations overly obscure control 
behavior oriented design authors term behavior oriented design 
author continued term great degree 
author nakata dealt automated design causal reasoning way device intended 
see drive levels section 
completely unrelated 
author steels complex agent field discussing development behavior robots 
steels primarily devoted documenting extremely impressive robot experimental enclosure robots competed cooperated generating acquiring electric power 
mention actual process behavior oriented design part definition behavior oriented design starts identifying desirable behaviors seeking subset behavior systems need developed 
steels approach speaks decomposition parallel modules robot architecture 
speaks behavior oriented opposed goal oriented design pp 

phrase encompass entire architecture philosophy point included avoiding action selection 
view dissertation significant elaboration earlier steels 
chapter gone detail describing bod methodological process put bod agent 
described specification bod agent needs contain 
described importance developing agent specification order continually optimize agent simplicity 
necessary order keep agent easy extend adapt maintain keep control complexity problems agent expected learn solve 
described important ancillary issues supporting bod development effort guarantee specification kept date best programmer time resources 
briefly related bod related high level software methodologies 
chapter devoted explaining bod methodology time example instruction 
chapter design process example modeling transitive inference primates previous chapters shown complete working bod systems toy examples illustrate design process 
chapter document complete design process order illustrate process developing scaling bod system simultaneously controlling complexity 
system developed built examine particular competence real animals ability perform transitive inference described 
relatively simple drive structure models compatible goals learning task training agent learn task 
experimental agents situated artificial life simulation complex perceptual motor control 
consequently behavior code relatively brief concentrating primarily coordinating behavior learning task reporting results 
full code appears appendix available online 
experiments chapter intrinsically interesting extend current models transitive inference learning available psychology biology literatures 
capacity learned brp 
difficulty monkeys humans learning task supports emphasis dissertation design learning action selection mechanisms 
biological background learning ordered behavior transitive inference process reasoning deduces quality domains real numbers property hold domains sporting competitions primate dominance hierarchies property necessarily hold 
example international tennis rankings general predictor outcome tennis matches may systematically fail predict outcome particular players piaget described transitive inference example concrete operational thought piaget 
children capable doing transitive inference capable mentally performing physical manipulations determine correct answer 
case transitive inference manipulation ordering objects sequence rules observing relative location demonstrations transitivity children various animals apes monkeys rats pigeons see review lead transitive inference basic animal competence skill operations logic 
fact reported shown adults trained context exploration type computer game performance difference individuals formed explicit models comparisons vs respectively 
characteristic transitive inference effects effects hold experimental subjects children monkeys rats pigeons adult video game players 
subject learned ordering set pairs ab bc cd tend show significantly chance results transitive inference 
show effects see review anchor effect subjects better correct faster reaction times test pair contains ends 
usually explained fact learned behavior regard points 
serial position effect account anchor effect subjects poorly closer middle sequence 
symbolic distance effect compensating anchor effect apart series items faster accurately subject evaluation 
effect seen contradicting step wise chaining model transitive inference steps longer rt distant items 
item effect verbal tests pairs better evaluated question posed direction evidence evidence takes form bigger smaller harder answer bigger 
considered possibly analogous fact pairs closer rewarded series done better symmetrically opposite items rewarded ac easier ce 
british sports word non transitive relationships lower ranking team called 
pair order ed dc cb ba repeated trials correct 
reject requires trials total pair order 
criteria consecutive trials correct 
reject requires trials total pair order 
criteria consecutive trials correct 
reject requires trials total pair order 
criteria consecutive trials correct 
rejection criteria 
pair randomly ordered 
criteria consecutive trials correct 
reject requires trials total binary tests sets pairs random order 
reward failed training pair 
trials 
correct redo 
sets trigrams random order reward 
extended version 
phases training testing transitive inference chalmers mcgonigle 
subject reaches criteria proceeds phase 
training subject transitive inference experiments training subject perform transitive inference trivial 
subjects trained number ordered pairs typically batches 
anchor effect chain length items order clearly demonstrate transitivity just untrained pair bd 
obviously items give information training transitivity notoriously difficult 
children master items master individual items generally labeled arbitrary way designed non ordinal color pattern 
additional control normally provided assigning different color pattern orderings different subjects 
example subject may learn blue green brown brown blue green 
subjects taught testing apparatus rewarded selecting option 
experiments reviewed subjects learned look colored tins reward 
trained pair de element rewarded subject learned criteria trained cd 
pairs trained manner phase repeated ordered training fewer exposures row pair followed period random presentations training pairs 
subject trained criteria exposed testing data 
interestingly true conventional sorting ordered items posts different lengths see mcgonigle chalmers 
psychological literature consistent higher rewarded 
uses high 
testing choice rewarded differentially rewarded training pairs interspersed testing pairs ensure forgotten 
standard models currently dominant way model transitive inference terms probability element get chosen 
probability determined weight associated element 
training weight updated standard reinforcement learning rules 
normalization weights rules demonstrated necessary order get results invariant order training ab de 
account pair specific context information proven useful accuracy necessary explain fact animals learn looping pair items 
provides summary model xy xy xy xy normalizing term ab indicates context sensitivity free parameters 
models assume reaction time varies probability correct response 
modeling errors transitive inference case cognitive modeling errors subjects telling way disambiguate different possible models 
section describes set experiments indicate transitive inference single weight system indicates 
describes models describing errors 
binary sampling model earliest non cognitive transitivity papers mcgonigle chalmers demonstrated animal learning transitive inference proposed model account errors animals 
monkeys children tend score pair bd 
mcgonigle chalmers proposed binary sampling theory 
theory assumes subjects consider items visible items expected visible 
take account elements associated current stimuli especially intervening stimuli associated 
subjects consider possible elements choosing pair random 
trained pair perform trained perform chance items item case perform selecting avoiding item respectively 
animal selects item act selection 
selection reinforces consideration item tends push animal higher valued items displayed 
pair bd model assumes equal chance monkey focus bc cd bd 
established training pair results monkey selecting pair bd results chance element chosen 
predicts subjects select time near average actual performance 
binary sampling theory naive probabilistic model incorporates concept expectation systematic 
fails explain symbolic distance effect 
motivated mcgonigle chalmers generate fascinating data set showing results testing monkeys children chalmers mcgonigle trigrams items 
binary sampling theory predicts trigram bcd chance chosen half times bd attended chance chosen times cd attended chance bc plus half bd 
fact monkeys showed respectively 
production rule stack model trigram data harris mcgonigle create model concept stack production rules 
model matches performance monkeys modeled group individuals 
production rule stack model requires assumptions 
subject learns set rules nature select avoid 

subject learns prioritization rules 
process results rule stack rule applied trigger finds context appropriate 
second 
production rule stack brp executed 
example consider subject learned stack 
select 
avoid 
avoid 
select top item assumed highest priority 
subject pair cd begins working rule stack 
rules apply 
rule indicates subject avoid consequently selects priority critical 
example pair de rules give different results 
rule higher priority selected 
adding assumption trigram test cases avoid rule results random selection remaining items harris mcgonigle model conglomerate monkey data significant difference model data 
example possible trigrams stack hypothesis predicts distribution lowest middle highest items 
binary sampling predicts logic course 
monkeys showed 
individual performance monkeys matched particular stack 
trigram data way discriminate rule set monkeys 
trigram data stacks distinguishable errors 
example stack 
select 
select 
select 
select select trigram bcd rule previous stack select time base decision rule 
discernible correct rule stacks rules solve initial training task 
correct stacks rules trigram experiments discriminate fourth rule selects avoids 
proposed model model transitivity built chapter influenced models discussed 
influenced models action selection reinforcement learning see review basal ganglia see chapter 
basal ganglia appears control movement primarily selective context inhibition activity moving perceptual motivational streams motor 
components novel model model proposes 
earliest phase training subjects learn grasp viewed tin order get reward 

large blocks ordered pair training subjects discover may select item rewarded 
consequently inhibit applicable grasping behaviors selected item 

size training blocks reduced subjects learn prioritization neighboring inhibition rules 
interactions neighbors gener ally sufficient produce total ordering allows learning additional ea pair 

process selecting rules similar activation involves probabilistic attentive sampling alternative rules 
attention allows searching increased evidence generally increases activation rule 
competing rules similarly weighted process longer arbitrary 
chapter focus modeling third proposals 
relatively fourth essentially elaboration common assumption sequence learning models 
learning model full model eventually construct requires vectors learned representing priorities contexts priorities rules applied context 
vector composed normalized weights representing priority level 
weights updated trial trial presentation pair trigram selection agent reward 
update rule replace sigmoid eq 
step function 
assume pair xy selected agent free parameters 
correct vx vy add vx 
incorrect subtract vx renormalize 
item task vectors represent different stimuli stimuli representing associated rules 
fact experimental runs stimuli selected attention 
runs vectors see examples 
trial subject agent selects stimuli attend rule apply current 
initial weights matched case outcome arbitrary 
subject agent stores selections short term working memory 
subject agent chosen training agent rewards fails reward subject 
subject agent updates vectors reward recalled decision 
behavior oriented design model agent section document construction performing agent version model 
section intended primarily detailed example bod 
case trigram subject selects rejected items random role equation 
intermediate versions model represented results shown section 
real modeling problem agent produced relatively simple particularly respect drive system 
model single task controlled environment real time 
see interesting examples drive collections see agents sections 
primary goal section illustrate detail bod process capabilities bod agent architectures 
harris mcgonigle reverse priority standard labeling letters chosen color labels items ordered 
reduces possibility confusion assumptions ordering 
examples correct transitive ordering red white blue green yellow 
initial decomposition steps bod initial decomposition see section applied task modeling monkey learning transitive inference 
agent built represents agents real world monkey test machine 
really strange real world test apparatus designed way accounts behavior monkey 
bod applied multi agent systems see chapter case behavior organization better considered perspective system 

high level description highest level description want system apparatus hand tests monkey hand choices learns 
detail want agent learn ordering selection rules choosing item pairs stimuli learns particular criteria want test novel pairs triads stimuli see 

prototype plans individual trial look set test choose box rewarded right notified wrong learn experience test board cleared 
higher level testing machine follow training procedure learn set adjacent pairs criteria demonstrate competence pair ordered sets training mixed randomly 
criteria passed perform possible pairs rewarding behavior pairs correct behavior training pairs possible triads rewarding behavior 

prototype plan primitives actions system needs able perform setting test administering reward clearing test grasping box learning episode test reward 
monkey need able notice test set distinguish boxes notice learned preferences 
machine need able tell administer test reward test reward administer 

prototype behaviors obvious decomposition case state needed monkey needed apparatus 
state monkey varies rapidly context monkey looking holding state adapts slowly time priorities monkey assigns possible actions 
different rates state change key decomposition indicator expect behaviors monkey eyes hands sequence priority learning apparatus testing machine 

determine drives case really modeling single high level competence code drive system run continuously developing debugging 

select behavior implement start modeling behavior harris system hard coded reactive plan transitive inference 
gives chance debug primitives demonstrate difference encoding knowledge learning 
initial decomposition exists remains iteratively build agent 
sections document development agent 
drawn model represents plan script debugged saved part test suite 
test suite relatively simple plan scripts useful major changes behavior library 
changes caused new insights underlying representations discovery bugs 
part development process added capability new simplification agent structure 
changes expected supported bod process 
modeling expert replicating simplified version harris system models skilled monkeys 
initially ignore slightly complicated avoid rules model correct solution select rules 
binary test cut just competence 
behaviors support representing state monkey state testing machine set test invoked hand running competence 
monkey part agent named elvis particular 
primitive set test called hand competence tested 
competence works effectively switch statement cond lisp production stack harris production rule system 
monkey grasps highest priority color sees 
see color primitives map single method particular perceptual argument 
perceptual primitive sets visual attention grasp seen determine object grasped 
grasp seen side effect removing grasped object test tray apparatus 
monkey visual attention hand elvis see color grasp seen grasp action selection see behaviors see red grasp seen see white grasp seen see blue grasp seen see green grasp seen plan set test apparatus test board plan binary test 
models simple trained competence making transitive choice 
subsequent diagrams omit grasp see arcs clarity 
driven test step incorporate elvis competence agent 
agent sets test currently test removes test monkey currently grasping lets monkey choice 
plan gives example posh element type action pattern gratuitous notice drive collection life goal ends 
bottom drive trigger included debugging purposes 
screeching nominally ascribed monkey behavior require state produce formatted output alerts experimenter 
learning ordering prior learn step enhance model forcing monkey learn ordering colors 
requires significant changes augmenting test behavior reward monkey appropriately adding new behavior sequence system 
screeching high level debugging agent operates tool wise debugging turned indication running successfully occasional red box 
monkey visual attention hand see color grasping noises grasp seen life action selection behaviors test new test grasping finish test test elvis choice test new test finish test see red noisy grasp see white grasp seen elvis choice see blue grasp seen see green grasp seen noisy grasp grasp seen plan plan driven test 
models experienced monkey 
apparatus test board external observers course ascribe sequence monkey 
notice separate object behavior previous monkey behavior 
keeping bod principle behavior decomposition dictated representation rate adaptation 
monkey state deictic changes utterly testing episode 
sequence represents life long learning 
primary adaptive state vector learning rule akin standard neural network weight update rules 
associated pieces state parameters learning rule fixed individual monkey 
apparatus uses adapted version debugged transitive competence determine monkey chosen correctly 
apparatus requires extra perceptual skills order notice color box selected 
apparatus new piece state reward nil peanut peanut 
real monkeys peanut audible lack reward choice 
illustrates example trading complexity behavior complexity plan see section 
educated grasp simple action pattern relies sequence determine item look 
motivation tradeoff simplification primary design goal agent learn appropriate prioritization 
important realize reward monkey looks elvis choice fact entirely new competence terms ability system actual code 
principle reducing redundancy section competence elvis choice simplification 
course reward monkey 
hand ar action find color reward new test apparatus selection test board test finish test save result reward grasp seen grasping adaptive choice noises consider reward sequence monkey seq look visual attention sig dif hand weight shift life behaviors test new test rewarded test grasping reward monkey test educated grasp find red reward find white reward reward monkey find blue reward find green reward educated grasp adaptive choice grasp seen test consider reward save result finish test plan plan prior learn 
learning priorities different colors 
ordering colors needs specified 
easy specify plan readily edited wanted different sequence case debugged 
sequence learner contains bits state list known objects weights significant difference weight shift 
learning algorithm works monkey chooses correctly certainty significant difference adds weight shift weight winner weights 
wrong shifts weight favor alternative regardless certainty 
sum weights sequence kept standard strategy modeling resource constrained learning 
monkey sees new item seen adds sequence list giving weight equal number items currently list reflecting lack expectation sort order item occur 
weight derived elements proportion current weight existing weight multiplied 
test machine charge setting rewarding behavior 
new primitive find searches world colored box reward lack reward machine attending monkey hand test board 
test action pattern calls actions sequence different behaviors sequence learns reward apparatus records result clears test board 
results learning systems section shown discussed section 
see particular plan 
section continue concentrating demonstrating scaling bod 
fair prior learn figures illustrate bod systems show aspect model complexity 
particular show code behavior methods names 
scaling model changes terms method code 
example script fair prior learn switches training agent possible pairs training adjacent pairs keeping standard animal procedure described section 
impact plans change new test new training set 
potentially significant change training regime ran cluster tests 
monkey level complexity performance effectively identical trained possible pair 
learning ordering rules full experimental results mcgonigle chalmers transitivity tests indicate monkeys year old children chalmers mcgonigle learn sequences colors sequences behavior rules 
fact exposed primate child exposed choice colored boxes 
explained harris mcgonigle showed tight fit model subjects learn rule avoid yellow select red 
fit assumes highest ranking applicable rule avoid yellow selection choices triad chance 
roger test step modeling learning rule color ordering modeling having rules 
returned earlier script driven test update represent monkey uses avoid rules 
monkey modeled happens squirrel monkey named roger 
main monkey difference roger test driven test plan competence elvis choice replaced behavior monkey action test save mcg result apparatus selection new bt test finish test test board see color grasping pending test noises grasp block pop test monkey tester visual attention tests hand life behaviors test pending test goal test new bt test grasping record finish test roger choice see red grasp seen roger choice see yellow grasp see white grasp seen see blue grasp seen record finish test save mcg result finish test plan plan roger test 
models monkey avoid rule apparatus test regime 
supports primitive grasp described 
order fully test behavior need expose monkey triads 
added new behavior apparatus tester governs training followed testing 
implementation fairly simple tester list possible tests list empty pending test false 
notice life goal terminates test complete 
rule learn final system combine roger test plan fair prior learn effectively plan 
debugging simpler fully explore model representation real monkey add behavior system time 
consequently rule learn incorporate tester roger test dedicated solely learning orderings rules 
model assume results harris mcgonigle learning select avoid rule independent possible con action find color reward new test selection test finish test save result rewarded grasping noises grasp seen monkey target chosen focus rule pick color visual attention priority focus rules reward hand look sequence seq sig dif weight shift life reward monkey behaviors choice learn reward test new test rewarded test grasping reward monkey educated grasp find red reward find white reward find blue reward find green reward apparatus test board reward rule learner rule seqs current focus current rule target chosen grasp seen educated grasp focus rule avoid pick focus rule select pick priority focus test rules reward save rule result finish test plan plan rule learn 
learns priorities rules different colors learning ordering rules 
text 
monkey learns visual stimuli colored box important stimuli rule appropriate 
consistent fact monkeys learn behavior looks select st avoid th select nd earliest mentioned rule highest priority major rule learn 
new behavior rule learner pieces named state 
sequences deictic state referencing winning units sequences 
fact rule seqs really list sequences element 
elements correspond visual contexts acquired way colors acquired prior learn 
assume gross behaviors select avoid acquired previously generally associated colors 
time new element added new rule sequence added rules preset equal priorities see section 
notice multiple instances sequence behaviors 
distinct variable state referenced differently primitives 
see section commentary directions 
second change educated grasp competence action pattern 
strictly necessary pick pick simply pick deictic variable 
large difference procedures felt segregating improved agent clarity 
differences somewhat visible 
example rules reward affects sequences 
implied fact method rule learner 
rule learn making choice monkey uses rule learner sequence determine color box attends rule seq associated color determine rule applies 
learn reward applies learning rule sequences 
real training regimes shown section rule learn prior learn converge exposed randomly ordered adjacent pairs sequence 
complete model subject monkey rule learn full training regime 
regime specified chalmers mcgonigle detail description 
educate monkey adding mechanism training regime bod agent strictly necessary 
explained section see section conventional software systems incorporated directly intelligent bod agent 
training system algorithmic intelligent prime candidate 
consequently new competence pick test grossly complexity regime phases training testing 
distinction adjacent pair gram explained earlier monkeys learn rules disambiguate item sequence fourth rule discriminated triad testing 
action board hand give peanut new test apparatus selection test board test finish test save result rewarded reward grasping noises pending test set test pop test grasp seen hand criteria monkey target chosen focus rule pick block tester tests test phase visual attention priority focus rules reward criteria hand num correct look sequence rule learner seq choice sig dif rule seqs learn reward weight shift current focus current rule life selective reward behaviors test done clean goal test pick test rewarded test grasping selective reward pick test educated grasp test goal criteria set ngram set pair board red hand white board white hand blue board blue hand green board green hand yellow give peanut target chosen grasp seen educated grasp focus rule avoid pick focus rule select pick priority focus test rules reward save rule result finish test plan plan educate monkey 
augments rule learn making training apparatus sophisticated 
bigram trigram document separate primitives simply documents movement training testing 
mcgonigle chalmers necessary continue partially training animals testing 
monkey confronted adjacent pairs trained performs incorrectly rewarded 
test stimuli triads non adjacent pairs monkey rewarded regardless choice 
explains needed alter reward competence educate monkey 
results shown script refinement computes monkey right rewarded order simplify analysis 
little additional theoretical pedagogical value improvement script educate monk included appendix results previous section described entire process developing bod agent model learning transitive inference 
main motivation going detail versions model illustrate bod process models provided interesting results 
section discuss results binary test driven roger test non learning models replicated harris mcgonigle 
checking replication essential part development particularly interesting operation production rule systems understood 
similarly prior learn fair prior learn essentially replications studies documented precise mathematical models 
learning systems provide basis comparison final models reviewing systems 
learning colors rules shows typical result fair prior learn 
real animals children models perform regardless training regime 
form prior learn weights sum significant difference set stable solution 
fact gave fair prior learn name exposed training testing pairs trained reliably stabilized weights quicker prior learn see 
doubt due high incidence significant boundary information provided training sets 
hand sig dif greater stable solution items reached 
learning tails hot hands phenomena causes weight item occurred number training pairs grow higher ranking element see 
systems stable solutions happens regularly 
results give hypothetical explanation individual difference transitive task performance 
individual differences stable discriminations priorities fast prior learn finds stable solution rapidly exists 
sig dif weight shift 
dotted line represents red st plain line white nd stars blue rd pluses green th triangles yellow th 
stable solution chance orderings tests drive set weights 
prior learn running sig dif weight shift 
results prior learn 
prior learn fair prior learn err 
weights 
err 
weights 
prior learn vs fair prior learn 
weights reported trials 
trials ended arbitrarily weights stabilized 
affect number items reliably ordered 
hand fair competing unstable weights represent top priority colors 
violates anchor effect biologically plausible course bottom priority item successfully stable weight imagine dual weighting system proposed henson anchor ends 
rule learning results rule learn fails find stable solution 
show rule associated stimuli select green pluses th avoid blue stars rd avoid white mark nd 
agent confuses training pair blue green 
added complication rule learning monkey model longer learn correct solution 
fact rule learn consistently learns solution shown symmetric nd rd rules fighting top priority 
priority stimuli stable priority rules quickly stabilize 
solutions look truly pathological mistake training pair top priority stimuli 
ordering rules irrelevant error whichever rule fires 
notice result display anchor effect 
simulated monkeys quickly choose rules avoid making errors points choose rules lead complete solutions 
displays serial position effect confuses central pairs 
real monkey named blue showing consistent error rd th item discussed harris mcgonigle 
model blue mind 
blue mcgonigle squirrel monkeys inside test apparatus 
confident items slower 
photos brendan mcgonigle training implemented educate monkey see rigorous procedure applied monkeys children difficulty learning task adult monkeys 
rigorous necessary simulated monkeys 
nearly converge quickly ones fail learn fail early usually phase 
shows interesting run educate monkey prior testing rules fully ordered 
rules concern opposite ends inference chain ordering correct 
shows rule provide stable solutions resource constraints tight stability prior learn 
rules normally compete share priority space producing solutions shown phases third portion training 
sig dif shows rules interfere share priority level testing 
trigram testing pressures similar coupled lack negative reinforcement result stable weight configuration longer correct 
course trigram testing selections rewarded agent perspective solution satisfactory 
training regime educate monkey place runs able find correct solution 
vertical lines labels mark labeled phase 
agent shows learning occurring test phases 
learns select red dots st avoid yellow triangles th avoid green pluses th 
monkey particularly stupid sig dif weight shift 
educate monkey agent 
agent learned select red dots st select white plain nd avoid yellow triangles th select blue stars rd 
monkey sig dif weight shift 
results educate monkey 
discussion primary emphasis chapter illustrating bod development process extended example 
flow design shown system competence simple behaviors posh action selection tree drive collection competences action pattern arbitrating behaviors adaptive 
learning model rule learning hypothesis proposed harris mcgonigle demonstrated number interesting agents show qualitative resemblance various individual monkeys supply hypotheses learning process beliefs underlying monkeys behavior 
results section contains analysis system agent continue scaled 
fully implement model proposed section need alter priority focus probabilistic model uncertain 
model biologically plausible basic priority representation probably requires weight vectors suggested section 
making improvements fairly trivial testing agents analysis results time consuming part process 
fact batch tester added top tester apparatus probably stage development 
model transitive inference task particularly interesting respect dissertation 
extends discussion tradeoffs plans behaviors begun section showing adaptive behavior rule learner learn essentially brp 
time difficulty children monkeys learning task underscores emphasis importance bias learning design ai 
chapter example modeling social interactions primate colonies chapter gave extended review bod project relatively simple agent system 
primate competence modeled significant interesting simulation real time 
modeling real world agents monkey machine built bod agent 
chapter reverse brief preliminary done interesting complex agent domain 
model development include current state demonstrates important features shown dissertation bod multi agent context 
real time drive system implemented newer posh implementation see section 
demonstrated earlier real time posh control robot chapter 
chapter uses implementation chapter code readily comparable see 
conventional level modeling emotional motivations 
existing models researchers lines reviewed section 
chapter demonstrates incorporate important idiom agent literature bod 
biological background de waal theory primate societies chapter done collaboration jessica emory university 
summary phenomena modeling interesting questions study animal societies individuals negotiate social relationships 
question conflict lower level units individual group members regulated formation higher level units societies described fundamental problem ethology leigh 
research non human primate societies indicates variety mechanisms aggression social tolerance avoidance conflict managed resolved de waal understood expression mechanisms varies social systems 
example tremendous variation macaque genus terms conflict managed despite similar patterns social organization 
aggression species common severe extremely frequent rarely levels produce injuries de waal luttrell 
corresponding variation degree aggression employed settle conflicts interest variation degree social tolerance dominant individuals subordinate ones particularly context resource acquisition variation degree relationships damaged aggression repaired reconciliation de waal luttrell 
appears variation conflict management mechanisms varies predictable ways species appear covariation species specific 
variation emergent patterns social interaction individuals self reinforced social learning 
bryson extending bod multi agent simulation significant technical challenge creating multi agent implementation bod system 
course easy multiple fully independent agents reasons described section wanted run bod agents commercial debugging environment single machine 
fortunately current version posh architecture implemented version common lisp supports multiple processes 
approach took dedicate process agent rely platform perform time sharing agents 
agent instances behaviors current control stack action scheduler 
currently share posh reactive plan intend explore heterogenous communities 
action schedule holds current instances posh control objects order keep track control state currently reason replicate template posh plan structure agent 
bod model drives emotions modeling conventional emotion drive theory topic emotions losing taboo artificial intelligence animal sciences 
emotions necessarily emotional subject raising unusually responses support criticism systems theories 
primary goal model explore models state behavior underlying complex social activity non human primates 
byproduct integrate emotional responses complex agent control 
indications various phenomena know emotions characterize set behaviors evolved significantly different points ancestral history ledoux 
emotions effectively intervening variable explain categories species typical behaviors related behaviors environmental contexts tend displayed expressive body postures behaving animal 
emotion variables real biological correlate relatively slow diffuse chemical transmissions brain rest organism create significant internal context brain operation affecting perception action selection 
agents designed model animal behaviors humans readily describe emotional interactions individuals primate colony 
current model shows animals oscillating drives desire groom desire privacy 
grooming interesting behavior associated bonding animals effect recipient 
primates derive pleasure grooming normally engage behavior relatively infrequently 
frequency grooming tends increase times certain social stresses 
desire privacy model stands number ways primates spend time foraging 
model seeking isolation agents simplicity sake 
monkeys living community monkey desire groom interfere desire privacy 
number possible solutions conflict de waal pilot study modeling tolerance aggression 
aggression course associated emotions anger fear 
representing emotions bod emotional responses agents simulation represented exactly behavior combination reactive plans representing particular orderings actions action patterns behaviors determine way actions expressed 
emotional responses continuous normal action selection sense light current understandings emotions 
damasio example suggests essentially species typical behavior emotional response emotions central motivation 
general purpose behavior drive level representing current level activation drive 
pieces state behaviors follow sort pattern activation emotional responses 
methods behaviors help determine motivation level see 
example desire isolation increases slowly presence animals decreases slowly animal 
fear hand increases radically context direct threat slowly context fight nearby agents 
decreases slowly isolation quickly context danger 
emotional body postures abstracted alife simulation simply colors agents 
expression controlled emotion behaviors 
primate action aligned target go partner edge engage width height selection color button touching target approach wait name label target doing want new loc want groom partner chosen target leave groom choose grooming partner explore grooming level primate level primate threshold latched level latched level increment drive level current chunk cc start time chunks memory length latch increment behaviors supporting move groom 
top rows primate state really characteristic object simulation 
model showing grooming oscillating privacy current system controlling primates follows 
currently behaviors 
grooming explore fairly simple behaviors described controlling latent variables identified emotions drives 
third drive level behavior described 
fourth primate relatively large responsibility handling primates bodies controls navigation agents enclosure 
simulations primates particularly complex primate probably decomposed behaviors 
important output system simple list events colony produced information compared existing models data 
purpose debugging gui representation agents represented simple buttons color indicating expression ascii characters indicating identity gestures 
observing function produces log activity information gleaned observing gui gathered field workers observing real primates 
course noise ambiguities arising field determining intended object gesture crowded location general level reporting plausible records expressed behaviors 
life grooming want groom wandering partner chosen aligned target groom partner overlap go partner edge partner chosen engage partner chosen approach choose grooming partner want new loc target chosen touching target want new loc target chosen forget target leave want new loc choose isolated place wait reactive plan supporting coordination alife agents 
see text explanation 
shows current reactive plan coordinating potential conflicting actions behaviors 
primate moves possible states trying groom trying just sitting 
current drive collection determines desire grooming outweighs desire isolation operating 
equally possible guard competences sense predicates relative differences drives 
move groom shows prioritization drive levels combined determining high level action selection 
preliminary results working building behaviors primates begun quantitative analysis results 
transcript shows brief ch charlie names unique letters ch charlie gesturing right ch charlie touching left ch charlie gesturing charlie touching grey neutral normal motion sitting pink displaying red angry fighting orange frightened screeching aroused purple mounting blue playing green grooming labels colors indicating state identity particular agent simulated colony 
colors current grey green 
episode experience colony 
animals want move location space attempting groom move 
mutual grooming seen murray jean stage coincidental agents deliberately cooperate 
example roger particularly mood groom particularly concerned isolated ignores alice 
george hand wants move isolated spot chased monica repeatedly tries sit moves 
agents shown simulation theory mind notice wanted failing meet goal 
course capacity bod representations current development efforts concentrating general mas aspects simulation creating better debugging tools 
steps model agents aware actions model tolerance aggression fear 
point review effects varying parameters system extent individual agents able meet individual goals amount time spent grooming 
baseline performance established modeling intervention behaviors social ordering 
discussion chapter brief glimpse multi agent bod modeling conventional drive theory bod system relationship emotions action selection 
code chapter see appendix shows functioning george approach ringo approach murray wait monica wait jean approach murray jean align murray jean groom murray alice approach roger alice groom roger murray approach jean jean approach murray murray groom jean jean groom murray monica approach george monica align george monica approach george monica align george monica approach george part sample observation log simulated primate colony 
approach indicates walking wait sitting foraging align engaging sitting closely interactions groom obvious 
see comments text 
real time drives implementation posh shows example behavior library posh script history 
primate project example mas built bod components 
platform exploring models primate social organization expect research useful examining differences modular intelligence single agent multi agent intelligence community 
primates interesting examples successful communities fairly unstructured low bandwidth communication agents 
chapter extending bod modeling neural systems useful interesting application complex agent technology creating functioning models naturally intelligent systems 
chapter examine extent possible bod methodology 
discuss extensions current standard bod agents useful modeling biological intelligence 
chapter argued convergent evidence agent architecture literature supporting utility necessity structural attributes bod agents 
claimed brooks hendriks jansen bryson biological agents face similar problems constraints complex artificial agents thesis chapter true animals expected control structures 
chapter examines evidence fact case 
examining relationship bod biological intelligence directly chapter examines relationship bod artificial neural networks ann 
anns vast simplifications real neural systems useful technology helping think model highly distributed systems representation control learning 
proven useful science providing models paradigms hypotheses engineering providing adaptive control classifier systems 
integrating ann agent software architectures may science engineering 
bod brings ann understanding modularity specialized learning timing synchronization issues 
ann brings bod homogeneous adaptive representation theory extend sorts adaptability possible bod 
anns far control systems attempt replicate behavioral complexity complete animals 
reason discussed chapter complexity systems effectively requires decomposition modules hierarchy 
requirement theoretical practical 
theory monolithic systems may turing complete attacked design learning practice complex control requires decomposition solvable subproblems 
seen modularity key bod bnn ann advances artificial neural networks ann inspired better understanding neuroscience bnn 
chapter shows similar relationships exist bod fields 
feature bod agents architectures complete complex agents 
chapter begins discussion modularity mammalian brains 
background describing mapping features bod agent architectures known functioning mammal brains 
return discussion begun chapter limitations bod adaptivity discuss extensions bod needed order model adaptivity exhibited natural intelligence 
conclude practical sublist biologically inspired features agent architectures consider useful ripe widespread implementation 
modularity nature types modularity mammalian brains 
architectural modularity 
shows brain composed different organs different architectural structures 
types connectivity nerve cells synapses characterize different brain modules different computational capabilities 
examples architectural modules include neocortex cerebellum thalamus hippocampus gray matter forth various organs fore mid 
second functional modularity 
modularity characterized differences utility underlying differences structure computational process 
modules specialized due combination necessary connectivity individual history 
gross examples include visual vs auditory 
sur shown level structural interchangeability surgery 
convincing invasive evidence 
example functionally defined cortical regions slightly different locations different people heeger 
people recover capacities temporarily strokes permanently disable sections brains experience cortical significant alterations body loss limb ramachandran 
evidence indicates brain innate capabilities adaptively form functionally modular organizations neural processing 
thirdly temporal modularity 
different computational configurations exist contemporaneously 
sorts evidence temporal modularity 
regions brain appear local winner take connection wiring dominant impulse inhibit competing impulses hebb grossberg 
neurological feature explain fact humans perceive interpretation visually ambiguous stimuli time 
second cells brain members assembly perform substantially different roles subtly different contexts hippocampus kobayashi wiener 
brain cell recording experiments showing individual cells associated different stimuli behavior members different ensembles depending animal current context mcnaughton 
sort temporal modularity understood implications individual differences intellectual task performance insight metaphoric reasoning 
ambiguous image 
seen vase faces time 
gleitman presence forms modularity mammalian brains motivates modular architecture ways 
interested modeling brain matter scientific interest need able replicate modularity 
second presence modularity best examples intelligent control available evidence modularity useful means organizing behavior 
evolution perfect designer mere presence solution nature prove optimal 
extent complexity brain evolved worth treating utility features hypotheses 
mapping bod features mammal brain structure chapter shows complete agent architectures converged sorts architectural modules order support complex reactive behavior 
skill modules hierarchically structured reactive plans focus attention behaviors useful particular circumstance provide temporal ordering behavior 
alarm systems switch focus action selection attention response highly salient environmental events 
bod behaviors correspond skill modules posh control structures handle plans attention switching 
sort organization necessary useful intelligent control reflected organization animal intelligence 
section relates principles known mammal brain architecture 
skill modules previous section discussed modularity mammalian brains 
terminology consider bod behaviors correspond roughly functional modularity particularly neocortex extent temporal modularity 
strength correspondence various factor bod application brain region 
consider behavior grasping visual target 
bod agent incorporate information mammals comes retinas visual associative motor pre planning motor coordination 
need exploit somatic proprioceptive feedback grasping limb complexity masked interfacing specialist modules 
processing encompassing perception action contrasts understandings brain modularity 
functional cortical modularity mammals tends general purpose modality specific example usual understanding visual auditory somatic 
hand research gandhi shows premotor motor represent motion multi modal input specific various complete motor primitives feeding scratching blows 
complex behaviors triggered single cell simulation indicates animals complex monkeys bod modules represent hierarchically 
temporal modularity parietal cortex hippocampal formation multi modal obviously strictly parallel 
temporally asynchronous context specific biological modularity motivates bod behaviors associated parallel processes active supporting affected primitives 
course artificial agent models strictly biological preclude researcher interested specifically biological modeling bod 
reiterated times dissertation bod behavior decomposition motivated primarily software engineer 
modularity bod serves primarily support orderly decomposition intelligence manageable constructible units 
researcher interested modeling brain directly bod easily known cortical modularity blueprint skill decomposition 
action selection basal ganglia proposed organ responsible aspects action selection mink prescott appear 
distributed parallel model intelligence main functions action selection arbitrate different competing behaviors 
process take account activation level various input cortical channels previous experience current related action selection contexts 
basal ganglia group functionally related structures 
main output centers parts ventral area send inhibitory signals neural centers brain directly indirectly control voluntary movement cognitive sensory systems middleton 
input comes relevant subsystems brainstem 
prescott appear proposed model system performs action selection similar proven useful complex agent architectures 
arbitrating subsystems part problem action selection 
action patterns sequenced appropriate durations step 
duration actions quick intricate monitored feedback left vagaries spreading activation competing unrelated systems houghton hartley 
animals removed shown capable conducting complex species typical behaviors simply unable apply behaviors appropriate contexts gleitman 
particular grey matter implicated complex species typical behaviors mating rituals defensive maternal maneuvers stern 
appears little literature exactly skills coordinated 
little evidence learned skills stored areas 
know cortical areas involved recognizing appropriate context stored motor skills 
cortical involvement part interface skill modules action selection 
environment monitoring proposal mammalian equivalent environment monitoring alarm systems straight forward 
established limbic system particularly associated nuclei responsible triggering emotional responses salient particularly dangerous significant environmental stimuli 
emotional responses ways creating large scale context shifts entire brain including particularly shifts attention behavior damasio carlson 
response basic perceptual stimuli loud noises rapidly looming objects visual field complex cortical perceptions recognizing particular people situations carlson 
claim system fully understood appropriately send information grey 
system meets criteria alarm system interconnected action selection biasing cortical skill module activation 
discussion produce mapping bod agent attributes neural subsystems primarily workings neural subsystems understood differences decomposition strategies 
primary function bod architecture facilitate programmer developing agent 
consequently complexity kept minimum encapsulation maximized 
evolution hand eagerly overload architectural module particular computational strengths large number different functions 
identified theories neuroscience analogous features bod agents 
describe interesting biological analog mental architecture constructed bod 
structure fact neat inverse surprising theory control perception specifically rensink theory visual attention comprehension rensink 
rensink proposes visual scene essentially covered proto objects monitored parallel vision system 
item fully attended time 
item constructed approximately fingers attention bind proto objects attended fully represented object 
attended objects appear episodic memory associated time 
proto objects may communicate location gist particularly level priming 
striking inversion bod model single point control attention focused brp plan steps governs expression behavior generated number semi autonomous behavior modules 
adaptivity modular systems discussed chapter bod designed support specialized learning 
design learning systems knowledge agent destined know dominant form learning exhibited mature agents nature 
tradeoff bod way designing agents particularly suited forms learning chapter called meta learning learning plans behaviors 
discuss possible strategies bod extensions bod addressing concerns 
action selection requires structure natural extension standard bod architecture allow agent learn new reactive plans 
means done 
commonly attempted ai constructive planning 
process plans created searching sets primitives applied particular order current situation result particular goal situation fikes weld 
kind search proposed seriously demonstrated genetic algorithm ga ga approach combine mutate existing plans calvin 
means learning plans acquire socially knowledgeable agents 
constructive planning intuitively obvious source plan culture 
intuition probably tells consciousness spends time doing acquire behavior patterns 
capacity constructive planning essential feature soar underutilized practice 
suspect case ga type models thinking combinatoric difficulties planning search chapman 
winston states learning take place nearly knows answer certainly true learning plans 
search algorithms planning real time agents highly constrained situations set solutions 
social mimetic learning addresses problem constraining possible solutions 
observing actions intelligent agent provides necessary bias 
may simple mother animal leading children location find food complex imitation complex hierarchical behavioral patterns terminology plans whiten byrne 
may particularly promising way increase intelligence agent learn society fact agent uses intelligence find solution particular confines may enhance solution 
case young language learners regularize constructed languages kirby 
secondly communicating culture may contain intelligence individual member leading notion cultural evolution dennett 
social learning ai explored schaal believe important capacity artificial agents 
problem learning new functional skill modules 
phd theses topic example demiris taxonomy efforts fall parameter learning single skill module behavior 
learning full new representations algorithms actions current state art machine learning 
system certainly built top fine grain distributed representation essentially ann 
state art ann allow learning representation complex diverse modules 
requirements behavior learning system current state art obstacle system capable forms adaptivity described previous section look 
believe require minimum elements shown 
section explains model 
consider behavior skill module system 
representation bod behaviors split functional modules behavior long term memory perceptual short term memory 
persistent representation behaviors representations algorithms belong current perceptual memory 
working memory wm representation behaviors modified current conditions example compensating high wind 
neurological model representations overlap organs example different networks neocortex cerebellum 
behaviors course contain perception action notice bidirectional arrows indicating expectation setting perception see jepson hinton ghahramani 
full path expressed action shown 
takes account standard action selection environment monitoring 
learning arcs removed see recommendations flowing behavior system action selection 
action selection takes account timing provided time accumulator ta see action selections decisions stored episodic short term memory 
expressed action takes account current perceptual information sp ta complete model sp ta expressed behavior wm wm sp ta skill modules sp ta learning action selection architecture allowing adaptation skill modules new plans new skill modules 
icons sensing action lower left right respectively 
dashed lines show flow information active attending system 
dotted lines pathways consolidation learning 
heavy solid line path expressed behavior double line represents constant perceptual pathway environmental alerts 
fine lines indicate system pointed representations system pointed 
current modulated version behaviors wm 
provided separate path basic perceptual reflexes alarm loud noises sudden visual looming 
module recognizing effects labeled sp special perception 
nature system consists perception systems superior inferior connections cortical system reflexive fear responses developed complex stimuli 
probably important isolate fundamental system possible modification skill module learning system 
action selection adaptive provide time accumulator ta proposed henson episodic short term memory postulated large number researchers see mcclelland experiments review 
episodic long term memory included measure consolidated experience represent forms semantic memory homologous 
keeping mcclelland model assumes modules state modules wm wm maintaining complete descriptions 
considered important attribute system needs hold large number things learned quickly allows relatively small amount state 
considered important computer science means reduce probability conflicting data sets feature evolved systems existing organization exploited variety means 
directions neuroscience complex agent architectures fortunately implementing complex system necessary agent applications 
general adaptive needs agent anticipated advance designer discovered implemented process developing agent 
suspect systems discovered explored neuroscience may soon standard functional modules agent architectures way action selection alarm systems 
capacities ascribed smoothing behavior probably functional module 
allows modules create motor plans operate relatively coarse granularity 
allows combination influences multiple modules current situation agent complicating skill modules 
current architecture know explicitly unit ymir th risson action scheduler selects way express messages agent current occupations see sections 
sort capacity number new ai graphics packages allow generation smooth images script discrete events brand baumberg hogg 
fact norm robotics see schaal atkeson atkeson may partially due fact physical agent take advantage physics mechanics smoothing bryson mcgonigle 
robots attempt complex balancing legs providing smoothed balanced motions may deserve dedicated modules models similar cited 
expect sparsely represented records episodic events section standard mechanism 
episodic records useful simplifying reactive plans recording state previous attempts actions reducing chance agent may show inappropriate redundancy trying solve problem 
mentioned previously episodic memory source consolidating semantic information noticing regularities environment agent performance smart 
records turn specialized learning systems particular problems full blown skill learning system implemented 
additional humanoid subsystems researchers currently working emotion modules complex agents 
emotions provide complex reinforcement signals learning behavior represent motivation level tu 
functional considerations addressed bod see example chapter 
explicitly modeling human emotions may useful hci standpoint breazeal provide agent model necessary comprehend human social interactions de waal 
am skeptical need practicality independent emotion module reasons 
great deal evidence basic emotions evolved independently different times history 
suggests single emotion module appropriate 
second emotions intimately involved action selection 
vertebrates emotions serve specialized mechanisms focusing attention including deactivating large sections cortex damasio 
fact damasio implies species typical behavior pattern effectively emotional response 
suggests impossible separate emotions motivation action selection 
consequently believe emotions best modeled existing bod framework 
contentious area research consciousness explicit knowledge 
models dissertation claims regarding aspects conscious information explicitly known 
due lack interest capability 
simply necessary feature particular models 
notice lack data unclear consciousness affects human action selection dennett 
imagine modeling current theories consciousness norman shallice dennett methodology dissertation 
bod hypothesizes 
intelligence broadly modular 
arbitrating modules requires specialized mechanism action selection 
complex behavior requires hierarchical sequential structure arbitration 
switching attention complex behavior new salient features events requires specialized mechanism operating parallel 
chapter shown hypotheses reasonable natural artificial intelligence 
shown relationships bod architectures ann research brain science suggested possible areas 
hope day rich exchange researchers complex agent architectures behavioral neuroscience currently ann neuroscience 
chapter extending bod industrial applications bod industrial setting 
believe reasons 
bod designed address concerns industrial development processes 
bod agents designed modular easy maintain easily decomposed multi programmer projects easy integrate 
behavior structure incorporate existing packages solutions posh control structures designed intuitive possible conventional sequential programmers 
second reason twice worked industrial semi industrial research settings 
unfortunately projects reached completion classified 
blue sky virtual reality vr research effort entertainment unfortunately terminated closed digital research division 
second dialog tutoring agent development human computer research centre scotland 
case leave project months due personal obligations 
projects may appear similar deal software agents 
fact vr project involved building personalities similar artificial life projects demonstrated dissertation 
dialog agent conventional large scale ai project 
requires integrating disparate technologies functioning coordinated system 
vr project required coordination time primarily disparate teams designers 
industrial applications similar needs 
example medical monitoring systems doyle intelligent environments coen 
problem system required prioritize conflicting goals integrate multiple sources information potentially viewed bod agent 
rest chapter describes progress projects mentioned 
describe exciting possibilities bod agents serve final examples bod methodology 
bod tutoring dialog systems dialog systems currently require enormous amount engineering typically result relatively brittle systems 
section reports exploring reactive planning general bod particular simplifying dialogue system design 
bod dialog project considering example problem dialog management system trains allen 
system major effort addressing complete problem dialog including having system capable planning acting discussing plans acquiring goals verbally 
trains system served assistant manager attempting deliveries commodities bananas orange juice number different cities 
addition various cities various important resources trains cars processing plants raw commodities 
cities connected rail transport requires scheduling time space 
build dialog system similar trains list rough set capabilities expect agent 
case existing system guide assume agent eventually need set speech acts capabilities 
organizing gross behavior agent speech acts simple primitives merely indicate place execution typing name 
practice implementing bare representative functionality part early design called ood 
roughly trains speech acts initial list primitives accept reject proposal dialog partner suggest proposal particular engine location particular task request information particular current plan supply info response request check agreement particular necessary due misunderstandings 
working primitives construct high level plan dialog management just lines see table 
sensory checks context indicated parenthesis 
primitive actions listed bold face 
highest level concern plan simply agent take turn wait quietly 
decided take turn highest priority behavior fulfill discourse obligations including obligation try understand previous statement successfully parsed 
existing obligations highest priority resolve inconsistencies agent current understanding indicated having requirement entailed task bound value 
indicates need clarification requirement current task 
inconsistencies outstanding task perform highest priority complete task case trains usually involves turn request obligation check request false reject request obligation check request true accept inform obligation supply info comprehension failure check utterance bound non requirement requirement checked check task check requirement requirement bound pick unbound req suggest req task request task wait table table indentation indicates depth plan hierarchy 
notice action primitives generally assume deictic perception primitive set attention particular task requirement 
assigning particular resource particular slot problem space 
task agent having social personal goals seek establish new 
simple plan indicates number elements state agent required keep track 
elements turn indicate behaviors agent needs established 
agent needs know currently believes turn speaking 
may simple bit information dependent number perceptual issues dialogue partner actively speaking agent completed utterance case expect agent take time processing information 
agent may capable instructed wait quietly 
waiting time bounded 
building behavior library drive structure approximation primitives plan arranged behaviors shown 
constructive planning required trains replaced fairly short reactive plan omitted space supplemented search algorithm finding nearest resources 
suggests reasonable initial drive structure trains dialog agent turn turn wait speak check request check task check requirement reject accept supply info task bound non requirement requirement checked requirement bound pick unbound req suggest req task hear utterance listen request obligation inform obligation comprehension failure cut behavior decomposition trains type dialog agent 
behavior diagrams dissertation contents behavior just names primitives behavior provide 
represents step bod initial decomposition process see section arrows vaguely indicate general information flow behaviors 
priority releaser action noise listen need answer think turn take turn wait small plan serves parallel operating root action selection entire dialog agent 
plan eventually derived table fit label take turn 
reactive plan scheduling including call search algorithm fit think 
drive structure allows speaker interrupt listen highest priority 
entire system relies basic behaviors shown 
act attempting take turn set flag need answer problem requiring domain specific planning encountered 
solving problem unset flag turn operate 
notice drive structure goal terminate due success 
lowest priority element precondition drive terminate failure wait timer limit wait fails 
scaling system system obviously hides great deal complexity problems parsing dialog input constructing sensible output completely untouched 
hand bod system sufficiently modular procedures may primitives black boxes ai systems language parsing generation constructed 
analysis preliminary organizing complex dialog project 
intention bod organize dialog management complex system shown 
problem domain tutoring basic electricity electronics hope integrate systems capable wide range behaviors assisting students 
examples desired behavior include analyzing incorrect answers order diagnose learning failure providing multi turn method tutoring lead students correcting basic misconceptions 
useful real students system need sufficiently reactive allow student solve problem prematurely able branch greater depth explanation response query errors student 
design specifications tutoring system described core 
specialized learning dialog agent bod designed enable learning behavior rate state varies chief cues state clustered particular behavior 
machine learning techniques constructing behavior part state 
promising research direction incorporate statistically acquired semantic lexicons lowe dialogue agent 
quickly broaden scope agent ability recognize conversational contexts 
agent lexicon recognize entire classes semantically similar sentences programmed interaction 
similarly incorporate statistically acquired mechanisms natural language generation knight knight oberlander brew dialog agent 
allow varying generative output dialog system appropriate various audiences simply training mechanism appropriate corpus 
ultimately interesting attempt learn dialog patterns directly corpora 
case create learning eliza basic turn mechanisms built system 
system vacuous searle apparent gossip level conversations 
bod integration ai characters vr entertainment evolutionary utility play considered lie enabling individual acquire complex behaviours learn appropriate situations express byers byrne 
section addresses problem incorporating pre packaged artificial intelligence creative play environment child 
character architecture constructive narrative research agents entertainment concentrates problem combining concept script notion autonomous reactive characters hayes roth van gent lester stone andr 
better approach constructive narrative eliminates problem changing top level creative design script cast characters 
simplifies task player removing need character addition substitution alteration removal 
penalty removing substantial element narrative structure sequential order events 
problem addressed creators role playing adventure games 
solution plot desired advanced knowledgeable characters objects revealed locations 
structure produced geographic space character personalities 
personality traits loyalty maintain order despite large cast autonomous character tying particular characters particular locations 
developing characters requires agent architecture powerful support complexity 
requires sufficient modularity allow reasonably quick construction behaviour patterns 
virtual reality agent architectures fundamentally behaviour partially reactive see sengers review critique 
reactive behaviour ai revolution late kortenkamp primarily triumph design approach 
behaviour ai simpler design monolithic intelligence system allows decomposition intelligent behaviour easy program modules localised control structures 
specifying intelligence reactive removes complex problems learning constructive planning agent 
spite limiting potential complexity agent capabilities behaviour approach successful achieving interesting believable characters fully human specified fully machine learned approach simply empowers human designer 
sets problems associated established ai complex agent architectures 
getting correct level control scripted personalities behaviours 
argued chapter hybrid architectures truly reactive support abrupt frequent changes context possible play scenario 
reactive elements constrained switching new complete plans exceptional circumstances example fire alarm sounded 
working children consistent sort responsiveness required order respond unexpected assistance interruption child 
events require movement script restarting changing scripts 
hand purely reactive architectures scripting coherent behaviour difficult 
words constructive play domain requires agent architectures see chapter 
set problems associated technical difficulties controlling real time multi modal vr system 
ai architectures support millisecond precision modality coordination necessary believable engaging real time interactions 
concerns critical vr particularly apparent dealing dialogue gesture th risson 
spark life working kris th risson developed solution problems spark life sol 
sol essentially ymir th risson extended posh action selection see section details extension 
ymir highly modular hybrid architecture combines features classical behaviour ai provides system simulate great detail psychosocial dialogue skills humans 
real time face face dialogue encompasses broad range perceptual cognitive action requirements 
ymir addresses phenomena including natural language multi modal input output facial expression gesture speech body language load balanced handling time short reactive behaviours fixation control execution seconds multi modal actions employs modular approach enables creation complex human behaviour 
sol consequently encompasses capabilities multi modal perception action real time speech input output memory planning 
sol modularity combined robust simple control ideal constructive play allowing easy additions modifications 
adapting bod sol constructive narratives sol architecture provides framework middle layer proposed design approach 
ai facilitates creation socially engaging world world requires careful creative design rich visual behavioral structure 
sol behaviour posh action selection excellent platform practicing bod 
bod adapted somewhat sol 
ymir architectures including prs soar represents explicit knowledge single general purpose knowledge base 
sol vr timing skills hinge particular ymir motor representation motor lexicon sol follows ymir representational framework including knowledge representation 
modularity knowledge documented ymir sol dividing knowledge base variety knowledge areas 
motor lexicon hierarchical structure form modularity quite useful incremental development 
motor lexicon elaborated new actions automatically absorbed sol ymir action scheduler specifically referenced plans 
link perception action explicit standard bod longer clear sol 
responsibilities ai developers development constructive play vr world requires development levels 
high artistic design level creating story characters 
middle behaviour design level creating personality character agents 
low vr design level basic capabilities appearances 
ai developers necessarily expected sufficiently skilled artists create plots characters needed fully engaging interactive play experience 
ai attracts requires developers belief ability replicate thinking skills 
artists devote years attention formal education perceiving constructing things situation interesting fun 
design process places ai developer intermediary artistic engineering aspects project 
ai developer best situation understand requirements restrictions project considerable responsibility communication developing solutions 
ai expert responsible set motivations goals knowledge personality quirks skills creating agent behave coherently 
rich virtual environment designed free creative play autonomous character able prioritise goals display intentions 
exhibit persistence resolution time aware opportunistic 
short recognisable personality 
developing initial set character attributes necessarily solely task agent expert 
necessarily task creative artists 
artist responsibility provide formed interesting characters skills situations design potential plots plot twists 
level design process model 
industrial design best artists team agent developers help artists understand limits agent behavioral expressive capabilities 
agent developers constrained particular platform artificial agent implemented 
robotics constraints come robot hardware virtual worlds come graphics environment agent embodied 
creating platform level design process 
responsibility ai developer provide requirements understand constraints underlying platform 
character personality developer may may correct person develop agent behavioral platform depending platform context provides basic behaviours behaviour primitives agents 
drawing line levels difficult 
example may sense put collision detection motor smoothing world graphics environment efficient performance system cleaner implementation easier debugging 
nature vertebrates dedicated systems providing smoothing carlson able rely physics smoothness consistency 
simulated world division agent perception world may defined 
implementations level point contention side fence graphics ai different skill sets developed people working side may prefer different solutions problems hand 
grossly levels design process model correspond different sides sol 
interface levels leads specifications personalities drives interface levels lead implementation behaviours 
emphasised bod design process happen iteratively 
forms technical constraint recognised development begun 
system develops provide considerable creative inspiration designers 
importantly early users particularly coming outside project discover shortcomings unforeseen creative potential system 
sources information lead periods redesign renegotiation various levels project 
personality may demonstrated subtle motions best provided behavioral level complex behaviour may require suggest changes plans drives 
levels design process available cyclic development reanalysis 
ai programmers working primarily level abandoned try satisfy potentially impossible constraints coming isolated processes side project 
case study creating characters adventure narrative design process described developed part research effort lego create interactive virtual reality entertainment package allows children engage creative constructive play established action adventure framework 
project illustrates design principles gives indication efforts difficulties involved 
refer ai portion large scale multi faceted research effort castle character project 
effort included detailed relatively large virtual world castle situated rolling hills surrounded mountain range 
full moon hangs sky sun just horizon 
users enter world desktop fully embodied virtual humanoid lego characters full body tracking immersive glasses displays 
high level design case castle character project character content predetermined virtual version active product 
general appearance characters outline personalities world developed part marketing stories created 
domain magic castle inhabited evil knight various magical entities 
larger vr research effort castle project real time interactive virtual reality environment 
image lego group dedicated ensuring simply exploring space intrinsically rewarding moving characters virtual experience alive magical 
example sol character named 
talking flying green lego dragon 
discuss castle encouraged demonstrate flying ability 
step creating interesting narrative set characters understand constraints task system 
set constraints comes character environment size features open spaces castle world complex interesting large relative size characters constrains characters motions inside castle 
compensated setting gross motion large character flying sword space surrounding castle 
set constraints dependent expected users system 
expected users young na virtual worlds importantly exposed system minutes total considered essential characters interesting user deliberately attempted interact 
solution characters interact 
designed react visitor domain way encouraged exploration intrusive user experience 
maintain interest characters act interact way generate continuous change 
steady state system characters reach user passive 
constraints virtual environment pre existing product meant change take form arrivals departures gross gestures 
effect achieved designing characters various incompatible goals 
example witch frequently fly castle quest intruders 
intruder little land nearby slightly approach stranger 
presence attract characters turn designed fear flying bats 
having characters attracted situations crowds characters help maintain amount free space needed character motion 
addition limits number simultaneous interactions amount confusion 
allows designers quickly focus interest short term visitor 
notice stateless reactive social behaviours flocking reynolds matari sufficient characters doing attracted avoiding obstacles 
displaying personalities 
visitor learn individual character traits manipulate deliberately 
exploring personality space characters world part puzzle part fun 
encoding personality creating rough description desired world task develop cut description reactive plans encode character personality 
starting descriptions characters set marketing department product keeping mind constraints determined evaluating task character described terms goals drives 
behaviour associated achievement goals visually described 
done team house artists external creative consultants ai team participating creatively technically informed resources 
personality characters sketched steps follows goals gross behaviours determining necessary preconditions 
example witch described goal castle air 
fairly high priority motivation reduced performance act general circles castle times 
priority landing room seen intruder longer desires fly 
avoids bats 
determining necessary behaviour primitives behaviour states 
example witch remember saw intruder patrol 
bat approach intruder closer closer successive 
state bat behaviour enables keep track current level turn determines trajectory 
characters friends playing 
remember friendly feel particular person 
seeing user avoiding walls castle flying landing behaviour primitives required agents 
developing testing behaviour libraries scripts 
architectural methodological support developed level discussed 
developing perception action primitives developing behaviour libraries task personality designer connects task environment architects 
castle character project potential difficulties relationship overlooked caused greatest difficulties ai effort 
possible approaches building basic movement primitives 
straightforward approach character developers program behaviours scratch models prepared graphic artists 
general problem approach mentioned earlier ai programmers necessarily artists students natural motion 
animals evolved complex motion behaviours constrained physical forces structures normally modelled artifact particularly designed run real time difficult take account 
animals constrained habits behaviour general species specific individual 
motion primitives achieved ai programmer process programming time consuming 
main source behaviors sol character flying talking dragon 
potential source behaviour primitives explored castle character project efforts team animators working project 
idea segment animations sets behaviours suitable exemplars various behaviour primitives 
continuous variety behaviour derived combining connecting fixed sets canned behaviours 
unfortunately animations proved slow difficult develop 
importantly format animations produced determined incompatible primary real time virtual reality environment 
explored intermediate solution purpose built animation tool quick dirty animation segments stored appropriate format main vr engine 
technique creating life motion castle guard responded approaching camera observer turning facing 
intelligence character purely reactive sol show promise technique 
motion capture humans participating final source intelligence explored project 
potentially served source primitives ai alternative explored due lack time 
dissertation chapter quoted part distinctive concerns software engineering today exactly set forth chapter original version mythical man month design build set programs system design build program system robust tested documented supported product maintain intellectual control complexity large doses 
complex craft demand continual development discipline learning compose larger units best new tools best adaptation proven engineering management methods liberal application common sense god recognize limitations 
brooks pp 
bod developed issues mind 
chapter description integrate bod real world industrial projects 
thought character tutor built edinburgh conventional personality 
application involves juggling priorities chosing possible actions regulating interpreting multiple environments contexts parallel profit bod design 
chapter dissertation behavior oriented design bod methodology creating complex adaptive agents capable addressing multiple conflicting goals 
bod consists architecture design process 
architecture modular specialized representations associated directly code acting sensing 
specialized representations facilitate learning modularity facilitates design 
potential conflicts modules resolved reactive plans 
details reactive planning system contributions dissertation literature research supporting approach experimental research demonstrating 
literature research primarily chapters artificial intelligence natural intelligence 
experiments primarily chapters simulated blocks world real mobile robots primate learning transitive inference social behavior primates 
working bod systems fully chapters 
complete listings contributions chapters please see chapter 
chapter concentrates restating important lessons dissertation 
design key success new ai important aspects reactive revolution late overlooked 
break throughs robotics associated reactive behavior systems usually attributed loss deliberate planning explicit representations 
real contribution reactive paradigm explained nearly decade earlier learn don practically know winston extension plan nearly 
reason simple combinatorics chapman wolpert mcgonigle chalmers 
evolutionary linguists case reasoning researchers try tell humans intelligent apes just creative ability plan excellent methods storing transmitting solutions manage find hammond knight 
reactive behavior ai facilitate advance ai ways 
severely planning state consequently learning reactive approach increased default emphasis largest problems ai software general design 
second behavior approach fashionable proven software design methodology modularity 
importance human design reactive systems recognized 
despite extensive mention design descriptions best known early architectures brooks maes 
users tend design agents hand architectures prs georgeff lansky intended exploit productive planners soar newell intended learn 
emphasizing modularity behavior movement important engineering contribution emphasizing specialized learning brooks pp 

specializing learning increases probability success increasing utility reliable agent 
similarly modularity simplifies program design locally increasing probability correctness 
learning important sufficient bod emphasis adaptive state perception indicates learning adaptation different time scales absolutely critical intelligent agent 
learning system achieve ai 
children highly learning machines take years acquire useful behaviors degree proficiency 
consequently building child ability science technology artificial system limited market window best knowledge designers impart 
learning necessary giving agent information designer know advance layout owner home 
useful save designer development time 
process making learning design process 
learning systems design critical 
bod new ai better behavior oriented design maximizes benefits behavior ai design process modularity 
bod addresses difficulties inherent arbitrating coordinating behaviors specialized representation posh reactive plans 
critical aspects posh action selection supports basic reactive plans allow flexible focussed action selection limits stack growth allows cycles hierarchy supports pseudo parallelism changing attention higher priorities restarts plan hierarchy root terminates 
bod posh action selection provides features eliminating autonomy heterogeneity underlying behaviors 
posh plans communicate behaviors interface supported behaviors 
bod leverages design contributions significant improvements software engineering years object oriented design ood 
example bod addresses issue behavior decomposition analogous issue agent decomposition facing mas community rule thumb object decomposition developed ood community 
behavior decomposition determined adaptive requirements various primitive actions 
bod heavily emphasizes iterative design 
fact bod exploits ood implies libraries behaviors easily cleanly developed object oriented language bod continue absorbing advances ood community 
bod doesn require changing architectures demonstrated bod greater lesser extent existing agent architectures 
means bod improve existing projects new projects reason implemented agent architectures simply object oriented languages 
long neat way express critical idioms action sequences basic reactive plans long learning behavior partly modularized bod help keep agents simple successful 
get maximum benefit bod development process conditions need met underlying architecture 
needs reactive action selection capable supporting kinds situations 
things need checked time 
things need considered particular contexts 
things reliably follow 
posh action selection supports situations drive collections competences action patterns respectively 
second ways modularize project code data preferably specialized representations particular learning tasks 
way tagging grouping associated primitive actions data supports 
structure development process designer design team come regularly reevaluate current structure agent 
provides opportunity agent clearer way 
regular housekeeping way keep project clean coherent 
said chapter main motivation conducting research create platform build psychologically plausible agents models 
motivation building exploring agents models bod just necessary step process 
doubt people agent community discover methodological insights significantly improve current bod process 
suggested chapter additional mechanisms may compliment architecture 
hope community able share insights improve field 
appendix posh code appendix shows clos code current version posh action selection see section additional code making things gui debugging posh code 
may want skip sections move appendix see behavior libraries 
basic posh classes file defines drive collection 
posh lisp joanna bryson june developed old code constants long things stay viewing default minutes sgi linux minutes lucid seconds running debugged code default viewtime debug schedule time note am assuming nil indicates times note change change corresponding new instance function defclass sol generic name accessor name initarg name initform name preconditions easy check quickly 
preconditions accessor preconditions initarg preconditions initform postactions post special bbs succesful completion note mechanism getting default done failed canceled messages done schedulers 
postactions accessor postactions initarg postactions initform string name blackboard accessor initarg initform cb thing really gets executed 
accessors defined 
content accessor content initarg content initform nil absolutely killed action scheduler timeout accessor timeout initarg timeout initform invalid remembering chosen rep came script file timeout rep accessor timeout rep initarg timeout rep initform nil relative starting killed action scheduler accessor initarg initform accessor initarg initform debug schedule time debug tells ultimate root motivation behavior drive name accessor drive name initarg drive name initform raw prototype generic methods send sol object content optional generate rec sol object content optional generate ready object checks preconditions true fire object tim viewtime execute thing object fire postactions object tim viewtime result execute object postactions new instance object drive name tim key postactions nil preconditions nil new instance gets put schedule action pattern called 
see comment file 
command object tag object action object accessors content field value object timestamp object find bbitem bb tag bb optional result find particular thing find prereq bb command tag bb find type tag action bbitem sol generic sg sol generic bb entry key command timeout timestamp nil generic functions related constructing datatypes 
bunch accessors content content key command tag action value nil timestamp fix content action sg action const bbitem content timeout optional timestamp nil really method type bbitem content bbitem bbitem sol generic bbitem item bbitem important check bb optional viewtime default viewtime maintain bb transfer stuff schedule cancel outdated things sol schedule item bbitem tim bbitem method put bbitem schedule action scheduler optional viewtime default viewtime run schedule processing cancel outdated 
driven action scheduler drive name debug stream optional viewtime action scheduler attend descendents specified drive 
reset debugging erase schedule class sensing primitives predicates defclass sol sense sol generic gets sense fired accessor initarg initform nil sense functions fire object tim viewtime execute thing object class exists tag collective classes 
defclass sol sol generic object currently active need activated 
active accessor active initarg active initform nil sol methods cancel obj wipe obj schedule schedule element object element tim sol action pattern simple structure encoding sequences parallel sets behaviors entirely triggered single environmental condition 
pattern started complete order failure element 
case remaining pattern dies 
notes elements listed firing order 
element looks invocation list function name arguments takes 
set elements clustered list fired parallel 
examples sequence 
elements sequence normally return true value 
false nil cause sequence terminate intention action pattern fired unit cognitive checking elements 
fact failed action pattern kind exception grabs cognitive attention see norman shallice 
action patterns usually aborted failed pre conditions elements element execution supervised wanting 
flexible system examines external state chosing elements see sol competence 
defclass sol action pattern sol elements accessor elements initarg elements initform remembering printed version esp senses ap guts accessor ap guts initarg ap guts initform sol action pattern methods fire object tim viewtime just calls activate class activate object tim create schedule children elements activate run scheduler fire new instance object drive name tim key postactions nil preconditions nil new instance gets put schedule action pattern called 
see comment file 
check parse check elements exist run roots scanning newly written script file debugging tool sol competence provides reactive plans prioritized sets procedures subgoals attaining particular goal preconditions determine applicability 
notes provide log tell competence doing 
beginnings labeled active ends labeled done goal passed fail triggered 
possible control simply passed children case terminating symbol log 
code doesn log 
triggers doing complicated things reasonable send blackboards 
words may want depends abstraction level primitives 
prefer keeping cognitive 
sol anyway book keeping seperate real active perception 
competence element 
trigger object action pattern nil see note 
element fired trigger succeeds trigger tested preconditions succeed retries equal 
tries integer number times element gets fire fails 
elements tries fail 
think logging stuff slow right composited stored raw 
jjb jan competence log command tag timestamp defclass sol element element fire 
trigger accessor trigger initarg trigger initform nil drive belong 
executing drive name accessor drive name initarg drive name initform assigned sol defclass competence element sol element ce label accessor ce label initarg ce label initform fix cel action gets executed action accessor action initarg action initform nil determines times element tried ignored neg 
retries accessor retries initarg retries initform competence accessor competence initarg competence initform competence defclass sol competence sol elements listed order priority highest 
elements accessor elements initarg elements initform goal element competence reward old edmund stick slot competence element 
goal accessor goal initarg goal initform nil place swap real preconditions waiting child temp preconditions accessor temp preconditions initarg temp preconditions initform nil noticing strategy isn working handled episodic memory allows act learning simple rules retrying 
see note jjb jan accessor initarg initform nil competence methods ready regular ready checks triggers activate put scheduler deactivate leaving scheduler fire run new instance object drive name tim key postactions nil preconditions nil new instance gets put schedule action pattern called 
see comment file 
check parse check elements exist run root scanning new script file truncate log remove log entries older particular timestamp 
drive collection provides root behavior hierarchies decision modules active determining create behavior 
modelling action scheduler outer loop entire structure 
kinds drives 
regular drive collections treat frequency number passes turns executions 
useful discrete time step simulations 
real time drive collections consider frequencies hertz fire time passed previous execution 
note drive name name defined sol element 
defclass drive element sol element hold sg firing done drive 
drive root accessor drive root initarg drive root initform de drive root rep accessor drive root rep initarg drive root rep initform dep determines times element tried ignored neg 
frequency accessor frequency initarg frequency initform write frequency frequency rep accessor frequency rep initarg frequency rep initform nil figuring time fire fired accessor fired initarg fired initform drive collection accessor drive collection initarg drive collection initform drive collection defclass drive collection sol elements listed order priority highest 
elements accessor elements initarg elements initform generally nil kill agent drive collection terminate 
keep non agents 
goal accessor goal initarg goal initform nil defclass real time drive collection drive collection just treats frequency differently drive methods file see posh run lisp generic methods structure lives bulletin board content section sol message 
assumes content command tag drive name action value timestamp value number values timestamp optional 
evolved bit specification necessary cart information 
bbitem command tag drive name action value timestamp timeout command request done cancel pending fail active request serviced system means needing scheduled 
done notification ordinary completion 
cancel means item canceled removed schedule completing done timeout done cancel method 
fail means command failed usually form radical failure feedback perceptual system 
pending means scheduler hasn gotten implementation far may help expected delays active plan meta modules supervising offspring stay scheduler 
fake accessors get stuff content 
nasty accessors replicated bit just 
defmethod command sg sol generic car content sg defmethod tag sg sol generic content sg defmethod action sg sol generic content sg defmethod value sg sol generic content sg defmethod timestamp sg sol generic caddr content sg defun content key command tag action value nil timestamp value setf value list value timestamp list command cons tag cons action value list command cons tag cons action value timestamp defmethod fix content action sg sol generic action setf content sg action construct bbitem content string defun const bbitem content drive name timeout optional timestamp nil bbitem command car content tag content drive name drive name action content value content timeout timeout timestamp timestamp timestamp caddr content construct content bbitem defmethod content bbitem bbitem content command bbitem command tag bbitem tag action bbitem action value bbitem value timestamp bbitem timestamp tag sg competence element name competence element name sg name action 
wasn problem actions just names functions unclear 
defmethod bbitem sol generic sg sol generic key command timeout timestamp nil bbitem command command tag tag sg drive name drive name sg action action sg value value sg timestamp timestamp timestamp get internal real time timeout timeout defmethod sol generic bbitem item bbitem instance sol generic name bbitem tag item content content bbitem item drive name bbitem drive name item timeout bbitem timeout item defmethod sol generic function func function optional name anonymous function instance sol generic name name content content command request sort tag name action func value nil defmethod sol generic function new local versions send sol rec sol assume real time sent real time 
really fix posh lisp deal non real time 
notice real time tim 
defmethod send sol sg sol generic content tim optional default viewtime declare special bb push const bbitem content drive name sg get internal real time tim bb time doesn matter tag content see find bbitem bb ignoring drive sure right defmethod rec sol sg sol generic content tim optional declare special bb cont const bbitem content drive name sg tim find bbitem bb bbitem tag cont bb returns particular tag defun find bbitem bb tag bb optional result nil item car bb cond null item result eq bbitem tag item tag push item result find bbitem bb tag cdr bb result find bbitem bb tag cdr bb result ymir pre labelled conditions pre reqs auto generating things aren advance 
command content bbitem see comments prereq command tag find single prereq defun find prereq bb command tag bb item car bb cond null item nil eq bbitem command item command eq bbitem tag item tag item find prereq bb command tag cdr bb find object happy defmethod ready sg sol generic preconditions sg cdr car car null done return true declare special bb find prereq bb prereq command prereq tag bb return nil fake ymir mechanism methods check bb bb send sol adds sends things action scheduler schedule 
viewtime long message stays bb default minutes 
note trimmed real time regardless agent running real time 
defun check bb optional viewtime default viewtime declare special bb unexamined cdr bb cdr unexamined item car bb car unexamined tim get internal real time null item bb cond bbitem timeout item timeout 
tim bbitem timeout item timed drop 
eq bbitem command item request show cancel 
push bbitem command cancel tag bbitem tag item action bbitem action item drive name bbitem drive name item value bbitem value item timestamp tim timeout tim viewtime bb setf bb delete item bb count eq bbitem command item request command process 
eq bbitem command item pending remove request 
sol schedule item tim setf bb delete item bb count ignore defun check bb schedule list objects executed notice schedule keep getting changed scheduler runs 
put schedule convert sol generic object isn 
goes schedule element 
changed june longer passing names objects longer names defined environment 
new instances garbage 
defmethod sol schedule item bbitem tim declare special schedule act bbitem action item cond typep act sol generic subclass push copy push new instance act bbitem drive name item tim schedule typep act function typep act method reg 
func call push sol generic bbitem item schedule build object 
complain error format nil unknown object type passed sol schedule item defmethod sol schedule executes 
notice things drives competences stay schedule executed 
just lower priority 
defun action scheduler optional viewtime default viewtime declare special schedule unexamined cdr schedule cdr unexamined obj car schedule car unexamined tim get internal real time null obj schedule cond timeout obj timeout 
tim timeout obj timed cancel 
send sol obj content command cancel tag tag obj action action obj value value obj timestamp tim tim viewtime setf schedule delete obj schedule count ready obj ready fire 
equal fire obj tim viewtime preserve setf schedule delete obj schedule count defun action scheduler action scheduler modified drives 
preserves info drives currently attended attention switches long behaviors time 
return value indicates currently scheduler belongs chosen drive 
calling function add drive root schedule get executed cycle 
defun driven action scheduler drive name debug stream optional debug action nil debug non action nil viewtime default viewtime declare special schedule debug stream setf debug action nil debug non action nil unexamined cdr schedule cdr unexamined obj car schedule car unexamined tim get internal real time nil flag need restart root null obj cond timeout obj timeout 
tim timeout obj timed cancel 
send sol obj content command cancel tag tag obj action action obj value value obj timestamp tim tim viewtime setf schedule delete obj schedule count drive member obj drive name right drive ready obj ready fire 
setf debug action format debug stream firing action drive name obj drive name equal fire obj tim viewtime preserve setf schedule delete obj schedule count firing old debug non action drive member obj drive name format debug stream action ready drive obj drive name format debug stream action wrong drive drive name obj drive name defun driven action scheduler defmacro drive member sg drive name eq drive sg drive name debugging 
defun drive member sg drive name drive name sg error format nil missing drive object called name sg sg eq drive name sg drive name fire evaluates action run notes records return value 
winds 
return value true postactions fired 
changed june accept function action jb defmethod fire obj sol generic tim optional viewtime default viewtime declare special bb won apply action obj value obj won progn push bbitem command done tag tag obj action action obj drive name drive name obj value won timestamp tim timeout tim viewtime bb fire postactions obj tim viewtime done progn push bbitem command fail tag tag obj action action obj drive name drive name obj value won timestamp tim timeout tim viewtime bb fire postactions obj tim viewtime fail won fire sol generic letting rest meta structure know going turn 
defmethod fire postactions obj sol generic tim viewtime result reqs postactions obj cdr reqs car reqs car reqs null done return true eq prereq command result send sol obj content timestamp tim command result tag prereq tag action prereq tag tim viewtime send sol obj content timestamp tim command prereq command tag prereq tag action prereq tag tim viewtime useful debugging code defun reset declare special schedule bb setf schedule nil setf bb nil sol methods see reason generic joanna jan break didn triggering didn check hard jb nov new instances keep old tag follow happening 
defmethod new instance ap sol generic drive name tim key postactions nil preconditions nil instance sol generic ap drive name drive name name name ap postactions append postactions ap postactions preconditions append preconditions ap preconditions ap timeout tim ap add plus debugging 
content content tag list tag ap content content tag tag ap command instance action action ap value value ap timestamp tim defmethod new instance sol generic don 
defmethod cancel sg sol generic declare special schedule tag tag sg cdr schedule cdr item car schedule car null setf schedule eq tag tag item push item sol methods notice action pattern children tag ap easily identified 
see comments sol schedule 
notice important new instance modifications aren permanent 
modified june see sol schedule 
returns modified schedule 
called functions methods new instance sol generic gets called july defmethod schedule element ap sol element tim declare special schedule cond typep element function function method call 
typep element method push instance sol generic name tag ap content content command request tag list tag ap el tag tag ap action element value value ap timestamp tim drive name drive name ap preconditions postactions timeout tim ap ap schedule typep element competence element new 
push new instance action element drive name ap tim preconditions postactions schedule typep element sol generic subclass 
push new instance element drive name ap tim preconditions postactions schedule complain error format nil unknown object type schedule element element defmethod schedule element sol sense methods defmethod fire obj sol sense tim optional viewtime default viewtime declare special bb won eval obj won progn push bbitem command done tag tag obj action sensed drive name drive name obj value won timestamp tim timeout tim viewtime bb fire postactions obj tim viewtime done progn push bbitem command fail tag tag obj action sensed drive name drive name obj value won timestamp tim timeout tim viewtime bb fire postactions obj tim viewtime fail won fire sol sense sol action pattern methods action pattern objects schedule leave kids orphans 
consequently activate object 
defmethod fire ap sol action pattern tim optional viewtime default viewtime activate ap tim element sequence previous element preconditions declares finished postcondition 
list element list indicates number elements go parallel share prereq contributes sequence step prereq 
defmethod activate ap sol action pattern tim send sol ap content command active tag tag ap action action ap value value ap tim ap el car elements ap car els els cdr elements ap cdr els sym nil nil nil null el cond el action pattern list indicates parallel chunk ell car els car cdr els cdr null ell setf sym list tag ap gensym schedule element ap ell list prereq command result tag sym tim push prereq command done tag sym setf sym list tag ap gensym schedule element ap el list prereq command result tag sym tim push prereq command done tag sym defmethod activate sol action pattern creates new temporary instance named action pattern putting scheduler 
notice tag timeout 
defmethod new instance ap sol action pattern drive name tim key postactions nil preconditions nil instance sol action pattern ap drive name drive name elements copy elements ap drive name name name ap postactions append postactions ap postactions preconditions append preconditions ap preconditions ap timeout tim ap add plus debugging 
content content tag list tag ap content content tag tag ap command active action action ap value value ap timestamp tim defmethod new instance sol action pattern fix spec allows parallel elements sort priority levels competences try posh script doesn support rush haven really checked 
returns copy 
defmethod copy elements ap sol action pattern drive name elist copy list elements ap els elist cdr els el car els individual priority list car els null els elist el progn setf el copy list el setf car els pls el cdr pls null pls el typep car pls sol sense setf car pls instance sol sense car pls drive name drive name action function done copy list set copied list priority typep car els sol sense setf car els instance sol sense car els drive name drive name defmethod copy elements sol competence competence methods check competence element ready 
lot previous checks triggers met 
defmethod ready compel competence element reqs preconditions action compel cdr reqs car reqs car reqs null done get trigger 
declare special bb find prereq bb prereq command prereq tag bb return nil trigger compel trigger trigger compel nil defmethod ready competence element triggers regular sol generics case just fire action patterns get fired rapidly going scheduler regular action patterns 
class type checking anyway think ll just leave gui 
defmethod trigger trig sol generic fire trig get internal real time defmethod trigger trig sol action pattern el car elements trig car els els cdr elements trig cdr els null el sense act function typep el sol generic trigger el apply el nil return nil inverse sol action pattern activate notice copy preconditions gets fire defmethod activate comp sol competence tim send sol comp content command active tag tag comp timestamp tim action action comp value value comp tim comp setf active comp setf temp preconditions comp preconditions comp push competence log command active tag tag comp timestamp tim comp jjb jan defmethod deactivate comp sol competence command tim send sol comp content command command tag tag comp timestamp tim action action comp value value comp tim comp setf active comp nil push competence log command command tag tag comp timestamp tim comp jjb jan scheduler fired add back schedule done add chosen element post preconditions set element runs 
temp preconditions regular preconditions competence see activate notice requires element name core element stands identity name global environment 
messy best thing think match edmund need keep track number times individual element triggered ymir environment 
modified july deal priority levels cleverly 
randomize priority normally ready anyway 
defmethod fire comp sol competence tim optional viewtime active comp activate comp tim activate active 
ready goal comp deactivate comp done tim done goal met 
pl car elements comp car pls start el 
pls cdr elements comp cdr pls checks priorities null pl deactivate comp fail tim result el car pl car els checks individual elements els cdr pl cdr els null el nil ready el retries el return fire cel el comp tim viewtime result return result defmethod fire competence puts element schedule returns preserve keep parent schedule 
sets key child fire copy parent won reactivated til child done 
defmethod fire cel el competence element comp sol competence tim optional viewtime symb list tag comp gensym setf retries el retries el schedule element comp action action el nil just pass element 
list prereq command done tag symb tim setf preconditions comp cons prereq command done tag symb temp preconditions comp preserve defmethod fire cel creates new temporary instance named competence putting scheduler 
notice tag timeout 
defmethod new instance comp sol competence drive name tim key postactions nil preconditions nil instance sol competence comp drive name drive name warning 
elements structures copy tree won deep copy 
write method 
elements copy elements comp drive name name name comp postactions append postactions comp postactions preconditions append preconditions comp preconditions comp timeout tim comp add plus debugging 
content content tag list tag comp content content tag tag comp command active action action comp value value comp timestamp tim goal goal comp comp jjb jan temp preconditions temp preconditions comp defmethod new instance sol competence notice important new elements retries stand 
copy list creates basic structure preserving order therefor priority 
changed july reflect extra nesting shared priority 
carry drive label motivating drive exemplar 
defmethod copy elements comp sol competence drive name elist copy list elements comp els elist cdr els plist copy list car els individual priority list copy list car els null els elist setf car els pls plist cdr pls null pls plist setf car pls instance competence element trigger trigger car pls drive name drive name action action car pls retries retries car pls set copied list priority set copied list elements defmethod copy elements sol competence sol drive methods needs serious re think context sol drives really competence 
july current answer 
re really sol context see posh run lisp competence methods needed drive ready 
defmethod ready compel drive element trigger compel trigger trigger compel defmethod ready competence element running posh previous version posh drive collections managed rest execution 
file main control loops posh action selection cycle 
posh run lisp main control loop posh system including lot stuff drives 
expect particular behavior library define init world debug world gets called debug true handle bod gui requests gets called gui true 
defun init world 
defun debug world output stream time 
defun handle bod gui requests input stream 
true global set variables things run 
relate gui code shielded parameter check run connected gui 
defvar debug defvar debug world print output debug world defvar debug drive nil show drive selected defvar debug failed action nil shows things didn get fired defvar debug action nil show element drive fired kinds time simulated time tyrrell cycle advances clock tick real time time follows internal clock 
thought checking time center mas complex jb nov real time mas purpose global just communicate gui defvar bb stream nil defvar stream nil defvar posh output require comm socket communication doesn compiling advance see lisp calling posh gui need keep stream open 
defun posh gui fast gui stream gui stream unwind protect fast real posh fast drive collection drive collection init real posh gui posh output gui stream gui gui stream drive collection drive collection bb stream bb stream stream stream debug world debug world debug world debug world nil init world init world init world nil gui stream attached gui don close 
close gui stream backwards memory defun posh real posh plan name posh output bb stream stream believe essence real posh want fast version driver driven action scheduler defun fast posh drive collection result nil time eq result drive lost eq result drive won result setf time time move requests schedule trim bb check bb execute scheduled items setf result driver drive collection time nil fast posh defun real fast posh drive collection result nil time eq result drive lost eq result drive won result setf time get internal real time move requests schedule trim bb check bb execute scheduled items setf result driver drive collection time nil real fast posh posh output debug prints monitor gui goes gui 
defun real posh optional key plan name nil gui nil posh output nil gui nil fast nil stream nil bb stream nil drive collection nil comes reading script debug world nil init world nil nil matters gui may initialize init world apply init world nil sanity checking xor drive collection plan name error real posh drive collection xor plan name 
dc pn drive collection plan name drive collection haven read brain 
setf drive collection posh script plan name may want fire single competence reason drive collection defun driver rest action scheduler may initialize init world apply init world nil works drive collection nil real time typep drive collection real time drive collection bb nil schedule nil declare special bb schedule print gui output window desired 
fast progn gui bb stream stream posh output error format nil posh fast running gui debugging real time real fast posh drive collection fast posh drive collection fast result nil time bb head nil eq result drive lost eq result drive won result setf time see comment top file real time get internal real time time move requests schedule trim bb check bb stream show schedule schedule stream time execute scheduled items setf result driver drive collection time posh output rest function debugging bb stream show bb bb bb stream time bb head setf bb head car bb debug world apply debug world list posh output time gui stepping handle bod gui requests gui gui format type letter break quit debug return proc res read nil cond eq res break eq res setf debug nil eq res eq res quit return gui fast defun real posh el drive element defmacro time el time el el frequency el frequency el time fired el defun driver drive collection time debug stream dc drive collection ready goal dc drive won pl car elements dc car pls start el 
pls cdr elements dc cdr pls checks drive priorities null pl drive lost result el car pl car els checks individual elements els cdr pl cdr els null el nil time el time ready el progn debug stream debug drive format debug stream fired drive time drive name el driven action scheduler active element 
drive name el debug stream debug action debug failed action setf fired el time reset fire time send sol start root drive root el content drive root el time return ready debug stream debug drive firing time el time format debug stream drive ready time drive name el format debug stream time drive time drive name el fire assignment result result return result body result defun driver defun show schedule schedule stream time format stream schedule time item car schedule car sched sched cdr schedule cdr sched iii iii null item format stream iii class name class item content item drive name item item show schedule defun show bb bb stream time bb head format stream bb adds time loop item item car bb car sched sched cdr bb cdr sched result nil cons item result eq item bb head null item result cond typep bbitem action item sol generic format stream bbitem command item bbitem tag item eq bbitem drive name item raw prototype drive known bbitem drive name item name bbitem action item bbitem timeout item format stream bbitem command item bbitem tag item eq bbitem drive name item raw prototype drive known bbitem drive name item typep bbitem action item function function bbitem action item bbitem timeout item defun show bb note dec fast posh replaced lack check result 
drivers haven replaced action scheduling 
reason macros 
doesn check return value drive won notice termination fast drive catches termination anyway 
defmacro fast posh time time nil fast driver time defmacro real fast posh time get internal real time get internal real time nil fast driver time assumes written posh code goal action execute 
want safety run code regular mode re sure debugged 
defmacro fast driver time dc drive collection pl car elements dc car pls start el 
pls cdr elements dc cdr pls checks priorities null pl drive lost result el car pl car els checks individual elements els cdr pl cdr els nil frequency el time fired el ready el progn setf fired el time return driven action scheduler drive name el result return result fast driver reading posh scripts probably tell bothered learn parsing 
posh script lisp jjb june file load posh 
load behaviors primitives read scripts 
right allows drive collection dc rdc 
todo script global hashes hashes process filename script mas 
agents scripts conditionals check things gender dominance change behaviors 
alternatively special variables declare control posh 
put line number object name errors global variables 
female sign male sign globals accessors scripts primitives 
load primitives load scripts 
load file 
defvar sense primitives hash table defvar act primitives hash table defvar action patterns hash table defvar competences hash table drive collection agent defvar drive collection nil defvar drive name nil defvar script comment nil aren necessarily predicates 
defmacro add sense name predicate setf name sense primitives predicate defmacro get sense name name sense primitives defmacro add act name function setf name act primitives function defmacro get act name name act primitives sure returns drive collection defmacro add drive name function progn setf drive name name setf drive collection function defmacro get drive name name eq drive name name drive collection nil structures rest file nb validate aggregate knows names hash tables aren necessarily predicates 
defmacro add action pattern name ap setf name action patterns ap defmacro get action pattern name name action patterns defmacro add competence name comp setf name competences comp defmacro get competence name name competences editing debugging gui scripts defvar competence elements hash table defmacro add competence element name comp setf name competence elements comp defmacro get competence element name name competence elements defvar drive elements hash table defmacro add drive element name comp setf name drive elements comp defmacro get drive element name name drive elements useful debugging 
defun flush brains sense primitives act primitives action patterns competences setf drive collection nil setf drive name nil setf script comment nil format re load sense act primitives defun partial brain flush action patterns competences setf drive collection nil setf drive name nil setf script comment nil basic functions controlling things 
posh script main read interface file symbol cat generally useful 
write functions posh script returns drive collection 
assumes behavior library loaded 
filename string symbol 
unfortunately read doesn documented compile script big object 
defun posh script filename string equal filename lap start array total size filename setf filename concatenate string filename lap file open filename direction input drive collection read aggregates read file nil eof close file validate aggregates drive collection doesn check drive collection just overwrites takes read 
defun read aggregates agg car car cdr cdr agg num agg num drive collection nil null agg drive collection car agg agg cdr agg find element cadr agg check name error format nil read aggregates name line file cadr agg agg num cond eq documentation eq comment setf script comment cons agg eq read competence agg eq dc setf drive collection read drive collection agg drive collection eq rdc setf drive collection read drive collection agg real time drive collection eq ap read action pattern agg error format nil unknown aggregate type passed read aggregate agg defun read aggregates checks referred hierarchy defined 
assumes primitives senses acts declared rest hierarchy having read 
defun validate aggregates validate action pattern action patterns validate competence competences drives differ comps element level 
drive collection validate competence bogus drive collection checks action defun find action element name cond get act name get action pattern name get competence name drive collection eq name drive collection name drive collection nil checks 
drive competence element names clarity editing scripts debugging logs aren posh system 
defun find element name cond get act name get sense name difference find action element get action pattern name get competence name get competence element name drive collection eq name drive collection name drive collection get drive element name nil defmacro unused name name find element name basic function controlling things 
posh script main write interface file assumes checked really want overwrite existing file gui 
see comment reading pretend object defun write posh script filename file open filename direction output exists overwrite exist create write char file script comment script comment file drive collection write drive collection drive collection file loop comp hash value competences write competence comp file loop ap hash value action patterns write action pattern ap file write char newline file write char file close file notice constrains actual posh engine 
example posh goal objects may sol generic posh action pattern elements may parallel 
reason constraint just bothered write full parser 
ll worry needs 
jjb june name token sol time time unit time unit minutes seconds hz sec pm min realtime add hours days microseconds 
goal goal ap competence name sol time goal elements time timeout ymir drive collection dc rdc name goal drive elements rdc real time systems elements elements comp element inner paren priority level drive elements drives drive element inner priority comp element name trigger ap name nd name action followed optional retries drive element name trigger ap name sol time drive name trigger posh root freq 
scheduling ap act sense value predicate default value default predicate eq act action primitive composite action pattern ap name sol time ap time timeout ymir reading file script spec directly 
drives returns drive collection add drive 
defun read drive collection agg drive type agg name car agg agg goal cadr agg agg elements caddr agg add drive agg name instance drive type name agg name content content command request tag agg name action goal instance competence element competence see action tag action instance sol generic name symbol cat agg name goal content content command request tag symbol cat agg name goal action nil trigger read ap guts cadr agg goal symbol cat agg name goal trigger nil 
elements read drive elements cdr agg elements agg name defun read drive collection recursively build element list return defun read drive elements agg elements drive collection cond null agg elements agg elements car agg elements error format nil read drive elements format error drives drive element inner indicate priority level 
car agg elements agg elements cons read drive element sublist car agg elements drive collection read drive elements cdr agg elements drive collection read drive elements recursively build element sub list return sub sub list allowed defun read drive element sublist agg elements drive collection cond null agg elements agg elements car agg elements agg elements error format nil read drive element sublist format error drive element name trigger ap optional retries car agg elements cons read drive element car agg elements drive collection read drive elements cdr agg elements drive collection read drive element sublist drive element name trigger ap name sol time drive name trigger posh root freq 
scheduling defun read drive element el drive collection drive name car el trigger ap cadr second el drive root third el frequency rep fourth el frequency nil frequency setf frequency read sol time frequency setf frequency add drive element drive name instance drive element drive collection drive collection drive root rep drive root drive root instance sol generic name drive name drive name drive name content content command request tag drive name action drive root frequency frequency frequency rep frequency rep drive name drive name trigger read ap guts trigger ap symbol cat drive name trigger trigger ap defun read drive element competences error checking key words 
defun read competence agg agg name car agg agg timeout rep cadr agg agg goal caddr agg agg elements agg agg timeout read sol time cadr agg add competence agg name instance sol competence name agg name content content command request tag agg name action timeout rep agg timeout rep timeout agg timeout goal instance competence element competence see action tag action instance sol generic name symbol cat agg name goal content content command request tag symbol cat agg name goal action nil trigger read ap guts cadr agg goal symbol cat agg name goal trigger agg timeout agg timeout rep elements read competence elements cdr agg elements agg name agg timeout defun read competence recursively build element list return defun read competence elements agg elements competence timeout cond null agg elements agg elements car agg elements error format nil read competence elements format error elements comp element inner indicate priority level 
car agg elements agg elements cons read competence element sublist car agg elements competence timeout read competence elements cdr agg elements competence timeout read competence elements recursively build element sub list return sub sub list allowed defun read competence element sublist agg elements competence timeout cond null agg elements agg elements car agg elements agg elements error format nil read competence element sublist format error comp element name trigger ap optional retries car agg elements cons read competence element car agg elements competence timeout read competence elements cdr agg elements competence timeout read competence element sublist return competence element saves editing bit faster 
defun read competence element el competence timeout ce label car el trigger ap cadr second el action third el retries fourth el retries setf retries retries error format nil read competence element format error comp element name trigger ap optional retries el add competence element ce label instance competence element competence competence ce label ce label action instance sol generic name action content content command request tag ce label action action retries retries trigger read ap guts trigger ap symbol cat ce label trigger timeout trigger ap defun read competence element internal time units second provided ansi standard lisp defun read sol time sol time sol time cdr sol time cadr sol time error poorly formed sol time see posh script comments sol time unit car sol time quant cadr sol time cond eq unit eq unit absolute eq unit real time quant eq unit minute eq unit min eq unit minutes quant internal time units second eq unit second eq unit sec eq unit seconds quant internal time units second eq unit hertz eq unit hz quant internal time units second eq unit minute eq unit pm quant internal time units second error format nil unknown time type passed read sol time unit defun read sol time action patterns defun read ap guts agg name timeout timeout rep instance sol action pattern name name ap guts agg timeout timeout timeout rep timeout rep content content command element tag name action elements mapcar read ap element agg defun read action pattern agg car agg agg error format nil read action pattern missing name timeout agg agg name car agg agg timeout rep cadr agg agg timeout read sol time cadr agg ap caddr agg add action pattern agg name read ap guts ap agg name agg timeout agg timeout rep read action pattern return ap list collected mapcar forget put sense nil nil trigger read ap sense defun read ap element item cond item read ap sense item item ap act sense value predicate act sense names 
value test null 
value default predicate eq 
returns sol generic defun read ap sense item name car item sensor get sense name value sol valid sense value predicate nil nil sensor error format nil read ap sense known sense name cdr item value value nil 
setf null apply sensor nil progn target value setf value cadr item caddr item predicate setf predicate caddr item setf predicate eq setf predicate apply sensor nil value sense instance sol sense name name content content tag name command sense action predicate value value defun read ap sense validating sure elements aggregates eventually read replace symbols functions validate action pattern competence run get key argument need 
returns action pattern case need defun validate action pattern ap setf elements ap mapcar validate ap element elements ap ap just returns appropriate element mapcar builds list defun validate ap element ap el cond ap el real ap find element ap el real ap real ap error know line number globals 
format nil validate ap element unknown element ap el typep ap el sol sense senses sorted read ap el error format nil validate ap element unknown type ap el defun validate ap element see comment defun validate competence comp setf trigger goal comp validate action pattern bogus trigger goal comp setf elements comp validate competence elements elements comp setf name competences comp shouldn necessary returns corrected list elements dies trying note works drive elements 
defun validate competence elements elements cond null elements elements car elements cons validate competence element sublist car elements validate competence elements cdr elements typep car elements competence element cons validate competence element car elements validate competence elements cdr elements typep car elements drive element cons validate drive element car elements validate competence elements cdr elements error format nil validate competence elements unknown type 
car elements defun validate competence elements returns corrected sub list priority elements dies trying competence element sublists contain lists note works drive elements 
defun validate competence element sublist elements cond null elements elements typep car elements competence element cons validate competence element car elements validate competence element sublist cdr elements typep car elements drive element cons validate drive element car elements validate competence element sublist cdr elements error format nil validate competence element sublist unknown type 
car elements defun validate competence element sublist returns fixed element 
largely replicated drives note try validate validated 
eventually fix right indication forgot flush brains 
defun validate competence element el setf trigger el validate action pattern bogus trigger el el action action el typep el action sol generic error know line number 
format nil validate competence element element real act action el action cond real act find action element real act fix content action el action find element real act el return value 
error know line number 
format nil validate competence element unknown action real act defun validate competence element returns fixed element 
largely replicates code 
notes drive element drive root sol generic 

defun validate drive element el setf trigger el validate action pattern bogus trigger el el action drive root el typep el action sol generic error know line number 
format nil validate competence element element real act action el action cond real act find action element real act fix content action el action find element real act el return value 
error know line number 
format nil validate drive element unknown action real act defun validate drive element writing notice functions don write file build list written 
drives defun write drive collection dc drive type spec cond typep dc real time drive collection rdc typep dc drive collection dc error really drive collection dc list drive type spec name dc list goal ap guts trigger goal dc cons drives mapcar write drive element list elements dc defun write drive element list elements mapcar write drive element elements write drive element list defun write drive element el frequency rep el list drive name el list trigger ap guts trigger el drive root rep el frequency rep el list drive name el list trigger ap guts trigger el drive root rep el competences error checking key words 
defun write competence comp list name comp timeout rep comp list goal ap guts trigger goal comp cons elements mapcar write competence element list elements comp defun write competence defun write competence element list elements mapcar write competence element elements defun write competence element el retries el list ce label el list trigger ap guts trigger el name action el retries el list ce label el list trigger ap guts trigger el name action el action patterns defun write action pattern ap list ap name ap timeout rep ap ap guts ap utility functions posh gui useful define files need read particular behavior library place 
place posh bl lisp file edited libraries added 
bod interface 
jjb dec defun load behavior library cond eq monkey compile file monkey bl load compile file monkey prims load compile file monkey world load eq primate edit colony lisp pm compile file posh utils load utils useful real time stuff compile file primate interface load launcher world compile file colony load world basic bl compile file primate groom load compile file primate novelty load compile file primate prims load error load behavior library unknown library passed couple functions think ought clos jjb utils lisp stuff lisp ought defmacro xor aa bb aa bb aa bb returns symbol honest 
length defmacro symbol cat read string concatenate string string string couple utility functions specific posh 
notice drive level code primate behavior library suspect idiom put 
posh utils lisp jjb jan 
stuff want behavior library 
thing posh thing lisp right just thing drive mem amorphous memory maintaining drive equilibrium 
oh time needed drive mem 
defined lisp internal time units minute internal time units second times relative speed slow simulation 
esp gui turned 
defvar time increment show updates world gui defvar minute time increment bogus minute update defvar incs second bogus mult 
factor getting seconds defvar incs minute bogus mult 
factor getting seconds defvar incs time bogus mult 
factor get internal real time rerun change time increment defun update increments setf incs second time increment setf incs minute incs second setf minute time increment incs minute setf incs time incs sec itu sec incs itu incs second internal time units second update increments stuff stored comes gets chunked minutes stored old chunks get dropped 
minutes time unit somewhat arbitrarily convenient models non human primates 
level tells current level drive compare ideal 
increment means spent unit doing thing 
called program 
update memory quietly book keeping 
latched helps drive want start mem time probably false memory 
instance drive memory cc start time get internal real time chunks defclass drive memory current chunk accessor current chunk initarg current chunk initform cc start time accessor cc start time initarg cc start time initform chunks accessor chunks initarg chunks initform rc total accessor rc total initarg rc total initform including current chunk 
memory length accessor memory length initarg memory length initform latching engage latch accessor engage latch initarg engage latch initform latch accessor latch initarg latch initform latch accessor latch initarg latch initform nil defmethod show dm drive memory format current level current chunk dm chunks dm engage min max just report current state defmethod latched dm drive memory latch dm level dm latch dm setf latch dm nil level dm engage latch dm setf latch dm latch dm level defmethod level dm drive memory get internal real time update memory dm current mem length cc start time dm internal time units minute current chunk dm rc total dm current mem length memory length dm defmethod increment dm drive memory optional update memory dm get internal real time setf current chunk dm current chunk dm minute time increment loop updates memory evenly leaves current time slot 
hack probably 
defmethod update memory dm drive memory current mem length cc start time dm internal time units minute current mem length setf current mem length ixi current mem length ixi weight current chunk dm floor current mem length ixi ixi setf chunks dm cons weight chunks dm setf current mem length setf rc total dm apply chunks dm setf cc start time dm floor current mem length internal time units minute setf current chunk dm gui load files 
type require comm type load posh gui 
startup require comm load posh gui streams involved communication gui posh process 
direct posh output window gui 
sending signals posh gui get connected server 
tried really hard just pass direction couldn get working 
think doesn give pieces need server listen just gives server function 
require comm socket communication doesn compiling advance 

bug report 
scm require private patch update scroll bar capi package capi really fixed 
fix compile file jjb utils load compile file posh load compile file posh script load compile file posh run load compile file posh bl load compile file bod interface load compile file lap interface load get gui set properly setf gui setf debug nil default posh run screws gui defvar posh port posh setf posh port emergency backup port defvar posh proc nil defvar bod interface instance bod interface display bod interface defvar debug interface nil making gui able talk posh non trivial esp limitations sets servers lots hidden 
relies independent server start posh process get arguments global variables 
making posh process triggered trying set pipe talk 
see bod interface lisp posh run lisp 
defun read line stream ch read char hang stream cond ch unread char ch stream read line stream defun stream posh handle gui stream instance comm socket stream socket handle direction io element type base char setf posh proc mp process run function format nil run fast posh handle posh gui run fast collector pane stream get output cp bod interface gui stream comm start server function stream posh service posh port real gui code bod interface lisp making posh process run code posh gui lisp sets server defvar color defvar color defvar posh input stream nil defvar run fast nil variables different different processes see handle bod gui requests comment 
bod env message defvar stepping nil capital setting defvar step please nil small setting nil defvar continue please nil defvar break please nil remember called posh seperate process working copies variables 
anytime set running better send notice 
read waiting characters process 
waiting step signal wait tenth second tail recurse defun handle bod gui requests gui error progn format collector pane stream get output cp bod interface break step continue stepping break please step please continue please stepping hi new char read char hang gui nil read char hang gui nil new char eq new char eof bod env message new char cond break please break click debug setf break please nil step please setf stepping setf step please nil continue please setf stepping nil setf continue please nil stepping stepping requests fall sleep handle bod gui requests gui defun handle bod gui requests see comments 
don get sent 
defun bod env message msg char cond eq msg char setf stepping eq msg char setf stepping nil eq msg char setf step please eq msg char setf step please nil eq msg char setf continue please eq msg char setf continue please nil eq msg char setf break please eq msg char setf break please nil trying talk posh port automatically starts posh process 
see posh gui lisp posh run lisp 
defun send run interface reset erase prior stuff bb schedule setf run fast nil setf posh input stream comm open tcp stream localhost posh port force output posh input stream case pending char step setf capi button enabled get run pb interface nil setf capi button enabled get fast run pb interface nil setf capi button enabled get quit pb interface defun send fast run interface reset erase prior stuff bb schedule setf run fast setf posh input stream comm open tcp stream localhost posh port force output posh input stream case pending char step setf capi button enabled get run pb interface nil setf capi button enabled get fast run pb interface nil setf capi button enabled get bod debug cb interface nil setf capi button enabled get quit pb interface defun send quit interface mp process kill posh proc reset bod run vars setf capi button enabled get run pb interface setf capi button enabled get fast run pb interface setf capi button enabled get bod debug cb interface setf capi button enabled get quit pb interface nil defun send exec item cond eq item step write char posh input stream eq item continue write char posh input stream eq item break write char posh input stream error item posh input stream force output posh input stream defun reset bod run vars setf quit please nil setf break please nil setf step please nil setf continue please nil setf posh proc nil debug setf stepping setf stepping nil needs callback type interface defun set bod debug interface setf debug set button panel enabled items get execution interface set setf debug interface instance bod debug viewer setf capi button enabled get db world cb interface capi button enabled get db drive cb interface capi button enabled get db action cb interface capi button enabled get db non act cb interface display debug interface setf bb stream capi collector pane stream get bb cp debug interface setf stream capi collector pane stream get cp debug interface posh proc set button panel enabled items get execution interface set setf stepping default way get step 
defun set bod debug interface setf debug nil debug interface destroy debug interface setf debug interface nil setf capi button enabled get db world cb interface nil capi button enabled get db drive cb interface nil capi button enabled get db action cb interface nil capi button enabled get db non act cb interface nil set button panel enabled items get execution interface set nil needs callback type interface defun choose bod lap interface file prompt file script file 
filter lap partial brain flush posh script file file setf display pane text get choose fap dp interface file file setf capi button enabled get run pb interface setf capi button enabled get fast run pb interface setf capi button enabled get graph fap cb interface setf capi display pane text get real time dp interface drive collection string typep drive collection real time drive collection shouldn happen won run 
defun set debug length choice new time cond eq choice sec internal time units second eq choice sec internal time units second eq choice sec internal time units second eq choice min internal time units second eq choice min internal time units second setf default viewtime new time debug schedule time new time defun set time needs callback type item interface defun load bod library choice interface flush brains kill fap windows don allow new script file read loading finished setf capi button enabled get choose fap pb interface nil setf capi button enabled get fast run pb interface nil setf capi button enabled get run pb interface nil setf display pane text get choose fap dp interface nil setf capi button enabled get graph fap cb interface nil setf capi display pane text get real time dp interface null choice load behavior library choice setf capi button enabled get choose fap pb interface defun load bod library graph edit functions lap interface lisp defun graph bod lap interface setf capi button selected get graph fap cb interface setf posh graph tool instance bod fap graph setf capi title pane text get graph script name posh graph tool display pane text get choose fap dp interface display posh graph tool defun kill graph bod lap unreferenced interface posh graph tool destroy posh graph tool fap graph defun edit bod lap interface setf capi button selected get edit fap cb interface setf posh edit tool instance bod fap edit setf capi display pane text get lap file dp posh edit tool display pane text get choose fap dp interface display posh edit tool defun kill edit bod lap unreferenced interface posh edit tool destroy posh edit tool fap edit defun kill fap windows posh graph tool kill graph bod lap posh graph tool posh edit tool kill edit bod lap posh edit tool graph edit functions lap interface lisp defun kill bod kids rest unreferenced args setf bod interface nil kill fap windows debug interface destroy debug interface defun debug window ref rest unreferenced args setf debug interface nil setf bb stream nil setf stream nil defun db world interface setf capi button selected get db world cb interface debug world defun db world interface setf capi button selected get db world cb interface nil debug world nil defun db drive interface setf capi button selected get db drive cb interface debug drive defun db drive interface setf capi button selected get db drive cb interface nil debug drive nil defun db action interface setf capi button selected get db action cb interface debug action defun db action interface setf capi button selected get db action cb interface nil debug action nil defun db non act interface setf capi button selected get db non act cb interface debug failed action defun db non act interface setf capi button selected get db non act cb interface nil debug failed action nil define interface bod interface panes title pane title pane text posh control panel background white debug cb check button text debug mode selection callback set bod debug retract callback set bod debug reader get bod debug cb callback type interface background color foreground color text orange button real time dp display pane text title real time title position left reader get real time dp background debug tp title pane title debug options title position left time dp display pane text title time title position left background choose fap dp display pane title script title position left text visible border min width background white reader get choose fap dp choose fap pb push button text choose script selection callback choose bod lap callback type interface reader get choose fap pb enabled nil background color graph fap cb check button text graph script selection callback graph bod lap retract callback kill graph bod lap callback type interface reader get graph fap cb enabled nil background color foreground color text orange button edit fap cb check button text edit script selection callback edit bod lap retract callback kill edit bod lap callback type interface reader get edit fap cb enabled background color foreground color text orange button db world cb check button text world selection callback db world retract callback db world callback type interface reader get db world cb enabled nil selected debug world background color db drive cb check button text drive selection callback db drive retract callback db drive callback type interface reader get db drive cb enabled nil selected debug drive background color db action cb check button text action selection callback db action retract callback db action callback type interface reader get db action cb enabled nil selected debug action background color db non act cb check button text non acts selection callback db non act retract callback db non act callback type interface reader get db non act cb enabled nil selected debug failed action background color library op option pane items nil monkey primate selected item title library selection callback load bod library callback type item interface reader get library op background white run pb push button text run selection callback send run callback type interface enabled nil reader get run pb background color fast run pb push button text run fast selection callback send fast run callback type interface enabled nil reader get fast run pb background quit pb push button text quit selection callback send quit callback type interface enabled nil reader get quit pb background color execution push button panel items step continue break selection callback send exec callback type data print function string capitalize enabled nil reader get execution adjust center impact 
background color debug length op affect operations option pane items default sec sec sec min min print function string selected item title debug trail length selection callback set debug length callback type item min width max width reader get debug length op background white output cp collector pane title debugging output stream posh output stream reader get output cp visible min width character output lp listener pane title listener stream posh output stream reader get output lp visible min width character column layout divider column layout divider background black foreground color column layout divider column layout divider background black foreground color layouts column layout column layout row layout library op row layout column layout divider row layout row layout output lp column layout divider row layout output cp simple layout didn help right justify simple layout debug cb adjust right row layout row layout title pane row layout row layout choose fap dp choose fap pb graph fap cb edit fap cb row layout blank bad idea expands vertically stretch 
row layout row layout row layout run pb quit pb fast run pb real time dp time dp row layout row layout debug cb execution debug length op adjust centre row layout row layout db world cb db drive cb db action cb db non act cb adjust centre default best height best width destroy callback kill bod kids destroy stuff hangs things title bod support background color define interface bod debug viewer panes bb cp collector pane title bulletin board stream bb stream reader get bb cp visible min width character column layout divider column layout divider background black foreground color cp collector pane title action scheduler stream stream reader get cp visible min width character layouts column layout column layout bb cp column layout divider cp default best height best width layout column layout destroy callback debug window ref title bod support debug window background color 
lap interface lisp edit posh plans 
couple functions involving interfaces rae bod interface lisp triggers 
defvar posh graph tool nil defvar posh edit tool nil defvar edit length default value slots editor 
isn scan hash keys 
defun hash keys hash result nil loop hash key hash setf result cons result result defun symbol thing thing string string thing string thing defun edit posh element data unreferenced interface posh edit tool edit bod lap bod interface setf capi display pane text get fap bit dp posh edit tool string data palette selector data posh edit tool defun fap graph rest unreferenced args setf posh graph tool nil bod interface setf capi button selected get graph fap cb bod interface nil defun fap edit rest unreferenced args setf posh edit tool nil bod interface setf capi button selected get edit fap cb bod interface nil ought discriminate different levels priority right get append note graph shows things connected drives potentially agent brain 
lap file may contain spare elements currently connected 
define interface bod fap graph panes script name pane title pane text told script name reader get graph script name background white fap graph graph pane roots mapcar drive name apply append elements drive collection roots list name drive collection node class push button best width best height selection callback edit posh element children function lambda xx find element cond typep xx drive collection mapcar drive name apply append elements xx typep xx drive element typep action drive root xx sol generic list name action drive root xx terminal typep xx sol competence mapcar ce label apply append elements xx typep xx competence element typep action xx sol generic list name action xx terminal typep xx sol action pattern ap guts xx layouts column layout column layout script name pane fap graph default best height best width destroy callback fap graph destroy stuff hangs things layout column layout title posh script graph background color lap editor defvar edit primitive cl nil set build edit primitive defvar edit action pattern cl nil set build edit action pattern defvar edit competence cl nil set build edit competence defvar edit drive collection cl nil set build edit drive collection task different palette items mutually exclusive 
note getting palette selector types accessed way 
defun palette selector item interface object nil type nil name item select proper thing get sense item setf object primitive type sense setf choice selected item get sense primitive lp interface nil get act item setf object primitive type act setf choice selected item get act primitive lp interface nil get action pattern item setf object get action pattern item type action pattern setf choice selected item get action pattern lp interface nil get competence item setf object get competence item type competence setf choice selected item get competence lp interface nil don worry selection stuff came 
object progn cond get competence element item setf object get competence competence get competence element item type competence get drive element item eq drive collection get drive element item name drive collection setf object drive collection type drive collection eq name drive collection item setf object drive collection type drive collection error palette selector unknown type item setf name name object show stuff eq object primitive primitive throw editor 
display object lap editor name type interface display object lap editor object type interface defun display object lap editor object type interface fix name editor 
setf capi display pane text get fap bit dp interface string string object object name object fix editor pane remember sub interface lap edit type type interface set type fill slots 
cond eq type sense eq type act setf capi choice selected item get type op interface ought pop editor window 
todo eq type action pattern setf capi choice selected item get type op interface action pattern fill action pattern object sub interface todo eq type competence eq type competence element setf capi choice selected item get type op interface competence eq type drive collection eq type drive element setf capi choice selected item get type op interface drive collection defun display object lap editor doesn apparently reader names aren getting set building code 
defun fill action pattern ap pane count priority priority prs ap guts ap cdr prs null prs els car prs cdr els slot symbol cat ap priority format nil count symbol cat ap priority format nil count prim slot symbol cat ap prim format nil count symbol cat ap prim format nil count null els eval setf apply slot list pane priority eval setf apply prim slot list pane car els setf count count needs callback type item interface defun lap edit type choice interface setf layout visible child get editing sp interface cond eq choice action pattern edit action pattern cl eq choice competence eq choice competence element edit competence cl eq choice drive collection eq choice drive element edit drive collection cl edit primitive cl lap edit type define interface bod fap edit panes palette tp title pane text palette background color competence lp list panel title competences background black brick red foreground white selection callback palette selector callback type item interface selection nil print function string reader get competence lp items sort hash keys competences symbol interaction single selection action pattern lp list panel title action patterns background blue slate foreground white selection callback palette selector callback type item interface selection nil print function string reader get action pattern lp items sort hash keys action patterns symbol interaction single selection act primitive lp list panel title acts background brown forest green foreground white selection callback palette selector callback type item interface selection nil print function string reader get act primitive lp items sort hash keys act primitives symbol interaction single selection sense primitive lp list panel title senses background red indigo foreground white selection callback palette selector callback type item interface selection nil print function string reader get sense primitive lp items sort hash keys sense primitives symbol interaction single selection lap file dp display pane title file title position left text bod interface display pane text get choose fap dp bod interface visible border min width background white reader get lap file dp lap lib dp display pane title library title position left text bod interface string choice selected item get library op bod interface visible border min width background white reader get lap lib dp save script pb push button text save changes selection callback save lap script callback type interface reader get save script pb enabled nil background color editing pane edit tp title pane text edit view background color edit view cbp check button panel items view edit layout class capi row layout title position left title background color interaction single selection selection enabled nil new fap bit pb push button title position left title text create selection callback new fap bit callback type interface reader get new fap bit pb background color enabled fap bit dp display pane title name text chosen title position left visible border min width background white reader get fap bit dp type op option pane items action pattern competence drive collection selected item title type max width selection callback lap edit type callback type item interface print function string capitalize reader get type op background white resort elements pb push button text resort title position left title selection callback resort elements callback type interface reader get resort elements pb enabled background color editing sp layout reader get editing sp description list edit primitive cl edit action pattern cl edit competence cl ed layouts edit cl column layout edit full title cl editing sp edit full title cl column layout edit title rl edit name rl visible border background color edit title rl row layout edit tp edit view cbp new fap bit pb resort elements pb visible border nil background color edit name rl row layout fap bit dp type op visible border nil background color palette cl column layout palette title rl palette rl palette title rl row layout palette tp lap file dp lap lib dp save script pb visible border background color palette rl row layout competence lp action pattern lp act primitive lp sense primitive lp visible border background color top rl row layout edit cl palette cl default layout top rl best width best height title posh element editor destroy callback fap edit destroy stuff hangs things background color defun write item setf write item doesn right ought edit primitives behavior files 
defun build edit primitive optional rows edit length setf edit primitive cl instance column layout description nil defun build edit action pattern optional rows edit length setf edit action pattern cl instance column layout description cons instance row layout description list instance text input pane max characters max width min width reader ap priority title title position top instance text input pane max width min width reader ap prim title sense action title position top selection callback write callback type item loop ix rows collect instance row layout description list instance text input pane max characters max width min width reader symbol cat ap priority format nil ix instance text input pane max width min width reader symbol cat ap prim format nil ix selection callback write callback type item defun build edit competence optional rows edit length setf edit competence cl instance column layout description cons instance row layout description list instance text input pane max characters max width min width reader priority title title position top instance text input pane max width min width reader label title label title position top selection callback write callback type item instance text input pane max characters max width min width reader retries title retries title position top selection callback write callback type item instance text input pane max width min width reader trigger title trigger title position top selection callback write callback type item instance text input pane max width min width reader element title element title position top selection callback write callback type item loop ix rows collect instance row layout description list instance text input pane max characters max width min width reader symbol cat priority format nil ix instance text input pane max width min width reader symbol cat label format nil ix instance text input pane max characters max width min width reader symbol cat retries format nil ix instance text input pane max width min width reader symbol cat trigger format nil ix selection callback write callback type item instance text input pane max width min width reader symbol cat element format nil ix selection callback write callback type item defun build edit drive collection optional rows edit length setf edit drive collection cl instance column layout description cons instance row layout description list instance text input pane max characters max width min width reader dc priority title title position top instance text input pane max width min width reader dc label title label title position top selection callback write callback type item instance text input pane max characters max width min width reader dc frequency title freq 
title position top selection callback write callback type item instance text input pane max width min width reader dc trigger title trigger title position top selection callback write callback type item instance text input pane max width min width reader dc drive title drive root title position top selection callback write callback type item loop ix rows collect instance row layout description list instance text input pane max characters max width min width reader symbol cat dc priority format nil ix instance text input pane max width min width reader symbol cat dc label format nil ix instance text input pane max characters max width min width reader symbol cat dc frequency format nil ix instance text input pane max width min width reader symbol cat dc trigger format nil ix selection callback write callback type item instance text input pane max width min width reader symbol cat dc drive format nil ix selection callback write callback type item build edit primitive build edit action pattern build edit competence build edit drive collection appendix transitive inference behavior library interface say chapter primitive interface file main documentation going library 
interface transitive inference task 
primitives monkey experiments july jjb revised learning dec jjb add act fail lambda nil add sense see red lambda see red add sense see white lambda see white add sense see green lambda see green add sense see yellow lambda see yellow add sense see blue lambda see blue add sense grasping lambda grasping optional general 
add act grasp seen lambda grasp add act grasp lambda grasp add act pick lambda pick add act pick lambda pick add act lambda add act lambda call adaptive behaviors monkey add sense rewarded lambda reward add act adaptive choice lambda educated choice add act consider reward lambda learn reward add act fairly consider reward lambda learn reward fairly dropped really interesting see local prior learn lap add act locally consider reward lambda learn locally reward add sense focus rule lambda get focus rule color rule trick add act priority focus lambda focus color rule trick add sense target chosen lambda null attention add act rules reward lambda learn rules reward really testing environment monkey add sense pending test lambda pending tests add act new bt test lambda setf test board random copy pop pending tests add act save result lambda print test result add act save mcg result lambda print brendan result add act save learning results lambda save monkey results color trick add act save rule learning results lambda save monkey results color rule trick add sense test lambda test board add act finish test lambda test add act new test lambda start test add act new training set lambda give training set add sense find red lambda find test red add sense find white lambda find test white add sense find green lambda find test green add sense find yellow lambda find test yellow add sense find blue lambda find test blue add act reward lambda reward monkey test generating behaviors thing board sense color add sense board lambda cadr test board nil car test board sense monkey hand add sense hand lambda hand add act give peanut lambda setf reward peanut add act lambda setf reward playing add sense criteria lambda criteria test add sense test done lambda test test add act clean lambda cleanup time add sense bigram done lambda binary done test add act check criteria lambda check test criteria test add act pick ngram lambda set test test add act pick pair lambda set pair test stuff 
add sense accounted lambda right add act monkey right lambda setf right add act monkey wrong lambda setf right scripts script files roughly order written 
binary test lap june july debugging lisp version jjb test white blue green level just test elements get red trigger see red noisy grasp elvis minutes goal grasping elements get red trigger see red noisy grasp get white trigger see white grasp seen get blue trigger see blue grasp seen get green trigger see green grasp seen get yellow trigger see yellow grasp seen ap noisy grasp minutes grasp seen driven lap binary test july debug drives test white blue green level just test elements get red trigger see red noisy grasp elvis choice minutes goal grasping elements get red trigger see red noisy grasp get white trigger see white grasp seen get blue trigger see blue grasp seen get green trigger see green grasp seen get yellow trigger see yellow grasp seen ap noisy grasp minutes grasp seen dc life goal fail drives set puzzle trigger test new test reward trigger grasping finish test choose trigger grasping nil elvis choice complain trigger nil prior learn lap driven binary test dec debug drives test white blue green level just test elements get red trigger see red noisy grasp elvis reward minutes goal rewarded elements get red trigger find red reward get white trigger find white reward get blue trigger find blue reward get green trigger find green reward get yellow trigger find yellow reward ap educated grasp minutes adaptive choice grasp seen ap test minutes consider reward save learning results finish test dc life goal fail drives set puzzle trigger test new test reward trigger grasping rewarded nil elvis reward get reward trigger rewarded test choose trigger grasping nil educated grasp complain trigger nil fair prior learn lap prior learn driven binary test feb jjb different prior learn trained adjacent pairs negative reward realistic 
elvis reward minutes goal rewarded elements get red trigger find red reward get white trigger find white reward get blue trigger find blue reward get green trigger find green reward get yellow trigger find yellow reward ap educated grasp minutes adaptive choice grasp seen ap test minutes fairly consider reward save learning results finish te dc life goal fail drives set puzzle trigger test new training set reward trigger grasping rewarded nil elvis reward get reward trigger rewarded test choose trigger grasping nil educated grasp complain trigger nil local prior learn lap fair prior learn prior learn driven binary test feb jjb different fair prior learn training affects weights members 
finished decided important elvis reward minutes goal rewarded elements get red trigger find red reward get white trigger find white reward get blue trigger find blue reward get green trigger find green reward get yellow trigger find yellow reward ap educated grasp minutes adaptive choice grasp seen ap test minutes locally consider reward save learning results finish dc life goal fail drives set puzzle trigger test new training set reward trigger grasping rewarded nil elvis reward get reward trigger rewarded test choose trigger grasping nil educated grasp complain trigger nil roger test lap driven binary test feb harris model roger choice minutes goal grasping elements get red trigger see red grasp seen get yellow trigger see yellow grasp get blue trigger see white grasp seen get green trigger see blue grasp seen ap record finish test minutes save mcg result finish test dc life goal test pending test nil drives set puzzle trigger test new bt test reward trigger grasping record finish test choose trigger grasping nil roger choice complain trigger nil rule learn lap prior learn driven binary test jan operational feb stuff fair prior learn lap learn priorities rules just priority items 
elvis reward minutes goal rewarded elements get red trigger find red reward get white trigger find white reward get blue trigger find blue reward get green trigger find green reward get yellow trigger find yellow reward educated grasp minutes goal grasping elements grasp trigger target chosen grasp seen avoid trigger focus rule avoid pick select trigger focus rule select pick focus trigger priority focus ap test minutes rules reward save rule learning results finish te dc life goal fail drives set puzzle trigger test new training set reward trigger grasping rewarded nil elvis reward get reward trigger rewarded test choose trigger grasping nil educated grasp complain trigger nil bad 
child test lap rule learn prior learn driven binary test jan jjb 
learn rules just priority items give complicated training regime 
demos way interface reasoning system case just algorithm determining course study 
behavior handles picking test 
see test child lap elvis reward minutes goal rewarded elements bad red trigger board red hand white bad white trigger board white hand blue bad blue trigger board blue hand green bad green trigger board green hand yellow ok trigger give peanut pick test minutes goal test nil elements set trigram trigger criteria bigram done new trigram set test bigram trigger criteria new bigram set shuffle pair trigger criteria new pair set train pair trigger criteria ordered pair set pair trigger clustered pair educated grasp minutes goal grasping elements grasp trigger target chosen grasp seen avoid trigger focus rule avoid pick select trigger focus rule select pick focus trigger priority focus ap test minutes rules reward save rule learning results finish te dc life goal test done drives set puzzle trigger test pick test reward trigger grasping rewarded nil elvis reward get reward trigger rewarded test choose trigger grasping nil educated grasp complain trigger nil test child lap child test rule learn prior learn driven binary test jan jjb 
learn rules just priority items give complicated training regime 
demos way interface reasoning system case just algorithm determining course study 
elvis reward minutes goal rewarded elements bad red trigger board red hand white bad white trigger board white hand blue bad blue trigger board blue hand green bad green trigger board green hand yellow ok trigger give peanut pick test minutes goal test nil elements set test trigger criteria pick ngram set pair trigger pick pair educated grasp minutes goal grasping elements grasp trigger target chosen grasp seen avoid trigger focus rule avoid pick select trigger focus rule select pick focus trigger priority focus ap test minutes rules reward check criteria finish test dc life goal test done drives set puzzle trigger test pick test reward trigger grasping rewarded nil elvis reward get reward trigger rewarded test choose trigger grasping nil educated grasp complain trigger educate monkey lap test child lap child test rule learn prior learn driven binary test feb jjb 
learn rules just priority items give complicated training regime 
demos way interface reasoning system case just algorithm determining course study 
unfortunately priority stuff isn read properly script dumb hack test child child training testing stuff 
note penalize case training pairs done incorrectly 
selective reward minutes goal rewarded elements bad red trigger board red hand white bad white trigger board white hand blue bad blue trigger board blue hand green bad green trigger board green hand yellow ok trigger give peanut pick test minutes goal test nil elements set test trigger criteria pick ngram set pair trigger pick pair educated grasp minutes goal grasping elements grasp trigger target chosen grasp seen avoid trigger focus rule avoid pick select trigger focus rule select pick focus trigger priority focus ap test minutes rules reward save rule learning results check cri dc life goal test done clean drives set puzzle trigger test pick test reward trigger grasping rewarded nil selective reward get reward trigger rewarded test choose trigger grasping nil educated grasp complain trigger nil educate monk lap educate monkey test child child test rule learn prior learn driven binary test feb jjb 
minor details keep track real right answer sake just reward 
uses nested comps selective reward minutes goal rewarded elements bad red trigger board red hand white bad white trigger board white hand blue bad blue trigger board blue hand green bad green trigger board green hand yellow ok trigger give peanut record correctness minutes goal rewarded elements reward trigger accounted selective reward bad red trigger find red hand white monkey wrong bad white trigger find white hand blue monkey wrong bad blue trigger find blue hand green monkey wrong bad green trigger find green hand yellow monkey wrong ok trigger monkey right pick test minutes goal test nil elements set test trigger criteria pick ngram set pair trigger pick pair educated grasp minutes goal grasping elements grasp trigger target chosen grasp seen avoid trigger focus rule avoid pick select trigger focus rule select pick focus trigger priority focus ap test minutes rules reward save rule learning results check cri dc life goal test done clean drives set puzzle trigger test pick test reward trigger grasping rewarded nil record correctness get reward trigger rewarded test choose trigger grasping nil educated grasp complain trigger nil behavior library code behaviors 
see wasn careful object oriented library 
monkey behavior libraries currently just functions 
remember actions normally return true 
return nil kill ap 
simple predicates defun see tb test board cdr tb tb nil equal car tb progn setf attention car tb return defun find test tb test board cdr tb tb nil equal car tb progn setf attention test board return equal hand setf attention hand defvar reward nil defun reward monkey setf reward eq attention hand peanut playing see thing hand thing just hand 
defun grasping optional thing nil thing eq thing hand hand simple acts 
defun release grip hand progn setf floor cons hand floor setf hand nil defun grasp optional graspable nil graspable setf graspable attention cond grasping graspable doing return true grasping nil return fail holding eq graspable grasp looking object random loop ixi test board eq ixi attention collect ixi setf hand object setf test board delete object test board count see graspable return fail see nil 
setf hand graspable setf test board delete graspable test board count defun format posh output eek 
eek defun call format posh output 
ooo ooo oo learning behavior obviously learns pretty quickly hurry 
defclass sequence learner seq accessor seq initarg seq initform nil sig dif accessor sig dif initarg sig dif initform weight shift accessor weight shift initarg weight shift initform defvar color trick nil declared reset bottom file defun reset color trick setf color trick instance sequence learner defmethod get item sl sequence learner label item assoc label seq sl item setf item add element sl label item give new element average weight reduce weight scale sum weights defmethod add element sl sequence learner label length seq sl setf seq sl cons cons label mapcar lambda setf cdr cdr seq sl get item sl label sum weights defmethod renormalize sl sequence learner loop ixi seq sl sum cdr ixi normalizer setf seq sl mapcar lambda setf cdr cdr normalizer seq sl due invariant mentioned called directly shift weight item normalizing scheme 
defmethod update weight sl sequence learner label value xix car seq sl car xsl xsl cdr seq sl cdr xsl null xix nil eq label car xix setf cdr xix value return pick highest valued available option 
interesting making result stochastic values close 
long learning keeps happening changes happen anyway proportion proportion uncertainty 
defmethod choice sl sequence learner optional list nil ls sort list subset possible options loop ixi list collect get item sl ixi seq sl choose options lambda cdr cdr null ls nil ls defmethod choice defmethod second choice sl sequence learner optional list nil null cdr seq sl nil cadr sort list subset possible options loop ixi list collect get item sl ixi seq sl choose options lambda cdr cdr ignores data testing triads tests weren done learning evaluation 
defun learn reward sl color trick choice get item sl hand reject get item sl car test board eq reward peanut monkey sl choice reject bad monkey sl choice reject learn surprising happened defmethod monkey sl sequence learner choice reject cdr choice cdr reject sig dif sl setf cdr choice cdr choice weight shift sl renormalize sl thought monkey hack 
defmethod bad monkey sl sequence learner choice reject temp cdr choice setf cdr choice cdr reject setf cdr reject temp general useful method 
ignores certain wrong really probably trigger big flag conscious context accelerate learning new situation 
defmethod sl sequence learner choice reject right reject setf reject second choice sl right cdr choice cdr reject sig dif sl break setf cdr choice cdr choice weight shift sl renormalize sl progn wrong 
see note certainty 
setf cdr reject cdr reject weight shift sl renormalize sl list choice reject defmethod defun learn reward fairly sl color trick choice get item sl hand reject get item sl car test board sl choice reject eq reward peanut really close cut defun educated choice setf attention choice color trick test board dealing rules defclass rule learner context need learn important attend accessor initarg initform instance sequence learner sig dif rules element context rule seqs accessor rule seqs initarg rule seqs initform hash table rule set re currently pondering current focus accessor current focus initarg current focus initform nil current rule accessor current rule initarg current rule initform nil defvar color rule trick nil declared reset bottom file defun reset color rule trick color rule trick test setf color rule trick instance rule learner setf test instance test giver defmethod clear focus rl rule learner setf current focus rl nil setf current rule rl nil defmethod focus rl rule learner setf current focus rl choice rl test board defmethod get focus rule seq rl rule learner res current focus rl rule seqs rl res res setf current focus rl rule seqs rl instance sequence learner sig dif seq random copy list cons avoid cons select defmethod get focus rule seq defmethod get focus rule rl rule learner cond current rule rl current rule rl current focus rl setf current rule rl choice get focus rule seq rl nil defun random list nth random length list list defun pick rl color rule trick setf attention cond eq current focus rl eq random loop ixi test board eq ixi current focus rl collect ixi learn rule item 
don complicated backprop just blame 
defun learn rules reward rl color rule trick chosen get item rl current focus rl reject nil goodness eq reward peanut focus rule seq get focus rule seq rl setf reject get item rl eq current rule rl avoid setf reject hand car test board rl chosen reject goodness get focus rule seq rl get item focus rule seq current rule rl nil goodness really close cut defun educated choice setf attention choice color trick test board stuff isn really monkey test little program basically running conceptual agents 
sense predicates actions defvar elvis training pairs yellow green green blue blue white white red standard test suite defun reset training set setf training set random copy elvis training pairs defun give training set training set reset training set setf test board random copy pop training set standard test suite defun set pending tests setf pending tests tests defun tests apply append loop ixi collect append random copy possible binaries random copy possible totally special purpose obviously hurry results standard high results opposite mcg defun print test test cons hand test board symb nil member red test setf symb member white test symb setf symb ab setf symb member blue test symb setf symb symbol cat symb setf symb member green test symb setf symb symbol cat symb setf symb member yellow test setf symb symbol cat symb symb defun print result cond eq hand red eq white hand eq blue hand eq green hand eq yellow hand defun brendan test test cons hand test board symb nil member red test setf symb member white test symb setf symb de setf symb member blue test symb setf symb symbol cat symb setf symb member green test symb setf symb symbol cat symb setf symb member yellow test setf symb symbol cat symb symb defun brendan result cond eq hand red eq white hand eq blue hand eq green hand eq yellow hand defun print test result format monkey results file print test print result force output monkey results file defun print brendan result format monkey results file brendan test brendan result force output monkey results file defvar num tests defvar past correct defun reset monkey counting setf num tests setf past correct defmethod print monkey sl sequence learner seq sl takes care printing seq wasn hash entry hack 
defmethod seq thing symbol thing defmethod print monkey rl rule learner option list sort seq rl lambda cdr cdr cdr option list res nil null option list res setf res cons list car option list seq option list rule seqs rl res defmethod print monkey rl defun save monkey results monkey optional setf num tests num tests format monkey results file num tests test board hand eq reward peanut right eq reward peanut setf past correct past correct eq mod num tests format monkey results file correct monkey past correct print monkey monkey force output monkey results file setf past correct note ascribed apparatus monkey defun test setf hand nil setf attention nil setf test board nil setf reward nil setf right nil world prims clear focus color rule trick defun start test setf test board colors complicated testing machine phase pair order repeated til learned 
crit correct 
rej trials phase pair order 
crit trials correct 
rej trials phase pair order 
crit trials correct 
rej trials phase pair order crit rej phase pair random order 
crit trials correct 
rej trials test binary tests sets pairs random order 
reward training pair 
test phase trials 
correct redo phase test sets trigrams random order reward 
test extend test defclass test giver test phase accessor test phase initarg test phase initform criteria accessor criteria initarg criteria initform test accessor test initarg test initform nil binary done accessor binary done initarg binary done initform nil desired accessor desired initarg desired initform yellow green blue white red test set accessor test set initarg test set initform green blue white red num correct accessor num correct initarg num correct initform num trials accessor num trials initarg num trials initform bad accessor bad initarg bad initform nil defvar test instance test giver defvar possible binaries yellow green yellow blue yellow white yellow red green blue green white green red blue white blue red white red defvar possible yellow green blue yellow green white yellow green red yellow blue white yellow blue red yellow white red green blue white green blue red green white red blue white red note num trials gets incremented binding defmethod check test criteria tt test giver eq reward peanut setf num trials tt num trials tt setf num correct tt num correct tt cond eq test phase tt 
tt pop test set tt null test set tt test phaser tt progn setf bad tt nil reset nums tt progn setf test tt fail cadr bad tt bad tt push num trials tt bad tt eq test phase tt pop test set tt setf num correct tt crit 

num correct tt test phaser tt null test set tt set test set tt setf test tt fail eq test phase tt pop test set tt num correct tt test phaser tt setf num correct tt crit 

null test set tt set test set tt setf test tt fail eq test phase tt pop test set tt num correct tt test phaser tt setf num correct tt crit 

null test set tt set test set tt setf test tt fail eq test phase tt pop test set tt num correct tt test phaser tt setf num correct tt crit 

null test set tt set test set tt setf test tt fail eq test phase tt pop test set tt null test set tt test phaser tt eq test phase tt pop test set tt null test set tt test phaser tt eq test phase tt pop test set tt null test set tt test phaser tt eq test phase tt pop test set tt null test set tt test phaser tt defmethod test giver called new test set needed may may advance phases criteria 
note criteria succesful runs collapsed trials 
defmethod test phaser tt test giver cond eq test phase tt record reset nums tt setf test phase tt criteria tt set test set tt eq test phase tt record reset nums tt setf test phase tt set test set tt eq test phase tt record reset nums tt setf test phase tt set test set tt eq test phase tt record reset nums tt setf test phase tt criteria tt set test set tt eq test phase tt record reset nums tt binary done tt setf test phase tt criteria tt setf test phase tt criteria tt set test set tt eq test phase tt num trials tt record reset nums tt crit get right test setf test phase tt binary done tt criteria tt set test set tt eq test phase tt num trials tt record nums tt num correct tt num trials tt setf test phase tt criteria tt setf test phase tt criteria tt reset nums tt set test set tt eq test phase tt num trials tt record reset nums tt setf test phase tt set test set tt eq test phase tt num trials tt record reset nums tt setf test tt criteria tt done set test set tt defmethod test phaser defmethod set test set tt test giver setf test set tt cond eq test phase tt lambda list cdr desired tt eq test phase tt lambda list cdr desired tt eq test phase tt copy list cdr desired tt eq test phase tt random copy cdr desired tt eq test phase tt random copy possible binaries eq test phase tt random copy cdr desired tt eq test phase tt eq test phase tt random copy possible defmethod set test set ok wish arrays defun random copy copy list delete car count len length len nil null setf cons nth random len records numbers 
defmethod record reset nums tt test giver optional trials record nums tt reset nums tt defmethod record nums tt test giver optional trials format monkey results file monkey results file phase complete done trials test phase tt num correct tt num trials tt force output monkey results file defmethod reset nums tt test giver optional trials setf num correct tt num trials tt defmethod 
tt test giver cond null bad tt num trials tt null cdr bad tt num trials tt num trials tt cadr bad tt defmethod set test tt test giver setf test board copy list car test set tt defmethod set pair tt test giver item car test set tt setf test board copy list cond eq item second desired tt list desired tt item eq item third desired tt list second desired tt item eq item fourth desired tt list third desired tt item eq item fifth desired tt list fourth desired tt item error set pair cdr item cdr desired tt defmethod set pair reset color trick re read library want set reset color rule trick re read library want set rest code 
file simulation wasn trivial separate world monkey apparatus 
monkey world lisp set things simulation defvar colors red white blue green yellow defvar test board defvar hand nil defvar floor nil things drop go defvar attention nil re thinking looking defvar monkey results file nil defvar training set nil defvar pending tests nil defvar right nil defun init world reset reset color trick reset monkey counting set pending tests setf hand nil setf test board nil setf training set nil monkey results file close monkey results file setf monkey results file open monkey results direction output exists overwrite exist create er rule trick results 
defun cleanup time save monkey results color rule trick force output monkey results file monkey results file close monkey results file defun debug world stream time format stream time time format stream board test board format stream hand hand defun list length thing random thing random thing thing setf thing thing thing setf thing list nth thing nth thing mcgonigle tests just things 
defun cons car appendix primate society behavior library interface say chapter primitive interface file main documentation going library 
interface primate society basic act things meant succeed add act fail lambda nil motion body prims colony lisp mas need sure re right agent behaviors 
macro looking objects associated process 
add sense target lambda self primate touching self target self self target self add sense touching target lambda self primate touching self target self add sense target chosen lambda target primate probably competence add act engage lambda self primate typep target self primate line self target self nil happen 
add act approach lambda self primate approach self target self add act lose target lambda setf target primate nil add act choose isolated place lambda self primate setf target self choose isolated place self move behavior simple add act choose grooming partner lambda self primate setf target self choose grooming partner self add sense partner chosen lambda partner target primate partner typep partner primate add sense partner overlap lambda self primate objects overlap self target self add act go partner edge lambda self primate move edge self target self add sense partner questionable lambda trim unavailable grooming target primate add act choose available grooming partner lambda self primate setf target self choose available grooming partner self novelty prims currently primate novelty lisp add sense bored lambda bored novelty don add boredom back wait add act wait lambda primate wait bored exploration prims replace novelty primate novelty similar add sense want new loc lambda want new location explore add act leave lambda explore approach pm target pm increment drive grooming prims primate groom lisp add sense want groom lambda want grooming grooming add act groom lambda grooming typep target pm primate groom nil happen 
affinity behavior include kin list scripts script files roughly order written 
documentation lap primate script log lap revision joanna primates works 
revision joanna virtually working version revision joanna primate libraries load testing real time posh testing mas revision joanna making sure logging works revision joanna initial revision rdc life goal fail drives grooming trigger want groom groom comp wandering trigger wander comp groom comp minutes goal fail elements groom gp trigger partner chosen touching target target gp trigger partner chosen touching target engage touch gp trigger partner chosen approach choose gp trigger choose grooming partner wander comp minutes goal fail elements bored wander trigger bored lose target sit trigger target chosen touching target wait wander trigger target chosen approach choose wander trigger choose isolated place documentation zero move groom lap move groom lap original version wit log zero move groom lap revision joanna initial revision revision joanna initial revision rdc life goal fail drives grooming trigger want groom groom comp exploring trigger explore comp groom comp minutes goal fail elements groom gp trigger partner chosen touching target target gp trigger partner chosen touching target engage touch gp trigger partner chosen approach choose gp trigger choose grooming partner explore comp minutes goal fail elements get moving trigger want new loc lose target sit trigger target chosen touching target wait move away trigger target chosen leave choose wander trigger choose isolated place documentation move groom lap lap moving 
fixed log move groom lap revision joanna primate works top want groom 
revision joanna initial revision rdc life goal fail drives grooming trigger want groom groom comp exploring trigger explore comp groom comp minutes goal fail elements groom gp trigger partner chosen target groom vert gp trigger partner overlap go partner edge gp trigger partner chosen touching target engage touch gp trigger partner chosen approach choose gp trigger choose grooming partner explore comp minutes goal fail elements get moving trigger want new loc target chosen touching target lo move away trigger want new loc target chosen leave choose wander trigger want new loc choose isolated place sit trigger wait documentation just wait lap move groom debugging log just wait lap revision joanna initial revision revision joanna initial revision rdc life goal fail drives exploring trigger wait documentation quota groom lap move groom go grooming slots log move groom lap revision joanna primate works top want groom 
revision joanna initial revision rdc life goal fail drives grooming trigger want groom groom comp exploring trigger explore comp groom comp minutes goal fail elements groom gp trigger partner chosen touching target target double check trigger partner chosen partner questionable reconsider part gp trigger partner chosen touching target engage touch gp trigger partner chosen approach choose gp trigger choose grooming partner ap reconsider partner minutes wait wait choose available grooming partner explore comp minutes goal fail elements get moving trigger want new loc target chosen touching target lo move away trigger want new loc target chosen leave choose wander trigger want new loc choose isolated place sit trigger wait behavior library primates really simulation needs environment run 
difficult divide aspects behavior primate world lives behavior defined source file world 
colony lisp supporting free ranging primate behavior jb nov file supports physical problem moving world 
bit odd behavior includes trad behavior primate gui world interface primate world list agents objects world observables want say contains behavior file heavily interrelated 
nb 
add new behaviors add method initialize 
recognize doing ch charlie names unique letters ch charlie gesturing right ch charlie touching left ch charlie gesturing charlie touching ch charlie heat females 
grey neutral normal motion sitting pink displaying red angry fighting orange frightened screeching aroused purple mounting blue playing green grooming eating food yellow digit elements max size screen defvar screen height defvar screen width code primate interface lisp creation world done interface launcher primate interface defvar world nil screen arena primates live defvar primate launcher nil build primates setf primate launcher instance primate launcher display primate launcher variable affecting motion see posh utils lisp time increment stuff defvar move increment far pixels normally move time increment primate behavior primate subclass object subclass target default target really just point 
want go points 
defclass target accessor initarg initform accessor initarg initform width accessor width initarg width initform height accessor height initarg height initform typically self 
inherit point defmacro distance sqrt comment distance defmacro direction atan defmacro get relative point dist theta delta round dist sin theta delta round dist cos theta instance target delta delta object anticipate food knows 
defclass object target height accessor height initarg height initform width accessor width initarg width initform color accessor color initarg color initform accessor initarg initform nil item text pm fix label defclass primate object name accessor name initarg name initform name logo accessor logo initarg logo initform logo label accessor label initarg label initform doing accessor doing initarg doing initform nil gender accessor gender initarg gender initform focus attention target accessor target initarg target initform nil special primate methods system level agent level returns symbol honest 
length symb special gender stuff state defmacro logo name name optional symb space read string array element type base char initial contents list aref name aref name symb get special individual process state way supposed axe bit 
faster version 
mind 
set primate method initialize process specific 
defmacro mind global actual bodies hash referenced behavior considered part state perception system defvar primates hash table active primates hashed process id get mind beh local procs part respective behaviors suppose 
defvar grooming hash table grooming behaviors active primates hashed process id defvar novelty hash table novelty behaviors active primates hashed process id defvar explore hash table new novelty behaviors old novelty just kept example defun reset primates loop xxx hash key primates mp process kill xxx primates grooming novelty explore defmethod initialize pm primate characterize setf logo pm logo name name pm cond eq gender pm setf height pm setf width pm show born pm maintain global list primates setf mp current process primates pm defvar mind hash table 
local minds 
setf mp current process grooming instance groom beh pm pm setf mp current process novelty instance novelty beh pm pm setf mp current process explore instance explore beh pm pm agents access minds defmacro process mp current process cond eq primate process primates eq grooming process grooming eq novelty process novelty eq explore process explore error 
seeing jane goodall speak mit experiences adult completely recalled level admiration felt child 
logging called defvar nil gets opened closed primate interface lisp defmethod jane pm primate eq logo pm jo just format name pm target pm typep target pm primate name target pm list target pm target pm nil get internal real time force output changes primate looks doing gui def defmacro look pm defmacro look pm setf capi simple pane background pm color pm capi item text pm format nil label pm logo pm mood need variable time neutral color defmacro get color cond eq display pink angry eq fight eq chase red scared eq flee eq orange eq exhibit eq mount purple eq play blue eq groom green eq eat yellow far groom implemented give taste defmacro get pose cond eq groom eq mount eq fight touch eq beg eq indicate gesture neutral defmacro bottom height defmacro top defmacro right width defmacro left array initial contents left right left find directions theta see get pose direction lisp trig polar notation defmacro get pose direction pm dir direction pm target pm aref round dir pi pi note sex signs part logo 
defmethod get label pm primate pose get pose direction eq pose neutral nil get pose direction pm cond eq pose gesture cond eq direction eq direction left eq direction right eq direction sv eq pose touch cond eq direction eq direction left eq direction right eq direction sv eq pose neutral defmethod pm primate eq doing pm setf doing pm setf label pm get label pm setf color pm get color look pm jane pm jane jane pm emergency debugging setf capi pane position pm values pm pm sleep time increment sleep returns nil reason defmethod primate behavior methods notice allows changing color format position defmethod born pm primate pm progn setf element parent pm nil destroy pm setf pm instance capi push button pm pm text format nil label pm logo pm font gp font description family courier size weight bold background color pm doesn 
setf pm hack font windows boxes instance capi push button pm pm text format nil label pm logo pm font gp font description gp find best font pm gp font description family courier size weight bold background color pm setf element parent pm pane layout world born primate defmethod die pm primate pm progn setf element parent pm nil destroy pm defmethod go pm primate newy pm move increment newy nil progn setf pm newy setf capi pane position pm values pm pm defmethod move pm primate loop ix go pm sleep give minimum quant direction arg defmacro pos abs pos pos pos defmethod go point pm primate pm pm delta delta dist setf dist round sqrt setf dist min move increment dist cond setf delta dist dist setf delta dist dist theta atan setf delta round dist sin theta setf delta round dist cos theta setf pm pm delta pm pm delta defmethod touching pm primate target pm target target pm width pm pm target width target pm target target pm height pm pm target height target diff sizes 
may close grooming 
defmethod aligned pm primate target cond typep target primate abs pm target abs pm target width pm height pm error target unknown type target pm target better methods height 
defmacro overlapping pm target pm height pm target bottom pm lower pm target top pm top pm height pm target height pm pm target height pm overlapping bottom pm target better methods height 
see overlapping comments just subs 
defmacro overlapping pm target pm width pm target pm target pm width pm target width pm pm target width pm defmethod objects overlap target target overlapping overlapping touching 
defmethod align pm primate target axis cond typep target primate eq axis go point pm pm target move go point pm target pm move error target unknown type aligning target getting monkey busy assume way go generally shorter defmethod move edge pm primate target target pm target top pm top target target height pm near top wall screen height target height target height pm go point pm pm target height pm move go point pm pm target height target move pm unstack timed version isn needed letting posh arch handle timing kept simplicity proven bad defmethod chase pm primate optional time increment time increment touching pm go point pm setf capi pane position pm values pm pm sleep time increment timed version isn needed letting posh arch handle timing kept simplicity proven bad defmethod approach pm primate optional time increment time increment go point pm pm approach note success losing pre req touching 
see comment posh 
defmethod line pm primate optional time increment time increment axis overlapping pm align pm axis pm align methods involving agents note navigation choose go past world boundaries 
really dumb fix pays attention obstacles 
changes direction motion extent 
defmacro fix target boundaries pm progn target pm setf target pm target pm setf target pm target pm screen width width pm setf target pm screen width width pm target pm screen height height pm setf target pm screen height height pm dumb 
dist default prob 
size screen 
happily go past center just want 
defmethod go center pm primate optional dist center instance target screen width screen height setf target pm get relative point pm dist direction pm center defclass agent accessor agent initarg agent initform nil dist accessor dist initarg dist initform theta accessor theta initarg theta initform questionable algorithm select nearby quadrants walls easily taken account 
may bio looking 
defmethod choose isolated place pm primate optional dist distance truncate observe walls pm dist setf target pm get relative point pm dist find biggest gap go center pm fix target boundaries pm target pm defmethod observe pm primate loop hash value primates eq pm am 
collect instance agent dist distance pm theta direction pm treat nearest walls defmethod observe walls pm primate instance target pm screen width screen width pm instance target pm screen height screen height pm near corner instance target cons instance agent dist distance pm theta direction pm cons instance agent dist distance pm theta direction pm cons instance agent near corner dist distance pm near corner theta direction pm near corner observe pm defun sort cond eq distance eq dist sort lambda dist dist eq direction eq theta sort lambda theta theta defun distance truncate loop dist collect returns direction center biggest gap list 
formats debugging defun find biggest gap cond null error find biggest gap null null cdr theta car pi theta car pi theta car pi sort direction car prev car loop cdr abs theta theta prev format theta prev theta gap progn setf setf theta theta prev setf prev tricky cause wraps 
abs theta prev pi theta format theta prev theta thi progn setf setf theta prev wrapping ok defun find biggest gap get sophisticated change behavior modules defmethod choose grooming partner pm primate optional dist observe pm car progn sort distance setf target pm agent car nil testing setf instance primate name joanna setf instance primate name setf height setf width setf height setf width born born emotion chemical drive behaviors 
remember level defined general posh file shown section 
primate groom eventually groom 
modeling assumptions essentially remember minutes 
want grooming minute 
minute half annoying 
interface want groom groom include list currently grooming objects timestamps tolerate grooming doing color gesture 
defclass groom beh pm accessor pm initarg pm initform nil remembers drive accessor drive initarg drive comment get back fixes quicker initform instance drive memory memory length chunks cc start time get internal real time engage latch latch terms drive drive want thresh accessor want thresh initarg want thresh initform target accessor target initarg target initform tolerate thresh accessor tolerate thresh initarg tolerate thresh initform long groom time increments threshold accessor threshold initarg threshold initform incs second reasons want grooming function checks 
eventually include tolerance social desires groom 
defmethod want grooming pg groom beh cond want thresh pg level drive pg individual drive engaged pg target pg level drive pg nil version engaged determined behavior actual state animal determined body 
defmethod engaged pg groom beh eq get color groom color pm pg defmethod want grooming pg groom beh latched drive pg send message target groom behavior 
defmethod groom pg groom beh optional nil setf target pm pg pm pg groom increment drive pg primate novelty attention wandering boredom resets haven bored 
note may hashes may bored thing 
backwards really notice new old 
jan boredom done drive sort inverse defclass novelty beh pm accessor pm initarg pm initform nil drive accessor drive initarg drive initform instance drive memory memory length chunks cc start time get internal real time bored threshold accessor bored threshold initarg bored threshold initform defmethod bored pn novelty beh bored threshold pn level drive pn start scratch interested lately defmethod get bored pn novelty beh increment increment drive pn look way turn want see new haven moving lately 
short memory thresholds reversed defclass explore beh pm accessor pm initarg pm initform nil drive accessor drive initarg drive initform instance drive memory memory length chunks rc total cc start time get internal real time engage defmethod want new location pe explore beh latched drive pe gui code 
primate interface lisp january defun start primate process name filename mp process run function format nil primate name create primate name filename defun create primate name filename instance primate name name initialize real posh plan name filename posh output world 
define interface primate world panes layouts world layout background best height screen height need room menu bar 
best width screen width top column layout world default best height screen height best width screen width destroy callback world layout world title primate world background pretty useless 
get error try 
defun world rest unreferenced args sleep world format debug world show primate colony display world defun primate launcher rest unreferenced args format debug world restart launcher display primate launcher define interface primate launcher panes new world pb push button text new world selection callback new world callback type interface reader get new world pb enabled background destroy world pb push button text destroy world selection callback destroy world callback type interface reader get destroy world pb enabled nil background debugging primate pb push button text debugging primate selection callback debugging primate callback type interface reader get debugging primate pb enabled nil background new primate pb push button text new primate selection callback new primate callback type interface reader get new primate pb enabled nil background choose primate fap dp display pane title new primate script title position left text visible border min width background white reader get choose primate fap dp choose primate fap pb push button text choose selection callback choose primate lap callback type interface reader get choose primate fap pb enabled background choose primate number tip text input pane title number new primates title position left callback type interface callback new primate reader get choose primate number tip enabled nil text max characters max width min width background white reader primate number tip time op wrong 
isn time option pane items sec sec min min selected item title trail length selection callback set time callback type item reader get time op background white layouts worlds row layout new world pb destroy world pb visible border background world plus row layout worlds time op worlds row layout new primate pb choose primate number tip debugging primate pb row layout choose primate fap dp choose primate fap pb top column layout world plus default destroy callback primate launcher layout top title primate launcher background defun set time choice choice isn really done defun set time defun new world interface setf open format nil jane get universal time direction output exist create setf world instance primate world display world setf capi button enabled get new world pb interface nil setf capi button enabled get destroy world pb interface defun destroy world interface confirm destroy primates proceed close quit interface world setf world nil setf capi button enabled get new world pb interface setf capi button enabled get destroy world pb interface nil reset primates defun new primate interface script display pane text get choose primate fap dp interface num parse integer text input pane text get choose primate number tip interface confirm create primate num script loop ixi num launch primate ixi script defun launch primate script start primate process prompt string format nil name new primate script defun choose primate lap interface file prompt file script file 
filter lap partial brain flush fix don want 
see todo null file setf display pane text get choose primate fap dp interface file file setf capi text input pane enabled get choose primate number tip interface setf capi button enabled get new primate pb interface setf capi button enabled get debugging primate pb interface defun primate number data interface num parse integer data junk allowed null num num num progn display message number primates setf text input pane text get choose primate number tip interface setf text input pane text get choose primate number tip interface format nil num defvar nil need date code bod interface lisp send run 
important stuff done init world defun debugging primate optional unreferenced interface setf instance primate name de bug setf posh input stream comm open tcp stream localhost posh port get run posh gui regular primates don bother passing init world 
defun init world initialize posh script display pane text get choose primate fap dp primate launcher defun target instance primate name initialize bibliography jack adams 
learning movement sequences 
psychological bulletin 
philip agre david chapman 
pengi implementation theory activity 
proceedings sixth national conference artificial intelligence pages seattle washington july 
morgan kaufmann 
philip agre david chapman 
plans 
pattie maes editor designing autonomous agents theory practice biology engineering back pages 
mit press cambridge ma 
albus 
nist real time control system rcs approach intelligent systems research 
journal experimental theoretical artificial intelligence 
james allen schubert george ferguson peter heeman chung hee hwang kato marc light nathaniel martin bradford miller massimo poesio david traum 
trains project case study building conversational planning agent 
journal experimental theoretical artificial intelligence 
anderson 
rules mind 
lawrence erlbaum associates hillsdale nj 
anderson 
rational analysis categorization act architecture 
chater editors rational models cognition 
oxford university press 
elisabeth andr thomas rist jochen ller 
integrating reactive scripted behaviors life presentation agent 
katia sycara michael wooldridge editors proceedings second international conference autonomous agents pages 
acm press 
colin angle 
legged walking robot 
master thesis massachusetts institute technology cambridge massachusetts march 
bachelor thesis 
stephen simon steward 
mobile software agents control networks 
bt technology journal march 
ronald arkin 
behavior robotics 
mit press cambridge ma 
rainer miller 
task specific neural activity primate prefrontal cortex 
journal neurophysiology 
christopher atkeson moore stefan schaal 
locally weighted learning control 
artificial intelligence review 
dana ballard mary polly rajesh rao 
deictic codes embodiment cognition 
brain behavioral sciences december 
butcher morris 
distinct components spatial learning revealed prior training receptor 
nature 
arvind bansal anand rao 
distributed storage replicated beliefs facilitate recovery distributed intelligent agents 
munindar singh anand rao michael wooldridge editors intelligent agents iv atal pages providence ri 
springer 
barber martin 
agent autonomy specification measurement dynamic adjustment 
proceedings autonomy control software workshop autonomous agents agents pages seattle wa 
joseph bates bryan loyall scott reilly 
architecture action emotion social behavior 
technical report cmu cs cmu school computer science pa may 
baumberg hogg 
generating spatio temporal models examples 
image vision computing 
antoine hanna damasio daniel antonio damasio 
deciding advantageously knowing advantageous strategy 
science february 
antoine daniel hanna damasio ralph charles antonio damasio 
double dissociation conditioning declarative knowledge relative hippocampus humans 
science august 
marc john alexander byers editors 
animal play evolutionary comparative ecological perspectives 
cambridge university press 
scott benson 
learning action models reactive autonomous agents 
phd thesis stanford university december 
department computer science 
derek 
language species 
university chicago press chicago illinois 
bizzi simon 
giszter eric mussa ivaldi philippe 
modular organization motor behavior frog spinal cord 
trends neuroscience 

effect reward maze performance rats 
university california publications psychology 
bruce mitchell blumberg 
old tricks new dogs ethology interactive creatures 
phd thesis mit september 
media laboratory learning common sense section 
barry boehm 
spiral model software development enhancement 
acm sig soft software engineering notes august 
bonasso firby gat kortenkamp miller slack 
experiences architecture intelligent reactive agents 
journal experimental theoretical artificial intelligence 
braitenberg 
vehicles experiments synthetic psychology 
mit press cambridge massachusetts 
matthew brand oliver alex pentland 
coupled hidden markov models complex action recognition 
proceedings ieee conference computer vision pattern recognition cvpr 
cynthia breazeal 
sociable machines expressive social exchange humans robots 
phd thesis mit department eecs 
cynthia breazeal brian scassellati 
context dependent attention system social robot 
dean thomas editor proceedings th international joint conference artificial intelligence ijcai july 
morgan kaufmann publishers 
cynthia breazeal brian scassellati 
build robots friends influence people 
international conference intelligent robots iros pages korea 
frederick brooks jr mythical man month essays software engineering 
addison wesley publishing reading ma th anniversary edition edition 
rodney brooks 
robust layered control system mobile robot 
ieee journal robotics automation ra april 
rodney brooks 
robot walks emergent behavior carefully evolved network 
neural computation 
rodney brooks 
intelligence reason 
proceedings international joint conference artificial intelligence pages sydney august 
rodney brooks 
intelligence representation 
artificial intelligence 
rodney brooks anita flynn 
fast cheap control robot invasion solar system 
journal british interplanetary society 
joanna bryson 
subsumption strategy development music modelling system 
master thesis university edinburgh 
department artificial intelligence 
joanna bryson 
reactive accompanist adaptation behavior decomposition music system 
luc steels editor biology technology intelligent autonomous agents 
springer verlag 
joanna bryson 
hierarchy sequence vs full parallelism reactive action selection architectures 
animals animats sab pages cambridge ma 
mit press 
joanna bryson 
study sequential hierarchical organisation behaviour artificial mechanisms action selection 
phil 
thesis university edinburgh 
joanna bryson keith decker scott michael huhns michael wooldridge 
agent development tools 
castelfranchi lesp rance editors seventh international workshop agent theories architectures languages atal 
springer 
joanna bryson jessica 
emotions action selection artificial life model social behavior non human primates 

joanna bryson lowe lynn andrea stein 
hypothesis testing complex agents 
alex elena messina editors nist workshop performance metrics intelligent systems pages washington dc august 
nist special publication 
joanna bryson brendan mcgonigle 
agent architecture object oriented design 
munindar singh anand rao michael wooldridge editors fourth international workshop agent theories architectures languages atal pages 
springer verlag 
joanna bryson th risson 
bats evil knights layer design approach character creative play 
virtual reality 
john 
exploring baldwin effect evolving adaptable control systems 
robert french jacques editors connectionist models learning development evolution proceedings th neural computation psychology works hop 
springer 
richard byrne anne 
learning imitation hierarchical approach 
brain behavioral sciences 
ca 
hormonal model emotions behavior control 
technical report vrije universiteit brussel artificial intelligence laboratory 
william calvin 
cerebral code 
mit press 
carlson 
physiology behavior 
allyn bacon boston 
margaret chalmers brendan mcgonigle 
children logical monkeys term series problem 
journal experimental child psychology 
david chapman 
planning conjunctive goals 
artificial intelligence 
david chapman 
penguins cake 
ai magazine 
david chapman 
vision instruction action 
technical report massachusetts institute intelligence lab cambridge massachusetts april 
peter coad david north mark mayfield 
object models strategies patterns applications 
prentice hall nd edition 
michael coen 
building brains rooms designing distributed software agents 
proceedings ninth conference innovative applications artificial intelligence iaai providence ri 
jonathan connell 
minimalist mobile robotics colony style architecture mobile robot 
academic press cambridge ma 
mit tr 
richard cooper tim shallice jonathon 
symbolic continuous processes automatic selection actions 
john hallam editor hybrid problems hybrid solutions frontiers artificial intelligence applications pages 
ios press amsterdam 
core moore zinn wiemer hastings 
modeling human teaching tactics computer tutor 
proceedings workshop modelling human teaching tactics strategies montreal 
luis steiger gar useful autonomous vehicle hierarchical behavior control 
moran moreno merelo editors advances artificial life third european conference artificial life pages berlin 
springer 
antonio damasio 
feeling happens body emotion making consciousness 
harcourt 
kerstin dautenhahn nehaniv editors 
proceedings aisb symposium imitation animals artifacts edinburgh april 
aisb 
richard dawkins 
hierarchical organisation candidate principle ethology 
editors growing points ethology pages 
cambridge university press cambridge 
scott mark wood 
developing multiagent systems 
castelfranchi lesp rance editors intelligent agents vii seventh international workshop agent theories architectures languages atal 
springer verlag berlin 
john demiris 
movement imitation mechanisms robots humans 
phd thesis university edinburgh may 
department artificial intelligence 
john demiris hayes 
active passive routes imitation 
proceedings aisb symposium imitation animals artifacts edinburgh april 
aisb 
dempster laird rubin 
maximum likelihood incomplete data em algorithm 
journal royal statistical society series 
daniel dennett 
intentional stance 
mit press massachusetts 
daniel dennett 
darwin dangerous idea 
penguin 
daniel dennett marcel 
time observer consciousness brain 
brain behavioral sciences 
mark inverno david kinny michael luck michael wooldridge 
formal specification dmars 
munindar singh anand rao michael wooldridge editors proceedings th international workshop agent theories architectures languages pages providence ri july 
springer 
jon doyle isaac william long peter szolovits 
architecture tool monitoring analysis interpretation 
technical report mit lcs clinical decision making group 
draft september 
hubert dreyfus 
computers 
mit press cambridge ma 
jeffrey elman elizabeth bates mark johnson annette smith domenico parisi kim plunkett 
rethinking 
connectionist perspective development 
mit press cambridge ma 
richard fikes peter hart nils nilsson 
learning executing generalized robot plans 
artificial intelligence 
james firby 
investigation reactive planning complex domains 
proceedings national conference artificial intelligence aaai pages 
james firby 
rap language manual 
ai laboratory university chicago ver 
edition march 
jerry fodor 
modularity mind 
bradford books 
mit press cambridge ma 
charles forgy 
fast algorithm patterns objects match problem 
artificial intelligence 
carl frankel rebecca ray 
emotion intention control architecture adaptively competent information processing 
aaron sloman editor aisb symposium designing functioning mind pages 
robert french bernard ans stephane rousset 
dual network memory models advantages shortcomings 
robert french jacques editors connectionist models learning development evolution proceedings th neural computation psychology works hop 
springer 
sigmund freud 
interpretation dreams 
avon new york 
sandra clara 
reinforcement learning autonomous robots empirical investigation role emotions 
phd thesis university edinburgh 
gallistel ann brown susan carey gelman frank keil 
lessons animal learning study cognitive development 
susan carey gelman editors mind pages 
lawrence erlbaum hillsdale nj 
garcia 
relation cue consequence avoidance learning 
psychonomic science 
erann gat 
reliable goal directed reactive control autonomous mobile robots 
phd thesis virginia polytechnic institute state university 
gat 
layer architectures 
david kortenkamp peter bonasso robin murphy editors artificial intelligence mobile robots case studies successful robot systems chapter pages 
mit press cambridge ma 
tim van gelder 
dynamical hypothesis cognitive science 
behavioral brain sciences 
georgeff lansky 
reactive reasoning planning 
proceedings sixth national conference artificial intelligence aaai pages seattle wa 
andrew gordon 
computational models basal ganglia 
movement disorders september 
henry gleitman 
psychology 
norton edition 
stephen grand dave cliff anil malhotra 
creatures artificial life autonomous software agents home entertainment 
lewis johnson editor proceedings international conference autonomous agents pages 
acm press february 
gandhi 
location zone gyrus monkeys 
experimental brain research november 
taylor moore 
brain mechanisms monitoring controlling body 
personal communication february 
stephen grossberg 
cerebral cortex 
learning attention grouping laminar circuits visual cortex 
spatial vision 
kevin tony prescott peter 
basal ganglia viewed action selection device 
proceedings international conference artificial neural networks sweden september 
hallam halperin hallam 
ethological model implementation mobile robots 
adaptive behavior 
kristian hammond 
case planning framework planning experience 
journal cognitive science september 
mitch harris brendan mcgonigle 
transitive choice 
quarterly journal experimental psychology 
george hartmann wehner 
ant path integration system neural architecture 
cybernetics 
barbara hayes roth robert van gent 
story making improvisational 
lewis johnson editor proceedings international conference autonomous agents pages 
acm press february 
hebb 
organization behavior 
john wiley sons new york new york 
horst hendriks jansen 
catching act situated activity interactive emergence evolution human thought 
mit press cambridge ma 
henson burgess 
representations serial order 
houghton editors proceedings fourth neural computation psychology workshop connectionist representations london 
springer 
richard henson 
short term memory serial order 
phd thesis university cambridge november 
st john college 
richard henson 
short term memory serial order start model 
cognitive psychology 
henry ian horswill david kortenkamp 
special issue software architectures hardware agents 
journal experimental theoretical artificial intelligence 
henry 
representing learning routine activities 
phd thesis state university new york buffalo december 
de boer van der hoek 
meyer 
control structures rule agent languages 
ller singh rao editors fifth international workshop agent theories architectures languages atal pages 
koen frank de boer wiebe van der hoek john jules ch 
meyer 
agent programming declarative goals 
castelfranchi lesp rance editors intelligent agents vii seventh international workshop agent theories architectures languages atal 
springer verlag berlin 

escape avoidance shock pigeons key 
journal experimental analysis behavior 
geoffrey hinton zoubin ghahramani 
generative models discovering sparse distributed representations 
philosophical transactions royal society 
geoffrey hinton steven nowlan 
learning guide evolution 
complex systems 
horn patrick winston 
laboratory environment applications oriented vision manipulation 
technical report mit ai laboratory 
todd horowitz jeremy wolfe 
visual search memory 
nature august 
ian horswill 
specialization perceptual processes 
phd thesis mit department eecs cambridge ma may 
ian horswill 
visual routines visual search 
proceedings th international joint conference artificial intelligence montreal august 
ian horswill 
visual architecture cognitive architecture 
journal experimental theoretical artificial intelligence 
george houghton tom hartley 
parallel models serial behavior revisited 
psyche february 
marcus huber 
jam bdi theoretic mobile agent architecture 
proceedings third international conference autonomous agents agents pages seattle may 
david hume 
essays concerning human understanding 
andrew millar london 
mark 
action selection methods reinforcement learning 
phd thesis university cambridge june 
allan jepson whitman richards david knill 
modal structure reliable inference 
knill richards editors perception bayesian inference pages pages 
cambridge university press 
leslie pack kaelbling 
learn difficulty learning autonomous agents 
proceedings th international joint conference artificial intelligence nagoya august 
morgan kaufmann 
ijcai computers thought award talk 
annette smith 
modularity developmental perspective cognitive change 
mit press cambridge ma 
scott kelso 
dynamic patterns self organization brain behavior 
mit press 
simon kirby 
function selection emergence language universals 
oxford university press 
hiroaki kitano minoru asada kuniyoshi noda osawa 
robocup robot world cup initiative 
proceedings international conference autonomous agents 
acm press 
christopher kline bruce blumberg 
art science synthetic character design 
aisb symposium ai creativity entertainment visual art pages 
chris knight michael kennedy james hurford editors 
evolutionary emergence language social function origins linguistic form 
cambridge university press 
knight 
level paths generation 
proceedings rd annual meeting association computational linguists acl pages 
kobayashi fukuda ono 
task dependent representations rat hippocampal place neurons 
journal neurophysiology 
kurt konolige karen myers 
architecture autonomous mobile robots 
david kortenkamp peter bonasso robin murphy editors artificial intelligence mobile robots case studies successful robot systems chapter pages 
mit press cambridge ma 
david kortenkamp peter bonasso robin murphy editors 
artificial intelligence mobile robots case studies successful robot systems 
mit press cambridge ma 
john laird paul rosenbloom 
evolution soar cognitive architecture 
mitchell editors mind matters 
erlbaum 

problem serial order behavior 
editor cerebral mechanisms behavior 
john wiley sons new york 
joseph ledoux 
emotional brain mysterious underpinnings emotional life 
simon schuster new york 
giles leigh jr levels selection potential conflicts resolution role common 
laurent keller editor levels selection evolution pages 
princeton university press princeton nj 
leon kortenkamp 
planning scheduling control architecture advanced life support systems 
nasa workshop planning scheduling space ca october 
james lester brian stone 
increasing believability animated pedagogical agents 
lewis johnson editor proceedings international conference autonomous agents pages 
acm press february 
joseph judith stern 
role gray maternal aggression fos lesion studies rats 
journal neuroscience may 
konrad lorenz 
foundations ethology 
springer new york 
lowe 
meaning mental lexicon 
proceedings th international joint conference artificial intelligence nagoya august 
morgan kaufmann 
pattie maes 
right thing 
memo mit cambridge ma december 
pattie maes editor 
designing autonomous agents theory practice biology engineering back 
mit press cambridge ma 
pattie maes 
situated agents goals 
pattie maes editor designing autonomous agents theory practice biology engineering back pages 
mit press cambridge ma 
pattie maes 
agent network architecture ana 
sigart bulletin 
pattie maes 
bottom mechanism behavior selection artificial creature 
jean meyer stuart wilson editors animals animats pages cambridge ma 
mit press 
chris malcolm 
hybrid behavioural knowledge approach robotic assembly 
dai research university edinburgh edinburgh scotland oct 
matthew marjanovic brian scassellati matthew williamson 
self taught pointing humanoid robot 
pattie maes maja matari jean meyer jordan pollack stewart wilson editors animals animats sab cambridge ma 
mit press 
maja matari 
distributed model mobile robot environment learning navigation 
technical report massachusetts institute technology artificial intelligence lab cambridge massachusetts june 
maja matari 
designing emergent behaviors local interactions collective intelligence 
proceedings second international conference simulation adaptive behavior pages cambridge ma december 
mit press 
maja matari 
behavior control examples navigation learning group behavior 
journal experimental theoretical artificial intelligence 
matheson 
targeting scratching 
journal experimental biology 
mcclelland rumelhart editors 
parallel distributed processing explorations microstructure cognition 
mit press 
volumes 
james mcclelland bruce mcnaughton randall reilly 
complementary learning systems hippocampus neocortex insights successes failures connectionist models learning memory 
psychological review 
brendan mcgonigle 
incrementing intelligent systems design 
jean meyer stuart wilson editors animals animats pages cambridge ma 
mit press 
brendan mcgonigle margaret chalmers 
monkeys logical 
nature 
brendan mcgonigle margaret chalmers 
ontology order 
les smith editor piaget critical assessment 
routledge 
brendan mcgonigle margaret chalmers 
rationality optimised cognitive 
chater editors rational models cognition 
oxford university press 
macdonald 
hearing lips seeing voices 
nature 

meyer berthoz floreano roitblat wilson editors 
animals animats proceedings sixth international conference simulation adaptive behavior 
mit press cambridge ma 
john jules ch 
meyer 
agent languages relationship programming paradigms 
ller singh rao editors fifth international workshop agent theories architectures languages atal pages paris 
springer 
frank middleton peter 
basal ganglia output cognition evidence anatomical behavioral clinical studies 
brain cognition 
jonathon mink 
basal ganglia focused selection inhibition competing motor programs 
progress neurobiology 
marvin minsky 
society mind 
simon schuster new york ny 
karen myers 
procedural knowledge approach task level control 
proceedings third international conference ai planning systems edinburgh 
karen myers 
procedural reasoning system user guide 
artificial intelligence center sri international menlo park ca usa edition 
nakata 
causal reasoning approach behaviour oriented design 
phd thesis university edinburgh department artificial intelligence 
neely 
semantic priming effects visual word recognition selective review current findings theories 
besner humphreys editors basic processes reading visual word recognition chapter 
lawrence erlbaum associates 
david heeger 
robust multiresolution alignment mri brain volumes 
magnetic resonance medicine 
alan newell 
unified theories cognition 
harvard university press cambridge massachusetts 
nils nilsson 
shakey robot 
technical note sri international menlo park california april 
nils nilsson 
reactive programs agent control 
journal artificial intelligence research 
donald 
norman tim shallice 
attention action automatic control behavior 
davidson schwartz shapiro editors consciousness self regulation advances research theory volume pages 
plenum new york 
jon oberlander chris brew 
stochastic text 
philosophical transactions royal society london series april 
lynne parker 
alliance architecture fault tolerant multi robot cooperation 
ieee transactions robotics automation 
david parnas paul clements 
rational design process fake 
ieee transactions software engineering se 
miles 
learning adaptivity enhancing reactive behaviour architectures real world interaction systems 
moran moreno merelo editors advances artificial life third european conference artificial life pages berlin 
springer 
jean piaget 
construction reality child 
basic books new york 

temporal mechanisms perception 
international review neurobiology 
robert port timothy van gelder editors 
mind motion explorations dynamics cognition 
mit press cambridge ma 
tony prescott kevin gonzalez peter 
evolution action selection 
david mcfarland holland editors 
mit press cambridge ma appear 
ashwin ram juan carlos 
continuous case reasoning 
artificial intelligence 
ramachandran 
brain human nature architecture mind 
fourth estate london 
peter tony prescott kevin 
basal ganglia vertebrate solution selection problem 
neuroscience 
scott neal reilly 
believable social emotional agents 
technical report cmu cs school computer science carnegie mellon university pittsburgh pa may 
ph thesis 
ronald rensink 
dynamic representation scenes 
visual cognition 
reynolds 
flocks herds schools distributed behavioral model 
computer graphics 
bradley rhodes 
behavior nets 
technical report mit 
media lab learning common sense 
bradley rhodes 
nets planning heuristically situated hybrid networks 
master thesis mit 
media lab learning common sense 
patrick riley peter stone manuela veloso 
layered disclosure revealing agents internals 
castelfranchi lesp rance editors seventh international workshop agent theories architectures languages atal 
springer 
roper 
learning biological phenomena 
halliday slater editors genes development learning volume animal behaviour chapter pages 
blackwell scientific publications oxford 
rosenblatt payton 
fine grained alternative subsumption architecture mobile robot control 
proceedings ieee inns international joint conference neural networks 
stuart russell peter norvig 
artificial intelligence modern approach 
prentice hall englewood cliffs nj 
tuomas sandholm 
distributed rational decision making 
gerhard wei editor multiagent systems pages 
mit press cambridge massachusetts 
stefan schaal 
imitation learning route humanoid robots 
trends cognitive sciences 
stefan schaal christopher atkeson 
robot juggling implementation memory learning 
control systems magazine 
searle 
minds brains programs 
brain behavioral sciences 
sengers 
thing right architecture action expression 
katia sycara michael wooldridge editors proceedings second international conference autonomous agents pages 
acm press 
sengers 
anti agent design cultural context 
phd thesis school computer science carnegie mellon university 
cheney 
monkey responses different alarm calls evidence predator classification semantic communication 
science 

implicit deductive reasoning humans 

mcnaughton 
spatial firing properties hippocampal ca populations environment containing visually identical regions 
journal neuroscience 
aaron sloman brian logan 
architectures tools human agents 
proceedings second european conference cognitive modelling pages nottingham uk april 
university nottingham press 
william smart 
location recognition wih neural networks mobile robot 
master thesis university edinburgh 
department artificial intelligence 
luc steels 
building agents autonomous behavior systems 
luc steels rodney brooks editors artificial life route artificial intelligence 
building situated embodied agents 
lawrence erlbaum associates new haven 
luc steels 
case study behavior oriented design autonomous agents 
dave cliff philip husbands jean meyer stewart wilson editors animals animats sab pages cambridge ma 
mit press 
isbn 
peter stone manuela veloso 
task decomposition dynamic role assignment communication real time strategic teamwork 
artificial intelligence 

learning direction global motion classes motivated models 
tesauro touretzky leen editors advances neural information processing systems denver 
sur sharma 
rewiring cortex role patterned activity development plasticity neocortical circuits 
journal neurobiology 

role supplementary motor area cells planning movements ahead 
nature 

hippocampal memory indexing theory 
behavioral neuroscience 
th risson 
communicative humanoids computational model psychosocial dialogue skills 
phd thesis mit media laboratory september 
th risson 
layered modular action control communicative humanoids 
nadia magnenat thalmann editor computer animation pages geneva june 
ieee press 
th risson 
real time decision making face face communication 
katia sycara michael wooldridge editors proceedings second international conference autonomous agents agents pages minneapolis 
acm press 
th risson 
mind model multimodal communicative creatures humanoids 
international journal applied artificial intelligence 
tolman 
cognitive maps rats men 
psychological review 
tolman 
removal reward maze performance rats 
university california publications psychology 
tu 
artificial animals computer animation biomechanics locomotion perception behavior 
springer 
toby tyrrell 
computational mechanisms action selection 
phd thesis university edinburgh 
centre cognitive science 
shimon ullman 
visual routines 
cognition 
frans de waal 
origins right wrong humans animals 
harvard university press cambridge ma 
frans de waal 
primates natural heritage conflict resolution 
science 
frans de waal 
ape master cultural reflections 
basic books boulder 
frans de waal luttrell 
comparative genus different dominance styles rhesus 
american journal 
daniel weld 
advances ai planning 
ai magazine 
stefan wermter jim david willshaw editors 
emergent neural computational architectures neuroscience 
springer 
steven whitehead 
reinforcement learning adaptive control perception action 
technical report university rochester computer science rochester ny feb 
andrew whiten 
primate culture social learning 
cognitive science 
wiener 
spatial behavioral sensory correlates hippocampal ca complex spike cell activity implications information processing functions 
progress neurobiology 
wilkins myers 
multiagent planning architecture 
proceedings aips pages pittsburgh pa june 
wilkins myers wesley 
planning reacting uncertain dynamic environments 
journal experimental theoretical ai 
matthew wilson bruce mcnaughton 
reactivation hippocampal ensemble memories sleep 
science july 
patrick winston 
learning structural descriptions examples 
patrick winston editor psychology computer vision 
mcgraw hill book new york 
david wolpert 
existence priori distinctions learning algorithms 
neural computation 
david wolpert 
lack priori distinctions learning algorithms 
neural computation 
michael wooldridge paul dunne 
optimistic disjunctive agent design problems 
castelfranchi lesp rance editors intelligent agents vii seventh international workshop agent theories architectures languages atal 
springer verlag berlin 
michael wooldridge nicholas jennings 
intelligent agents theory practice 
knowledge engineering review 
michael wooldridge paolo ciancarini 
agent oriented software engineering state art 
paolo ciancarini michael wooldridge editors international workshop agent oriented software engineering volume lncs pages 
springer berlin 
michael wooldridge nicholas jennings editors 
intelligent agents ecai workshop agent theories architectures languages amsterdam 
springer 

minimal model transitive inference 
staddon editors models action pages 
lawrence erlbaum associates mahwah 
professional edition 
waltham ma edition 


