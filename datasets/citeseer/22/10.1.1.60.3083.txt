difficulty scalably detecting network attacks uc san diego cs ucsd edu network intrusion tools bro flow state reassemble tcp connections fragments order detect network attacks syn flooding connection hijacking preliminary reconnaissance port scans 
hand network intrusion detection implemented high speeds network vantage points form aggregation necessary 
security analysts believe flow state required problems clear proof case 
fact number problems detecting large traffic footprints counting identifiers scalable solutions 
initiate study identifying security attack detection problem scalable solution 
tools communication complexity prove common formulations known intrusion detection problems detecting syn flooding port scans connection hijacking content matching fragments require flow state 
theory exposes assumptions need changed provide scalable solutions problems conclude systems techniques circumvent lower bounds 
categories subject descriptors computer communication networks general security protection analysis algorithms problem complexity miscellaneous general terms security theory keywords network intrusion detection communication complexity 
story commonly told internet began collection mutually trusting networks 
trust permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
ccs october washington dc usa 
copyright acm 
uc san diego cs ucsd edu george varghese uc san diego varghese cs ucsd edu implicit original design remained phenomenal success internet trustworthiness hosts 
today faced problem extracting utility internet seemingly populated hostile agents 
approach problem secure internet hosts anti virus software personal firewalls 
hard ensure hosts running latest versions software attempts insiders second approach secure campus enterprise networks attacks firewalls network intrusion detection systems nids 
intrusion detection devices 
firewalls place check allowed header patterns catastrophic attacks worms tunneled firewalls headers legitimate traffic allowed 
despite number technical issues major enterprise buys nids devices market growing table offers sampling vendors offering network security products 
approach step intrusion detection devices deployed deeper inside network say isp level provide security hosts connecting service provider 
vantage point provides cost savings compared deployment closer hosts due smaller number devices need deployed reduced administrative overhead required manage systems 
second wellknown reason deploy nids deeper internet provide discriminating blocking source addresses spoofed 
example response tcp syn flood attack nids may rate limit traffic targeted 
mitigates effects attack disrupts service legitimate users placing nids deeper inside network close attacker possible fewer legitimate users affected 
flow state effect speed 
current intrusion detection prevention systems vendors cisco checkpoint seek detect wide class network intrusions denial service attacks worms port scans enterprise campus networks 
big challenges generation ids devices provide real time wire speed intrusion nids vendors surveyed markets nids service providers 
detection claim vendor syn flooding port scans conn hijacking content matching checkpoint cisco mazu networks network associates table vendors offering network intrusion detection systems components thereof 
vendor indicate attacks considered products claim detect 
blank entry indicates find specific claim detect attack literature provided vendor web site product may detect attack 
detection attacks high speeds ii reduce false positives 
running nids device edge network deeper inside network requires nids operate higher link speeds 
vantage points expose detection system larger number flows setting infeasible maintain flow state track active conversation place instrumented link 
precisely information nids detect large classes attacks 
example detect port scans snort popular open source nids maintains target bit vector track ports probed suspected attacker vendors table cisco network associates mention maintaining flow state product literature 
known high speed implementations tasks forwarding path network devices routers relied small memory footprints fit cache chip sram 
example internet lookups routers prefix aggregation store prefixes entire internet 
similarly diffserv uses class aggregation avoid flow state core routers 
fundamentally number connections flows network vantage points easily scale millions scale increases size high speed memory 
wire speed implementation community notion flow state long time 
requirement small amounts control memory may irrational prejudice world plentiful memory technical basis 
roughly fairly fast dram memories ddr available highest speed memories chip chip sram limited growing slowly 
particular programmability required security implementations attack technology constantly evolving programmable chips fpgas smaller amounts memory say mbit compared custom chips 
particular chips hold state millions hundreds thousands concurrent connections traverse fairly large enterprise network 
current state art load splitters low slower nids devices protect single highspeed link 
installations expensive inhibit detection attacks split devices 
flow state necessary 
constraints may ask flow state truly necessary common network intrusion detection tasks hope finding clever memory efficient algorithms 
consider example detection problems 
estimate number distinct destinations 

determine www site accessed times 

estimate number dns queries 

detect tcp syn flooding attack 
require flow host state nids 
turns problem efficient non trivial solution require host state :10.1.1.102.5483
hand second problem require state proportional number www sites shown technique section 
third problem estimating number dns queries quite easy solved exactly need count number udp packets port 
detecting tcp syn flooding attack requires flow state conditions consider section 
formalize study attack detection tasks require flow destination state 
impossibility results best regarded practitioners labor saving devices precisely stating problems assumptions flow state required designer choose memory technology allows appropriate amount memory corresponding speed tradeoffs change assumptions invalidate lower bounds low memory implementations possible 
consider common network intrusion detection tasks table detecting tcp syn flooding detecting port scans detecting attempts hijack tcp connection matching payload split fragments evasion attack 
prove internet egress nids ingress setting network intrusion detection system nids router connecting network internet 
say detector ingress detector uses traffic entering protected network 
detector egress detector uses traffic leaving protected network 
lower bound detection comment practical implications 
continue definitions section need formalizing arguments description set disjointness problem communication complexity powerful tool establish lower bounds 
sections consider turn nids tasks listed 
section description problem followed lower bound 
section covers tcp syn flooding section covers port scans section covers tcp connection hijacking section covers evasion fragmentation 
results implications summarized table page 

theoretical tools section introduce main theoretical tools prove lower bounds attack detection 
section describe setting introduce simple turing machine model 
reader implementations today computers chip sets space lower bounds turing machine model apply ram commonly computation models 
section intuitively describe main tool lower bounds classical set disjointness problem communication complexity 
rest game recast seemingly different attacks versions set disjointness problem 
setting model setting detection system monitoring traffic network router connecting network internet see fig 

classify detection schemes ingress egress detector uses traffic entering protected network ingress traffic entering leaving network egress 
distinction nids may access incoming traffic due asymmetric routing distinction crucial problems 
model detection system turing machine tape sequentially accessed read input tape 
input consists packet sequence finite sequence problem specific alphabet take space complexity algorithm maximum space bits finite length packet sequences 
allow machine probabilistic choices take random samples require fail fixed probability half 
notational convenience denote set 

set disjointness tool set disjointness problem fundamental problem communication complexity addresses difficulty terms bits exchanged knowing sets ends link element common 
construction alon matias szegedy prove lower bound space required device wishes determine number occurrences frequent element element content packet data stream 
earlier result alon set disjointness prove certain database streaming queries require large amounts memory 
contrast set disjointness problem prove formulations attack detection problems require large amounts memory worst case 
precisely set disjointness problem follows 
consider parties alice bob set numbers alice know bob set numbers bob know alice find number communicating bits information possible 
allow unlimited computational resources measure number bits send 
strategy alice just say times number starting 
bob know number common tell alice requires bits communicated may ask better 
turns answer fact basis proving asymptotic lower bounds amount space required detect attacks 

tcp syn flooding study attack scalability tcp syn flooding attacks 
tcp syn flood denial service attack exploits way tcp connection established sender receiver tcp mating dance begins sending called syn packet responding called syn ack response 
unfortunately sending syn ack response allocates resources remember pending connection pre specified amount time roughly minute waiting sender establish connection ack packet 
tcp syn flood occurs malicious host repeatedly sends syn packets typically forged source ad reasonable model measure space words word size logarithmic length input 
detection problem scalable comment syn flooding ingress egress detection relies egress trust protected network 
port scans ingress scalable egress detection possible egress estimating 
distinct items 
conn hijacking ingress scalable detection possible attacker egress outside protected network 
evasion ingress workaround exists ip fragmentation egress tcp segmentation 
table summary results practical implications 
ingress refers detection traffic entering network egress detection traffic entering leaving network 
scalable means detection scheme flow state 
see appropriate section discussion 
additional empirical evidence needed test effectiveness approach 
dresses causing listening host allocate half open connections 
generous timeout small number connections allowed half open state easy attacker server connection resources preventing service legitimate clients 
modern implementations address mitigate problem techniques syn cookies simply allocating resources 
attack useful detect 
link level attack may characterized packet sequence containing syn packet subsequent ack packet 
considering attack consider slightly different problem detecting connections 
connections consisting opening syn packet closing fin packet 
detecting connections versus half open connections requires consider rst packets cause connection close 
problem harder affect lower bound 
ingress syn flood detection section consider problem detecting connections traffic entering protected network 
glance may sufficient count number syn packets number fin packets declaring packet stream contain session 
approach advocated 
attacker circumvent strategy sending fin packets ahead syn packets sending fin packets different address 
matching fin packets preceding syn packets efficient way determine sessions show 
problem formulation 
apply lower bound technique problem define packet set syn fin set tuples consisting session identifier packet type field syn fin 
call packet syn packet sequence matched fin occurs remainder sequence 
call packet unmatched matched 
intuitively unmatched syn packets correspond connections 
example model tcp syn flooding session identifier formulation tcp tuple consisting source address source port destination address destination port 
problem detecting packet sequence containing unmatched syn packets 
practice detecting unmatched syn packet stream may strict 
allow algorithm fail unmatched syn packets 
formally guarantee algorithm detecting unmatched syn packets input contains unmatched syn packets unmatched syn packets constitute fraction packet sequence 
call variant 
ready prove lower bound ingress detection 
lower bound 
algorithm space 
algorithm space 
proof lower bound 
prove statement see appendix proof second 
promised proof reduction disj set disjointness problem communication complexity see appendix formal description problem lower bounds 
show parties alice bob decide sets held alice bob respectively disjoint bits communication space detection algorithm 
lower bound communication complexity set disjointness imply 
reduction follows 
alice forms packet sequence syn syn 
syn 
elements runs detection algorithm parameter set sequence suspends immediately reading element 
sends state bob 
bob forms packet sequence fin fin 
fin 
elements resumes algorithm state received alice providing remainder sequence rest input 
algorithm input appears concatenation sequences 
observe disjoint matching closed connection consisting syn fin aggregate sequence seen algorithm 
conversely intersect say element packet syn matching fin packet 
intersect aggregate packet sequence seen algorithm contains unmatched syn 
result algorithm bob determine disjoint 
note communication alice bob bits state algorithm 
communication complexity follows 
shown detection system effectively maintain flow state order detect unmatched syn packet 
practical implications 
lower bound means detect tcp syn flood traffic entering network sizable fraction syn fin traffic 
effectively best pick random syn packets packet stream watch followed matching ack see type approach 
note scheme vulnerable evasion described paxson attacker set ip ttl field ack packet seen nids victim 
practice detection scheme may keep flow state reasonable round trip time rtt say second 
incoming syn followed matching ack second may reasonably assume ack come 
simple back calculation shows relaxation requires considerable memory gbit sec link may see syn packets second 
egress syn flood detection attacker inject packets traffic leaving protected network detect tcp syn flood considering difference number syn packets entering network number fin syn ack packets leaving network 
attacker tamper directly packet sequence expect large number incoming syn packets corresponding fin packets reasonable indicator attack 
implicit detection scheme trust hosts access packet stream 
cooperating host inside zombie spoil scheme sending spoofed fin packets nids 
nids thinking syn packets resulted successful connections see fig 

note scenario somewhat unusual compromised host inside attack victim directly 
scenario illustrates important point egress detection egress detection system relies credibility packet stream leaving network administrator users scalable nids decide trust justified 

port scans continue study state required detecting attacks considering port scans 
attack port scan usually precursor 
consists internet dst syn nids src fin syn flooding scenario nids fooled attacker control compromised host inside 
nids considers tcp syn flood progress significantly syn packets entering network fin packets leaving network 
attacker sends syn packets time compromised host inside network sends spoofed fin packets nids fooling ignoring attack 
attacker identifying open ports machine determine services available 
knowledge attacker attempt exploit vulnerability services determine port open attacker sends packet target host attempting connect desired port 
target host listening port respond opening connection 
exact details host responds connection attempt examined section consider egress detection 
start seeing detect phenomenon scalably traffic entering network 
ingress port scan detection problem formulation 
problem define set tuples consisting source address destination address 
call set 
ik scan size 
ik distinct 
scan problem determining packet sequence contains scan size note corresponds scenario scanner probes set hosts typically port called horizontal scan 
port scan taken scan probing range ports services single machine looked vertical scan 
formal definition captures scenarios complex scans scan number hosts number ports 
key abstraction host sending packets 
proving lower bound variant consider distributed port scans 
example model general scan formula tion represent ip source address scanner represent combination ip address port scanned point sequence 
lower bound 
algorithm scan space 
proof lower bound 
give proof case 
proof general case uses different reduction appendix 
proof reduction disj set disjointness problem communication complexity scan 
alice set bob set 
alice forms packet sequence 

elements runs scan detection algorithm parameter set sequence suspends reaches element terminates 
sends state algorithm bob resumes algorithm providing sequence remainder input 

elements disjoint input sequence algorithm contain scan conversely intersect say element input sequence contain scan consisting 
bob determine disjoint output scan detection algorithm 
alice sent bob bits size state algorithm follows 
practical implications 
lower bound implies ingress detection port scan constant require flow state 
reduction hinges difficulty determining hosts probing exactly target probes general case 
increase number distinct targets probed necessarily host may cases reasonable indicator suspicious activity 
fact exactly distributed port scan appear nids 
turns quantity estimated efficiently see example propose indicator port scan 
approach problems 
estimator accurate detect scan hidden large traffic stream inside network 
second increase number distinct hosts accessed may benign explanation route change example 
doubtful increase estimate number distinct destinations viable indicator port scan 
egress port scan detection tcp specification requires host send rst packet response connection attempt port listening process 
similarly packet sent udp port may generate icmp port unreachable response 
unfortunately firewalls block packets security reasons 
view increase number distinct destination addresses generating responses may better indicator port scan implicitly excludes packets addressed existing services 
noise due addresses poor detector sensitivity hinder detection remains verified experimentally accurate detector 
note tcp syn flooding insider fool nids prevent victim rst packets reaching nids 

tcp connection hijacking transmission control protocol provides abstraction reliable communication channel processes usually district network hosts say mechanisms tcp ensure segment sequence number identifies packet payload belongs interprocess data stream 
mechanism provides protection attacker wishing inject packets existing connection sequence number window accepted attacker wishing able correctly number forged packets knowing sequence numbers attacker narrowing possibilities may attempt guess correct sequence number injecting packets incorrect sequence numbers stream 
observer seeing traffic appear tcp session containing packets sequence numbers strictly increasing 
efficiently detect attack signature nids 
ingress connection hijacking detection problem formulation 
section consider problem detecting session sequence numbers increasing 
formally set tuples consisting session identifier sequence number 
define session subsequence packets session identifier 
call packet order packet session sequence number preceding packet session greater 
note packet reordering retransmission occurs normal operation network 
exclude benign phenomenon correct consider order packet anomalous segment sequence number differs substantially session predecessor 
problem determining packet stream contains session order packets order packets session 
guarantee detection algorithm session contains order packets contains 
example model tcp connection hijacking formulation session identifier represent tcp tuple connection identifier sequence number represent tcp sequence numbers received packet 
formulation lower bound 
algorithm space 
proof lower bound 
see appendix 
practical implications 
lower bound tells detecting attempts guess sequence numbers solely stream sequence numbers entering network requires flow state 
fact scheme relies relating packets session require state 
example suppose tell packets came host source addresses forged example means os fingerprinting 
efficiently detect connection hijacking 
requires comparing packets session requires flow state 
egress connection hijacking detection tcp specification defines appropriate response segment sequence number outside receiver window acknowledgment valid packet payload 
responses provide indication nids far sequence number fell outside window excessive number ack packets may indicator real sender attack place 
notices number ack packets significantly greater number packets sent reason suspect injecting packets session 

evasion fragmentation number intrusion detection systems attempt detect attack attempting find substring known worm payload packet 
fragmentation mechanism internet protocol splits large packet smaller ones allows attacker conceal payload fragments analogous mechanism called segmentation tcp divide interprocess data stream discrete packets 
substring sought intrusion detection system spread packets packet sequence space efficient detection impossible 
section prove lower bound determining packet split fragments contains string 
evasion detection problem formulation 
define st nd set tuples containing packet identifier marker indicating fragment second fragment fragment packet parts string intruder hopes avoid evasion 
say packet stream contains string qr packets st nd occurring order 
call problem detecting packet stream evasion 
example model evasion ip fragmentation packet identifier formulation represent combination packet identifier source ip address 
tcp segmentation packet identifier represent tcp connection tuple 
ip fragmentation st represent fragment offset nd represent fragment fragments bit zero 
tcp segmentation second markers represents byte sequence numbers payload lengths markers inferred 
string qr malicious payload nids trying detect known virus signature 
lower bound 
algorithm evasion space 
proof lower bound 
see appendix 
practical implications 
lower bound means algorithm attempting detect particular string reconstructed interprocess data stream maintain flow state 
effectively nids traffic normalizer component described reassemble fragmented packets 
fortunately workaround ip fragmentation implemented nids simply drop small fragments legitimate reasons see internet 
nids detect fragment contains sufficiently large substring harmful payload 
tcp segments quite small allowing attacker spread payload packets far apart packet stream making detection flow state impossible 

table summarizes results detecting tcp syn flooding port scans tcp connection hijacking evasion fragmentation implications intrusion system designer 
results indicate common stream processing problems created equal coarse characterization require flow state accurate 
port scans tcp syn flooding practical implication results scalable ingress detection stated impossible egress detection possible certain reasonable assumptions 
example port scans assume failed scans produce measurable response rst packets produced normally signal noise ratio sufficient detection 
fact general form approach recognize attacker trying access nonexistent hosts services network telescope honey pot vendor incorporated product 
port scan problem illustrates phenomenon may manifestations scalably detecting hard scalably detecting may feasible 
results detecting evasion attacks tcp hijacking grim solution keeping state ingress egress detection confirming intuition ids designers 
despite emphasize results worst case conditions 
practice packet stream may disposed favorably nids designer 
fact worst case conditions arise means designer decide nids fail arise 
furthermore may information available nids captured model 
example jin wang shin ttl field determine source address hash spoofed sure sign illicit activity 
began observing economic logistical forces may drive network intrusion system deeper deeper network 
technical implications new setting place increased demand system perform quickly efficiently demands current nids state art hard pressed meet 
clearly nids designs change 
step direction shown hardness detecting number common attack classes bringing light fundamental obstacles overcome 
state existing nids hope results guide nids algorithm designer fruitful directions tried point analysis 
believe new breed fast scalable ids systems low false positive rates born new fellowship algorithmic network security research 

alon matias szegedy 
space complexity approximating frequency moments stoc pp 

cert 
cert advisory ca tcp syn flooding ip spoofing attacks 
cert 
cert advisory ca ip denial service attacks 
check point software technologies www checkpoint com cisco systems 
www cisco com cohen 
mathematical structure simple defense network computers security pp 

estan varghese 
new directions traffic measurement accounting focusing elephants ignoring mice acm transactions computer systems pp 

estan varghese fisk 
bitmap algorithms counting active flows high speed links internet measurement conference 
technologies 
www com 
www com 
remote os detection tcp ip stack fingerprinting www insecure org nmap article html handley paxson 
network intrusion detection evasion traffic normalization protocol semantics th usenix security symposium pp 

jin wang shin 
hop count filtering effective defense spoofed ddos traffic acm conference computer communication security ccs 
october 
networks 
www net schnitger 
probabilistic communication complexity set intersection siam journal discrete mathematics pp 

singh varghese 
scalable attack detection network acm sigcomm internet measurement conference 
kushilevitz nisan 
communication complexity cambridge university press 
mazu networks 
www com moore voelker savage 
inferring internet denial service activity th usenix security symposium pp 

network associates www nai com technologies www com paxson 
bro system detecting network intruders real time th usenix security symposium pp 

postel 
transmission control protocol rfc 
postel 
internet control message protocol rfc 
snort 
www snort org technologies 
www com wang zhang shin 
detecting syn flooding attacks ieee infocom 
appendix appendix set disjointness problem communication complexity see set disjointness problem disj goes follows 
parties unlimited computational resources canonically alice bob set respectively 
determine disjoint intersect exchanging bits possible 
trivially alice send bob bits th bit 
bob determine communicate alice 
may ask better communicating fewer bits 
turns answer allow alice bob randomized protocol errs fixed probability half 
see deterministic lower bound probabilistic 
fact problem remains hard randomization powerful source reductions 
stream setting alon matias szegedy technique 
multi party set disjointness problem alon proof scan lower bound rely problem communication complexity 
alon matias szegedy introduce multi party set disjointness problem call involving players holding subset cardinality 
subsets 
pair wise disjoint intersect exactly element xi xj xr 
alon matias szegedy showed fixed failure probability half communication complexity problem 
omitted proofs lower bound see 
algorithm space 
algorithm space 
proof 
half claim proven section remains prove lower bound relaxed variant 
fact proof exception alice bob correct instance 
alice bob sets respectively 
set set arbitrarily satisfy 
protocol proof claim note element packet sequence seen algorithm fraction total input size 
allows alice bob instance detection algorithm drop replacement detection algorithm proof claim 
lower bound see 
algorithm scan space 
proof 
reduce multi party set disjointness problem alon matias szegedy see appendix scan 
set required 
demonstrate protocol algorithm deciding scan 
th player having input set xi forms input sequence scan algorithm parameter xi xi 
xi xi xi 
xi elements xi 
player provides sequence algorithm suspends reading tuple sends bits state second player 
second player resumes algorithm providing sequence continuation input suspends reading tuple sends state 
continues player receives state finishes computation providing sequence remainder input 
sets 
intersect element say scan 
occur packet sequence 
conversely sets pair wise disjoint element occur packet sequence 
allows player determine sets disjoint output scan algorithm 
number bits exchanged state algorithm communicated times 
complexity follows 
lower bound see 
algorithm space 
proof 
establish lower bound reduction disj 
usual set held alice set held bob 
alice forms sequence 

elements runs detection algorithm parameter set sequence suspending immediately reading element sends state bob 
bob forms sequence 

elements bob runs algorithm providing sequence input suspending immediately reading element 
sends state algorithm back alice resumes sequence 
suspending immediately reading element sends state bob 
bob resumes th 
simulation sequence 

times altogether bob finishing execution algorithm determining output 
disjoint aggregate packet sequence provided algorithm input contains sessions sequence numbers strictly increasing 
intersect say element packet sequence contain session 
contains exactly order packets 
bob result determine disjoint 
alice bob exchanged state algorithm times 
lower bound see 
algorithm evasion space 
proof 
proof reduction disj 
alice bob sets respectively 
alice forms packet sequence form st st 
st st st 
st 
elements 
elements runs evasion detection algorithm parameter set suspending immediately reading element 
sends state algorithm bob 
bob forms packet sequence form nd nd 
nd nd nd 
nd 
elements 
elements resumes algorithm provides remainder sequence input 
intersect pair packets st nd occurring order sequence 
conversely intersect pair packets packet sequence 
result evasion detection algorithm bob determine disjoint 
follows 
