computationally sound secrecy proofs mechanized flow analysis michael backes laud department mathematics department mathematics computer science computer science saarland university university backes cs uni sb de laud ut ee august novel approach proving secrecy properties security protocols mechanized flow analysis 
contrast existing tools proving secrecy interpretation tool enjoys cryptographic soundness strong sense blackbox reactive simulatability uc entails secrecy properties proven tool automatically guaranteed hold secure cryptographic implementations analyzed protocol respect fine grained cryptographic secrecy definitions adversary models 
tool capable reasoning comprehensive language expressing protocols particular handling symmetric encryption asymmetric encryption produces proofs unbounded number sessions presence active adversary 
implemented tool applied number common protocols literature 
security proofs cryptographic protocols known difficult automation proofs studied soon protocols developed 
start actual cryptographic operations proofs idealized called dolev yao models see 
idealization simplifies proof construction freeing proofs cryptographic details computational restrictions probabilistic behavior error probabilities 
conducting secrecy proofs typing abstractions shown particularly salient technique allowed elegant fully automated proofs unbounded number sessions 
type system combines conciseness language reasoning dolev yao models strong computational soundness guarantees protocol typechecks cryptographic realization provably keeps quantities handed protocol users secret computational sense 
computational soundness guarantees proofs identified central gaining trustworthy guarantees security protocols computational model strives stronger fine grained security notions furthermore considers realistic adversary allowed perform arbitrary bitstring manipulations long performed probabilistic polynomial time 
despite type system allows computationally sound reasoning active attacks major drawback type inference considered 
consequence entail automated procedure analyzing secrecy aspects cryptographic protocols cryptographic soundness guarantees arguably central goal unifying advantages approaches 
remedy shortcoming presenting mechanized approach soundly proving secrecy properties cryptographic protocols analysing possible flows data execution protocol 
approach capable reasoning comprehensive language expressing protocols particular handling symmetric encryption asymmetric encryption allows precise analyses compared type system fully automated produces proofs unbounded number sessions presence active adversary 
results rely variant dolev yao model backes pfitzmann waidner henceforth called bpw model shown computationally sound strong sense blackbox reactive simulatability 
security notion means system cryptographic realization plugged arbitrary protocols system bpw model called uc universal composition properties 
security proofs common protocols hand crafted bpw model shown bpw model accessible theorem proving techniques 
shows soundly proving secrecy properties fully automated manner possible bpw model identifies cryptographically sound secrecy typing promising direction general 
particular line complements large number existing works aims establishing computational soundness dolev yao models considering secrecy typing cf 
section related details 
analysis builds spi calculus style language deterministic semantics corresponding type system inspired methods control flow analysis 
works collecting defined variable protocol point possible shapes terms variable may point including possible creation points atomic subterms 
information collected channels participants encryption keys yielding information terms may communicated channel terms may encrypted keys honest participants respectively 
abstraction collected terms adversary may learn run protocol 
couple noteworthy points 
inputs adversary modeled single value freeing analyser necessity model new term adversary may construct 
consider explicit rules decomposing value adversary input allows keep description adversary knowledge finite 
secondly parts protocol statically public key decryption analysed twice assuming ciphertext created honest participant assuming created adversary 
distinction cases important precision analyser 
thirdly collect possible values variables relationships 
certain operations restrict set possible values variables exploit recorded relationships order restrict set values related variables 
collection relationships reminiscent shape analysis task considerably simpler full shape analysis destructive updates 
record relationships variables collecting set constraints abstractions satisfy 
prover consisting constraint generator solver implemented caml downloaded www ut ee research 
related early linking dolev yao style symbolic models cryptography considered passive attacks general statements protocols 
security notion defined generally simulatability definitions secure step function evaluation 
extended somewhat different details called uc universal composability widely applied prove individual cryptographic systems secure derive general theoretical results 
particular uc allows plugging system arbitrary protocols system retaining essentially arbitrary security properties 
cryptographic justification dolev yao model sense uc extensions 
papers considered extent restrictions weaker security properties general protocol classes allow simplifications compared laud cryptographic foundations dolev yao model symmetric encryption specific certain confidentiality properties surrounding protocols restricted straight line programs 
warinschi cryptographic underpinnings dolev yao model public key encryption restricted class protocols protocol properties analyzed primitive 
baudet cortier kremer established soundness specific classes equational theories dolev yao model passive attacks 
canetti herzog shown dolev yao style symbolic analysis conducted framework universal composability restricted class protocols mutual authentication key exchange protocols additional constraint protocols expressible loop free programs public key encryption cryptographic operation 
stress works build type inference proving secrecy properties security protocols 
comes closest laud designed type system proving secrecy aspects security protocols bpw model 
shows protocol typechecks system cryptographic realization provably keeps quantities handed protocol users secret computational sense 
proof fact exploits uc soundness result carrying symbolic proofs secrecy bpw model actual cryptographic realization similar 
type inference implemented entail mechanized procedure soundly proving secrecy aspects security protocols 
efforts way formulate syntactic calculi probabilistic polynomial time semantics including approaches process algebra security logics cryptographic games 
particular datta proposed promising logical deduction system prove computational security properties 
aware implementations frameworks blanchet automated tool proving secrecy properties security protocols transforming cryptographic games 
line orthogonal justifying dolev yao models offer higher level abstractions simpler proofs applicable proofs larger systems automated 
mention area type systems cryptographic protocol analysis 
type system kind proposed abadi verifying secrecy payloads nonces protocols symmetric encryption 
type system remaining ones describe dolev yao model 
type system extended cope asymmetric encryption abadi blanchet 
abadi blanchet generalized type system handle generic cryptographic primitives 
type system abadi extended gordon jeffrey check integrity properties 
static program analysis type system exist directly computational model handling programs containing symmetric encryption passive adversaries 
interpretation cases automatable data flow analysis considered analysis cryptographic protocols dolev yao model 
see example contained 
structure start describing machine execution model language program machines expressing security protocols sec 

continue sec 
description analysis 
particular give correctness theorem stating conditions results analysis entail computational security cryptographic protocol 
sec 
describes implementation tool applicability common security protocols literature 
sec 
give main technical lemma similar subject reduction prove previously correctness theorem 
execution model setup system 
short bpw model called cryptographic library corresponding original title honest users implemented machine thn input ports receive commands th user output ports return results commands handles received messages ports ina 
outa 
communication adversary database terms 
database records structure messages knowledge messages parties users adversary 
users adversary access messages handles transmission messages involves translation handles 
possible commands construction apart sending messages 
protocol logic th user implemented machine user pi connects ports offers ports may send receive data 
execution step machine pi consists receiving message thn user performing computations terms optionally sending message 
machines pi programmed language resembling spi calculus defined 
keypair store retrieve list 
xk pubkey xk xt xk xt gen symenc key xk xt xk xt gen nonce sip receive xp ip sip sip ip ii xp variables expressions input processes output processes labels program points expressions interest 
label may occur twice protocol text variable defined twice defined 
language contains publickey symmetric key encryption cryptographic primitives nonces 
public secret key pair created expression keypair public key extracted pubkey 
level associated symmetric key prevent encryption cycles proof relating thn concrete implementation go symmetric key may encrypt keys lower level 
store retrieve expressions convert payloads data communicated user handles back 
expression extracts th component list length pointed xp xp variable message xp identity party 
channel message constant channel channel group messages sent protocol participants protocol user participant channel determine sender receiver message 
furthermore set channels chan partitioned parts denoted 
message sent channel resp 
means message travels protocol participants secure resp 
authentic insecure channel 
message sent channel travels protocol user protocol participant concrete channels 
variables xp bound receive statement 
variable bound default branch statement branch taken failure evaluating internal state inactive currently running pi consists list input processes execution environments giving values defined variables 
program initial state pi list input processes 
active pi additionally contains received message apparent sender name channel received currently running output process environment 
pi receives message handed input process xp matching channel name list processes 
variables xp bound message apparent sender process executes ii list input processes value ii means rejecting message list input processes pi changed currently executing process environment discarded forgetting new terms may created receiving message message handed input process matching channel name list input processes pi 
process accepts message executes list input processes processes list environment output process put list input processes pi addition depending presence replication original process 
process accepts message simply lost 
security security property interested secrecy payloads 
property considered treatment differ theirs 
short want system implementing protocol consisting machines pn thn retain secrecy payloads handed users ports 
secrecy payloads means user adversary system implementing protocol really computing values received user values scrambling done channels channels precise definition concise description 
properties stated sufficient secrecy payloads simulatability machine thn bit strings machines pi receive ports affect control flow pi data statements ii machines pi may pass bit strings received user cryptographic library store commands iii terms resulting store commands available adversary adversary get handles terms 
iv symmetric keys order encrypt terms order note symmetric keys created adversary order restricted condition symmetric key unknown adversary adversary handle encryption key known adversary 
analysis verifies properties hold 
analysis domain possible values protocol variables abstracted sets values av av av av av xp xs av store avi nonce anypubval pubkey av 
av av av symenc av av av contains possible abstractions payloads may public xp secret xs 
addresses communication partners variable xp send public 
data received protocol users secret 
terms av possible abstractions terms database thn 
self descriptive 
arguments refer program points labels expressions values created 
arguments resemble program points mentioned analyse parts protocol public key decryption twice assuming ciphertext generated protocol participant assuming generated adversary 
public key decryptions occur program point point really counts different program points analysis 
program point decryptions bit string length th bit records assumed creator th decrypted ciphertext honest participant adversary 
call decryption context 
argument records level symmetric key 
value corresponds identities symmetric keys created program point decryption context 
thn adversary able find identities symmetric keys ciphertexts created 
value anypubval denotes value adversary knows may constructed 
av denote values constructed protocol participants 
secret decryption keys listed possible case av thn puts severe restrictions may decrypting ciphertexts appear subterms complex terms 
constraint variables protocol set labels generate constraint system constraint variables sb statement labels occurring protocol consider labels receive statements labels occurring expressions 
bit string length equals number asymmetric decryption operations occur protocol including point labeled 
program point preceded asymmetric decryptions different variables var set variables defined protocol point 
var union var set protocol variables assigned value depending labels receive statement set elements 
possible values sb mappings var sets values av variable sb records possible values protocol variables successful completion operation program point 
statement successful default taken 
receive statement successful 
rb statement labels occurring protocol having possible values sb constraint variables introduced ease presentation constraint system 
handling statement succeeds proceeds steps constraints giving abstraction newly defined variable evaluated followed evaluation constraints describing relationships values different variables 
constraint variable sb contains result steps 
constraint contains result step 
variable cc channels occurring protocol 
possible values variables sets values av variables record abstraction possible messages sent channel record values adversary knows 
possible values variable sets values av eb label occurring key generation 
set records values encrypted key generated preceding asymmetric decryption results described bit string meaning variables sb point interest occurrence protocol 
possible values variables sets values av labels statements 
denote true default false branch statement alive 
bit string meaning 
possible values variables false true 
true lb false constraints constraint states constraint variable introduced greater equal monotone expression constraint variables 
sense partial order defined possible values constraint variables 
applying standard algorithms constraint solving orders defined structure upper semilattice 
order booleans false true 
sets values ordered subset inclusion 
mappings sets values ordered pointwise 
sources constraints protocol adversary 
describes movement values computations performed protocol second describes capabilities adversary decomposing messages 
second set constraints quite straightforward store av av av av av symenc av av av av av av anypubval av av av av av symenc av xp anypubval constraints obvious adversary retrieve stored payloads decompose lists 
third constraint states adversary decrypt symmetric encryption key 
relation relates values sets terms correspond may intersect 
meaning anypubval depends adversary knowledge relation depend 
relation reflexive symmetric structure respecting relation values satisfies av av anypubval store xp anypubval av av av 
av anypubval av 
av anypubval anypubval 
anypubval anypubval av av av av av av av av anypubval av av av av symenc av av symenc av av anypubval xs xp fourth constraint adversary capabilities states public key public encryption may created adversary means secret key created adversary adversary may find plaintext 
fifth sixth constraints state adversary capable determining identity key produce ciphertext 
asymmetric encryption identity public key symmetric encryption 
public values xp anypubval may known adversary 
set constraints generated input output process mapping going define 
defining define mappings 
gives set values result evaluating expression decryption context evaluating abstractions defined variables mapping give necessary conditions evaluation succeed fail 
gives set constraints variables eb generated boolean showing expression live code 
gives abstractions variables defined assignment variable occurring gives set values certainly abstracts value successful evaluation mapping collect relationships values variables 
relationships variables allow analysis precise account need form greatest lower bounds pairs sets values 
upper bound may just union sets greatest lower bound simply intersection 
reason sets values valid abstractions concrete value want greatest lower bound valid abstraction value 
certain concrete values may correspond different values example nonce known adversary may occur abstractions nonce anypubval 
defining define partial binary operation values smallest defined arguments possible idempotent symmetric structure preserving operation satisfies av anypubval av value av defined 
just define av av av av 
define iff mappings 
left definition true 
left definition 
la resp 
ls set labels occurring protocol positions keypair resp 
gen symenc key 
xp false false keypair keypair false store store av av store false retrieve av store av xp anypubval retrieve anypubval av store av retrieve av av store 
list 
xk av 
av av xi list 
xk av xi av 
list xk av xi av 
gen symenc key gen symenc key false av av av anypubval anypubval anypubval av av av av av 
av pubkey pubkey pubkey pubkey av av 
gen nonce nonce gen nonce false xk xt av av av xk av xt av pubkey anypubval av anypubval xk av xt xk xt anypubval xk pubkey xk xk xt pubkey xk xt la xk xt symenc av av av xk av xt av symenc anypubval av anypubval xk av xt xk xt anypubval xk xk xk xt xk xt ls xk xt av symenc av av xt av xk av av anypubval anypubval xt xk anypubval xt xk xk xt anypubval xk xk xk xt av pubkey av xt xk anypubval xt xk xt anypubval anypubval xt xk xk xt xk see special treatment anypubval example payloads extracted projections taken 
result public value 
encryption anypubval may serve encryption key course ciphertexts decrypted adversary 
decryption ciphertext anypubval variables determine possible plaintexts 
distinction participant generated adversary generated ciphertexts publickey decryption seen definitions xk xt assumes ciphertext generated protocol participant second assumes adversary source ciphertext 
cases symmetric decryption joined analysis handle separately 
relationships newly defined existing variables 
recall gives variable set values guaranteed concrete value 
definition missing equal precision gained 
list xk av 
av av xi list 
xk xi av av av anypubval anypubval av av 
av anypubval anypubval av 
av av av av 
av av av 
av anypubval anypubval av anypubval 
anypubval av anypubval xk xt av av av xk av xt xk xt xk av av av av xt xk xt xt av av av av xk xk xt symenc av av av xk av xt xk xt xk av symenc av av av xt xk xt xt av symenc av av av xk store store av av pubkey pubkey pubkey pubkey xk xt anypubval xk xk xk xt anypubval xk xk usage may clearer look constraints generated processes 
generation done constraint variable describing protocol state execution process bit string current decryption context variable denotes process alive set constraints form monotone expression may contain constraints relate values variables defined execution contains constraint result suitable abstraction value mapping variables sets values set constraints form denote greatest solution constraints variable equal mapping defined follows 
public key decryption var true false lb true rb rb true sb lb true false public key decryption different default branches decryption contexts var true true false lb true rb sb rb rb rb true lb true lb true false see constraints generated 
process alive true expression may succeed resp 
fail demand boolean variable reflecting lb true resp 
lb false true 
may succeed lb true true mapping rb mapping additionally fix abstraction left hand side means equal constraints rb lb true false rb constraints maps 
set constraints includes relationships variables defined successful execution note inequality signs constraints opposite direction inequality signs constraints generated constraint sb rb states sb contains basically abstractions rb recorded relationships variables taken account 
constraint sb inequality sb rb holds 
add constraints variables eb recursively invoke false branch 
arguments recursive calls worth noting 
see pass protocol collect constraints expressing relationships variables 
default branch sb abstraction initial state mapping variable assigned evaluation failed 
collect new relationships variables fails possible change precision analysis practice 
consider cases process false rb av av av av true lb true false check abstractions may intersect 
add equality set constraints xp xp cc send command succeeds intended recipient known adversary message recorded occurring channel known adversary 
receive xp true sb rb sb lb true cc xp xp rb anypubval xp xp rb xs xp xp see message adversary abstracted anypubval message user secret payload 
sender message known adversary xp public integer 
new constraints added invocation needed ii ii ii program machine pi set constraints protocol union ii true mapping empty domain 
protocol label occurring protocol labeling subprocess ib denote variable sb empty mapping occurs argument call invoked construction constraints 
ib gives values variables entering subprocess labeled context theorem states security protocol established analysis 
theorem 
protocol eb cc constraints fulfilled 
conditions hold composition machines thn pi preserves secrecy payloads payloads cryptographically secret thn replaced cryptographic realization 
protocol contains statement form xs xs store xs store xs 
ii xs sb occurs argument operation operation store send user 
values entry iii xs 
iv av eb symm 
key order generated order av order order tuple maximum order members 
order values 
implementation find componentwise solution aforementioned collection inequalities 
fixed point computed iteratively version solver specifically tailored systems constraints 
computation terminate believe problem real protocols fact encountered situation applied tool common protocols literature 
case computation guaranteed terminate protocol able create terms arbitrary complexity help adversary 
believe potentially exponential number variables size protocol problem practice protocol descriptions short 
ways deal divergence fixed point computation add suitable widenings 
believe exponential number sets represented compact way necessary 
value computed iteratively solution method 
mapping initialized iteration proceeds downwards 
constraint generator solver implemented caml version compile native code 
tested analyser protocols literature needham schroeder public key fix lowe otway rees yahalom modification burrows 
goal protocols exchange symmetric key parties 
analysis find safe exchanged key protect secret payloads transit public networks 
added extra message protocol sessions protocols 
extra message communication secret payload party encrypted freshly exchanged key 
analysis considers protocols secure original flawed needham schroeder protocol 
allows old session keys known adversary may attacks discovered analyser bpw model consider leakage secret keys cause called commitment problem proof computational soundness sense uc impossible 
attacks modified yahalom published attacks affect message secrecy properties allow adversary learn new key inject key 
running times analyser computer ghz intel celeron processor mb main memory seconds protocols seconds needham schroeder lowe versions yahalom 
correctness analysis theorem straightforward corollary lemma similar subject reduction 
going give statement lemma proof appendix 
arguing correctness need distinguish public secret payloads 
change semantics system little bit assume payload labeled secrecy level 
integer received protocol user labeled secret constant integer apparent sender message labeled public 
payloads stored database terms labels stored 
retrieved labels 
integers compared secrecy levels ignored 
run protocol finite sequence steps 
state database thn run 
protocol variable definition occurs replications 
variable assigned value inside th replica outermost replication th replica replication denote value ik 
value handle term secret integer public integer 
similarly program point inside replications syntactically preceded public key decryptions 
ik bit string bits describe source ciphertexts decryptions visible point replica 
ik 
note ciphertext term database creator simply principal handle 
set terms database downwards closure smallest set terms containing closed respect list projection decryption keys extracting public keys symmetric key names ciphertexts 
value av define semantics av respect contents database semantics set terms set payloads 
xp public 
xs secret 
store av set terms type data argument belongs av nonce set terms type nonce generated gen protocol point replicas ik ik pubkey defined way nonce replace nonce skse pkse ske pke 
av av set terms type list length th component term belongs av av av set terms type enc created expressions protocol point replicas ik ik term corresponding public key belong av term corresponding plaintext belong av symenc av av defined similarly enc replaced symenc 
anypubval downwards closure set terms adversary knows 
largest set anypubval av av implies av informally obtained deleting anypubval value list components flattening lists anypubval 
set better characterization set terms created honest participants learned adversary 
definition adversarially constructed terms 
term downwards closure set terms known adversary adversarially constructed respect holds av av immediate subterms immediate subterm public key symmetric key name corresponding secret key known adversary adversarially constructed 
type nonce ske enc garbage skse symenc constructed adversary 
term adversarially constructed adversary knows construct term terms analysis know 
lemma subject reduction 
protocol sb eb cc lb constraints sec 
fulfilled 
run protocol 
state database thn claims hold 
term known adversary adversarially constructed wrt 
ik may term immediate value replica ik passes point operation succeeding value defined exists av ik av term communicated channel exists av cc av tk term representing asymmetric symmetric key generated program point replica 
ik tp term occurs plaintext encryption tk key holds exists av ik tp av tk tp known adversary term representing encryption tp tk constructed adversary 
branching point protocol statement branch taken true 
replica 
ik true default false ik lemma proved induction length abadi gordon 
calculus cryptographic protocols spi calculus 
proc 
th acm conference computer communications security pages 
mart abadi 
secrecy typing security protocols 
journal acm september 
mart abadi bruno blanchet 
secrecy types asymmetric communication 
theoretical computer science 
mart abadi bruno blanchet 
analyzing security protocols secrecy types logic programs 
journal acm january 
mart abadi phillip rogaway 
reconciling views cryptography computational soundness formal encryption 
proc 
st ifip international conference theoretical computer science volume lecture notes computer science pages 
springer 
michael backes 
cryptographically sound dolev yao style security proof otway rees protocol 
proc 
th european symposium research computer security esorics volume lecture notes computer science pages 
springer 
michael backes birgit pfitzmann 
cryptographically sound security proof needham schroeder lowe public key protocol 
ieee journal selected areas communications 
michael backes birgit pfitzmann 
symmetric encryption simulatable dolev yao style cryptographic library 
proc 
th ieee computer security foundations workshop csfw pages 
full version iacr cryptology eprint archive feb eprint iacr org 
michael backes birgit pfitzmann 
relating symbolic cryptographic secrecy 
ieee transactions dependable secure computing 
michael backes birgit pfitzmann michael waidner 
composable cryptographic library nested operations extended 
proc 
th acm conference computer communications security pages 
full version iacr cryptology eprint archive jan eprint iacr org 
michael backes birgit pfitzmann michael waidner 
symmetric authentication simulatable cryptographic library 
proc 
th european symposium research computer security esorics volume lecture notes computer science pages 
springer 
extended version iacr cryptology eprint archive jul eprint iacr org 
david basin sebastian luca 
symbolic model checker security protocols 
international journal information security 
baudet cortier kremer 
computationally sound implementations equational theories passive adversaries 
proc 
nd international colloquium automata languages programming icalp volume lecture notes computer science pages 
springer 
bruno blanchet 
computationally sound mechanized prover security protocols 
proc 
th ieee symposium security privacy 
appear 
chiara mikael degano flemming nielson hanne riis nielson 
static validation security protocols 
journal computer security 
michael burrows mart abadi roger needham 
logic authentication 
acm transactions computer systems february 
ran canetti 
universally composable security new paradigm cryptographic protocols 
proc 
nd ieee symposium foundations computer science focs pages 
extended version cryptology eprint archive report eprint iacr 
org 
ran canetti jonathan herzog 
universally composable symbolic analysis cryptographic protocols case encryption mutual authentication key exchange 
cryptology eprint archive report 
eprint iacr org 
cortier bogdan warinschi 
computationally sound automated proofs security protocols 
proc 
th european symposium programming esop pages 
anupam datta ante derek john mitchell shmatikov 
probabilistic polynomial time semantics protocol security logic 
proc 
nd international colloquium automata languages programming icalp volume lecture notes computer science pages 
springer 
danny dolev andrew yao 
security public key protocols 
ieee transactions information theory 
shimon oded goldreich 
security multi party ping pong protocols 
proc 
th ieee symposium foundations computer science focs pages 
christian helmut seidl 
faster solver general systems equations 
radhia cousot david schmidt editors static analysis third international symposium sas volume lncs pages aachen germany september 
springer verlag 
andrew gordon alan jeffrey 
authenticity typing security protocols 
journal computer security 
andrew gordon alan jeffrey 
typing correspondence assertions communication protocols 
theoretical computer science may 
andrew gordon alan jeffrey 
types effects asymmetric cryptographic protocols 
journal computer security 
guttman thayer zuck 
faithfulness protocol analysis message authentication 
proc 
th acm conference computer communications security pages 
jonathan herzog moses liskov silvio micali 
plaintext awareness key registration 
advances cryptology crypto volume lecture notes computer science pages 
springer 
russell impagliazzo bruce 
logics reasoning cryptographic constructions 
proc 
th ieee symposium foundations computer science focs pages 
richard kemmerer catherine meadows jon millen 
systems cryptographic protocol analysis 
journal cryptology 
laud 
semantics program analysis computationally secure information flow 
proc 
th european symposium programming esop pages 
laud 
handling encryption analyses secure information flow 
degano editor programming languages systems th european symposium programming esop volume lncs pages warsaw poland april 
springer verlag 
laud 
symmetric encryption automatic analyses confidentiality active adversaries 
proc 
th ieee symposium security privacy pages 
laud 
secrecy types simulatable cryptographic library 
proc 
th acm conference computer communications security pages 
laud vene 
type system computationally secure information flow 
li reischuk editors th international symposium fundamentals computation theory fct volume lncs pages beck germany august 
springer verlag 
lincoln mitchell mitchell scedrov 
probabilistic poly time framework protocol analysis 
proc 
th acm conference computer communications security pages 
gavin lowe 
breaking fixing needham schroeder public key protocol fdr 
proc 
nd international conference tools algorithms construction analysis systems tacas volume lecture notes computer science pages 
springer 
gavin lowe 
breaking fixing needham schroeder public key protocol fdr 
tiziana margaria bernhard steffen editors tools algorithms construction analysis systems second international workshop tacas volume lncs pages passau germany march 
springer verlag 
michael merritt 
cryptographic protocols 
phd thesis georgia institute technology 
daniele micciancio bogdan warinschi 
soundness formal encryption presence active adversaries 
proc 
st theory cryptography conference tcc volume lecture notes computer science pages 
springer 
mitchell mitchell scedrov 
linguistic characterization bounded oracle computation probabilistic polynomial time 
proc 
th ieee symposium foundations computer science focs pages 
roger needham michael schroeder 
encryption authentication large networks computers 
communications acm december 
otway rees 
efficient timely mutual authentication 
operating systems review 
lawrence paulson 
inductive approach verifying cryptographic protocols 
journal cryptology 
birgit pfitzmann michael waidner 
composition integrity preservation secure reactive systems 
proc 
th acm conference computer communications security pages 
extended version matthias ibm research report rz may www org publ ps gz 
birgit pfitzmann michael waidner 
model asynchronous reactive systems application secure message transmission 
proc 
nd ieee symposium security privacy pages 
extended version model michael backes iacr cryptology eprint archive eprint iacr org 
steve schneider 
security properties csp 
proc 
th ieee symposium security privacy pages 
christoph michael backes david basin birgit pfitzmann michael waidner 
cryptographically sound theorem proving 
proc 
th ieee computer security foundations workshop csfw 
paul syverson 
taxonomy replay attacks 
proceedings th ieee computer security foundations workshop pages new hampshire june 
ieee computer society 
reinhard wilhelm shmuel sagiv thomas reps shape analysis 
david watt editor compiler construction th international conference volume lncs pages berlin germany march 
springer verlag 
proof subject reduction possible steps protocol implementation main body mentioned proof lemma induction length run give precise account possible steps structure consisting thn 
pn 
mentioned internal state pi consists sequence pairs process environment giving values free variables variable occurs domains environments different processes value environments 
values variables integers term handles represented integers 
assume variables typed statically known contents variable payload handle 
typing enforced trivial type system containing just types 
participants may active time 
exists active participant pi state additionally contains index currently running process sequence processes running process environment received message channel apparent sender state combination thn 
pn contains database machine thn contents buffers secure authentic channels participants 
combination thn pn active pi perform kinds steps 
adversary may invoke local adversary command 
command executed thn possibly changing result returned adversary 
participant activated 

adversary may invoke send command 
messages terms thn pairs consisting channel name real message recipient pi message activated index currently running process initialized running process environment initialized received message channel apparent sender initialized received message 
message handle apparent sender public integer 
step remove message buffer channel participants channel secure authentic 

user may send message corresponding participant 
participant activated way receiving message network 
message secret integer apparent sender public integer channel channel user 
combination thn pn active pi perform kinds steps 
initiated pi 

running increment index currently running process 
index larger length sequence processes pi inactive 
consider channel mentioned receive statement process pointed equal running process environment th element sequence processes receive command process 
environment additionally map variables receive statement channel mentioned receive statement equal start step 
assume running process environment defined 
step depends command 
parallel composition input processes put processes environment back sequence processes pi 
put just position process th position replicated remove sequence processes 
inactive 

send command rest process process parallel composition input processes 
construct outgoing message pairing channel real message mentioned send command 
handle described 
right inactive send outgoing message away receiver mentioned send command 
step adds buffer channel participants channel secure authentic 

ii 
command evaluate expression possibly interacting thn evaluate expression 
successful update environment take default false branch depending success evaluating expression 
constant expression evaluated result public integer 

command compare take true false branch 
initially processes state pi protocol specification 
environments empty 
database empty 
buffers channels empty 
participant active 
relationships variables valid abstraction values protocol show constraint variable rb variables protocol point context sb rb valid abstraction set constraints describing relations variables collected far 
protocol label possible context successful evaluation command protocol point cb set constraints compute sb rb lemma 
av av av av exists av av av av av proof 
induction shape subterms av av values equal anypubval 
case av av av 
second case av equal av av 
subterms av av equal anypubval av equal value av av done 
types av av equal correspond type immediate subterm av av corresponding immediate av av 
find av av av av av values av construct value av necessary properties 
lemma 
run step successful evaluation label replica ik 

ik 
assume lemma holds run step 
mapping var sets values var exists av ik av var constraint cb exists av ik av proof 
induction length path protocol 
induction assumption claim lemma holds constraint introduced preceding suitable mapping variables mentioned changed values lemma holds introduced set constraints protocol point 
claim lemma obviously holds 
label statement 
labels statement cases handled 
premises lemma state statement successful returns true ik ik 
ik av av premises lemma 
labels statement case analysis possible contain av ik av lemma 
run step successful evaluation label replica ik 

ik 
assume lemma holds run step 
variables var exists av rb 
ik av variable exists av sb 
ik av proof 
define mappings fi gi sets values fi gi gi fi gi fix point theorems tarski kleene know sb gi 
sets rb finite exists sb gi 
induction show exists av fi av gi 
ik av 
ik av induction base premise lemma 
induction step gi fi follows lemma right hand side constraint cb lemma intersection 
step fi gi follows lemma 
induction length induction base length run 
terms variables assigned values exchanged messages 
claims lemma trivially true 
induction step assume lemma holds run step 
consider possible steps show claims lemma continue hold 
step st kind 
adversary may create new term parse existing term 
claims clearly hold run step change mentioned claims 
command thn may effects new term created encryption 
holds run 
immediate subterms term adversarially constructed induction assumption holds 
new term representing public symmetric key encryption created 
holds reasons previous case 
key plaintext known adversary second case holds 
command creating term created respective term existed 
term payload list 
adversarially constructed created adversary case 
holds run 
holds new encryptions created 
command parsing term giving component holds run 
subterms adversarially constructed adversarially constructed holds run 
exists av av definition exist subterm av av av anypubval value defined structural induction av anypubval 
constraints representing power adversary av may need elaboration 
av anypubval known adversary adversarially constructed induction assumption 
satisfies bullet point definition adversarially 
satisfied run 
step nd kind 
effect quantity mentioned lemma 
step rd kind 
effect quantity mentioned lemma 
step th kind 
step affects values variables hold run hold run step 
semantics processes channel source message secure authentic channel exists av cc av constraints receive commands av belongs rb variable going hold message insecure channel known adversary implying anypubval anypubval rb 
denotes channel user protocol secret integer belongs meaning xs belongs 
variable xp holding apparent sender get value public integer xp xp 
step th kind 
effect quantity mentioned lemma 
step th kind 
step may add new terms channels adversary knowledge 
effect quantity mentioned constraints send command obvious hold run held step 
step th kind 
effect quantity mentioned lemma 
step th kind 
process step inside replica 
ik 
ik 
step affect quantities mentioned evaluating expression assigning result variable program point 
depending success evaluating default false branch taken 
induction assumption true variable controlling program point reached third argument 
definition see lb true resp 
lb false true iff resp 
true 
induction assumption variable defined execution step replica ib contains av 
ik av consider possible cases definitions see succeeds resp 
fails resp 
true 
holds step set encrypted terms key affected 
induction assumption implies held step continues hold step 
definition see true constraint rb ib 
considering possible cases making induction assumption ib decryption see result value belongs av av rb 
av rb value member av exists variables var premises lemma fulfilled claim holds replace rb sb holds step step th kind 
step affects control flow protocol hold run hold run step 
claim directly follows lemma 
compared variables integers xs xp member ib correct induction assumption xs xp member ib 
comparison elements ib ib returns true 
lb true true holds run 
compared variables equal term handles pointing term exist av ib av ib av av lemma states av av apply lemma run step 
run step claims lemma hold induction assumption 
lb true true holds run 
lemma 
assume lemma holds certain protocol run 
database thn run 
term database av av values av av av av proof 
induction structure base subterms values semantics may contain anypubval 
second constructor determined type arguments may determined location created 
av av anypubval equal values 
say av anypubval known adversary adversarially constructed 
av equal anypubval done 
consider possibilities definition adversarially 
exist value semantics contains value equal av exist value constructed adversary case value anypubval semantics contains step subterms 
type data list pke pkse enc symenc 
type pke pkse exists value anypubval semantics contains argument induction basis applies 
assume type data list enc symenc 
av av anypubval outermost constructor 
different constructors values correspond different types terms database av av iff corresponding av av related corresponding intersect intersection contains corresponding subterm induction assumption corresponding subterms av av related av anypubval av anypubval known adversary adversarially constructed 
consider possibilities 
type enc symenc constructed protocol participants 
outermost constructor av symenc 
adversarially caused existence av av term av outermost constructor av definition gives av anypubval 
argument previous paragraph gives corresponding subterms av av related outermost constructor av av symenc definition gives av anypubval av type enc symenc constructed adversary 
value semantics contains anypubval av impossible 
type data 
av store xp store xs 
definition store xp anypubval 
av store xs av definition adversarial 
type list 
outermost constructor av tuple constructor 
exists av av argument symenc outermost constructor av tuple constructor corresponding components av av related av anypubval 
exists av subterms call 
tk adversarially constructed adversary know ti anypubval av av av ti av induction assumption av anypubval 
av anypubval anypubval 
properties av anypubval 
av anypubval av anypubval swap av av apply argument 
av av anypubval av av 
