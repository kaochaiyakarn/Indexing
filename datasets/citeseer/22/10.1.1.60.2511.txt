test driving reusable components stuart marshall thesis submitted victoria university wellington fulfilment requirements degree doctor philosophy computer science 
victoria university wellington april developers need evaluate reusable components decide adopt 
developer evaluates component need understand component behaviour component exhibit 
existing evaluation techniques formal analysis sophisticated classification search functionality rely presence extensive component documentation evaluation component versions 
model describing developers gain hand experience component runtime behaviour test driving directly invoking monitoring behaviour 
analyse issues model raises 
propose test driving done developer currently test driving done marketplace component initially 
analyse issues raised shifting test driving marketplace 
propose architecture data formats support marketplace test driving 
spider proof concept prototype marketplace test driving 
developers spider test drive reusable components standard web browser storing information extracted server side runtime environment back developer software visualisations 
argue approach provide developers new way evaluating reusable components turn support efforts making correct reuse decision 
name front thesis reads lone thesis student stands army support 
leading charge dr james noble dr robert mission dealing years 
ability comprehend initial drafts come back read example 
partner constant source strength appreciated distractions phd 
wrong kind set 
completing phd possible 
parents supportive long drawn study love 
various people come gone returned back school mathematics statistics computer science victoria university wellington simple pretty 
lastly phd preceding masters twelve years making 
members human race successfully delayed species submit 
feel free continue 
contents reuse 
component reuse 
evaluating components 
thesis contributions 
thesis organisation 
related reuse 
software crisis 
benefits reuse 
reuse 
components 
software development 
component definitions 
repositories marketplaces 
reuse activity 
tool support 
reuse tasks 
reuse costs 
finding components 
quality 
intellectual property 
program comprehension 
learning 
modeling comprehension 
software visualisation 
execution traces 
web tools software engineering 
requirements analysis design tools 
publishing 
access non web tools 
maintenance monitoring debugging 
summary 
contents test driving test driving learning activity 
basis model 
example components 
marketplace support 
test driving versus evaluation techniques 
test driving model 
step accessing component 
step analysing component interfaces 
step determining test drive input 
step determining test drive output 
step encoding test drive input 
step encoding test drive output 
step setting system 
step cleaning system 
step executing test drive 
step viewing results 
step eleven deciding reuse 
step twelve adopting discarding exploring 
test driving artifacts 
test harness 
component 
component repository 
component interfaces 
documentation 
execution environment 
test drive report 
test driving software testing 
traditional software testing 
appropriateness versus correctness 
incomplete knowledge 
summary 
test driving marketplace test driving issues 
trust 
cost 
availability 
test driving marketplace 
web enabled test driving 
analogies web enabled marketplace test driving 
documenting components marketplace 
adhering test drive model 
analysing component 
preparing test drive 
execution 
solving problems test drive model 
contents trust 
cost 
availability 
web issues 
accessibility 
environmental differences 
trust 
software visualisation 
visualising test drives 
deciding particular visualisations 
summary 
architecture marketplace test driving vare 
component repository 
component set 
engine repository 
engine process 
test drive report repository 
transformer repository 
transformer 
visualisation repository 
visualisation 
session manager 
component repository interface 
test drive interface 
test driven program interface 
transformer repository interface 
visualisation interface 
documenting components 
component 
component 
component reused 
storing test drive reports 
intermediary storage 
process abstraction language 
reusable component description 
xml trace execution 
summary 
spider test driving model 
analysing component 
writing test drive 
execution 
test driving marketplace 
accessibility 
environmental differences 
contents trust 
documenting test drives 
component repository interface 
test drive interface 
session manager 
component repository 
component set 
engine repository 
engine 
test drive report 
test drive repository 
evolution spider 
dyno 
usability evaluation dyno 
dyno spider 
contributions 
test driving model 
marketplace test driving 
architecture marketplace test driving 
comparison related 
test driving model 
marketplace test driving 
architecture marketplace test driving 
discussion 
trust control 
reducing shifting costs 

usability evaluation 
integration marketplaces 
addressing web issues 
summary 
chapter thesis models analyses presents tool support technique understanding evaluating reusable software components component marketplace 
technique providing developers hand experience component behaviour 
visualisation documentation created developers experiences documentation community resource assist developers 
reuse researchers proposed software reuse means reducing cost software development improving quality software 
software reuse involves existing software new context software author may may designed software new context 
developer reuses existing software avoid designing implementing testing maintaining duplicate software functionality provided 
reusing piece software lead improvements software software continually executed new contexts 
executing software new contexts lead identifying subsequently resolving faults encountered earlier software testing 
identifying resolving faults improve quality software 
component reuse concept software components arisen context software reuse 
jacobson define general concept component high quality type class uml designed documented packaged reusable 
component cohesive stable interface software components components contain code source form compiled form 
means interested components independently part larger system executed way 
mcilroy argues software development 
mcilroy argues deliberately creating reusing reusable components lead necessary occurred industries 
component reuse subset software reuse 
scope component reuse includes designing software parts chapter 
developers easily combine parts form new systems 
scope component reuse includes techniques tools easily combining existing parts required systems 
developers perform variety tasks reuse existing components 
tasks searching relevant components evaluating components identify appropriate match retrieving appropriate component integrating retrieved component developer new system 
evaluating components method evaluating component experience component behaviour 
component authors typically provide evaluation versions component developers invoke component behaviour witness results 
evaluation versions reusable component marketplaces 
evaluation components analogous number industries car market car buyer test drives car committing purchasing vehicle 
essence developers test drive components ensure component meets needs just test drive car 
component marketplaces web intermediary component authors wish sell components developers wish adopt reuse components 
test driving new activity understood 
thesis model activity test driving reusable components 
purpose modeling test driving understand issues affect developer success evaluating reusable components issues resolved 
resolving issues may lead reduction costs developer attempt reuse 
turn affect developer desire consider reuse viable alternative recreating solutions old problems 
currently developers component evaluation versions invoking component behaviour developer system 
developer trust component negatively affect system 
marketplace trust developer intellectual property built component developer financial commitment marketplace author 
cost test driving developer system may expensive time effort lack available component documentation may limit developer ability comprehend component 
executing components result component code generating extremely large number events data items runtime environment 
events things method calls security checks 
data items things objects input output 
events data items represent potentially interesting information developer evaluation 
information needs developers meaningful manner integrating existing software visualisation research component reuse solution issue 
issues arise evaluating reusable components test driving may resolved considering new forms tool support 
thesis propose tool support allows developer test drive reusable component web marketplace visualise information extracted component execution 
provide architecture tool support demonstrate proof concept permits test driving reusable components web 

thesis contributions thesis contributions contributions thesis 
twelve step model test driving reusable components 

analysis test driving marketplace resolve issues trust cost availability raising new issues trust accessibility environmental differences 

architecture proof concept tool support merges marketplace test driving software visualisation 
thesis organisation chapter discusses related 
identify current state practice component reuse web case tools software comprehension 
informs chapters serve basis comparing contributions existing knowledge base chapter 
chapter presents model test driving reusable components 
identify twelve steps developer follows evaluate candidate reusable component 
differentiate test driving traditional software testing 
chapter argues test driving done web marketplaces developer place 
analyse new issues arise developers test drive reusable components web marketplaces 
finish chapter discussing role software visualisation play test driving activity 
chapter presents architecture data formats supporting web marketplace test driving 
identify key parts system web marketplace test driving information stored inform developers happened test drive 
architecture links test driving existing software visualisation research 
rcd xte data formats contribute means storing test driving information visualisation independent manner 
chapter presents prototype tool called spider proof concept idea web marketplace test driving 
show spider supports model chapter solves issues trust accessibility identified chapter implements parts chapter architecture responsible web test driving information retrieval information storage 
chapter summarises thesis contributions field knowledge places contributions context related discussed chapter 
briefly discuss test driving software visualisations fit known software visualisation taxonomy effects architecture 
close outlining line research 
chapter 
chapter related exploring web tool support test driving reusable components 
research crosses variety different fields computer science discipline 
fields include component reuse program comprehension web software engineering tool support software visualisation 
chapter discuss relevant research fields 
discussion provide context contributions chapters 
discussion referred chapter summarise contributions explicitly identify complement existing 
introduce central ideas software reuse discuss concept reusable component 
discuss component repositories marketplaces 
explore program comprehension techniques including software visualisations currently applied variety tasks program traces extracted stored 
finish discussing web tools software engineering 
reuse core assumptions thesis software reuse useful worthy need support 
jacobson define reuse repeated artifact 
typically software artifacts designed outside original context create new systems software artifacts interested code integrated code form executable software 
code come variety forms ranging human readable source machine readable binaries 
claimed software reuse improve quality reduce cost software development 
claim response ongoing software crisis researchers perceive affected software industry ability meet demand 
briefly recap software crisis discuss benefits reuse depth 
software crisis half th century st century society progressively reliant software 
reliance facets modern life public services private enterprise chapter 
related life death scenarios popular entertainment 
researchers persistently called question ability software developers supply sufficient high quality software affordable cost meet increasing demand 
issue perceived inability software developers resolve issue known software crisis 
nato science committee conference term software crisis term software engineering 
resulting discipline attempt software development copy rigour experiences traditional engineering 
objective create software development practices tools enable creation high quality low cost software context time resource constraints 
subsequent research new methodologies tools practices yielded improvements software quality cost 
increasing demand dictated approaches need explored 
software reuse approach 
improvement methodologies tool support software development activities faster 
comparison software reuse promises eliminate design implementation activities altogether parts system functionality provided existing software 
benefits reuse researchers argued software reuse improve productivity quality software products 
productivity goals software reuse reduce amount time resources required develop software removing need redesign reimplement old solution existing problem 
claim software companies need shorten development times take advantage new technologies new markets reduce development costs ensure prices competitive 
removal significant amounts design implementation promise achieve positive results time cost 
removal design implementation come cost see section 
quality reuse software new context result software tested real 
component spreads different development teams cumulative effect testing rapidly uncover bugs 
bugs fixed fixes propagated back developers reusing component 
wide spread testing undertaken team result stable error free software 
tried tested components higher quality product 
performed empirical study supports idea reusable software fewer defects stable non reusable software 
tracz argues improved quality means software reuse main benefit 
reuse maintenance activity pre release design implementation activities 
reuse 
people frequently reuse designs different contexts 
example vehicle car 
courier may cars particular model courier packages city 
private individual may different instance car model commute 
individual car design transport context nature transported differ 
jacobsen quote start section offers definition term reuse context software engineering 
reuse activity purpose existing solutions problem instance problem arises new context 
definitions exist 
particular note tracz defines software reuse process reusing software designed reused tracz definition see emphasis reusing existing software crafting software easier reuse 
software engineering artifacts reused 
include limited things software design models cases documentation 
artifacts developers may reuse development processes different software projects 
management reuse artifacts reuse software development methodologies topic research decades 
tracz notes reuse software software exist 
software reusability research seeks find better ways software easier reuse 
tracz argues software reusability considered dimensions usefulness software usability software quality software adaptability software portability software 
discuss reuse software design reusable software contributions thesis understanding evaluating existing software 
argue broadly different scenarios reusing code 
scenario involves unit source code called component defined section exists context component new context 
results component reused 
second scenario involves replacing component context component 
results context reused 
context piece code invokes component 
model reuse integration components contexts 
context component communicate solely interfaces communication represents dependency context component 
interface context component described listing dependencies dependencies categorised dimensions degree dependency intended component author degree programming language supports implementing checking dependency 
reuse component context assisted programming language features 
researchers particularly noted features object oriented programming languages may assistance software reuse 
note chapter 
related inheritance polymorphism assist context reuse horowitz munson note inheritance classes composition genericity assist component reuse 
components discuss software components 
primary focus thesis propose analyse techniques tools support reuse software components 
section discuss reason industry researchers proposed software components 
discuss various definitions term component put forward preceding decades 
finish section discussing role component repositories marketplaces far played 
software development mcilroy argued software development needed component centric software engineering 
mcilroy proposed components emergence object oriented paradigm mcilroy idea component source code representations reusable subroutines 
software development result new software applications composed existing components 
component software development similar component industries aeroplane manufacturers entertainment industry 
manufacturers build new aeroplane models components components build types 
aeroplane components may product sold manufacturer building composite products 
software development component main task software implementation selection relevant components composition components 
similarly entertainment industry reuse ideas create new movies 
may sound far fetched demonstrate generality underlying ideas 
majority romantic follow formula developing conflict resolving conflict suitably happy 
likewise commercially successful widely known action franchise th century james bond series noted critic roger ebert basic plot formula nearly films series 
case james bond film series say films component ian fleming novel 
fleming novel casino soon reused movie adaptation third time 
environments characters reused film reduce necessity create introduce aspects new stories jaws spy loved subsequent popular reuse 
despite years having passed mcilroy proposal researchers existence software crisis argue software industry fully realised benefits component driven development 

components component definitions meyer notes computer hardware industry successfully uses components manufacture high quality standardised cost efficient products single widely agreed definition software components 
commonalities various proposed definitions 
meyer defines component element program properties element may program elements clients clients authors need known element authors meyer argues component described number orthogonal viewpoints 
viewpoint component accessibility defined meyer interface description source information hiding 
possibility components highlighted define component binary code offers set related services published interface jacobson pick theme component interface important defining component high quality type class uml designed documented packaged reusable 
component cohesive stable interface jacobson definitions explicitly mention interface interface contract offer request services 
published contract remove need components explicitly aware requesting services satisfies meyer requirement component author need know developer reusing component 
add aspect definition component claiming component 
follows tracz views software reusability judged usefulness usability quality adaptability portability 
component characteristics presumably stand chance 
requirements raise barriers reuse shall see section 
szyperski defines component unit deployment versioning replacement 
szyperski components functionality incoming interfaces describe dependencies outgoing interfaces 
szyperski claims components executable human intervention deployment components outside development process deployment rely skills developer 
repositories marketplaces global component market benefit wide scale adoption component software engineering 
market benefit developers component authors chapter 
related 
developers benefit market provides centralised access existing component collections 
centralised access reduce number disparate search spaces developer navigate find suitable component 
authors benefit market connects large collection potential buyers 
market support trusted payment system provides income authors develop components purely reuse 
market increase number existing components easily available developer provide business environment authors create components 
main problems facing component reuse lack available components studying create support market worthwhile goal researchers 
global component market gained significant software engineering industry despite academia industry promoting component reuse years 
section shall discuss gradual rise commercial component marketplaces characteristics marketplaces problems marketplaces face 
delve topic commercial component marketplaces shall take look general component repositories 
repositories contrast component marketplaces component repositories existed years house collections single support user groups certain languages environments 
components repositories typically free access may restricted particular group 
offered enhance productivity quality product lines encourage adoption technology solving common problems user base encounters 
word repository mean warehouse depot reusable components stored retrieved 
lack available components seen barrier widespread reuse large companies sought create private collections employees leverage multiple projects 
examples companies ericsson hewlett packard motorola 
warehouses depots typically store software components artifacts software engineering lifecycle considered 
guo survey number repositories 
guo argue trend commercially sold repositories integration case tools support software engineering 
argue trend government repositories web accessibility governments ensure wide range public servants access available components 
contributions chapters build web accessibility integrate component evaluation understanding browser tools support software engineering see section 
marketplaces time market grown producing code components purely sale 
component marketplaces developed meet needs market 
component marketplaces viable businesses relatively 
components 
suggest hyperlinks connect components documentation repository component marketplaces typically located web 
rise web markets developers access large audience consider developing reusable components income 
web excellent geography independent marketplace witnessed rise internet companies amazon shift traditional bricks mortar companies having web presence 
web markets offered reasons cautious optimism component reuse 
commercial markets infancy thomas discuss software component markets compare perfect markets economic theory 
describe multi agent system architecture software component marketplaces 
architecture uses number component market ontologies 
ontologies describe marketplace component domain considered advertised 
offer high level view ontologies shared agents marketplace 
ontologies modeled uml 
ability share change ontologies allows agents react changes domain knowledge 
supporting reuse marketplaces support reuse component collections supplying versions components accessed adopted licensed 
typically referred evaluation versions developers download systems experimentation 
numerous researchers investigated marketplaces support reuse 
guo claim marketplace functionality 
automated library system graphical user interface browsing searching retrieval 
standard component framework include purpose functional description certification level key environment constraints historical results usage legal restrictions 
effective classification scheme domain 
thorough system component documentation 
guo claim marketplaces accessible different platforms offer tool support identification comparison evaluation retrieval integration components 
argue marketplaces support developers search evaluate components standard documentation frameworks required improve component understanding 
claim marketplaces provide functionality protect component author intellectual property 
claim marketplaces best served concentrating black box reuse components 
black box reuse require access source code easiest form reuse developers undertake 
ravichandran concur importance search evaluation black box reuse functionality success component marketplaces 
chapter 
related van argue favour components offered intermediaries components supplied quality ratings 
part ensuring suppliers need easy customers assess value component offering extensive information example demos documentation user preferences hong lerch undertaken study consumer preferences behaviour software evaluation 
goal explore link component objective features resulting consumer behaviour component evaluated 
hong lerch hypotheses 
number methods software component significant positive effect consumer preferences purchasing behaviour 

popularity indicator software component significant positive effect consumer preferences purchasing behaviour 

number lines code software component significant positive effect consumer preferences purchasing behaviour 
study computer science master degree students producers business administration master degree students consumer 
study supported second third hypotheses study analyse required 
reuse activity software reuse activity 
researchers model activities understand tasks activity understand costs benefits 
models assist reducing costs benefits 
software reuse embraced industry rising popularity component software engineering cbse 
cbse development individual product integration activity implementation activity 
component software engineering touted revolution software development 
variety strategies available reusing software 
ravichandran discuss types component reuse strategies 
strategies black box reuse external components black box reuse internal components white box reuse internal components 
purposes categorisation internal component created organisation developer belongs 
external component created different organisation 
tool support researchers exploring tool support reuse 

reuse activity example orion re integrated development environment 
alvaro analysed requirements cbse determine collection software tools comprises orion re 
alvaro performed evaluation orion re industry demonstrating usefulness component case tools commercial applications 
requirements listed orion re include language technology independence reusability components publishing 
second example ye fischer source code help identify candidate reusable components :10.1.1.1.6877
ye fischer take approach analysing source code developers creating semantic meaning querying centralised repository identify reusable components developer current context 
increasing component technology number standards service suites risen 
standards suites enable easier integration clearer understanding component purpose easier switching different components 
standard sun microsystem javabeans 
javabeans java components adhere particular style api description offer common functionality 
developer component reuse experience javabeans query functionality new 
similarly javabeans adhere published api description tools automatically query javabeans assist integrating different javabeans 
standard microsoft com component model 
components allow application suites microsoft office share certain functionality spreadsheets applications microsoft word microsoft excel microsoft powerpoint 
microsoft com programming architecture developing components combination runtime environment runtime services integrating querying components 
standards provide technique organising component description services access exploration partly automated 
example support accessing integrating components common object request broker architecture corba 
reuse tasks cbse lifecycle considered phases domain analysis component design development component cataloguing retrieval component selection application assembly 
phases require looking ahead see possible reuse 
second phases require integrating available components meet requirements new application 
wang argues component representations lacking building existing components difficult due non standard component documentation formats 
consider tasks involved reuse existing components 
identify tasks search components selection evaluation located components comprehension components integration adaption selected components 
describe model selecting commercial shelf software 
model describes evaluation criteria formed variety sources components screened possibilities explored suitability 
model go great detail information component may extracted evaluation phase concentrates chapter 
related developer may want hypothetical perfect component 
method main stages evaluation criteria definition search screening evaluation analysis results 
describe main categories need considered component evaluation 
categories functional requirements product quality requirements strategic concerns domain architecture compatibility 
examples strategic concerns include issues acquisition costs amount effort saved 
developers need select evaluate components ensure suitable proposed new context 
traditionally researchers tackled need evaluation directions providing suitable classifications query languages filter unsuitable components providing component testing techniques 
discuss related classification querying component testing 
classification area repositories markets received significant attention classify components 
researchers identified lack components engineering barrier successful reuse repository intelligently classify components provide powerful search mechanisms suffer reverse problem 
reduce disadvantage large search space researchers explored variety different techniques indexing querying component databases 
goal organising components repository market speed retrieval useful candidate components reuse context 
henninger lists different techniques organising components repository 
techniques faceted classification enumerated classification free text indexing 
prieto di az describes faceted classification synthetic approach 
components classified selecting keyword pre defined keyword sets 
classification scheme set keyword sets called facets synthesised class component key facet 
scheme european indian book libraries 
queries created selecting keywords facets matching known classification 
prieto di az performed studies facet classification number repositories identified cost classification problem scheme 
argued faceted classification works best domain specific repositories 
repositories component domain stored facets general lose effectiveness 
mili argue faceted classification grounds manual task classifying component greater cost benefit derived facet queries string queries 
particular mili question appropriateness facet queries initial stages component selection developer fully form solution take 
enumerated classification assumes list available classes component placed act classifying component selecting class 
dewey decimal system book libraries example enumerated classification 
facet enumerated classifications controlled vocabularies 
cause difficulties developer unsure vocabulary means 
reuse activity vocabulary subtly different different repositories 
alternative approach automatically extract information analysing component source code interface accompanying documentation 
approach allows queries written natural language ranked candidates classification closeness 
querying techniques proposed helping developers find appropriate reusable components 
dio surveys state art text component search retrieval 
dio identifies research classification schemes see section statistical analysis important contributors allow developers formulate queries controlled uncontrolled vocabulary 
yao formulating queries natural language 
henninger argues formulating queries hard 
henninger observes designer understanding problem evolves searching component formulating search terms initial stage quite difficult 
frakes pole claim classification techniques show appreciable difference effectiveness retrieval henninger claims indicates search effectiveness heavily influenced effectiveness query 
henninger presents codefinder tool 
codefinder supports incremental creation queries developers providing feedback results earlier queries 
codefinder uses associative reasoning creates network components share similar keywords terms matched similar necessarily identical vocabulary developer queries 
mili discuss different types retrieval algorithms exact retrieval approximate retrieval 
different algorithm types meet different developer needs 
developer wishes reuse component satisfy requirements needing modify component developer needs exact retrieval algorithm 
exact retrieval algorithms return components specifications proven match specifications developer requirements 
developer willing able modify component developer employ approximate retrieval algorithm 
algorithms return set components specifications transformed meet developer specifications minimal effort definition minimal 
podgurski pierce propose method retrieving suitable components exploiting component executable nature 
differs approaches henninger frakes utilise text information contained linked component 
podgurski pierce introduce concept behaviour sampling 
developers searching components specify target interface specification identifies desired component output certain input 
podgurski pierce system attempt automatically match specification actual interfaces components repository 
component matched executed sample input contained specification 
developer informed component execution creates desired output 
podgurski chapter 
related pierce preliminary experiments show behaviour sampling accurately retrieve useful components small sample set test data 
inoue propose method ranking components exploiting interrelationships 
approach demonstrated tool enables ranking components amount times known applications 
component testing significant automated component program testing 
component author predict possible reuses component prudent developer reuses component perform testing 
component testing research covers automated generation test cases test case management execution 
emphasis testing carried new development practices agile methodologies 
beck extreme programming xp methodology requires developers write black box unit tests driver code development 
researchers developed tool support component unit testing junit tool java classes 
patterson added tools existing integrated teaching environment called 
allows support student interaction executing code object class method level allowing students check executions consistent specifications 
approach demonstrated hoffman utilise boundary value analysis create executable test programs embedded test scripts java code 
researchers investigated techniques devising comprehensive set test case examples better represent set possible interactions 
requires consideration test input observed output input output combined test artifacts test artifacts bundled components assist subsequent integration testing 
consider issues turn 
body relevant thesis contributions offer alternative complementary approach mathematical analysis typically 
thesis supports developers having actively creating new test cases cover aspects component immediate interest 
generating input marinov khurshid propose framework generates input java programs specifications supplied developer 
inputs executed evaluated correctness criteria supplied developer 
specifications correctness criteria provided order relational notation 
approach seeks reduce time effort developer spend generating test cases provide comprehensive coverage component functionality 
similarly liu formal framework specification class testing 
framework supports generation test cases test class methods relationship methods relationship class subclass 
liu focus testing class level marinov khurshid focus testing application level 
mathematical approaches input generation 
ramachandran uses set analysis create test input 
ramachandran decomposes components object models extract test case input boundary analysis 

reuse activity generating output korel schroeder tackle issue automated testing different perspective 
propose technique takes advantage link program input program expected output 
technique involves execution small subset possible test data set 
results subset test data analysed resulting analysis creates expected output entire test data 
entire test data program actual output automatically compared expected output 
technique seeks reduce amount time effort developers need spend creating test data oracles measure success particular test case 
automated testing approaches korel set mathematics determine link input output 
combining testing artifacts complemented research test case test result generation combines setting test cases subsequent execution analysis 
ai planner generate independent fully contained test programs test class behaviour 
approach requires test cases closed specifications classes provided 
closed specifications generate sequence methods necessary satisfy pre defined condition 
demonstrate prototype tool generating test programs uses deterministic tree searches closed specifications 
research focused creating black box test cases formalised requirements test cases closely mapped actual needs component application 
propose method creating system model system requirements utilising system model generate test cases large applications 
system model represented extended finite state machine 
component deployment testing research deploying test suites components 
research resulted component deployment testing cdt framework supports bundling execution test cases components developers download 
framework goals 
support early specification documentation test cases developers 

provide execution environment developer system performing tests 

facilitate reuse test cases 

deliver test suites developers 

provide additional form behavioural documentation 
cdt proposes developer creates spy classes describe functionality developer wishes component 
driver classes spy classes xml mappings desired functionality actual component implementation test particular component 
spy classes mappings created component authors developers easily re test components environment gain level trust component 
chapter 
related reuse costs despite promise reuse improve productivity quality software development process reuse institutionalised industry 
technical non technical reasons 
jacobsen argue categories problems face systematic reuse engineering process organisational business 
engineering problem includes lack flexible high quality reusable components lack tool support technical difficulty identifying reuse opportunities 
process problem includes lack reuse consideration specified wide spread software development methodologies 
organisational problem relates lack support managing reuse coordinating multiple projects common reusable elements 
organisational problem includes problem lack trust lack shared information regarding reuse opportunities 
business problem relates issues cost financial required develop reusable software explore legal educational requirements making reusable software reusable 
reusable software cost times develop non reusable software due need domain analysis identifying probable commonalities 
engineering organisational business problems particularly relevant thesis 
introduce describe tool support provides evaluation documentation reusable components 
documentation created hand experience component behaviour identify reuse opportunities 
documentation understand component trust component advertised functionality consistent component really 
chapter analyse documentation built community developers stored central repository dissemination interested parties 
creating reusable components costly developer initiated documentation provides cheap source details components may help improve reuse appeal 
improvement lead developers adopting component component author costs compensated 
evaluation experience documentation acts form education 
describe process evaluating documenting reusable components behaviour discuss process integrates existing software development reuse practice 
thesis seek address process problem identified jacobsen discuss issues finding reusable components quality reusable components intellectual property considerations reusing components 
issues contained jacobsen categories addressed thesis 
finding components finding reusable components engineering problem 
mili concur key issues building applications reusable software issue retrieving components 
identify need developer translate requirements query performed component repository 
mili identify problems integrating existing components current projects role understanding alleviating problem 
mili identify key areas 
reuse costs methodologies tools need better support programmers locating reusable assets assessing asset relevance current needs adapting relevant asset needs 
focussing finding components thesis shall address assessment components assist developers identify component adapted 
quality quality proposed benefits software reuse benefit dependent developers capable creating high quality trusted components 
long identifies lack testing certification problems car fiasco anti pattern reuse 
long argues moral learnt reuse experience assets aren product quality typically come back 
meyer discusses grand challenge trusted components 
particular meyer argues quality important reusable components non life critical non reusable software 
meyer argues minor flaws may left unresolved due time constraints non reusable software potential major flaws new context 
reusable software exercised wider variety contexts possibility increases software context minor flaw causes major problems 
meyer proposes component quality model defines categories criteria trusting component 
categories acceptance behaviour constraints design extension 
examples criteria categories 
reuse attested acceptance 

producer reputation acceptance 

published evaluations acceptance 

examples behaviour 

usage documentation behaviour 

extensive test cases design 

mechanisms addition extension 
thesis shall address categories supporting developer create publish component evaluations developer specification control component execution 
argue mixed success components mission critical applications difficult develop trust required adopt component application 
describe creation contract system classify behaviour interface component 
propose usage model technique certifying component specified reliability constraints 
certification method requires software usage modelled resulting model create profile component 
profile model generate test cases test chapter 
related cases executed identify bugs 
subsequent bugs resolved component certified correctly uses 
profile contains uses developer uses profiles retrieve suitable component current context 
thesis builds actively supporting developer model component requiring developer rely component author provide model profile 
intellectual property software component contains author intellectual property ip 
adequately protecting ip encourage authors continue developing new components market 
ch vez wiederhold discuss issue licensing components ensure authors adequately developers adequate protection usage rights 
ch vez discussions explicitly prohibit distribution source code licensed component identify author needs strongly consider source code able modified integrated third party systems 
ch vez discuss aspects regular software application license context licensing software components 
aspects license payment ownership liability support warranties confidentiality 
aspects change applied software components software components integrated systems 
integration necessitates new understanding ip infringement faults cost issues 
agrees licensing payment key issues authors marketplaces need address consider entering reuse business 
ip concerns arise developer decides adopt component developer provided version component evaluate suitability 
significant research obfuscation making algorithms designs data structures hard reverse engineer understand 
examples include thomborson 
chapter shall introduce analyse approach reduces ip risks may occur prior developer adopting licensing component 
argue source code distributed binary components 
source code contains author ip format easy extract 
analysis source code technique developers trust component advertised functionality consistent implementation 
evaluation technique provide trust requiring access source code 
program comprehension purpose program comprehension understand existing piece code 
reason understanding piece code maintain evolve reuse code 
identifies software engineering tasks require program comprehension maintenance perfective maintenance corrective maintenance reuse code leverage 
thesis proposes models introduces tool support 
program comprehension technique understanding evaluating reusable components 
interested role program comprehension plays reuse process 
researchers modeled program comprehension investigated techniques enhancing comprehension developed tools support software engineers 
section shall discuss people learn knowledge describe various models proposed program component comprehension 
shall discuss techniques supporting comprehension learning example software visualisation 
thesis contributes architecture visualising reusable components shall focus particularly related field software visualisation 
software visualisation representation underlying information shall finish section discussing existing approaches extraction storage underlying information 
learning develop comprehension body knowledge person learn knowledge 
psychologists argue people learn experience 
shall briefly discuss model learning discuss role experience learning examples learning 
modeling learning theory psychology called constructivism 
define central principle constructivism people construct meanings experiences told discuss role constructivism teaching science 
constructivist teaching argues students form models current understanding test models identify models strengths weaknesses 
constructivism argues learning generative passive reading transmission knowledge teacher student 
thesis takes constructivist approach providing means developers construct models initial understanding component actively test model component actual behaviour 
learning experience claims learners actively involved constructing environments describes experience foundation stimulus learning true stages education 
describes activities playing experience gained means tuning behaviour desired consequences attained certain antecedents 
lists tuning form learning experiences modify neural network gain control thought action 
chapter 
related lists form learning learner manipulates intent discovering interact get reveal 
carroll rosson observed smalltalk programmers attempted understand reuse existing code 
smalltalk programmers demonstrated desire reuse understand component reuse modify existing component 
process exploring uses borrow execute fix feedback compilation execution identified issues 
carroll rosson findings reinforce idea programmers attempt experience code behaviour fully developed complete understanding 
findings identify programmers willing go ahead actions knowing needed know actions basing learning hand experience 
computer scientists researched methods providing developers experiences support tuning 
mitra exemplars help developers comprehend reuse frameworks 
exemplar executable visual model consisting instances concrete classes explicit representations collaborations developers experience visual model execution prod visual model reveal information underlying framework dynamic behaviour static architecture 
developers prod exemplar demonstrate dynamic behaviour selecting objects classes interest invoking methods provided exemplar creator 
developers view static architectural information provided class framework 
information stored form comments describes classes responsibilities relationships 
developers able practise play exemplar integrating new classes create new applications top refinement 
technique expands approach allowing developers effectively create methods attach new documentation component behaviour caused new methods 
korel reinforces notion identifying properties commercial shelf cots components activity worthy supporting processes tools 
korel discusses blackbox understanding cots components due unavailability source code 
blackbox understanding described centering creation test cases 
test cases encode input expected output actual output determine component behaviour 
korel discusses component interface probing determine component properties notes significant turn costly probing may required uncover properties 
korel discusses means semi automated automated test case generation 
include notion creating test cases assertions supplied programmer equivalence partitioning boundary value analysis extract representative inputs components 
comparison thesis model developers manually explore components learn experience exploration 

program comprehension modeling comprehension mayrhauser vans identify common features variety program comprehension models 
particular noted comprehension formulation subsequent testing revision hypotheses 
hypotheses generated developer existing knowledge general domain software engineering activities software specific domain particular program component 
identifies major types hypotheses conjectures hypothesize purpose function design choice conjectures hypothesize method accomplishing program goal conjectures hypothesize classification example variable function 
letovsky models comprehension knowledge base external representations documentation code manuals 
similar theme comprehension model brooks external representations beacons verify developer internal schemas 
comprehension models focus understanding source code due interest program comprehension perspectives software tester software maintainer 
thesis focused software software testers software maintainers may access source code 
taxonomy cognition bloom devised taxonomy measuring learning objectives 
taxonomy divided cognition different levels knowledge comprehension application analysis synthesis evaluation 
levels form ordering cognition ranging recall lowest evaluation highest 
knowledge level cognition demonstrates ability recognise terms behaviour phenomena recognise place particular domain 
comprehension level cognition demonstrates ability translate interpret extrapolate information terms behaviour phenomena 
comprehension application require ability information appropriate situation 
bloom distinguishes comprehension application levels stating demonstrate comprehension correctly information prompted 
demonstrate application person able correctly information prompted recognising situations information relevant 
bloom defines analysis ability separate parts understand relationships parts 
bloom defines synthesis ability combine parts create new immediately apparent creation 
bloom defines evaluation ability create value judgements qualitative quantitative terms phenomena 
level bloom taxonomy builds skills required attain earlier levels taxonomy 
chapter 
related buckley argue bloom taxonomy applied study program comprehension 
furthermore buckley claim current program comprehension research focused primarily lower levels bloom taxonomy 
different knowledge levels appropriate different tasks research higher levels knowledge program comprehension may benefit tasks prevalent expensive software development 
particular task reuse may benefit application synthesis evaluation levels cognition 
chapter show technique understanding evaluating components satisfy higher levels bloom taxonomy learning 
component comprehension research field comprehension focused specifically comprehension components comprehension entire programs 
particularly relevant thesis concerns reusable components 
andrews developed comprehension model component understanding 
model identifies component understanding specialised version program understanding 
goals component understanding model solely understand code understand works needs adapted 
andrews investigated software engineers typically understand software components adapted 
findings indicate comprehension task performed behaviour testing code inspection 
sitaraman discuss role mathematical modeling component comprehension 
argue mathematical modeling critical component software engineering safety critical application due need reason soundly component behaviour 
sitaraman allowance comprehension non mathematical means non safety critical applications note resulting lack soundness may negatively affect productivity quality component reuse supposed improve 
arguments merely apply ensuring components developed correctly respect specifications apply programmer hoping identify integrate correct component current situation 
thesis builds andrews providing technique understanding evaluating reusable components advantage components executable nature 
thesis relates sitaraman providing non mathematical means evaluate component complement replace formal mathematical approaches 
researchers modelled component comprehension modelled components produced tool support component comprehension 
create models com components linking existing component inspection techniques source code analysis 
programmers component inspection techniques explore aspects component architectural structure led relevant parts source code 
information programmer extracted source code compiled version component 
run time behavioural information aid program comprehension 
research extends usual execution traces capture method entry exits include parameter information 
supports object tracking 
program comprehension new means exploring execution trace 
supports limiting execution trace focusing events occur particular subset objects 
note developer may interested entire component program 
describe moose task driven program comprehension environment uses wizards guide developers series reverse engineering visualisation techniques 
techniques extract useful information regarding program component functionality program slicing identify parts program relevant functionality developer interested 
tool support help reduce costs developers pay comprehend existing code 
notkin researched programmers supported comprehending software libraries existing examples library 
tool support utilises existing applications reuse library currently consideration 
central idea class diagrams existing application merged class diagram library 
reuse boundary calculated 
reuse boundary classes example application directly extend classes library classes library directly referenced extended classes example application 
calculating different reuse boundaries different example applications intersection reuse boundaries programmer directed classes library focal point reuse 
tool supports visualisation reuse boundary intersections multiple example applications 
examples selected user demonstrates reuse application code support reuse library code 
introduce tool support chapters uses wide variety behavioural information 
research rely availability source code useful source code may available see section 
propose centralised collections documentation created developers experiences components 
complements notkin providing means library examples built disseminated 
comprehension requirements comprehension requirements differ various tasks performed software development 
explore requirements software maintenance software testing tasks 
reuse technique chapter superficially similar software development tasks particular software testing task 
show chapter key differences technique software testing instructive review similar tasks eye commonalities 
see access source code associated documentation beneficial software maintenance software testing 
contributions thesis remove reliance access source code reuse component comprehension 
software maintenance discuss program comprehension perspective software maintenance 
research involved quantitative study software maintenance 
survey highlighted key points regarding chapter 
related requirements techniques relevant maintenance task 
identify navigable multi layered subsystem inter relationship abstraction knowledge previous maintenance useful information sources 
abstraction help show impact changes maintenance knowledge frequently derived comments attached program artifacts 
interestingly note partial comprehension due resource constraints despite additional risk mistake carried 
full comprehension frequently expensive task achieve 
research discusses data mining code clustering techniques supporting program comprehension 
data mining code clustering clusters program entities subsystems similarity automated means provide contextual view system 
argue view navigable clusters demonstrate structure interrelationships maintainers 
software testing discusses program comprehension requirements perspective software testers 
argues general questions tester answer 
objects architectural functional tested 

objects tested best 

degree object tested 
answering questions requires program comprehension create relevant test cases 
defines test case having minimum set attributes identification test object function tested set arguments set expected results precondition environment definition 
lists different sources information useful forming necessary comprehension source code design documentation database schemas interface specifications requirement specifications system repository contains relationships test objects test cases 
software visualisation research field visualisation lead improvements large complex data sets users 
visualisations help people understand information means understand information manipulated understand consequences manipulations 
visualisations applied different industries research disciplines researchers explored visualisation techniques best tailored specific industry discipline 
software visualisation study visualisations describe static dynamic characteristics software 
petre discuss cognitive questions arisen field software visualisation 
petre identify aims software visualisation may large data sets demonstrate virtual machine behaviour program change perspective user attempt manage complexity provide new support ill supported methods reasoning software 
argue categorisation software visualisation models traditional split code data algorithm 

program comprehension petre argue researchers need differentiate visualisations external structure visualisations cognitive structure representations structure versus representations purpose expectation petre note fully understood visualisations useful questions visualisations inherently better 
argument visualisations model supported notion bridging user understanding information rich visualisation visualisation initially comfortable 
research software visualisation conducted past years time different audiences investigated specific requirements techniques proposed audience 
visualisations created software designers coders testers maintainers students teachers 
discuss representative asked question software visualisations look 
discuss concept dynamic behaviour 
describe current tool support software visualisation providing overview commonly cited software visualisation taxonomy 
visualisations look wide variety different visualisations created ranging algorithm animations snapshots cumulative performance data uml diagrams 
currently consensus set visualisations adequately provide developers required information wide variety contexts 
lack consensus jones welsh argue users software visualisation systems allow users strong input specifying visualisations look 
jones welsh describe uq software development system includes editor creating new types visualisations 
visualisation capabilities integrated software development environment comprehension authors argue software comprehension disjoint activities creation modification 
users write new visualisation specifications built editor creation modification syntax trees 
uq create visualisations static information software documents created software development lifecycle 
includes limited source code 
uq create visualisations dynamic information generated runtime 
globus evaluate visualisation software 
globus argue quality unknown concept majority visualisation systems conclusive proof visualisation systems actively promote user understanding underlying data 
globus claim visualisation system comparisons ease flexibility speed operations presence absence particular features 
argue irrelevant underlying data visualisation research required constitutes quality visualisation 
lack definitively useful software visualisations suggests visualisation architectures allow flexibility selecting visualisations constrain information shown select pre defined visualisation types 
chapter shall propose visualisation architecture supports high level flexibility underlying information visualised 
chapter 
related dynamic behaviour visualisation tools require underlying information represent 
useful information extracted code executes 
data extracted analysis dynamic run time environment provides behavioural information difficult extract static compile time form 
ball discusses characteristics information captured dynamic analysis executing program 
characteristic information precise information evidence actual execution 
comparison static analysis object oriented languages confused particular language features 
confusion arises polymorphism cause runtime binding difficult interpret prior execution behaviour class defined definition definitions parents 
second characteristic easy relate input output behaviour demonstrated act execution 
problem dynamic analysis typically comprehensive coverage code code coverage determined set executions developer chooses 
thesis utilises dynamic behaviour rosson carroll show interested comprehensive coverage code interested precisely identifying particular uses properties 
dynamic behaviour creates concrete results developer direct evidence component suitable particular context 
tools researchers created wide variety software visualisation tools 
developers professional animators tools create new visualisations exploration 
tools standalone applications built integrated development environments 
alonso frakes developed model architecture visualising reusable components 
model architecture focuses providing visualisations linked repository components stored 
goals alonso frakes architecture model support multiple different representations component comprehension limited weaknesses representation 
approach providing programmers concept content context component matches initial query repository 
programmer attempt understand concept content context component order 
information stored xml file cml format 
visualisations created intermediary xml files resulting visualisations describe static information provided original author available compile time 
cml files include dynamic runtime information extracted executing component 
chapter shall contribute architecture visualising reusable components 
architecture shall capturing documenting component behavioural structural information 
contrast alonso frakes documentation component structural information 
early creating software visualisation environments done late early 
ronald baecker system visualised executing program behaviour 
mackworth created system animating lisp programs 
program comprehension 
years brown sedgewick developed balsa environment animating algorithms 
coincided reiss developing tool allowed multiple views program development 
reiss subsequently developed bloom tool visualisation static dynamic information 
bloom tool supports static dynamic visualisation applications flexible manner 
supports powerful querying language interested users able dictate wish see visualised application 
thesis complements reiss research firstly supporting visualisation components applications secondly providing means developer directly control task visualised 
discuss examples visualisation tools support pedagogical reverse engineering profiling debugging tasks 
tools support understanding aspect software development relevant support thesis proposes 
discuss examples web visualisations tools section 
pedagogical tools stasko developed samba tool students create animations algorithms 
samba requires students instrument algorithm source code specifying events data require visualisation 
stasko argues turns student teacher instrumentation forces student think abstractly algorithm 
stasko argues factors assist student learning algorithm 
comparison approach require developer instruments source code directed assisting developer understand component black box 
reverse engineering tools knight munro provide overview salient program comprehension techniques considered research community 
knight munro discuss project sought xml graph exchange language gxl reverse engineering tools 
reverse engineering tools extracted information static source code converted gxl format 
gxl files interpreted application called resulting visual graphs aimed supporting comprehension source code purposes maintenance 
example jerding create scalable interactive visualisations object class interactions execution 
interaction visualisations may reveal interaction patterns program high level behaviour 
examples tool action demonstrate executions repetitive terms sequence classes methods jerding argue providing scalable overviews entire execution necessary manually detecting repetitions patterns 
visualising interactions help uncover implemented design assist reverse engineering program form developer understand 
thesis xml languages provide visualisation independent storage formats 
document dynamic information static information 
content dynamic information replicate jerding visualisations provide support reverse engineering tools 
reverse engineering extracts design decisions existing code extracting design decisions existing reusable components may support developer identify possible reuse opportunities 
chapter 
related profiling tools define profiling measure entities program exercised executions program walker demonstrates tool support performance tuning software applications 
walker extract performance information executions 
performance information includes number objects execution interactions objects 
developers provided line navigable visualisations 
line visualisation viewed separately execution benefit information pre processed software developer sees software developer ability re wind re play visualisation 
debugging tools visualisation tools developed assist developers find bugs source code 
tools specifically addressed detection bugs source code programs capable executing multiple processors parallel 
stasko kraemer developed methodology visualisations parallel programs 
stasko kraemer note visualisations debugging differ visualisation profiling debugging visualisations typically need specific program debugged 
program specific visualisation demonstrates aspect program semantics resource details generic programs 
developed debugging visualisation concurrent java programs 
create uml diagrams extracted runtime behaviour concurrent applications 
tool main parts part creates trace events occur execution second part creates visualisation trace 
trace part uses java platform debugger architecture jpda specifically java debugger interface jdi 
jdi monitor virtual machine interrogate system interesting events occur 
uses jdi extract information virtual machine method entered exited 
visualisation part capable creating uml interaction diagrams entire trace deadlock 
case objects threads feature deadlock documented interaction diagram 
individual diagrams sequential nature concurrent support lies threading information detected stored execution trace capability create individual interaction diagrams subset threads objects dependent deadlock interest 
introduce discuss prototype tool chapter reuses debugger technology create execution traces 
taxonomies wide variety software visualisation tools techniques 
price developed taxonomy software visualisations help categorise software visualisation systems highlight key differences different systems 
taxonomy split highest level scope content form method interaction effectiveness 
price demonstrate taxonomy applying visualisation systems 

program comprehension taxonomy content category categorised program algorithm visualisation code visualisation data visualisation compile time run time information fidelity completeness 
notion compile time run time information important distinction software visualisation tools support static analysis source code compiled binary 
method extracting information explored 
software visualisation tools require program visualised annotated calls visualisation libraries 
deemed invasive method taxonomy 
taxonomy notes software visualisation systems require user familiar code 
point view reuse costly deterrent significant knowledge component implementation required visualisations support knowledge created 
execution traces software visualisations provide new representations underlying information model 
underlying information extracted original source create required visualisations 
underlying information model initially stored intermediary format immediately extraction 
category intermediary formats execution trace 
execution traces document dynamic behaviour executing code 
de pauw model object oriented program executions intention visualising executions 
identify program dynamic run time aspects equally important program static compile time aspects purposes understanding program development 
de pauw populate event space event types object creation object destruction method calling method exiting 
de pauw highlight problems managing cost handling potentially huge event space determining event modified visualisation timely manner 
flows primary goals research completeness useful information possible captured compactness captured information stored little memory possible efficient retrieval visualisation tools maintain performance responsiveness traversing event space filtering user 
meet goals de pauw matrix storing number times unique call frame occurred execution 
queries matrix create variety different visualisations 
moe carr execution traces assist programmers understanding large distributed systems 
moe carr corba interceptors capture information traces 
benefit capturing information right granularity assist debugging performance behavioural problems 
information captured corba interceptors relates remote procedure calls returns 
tested usefulness traces visualised spotfire net tool trace summary statistics identify performance design problems large application tested deployed customer site 
thesis execution traces support flexible documentation developers experiences developer specified visualisations 
require identifying extracting relevant information storing information format 
consider activities extracting execution traces storing execution traces 
chapter 
related extraction tools run time data linking visualisation system code investigation monitoring runtime environment gathering reports key events occur 
case data needs passed monitoring subsystem subsystem 
visualisation tool flexibility retroactive adaptability influenced choice data format choose pass data 
call data intermediary information intermediary runtime representation executing code visualisation representation viewer ultimately sees 
schmitt jdi capture events execution java applications 
tool targeted sequential java applications 
targetted supporting computer science education supports visualisation resulting execution traces object diagrams sequence diagrams 
object diagrams current frame call stack 
object diagram shows objects currently scope frame 
includes object current method invoked parameter variables local variables 
include support concurrent applications support visualisation call stacks existing thread 
architecture model view controller pattern acts stand application attaches monitors target application executing java virtual machine jvm 
schmitt anecdotal evidence students visualisations useful lectures reinforce happening execution java applications 
extraction useful information time consuming 
reiss developed jive tool visualise executing java applications sufficiently low overhead providing immediate feedback execution attainable 
reiss achieves splitting execution trace intervals visualising summaries interval 
de pauw discuss concept burst execution traces 
burst represents events relevant user identified task 
de pauw argue detailed execution traces entire execution prohibitively large non trivial applications 
due size problem execution traces store events relevant particular task 
user specify initial task interested encode burst request 
burst request includes method trigger event tracing methods objects threads monitored user specified criteria met 
de pauw define term drive analysis iterative cycle specifying burst executing application viewing results specifying new burst explore new task old results shown potentially interesting 
storage developed xml execution trace format document runtime behaviour object oriented applications 
trace format called process abstraction language pal 
developers pal create platform independent independent execution traces adhering publicly available format custom visualisation tools 
pal stores static type information runtime event information general structure pal file shown table 
thesis shall build done pal create new xml formats document 
web tools software engineering component structure behaviour 
approaches reducing requirement developer interaction creating new visualisations execution taken place 
approach store trace test drive relevant information stored information visualisation techniques explore query 
involve processing raw data coming information sources level filtering applied remove useful information put form easier query 
approach reiss moe carr 
second approach capture interactions component including gui network file interfaces associated systems replay interactions component 
approach favoured tool observation testing systems 
web tools software engineering discuss tool support understanding reusable components chapters 
developers access computer aided software engineering case tools decades tools intended improve developers undertake different activities software engineering 
reported developers case tools hoped 
user survey suggests indicator case tool effectiveness perceived complexity 
perceived complexity function variety factors including aspects interface compatibility hardware compatibility 
response concerns researchers proposed variety light weight webbased software engineering tools 
light weight tools may offer range functionality heavy weight tools may offer fulfill needs majority prospective users 
light weight tools available ubiquitous web browsers minimising concerns software hardware compatibility 
section shall review software engineers currently web access case tools 
particularly interested tools publishing documentation especially visualisations community collaborative tools tools allow developer remotely execute code choosing 
shall see themes chapters 
shall explicitly discuss web component marketplaces covered section 
worth noting significant research supports developers engineer web applications 
reusable components web relevant developers 
interested web tools applications components non web tools web applications components 
requirements analysis design tools tools exist create uml models web 
developed seek tool supports creation uml sequence diagrams standard web browser 
similarly mackay developed tool supports creation uml class diagrams standard web browser 
seek variety technologies implement functionality chapter 
related element composition attributes pal type execution context idref name classification type context 

typeid name context typeref superclasses methods variables 
typeref modifier 
superclasses superclass methods method variables variable modifier name superclass typeref access method modifier typeref argument name access variable modifier typeref 
name access argument modifier typeref 
name execution type event event methodcall methodcall 
value value value classification table table shows organisation pal file 
top level element pal file pal element 
elements composed elements may contain attributes 
names italics represent elements solely consist text compositions elements 
pal describes hierarchy structure types execution records collection different events method calls method returns object creation deletion starting processes exiting processes 

web tools software engineering provided 
technologies java server pages jsp mysql database execute entirely web server 
resulting output sent web browser displayed standard html 
developers interact diagrams selecting hyperlinks contained images image maps submitting forms 
tools relevant research demonstrate web browsers create software engineering artifacts need special browser plugins extend available interface capabilities 
html forms image maps hyperlinks combined server side technologies provide sufficiently expressive interactive interface support analysis design activities 
tools useful collaborating team uml models stored central server accessible ubiquitous web browser tool 
demonstrates usefulness web mechanism supporting collaborative analysis design 
demonstrated supporting creation management incremental development essential cases 
tool accessible web browser developers html forms enter case information 
information submitted server side cgi scripts showing useful modelling functionality provided developers need significant computation developer system 
ibm rational rose tool convert uml model created stand application collection html pages 
html pages published standard web server 
approach support subsequent modification pages web browser demonstrate possibilities publishing highly visual information web 
publishing web offers widely supported collection protocols standards 
protocols standards publish variety information manner minimises platform dependence 
example web publishing software engineering wide spread html javadoc format document java libraries 
demonstrates acceptance web technologies support developer understanding libraries components 
significant amount research focused publishing software visualisations web 
research takes advantage multimedia capabilities various web protocols 
thesis propose web publishing software visualisations help developer community understand reusable components 
shall discuss relevant web software visualisation web collaborative documentation 
software visualisation web publishing offers platform independent method creating distributing educational material students classroom home 
enabled teachers provide students experiences interactive documentation key computer science 
experiences documentation chapter 
related shared lab geographically dispersed class help teachers students ubiquitous tools 
brown najork developed cat web algorithm animation tool 
purpose cat combine advantages algorithm animation express information advantages web pervasiveness support publishing multimedia 
interesting aspect cat cat supports algorithm animation shown multiple different sites web browsers 
capability tools preceding cat cat extended state art enabling people different sites customise displays 
brown najork argued especially beneficial teaching environment instructor control algorithm animation viewed students lab students capable modifying see animation 
cat follows brown balsa tool code annotation identify key events executing software worthy visualisation 
domingue demonstrated web algorithm animation tool classroom 
tool internet software visualisation lab supports programs submitted central place program animated fly broadcast web java enabled web browsers 
tool supports annotation storage movies algorithm animations 
extends cat allowing fly animation programs asynchronous communication annotated visualisations 
research extends cat approaches supporting visualisation components applications providing means developer interact component execution control resulting behaviour 
flores provide summary evolution evaluation web program execution visualisation 
focus educational uses approaches claim educational web enabled visualisations program executions reach maturity 
identify evolution visualisation repositories source new research creation dynamic active digital libraries enhance students learning experiences 
libraries initially focus describing algorithms code pedagogical aims teaching programming 
libraries may adapted show component behaviour assist understanding reusability particular component 
research follows providing means create visualisation repositories create visualisations specific tasks developer interested learning 
provide possibilities advantages disadvantages inherent web delivery educational software visualisations 
web software visualisation researchers primarily interesting publishing existing visualisations creation new visualisations 
standard web publishing format html supports inclusion image files animated gif files embedding objects deferred browser plugins 
plugins offer sophisticated interactive animations macromedia flash apple quicktime presentations 
software java applets execute java code client side java window toolkit awt create sophisticated interactive animations 

web tools software engineering collaborative documentation developers web support communication 
especially useful developers team located different geographical locations 
discuss examples web collaboration software engineering lifecycle 
contributions research support creation web developer communities sharing artifacts component evaluations 
build cunningham wiki concept create tool 
asynchronous collaboration tool accessible standard web browsers 
identify categories group different uses tool collaborating artifact creation reviewing activities creating case libraries distributing information 
specifically identify lack need specialised software ease linking documents key facets usefulness tool 
benefits seen part research chapters 
discuss development process weaver tool monitor software process management 
web means distributing information quickly variety different people scattered world 
tool supports creation modification software development processes waterfall model spiral model web browsers connect java extended web servers 
demonstrates ability create wide variety artifacts standard web interfaces 
access non web tools components designed implemented interacted web 
researchers explored techniques providing web access non web enabled applications simulations 
example punch simulation environment developed kapadia punch accessible standard web browsers supports access programming tools need download install configure tools user system 
kapadia sought overcome problem existing web access programming tools web application supported small set programming tools 
meant web applications re engineered new programming tools 
punch demonstrates possible execute applications server side application question intended executed client side 
possible requiring extensive effort part server administrator client side user 
research shall build demonstrate similar concept utilised component understanding 
supporting web access simulation tools researchers explored ways open web accessible greater configuration manipulation 
chatterjee developed cslab web accessible simulation environment supports higher levels interaction configuration existing simulations algorithm animations 
chatterjee identified trend web enabled java language create java applets users download little control configuring modifying 
chatterjee goal create cslab tool open architecture intuitive user interface allow easier configuration modification simulations run viewed chapter 
related web 
cslab interface worksheet users access modify 
maintenance monitoring debugging web tools exist support maintenance monitoring debugging existing software applications 
applications need web accessible tools provide web access applications 
shall look representative tools net dbx 
dreyer developed web tool data collections pertaining program inspections 
tool useful monitoring controlling inspections 
dreyer demonstrated users rate highly respect usefulness ease demonstrate indicators correlated users predictions tool 
indicates possible create satisfactory tools support remote analysis developer supplied software widely available technologies developer existing system 
developed web application reverse engineering applications 
application accessed central site web browser supports analysis querying compile time information extracted java code 
users upload code generate reports provide insight code design 
uses java servlet technologies provide server side generation displays analysis supplied source code 
case source code passed tool mimics compiler parses constructs models source code 
case java uses tool called parse source code compiled java classes 
takes advantage java lack preprocessor directives architectural neutrality allow class files parsed requiring source code 
support feature code 
uses server side coding ensuring output straight html interpreted standards compliant web browser 
example tool provides developers opportunity upload centrally analyse source code applications 
works static compile time information complete programs research focus dynamic run time information individual components 
developed net dbx web enabled tool debugging porting parallel distributed applications 
net dbx uses widely available gdb debugger programs attach local nodes parallel distributed application 
debuggers accessed remotely web browser 
uses combination server side cgi client side java applets provide debugger interface user control execution parallel distributed application 
net dbx supports uploading new source files compilation execution debugging 
net dbx provides user ability specify number processes application run control processes 
net dbx shows debugger technologies web environment extract useful behavioural information 
net dbx demonstrates source code complete program loaded central server remote execution loading execution controlled web interface 
net dbx demonstrates debuggers 
summary controlled remotely web browsers 
research deals remote manipulation executing components chapter deals debugger technology extract useful information 
summary computer scientists researched consequences techniques reusing software components decades 
components existing software artifacts developers build new applications applications suites 
reuse activity involves variety tasks including searching evaluating candidate components 
rise component marketplaces provided new repositories third party components traded component authors software developers 
marketplaces facilitate searching task collections providing querying categorisation capabilities 
marketplaces facilitate evaluation task providing evaluation versions components 
aspect reuse activity requires research evaluations performed 
developers need finish evaluation sufficient understanding component informed decision suitability new context 
cognitive psychologists argue people learn experience 
approach understanding component directly interact observe component 
components behavioural aspect observed component executing 
behavioural information important ultimately adopted component required execute new integrated context 
means refinement concept directly interacting observing component developer gains hand experience invoking observing runtime behaviour 
dominant theme software engineering proliferation tool support underpin various development tasks activities 
researchers created tools help developers understand model collaborate software components applications 
tools accessible world wide web due web usefulness providing architecture independent access ubiquitous communication medium 
subsequent chapters propose model evaluating reusable components developers invoking observing runtime behaviour 
propose web specifically web component marketplaces appropriate location evaluations take place analyse issues arise 
follow proposing architecture tool support assists component evaluations web marketplaces demonstrate prototype tool architecture 
chapter 
related chapter test driving chapter describe model test driving reusable components 
test driving evaluation reusable components invoking observing runtime behaviour 
evaluation takes advantage component executable nature test driving provides experience component achieve task 
model describe tasks developer performs test driving activity 
describing model discuss issues arise performing tasks 
especially focus issues due context exploring peoples code 
contribution chapter model test driving activity 
believe contribution assist supporting developers reuse process 
test driving bears similarities activity software development lifecycle activity software testing 
argue activities fact different 
discuss differences test driving software testing describing model 
test driving learning activity developers need understand component confirm reusable new context 
approach learning product practice experience 
developer variety information sources learn 
component contains static information structural information defines architecture types operations attributes contained 
information available component source code compiled forms derived source code 
developer adopt component purely gain access component structural information 
developer adopt component dynamic runtime behaviour component satisfactory needs 
developer needs experience runtime behaviour judgement component suitability 
developer learns component commit adopting integrating component developer avoid adoption cost integration effort component turns unsuitable 
valuable developer afford license integrate multiple reuse candidates may need discarded 
goal identify component meets necessary requirements decision contrary costly wasted time effort chapter 
test driving money 
section see component marketplaces help developers experience marketplaces components adoption 
currently model describes developer creates experience marketplaces support 
chapter model test driving twelve step activity describes developers currently explore marketplace supplied components systems 
model outlined table 
developer undertakes activity understand component suitability reuse particular context 
side effect activity developer document component suitability 
describe step order identifying task purpose step demonstrating step actual test drives real reusable components 
create model chapters address key issues developers face help create necessary tool support 
industries outside software development tools output behavioural information device typically placing device special environment sending defined input environment 
environment pre configured output relevant information device reacts supported input 
ensures people engineer device understand device behaviour constrained defined environment identify causes particular behaviours 
tool typically measure power torque created transferred running engine 
apply input various loads engine measure output engine reaction loads 
propose implement similar tool support chapters 
basis model descriptive test driving model developers constructivist learning see section understand reusable component behaviour purpose evaluation 
developer constructs new knowledge component actively engaging component 
developer uses knowledge identify act component suitability context developer aware 
model implementation evaluation analysis decision phases component selection models process 
test driving evaluation reusable components invoking observing runtime behaviour 
observed behaviour evaluation data analysis component suitability decision adopt discard 
process requires evaluation results derived component evaluation criteria 
steps eleven twelve model represent analysis evaluation results reuse decision process 
preceding steps model support analysis decision creating necessary information steps form evaluation phase process 
test driving supports evaluations judged component behaviour requirement step component executed 
execution performed step 
perform component execution environment appropriately configured step developer specify input shall provided 
test driving learning activity step purpose analysing component accessing component developer gains access executable version component component documentation 
analysing component developer uses documentation interfaces tool support understand different interfaces component exports 
determining test drive input developer decides input provide component 
determining test drive output developer decides output expect see execution 
preparing test drive encoding test drive input developer writes code input encoded execution 
encoding test drive output developer writes code output state side effects interest component execution 
setting system developer configures system desired execution take place 
cleaning system developer decides encodes steps required clean system component post execution 
execution executing test drive developer executes component supplies additional input previously encoded 
system component cleaned specified step 
viewing results developer views information displayed captured execution result encoding test drive output step 
deciding reuse developer decides know reuse discard component test drive component 
adopting discarding developer acts exploring decision step 
table model test driving reusable components 
model consists twelve steps split groups 
group steps involves developer gaining access component deciding component behaviour want see determining invoke behaviour 
second group steps involves developer describing intended input expected output format computer understand configuring system component executed 
third group steps involves developer executing component witnessing results deciding course action 
chapter 
test driving shows groups steps test driving model 
group contains steps outlined table 
steps take place developer system information may initially come marketplace 
final step model may require developer return marketplace license component 
group steps represents developer analysing component programming interfaces documentation 
second group steps represents developer creating code test drive component preparing system test drive 
third group steps represents developer executing code deciding usefulness component context 

test driving learning activity component application program interface api step 
extract useful information evaluation developer specify output interested output captured step output automatically appear 
component behaviour change environment executes developer plan ensure environment restored usable state post execution step 
steps support execution step creating configuring necessary artifacts environments 
steps turn require additional support 
developer specify input desired output consider valid options input output steps 
developer subsequent choice input output driven evaluation criteria determined earlier phases process 
input output consideration requires developer view descriptions component interfaces step developer discover requests interfaces support 
developer see component interfaces execute component behaviour developer requires access component documentation executable version component implementation step 
test driving model derived considering necessary requirements behaviour evaluation analysis inside component selection process 
example components demonstrate application model discussion individual steps 
demonstration components selected various component repositories 
components cover range object oriented languages range purposes 
components represent graphical user interface library networking library debugging logging library text checking library 
libraries java 
object oriented terminology describing model example components object oriented 
model principles carried components programming paradigm 
due space considerations demonstrate component step 
select components step 
selection components interesting point 
briefly discuss components depth 
graphical user interface component decided test drive jcalendar component 
developer jcalendar component add calendar features graphical user interface gui 
component supports different views months years different styles adjusting views 
different views calendar component seen figures 
jcalendar java component extreme components commercial third party component market 
chose component contained gui 
gui affects test driving process represents new source information affect component behaviour 
chapter 
test driving shows month view supported jcalendar component 
shows year view supported jcalendar component 

test driving learning activity networking component selected component third party component market 
software ip works 
ssl edition linux available supports wide range ssl internet programming 
includes telnet email network management file transfer aspects common network usage commerce 
selected component large scale component offering wide variety functionality 
representative commercial binary reusable component tailored different operating system commercial components 
java expression component selected java component available gnu free software library 
component instantj provides functionality fly execution java code 
users specify java code code executed java virtual machine compilation necessary 
reason selecting instantj representative set components outside commercial third party component market 
instantj represents set components communication predominately code target system networking interface gui filesystem interface 
logging component decided test drive logging component 
component logging software gmbh 
component supports logging events applications written range programming languages 
component written windows nt family platforms works programming language com dynamic linked libraries 
component contains configuration analysis tool ability send log messages central server 
selected component contains filesystem interface written different target platform developer community components 
marketplace support section saw marketplaces support component evaluation 
marketplaces provide documentation evaluation versions components developers 
jcalendar logging ip works 
components section evaluation versions developers prior licensing component 
marketplaces provide support activity reasonable assume assigned positive value ensuring developers experience inform reuse decisions 
development model describes developers experience test drive reusable component help identify issues activity 
issues identified appropriate measures undertaken reduce effect 
chapter 
test driving test driving versus evaluation techniques techniques artifacts evaluate components 
briefly discuss test driving fits existing documentation formal methods 
existing documentation existing forms component documentation provide developers understanding component usage behaviour 
documentation typically written component authors familiar component capabilities 
test driving activity replace need component documentation 
test driving complements existing documentation constructivist approach learning learn experience 
higher levels cognition bloom taxonomy require demonstration cognition actions ability synthesis ability apply information new contexts 
test driving developer component additional artifacts form executable executable appropriately configured environment generate interesting behaviour 
developer applies knowledge component interfaces knowledge provided viewing existing documentation invoke new behaviours previously unseen contexts 
existing documentation helps developer identify behaviours may worth experiencing behaviours invoked 
test driving complements theoretical understanding provided existing documentation practical understanding provided experience 
formal methods formal methods evaluating component correctness respect specification 
formal methods mathematical analysis identify specified input generates right output set theory identify sample input representative possible input 
formal methods involve executing component useful techniques evaluation 
test driving complements replaces methods 
automated formal methods select relevant components 
developer needs understand relevant component selected reused 
test driving means exploring component hand provides capability practise play key component forms learning 
test driving allows developer control border line components considered reuse discarded 
formal methods may difficulty identifying components easily modified fit new contexts developers supply fixed evaluation criteria component executes 
criteria may unable allow acceptable levels variance actual behaviour desired behaviour 
test driving provides developer chance actively evaluate information observed behaviour 
developer flexibility modifying evaluation criteria experiences observations 
example formal methods test driving complement formal methods select set relevant components large repository 
test driving learning activity match broad criteria 
test driving identified components provide developer understanding component modified achieve desired goals 
chapter 
test driving test driving model section shall discuss twelve steps model 
step accessing component description developer gains access important sources information 
source information executable form component 
developer invoke component execution interact runtime interfaces developer considered necessary access 
second source information documentation associated component 
developer view documentation considered necessary access 
purpose task ensure developer sufficient control component execute test drive 
developer immediate access executable version component step provides opportunity consider may create executable available 
issues component exist form 
form source code describes component implementation way developers read write 
second form intermediary format source code converted machine readable 
third form final compiled version understandable execution environment 
forms different versions component may contain different information may different capabilities 
source code form contains variable names comments removed compiled form 
compiled form may contain language version compiler create information added compiler source code form 
algorithm source code form may optimised modified compilation resulting slightly different equivalent algorithm execution 
source code form compiled form different purposes 
compiled form system execute instructions provided developer source code form 
developer directly edit compiled form form typically machine readable binary difficult human parse 
source code may understandable execution environment understandable developer 
developer wishes execute component access component compiled form 
form immediately available developer may able create available forms 
raises problem may cost time effort create compiled form 
compilation phase trivial developers may introduce errors affect accuracy evaluations 
cheaper developer direct access compiled form additional information source code form beneficial 
unusual 
test driving model proprietary components released source code due intellectual property concerns 
examples demonstrate step logging instantj components 
logging provided evaluation version version logging component 
goal evaluate version component 
evaluation version contains functionality full release version addition evaluation messages display provides list key differences versions decided evaluation version 
downloaded evaluation version machine component arrived ms windows os self extracting executable 
ran self extracting executable new setup exe executable extracted 
required add application operating system administrator accessible add remove programs os feature 
repository links product reviews support forums publisher details extra documentation 
unfortunately product reviews forum threads currently available component 
read brief history component publisher details 
downloaded english language white component available german help archive 
help archive consisted text descriptions images videos gui action 
instantj instantj component free download gnu free software website 
component published lesser gnu public license distributed java source code 
allows distribute software conform free software foundation definition free linking software ed component 
allowed distribute software long provide access source code derivative works base component 
link suggested distribution available source code version turns compiled classes included jar file distribution 
instantj website links brief documentation outlines library core purpose documentation included downloaded distribution 
component available entirety provision adhere clauses 
chapter 
test driving step analysing component interfaces description developer analyses component interfaces understand relationship interaction behaviour 
developer considers different sequences instructions result useful behaviour considers possible impact different parameters may instructions 
developer identifies information component may output various interfaces 
purpose step ensure developer basic understanding component interfaces 
basic understanding help developer decide test drive input output help developer decide input output needs encoded 
developer may able determine state component needs system desired execution take place 
issues developer needs understand component vocabulary 
vocabulary described interfaces 
consider different interfaces public api gui filesystem interface network interface non public api available subtypes 
interface list public services exported component 
documented part component api 
second interface gui elements component presents users 
interface set commands component sent sends files filesystem 
interface set commands component sends receives network connections holds 
fifth interface list operations constituent classes overridden extended change component current behaviour 
api interface list types methods fields represent points code link component object creation invocation access modification state 
assume developer need deal interface 
existence interfaces depends component functionality 
useful know public types methods fields know protected private 
approach reuse extend behaviour type subtyping 
knowledge protected types methods fields useful additional services offered component provided simply instantiate instances component 
knowledge private types methods fields open new avenues modifying underlying source code creating new behaviour old behaviour 
developer know interact types interfaces general sense may know interact specifically component 
similar person understand english doesn understand vocabulary players particular sport 
structure english sentences know sporting vocabulary don know questions ask player help learn sport 
may able understand answers answers sentences grammar understand 
vocabulary learnt words sentences ask sensible questions understand answers 

test driving model information regarding component interfaces extracted component intermediary compiled form 
java information typically names methods parameter types return type 
information sparse 
situations debugging information included compilation variable names provide useful context missing 
filesystem networking guis encoded compiled form extraction information difficult due different ways interfaces structured 
developer usually reliant additional documentation available describes interfaces 
component author intended component reused financial incentives act altruism unreasonable expect documentation provided author goal 
examples demonstrate step jcalendar logging components 
jcalendar jcalendar component came javadoc api documentation 
component came example code demonstrating component 
browsed javadoc api documentation began understand component consisted main class called jcalendar 
jcalendar class extended swing class java standard development kit sdk 
api documented parameter constructor accessor getx mutator setx methods operations firing events gui listening new events 
gave understanding operations invoked instances component 
example application component 
executed application component gui displayed screen 
application screens 
screen displayed component gui screen displayed source code example application third screen displayed component javadoc api 
logging logging component interfaces component api filesystem interface gui network interface 
component api documented ms windows help files 
constituent classes contained separate page method outlined purpose parameters expect return value 
component api documented global methods variety macros 
browsed component api documentation began understand global method get access instance class 
instance need initialised initialize method 
initialize method ordinarily requires license key disabled evaluation version 
instance initialised create turn send messages log 
noticed chapter 
test driving enumerated type called provides different message categories info warning error alarm 
additional information described gui log analysis tool included part component 
information included static screenshots tips navigate user controls 
similar information available network filesystem interfaces 
network interface focused describing gui gave developer control log server 
filesystem interface briefly described format files stored 

test driving model step determining test drive input description developer selects particular goal achieve component test drive 
developer identifies sequence instructions request desired behaviour component 
developer identifies specific parameters passed individual instructions 
developer decides initiate requests component developer encode executable form step 
developer chooses goal eventually require component achieve context system development 
developer considers sequence instructions believe necessary component new system 
issues developer set goals want achieve component 
developer may want get component existing implementation behave particular way 
developer may want observe component works see modify extend existing implementation create new behaviour 
developer needs achieve goals 
developer component incomplete understanding interfaces implementation opinion useful input may incorrect 
developer selects input understanding component syntax semantics input intended demonstrate desired behaviour 
developer understanding semantics choose input part demonstrate behaviour 
input sent component interfaces 
input component api operation calls objects values passed parameters 
input component network interface formatted text strings sent tcp ip 
input contain multiple items multiple operation calls time sequenced ordering 
developer decides component services wish invoke need consider needs done 
operation call build state consequences caused previous operation call 
operation call sent object created earlier construction 
may variation planned input conditional prior results 
mapping goals inputs may fail reasons 
firstly component interfaces may list services look perform necessary task 
secondly task sub task needed achieve goals may map services component interfaces developer may able see way request services necessary order 
due sub task seemingly leaving state incompatible preconditions subsequent sub task 
thirdly developer may sufficiently familiar component naming scheme easily understand service offers 
examples demonstrate step jcalendar instantj components 
chapter 
test driving jcalendar having browsed jcalendar javadoc notice methods getting day month year calendar believes current date 
decide piece functionality calendar ability users select dates dates retrieved system scheduling showing events 
methods interested instance methods firstly require jcalendar object 
argument public constructor listed deem acceptable option 
interested retrieving user selected date jcalendar object plan calendar gui displayed 
javadoc api notes main class component extends swing class 
indicates jcalendar object need placed inside java awt frame object window screen calendar packed displayed 
decide test data choose may date shall selected 
input shall provided component clicking appropriate place gui execution 
logging decide provide logging component couple different log messages 
noticed step class contained method assigning different categorisations message 
decide piece functionality able error messages standard information messages log 
create input test drive 
application started 
missing parameter configuration file specified 
default configuration 
network failure connect server mcs ac nz third messages standard information messages second fourth messages error messages 

test driving model step determining test drive output description developer identifies information test drive output test drive considered success 
output include returned values method calls sideeffects state modified executing code information sent filesystem network gui 
output may include information performance measurement security monitoring 
developer identifies expected output means expect output delivered 
expected output corresponds expected behaviour step identify necessary input 
issues developer want output different sources 
source component 
developer may wish see values component returns interfaces 
specifying output source requires understanding component interfaces 
understanding dependent interface descriptions including formats ranges values returned 
second source runtime environment 
developer may wish output performance information environmental information shows component doing normally output normal execution 
example information execution trace 
execution traces require additional setup performed system execution take place developer need consider steps 
explore test drive output section 
developers tool support detecting presenting relevant state changes side effects 
tools junit support assertion facts checked information extracted executing code 
tools output assertion correct incorrect execution 
tools junit support event detection throwing exceptions report events developer 
similarly developers express interest output created debugger tools 
debugger tools profile monitor executing code 
step necessary despite presence tools junit debuggers developers need specify assertions interested checking aspects detecting thrown exceptions may handled automatically 
examples demonstrate step ip works 
jcalendar components 
ip works 
ip works 
component supports wide variety network related functionality 
performed step component decided test drive component telnet functionality 
involved attempting connect telnet server foobar ac nz firewall firewall foobar ac nz sending commands 
methods component class return integer 
method returns method completed successfully error code index table error messages 
chapter 
test driving decide capture returned values send screen view execution 
jcalendar previous step decided retrieve user selected date calendar 
particularly interested methods individually retrieving day month month year 
having decided user enter date may infer output test drive method returns method return method return 
decide calendar gui updated date visible highlighted screen 

test driving model step encoding test drive input description developer translates part sequence instructions created step form computer understand 
developer particularly interested component api interface 
interface requires developer writes additional code invoke methods listed api 
filesystem interface network interface guis handled steps 
instructions destined api interface explicitly written method calls appropriate syntax 
means acquiring parameter information instructions encoded 
developer may decide variables refer information shared multiple method calls case variables declared referenced appropriately code 
issues accessing component api interface may require developer understands language implementation 
support ability write method invocations trigger behaviour component 
may situations developer know need know component language 
object management group corba specification allows developers integrate components target system common programming language 
especially useful component implementation language hard requirement target system 
case technology increases set candidate components removing criteria consideration 
component api rewritten intermediary language corba middleware system supports requests responses sent intermediary language 
test drive input need encoded intermediary language 
examples demonstrate step instantj logging components 
instantj instantj api supports creating expressions evaluated java code 
evaluate method class particularly interested 
wish evaluate expression evaluating days current age ear ear decision test expression 
performing step component identify need create java util hashtable object contains variable types expression object contains expression wish evaluate 
create java util hashtable object contains variables initial values pass chapter 
test driving method 
return object interface evaluate method expressed interest 
encode actual java code demonstrated code snippet hashtable types new hashtable hashtable values new hashtable types put integer type types put integer type types put integer type types put integer type values put new integer values put new integer values put new integer values put new integer string ear ear expression expr new expression types expr values evaluate logging test messages wish send log 
wish alternate standard information messages error messages 
messages written method class 
message categories set typedef parameter method 
encode actual code demonstrated snippet log log initialize application name const char null const char null output log log channel output app load application started level info output app configure missing parameter configuration file specified level error output app configure default configuration level info output app network network failure connect server mcs ac nz level error log 
test driving model step encoding test drive output description developer writes additional code ensure developer access results api interface interesting execution state execution completed 
task involves writing code component executes step print information values returned method calls field values interesting objects values variables method parameters 
developer necessarily need estimate exact values output 
developer identifies information sources interest component told output information information shown 
issues common approach directing output visible location print statements 
approach common software testing reasonable approach solving issue developers shown component state execution 
developer may requested information extracted component interfaces requires extraction runtime environment 
developer explore available tools environmental options may available create things execution traces heap dumps 
tools options require explicitly turned developer need identify achieved encode suitable instructions effect 
tools unit testing environments junit debuggers gdb provide special syntax request interesting output assertions 
tools eclipse debugger automatically output variable values developer steps code execution 
may explicit language support accessing desired output 
aspect oriented programming paradigm provides ability weave modules implement particular concerns existing code 
particular concern need view state side effects execution module implementing concern woven access state existing code executes 
aspect oriented environments assist weaving process remove need developer modify existing code 
encoding output collection step achieved writing new aspects 
examples demonstrate step instantj ip works 
components 
instantj encoded input test drive instantj component step 
statement call evaluate method inspection returns string object 
object represents expression result performing step component decided result 
want ensure verify modify line test drive input print result screen 
chapter 
test driving system println expected system println received evaluate ip works 
step decided capture returned integer method call class send integer screen 
integer represents error message error messages documented component api analysed performing step model component 
step performed model code written encode methods calls instance class 
extend code creating integer variable assigning return value method integer variable 
immediately call test drive input integer variable printed screen 
print name method aid comprehension test drive output 
int firewall foobar ac nz cout stuart cout cout connect foobar ac nz cout connect send set cout send send open home pc cout send disconnect 
test driving model step setting system description developer configures environment test drive performed 
configuring environment involves number subtasks 
subtask write additional code ensure combination test drive input test drive output component form independent executable 
second subtask convert combination independent executable 
third subtask configure network filesystem information expected interfaces readable information sent interfaces writable 
fourth subtask set execution environment executable encode additional information command line parameters environmental variables expected just prior execution 
issues component usually independent executable 
component meant part larger application run 
developer extends component code writing code requests receives responses instances component 
series requests responses complete executable 
extended code base runtime environment need modified test drive code run 
example seen java programming language 
java virtual machine takes class file argument executes class file 
virtual machine assumes class file public static void main string method method represents application starting point 
write valid calls component methods group calls method class successfully compile source code class file format 
treat class file stand application pass virtual machine virtual machine complain know start executing 
runtime environments allow developers pass individual code fragments having specify complete application 
interpreters script languages source code passed directly interpreter explicit compilation phase put interactive mode 
possible developer appropriately configure interpreter prior final submission scripted component test drive 
worth noting developer wants achieve component may directly achievable new component instance empty environment 
developer may need check component perform particular activity particular information set 
information set may ordinarily available point application trigger component 
developer uses test drive simulate application request component behaviour need ensure normally done providing information set simulated 
example component extracts information server network 
sufficient simply describe request behaviour 
developer set network server simulation chapter 
test driving component extract necessary information 
perform task target system network server available 
example developer wants test component ability query stored information 
developer decides query string input identified test input data output query produce input data 
test drive predominately interested invoking query behaviour developer needs set instance component contain stated input data 
initial state created new component instance 
developer may require additional calls component services add information may need directly manipulate component state breaking encapsulation setting data fields 
necessary break encapsulation developer needs check possible runtime environment configure environment allow 
consideration setting test drive may supporting middleware architecture accessing component functionality 
corba example component infrastructure supports standard approach requesting operations components may share language 
infrastructure exists developer needs consider requirements integrating component infrastructure step activity 
examples demonstrate step instantj logging components 
instantj encoded test drive input output instantj java component 
code written currently executable right 
need convert code independent java application passed java virtual machine 
requires steps adding code infrastructure compiling source code configuring virtual machine classpath 
complete code infrastructure need current test drive code public static void main string method 
need ensure code access named classes instantj library 
ensure importing library source file 
infrastructure complete java compiler convert source code java class file 
compiled ready invoke virtual machine 
ensure virtual machine access compiled class file configure classpath environmental variable include location compiled file 
decide step invoke virtual machine shell ensure standard output encoded step sent screen 
support step invoke shell type name virtual machine 
type name java class argument virtual machine 
send command shell execution 
logging created code test drive input test drive output 
need turn code executable application 

test driving model require steps adding code infrastructure compiling source configuring library path executables 
complete code infrastructure need current test drive void main char int method 
need ensure code access logging classes including header file 
infrastructure complete compiler convert source code windows executable 
compiled ready start executable 
ensure executable access compiled form libraries tailor library path include location library files 
chapter 
test driving step cleaning system description developer decides system resources deallocated restored execution completed step model 
cleaning system require tasks calling object destructors resetting environment variables removing unwanted files closing network connections killing child threads processes 
necessary ensure system resources needlessly wasted irreversibly altered test driving test driving negatively affect developer system ability handle activities 
developer writes additional code perform cleanup appended test drive code written steps 
cleanup code may language rest test drive code may require external scripts languages operating system utilities remove restore files reset environmental variables 
developer interested removing effects current test drive execution currently interested removing entire component system 
developer want permanently affect system test drive component may discarded 
want completely remove component directly step may decide adopt undertake exploration 
issues cleaning system may involve restoring information pre test drive states 
requires developer information backed retrieved 
issue developer address planning clean system identify data modified ensure copies safely stored 
test drive may changes data developer position reverse 
example test drive may send network traffic system outside developer administrative control 
test drive may trigger events surrounding systems cascading effects 
test drive cause irreversible events developer needs consider mitigation strategies execution takes place 
mitigation strategy may execute component virtual machine 
virtual machine may responsible management requested system resources may able support subsequent deallocation resources 
virtual machine acts tool support cleanup step especially exiting virtual machine automatically triggers behaviour attempts clean system virtual machine exits 
example java virtual machine runs garbage collector capable releasing memory objects memory deemed longer 
virtual machines virtual environments simulate network servers manage security policies limit component ability manipulate surrounding system 
consideration developer take account mitigation strategy may cause component execution different occur normally may provide misleading picture component behaviour capabilities 

test driving model examples demonstrate step jcalendar logging components 
jcalendar jcalendar component operates event listener model 
user selects date listener contacted react change underlying information 
steps model require developer create listener registered jcalendar object 
listener appropriately invoked query methods specified step output results 
need exit virtual machine clean environment 
achieved simply invoking method system exit 
virtual machine finish operating system deallocate resources provided 
logging small application operate event listener model 
log messages written log channel application automatically exit freeing allocated resources 
test drive result messages written file 
currently sure file file called 
plan check filesystem completion file viewed removed 
chapter 
test driving step executing test drive description developer executes component code written steps 
developer provides component additional input identified step encoded step 
input sent component filesystem network guis 
execution creates information behaviour detected infrastructure created steps step 
issues developer determines want component set appropriate feedback structure comes time component perform desired task 
component placed appropriate environment component interfaces accept input specified earlier sequence interaction phase 
component executes specified sequence interactions require input external actors 
example input component may require human user interact gui 
environments support ability specify gui interactions ahead time send interactions predetermined times trigger events code 
may desirable possible input may dependent output output may difficult accurately predict execution 
depending comprehensive supporting documentation developer may aware guis works step undertaken 
case developer opportunity learn gui experience reach decision appropriate interactions 
learning experience enhanced access information output result step 
help identify effects different actions gui 
points hold true component interfaces may poorly documented non trivial 
developers aware show gui developer screen component api exploration step step 
component gui may require gui framework 
setting framework accomplished step step 
shall discuss issues regarding component interfaces section 
examples demonstrate step jcalendar ip works 
components 
jcalendar execute virtual machine setup step 
virtual machine load relevant classes create gui calendar accordance steps 
calendar accessible displays select date may determined step 
triggers rest test drive code results environment cleaned accordance step 

test driving model ip works 
execute application created performing previous steps ip works 
component 
component attempts connect telnet server foobar ac nz 
challenged firewall firewall foobar ac nz provides user name password encoded test drive 
component turns automatic loading telnet configuration file attempts open connection home pc port 
connection opened component disconnects telnet server finishes execution 
dependent aspects test drive set performing step model component 
aspect component provided relevant security permissions access network 
second aspect ensure valid servers specified urls 
chapter 
test driving step viewing results description developer provided output created step execution developer compares contrasts output step expectations 
differences step expected output step observed output identified 
differences lack thereof inform decision step eleven 
differences expected observed represent deviations developer thought component component 
deviations may reflect component functionality different developer needs developer properly understand component interfaces 
issues developer specified infrastructure expected output steps 
developer combine output information meaningful report 
issue arises executing components create mass information 
developer may requested data extracted component interfaces return values runtime environment execution traces 
data output may useful reuse decision 
developer incomplete understanding component may lead requesting output unnecessary redundant 
combination data lead information overload needs serious consideration report developer 
step claimed common approach outputting data print statements 
printing text relatively easy object oriented languages seen subsection people difficulty extracting important insights resulting mass text 
chapter describe software visualisation research better output created step 
examples demonstrate step logging instantj components 
logging logging test drive perform expected 
performed step component decided output return value method call step non void return type 
encoded part test drive output 
return value initialize method false 
indicates initialisation failed 
subsequent methods silently failed written messages file filesystem 
instantj test drove instantj component evaluate expression ear ear 

test driving model step encoded print statement sent result step evaluate screen 
created shell step contain virtual machine 
shell cleaned step shell active displaying standard output sent executed test drive 
note component evaluated expression value 
expect born may years old december accept component evaluated expression expected successfully handle parentheses ternary operators boolean operators binary operators 
chapter 
test driving step eleven deciding reuse description developer needs reduce set possible components candidate subsequently adopt integrate 
developer decides test drive convinced current component suitability 
test drive may demonstrate component provide necessary functionality may demonstrate component provide necessary functionality expected input 
developer may decide test drive inconclusive 
test drive inconclusive developer may decide test drive component answer questions raised 
alternatively developer may decide possibility finding component suitable sufficient warrant test drives 
developer ultimately decides adopt discard explore component 
issues test drive demonstrated component behaviour set input 
developer needs certain correctly understand observed observed reflects behaviour occurred 
case complicated components capable achieving multiple tasks handling tasks different ways depending input environment single test drive insufficient considered reuse decision 
single iteration test driving model represents performance single task 
developer may iterate model times component 
shown 
single test drive iteration sufficient developer may decide start iteration component may decide discard component worth investigation 
test drive iteration sufficient developer decide discard component consider adoption 
developer initially test drove component answer question 
result test drive may raise new questions 
developer learns component runtime behaviour developer may consider different avenues reuse extension existing behaviour modification existing implementation 
examples step jcalendar logging components 
jcalendar successfully test driven jcalendar component received result hoped expected 
confident jcalendar component serve needs 
particular decide calendar gui style may conflict rest interface 
notice methods listed api change ui style decide reuse component 

test driving model test driving activity iterative 
result decision step eleven may perform new test drive component 
case model returns step developers studies interfaces identify new ways interact component 
logging test drive perform expected 
initialisation failed messages lost 
read notice second argument initialize method configuration file determines logged messages sent 
decide initial mis understanding invalidate component usefulness component advertised functionality attempt second test drive 
chapter 
test driving step twelve adopting discarding exploring description developer enforces decision step eleven 
adopting component may require evaluation version component require procedure licensed user component 
discarding component require evaluation version component removing local copies component documentation 
exploration component requires returning step model prior test drive indicates interfaces poorly understood step model developer confident understanding interfaces wishes try new goal 
issues installed components may come features task easy developers may require straight deletion stored files 
problems arise installed component stores files unexpected locations developer difficulty locating files clean 
developer may aware files stored 
problems arise component accidentally removes shared libraries required software 
similar dynamic linked library problem discuss section 
examples features tools software deleting files tracking libraries software 
installation wizards software microsoft windows environment frequently provide option software operating systems frequently provide ability add remove known software 
similarly unix derivative operating systems distributed tools install rpm deb packages visually list packages known currently installed system 
tools support developer task 
examples demonstrate step jcalendar logging components 
jcalendar decided explore jcalendar component 
component system change library binary requires rolling back 
access component documentation return back step determine methods called change component appearance 
logging decided explore logging component 
component system changes installed binaries 
test drive resulted failure decide return back step read create necessary configuration files 

test driving artifacts test driving artifacts described test driving model order events developer follow 
developer creates uses artifacts events artifacts shown 
tool support test driving activity required support handling creation artifacts 
discuss artifacts depth 
shows artifacts created test driving activity 
component existing artifact retrieved repository 
component placed test harness written developer 
component test harness placed execution environment execute create output stored 
contains step test driving model artifact created 
test harness test drive harness collection code developer writes perform test drive component 
test drive harness represents infrastructure simulates application development 
component test drive harness combined form executable 
developer code broken different pieces different purposes 
different pieces code written test driving model 
pieces encoding test drive input data encoding test drive output data setting environment cleaning environment 
test drive input output works directly component interfaces represents actual task developer wishes observe component 
environment setup cleanup interact component execution environment 
mod chapter 
test driving ify environment component necessary component performs task 
developer variety artifacts create test drive harness 
artifacts explaining environment explaining component developer determine needs done 
represented documentation box component interface box 
test drive harness sent execution environment completed 
test drive harness combine component execute causing behaviour documented test drive report see section 
component component piece code developer interested learning 
component resides execution environment different interfaces 
developer uses interfaces invoke behaviour takes place inside execution environment 
component typically executable right requires developer write test drive harness talks component component published interfaces 
combination component test drive harness results artifact run independently execution environment 
component repository component repository central location store components developers easily find access components 
marketplace discuss chapter component repository repositories need commercial interests 
component interfaces interfaces published component 
interfaces component talks world world talks component 
interfaces cover variety different communication modes 
components api listing public operations code invoke 
component may network interfaces file interfaces guis listener hooks event listener model rmi interfaces remote procedure calls 
interfaces artifacts created component documentation associated component 
artifacts shown developer uses create artifacts form test drive harness 
documentation developers available documentation create test harnesses 
developer potentially modifying component environment just component documentation useful 
documentation setting cleaning environment assist making sure test drives run smoothly unintended costly consequences paid developer 
component documentation may prior examples component tutorials comments extracted source code 

test driving software testing execution environment execution environment represents systems actors component interact execution 
includes software hardware developer current knowledge experience 
state environment developer begins test driving affect component observed behaviour 
reason developers understand environment environment modified 
environment differ component component 
components may computer operating system perform activities 
components may communicate processes computer may network communicate servers peer applications 
distributed components may execute multiple computers 
complex environment harder detect understand component modifies environment 
developer needs understand component modifies environment execution impact component integrated developer target system 
developer task understanding component execution environment complex fact parts environment may solely responding test drive 
computer environment component may hosting developer test drive separate component 
computer may involved test drive responding users non test drive related requests 
test drive report test drive report documents behaviour observed component executed test harness 
test drive report created sources information 
source information output component sends interfaces encoded step test driving model 
second source information state events occur runtime environment 
test drive reports created monitoring sources 
discuss test drive reports detail section 
developer uses test drive reports understand component behaviour potential reusability 
test drive reports provide evidence decision reuse component documentation create new test harness component 
non trivial components generate vast quantity information performing tasks 
test drive reports need managed manner developer usefully extract key ideas observed behaviour 
shall discuss presentation test drive reports section 
test driving software testing chapter define test driving activity experiencing hand component usage behaviour 
term test driving context understanding evaluating reusable components 
test driving activity similar software engineering activity software testing 
briefly discuss definition software testing discuss differences chapter 
test driving test driving testing 
support claim modeling test driving useful contribution 
software testers term test driver refer equivalent test drive harnesses 
purposes section shall term reuser refer test driving part reuse process term tester refer test driver software testing activity 
argue fundamental differences test driving software testing 

reuser trying find appropriate component contribute system developed 
tester trying determine component behaviour agrees component specification 

reuser incomplete knowledge component specification implementation 
tester incomplete knowledge component implementation 
traditional software testing myers defines software testing process executing program intent finding errors similarly define software testing process finding differences expected behaviour specified system models observed behaviour system expected behaviour defined requirements basis system models agreed client individual organisation responsible sponsoring system development 
tester finds errors differences expected observed behaviour people responsible writing code fix 
known differences removed observed behaviour closely match client requirements system considered working 
software testing iterative process result piece software tested multiple times 
beneficial number reasons 
iterative process ensures error masked earlier error identified earlier error fixed 
iterative process ensures error caused fixing earlier error identified initial set known errors resolved 
number different software testing approaches 
approaches differ degree mathematical formalism artifacts type differences attempt uncover 
examples unit testing procedures ensure single component works properly stress testing procedures ensure entire system works adequately extreme loads resource constraints semi formal boundary analysis equivalence ensure set components executed sample input representative larger set possible input 
forms testing unit testing integration testing require additional test code written invoke behaviour monitor system code 
test driving software testing development 
test code test driver causes behaviour observed 
define test driver test driver simulates part system calling component test 
test driver passes test inputs identified test case analysis component displays results software testing activity interleaved activities implementation activity 
agile development methodologies extreme programming require tests written code tested 
test driven methodologies fix component interfaces system interfaces implementation completed 
interfaces accessed test code affect selection input tests 
tests executed potentially automated fashion implementation complete 
contrast software testing test driving 
software testing take different forms different stages software development focus comparison unit testing integration testing custom built components 
ensure comparing activities performed parts larger system utilise creation additional code invoke observe behaviour 
define custom built components software components built development team tester supporting 
appropriateness versus correctness key point reuser trying find useful component tester trying find errors single component 
discuss perspectives reuser tester contrast perspectives 
reuser reuser wants find component meet needs 
reuser desired behaviour wish see desired behaviour matches functionality system developing supposed provide 
reuser motivation find high quality implementation remove need reuser implement functionality 
reuser test drives component find differences desired behaviour observed behaviour 
differences represent barriers need overcome component successfully integrated new context 
difference may cause component discarded unsuitable new context may require reuser development team explores ways extend modify component existing implementation remove difference 
component documentation useful aid reuser 
documentation convey aspects component structure behaviour example uses 
test driving complements existing documentation providing reuser hand experience component experience initiated governed reuser actions 
reuser may consider component inappropriate new context differences detected desired behaviour observed behaviour 
component discarded test drive harness created component largely chapter 
test driving discarded 
test drive harness dependent component interfaces interfaces change component set components domain 
test drive harness discarded time effort spent creation execution test drive harness lost 
reasons reuse components improve productivity development teams waste time effort discourage reuse 
typically option reuse process designing implementing testing maintaining custom built solution 
reuser development team ability modify component source code 
development team may technical tools expertise modify source code may legal right access modify source code may time effort spend understanding modifying testing source code 
reasons reuser considers component appropriate new context differences detected reuser typically want find ways adapting component behaviour modifying source code 
adaptation include inheritance mechanism create subtypes subclasses 
adaptation include subtyping subclassing parameter objects 
result polymorphism causing change behaviour component source code uses new parameter objects 
adaptation achieved means adaptor pattern manipulation information information component 
reuser interested input component result certain output generation output uses certain resources 
reuser interested component uses input 
reuser understands component uses input reuser modify component behaviour modified input 
tester tester wants find differences stopping component observed behaviour matching behaviour specified requirements system models 
tester may create test drivers invoke observe component implemented behaviour test drivers dependent component interfaces 
interfaces typically agreed design phase 
tester checking implementation interface agreed 
tester finds errors component component need tested errors resolved 
subsequent tests reuse test drivers implementation interface fault needed modified 
testing activity vital stage development lifecycle fundamental part developed system quality control 
testing activity optional tester development team reputation clients 
contrasting testers contrast test driving software testing perspectives respect appropriateness correctness 

test driving software testing single versus multiple components reuser checking appropriateness respect context reuser try different components discard differences insurmountable 
tester checking correctness respect specification tester keep testing revised versions component satisfied component working correctly 
effect test driving model decision re test drive component requires reuser return step 
tester need return step 
reuser test driver harnesses reusable different components different interfaces 
modification reuser test driving may explore component modified needing change source code differences resolved 
tester consideration differences detect fixed outside testing activity 
effect test driving model consideration useful output steps 
incomplete knowledge reuser tester test driving incomplete knowledge 
discuss perspectives reuser tester contrast perspectives 
reuser reuser test drives component reuser decision reuse component 
decision reuser sufficient knowledge component judge appropriateness 
reuser test drives component discover knowledge 
reuser lacks knowledge component areas 
firstly reuser know component implementation 
secondly reuser know component specification 
reuser know component specification reuser effectively discovering behaviour possible certain behaviour invoked 
situations component documentation available documentation act aid identify aspects component particularly useful test drive 
hand experiences provided test driving act evidence claims documentation 
test driving complements removing need existing documentation 
tester argues testers trying develop way find don know don know software testing act discovery 
testers discover errors knowledge represented software implementation aware 
tester aware errors errors resolved chapter 
test driving responsible implementation activity 
testers know errors looking errors exist 
tester tests component access knowledge contained component specification 
specification tester judge component observed behaviour 
specifications assumed correct purposes software testing activity modifications performed different activity 
means tester knowledge component interfaces intended sequence interactions result useful output 
argues software testing largely consists heuristic strategies select representative test cases identify high density knowledge centers software mistakes 
contrasting testers contrast test driving software testing perspectives respect incomplete knowledge 
access specifications tester access component specification interface descriptions 
tester testing interfaces choice test cases driven methods 
assist tester know invoke behaviour useful observe 
comparison reuser knows data context application developing may know data invoke behaviour desire 
reuser discovering behaviour possible invoke particular behaviours 
timing test cases tester uses component specification generate test drivers agreed interfaces 
specification interface descriptions may exist component implementation 
reuser generate test drive harnesses access component study interfaces 
third party components typically component implemented available 
summary modelled test driving activity 
test driving means evaluating reusable components experiencing component behaviour hand 
test driving form active learning follows constructivist approaches program comprehension 
described twelve steps model demonstrated model application test driving real third party components 
test driving reusable components different software testing 
reuser hoping find useful component tester hoping discover component implementation differs specification 
reuser may access different component artifacts source code documentation specifications may test driving component different state relative implementation 

summary reasons need separate model test driving components reuse process 
chapter provided model 
chapter 
test driving chapter test driving marketplace number issues arise chapter test driving model 
issues trust cost availability 
issues negatively affect benefits software developers component authors get test driving 
software developer needs able trust component states 
developer needs test drive process cost time effort 
lastly software developer needs documentation available guide select candidate components 
component author needs trust developers respect author intellectual property rights 
authors need developers able quickly easily choose components reinforce consumers interest market 
lastly authors need way advertising components software developers 
need address issues propose solution problems raise 
reason issues problems software developers test drive systems 
chapter propose web solution links research software visualisation 
solution moves developer test drive system marketplace system 
means component code execute confines marketplace transfered interact developer system test drive 
developer web browser configure interact component executes marketplace 
test drives visualised marketplace visualisations shown developer interested parties 
discuss detail problems arise test driving 
identify solution solves problems show solutions meet modify test driving model 
discuss new problems solution raises 
close chapter linking activity test driving field software visualisation 
test driving issues issues involved test driving process need addressed 
identified issues shown 
chapter 
test driving marketplace developer tries download component marketplace face issues 
issue suitable component accompanying documentation available 
second issue developer trust unknown component execute system 
third issue downloading installing testing component costs time effort 
marketplace faces important issue 
marketplace trust developer component intellectual property outside marketplace sphere influence 

test driving issues trust component markets authors want developers reuse components 
reuse requires time effort part developer resources short supply 
reason markets authors frequently provide developers evaluation versions components 
purpose evaluation versions provide developers means satisfying component need 
author author needs trust developer intellectual property ip 
developer committed purchasing component download evaluation version developer explicit obligation author marketplace 
developer lack obligation poses problem security intellectual property 
ip concerns difficult detect ip developer downloaded author component 
electronic format components easy duplicate free distribution fully functional versions evaluation cut sales developers simply adopt evaluation version licensed version 
car dealers may appropriate identification allow potential customers test drive cars outside lot knowing customer doesn return car reasonable chance finding returned car chance customer copy car able functionality 
developer test drive machine author left problem allowing developer test drive purchase component way developer need purchase test drive 
allowing developer test drive component reduces developer ability convince component suitable 
reduces chance developer decide purchase component 
allowing developer test drive component tackled ways 
way evaluation copy component supplied provides functionality 
second way evaluation copy limited lifespan 
evaluation copy respond specific number uses occurred certain time period elapsed installation 
implementations problems 
limited functionality limiting evaluation version range functionality show developer part receive 
developer left informed decision partial information 
developers may form incorrect opinions component behaviour behaviour get paid sale price 
evaluation versions may designed show reuses author anticipated may act reliable gauge component reused way author anticipate 
increases likelihood developer making wrong decision 
case false negatives component suitable developer decides isn author loses 
case false chapter 
test driving marketplace positives component suitable developer decides developer eventually encounter problems component lose faith author market reuse activity 
limited limiting evaluation version number uses assumes safeguards hard break 
demonstrated true 
determined ip able reverse engineer component discover new algorithms contained possibly break safeguards give unlimited 
industry precedents approaches precedents software industry 
computer game companies frequently release versions upcoming games allow players play part game limited introductory levels particular aspect story 
done develop player community hooked game stimulate sales total package 
similarly macromedia release evaluation versions timed uses 
rational rose release evaluation versions rose uml modeling tool timed days installation 
equivalent examples industries 
example evaluations providing small samples songs prospective music consumers 
small sample equivalent entire song gives indication song 
helps consumer determine full version sufficiently justify purchasing 
example time restricted evaluations trying clothes clothes shopping 
clothes evaluated full functionality evaluation limited store 
effectively limits consumer time uses final decision purchase 
ip protection obfuscation software reverse engineered 
determined developer may able extract source code downloaded evaluation binary source code may reveal author intellectual property 
alternative approach protecting ip contained software binaries obfuscate encoded design instructions 
obfuscation involves obscuring meaning variable names control flows structure reverse engineers greater difficulty understanding algorithm data structure works 
researchers currently exploring ways obfuscate code design level instruction level 
design level obfuscation confuse reverse engineering developers remove useful context developers understood software structure 
design level obfuscation research new promising prove scalable large components large applications 
obfuscation help hide component ip absolute guarantee ip retrieved 
scenario developer test driving component evaluation version committing adopting component marketplace test driving holds advantage obfuscation 
advantage marketplace test driving ensures marketplace retains evaluation version times controls developer access 
developer direct access binary run reverse engineering tools binary 

test driving issues developer receives copy component binary decided adopt signed appropriate contracts marketplace author 
developer developer executing poorly understood component system issue component capability damage maliciously accidentally 
risk associated cost cleaning damage discourage extensive exploration reusable components 
may especially true case accidental damage due environmental mismatches market component author reasonably expected foresee 
differs example test driving car physical world 
prospective buyer knows car test driven certified road safe 
car operating general environment cars safely travel roads 
applies components authors legally exempt liability damages software environment component execute radically differ evaluation 
security concerns may alleviated couple mechanisms 
developer may access component source code 
assuming developer satisfy source code represents compiled component assuming compiled version developer inspect source code ensure problems 
developer may gain confidence component reading peer reviews developers experiences working component 
peer reviewer component similar setting may help developer fears 
mechanism reading source code time intensive requires component evaluation version deployed source code 
open source project developer may having eyes viewing freely distributable source code assumption community identify malicious code existed raise alarm 
source code contains author intellectual property easily extractable form remains significant quantities proprietary component evaluation versions come source code 
second mechanism peer reviews suffers need wide selection peer reviews choose 
relevant peer reviews refer evaluations component similar environments similar goals 
suitable pool reviews take time build component wide variety potential goals wide variety potential environments 
reviewers easy access source code reviews may cover surface impressions component may cover behaviour developer unexpectedly trigger 
developer trigger behaviour providing environment providing information manner author intended 
similar way black box testing components typically cover component uses derived analyse interface requirements actual implementation hood 
black box testing usually complemented chapter 
test driving marketplace white box testing ensure software bugs possible 
clear equivalent white box testing evaluation methods available date 
cost developers wish reuse components benefit tried tested components successfully avoid having design implement maintain version solved functionality 
developer save time effort money re inventing solution solved problem case cost finding old solution cost creating new solution 
proposed model describing developers test drive reusable components 
model consists twelve steps step requires developer spend time effort 
cost compounded fact developer test drive multiple components finding suitable 
time effort spent test driving component recovered test drives components test drive artifacts heavily dependent component interfaces 
component interfaces differ widely components functional group artifacts need heavily modified reusable 
steps test driving model require developer basic assumptions component 
developer test driving component get better understanding basic assumptions run risk wrong 
turn cause false negatives decisions component unsuitable fact successfully integrated require test drives completed developer successfully triggers behaviour happy 
developer may need pay component 
markets extreme components companies components authors may companies require license fee developer legally adopt component 
additional cost may annually re occuring licensing cost factored cost benefit analysis reusing existing components 
developer knows need pay price adopt chosen component especially keen ensure chosen wisely efficiently 
affects test driving process reasons 
firstly developer needs test driving give comprehensive picture component behaviour 
secondly developer needs test driving relatively cheap perform paying areas reuse activity 
test driving expensive inconclusive developers may purchase components turn suitable damages faith reuse activity 
model assumes component test driven developer environment 
cost resources cpu cycles disk space network bandwidth needs considered 
test driving component may require interacting systems people 
cost test driving needs include affects component actors 
test driving cost factors associated 
important consideration reducing costs possible 

test driving marketplace availability developers test drive components find solution problem part system implemented 
solving problem aided having set candidate components available supporting documentation components 
component markets entered mainstream 
companies maintained inhouse repositories repositories limited size 
component markets offer possibility large collections components available test driving 
negative 
increasing number available components increases chance component developer needs 
search space complicated cluttered 
filtering test drive phase developers left test driving unsuitable components 
turn costs time effort wasted final product 
components easily available format quickly cheaply test driven 
components require compilation executed components come evaluation versions hard access 
availability supporting documentation helps developers identify tasks done component tasks performed 
easier specify test drive results behaviour developer wants see ease lower cost test driving 
reading documentation costs time effort documentation may explicitly address issues relevant developer current context 
test driving marketplace software developer gains access candidate component step test driving model 
chapter assume developer downloads component marketplace machine 
component marketplaces typically supply evaluation versions components assumption observation current state practice 
propose component leave marketplace software developer decided adopt system 
requires test driving takes place marketplaces systems 
turn requires developer access marketplaces test driving systems systems 
proposal comes part usability analysis performed prototype java test driving tool called dyno 
dyno allows developers test drive java classes systems created proof concept msc thesis 
discuss dyno functionality design section 
usability analysis showed common observation participants test driving support needed better integrated documentation reuse tools available 
marketplaces contain online documentation components marketplaces tools provide search capabilities transaction capabilities component industry 
indicates support test driving components needs tightly integrated component marketplaces 
chapter 
test driving marketplace web enabled test driving obvious means providing developers access marketplace systems support developers test driving components web 
web main benefits 
firstly component markets web 
tying extra functionality supplied market creates integrated reuse environment software developers 
secondly web browsers pervasive software developers machines access web largely platform independent 
web browsers software engineering activities accessing online documentation developer forums network access corporate firewalls may easier set 
software developers need download special client side software access functionality removes potential cost potential accessibility issue compatible client developer environment 
thirdly web browsers offer understood user interface 
different web sites different look feels common features enforced implementing technology 
web browsers commonly tool facets life provides head start creating usable user interface accessing test driving visualisation functionality 
analogies web enabled marketplace test driving producers encourage consumers buy marketplaces directly producer 
producers web promote products actual product requires consumer purchase intermediary marketplace 
trying goods marketplace main analogies chapter test driving cars trying clothes 
instances prospective buyer went car yard clothes shop try goods 
clothes ordered mail returned necessary majority cars clothes bought going intermediary physical store 
producer consumer may see intermediary marketplace heavily biased side trustworthy terms support security 
trust highly important commerce 
products evaluated purchased intermediary marketplace producer trust consumer easily steal product 
consumer easily steal product marketplace suffers financial lose producer 
similarly products evaluated purchased intermediary marketplace consumer trust third party satisfied product quality 
producer creating poor quality products marketplace sells products receive poor reputation consumers suffer poor repeat business 
consumer reason trust marketplace quality control producer quality control marketplace theory switch suppliers harder producer switch product lines employees 
marketplaces frequently offer products competing producers may focus solely selling product line cost consumer product faults 

test driving marketplace marketplace testing equipment consumers may gain testing product marketplace especially producer marketplace access testing equipment cost effective individual consumers 
example running shoes 
sports stores equipment measure runner gait pressure points running 
consumer try shoes run machines get feedback shoe supporting particular running style 
helps consumer informed decision shoe buy extreme situations assist consumer making changes way shoe change walk run 
consumer access machines homes local equivalent test driving components client computer 
consumer need rely senses instincts may finely tuned detect subtle problems 
movie web sites film industry example consumers web affect purchasing decisions 
studios frequently post movie trailers websites cinema view 
companies want control view trailers purposes linking services advertisements viewing offered streaming video 
computer uses viewer application apple quicktime viewer display video sent central server 
film companies allow movie reviewers see movies general public allow reviewers post reviews web newsgroups newspapers 
trailers reviews artifacts created movie substitutes watching movie 
documenting components marketplace consequence developers accessing components marketplace marketplace analyse developers test drives useful information 
marketplace link useful information back component see 
developers documenting component web examples execution 
examples annotating documentation web example executables 
example sun microsystem java tutorials 
tutorials include java applets demonstrate particular feature standard development kit user interface widgets 
developer download applets system technologies java see tutorial code action 
applets suffer security problems affect developer trust execution 
applets typically created developer 
approach allows software visualisation techniques test drive output developer requiring test drive executes developer system 
visualised test drive output represents new form component documentation developer create market solely marketplace systems 
marketplace test drive visualisation removes burden execution developer currently applet tutorials 
marketplace test drive visualisations chapter 
test driving marketplace provide developer far control see applet tutorials written 
developer test drive visualisation new form documentation marketplace opt documentation promote components 
discuss issue marketplace documentation section 
discuss issue test drive visualisation section 
adhering test drive model discuss web marketplace test driving fits test driving model 
modifies shown reflect move marketplace 
shows groups steps marketplace test driving model 
comparison 
developer sending instructions marketplace instructions invoke behaviour results side effects output 
marketplace may send component documentation developer system viewing 
component leave marketplace developer decides adopt developer system safe component execution evaluation 
analysing component accessing component model requires developer gain access component 
implicit assumption chapter developer download component marketplace machine 
developer 
adhering test drive model test driving component web developer needs gain access component webpage 
component remains marketplace market links component executable version component imported marketplace 
analysing component interfaces developer view component interfaces 
web publishing medium component interfaces viewed needed 
component documentation downloaded web respect web test driving ably supported part model 
web navigational aids exploring interfaces assist developer 
example java javadoc format substantially uses hyperlinks link interface declarations indepth documentation link classes sub super classes packages constituent types 
determining test drive input developer determine test drive input required manner access component web machine 
step played developer mind comes interpret component interfaces seen step model 
determining test drive output prior step determining test drive output primarily achieved developer mind independent component accessed 
preparing test drive encoding test drive input test drive input needs encoded form runtime environment understand 
fact runtime environment moved developer marketplace affect runtime environment understands instructions 
step significantly affected marketplace test driving efficiencies marketplace due volume test driving experience 
aspect need addressing developer communicates interfaces filesystem network 
interfaces marketplace developer machine developer control marketplace machine 
issue addressed detail section 
encoding test drive output encoding test drive input encoding test drive output significantly affected developer point view 
developer need state interested seeing marketplace need capture information output runtime 
information published web just static views component interfaces step 
marketplace control components streams control component runtime environment 
marketplace able redirect streams documents accessible web 
chapter 
test driving marketplace setting system test drive code execute marketplace 
means marketplace developer system needs setup 
developer may control manipulating marketplace systems manipulating system knowledge marketplace environment configured 
marketplace system may differ developer system disadvantage marketplace test driving 
discuss possible solutions sections 
developer reliant proactive author marketplace provide necessary access 
author marketplace know component best position know adequately component environment 
developer may need set instances component sufficient state start intended test drive 
achieved invoking operations manipulating component state regardless test drive done developer machine marketplace 
cleaning system step affected web marketplace test driving way previous step 
developer needs clean environment marketplace assist 
marketplace site regular frequent test drives range components 
means marketplace specialise setting cleaning environments frequent cost effective 
execution test driving marketplace affect test drive performed observed 
executing test drive developer specified test drive code code sent server execution 
server may receive concurrent requests multiple developers test drive components 
server need execute partially closed environments limit contamination 
point view model test drive executed appropriate runtime environment runtime environment marketplace developer place 
viewing results need send developer results test drive executed marketplace 
require transmitting information network developer web browser 
web publishing medium discussed section difficulties 
worth noting marketplace keep local copy results dissemination interested individuals information originates marketplace 
deciding reuse developer need determine happy component behaviour test drive results 
irrespective test drive performed results published step unaffected delivering test drive functionality marketplace web 

solving problems test drive model adopting discarding exploring component leaves marketplace test drive activity 
affects discarding adoption components results decision step eleven 
developer decides discard component need clean developer local environment 
component migrated developer machine developer need hunt installed files discarding component simple act forgetting link component web location 
developer decides adopt component marketplace presumably full version component licensed 
test driving performed developer system evaluation version may need removed replaced fully licensed version 
discarding components longer consideration cost test driving occurs marketplace 
solving problems test drive model discuss delivering test driving functionality web solves problems raised chapter 
trust noted issue trust important developers authors 
developer required execute unknown component system open malicious accidental damage 
test driving component marketplace developer confident compromised security 
test drive shows component developer test drive determine component safe execute system 
lowers developer initial risk reduces level trust developer respect component author component market intermediary 
useful reasons 
developer undertaken little reuse past prior relationship marketplace 
marketplace may claim verify components correctness developer prior experience measure accuracy claim 
test driving components marketplace protect malicious marketplaces protect marketplaces poor quality control 
developer undertaken reuse past may strong relationship particular component author 
authors marketplaces 
developer may informed opinion quality business history component authors may opinion quality previously purchased particular marketplace 
marketplaces significant share particular market long time success reflects component selection customer service 
authors may specialised niche component industry developers may operate niche sufficiently build necessary relationship directly 
chapter 
test driving marketplace seen book industry 
multitude writers creating fiction non fiction sizable number publishers large small distribute 
relatively online 
amazon barnes noble borders large commerce operations selling books web typical consumer looking book website may care author care publisher developer test drive respected marketplaces need trust marketplaces test drive functionality correct 
developer need immediately trust unknown authors undocumented track record 
component authors benefit developers test driving components markets machines 
author intellectual property licensed developer developer decides adopt component appropriate payments 
authors benefit developers willing test drive developers may thoroughly investigate component convince suitable 
raise adoption rates 
component author need manage evaluation versions components provide developer full access entire component concerned 
simplifies things author means developer full access entire range functionality increasing likelihood developer informed decision 
developers feel confident reuse decisions improve consideration reuse situations 
result repeat business author larger market component 
cost time effort cost associated steps test driving model 
reasons reusing reduce development cost means reducing cost reuse improve usefulness reuse 
supplying test driving visualisation functionality web reduce cost 
costs associated test driving model step developer gains access component 
developer test driving client side download component install system component model 
activities costs time effort 
developer avoids needing perform activities pay costs test drive component currently kept 
assume cost specifying test drive code regardless web accessibility see section validity assumption developers net saving time effort reduces cost activity 
availability test driving components web increases amount information stored repository 
repository accessible developers information created developer available developers 
helps developers authors 

solving problems test drive model test driving form active learning far primary purpose test driving help developer better understand component usage behaviour active learning 
developer performs test driving activity system developer benefits 
developer experiences additional purposes 
firstly documented experiences act form peer review 
peer reviews inform developer strengths weaknesses particular component assist developer informed reuse decision 
secondly documented experiences show reuse possibilities 
component author may think ways component developer may find valuable test driving 
developers learn new techniques allowed access peers test drives 
similarities patterns software engineering 
pattern name problem proposed solution consequences solution 
similarly developer may frequently name test drive differentiate test drives review 
developer problem target system missing functionality need component provide missing functionality 
developer describes problem input sent output expected component 
developer encodes proposed solution sequence interactions component 
consequences proposed solution seen resulting test drive 
patterns useful published large audience people learn 
similarly argue test drives useful published large audience 
second hand exposure test drives provide hand experience aspect previously argued exposure cheap collect second best thing 
developers experiences developers guide components choose test drive choose test drive 
developers test drive visualise state ignorance visualised test drives incredibly successful meeting objective showing component reused 
patterns useful just writes useful patterns called anti patterns don attempt show successfully solve show bad proposed solution results failure 
failed test drives may useful manner anti patterns 
industries peer reviews 
amazon allows consumers post reviews books videos dvds product buy website 
reviews complementary product question reinforces consumers confidence integrity market review process 
newspapers publish reviews books art music movies effectively person opinion having read seen heard watched object question 
peer reviews take time create people bother 
benefit performing test driving marketplace information developer need say information publicly linked component 
authors benefit having test drives performed stored repository 
presence additional information provides comfort prospective chapter 
test driving marketplace adopters sufficient data informed decision 
turn may encourage initial consideration component people initially consider component people may adopting 
test drives failed original developer may useful developers 
test drive may shown original developer component reused manner hoped developer may want reuse component completely different way failed test drive may fact indicate means successfully test driving component meet new needs 
different views component may appeal different audiences 
publishing centrally increases chance component appeal 
uncommon industries publish view report service 
movies frequently trailer movies create different trailers different audiences 
trailer may appeal audience prefers romance trailer movie may appeal audience prefers action 
example star wars attack clones 
common companies create series advertisements product banks retailers 
web issues providing test driving functionality marketplace partially solves problems identified chapter 
new problems arise identify new problems section 
problems accessibility component interfaces environmental differences client server different take issue trust 
accessibility standard web browser test drive components reduces need developers download install special software 
succeed developer able interact component types interfaces web browser supports 
step test driving model requires developer access component interfaces 
steps model require developer able specify input expected output 
understanding test drive require access ideally control graphics animations 
basic web interfaces coded html 
html support text hyperlinks images frames embedding objects client side viewers limited client side scripting entry forms text fields menus buttons 
html sent network protocol 
need consider web interface elements sufficient supporting test driving possible solutions 
component api component api collection text representing type names information operation field signatures extra meta information 
html supports displaying text 
relatively trivial encode component api html 
web issues best illustrated widespread acceptance javadoc html documentation 
satisfies step test driving model 
mentioned earlier steps test driving model require developer specify input expected output proposed component usage 
model explicitly states written code 
html forms support writing code web browser 
individual operations fields hyperlinked 
combine hyperlinks client side scripting supported majority standard browsers 
allow developers click want component added directly 
javadoc hyperlinks helps developer quickly navigate different types comprise component 
frames assists developer maintain code writing screen time allowing part screen change show different types may interest 
step test driving model requires developer execute code 
proposing developer execute code server specifying client 
html forms support submission data browser server sufficient pass necessary code server execution 
user interface component may user interface appears execution 
handling user interface problematic handling component api interface 
programming languages offer complex user interface libraries 
developers libraries create complex user interfaces variety interaction techniques 
user interfaces built widgets ranging buttons text fields tables tree browsers drag drop functionality animation 
html support interaction techniques complexity translating html supported techniques user interface libraries actual html prohibitive especially allow multiple libraries multiple programming languages 
run issue show non html supported techniques drag drop html 
problem merely overcoming complexity second problem appears case achieving supported web browsers 
developer initiated interaction sufficient simply show basic image user interface developer able interact image 
approach follows consideration images html image maps 
image maps support mapping user clicks parts image scripts hyperlinks 
possible map part image link triggers server slightly different way 
server receives trigger determines image developer clicked happened developer clicked spot component actual user interface sends updated image showing result 
approach technically feasible prohibitively expensive perform 
interaction techniques drag drop need updates developer moved object part screen pixel movement potentially triggering update 
network resources consumed client server communication expensive especially modified images chapter 
test driving marketplace frequently sent 
timing lag client server high reducing speed developer interact component 
lag result error frustration negatively affect developer decision directly fault component 
component initiated interaction overcome problem developer interacts component run problem component interacts developer 
user interface may solely reacting developer may want show information developer triggered event environment 
information may explicitly requested developer byproduct execution 
standard web browsing experience revolves client sending requests server server reacting requests sending information 
server send information client prompted 
server store significant information current clients relying client cookies url encoding recognise clients session 
server contact client server side component user interface needs alert developer 
websites store time specific context specific information needs regularly updating 
websites encode html sent client time immediately receipt 
time causes web browsers immediately go back server request new copy information 
constant updating allow server maintain illusion updating client costly network traffic 
reduce network traffic reducing update frequency turn creates time lag component reacting developer seeing change 
turn lead wrong interaction component false impression component abilities 
example consider case component pops confirmation box obscures part interface 
developer see confirmation box client side accidentally triggers confirmation box meant interact obscured part interface 
vnc standard web browsers may able easily handle full range component user interfaces web browser plug ins offer arounds 
plugin vnc viewer utilise chapter 
vnc virtual network computing system supports remote access computer computer 
remote access includes ability view manipulate computer graphical user interface computer 
vnc works client server model seen 
computer accessed remotely executes vnc server 
vnc server creates windowing environment computer 
computer windowing environment shall accessed executes vnc client 
vnc client connects vnc server port machine account password information supplied user 
vnc client displays remote computer windowing environment 
user interaction vnc client keyboard mouse redirected vnc server interpreted context graphical user interface currently displayed windowing environment 
updates interface 
web issues sent back vnc client re display 
vnc supports remote access computer computer 
vnc client server architecture vnc server executes windowing environment connected network 
vnc client connects vnc server interaction mouse keyboard vnc client sent directly vnc server 
server sends interaction windowing environment sends subsequent updates back vnc client 
obtained website 
event listeners components may utilise event listeners behaviour triggered event occurs 
developers typically invoke component event notification system register listener component call 
test driving interface means notifying developer component called registered event listener 
problem arises web interface server need contact client inform update necessary 
similar problem previous discussion regarding component user interface 
secondary problem registering event listeners may require creation new types implement certain interface 
considered complicated invoking methods setting fields specification new type described text 
html provides support submitting text web server 
chapter 
test driving marketplace network components may network execution connecting server acting server 
developer direct control marketplace network developer reliant marketplace security policy allowing component necessary permissions 
necessary permissions granted developer network interface 
component acting server long ip address port number published developer connect writing test drive code 
test drive code standard html forms 
component connecting server developer need ensure server available means 
component api supports passing ip address port number server achieved standard html forms 
file system components may file system 
range reading configuration files startup writing logs performing tasks 
communicate component filesystem developer needs ability add files filesystem component read retrieve files component written 
developer may need simulate particular filesystem characteristics component happens expecting directory structure 
protocol includes put operation allowing information posted web server 
files uploaded approach web email clients add attachments emails 
files retrieved navigating filesystem hyperlinks manner web browsers navigate local filesystems 
server need permit developer navigate filesystem achieved setting appropriate security policy 
simulating directory structure achieved creating new directories 
necessary information creating directory directory name directory parent 
specified text entered html forms 
multiple developers test driving components need means sandboxing developer filesystem 
avoid developer polluting developer environment 
sandboxing achieved marketplace mapping file requests component particular part real filesystem allocated particular user 
remote procedure calls components may remote procedure calls rpc act target remote procedure calls 
problems solutions issue similar network interface 
invoking methods rpc requires developer interact proxy actual component 
languages support rpc provide tools creating proxies marketplace utilise tools 
proxy interface similar api published accordingly 

web issues marketplace need provide means registering component instances rpc need done web browser interface 
developer need write code achieve code basically text achieved html forms 
environmental differences moving test drive execution developer system marketplace system introduces problem environmental differences 
component behaviour affected environment developer ultimately interested component behave systems 
environmental differences lead component turn lead wrong reuse decision 
steps test driving model deal setting cleaning test driving environment 
situations server architecture environment significantly different target system architecture environment may difficult achieve 
example marketplace microsoft windows operating system developer mandrake linux operating system 
components run different operating systems developer able test drive component developed mandrake marketplace 
component implemented language designed portability java component may behave change environment 
example different java virtual machine implementations may differ implement threading garbage collection 
virtual machine may depend threading support underlying operating system turn differ operating system 
differences result java applications especially concurrent applications performing differently bytecode executed 
busy marketplace processes requesting resources system developer side testing environment dedicated testing process 
presence additional processes additional impact component behaviour seen developer side testing 
best case scenario developer test drive component 
worst case scenario developer test drive component aware differences seeing see executing system 
case developer useful information right reuse decision 
approaches combat problem 
approach ensure developer aware marketplace architecture environment 
partially achieved simple act displaying name operating system hardware brief information load server 
useful list major libraries currently server versions libraries 
developer may decide reliably test drive component server know accidentally trust faulty information 
second approach relies fact marketplaces tend specialise key platforms 
leading marketplaces support just operating systems ranging windows unix linux 
funded chapter 
test driving marketplace component repository afford maintain different testing environments developer directed appropriate environment 
component may depend libraries part standard operating system environment distributions 
case component authors markets encouraged explicitly list dependencies developer run difficulties test driving developer system libraries 
reducing difference marketplace system developer system increase accuracy information portrayed improve chance developer correct reuse decision 
trust developers need trust seeing test drive components 
test driving occurs marketplace marketplace control environment activities take place 
developer trust marketplace developer trust information information help correct reuse decision 
alleviated fact marketplaces long term interest ensuring developers confident reusing components 
developers test drives inform reuse decision want components decide adopt prove comes integration deployment 
developers frequently adopting components false positives lose faith process lose faith reuse 
turn diminishes marketplaces long term audience business 
faulty test driving information leading false positives marketplace incentive ensure test driving information accurate possible 
may lead decisions adopt developer may adopt component marketplace benefits 
motivation help developers fears trust marketplace test driving tools accurate 
worth comparing marketplace providing tools author providing accompanying documentation 
easy way developer guarantee documentation truthful reflection component binary code developers willing accept documentation authors authors wish repeat business 
repeat business negatively affected poor developer experiences evaluation process 
just developer happy partially trust author happy partially trust marketplace 
marketplaces opening systems developers pose security risk 
marketplace need implement appropriate security policies systems advantage control code executed filtering components offered developers 
marketplace may decide offer component marketplace test driving component execution marketplace system presents high risk system integrity 

software visualisation software visualisation finish chapter addressing possibilities software visualisation illustrate results test driving 
motivate inclusion visualisation aspects architecture proposed chapter 
discussion motivate decision explore intermediary visualisation independent languages components test drives 
software visualisations may created component author developers wish reuse component 
benefit author creating software visualisations author knows component 
author visualisations assist developer identify reuse possibilities act interactive documentation component behaviour 
benefit developer creating software visualisations developer knows immediate interest 
developer visualisations act interactive documentation explorations form part community peer created reviews documentation components 
visualising test drives field scientific visualisation explores techniques help people form coherent understanding large data sets 
software visualisation subfield explores presentation data sets describe structure behaviour computer programs 
seen chapter typically involves strictly limited formatting diagrams animation 
step test driving model developer information extracted test drive 
minimum set information received requested step model 
information may complemented additional information extracted runtime environment execution traces mentioned chapter 
additional information provides insight component usage behaviour result developer huge quantity data 
poses problem terms comprehension 
need large data set software visualisation active research area aspects software engineering years believe worthwhile software visualisation illustrate results test driving 
easier developers understand results test drives confidence developers test drives inform reuse decisions 
developers confident making informed decisions may liable continue reusing providing audience component marketplaces 
chapter briefly discuss output developer request 
includes return values method calls component state happens cross component interfaces 
usually encoded text strings typical technique state print statements java println string method 
software visualisation intends better human ability comprehend complex visual stimuli 
software visualisation worth exploring help understand test drives trying tell need consider visualisations may look 
chapter 
test driving marketplace deciding particular visualisations consider particular visualisation set visualisations wish test drive results 
need consider developer objectives 
need consider current visualisation styles provide 
developer objectives developer objectives show similarities differences software visualisations test driving areas software engineering 
developer objective understand component achieve need 
comparison student visualisations pedagogical purposes interested component works internally 
shall consider example quicksort algorithm component 
developer interested input unordered set output ordered set complexity algorithm log respect input size average case 
developer may interested specifics achieved 
student needs understand quicksort moves input output implement 
developer interested reusing existing implementation 
comparison software maintainer needs know intricacies system implemented modified updated 
ideally developer reuse component modifications updates cost time effort developer primarily interested determining component needed 
software maintainer interested white box view system developer interested black box view component 
similarities 
developers may just interested performance characteristics component software tester 
developer performance characteristics ensure component break non functional requirements system successful component integrated 
range software visualisation see chapter significant range different software visualisations available 
visualisations uml notation describe interaction structural views software 
software visualisations graph notation describe tree data structures network topologies 
software visualisations offer dimensional city scape views filesystem inheritance hierarchy 
visualisations range accepted widely implemented standard notation highly customisable unique 
software visualisations differ underlying information model respect time dimension 
model may contain events sequence visualisation model may static vary time viewed 
alternatively model may contain state changes time visualisation model may contain animations show different parts time viewed 

software visualisation represents initial web user interface selecting particular type uml diagram 
underlines principle ability show different visualisations useful appealing broad audience broad range scenarios possible 
example static view uml sequence diagram 
sequence diagram shows series calls objects system ordered vertically time 
sequence diagram picture viewer sees entirety 
example animated view animation shows shortest path network nodes 
animation may individual frames show step traversing graph reach destination actual shortest path existed single frame 
real consensus community visualisation particular problem 
research currently undertaken group apply architecture data formats chapter range different visualisations unified modeling language uml diagrams 
example research scalable vector graphics svg xml schema graphics animations document execution traces 
figures demonstrate svg representations uml interaction diagrams 
diagrams visualised output visualisation architecture reuse vare shall form main contribution chapter 
svg representations built xml process abstraction language 
pal predecessor xml schemas discussed chapter 
example research dyno earlier prototype test driving visualisation tool 
dyno create range different visualisations see figures created directly developer test drive 
shall discuss dyno depth section 
dyno pal execution traces vare architecture 
chapter demonstrate evolved dyno prototype utilise xml encode test drive output architecture general test drive visualisation 
chapter 
test driving marketplace demonstrates uml sequence diagram extracted pal execution trace 
uml sequence diagram represented svg visualisation viewable web browser 
demonstrates uml collaboration diagram extracted pal execution trace 
uml collaboration diagram represented svg visualisation viewable web browser 

software visualisation demonstrates dyno visualising data structure 
case data structure stack developer see data stack pushed popped execution 
visualisation animation changes stack underlying information changed 
demonstrates dyno visualising data structure 
data structure tree developer see items added removed tree data structure test drive execution 
chapter 
test driving marketplace dyno capable creating uml sequence diagrams 
previous dyno diagrams animations changed test drive execution 
sequence diagram static image shows entire interaction test drive snapshot 
dyno capable presenting time animations static snapshots entire execution 
visualisation flexibility brings back question test drive visualisation look 
thesis directly address question 
arguably need support wide range visualisations possible increase likelihood developer finds representation helps reinforce knowledge learnt 
conversely important aware effect multiple visualisation representations may cost understanding visualisations 
new representation developer provided initial learning cost determining visualisation trying say 
acknowledge know test drive visualisation look entertain prospect may change component component developer developer anyway need find ways add flexibility visualise test drives 
means providing flexibility store test drive output visualisation neutral format 
demonstrate achieved section 
section demonstrates architecture linking ideas test driving visualisation neutral test driving output software visualisation 
summary chapter contributes repositioning test driving model context marketplace 
result analysis issues raised chapter test driving model 
issues trust availability cost concern component author developer 
proposed developer test drives component marketplace 
summary system 
shown change venue affects test driving model shown impact marketplace test driving issues trust availability cost 
consequences marketplace test driving marketplace access developer test drive output 
utilise test drive output software visualisation techniques better complex information contained 
visualisations new form component documentation documentation available wider audience just developer performed initial test drive 
contributed component evaluation approach reduces level trust authors developers 
approach removes cost downloading installation developer evaluation provides source visualisations documentation available developers 
full visualised test drive output require architecture linking component repositories test driving visualisation 
require visualisation independent formats storing test drive output create different visualisations test drive completed 
requirements topic chapter 
chapter 
test driving marketplace chapter vare architecture marketplace test driving chapter propose software architecture supports marketplace test driving reusable components 
architecture form basis prototype chapter 
architecture supports storage retrieval information describe test drives taken place 
test drives generate wealth information component behaviour call information test drive report 
describe set information test drive reports contain propose xml schemas storing test drive reports 
test drive reports huge software visualisation techniques required reports coherent manner 
visualisation architecture reuse vare shows test driving software visualisation linked marketplace 
reusable component description rcd format xml trace execution xte format show test drive reports stored visualisation independent manner architecture 
start chapter discussing vare architecture expands artifacts supporting marketplace test driving visualisation test drive reports 
vare chapter core contribution 
introduce rcd xte discuss help visualise test drive reports storing reports visualisation independent manner 
vare section visualisation architecture reuse vare 
architecture designed support activities test driving presenting documented test drive reports software visualisation techniques 
assume component market contain components multiple programming languages components varying size configuration 
tools fully implement architecture able provide test driving report visualisation functionality clients network 
component execution initial stages visualisation performed server collection servers clients perspective features offered 
basic component repository 
chapter 
architecture marketplace test driving 
provision server side test driving harnesses individual components component sets range implementation languages 

extraction compile time structural runtime behavioural information components storage visualisation 

transformation structural behavioural component information visualisations client specified templates 

client side display resulting visualisations 

component evaluation need prematurely transferring poorly understood intellectual property owner prospective 
shows vare architecture 
architecture split client server division 
firstly discuss architectural entities server side discussing associated entities client side 
server side vare contains repositories process classes set components 
discuss order typically visualised test drive 
table shows elements vare architecture map steps chapter model 
share elements 
vare software architecture tool support manage create artifacts identified section 
notion component component repository test drive report exist figures 
vare engine vare component set equivalent execution environment artifact 
vare test drive interface displays component interface artifact documentation artifact 
test drive interface developer creates test harness artifact artifact passed engine 
component repository component repository set components currently known server 
repository may contain actual copies components executable state java class files perl scripts uris documenting copies retrieved 
repository provides clients capability register new components users benefit searches 
minimum set information kept component repository registration 
set includes unique key keywords language version dependencies additional documentation 
shall discuss depth 
unique key component unique identifying key 
sufficient component name purpose component name guaranteed unique respect components 
reason repository may store multiple versions releases component sharing name potentially exhibiting differing structure behaviour 

vare vare architecture supporting networked test driving visualisation reusable components 
architecture supports multiple developers test driving components concurrently session manager server side 
session manager hub communication client side interfaces repositories process 
communication go directly session manager display components user interfaces form remote desktop viewer 
chapter 
architecture marketplace test driving model step vare elements component repository component repository interface component set session manager component set engine engine repository test drive interface session manager developer developer test drive interface session manager test drive interface session manager test drive interface session manager test drive interface session manager component set engine test driven program interface test drive report repository session manager test drive interface test drive report repository transformer transformer repository transformer repository interface visualisation interface visualisation repository component repository session manager developer component repository interface component set session manager table map steps test driving model relevant elements vare architecture 
steps involve developer considering options map specific elements supported elements mapped preceding steps 
keywords keywords stored categorising component 
helps developer find relevant components test drive 
significant undertaken researchers categorise index structure repository easy extraction relevant components 
thesis contribute issue architecture compatible best practice 
language implementation language language version java stored 
ensures select correct environment test drive component 
components may support multiple languages multiple versions 
example component implemented net architecture run common language runtime environment component implemented net architecture 
dependencies components component depends listed 
components accessible marketplace permit test driving component assume components turn registered repository 
may situations possible register components intellectual 
vare property reasons 
example component may dependent particular library available licensed developer available marketplace 
situations server code required test drive component component need de registered test drive functionality disabled 
issue component version pose problem due version management potential incompatibilities different dependencies 
example reusable dynamic link libraries dll versioning problem encountered microsoft windows environment problem subsequently dubbed dll hell 
system contain version component component loaded runtime application required 
applications installed checked system contained correct version dll application required version incorrect dll upgraded downgraded suit installation 
create problems applications installed relying original version dll 
problem arise component dependencies 
component may depend components component may depend version component component depends version component need mechanism addressing library versioning system implemented modern microsoft windows operating systems 
address issue component incompatibility thesis acknowledge area necessitates research 
additional documentation documentation provided component authors associated component 
expect documentation primarily textual javadoc files java components may include tutorials installation guides help 
storing information set describe xml schemas section associated components component repository 
rcd files document structural meta information relating third fourth parts information set just discussed 
xte files document test drives performed registered components 
component repository stores rcd file associated component 
component repository links component relevant xte files test drive report repository see section 
help developer reuse existing test drive reports understand components consideration 
component set developer browses component repository may find components wish test drive 
component set collection components developer expressed interest combined components collection dependent 
chapter 
architecture marketplace test driving purpose component set supply test driving harness interfaces developer wish 
ensures developer easily specify operations test drive sequence overwhelmed information regarding registered components having remember interfaces components interest 
assume expression interest component requires initially selecting meta information viewing 
selection method filtering final set specifying final set entirety 
engine repository engine repository responsible storing applications hold test drive harnesses 
applications called engine processes individually discussed depth section 
architecture supports test driving components different implementation languages language versions 
implementation engine process typically support language multiple versions language 
means need multiple engine process implementations 
engine repository stores indexes implementations unique combination language name version 
developer selects component set moves test drive activity engine repository analyses component set 
analysis determines languages language versions components set implemented 
component set may contain components implemented different languages different versions language 
engine repository creates engine process instance engine types repository registered supporting language language version component set 
ensures components executable appropriate engine process 
engine process instances registered session manager tracked particular user 
instance supplied repository may exist multiple test drives supported components 
developer may decide test drive wish start clean environment 
case may request new instance obtained engine repository old instance destroyed 
similarly developer may decide wish environments language language version 
may request new instances obtained engine repository 
engine repository store individual instance currently developer 
instances indexed session manager 
shall discuss session manager section 
engine process engine process instance supports test driving components sharing common language language version 
engine process capability extract interesting information test drive runtime environment store information test drive report repository discussed section 
engine process sets input sets output 

vare input set input current component set 
provides structural information needed display component interfaces developer 
second set input sequence interaction developer wishes try 
component executing sequence interaction component may requests input 
may include files filesystem data network information entered selected gui 
third set input data supplied response requests 
output set output collection apis components component set engine process supports 
relates second step model describe chapter 
output sent network developer displayed browser 
developer uses output determine test drive sequence returned engine process input sets stated 
second set output output created executing component 
third input set include things output filesystem output network output gui 
output sent network client browser 
third set output execution trace describing components behaviour test drive 
execution trace documents events occurred executing environment component performed task 
include method calls method returns field accesses thrown exceptions thread creation 
third set outputs stored test drive report repository visualisation 
engine process provides execution environment component run execution environment different compared regular execution environment particular language 
engine process needs able spy create execution traces 
engine processes execution environment performs operations component reports notable events arise completion test drive 
engine process may filter events included final test drive report may supplement events information gathered test drive 
supplementary information include name developer date test drive performed notes developer may time 
annotate developer intended purpose test drive particular insight test drive afforded 
test drive report repository test drive report repository stores execution traces created engine processes 
developers test drive reports create software visualisations 
developers need able identify appropriate test drive report visualise reports indexed developer name date created developer supplied keyword 
chapter 
architecture marketplace test driving test drive report relates components component repository 
assist finding prior test drives interesting components test drive report repository informs component repository new test drive reports provides means 
component repository stores links component copy actual test drive report maintained test drive report repository 
test drive reports stored xml xte format describe section 
xte files primarily document runtime behaviour assume associated rcd files describing static structure components 
rcd files stored component repository test drive report repository needs include links files registered report 
transformer repository transformer repository stores visualisation templates 
templates transform component information viewable visualisations 
developer selects visualisation template believe useful showing need know test drive 
templates written third party trained creating visualisations 
remove burden developer knowing ahead time needs shown needs shown needs shown 
templates provided expectation financial reward 
people submit third party templates way people contribute reviews guides books hardware existing community websites 
templates created component author help developers understand test drives 
developer considers cost test driving visualising initial decision consider component author reduce cost promote confidence gathered information help gain audience component 
authors intimately familiar component behaviour best position know visualise maximum promotional effect 
downside developer knew visualisation template came author template may trusted show details 
author may perceived having short term interest showing developer want see happening 
transformer transformer takes test drive report input outputs visualisation 
visualisation encoded format interpreted displayed viewer application 
type transformer responsible creating type visualisation 
example transformers uml sequence diagram transformer stack adt animation transformer 
vare architecture require transformers output visualisations format 
transformers create macromedia flash visualisations side transformers create scalable vector graphics svg visualisations 

vare visualisation repository visualisation repository stores visualisations created test drive activity 
may multiple visualisations test drive 
repository able store visualisations multitude formats best suit needs varied audience 
browsing market able discover visualisations request displayed client side 
repository usefully link visualisations components searching relevant visualisations easier 
useful link visualisations original test drive report 
visualisation visualisation way representing set information uses techniques sound graphics animation convey meaning structure information 
visualisation encoding formatted viewer application interpret visualisation developer display 
commit specific template visualisations match commit specific format visualisations encoded 
session manager claim developers able perform activities web 
markets customer point time customers access repositories necessary server maintain session manager differentiate developers 
session manager able store engines transformers component sets currently particular developer continue interact data set processes multiple request response cycles 
component repository interface component repository interface developer client side architecture 
developers component repository interface select components interested test driving browse test drive reports created 
component repository interface provides developer information stored component component repository 
information developer create component set specifying components match requirements 
component repository interface supports registering new components 
depending nature marketplace component may registered developer registered associated marketplace 
registering component requires specifying meta data stored component repository 
includes name component version component implementation language language version keywords dependencies 
interface support specification uris component implementation extracted needed 
component registration information sent component repository stored retrieval 
chapter 
architecture marketplace test driving registers component may ancillary comments documentation developer 
interface support extra information entered referenced 
component repository interface sends component selection information session manager incorporated server side component set 
test drive interface shown component set explored 
selecting existing test drive report results report extracted test drive report repository server side transformer repository interface appearing client side 
selecting existing visualisation results visualisation extracted visualisation repository server side visualisation interface appearing client side 
test drive interface developers test drive interface write test harness test drive components component set 
information passed engine server side turn generates test drive report 
test drive may result information communicated developer directly test drive interface 
engines developer uses execute test drive depend languages versions selected components 
components may capable working multiple languages designed microsoft net common language runtime clr common type system cts 
components may capable working multiple versions language 
vare designed support having components different programming languages marketplace 
test drive interface assume particular programming language write test harness 
programming language specifying test harness vary depending component interest developer particular point time 
test drive interface helps developer write test drive supplying api information selected components 
information sent engine relevant engines instantiated component set 
developer view api information decide operations attributes interested discover access 
test driven program interface test driven components may user interface 
developer may need interact user interface test drive executed 
test driven program interface provides means interact server side user interface client side 
display developer sees limited engine developer time 
sufficient single display server side vare supports multiple developers test driving time 
developers shared server side display risk accidentally interacting wrong test drive risk display cluttered confusing 

documenting components transformer repository interface transformer repository interface lists transformers registered server side 
transformer repository interface support registration new transformers subsequent selection transformers creating visualisations 
transformers need shown name brief description create 
developer selected test drive report component repository interface 
developer selects transformer want applied test drive report information passed server transformation undertaken 
transformers created explicitly vare written separately imported 
ability import new transformers vare provides flexibility visualisations created 
different people different interests wish visualised wish visualisation appear 
specifying fixed set transformers need forecast transformers available meet possible demands 
turn avoids risk forecasting incorrectly 
transformers need imported transformer repository interface needs support registration 
minimum interface support referencing transformer implementation 
interface support inclusion additional information 
additional information include name transformer brief description transformer format resulting visualisations 
visualisation interface visualisation interface displays visualisation created transformer 
vare limit visualisation formats built visualisation interface fancy text browser svg viewer macromedia flash viewer 
visualisation interface receives visualisation client side network 
visualisation interface need decide appropriate player visualisation received instantiate player needed 
visualisations linked component repository interface indexed components visualise 
documenting components section states developer may want output different sources output sent back component interfaces output generated monitoring runtime environment component executes 
test drive report combines information developers reports assist understanding component usage behaviour 
describe set information developer find useful deciding reuse component 
set includes information extracted execution information extracted compiled source form extra information provided author developers 
chapter 
architecture marketplace test driving split set sections 
section describes particular line questioning component functionality component component component reused 
component 
decide potentially reusable component useful new context developer know component 
treat component section black box interested external side effects results occur consequence interacting component public interface 
consider elements important understanding component author user descriptions 
actual results side effects sequence accesses public interface 
data sent requested external component 
user input output required execution 
shall expand points depth 
author user descriptions component author know specific details component 
information provide traditional text documentation understanding component 
similarly regular users component understanding component capabilities advice feedback give component useful determining appropriateness code developer new context 
text common form documentation currently available complemented visualisations replaced entirely 
visual techniques applied descriptions aid readability understanding peoples reports experiences components remains powerful way sharing knowledge 
results side effects results executing certain sequences method calls component public interface side effects sequences components data component state affect applicability reuse new context 
results cases determine functionality provided component matches needed developer 
side effects may help show component components compromising functionality 
may show particular sequence interactions leaves component correct state required sequences 
point may especially important component reused multiple times 
case interaction component need leave usable state interaction 

documenting components sent requested data component reused information sent requested component entities network filesystem database needs handled new context 
important developer understands requirements actions component regards external environment 
ensures components needs met directly relatively minor modification new context discarded selection process 
represents results side effects external immediate application component reused direct user input output discussed section 
user input output component require interaction user perform functionality needs understood developer informed decision appropriateness new context 
specifically developer may need know information required user information user method interaction environment graphical command line required interaction take place 
component 
approached question component treating black box 
may help deciding functionality available meet requirements new context question component works 
important resource permission requirements operation may prohibitive new context rule component candidate reuse 
possibility extending modifying behaviour component meet new requirements 
understanding internals components may open opportunities modifying behaviour required replacing sub components overloading methods 
treat component white box look internal information useful visualise author user descriptions 
system permissions 
software applications libraries 
hardware resource usage 
execution traces 
multi threading synchronisation 
timing 
shall expand points depth 
chapter 
architecture marketplace test driving author user descriptions similar author user descriptions mentioned section authors users placed impart valuable knowledge component works 
visualisations aimed promoting understanding component works incorporate feedback author users 
system permissions system permissions required component affect appropriateness reuse situation 
environments may restrict permissions security reasons untrusted java applets browsers deny component certain permissions 
describing permissions component requires allows developer informed decision regarding usefulness 
ties section data sent requested identified useful visualise 
identify files accessed modified servers ports accessed network 
possible permissions include considerations component execute example component needs execute superuser 
software applications libraries component require software fulfill functionality visualising information enable developer better understand component appropriate reuse 
visualising information may help identify specifics software required 
developer investigate position knowledge software available usable new context 
hardware resource usage performance component may prohibitively expensive reuse new context 
new context requires functionality achieved fixed parameters certain time frame certain amount cpu usage certain boundaries filesystem access network traffic candidate reusable components measured criteria 
visualising information gives developer better understanding appropriateness code component restrictions placed new context 
execution traces possible approach reuse overload certain methods component extend classes component modify existing functionality required 
visualising methods get called classes may give developer better understanding methods classes need modifying change behaviour 
relates primarily execution hidden public interface component 
tracing execution internal component involves capturing information method calls method returns field accesses field modifications object creation 
documenting components object deletion 
visualising information developer gain better understanding potential consequences alternative executions created overloading replacing certain parts component 
multi threading synchronisation issues threading synchronisation resource sharing deadlock avoidance important factors deciding component reusable new context 
component may reasonably expected correctly original context identifying threads requirements resources may highlight problems working components currently new context 
component reliance threads may unsuitable particular architecture architecture may support multi threading supports fashion inconsistent model component uses 
information regarding derived analysing static source code dynamic information gained runtime viewing threads synchronisation useful show sequencing events amount time spent holding waiting resource 
threading synchronisation data may comprise large amount information 
visualisation techniques highlight important parts information help developer informed decision reusable component ability collaboration components 
timing hardware usage may measure component performance respect computer resources new context may place restrictions components may fit 
restriction may time component needing complete operation certain time frame result useful 
example component real time application 
visualising time line execution help developer measure component performance required potentially reusable components fulfilling functionality 
component reused 
developer decided component easily modified need acceptable need understand reuse 
simple example may know network component allows create network connections servers underlying native socket libraries need know order execute various methods public interface get job done 
touches wishes section 
list stated wanted know originally intended operation component interested modified new context may specifically designed 
chapter 
architecture marketplace test driving categories information see important understanding reuse component example uses component public interface 
example extensions component inheritance overriding methods 
details install software required component 
shall expand points depth 
example uses examples showing previous uses public interface component show link component code new context 
involve showing set state objects required passed reusable code functionality invoked 
example extensions reusing code may consist simply plugging old code new project interacting public interface may involve extending currently available functionality match new requirements 
approach mechanism inheritance extend certain classes methods reusable component borrow add extra capabilities needed 
example extensions show classes methods extended potential side effects doing 
show extending classes objects parameters global variables component modify behaviour component intention meeting required new functionality 
installation details barrier successful reuse time effort involved installing component new project 
components may comparatively easy task downloading component including file files search path compiler runtime environment class path source path variables java 
components may need complex installation procedures 
include recompilation local architecture downloading ancillary components reused component needs 
clearly available information go doing help reduce time effort required reuse process 
example available predominately text documentation readme files complemented incorporated visualisation techniques 
storing test drive reports test drive reports contain subset information discussed section 
section shall claim test drive reports need stored visualisation neutral 
storing test drive reports format 
shall close chapter proposing xml schemas structure test drive reports 
schemas assume working test drives object orientated components 
schemas explicitly refer aspects object orientated languages objects classes methods fields 
schemas may modified orientated languages address modifications thesis 
intermediary storage extracted information test drive report need address issue format stored report 
approach immediately transform information visualisation displayed saved discard information 
second approach create new visualisation keep information 
third approach keep information immediately create visualisations 
advantages disadvantages keeping raw information test drive completed 
claim possible transform old test drive reports new visualisations long original test drive performed 
motivate earlier claim test drive reports stored schemas described rcd xte 
briefly discuss advantages disadvantages storing test drive reports pre visualisation form identifying possible alternative approaches limited 
advantages benefit storing raw information need omniscient regarding visualisations 
know test drive visualisations look possible components 
certainly uml diagrams useful avenue explore equally possible set visualisation types suitable components networking components mathematical components graphical components developers cultural language environmental reasons 
test drive reports stored intermediary schema feed different transformers time 
developers investigate existing test drive reports new ways prompted questions raised earlier investigations 
turn improves test drive report flexibility reusable artifact 
section identified methods storing useful information create new visualisations old test drives 
method store test drive report second method store interactions component resulted test drive report 
favour method removes requirement component accessible extra software visualisations created 
test driving system visualisation system need coupled shared information schema need concurrently executing 
chapter 
architecture marketplace test driving disadvantages execution traces extremely large 
massive amount information exists execution non trivial component 
information space filtered appropriately resulting traces sufficiently big consideration needs traces structured 
filtering restrictive difficult 
filtering available data gather relevant information requires knowledge fact relevant 
software tool performs filtering task disadvantage visualisations limited tool author thought interesting 
developer expected perform filtering disadvantage developer needs identify relevant data set fully understand 
alternatives wish view new visualisations intermediary format alternative approaches 
alternatives problems 
alternative re execute test drive 
developer needs spend time effort performing test drive wasteful recreating exactly done 
static information captured analysing source compiled forms component easily rediscovered 
dynamic information costly reproduce terms resource cost re executing code time taken developer repeat test drive 
possible second test drives subtly different inconsistency introduced developer change external environment component executing changes files filesystem network 
leads differences visualisations incorrectly thought show underlying test drive report 
second alternative extract information model visualisation attempt create second visualisation 
unfortunately visualisation may contain information original test drive report 
creating second visualisation answer questions posed visualisation need access information underlying information model shown inadequately shown 
wagner claim non proprietary intermediary schema needed describing execution traces 
test drive report format ideally platform neutral 
encourage widest possible development visualisations reports 
created xml formats combined document component structure behaviour test drive 
formats reusable component description rcd format xml trace execution format xte 
benefits xml schema dtd easily distributed understood resulting text files architecture neutral exists xml parsing transformation libraries widely programming languages 
rcd xte builds done 
developed process abstraction language pal documenting test drives programs 

storing test drive reports process abstraction language discussed pal format section 
pal files contained static information regarding program structure dynamic information regarding program runtime behaviour 
static dynamic information contained pal file regardless multiple pal files describing program 
conducted trials pal test handled moderate sized implementations 
generated pal files sample program executions 
executions java applications ranging lines code jdk standard libraries 
pal file small moderate program range tens megabytes hundreds megabytes size 
multiple test drives program pal files quickly began consume significant amount secondary memory 
trials identified problems pal dictated information stored 
pal files combined static dynamic information file stored entire information needed describe specific test drive 
lead lots redundancy situations storing multiple test drives 
static information identical test drive component multiple times 
component may depend common components shared components test driven 
example java language java libraries packaged standard development kit 
similar examples widely programming languages 
remove redundant information test drives decided necessary store static information relevant single component separately dynamic information relevant single test drive 
result rcd static information xte dynamic information 
rcd file documents types particular component xte file externally associated collection rcd files represent test driven component 
number benefits approach 
firstly individual files smaller beneficial storage transportation costs 
secondly easy means identifying version component contained pal file 
thirdly easy means identifying types comprised component types component 
table compares features pal rcd xte 
reusable component description rcd stores information single component 
component may consist multiple classes multiple namespaces 
due familiarity java term package language indicate coherent collection classes namespace 
information included rcd file consists names included packages names classes packages 
class listed include interface description place type hierarchy signatures operations attributes 
rcd file contains meta information component component name component author natural language description component capabilities 
interface description important information contained referenced separate xte files 
meta information important help identify different versions component help provide background chapter 
architecture marketplace test driving feature pal rcd xte overview information sources static dynamic static dynamic extensible meta data structural information class hierarchy class dependencies method signatures field signatures information stored execution component execution behavioural information method events field events security events security events security events thread identification variable values information stored execution execution table table compares features pal rcd xte 
pal documents executing programs contains static information types execution 
rcd documents component structure include run time behavioural information 
xte documents component behaviour comprehensively document component static structure 
xte supports wide variety events pal 
rcd xte meant document component structure behaviour 

storing test drive reports implementation purpose 
separation static dynamic information gives important benefit 
document component test drive performed 
benefit developer needs component documentation decide ones bother test driving 
decide test drive component need documentation describing interface devise appropriate sequence interaction 
rcd files created analysing component compiled source form 
visualisations component interfaces created rcd files assist developer 
rcd currently support object oriented languages currently support multiple inheritance 
support differentiating extending existing class implementing multiple interfaces demonstrating rcd bias java programming language 
rcd allows type component list dependencies 
intended comprise list classes internal external component implementation interface requires 
useful developer helps identify needs brought test drive 
useful integration final system 
modifying component plausible means reusing existing behaviour easy access dependencies show modifications successfully performed 
method reusing frameworks subtype types passed parameters methods 
similar approach taken may modify component behaviour developer requires 
element composition attributes rcd version creator detail package package class class classname methods fields interface dependency methods constructor method fields field constructor modifiers argument method type modifiers methodname argument field type fieldname modifiers modifiers access static native final synchronized volatile transient interface argument type type typename table table shows organisation rcd file 
top level element rcd file rcd element 
elements composed elements may contain attributes 
names italics represent elements solely consist text compositions elements 
table shows organisation rcd file 
top level element rcd element composed meta data packages 
package turn composed chapter 
architecture marketplace test driving classes class composed methods fields 
methods fields defined class listed class 
methods fields inherited superclass listed superclass regardless superclass part component documented rcd file 
raises issue link rcd files identify correct version rcd file 
supported including relevant information detail elements dependency elements 
demonstrates example rcd file 
xml trace execution xte stores test drive information 
test driven components referenced xte file intention relevant rcd file located loaded subsequent transformation visualisation 
xte supports documentation event types test driving component 
event types include object creation method calls method returns field accesses field modifications exception throws catches security permission requests 
xte stores information object created accessed modified parameter execution 
individual implementations vare engine process filter objects developer may wish track 
xte file contains list object elements represent starting state objects 
state objects accessed modified field access field modification event detected stored test drive report 
ensures test drive report contains information object changes time 
object element represents object represent single variable multiple objects course execution 
event happens affect object event refers object id stored object element 
event happens affect primitive value primitive value stored event element literal 
table shows organisation xte file 
top level element xte element 
xte element composed meta data execution list objects 
execution composed series events identified unique event ids associated particular threads 
object composed type name list fields execution initial values fields 
field modification events execution element show subsequent updates initial values 
object contains object id referenced events execution 
shows example simple execution component documented 
specific information stored regarding event types briefly describe information justify selection 
event contains thread id providing support clearly documenting multi threaded components 
xte method object creation information similar pal albeit different nomenclature 
added new features language security permissions exception handling 

storing test drive reports rcd version version creator stuart marshall creator detail assumes java sdk detail package class classname classname java lang object dependency java lang string dependency methods constructor modifiers false access public final false interface false native false static false false synchronised false transient false volatile false argument message rcd type rcd name java lang string rcd name rcd type argument constructor method type rcd name void rcd name rcd type modifiers false access public final false interface false native false static false false synchronised false transient false volatile false methodname rcd methodname method methods fields field type rcd name java lang string rcd name rcd type fieldname message rcd fieldname modifiers false access private final false interface false native false static false false synchronised false transient false volatile false field fields class package rcd shows rcd file simple component 
component called consists class 
class contains constructor takes string message field stores message 
class contains additional method called takes arguments 
class extended object 
list java lang string dependency class declaration 
include detail states component uses java sdk 
chapter 
architecture marketplace test driving element composition attributes xte creator date details execution object object complextype field objectid field execution methodcall complextype parameter objectid threadid methodcall typename methodname parameter threadid typename methodname objectid 
threadid fieldname objectid threadid fieldname objectid threadid location details threadid location details threadid location details permission threadid parameter complextype location complextype methodname complextype typename typename objectid table table shows organisation xte file 
top level element xte file xte element 
elements composed elements may contain attributes 
names italics represent elements solely consist text compositions elements 

storing test drive reports xte creator stuart marshall creator date january th date execution evt objectid obj threadid thr complextype typename typename complextype parameter complextype typename java lang string typename complextype message objectid obj parameter evt objectid obj threadid thr typename typename parameter complextype typename java lang string typename complextype message objectid obj parameter execution object objectid obj complextype typename typename complextype field objectid obj field object object objectid obj complextype typename java lang string typename complextype object xte shows xte file execution component 
execution involves creating object type 
events corresponding 
objects object created event string parameter object 
show string object fields reasons space 
event list method name corresponds event 
chapter 
architecture marketplace test driving security permissions documenting security permissions shows resources capabilities component trying access outside implementation 
developer information decide component inspection able operate context needed component tries perform actions may compromise security system integrated 
specific information stored location permission requested natural language description permission keyword identification permission type 
enumeration list possible keywords list dependant test driven component implementation language 
plausible permission types read network write network access file modify file execute program 
exist security permission models various languages servers 
java net implement security models ensure access resources filesystem network authorised security policy 
security models permit deny activities creation new class loaders exiting virtual machine access system properties creation gui windows execution applications 
access modification resources security threat web servers emergence active content cgi scripts 
vital detect executing code accessing modifying resources behaviour blocked avoided 
documenting security permissions executing code requests underlying security policy assist detection 
exception handling documenting exception handling shows component detect handle events boundaries typical behaviour 
reliable robust system ability handle exceptional behaviour gracefully support graceful recovery error reporting 
developer wishes integrate component system need indication component break non functional requirements 
types information documented occur particular test drive xte file represents 
list possible exceptions thrown particular operation listed static information kept component equivalent rcd file 
methods xte documents object creations constructor calls method calls method returns 
method call corresponding method return object creation corresponding method return 
method object creation events contain information identify comprehensive class operation information stored associated rcd file 
instance case method calls name method object invoked list parameter types included parameter values 
combination 
storing test drive reports method name type list sufficient identify unique operation signature static rcd file object id resolve class method called 
information exceptions throwable method return type associated method stored method call events xte 
information stored rcd file 
fields added field access field modification events xte 
developers note operation affected particular state object operation affects particular state object 
useful reasons 
firstly show operation behaviour may differ developer changes object state time 
help guide test drives lessons learnt earlier test drives 
secondly indicate side effects particular sequences operations sequence operations may configure data affects sequence operations 
field access event provides information name field accessed object field value field point time 
field modification event provides similar information includes old value time modification new value modification 
events detected object system may may filtered instances component classes 
meta information xte supports meta information test drive performed 
metainformation includes name developer date test drive performed details expressed natural language test drive meant achieve 
useful test drive reviewed initial performance 
documenting component information rcd xte rcd xte document subset information outline section 
particular rcd xte document compile time run time information 
rcd xte encode test drive reports provided means storing test drive reports subsequent multiple visualisation 
table outlines parts section information set stored rcd xte 
discussion table warranted 
xte factors component structural information single rcd file 
rcd file available able completely understand information xte file 
reason list features execution traces supported rcd xte xte nominally represents run time behaviour 
reasoning holds true decision list example uses example extensions supported rcd xte 
rcd xte currently supports sent requested data user input output hardware resource usage installation details 
sent requested data user input output technically appear method calls buried execution traces 
information sufficiently difficult extract consider rcd xte explicitly supports 
information difficult extract chapter 
architecture marketplace test driving information buried multiple method calls variety possible libraries known developer 
continue look ways expand rcd xte support useful component information 
rcd xte support large subset information deemed useful section represents start creating format comprehensive test drive reports 
information item rcd xte component 
author user descriptions results side effects sent requested data user input output component 
author user descriptions system permissions software applications libraries hardware resource usage execution traces multi threading synchronisation component reused 
example uses example extensions installation details table rcd xte support subset information discussed section 
table lists categories information set identifies supported rcd xte 
rcd contains compile time information xte contains run time information 
indicates information item supported format 
summary chapter contributes architecture visualising test drive reports marketplace contributes xml schemas storing test drive component information visualisation independent manner 
vare architecture implement test driving tool support helps developers evaluate document components marketplace 
particular designed developed vare architecture handle artifacts created chapter test driving model 
necessary requirement test driving model developer handles artifacts handling incur cost time effort 
providing tool support architecture helps developer handle artifacts hope reduce cost reuse improve developers insights component usage behaviour 
vare supports marketplace test driving visualisation documentation developer creates available developers 

summary vare uses rcd xte data formats store test drive reports components visualisation independent manner 
enables vare provide developers ability create new visualisations old test drive reports having re execute initial test drive 
help developer explore experiences existing documentation thrown new light component usage behaviour 
chapter 
architecture marketplace test driving chapter spider chapter introduces spider prototype tool test driving reusable components marketplace 
developed spider proof concept contributions preceding chapters 
chapter discuss contributions realised spider implementation 
start overview prototype moving contributions turn 
identify developing prototype affected development models formats architectures 
closing discuss evolution spider earlier prototypes 
developed spider show models formats architectures identified chapters implementable 
chapter identifies prototype 
overview developed spider web prototype tool actively exploring documenting reusable components 
developer access prototype web browser tool test drive registered components 
xml formats discussed chapter document component test drives 
extensive research organise components repository easily 
spider proof concept marketplace test driving implement minimum repository infrastructure required components available marketplace test driving 
implement sophisticated indexing querying functionality test driving model begins initial set candidate components selected 
actual repository integrate spider test driving features accordance vare architecture discussed chapter 
test driving model commit particular programming language paradigm 
spider current implementation supports java programming language 
spider follows vare architecture design supports inclusion programming languages minimal modification existing code base 
spider documents test drives rcd xte formats 
able create documentation spider needs able interpret information stored component detect events runtime environment interrogate runtime environment state 
spider needs able manipulate information necessary formats 
chapter 
spider spider uses existing java libraries achieve functionality notably java reflection java debugger interface jdi technologies extract information apache xml technology store information 
test driving model chapter proposes model describing developer test drive experience 
show spider follows model 
test driving model task description test driving activity look spider largely developer perspective section 
sections shall look closely spider design implementation 
analysing component spider explicitly supports steps test driving model 
steps gaining access component viewing interfaces 
third fourth steps test drive input test drive output explicitly supported developer decide expectations 
accessing component developer enters authenticates spider website list components registered repository 
developer explore component repository specify particular component worthy study 
developer browser renders page contains html form developer explore component structure behaviour 
accessing page developer gained access executable version component satisfied step test driving model 
shows interface spider presents developers arrival 
basic list known components 
figures show developer importing new components repository 
note currently meta information associated components categorisation purposes 
aim research prototype 
analysing component interfaces registers component repository spider creates rcd file component 
developer selects particular component browser renders page primarily created rcd file 
rcd file contains information extracted component static compiled representation additional information submitter may supplied time 
interface component rcd file automatically documents component api 
difficult determine component interfaces filesystem network component binary source form 
rely component authors document component submitter include documentation registering component repository 

test driving model developer represented simple list components imported spider repository 
list seen top left hand corner 
developer select particular subset interesting components selecting individual components clicking select component set form button 
developer provided information selected component 
developer import new component repository 
developer form tool specify component name author version list urls point jar archives class files component comprised 
shows developer importing instantj component discussed chapter 
chapter 
spider developer may provide url component 
demonstrates game component mixture class files jar archives 
developer view component shown figures 
developer views documentation viewing component interfaces satisfying second step test driving model 
writing test drive steps test driving model involve writing code form test harness test driven component 
developer writes code html form sent marketplace execution server side 
show developer supported spider create test harness 
encoding test drive input developers encode test drive input standard html form 
demonstrated figures 
spider supports single method call statement supports assignment values fields return values variables 
spider support conditional loop statements handle multiple method calls statement 
spider executes code developer sends 
instruction performed spider updates collection known objects values available subsequent instructions 
developer allowed name variables manner standard java 
developer variables method call parameters values assigned variable object field 
similar variables standard java 
encoding test drive output spider automatically prints return values operations results assignment statements 
demonstrated 
developer need specifically encode output combined automatic extraction xte test drive reports ensures test drive sufficiently documented 
code 
test driving model rcd rcd xmlns rcd www mcs ac nz rcd rcd package rcd instantj expression rcd rcd class rcd classname rcd classname rcd java lang exception rcd rcd methods rcd constructor rcd modifiers false access public final false interface false native false static false false synchronised false transient false volatile false rcd argument rcd reason rcd rcd type rcd name java lang throwable rcd name rcd type rcd argument rcd constructor rcd method rcd type rcd name java lang throwable rcd name rcd type rcd modifiers false access public final false interface false native false static false false synchronised false transient false volatile false rcd methodname rcd methodname rcd method 
rcd methods rcd fields rcd field rcd type rcd name java lang throwable rcd name rcd type rcd fieldname reason rcd fieldname rcd modifiers false access private final false interface false native false static false false synchronised false transient false volatile false rcd field rcd fields rcd class shows part rcd file instantj component 
rcd segment describes instantj expression class contained instantj component 
class superclass constructor methods field 
constructors methods fields modifiers control access name 
methods constructors may parameters methods fields types associated 
method type documents type values returned completion 
field type documents type values stored field 
removed method descriptions reasons space 
chapter 
spider shows developer view component set chosen 
top right hand corner contains table contents selected component set 
top left hand corner contains simple test drive interface 
components apis listed bottom half screen 
apis far large screen user currently scroll explore different classes interfaces component 
components hidden view clicking show hide links component name top left corner table contents 
component api begins listing package component 
listing includes names classes interfaces package 

test driving model shows different part component api shown 
currently observing instantj component imported 
part api contains class called shows tables laid fields constructors methods 
class identified having extended class instantj compile compiler 
shows part encoding instantj test drive discussed chapter 
currently standard java syntax parsing instructions relatively simple task 
individual instruction begins create calling constructors invoke calling methods access retrieving field values 
store values instructions return providing variable name followed sign 
variables subsequent test drives test drive environment 
parameters passed providing type parameter variable adhere followed variable literal value chapter 
spider shows part encoding instantj test drive discussed chapter 
part encoding includes invoke instruction demonstrates instructions split multiple lines 
entire encoding completed submit test drive execute test drive code button 
test drive performed current test drive environment 
test drive environments created deleted buttons interface 
session may contain active test drive environment point time 
test drive output effectively added spider developer submitted rest test harness 
setting system spider automatically handles boilerplate required start java application virtual machine 
developer required setting test harness 
example boilerplate code public static void main method standalone java applications contain 
ordinarily provides virtual machine starting location application 
spider starts virtual machine uses application interpret java test drives initiated developer 
spider knows set application generic test drive 
developer may need write code set particular instances component suitable state prior test drive 
code added developer html form code written preceding steps 
developer test drive current test driving session developer choose reuse objects values left earlier test drives 
partially removes need write setup code subsequent test drives existing state reused immediately 
spider currently provide support modifying filesystem operating system environment prior test drive 
cleaning system principles apply cleaning environment applied setting environment 
developer chooses reuse state current test drive test drives spider maintain state reusing environment 

test driving model shows output test drive leads interface shown 
jcalendar class extends swing purely 
placed frame purpose current test drive create populate show frame 
shows vnc viewer foreground web page background 
web page lists object creations method calls assignment statements encoded test drive 
web page lists return values operations assignments 
result test drive calendar displayed vnc viewer 
discusses subsequent test drive calendar 
chapter 
spider shows test drive jcalendar component 
object instance jcalendar class created stored visible see 
resulted calendar displayed vnc window machine 
vnc window allows interact gui currently executing server 
selected may date see section encoded test drive extract day month year calendar api 
shows vnc viewer foreground web page background 
web page contains html form top left hand corner contains code sent server control part test drive 

test driving model spider destroy environment deallocate resources environment 
execution spider partially supports steps twelve test driving model 
steps executing test drive code viewing results twelve adopting discarding exploring supported 
step eleven deciding reuse explicitly supported developer performs activity feedback experience earlier steps decision 
executing test drive code developer enters test drive code html form supplied step 
test drive code entered developer submits html form server 
developer test drive current component set server create new runtime environment perform test drive 
currently active runtime environment executes supplied code 
execution component may require interaction developer 
vnc viewer applet provided developer web browser 
developer vnc viewer interact component graphical user interface 
demonstrated 
discussed vnc section 
viewing results test drive result output completion 
forms output considered 
return values side effects caused individual statement test drive code 
developer html web browser 
second test drive report encoded xte file 
stored server tool asks developer wish name report wish provide annotations report 
spider currently support transformation xte test drive reports software visualisations 
output stored available visualisation accordance step test driving model 
figures show fragments xte file created instantj test drive 
represents top xte file contains limited metadata object elements 
shows events occurred java virtual machine test drive 
events object ids refer object values accessed modified parameters 
figures show reported results test drives performed instantj jcalendar components respectively 
adopting discarding exploring developer decides adopt component normally proceed license rights download component marketplace 
spider prototype marketplace test driving support secure online transactions purchase components outside spider scope 
chapter 
spider shows report instantj test drive 
values returned method calls field accesses shown html table 
row table corresponds instruction 
instruction re iterated returned value shown 
value returned word null displayed 
developer decides discard component step twelve model easily achieve navigating back main repository 
developer choose deallocate test drive environment test drive component set 
developer ends session doing environment automatically deallocated 
developer chooses explore component choose reuse test drive environment reuse objects values created test drive 
choose start new test drive environment just chosen discard component 
test driving marketplace developers spider test drive components marketplace 
chapter identifies issues marketplace test driving raises 
issues accessibility environmental differences trust 
section shall discuss spider addresses issues 
accessibility components interfaces interfaces need developer 
component executing server side developer client side interfaces network 

test driving marketplace similar shows results test drive jcalendar component 
see values returned interpreted may 
correct selected may vnc window 
note method returns value despite fact may fifth month year 
ascertain component indexes 
means index fifth position list matches selection may calendar gui 
learnt new aspect component output 
chapter 
spider xml version encoding utf xte xte xte creator xte creator xte date fri dec xte date xte object xte objectid object xte complextype xte typename instantj expression expression xte typename xte complextype xte field xte fieldname properties xte fieldname xte xte objectid object xte field xte object xte object xte objectid object xte complextype xte typename java lang string xte typename xte complextype xte object xte object xte objectid object xte complextype xte typename java util map xte typename xte complextype shows part xte file instantj test drive 
file contains multiple xte object elements correspond objects test drive 
object objectid type number fields 
include fields test drive document field name value 
information field type documented component rcd file 

test driving marketplace xte xte event xte objectid instantj expression expression xte threadid thread xte fieldname count xte fieldname xte xte xte value xte value xte xte xte xte xte value xte value xte xte xte xte xte event xte objectid object xte threadid thread xte fieldname properties xte fieldname xte xte objectid object xte xte methodcall xte event xte receiver object xte sender object xte threadid thread xte methodname xte methodname xte typename instantj expression expression xte typename xte parameter xte complextype xte typename java lang string xte typename xte complextype xte xte objectid object xte body xte xte parameter xte parameter xte complextype xte typename java util map xte typename xte complextype xte xte objectid object xte properties xte xte parameter 
xte methodcall shows part xte file generated instantj test drive 
events field modification event field access event method call event 
events object ids refer objects exist runtime environment 
objects documented separately xte file demonstrated 
objects types described associated rcd files 
events literal values primitives demonstrated field modification event 
chapter 
spider briefly discuss spider support listed component interfaces 
component api spider extracts component api component rcd file 
api shown developer dynamically created html 
spider displays public protected methods fields component 
developers view protected methods fields know available choose reuse component sub 
spider displays basic class method field signature information javadoc 
currently scripting language automatically add method field test drive form hyperlink selected 
technically feasible possible usability feature version 
current version spider requires developer manually type interaction component api supplied html form 
graphical user interface spider uses vnc display component server side user interface developer web browser 
involves transmitting vnc applet client running applet browser 
vnc applet gives developer window server 
spider provides username password developer test drive 
vnc applet connects vnc server developer provides username password 
test drive engine component configured execute display vnc applet connected 
user interfaces component creates seen developer developer interact user interfaces mouse keyboard code executing locally 
event listeners event listeners hooks developers register interest certain events component 
events occur component component alerts registered listeners location typically method call object developer placed component information describing event 
spider support dealing event listeners developer great deal control support provided 
developers create register instances existing event listener classes register components offer event notification services 
spider currently support specifying new event listener subclasses test drive code 
spider support automatically registering basic listeners events simple name analysis component methods 
support complete scan component registration add listener methods 
scan locates add listener methods parameter analysed subclass parameter type automatically created 
instance subclass automatically registered instance component created test drive engine 
subclass simply show developer string representation event passed listener 
developer 
test driving marketplace able easily respond event aware event occured 
event messages included test drive output 
spider rely events detected engine signalled test drive complete 
test drive output sent spider facility update information developer browser 
network spider implements security manager choose deny network access components marketplace tags high risk 
remove developers ability interact component network interface 
security manager permits network access component need get past firewall marketplace puts web server firewall developer installed 
firewalls allow communication component selected port network traffic exchanged just component executing developer system listening port 
permits limited access developer component network interface 
file system test drive security engine deny file access components marketplace tags high risk 
file access denied completely developers access file system interface 
file access allowed component able write files system allowing direction communication 
spider currently support developers creating new files server filesystem test drive begins 
difficult create custom configuration files affected component behaviour 
remote procedure calls spider provide assistance developers wish set remote procedure calls components 
component implementation contains code set remote procedure calls interfaces network security client server sides permit communication possible 
entirely dependent component author having built functionality component 
environmental differences java components developers test drive spider portable different environments 
virtual machines different architectures adhere specification underlying operating system surrounding environment affect behaviour 
spider currently offer developers opportunity execute test drives different environments test drives performed machine web server 
spider written purely java portable operating systems architectures 
chapter 
spider developers request environment settings place web server provide background information test drive 
developers currently modify settings 
spider restrictive comes marketplace filesystem structure 
spider give developers view filesystem prior test drive place depending marketplace security policy may component gui popup file browser 
spider seek address issue environmental differences developer target system web server 
developing spider helped see issue important direction 
modified saw vare architecture 
initial take engine entity architecture type engine support version programming language java engine engine lisp engine 
subsequent take engine include environment netbsd java engine win engine 
trust discussed section developers authors marketplace need trust marketplace test driving functionality 
developers need trust seeing truthful representation 
authors need trust intellectual property ip 
marketplaces need trust developers maliciously inadvertently damage marketplace 
spider addresses issues trust discuss achieved 
spider address issues trust briefly choice 
developer developer tool marketplace controls evaluate value reusable component 
developer reason believe marketplace tool component developer lose faith value resulting test drive reports 
industries solve problem getting independent tool trusted source 
spider proof concept prototype tool demonstrating technologies model architecture sought 
consider outside scope prototype marketplace infrastructure issue tool support issue 
note prototype allow stage marketplace test driving tool support prohibit resolution marketplace infrastructure issues 
author author may ip components 
ip versions representations component 
developer test driving author component test driving author ip author may concerned developer ip 
spider guards author ip providing level indirection developer actual component 

documenting test drives spider includes component repository stores components stores links components 
developer component repository interface allows navigate available components select test driving 
developer directly provided copy component interact component test drive harness 
time interacts repository actual copy component registering component repository 
point person registering component access ip spider providing access available 
marketplace marketplace executing code behalf developers 
marketplace needs ensure facilities abused accidentally maliciously developers 
abuse lead financial cost marketplace loss confidence marketplace clients 
spider uses java virtual machine test drive java components java standard development kit comes security manager infrastructure 
infrastructure extended provide custom security executing applications 
test drive engine executes developer instructions responsible setting security 
receives instructions test drive engine creates new instance security manager allows disallows particular actions 
marketplace security manager set permissions trust component test driven potential inherent component abuse 
security manager allow disallow actions network access requests filesystem access requests class loading class access method access exception throwing 
marketplaces may want deny permissions perform actions component access network filesystem 
help malicious attackers breaking marketplace limit interfaces component legitimate developers 
developer manipulate test drive engine security manager manager solely controlled marketplace 
marketplace trust intended security policy followed marketplace bears responsibility put security policy place 
security policy may depend upload components registry 
spider currently allows upload component 
live environment marketplace probably wish review newly registered components available test driving ensure attack marketplace 
documenting test drives spider implements test driving aspects vare architecture discussed chapter 
includes documenting component developer test drives chapter 
spider rcd xte formats discussed chapter 
section discuss spider implements vare extracts stores rcd xte information 
spider web application follows client server model prescribed vare architecture 
spider web server uses variety applications libraries basic component repository test driving functionality developer client side web browser 
discuss subsystems vare architecture identify applications libraries spider support implement subsystems 
concentrate solely test driving reporting aspects vare architecture spider currently support transformation test drive reports specific software visualisations 
area tie software visualisation functionality 
spider follows vare architecture design spider test driving functionality supports software visualisation functionality plugged date 
done visualisation aspect architecture demonstrated section 
shows spider vare structure 
discuss relevant architectural subsystems depth 
component repository interface developer view components registered spider standards compliant web browser 
developers register new components spider 
developer reaches component repository spider supplies dynamically generated html page contains names versions components currently aware 
page contains links developers follow retrieve dynamically generated html page describing component 
wishes register component request component registration page 
static page contains html form submitter uses form enter component binaries uris component name component version 
submitted information sent component repository transformed rcd file 
component specific html page linked repository shows information extracted associated rcd file 
section discusses component binary representations stored component repository 
test drive interface developer test drives components spider standards compliant web browser 
test drive interface combination static html dynamically created html cascading style sheets java applet 
developer enters code form submits form 
developer code sent engine created engine repository 
test drive begins developer browser sent vnc viewer applet 
viewer applet connects designated vnc server running web server 
vnc viewer provides developer access user interfaces component generates executing web server 
test drive completed spider sends developer new dynamically generated html page replacing applet 
page briefly results statement submitted code 

documenting test drives spider architecture vare 
spider implement visualisation functionality implement web test driving functionality 
shows key parts spider implementation support developer test drive reusable component marketplace 
chapter 
spider session manager multiple users spider concurrently 
users may perform multiple consecutive test drives components particular interest 
web servers help web applications know particular request come means web applications tailor environments individual users 
spider uses java servlet technology built apache tomcat web server 
servlets maintain information lifespan web server maintain information user sessions 
user session series requests come user represents user trying achieve meaningful tasks system sitting 
session identification information encoded web pages returned users subsequently interact stored special files client side 
component repository spider contains basic component repository 
developers register new components repository list current contents 
repository contains component compiled representation link 
repository contains rcd file component 
rcd file created registration 
spider attempt provide sophisticated indexing querying functionality accessing repository 
repository contains flat file database links rcd files associated xte files 
spider component repository effectively contains elements servlet rcd generator directory structure 
repository servlet repository servlet handles access component information stored filesystem 
servlets return dynamically generated lists components return dynamically generated page component 
servlet receive information submitted component add component repository 
servlet uses discussed generate rcd file newly registered component 
new component registered repository spider downloads copy class files archive files 
spider passes files tool developed called 
responsible parsing files creating single rcd file component 
understands java classfile formats 
creates model type stored extracts information model populate rcd document 
benefit approach simply reflection api information class file available reflection api 
java class file include component interface component implementation 

documenting test drives reflection api provides developer runtime access type interface list operations fields type dynamically create objects type invoke operations objects access objects state 
reflection api allows execute components reflection api extra functionality help gain extra compile time information 
access class interface bytecode class interacts classes 
executing code reflection api added benefit able look implementation spot potential dependencies 
dependencies listed component additional documentation may useful developers 
generated rcd file stored repository filesystem 
directory structure spider currently contains tier directory structure components registered system 
component stored directory turn stored repository root directory 
component directory named component full name version number 
component directory contains rcd file component link component compiled form compiled form 
component repository stores relevant information regarding component 
compiled form component collection class files 
class files may separate packaged jar files 
links components represented uris stored plain text file directory 
example relevant information linked xte test drive reports generated component 
component repository maintains file component contains names relevant xte files stored test drive repository 
registered components test driven extract information specific test drive report specific component confident information typically extracted step extracted component investigation 
developer include link accessible copy component compiled class files register new component 
link list uris identifying java class files java archive files 
component set developer tell spider interested particular component 
done name version location component executable stored session information 
session information kept session manager 
developer decides wish test drive components interested information tell engine java classes load developer refers particular types name 
chapter 
spider engine repository engine repository simply instantiates java test driving engine notified new test drive required 
spider currently supports test driving java components 
engine repository coded additional engines added 
registering engine implementation engine repository requires providing location name engine binary 
registered language language version engine 
spider currently defaults java engine coded components tried executable java virtual machine 
engine spider able dynamically invoke operations listed developer test drive 
time spider able monitor component execution inside java virtual machine 
java engine uses reflection api dynamically invoke operations 
engine maintains set objects values created modified earlier operations test drive 
engine interprets operation uses set objects values execute operation 
changes operation causes set object values recorded 
java engine uses java debugger interface jdi monitor test drive environment 
sun microsystems published jdi api part java platform debugger architecture jpda 
jpda jdi enables developers listen events virtual machine interrogate virtual machine runtime state 
jdi detect variety events execution class loading method calls returns field access modifications exceptions breakpoint triggers virtual machine shutting 
jdi extract information state virtual machine events occur 
allows spider collect information needed test drive reports relying developer annotating component source code 
schmidt technique tool visualising sequential java applications educational purposes 
test driving done clean secure environment possible 
reason spider perform developer test drives virtual machine responding requests developers 
spider creates new virtual machines vnc server engine 
communicate developer network 
approach number benefits associated cost 
provide overview different roles engine discussing benefits cost 
different environments virtual machines correspond main entities engine test drive harness monitor 

documenting test drives test drive harness test drive harness receives developer instructions executes instructions 
instructions sent plain text network socket requirement web server talking java virtual machine instructions sent 
virtual machines started ordinary applications arguments passed configure appropriately 
language runtime environment started web server long runtime environment understood content plain text instructions 
modifying name application web server starts presumably triggered component implementation language languages easily supported spider 
monitor monitor uses debugger technology link test drive environment 
monitor register events interest method calls method returns field accesses field returns exceptions detect events occur 
monitor detected event interest uses information event notification interrogate test drive runtime state 
information gathered written test drive report storage test drive repository 
monitor receives event notifications extracts information test drive harness builds xte file sent test drive repository 
creation virtual machines part required jdi technology implement monitor 
earlier prototypes see section native code java virtual machine debugger interface 
code run virtual machine code monitored 
concerns portability dictated move java jdi 
jdi code run virtual machine code monitored 
jdi code access monitored virtual machine extract information informed events 
vnc server spider needs show component graphical user interface developer 
component executing server developer client spider needs arrange special access developer server side displays 
chapter mention virtual network computing vnc possible solution problem letting developer see component user interface web browser 
vnc allows client view display running remote server 
spider starts test drive harness virtual machine display attached vnc server 
display seen developer web browser freely available vnc viewer applet 
vnc viewer applet passed back developer webpage viewer applet informed display id developer provided username password access display test drive 
benefits core benefit executing test drives different virtual machine web server reduces risk rogue test drive crash web server 
reduces negative impact user community 
operating systems limit amount resources cpu threads process consume 
chapter 
spider feature test drive accidentally maliciously consuming resources server effectively causing denial service attack 
stated benefit separation extend separating test drive harness virtual machine monitor virtual machine 
monitor virtual machine suspends execution test drive harness virtual machine notified event monitor extracting information 
monitor crash handling event extracting information possibility test drive harness virtual machine resume 
benefit virtual machine classpath 
classpath list directories archives virtual machine searches class implementations 
classpath set automatically point specific components developer expressed interest 
useful situations repository contains multiple versions component 
different versions component typically share fully qualified class names single virtual machine able load version causing naming conflict 
version normally loaded version encountered class search path 
virtual machine classpath contain versions components registered repository support multiple developers multiple interests developers see wrong version component 
problem developer gaining access component single execution environment step test driving model 
problem solved developer having execution environments 
developer decides test drive component system provide new virtual machine classpath contains selected component version 
virtual machine know component versions naming conflict 
cost cost approach virtual machines consume resources server 
virtual machine may able directly affect virtual machine large collection virtual machines overload computer cpu 
low machine deal small number users major difficulties 
approach undertaken major component market concurrent users cost initialising closing virtual machines may impact heavily server performance 
cost driven demand component evaluations subsequent component pay necessary upgrades marketplace resources 
cost applies creating vnc displays 
vnc displays shared users reason virtual machines shared 
chance cross contamination high lead confusing erroneous results due clashes concurrent test drives 
test drive report spider monitor writes execution traces xte format discussed chapter 
java engine uses jdi library extract information uses document object model dom organise extracted information 

documenting test drives developing spider technologies raised issues needed addressed 
method return values majority information interested accessible jdi 
useful item information missing return values methods method exit events 
useful information support xte format document return values 
solution problem system annotate compiled class files return values passed particular method just return normally execute 
system detect invocations particular method store value passed integration subsequent method return event 
experience extracting rcd information java class file format helped understanding modify bytecode include new method calls 
system automatically annotate class file registered belonging component 
developer author need know support action 
handling issue affects author intellectual property outside scope prototype 
worth noting aspect contribution identify areas existing debugger technologies meet information needs 
information wish extract test drive reports similar required people debugging software 
suggests debugger technology able provide information request technology meeting entire needs primary audience people finding removing software faults 
execution trace sizes non trivial execution traces huge 
improved pal separating rcd information xte information reduce amount static information copied test drives component 
xte information consume lot storage space 
initially primary memory store execution traces constructed test drive 
proved problematic constructing test drive reports exceed local memory limitations 
certain information needed accessed construction 
events refer objects created earlier necessary store object information primary memory correct object ids event quickly determined 
events explicitly refer earlier events events need reordered detection 
events written filesystem fly object information written test drive 
reflected xte dtd xte object elements appearing xte execution element contains events 
initial dtd element groups organised way 
test drive repository spider stores xte files directory filesystem 
xte file documents single test drive possible developer may component particular test drive 
ensure associated components chapter 
spider link test drive report xte files kept directory referenced flat file db stored component repository 
evolution spider close chapter discussing spider evolution earlier test driving prototypes 
significant prototypes dyno 
recap dyno supports test driving activity discuss usability study performed tool 
dyno prototype tool developed msc thesis usability study undertaken part phd thesis 
discuss dyno client side java class test driving evolved spider server side java component test driving 
intermediary prototype developed dyno spider 
implementation web server protocol service test drive requests web clients provide corresponding test drive documentation 
translated urls contained messages service requests sent back html display standards compliant browsers 
web technologies java servlets removed need implement entire web server prototype way spider 
development prototype prompt initial vare architecture means identifying designing required parts web server 
dyno spider evolved dyno 
dyno client side test drive visualisation prototype focussed individual java classes larger java components 
developers test drive java classes objects information captured fed specified visualisation templates 
resulting visualisations viewed live stored playback 
name dyno derived term 
test bench tool defined oxford english dictionary name instruments various kinds measuring amount energy expended motor engine action mechanical force common example harness car placed 
harness contains monitoring equipment attached car measure various aspects car car engine engaged 
supports simulation driving car analysis car performance 
briefly discussed section 
capabilities developers dyno explore class api invoke operations objects access state objects 
developers map categories execution events method class invoked field modified elements events visualisation 
visualisation templates written java classes events test drive mapped operations specified visualisation templates 

evolution spider mapping occurs point test driving difficult re visualise old test drives new ways 
line arguments earlier chapters spider separates test drive reports visualisations new visualisations old test drive reports fact 
classes loaded independently archived jar files 
developer needs access compiled form dyno load 
loaded class main organisation unit explicit concept component comprised multiple classes multiple packages 
spider adds concept component unit organisation moves execution developer side marketplace 
developer interaction developers run dyno systems test drive visualise java classes 
developers import classes dyno execute methods map execution traces visualisation templates 
developer view resulting visualisations reading execution traces filesystem directly connecting viewer dyno test drive place 
dyno main interface contains component browser stores classes imported objects created 
main interface contains tables showing methods fields class object developer selected browser 
seen 
browser organises classes tree hierarchy 
objects leaf nodes type parent 
developer clicks method method executed 
developer asked parameter values literal values variables created earlier 
developer clicks field field shown detail developer may choose change value 
example method execution shown 
method executed field accessed dyno detects events occurred runtime environment useful information events 
developer wishes map event information particular visualisation developer needs select visualisation test drive classes 
mapping process involves specifying events runtime environment trigger predefined animations user supplied visualisation template 
write template java templates uses triggers execution trace determine awt swing code execute 
example developer may want show test drive stack data structure visualisation stack 
visualisation template may methods pop object push object data 
method encode animation awt swing libraries 
stack class may equivalent methods object void object data 
developer dyno interface link remove invocations pop animation visualisation invocations push animation 
resulting execution traces immediately converted visualisations stored file visualisation dependent form sent live stream connected viewer 
shows example live stream tree data structure visualisation 
chapter 
spider developer browser uses filesystem tree interface display classes imported equivalent folders objects created equivalent files 
inheritance hierarchy represented multiple levels folders 
developer selects class left side browser tables right interface show static methods fields class 
developer selects object browser tables show instance methods fields object 
methods fields identified class declared 
developer select instance method object static method class 
method selected developer dialog box asking parameter values method 
method execute parameter values confirmed 

evolution spider developer view different visualisations test drives 
visualisation tree representation display effects test drive monitored tree data structure 
visualisation created live stream sent test drive tool file test drive tool written 
usability evaluation dyno performed usability evaluation dyno part early phd research 
evaluation involved observing mixture computer science postgraduate students information technology services employees 
evaluation subjects performed test drives variety java classes small java components asked think aloud worked 
subjects familiar dyno told dyno 
dyno interface test driving java class shown 
subjects agreed main usability complaints 
complaints identified issues regarding method ordering parameter passing information overload 
briefly discuss issues 
section discuss spider evolved consideration issues 
method 
subjects difficulty deciding order execute methods 
subjects method signatures insufficient judge dependencies methods documentation required 
difficulty parameters 
subjects difficulty correctly understanding method parameters 
subjects provided parameter type class compiled debugging flags turned provided parameter name 
insufficient understand pre conditions value sent parameter 
chapter 
spider subjects able experiment different values sure look appropriate side effects 
information overload subjects identified third issue expected problem 
subjects frequently overwhelmed amount information available 
large classes java awt methods 
large classes may inherit methods inheritance hierarchy 
methods grouped class defined 
list started group methods defined current class 
list proceeded methods superclass starting bottom inheritance tree working root 
methods group ordered alphabetically 
worked occasions relied subject knowing probable name desired method 
long lists methods predominately text representation difficult read 
dyno spider dyno prototype supports test driving reusable classes developer environment creates visualisation dependent test drive reports 
spider prototype supports test driving reusable components marketplace creates visualisation independent test drive reports 
usability study performed dyno identified possible improvements common problems 
improvements mentioned explicitly subjects improvements problems encountered 
problems problems lack integration tools uncertainty happen 
subjects frequently stated ability test drive useful needed better integration existing approaches understanding component documentation 
primarily java components accepted standard java documentation html javadoc format 
subjects uncertain side effects results particular action 
uncertainty caused lack prior experience component problem information overload 
dyno required subject execute test drive machine specify mapping test drive visualisation test drive executed 
means dyno requires developers trust component won compromise system test drive reports visualisation specific 
improvements saw improvements move dyno spider 
result trust issue resolved move test driving prototype client side server side 
server side tools existed web 
evolution spider component marketplaces component documentation 
therefor resolved server side test driving accessible web 
result uncertainty issue resolved test drive reports documented visualisation independent manner 
mean different visualisations chosen fact 
ability arbitrarily change mapping execution visualisation reduce need developers guess interesting component advance 
secondary result uncertainty issue resolved create xml format component compile time information 
support different visualisations component api interface aim finding representations hide useful features information overload 
spider evolved dyno response perceived need improvements 
chapter 
spider chapter chapter summarise thesis 
thesis contains main contributions review contributions turn 
place contributions context related chapter briefly review test drive reports fit published software visualisation taxonomy 
close look directions research go 
contributions thesis contributions 
contributions test driving model analysing marketplace test driving developing architectures support marketplace test driving 
test driving model contribution thesis conceptual model developers test drive reusable software components 
test driving model chapter contains twelve steps see section developer follows explore behaviour component 
developer gains access component analyses interfaces writes test harness communicate components interfaces particular manner executes observes behaviour component test harness combination 
model describes developers key objectives step shows earlier steps support steps 
model identify trust cost availability issues deter developer considering component reuse viable option 
issues discussed chapter 
section model highlight test driving differs traditional software testing 
observation shows sufficient simply provide software testing environments developers considering component reuse 
active exploration reusable components needs considered separately supported different ways 
marketplace test driving second contribution thesis shifting test driving developers systems software component marketplace 
argue developer access marketplace test driving web browser web browsers ubiquitous developers chapter 
systems 
section analyse marketplace test driving addresses original issues trust cost availability 
section analyse marketplace test driving raises new issues trust accessibility environmental differences 
marketplace test driving removes need developers download components prior evaluation protecting developer accidental damage author ip 
marketplace test driving removes need install configure components removing cost developer pay 
marketplace test driving allows earlier test drives retained repository provided developers documentation assist understanding component 
marketplace test driving affects different groups developers authors marketplaces 
identify areas groups need supported test driving useful method evaluating reusable components 
chapter introduces proof concept tool called spider 
spider demonstrate solutions issues trust accessibility 
spider provides capability test drive reusable components simulated marketplace extract useful information component structure behaviour 
architecture marketplace test driving third contribution thesis software architecture support marketplace test driving 
developed visualisation architecture reuse vare show test driving reporting functionality tied repository marketplace 
vare links subsystems support test driving components marketplace support extraction storage visualisation resulting structural behavioural information 
structural behavioural information stored visualisation independent format different software visualisations created test drive fact 
support storage information vare created xml formats 
reusable component description rcd format stores structural compile time information meta data supplied person registers component repository 
xml trace execution format xte stores behavioural run time information extracted developer test drive 
xte document contains information test drive refers component information stored test driven component rcd file 
comparison related section describe contributions turn build compare related discussed chapter 
test driving model component reuse models typically focus entire reuse activity formal specification solutions match developer requirements component capabilities 
focus entirely part reuse activity component evaluation active exploration approach mathematical approach 
differentiate model areas scope developer control 

comparison related scope existing models reuse activity focus entire activity initial search final integration 
example includes evaluation phase uses formalised criteria analysis describing developer actively explores component 
take high level view component development lifecycle model aimed project managers developing component strategy project 
describe high level view reuse activity evaluation built selection process 
complements works describing old evaluation technique new light 
storey discuss constructing mental models understanding applications 
model complements approach describing developers achieve goaldirected hypothesis driven exploration briefly mention cognitive design element 
alves describe model finding evaluating integrating commercial shelf applications cots 
cots applications reuse component reuse overlap similar 
test driving model describes developer create code manipulate component behaviour 
approach necessarily applicable cases cots application reuse interaction solely driven users code integrated system 
describes goal driven approach component comprehension 
mention component comprehension analysing execution extends describing developer achieve 
exist component development environments component reuse models 
developers component development environments wren search components perform automated tests integrate components 
developers easily explore behaviour single component tools manually 
model describes developers write code test component response certain stimuli 
typically existing integration tools assume rest target application target application component need integrated 
tools provide developers component interfaces interfaces viewed 
interfaces invoked components 
component evaluation done variety reasons deciding reuse component traditional software testing 
section discuss test driving differs traditional software testing 
particular discuss test driving differs category traditional software testing unit testing 
unit tests precede test new development system test drives evaluate existing code inclusion system 
beck unit tests ensure component correct respect specification 
test drives explore potential uses resulting behaviours 
causes differences tests grouped information shared tests target tests 
developer control tools models focus reuse information stored queried extracted repository 
examples include prieto swanson peel tool 
approaches tend take mathematical formal chapter 
specification developers issuing questions specially provided query languages indexed categorised components 
research complements contradicts earlier research 
earlier works developer ability access manipulate static component information author included component registered 
developer control access manipulate dynamic information encoded component runtime behaviour 
research differs earlier models tools 
researchers concentrated modelling dynamic static information methods state machines set theories 
examples sitaraman 
aim provide developers ability actively explore components providing solely tool analysis component 
models assume tools automatically generate test harnesses parsing component 
approaches provide developer opportunity actively play component 
developer automatically extracted documentation tool interpretation component 
propose automated test program generation tool uses closed class specifications test cases input 
approach allows flexibility developer explore component different reuse opportunities identifying component reused extension modification 
approach provides developer opportunity evaluate learn experience checking correctness component original specification 
research differs existing component reuse models describe developers actively explore component evaluation phase 
korel works automated test case generations 
approach rely computer able understand component interface developer able abstractly specify needs 
developer investigate component interfaces check interpretation correct 
approach assumes filtering mechanism limit number components actively test driven korel factor approach 
approach filter components behaviour incompatible developers goals 
querying classification methods filter basis information known repository 
test driving method filter basis information known repository stored component 
podgurski pierce advocate behaviour sampling 
test driving differs behaviour sampling test driving provides developer opportunity investigate component interpret component interfaces 
test driving require developer specify interface retrieved components match 
model developer immediately gets involved components learns 
comes cost requiring additional search time effort 
allows human interpretation shown requiring automated tool properly recognise reuse possibilities 
existing research looks component examples provide developers information component 
discuss developers actively play components learn 
research looks developers leverage 
comparison related existing component uses 
argue approach provides developer access afforded earlier research control expand access situation deems fit 
marketplace test driving component markets component source extreme component existed number years 
researchers investigated developers currently existing markets simulated markets 
research builds 
hong lerch explore simulated market determine consumer behaviour affected components organised 
build giving consumer control components explored 
raise issues component markets need address increase audiences 
identify issues making easy consumers access component value protection intellectual property emphasis black box reuse access source code 
addressed issues chapter address third issue extract test drive reports chapter 
ravichandran discuss different reuse strategies black box reuse vs white box reuse context component markers assist developers 
identify licensing issues confidence component suitability important drivers successful component markets 
boundaries component evaluation phase address issues advocacy marketplace test driving 
research component markets research web case tools 
research differs existing research discuss developers actively play explore reusable components 
differentiate research areas accessed developer exhibits control 
accessing components vs accessing applications web software comprehension tools exist studying entire applications 
tools understand programs debug programs 
demonstrated tools punch 
demonstrated tools net dbx delta debugging 
approach differs target tool component entire application 
means primary interface different 
application target application user interface primary means controlling behaviour 
component target component api primary means invoking behaviour 
case component target user interface secondary consequence accessing api 
web debugging tools developer may control statement statement execution accessing component strictly api 
marketplace test driving developer control component largely mechanisms component api interacting component code 
web environments teaching students code 
emphasis helping developers understand specific components helping developers understand languages methodologies paradigms 
chapter 
field reverse engineering explored web case tool support 
supports authorised uses uploading code central web accessible repository reverse engineering 
developers analyse browse code developer drive execution code analyses static information 
static information extracted compiling code monitoring compilation phase 
includes integrating dynamic analysis runtime behaviour contribution discuss achieved issues involved 
developer control research targets marketplace appropriate place perform evaluations 
reuse tools interact marketplace web repository support developer experimenting components repository 
component deployment test cdt framework 
test cases controlled specifications created hand testing process involves mapping notions service component offer actual component interfaces implementations 
approach differs developers direct access actual component interfaces implementation marketplace 
direct access interfaces allow expressive input wider variety different component interfaces guis filesystem network may able easily encoded specification language 
concentrate separating test case specification component implementation test case specifications reused 
approach provides developers hands experience working components expense ability reuse experience components 
cdt support creation behavioural documentation component 
cdt creates test documentation re executed developers systems 
approach creates visualised test drive reports require re execution developer tries access 
tools codefinder codebroker automatically search repositories viable components 
component selection automatically querying repository database active user exploration 
concentrates analysing developer client side programming inferred facts generate queries repository 
describe architecture supporting component retrieval ontologies 
concentrate considering selected components explicit manipulation repository 
architecture marketplace test driving discussed demonstrated architecture supporting data formats marketplace test driving 
tools implementing architecture fit research area program comprehension 
differentiate research research area program comprehension ways developer exploring flexibility presenting re presenting test drive reports 

comparison related exploration existing program comprehension systems bloom typically aimed coders need debug maintain entire applications 
research differs aim developers interested understanding single component 
approach requires architecture contains extra features combine documentation active exploration developer perspective 
extra features extend architecture required solely combine documentation user manipulation system inspection 
information formats build existing execution formats 
moe carr document execution traces large distributed systems components 
system system reiss event performance analysis xml execution trace formats primarily document entire application executions 
formats concentrate component document entire executions 
affects information stored affect information split 
alonso frakes describe architecture visualising reusable software assets 
architecture visualising reports querying component information invoking component behaviour 
similarly orion re web software re engineering environment applied components 
orion re uses forward reverse engineering techniques extract component information knowledge base component 
orion re support developer invoking component behaviour vare approach differs orion re 
flexibility discussed test drive software visualisations look 
useful compare vare existing tools choose represent individual visualisations 
useful compare vare existing tools create visualisations range different visualisations supported 
current software visualisation tools predefined visualisations created executions user providing form mapping basic filtering events interesting uninteresting 
examples include shrimp software world 
tools exist provide visualisations program performance data 
examples include 
visualisations tend predefined trivial add new visualisation templates reuse old performance data new templates 
form supports multiple views executing code manner allows new views added easily 
extracted information sent directly views information extracted distributed standalone applications components 
tools implementing form execute entirely developer machine 
means form easily support creating new visualisations old test drives directly applicable reusable component market 
differentiates vare form 
balsa provides developers multiple concurrent views executing code new views created system 
form balsa creates chapter 
visualisations execution support re visualisation old executions 
tools store execution traces databases new visualisation tools 
execution traces tools tend language specific java programs architecture format language independent object oriented paradigm 
majority current software visualisation tools describe dynamic information standalone applications designed run entirely developer environment 
examples include bloom 
architecture shows software visualisation tied active exploration source server side 
web software visualisations typically static information necessitating different architecture educating students informing developers 
domingue developed 
staged dynamic software visualisations web allowing developers upload entire applications 
architecture differs implicit architecture developers interact components applications extending components inclusion test harnesses 
web software visualisations typically published web initially built client side 
build done useful representations information web leave test drive reports format accessible variety different tools visualisation approaches 
discussion model test driving identify issues need resolved 
shifting test driving marketplace resolves initial issues cost availability trust ip security compromises 
marketplace test driving results new challenges need addressed test driving effective part component reuse 
underpinning chapter issues cost availability accessibility environment differences developer marketplace trust concepts control trusting party compromise system integrity intellectual property rights 
problem encountered attempting mitigate test driving issues different configurations concepts result party time party 
difficult equally benefit parties addressing new test driving techniques marketplace test driving respect trust control 
section identify core difficulties discuss difficulties resolvable 
trust control key insight developers trade needing trust component wanting control test drive marketplaces trade wanting control test drive needing resource test drive 
chapter test driving model assumes developer trusts component component evaluated 
model states developer downloads compo 
discussion nent system exert control invokes component unknown behaviour 
comparison marketplace test driving concept analysed chapter states developer need download trust component test drive performed system developer total control 
chapter model assumes author marketplace trust developer version component evaluated downloaded system author marketplace control 
chapter marketplace test driving removes need components sent developer developer commits adopting component 
marketplace test driving provides marketplace control test driving performed comes cost test drives undertaken potentially large consumer base 
regardless test driving takes place developers marketplaces trust 
marketplace safely provide developers complete access marketplace systems due security resource concerns developer complete control marketplace test driving environment 
test driving takes place marketplace developer trusts marketplace developer need trust component component author prior adoption 
similarly developer trust accuracy marketplace test driving reports 
marketplace resources test drives developer trusts marketplace developer provides marketplace control useful documentation resources describe component behaviour 
reducing shifting costs requirement trust lack complete control test drives costs borne parties reuse process 
proposal analysis marketplace test driving reduce costs 
control costs exchanged developer marketplace trust cost partly reduced partly shifted 
trust marketplace test driving removes need developers trust authors removes need authors trust developers 
trust replaced need developers trust marketplace test driving report mechanism 
marketplace test driving changes marketplace need trust developers intellectual property need trust developers access marketplace systems 
marketplace test driving necessarily reduced amount trust required nature trust changed 
may easier certify trustworthiness independent third party component markets certify trustworthiness large number small component authors 
reduce actual cost mitigating amount trust required developer marketplace 
marketplace frequently host test drives gain necessary experience judge safe safe allow test driving 
subsequent chapter 
development safe test driving environments cost effective marketplace frequently hosts test drives developer test drives infrequently 
control marketplace test driving lack complete control cost paid developer marketplace 
marketplace controls test drive environment mitigate risk trusting developers implementing tested security policies 
developer control accessing manipulating test drive environment results lesser understanding environment configuration 
reduce developer comprehension test drive report context may reduce emphasis developer place reports decision reuse 
exchange marketplace exerting control test drive marketplace provide required computational resources 
resources previously provided developer developer require cost installing browser plug vnc client interact component guis 
developer cost amortized test drives 
resources marketplace provide marketplace test driving differ required developer side test driving 
particular marketplace explicitly help developers interact components executing different systems developers 
significant technical challenge tool support spider see chapter meet challenge 
marketplaces centralised location test drives marketplace resource costs may reduced due economies scale 
close thesis briefly discussing directions research 
usability evaluation developer starting extremely limited knowledge respect component capabilities usage beneficial provide extensive support steps test driving model accessing component analysing interfaces determining test drive input 
tool worth strongly influenced users believe tool supports aspirations 
plan perform usability evaluations spider prototype 
usability evaluations help highlight key interactions developer component assist analysing web interfaces support interactions 
particular interesting analyse developers best specify test drives 
performed conjunction exploring effective techniques presenting complex component apis developer 

summary integration marketplaces spider prototype contains sophisticated indexing traditional querying functionality 
modern marketplaces require features assist filtering massive search space manageable component set 
direction integrate functionality prototyped spider functionality market 
doing explore test drive enabled marketplaces support full reuse activity models mention chapter 
integration existing marketplaces help create large library test drive reports visualisations 
impact library availability developers reuse decision explored 
addressing web issues chapter identifies web issues affect marketplace test driving trust accessibility environmental differences 
provided perfect solutions issues goal providing marketplace test driving standard web interfaces requires research projects 
firstly relative importance issue real developers identified 
secondly limitations test driving technique identified solutions engineered issues developers feel major obstacles inherently limited technique 
summary key contribution thesis model test driving 
purpose test driving help developers understand evaluate reusable components 
model identifies issues artifacts result developers test drive 
existing marketplaces support developers test drive providing downloadable evaluation versions stored components 
addressing issues providing tools handle creation management artifacts lead better support developers reuse process 
identify trust cost availability main issues current technique test driving components developer system 
issue trust equally relevant author developer 
author provide developer part author intellectual property prior developer committing purchase 
developer trust unknown software perform safely confines developer system 
address issues arising test driving model shifting scene test drive execution developer system marketplace system 
resolves issues initially identified raises new issues accessibility environmental differences new take trust 
argued new issues trivial may easy resolve tool support earlier issues 
proof concept demonstrated prototype resolves number accessibility problems identified 
prototype implements significant part vare architecture architecture designed support test driving activity 
vare tools provide functionality combines flexible visualisation developer controlled test drives component repository technology 
vare supports chapter 
marketplace test driving storage test drive reports visualisation independent manner developer control test drive report visualised 
implementing prototype vare architecture provided appreciation technical difficulties arise 
difficulties documented offer foundation research 
closing thesis models analyses supports evaluation technique called test driving 
test driving help developers understand evaluate reusable components 
thesis provides analysis benefits limitations developer side test driving marketplace test driving doing provides justification moving test driving marketplace 
support marketplace test driving thesis provides vare architecture rcd xte xml schemas describes prototype tool called spider 
bibliography report nato software engineering conference 
omar alonso william frakes 
visualization reusable software assets 
proceedings sixth international conference software reuse 
springer verlag berlin heidelberg 
alexandra alvaro daniel dio cardoso garcia antonio luis carlos 
orion re component software reengineering environment 
proceedings th working conference reverse engineering 
alves anthony finkelstein 
challenges cots decision making requirements engineering perspective 
proceedings th international conference software engineering knowledge engineering pages 
acm press 
andrews sudipto ghosh eun man choi 
model understanding software components 
proceedings international conference software maintenance 
ieee 
phillip 
unconscious art software testing 
commun 
acm 
electronic arts 
ea games demo download page 
www com redesign editorial jsp src downloads december 
ronald baecker 
system produce animated representations execution computer programs 
acm sigcse bulletin february 
ball 
concept dynamic analysis 
proceedings th european engineering conference held jointly th acm sigsoft international symposium foundations software engineering pages 
springer verlag 
kent beck 
simple smalltalk testing patterns technical report 
www com htm 
kent beck 
extreme programming explained embrace change 
addison wesley 
bibliography andrea 
framework component deployment testing 
proceedings th international conference software engineering page 
antoine jean marc quel plouzeau damien watkins 
making components contract aware 
ieee computer july 
robert stuart marshall john miller williams 
reuse debuggers visualization reuse 
proceedings symposium software reusability 
robert 
inheritance reusability 
technical report victoria university wellington new zealand 
robert 
modelling reusable adaptable software 
proceedings adaptable adaptive software workshop oopsla 
benjamin bloom editor 
taxonomy educational objectives handbook cognitive domain volume 
longman green 
christopher frances michael jessica lambert ross 
tying creating self contained animated interactive web resources computer science education 
proceedings thirtieth sigcse technical symposium computer science education pages 
acm press 
david ruth cohen david walker editors 
experience learning 
open university press 
marc brown marc najork 
collaborative active textbooks web algorithm animation system electronic classroom 
proceedings ieee symposium visual languages 
marc brown robert sedgewick 
system algorithm animation 
proceedings th annual conference computer graphics interactive techniques pages 
acm press 
william brown raphael hays skip mccormick iii thomas 
refactoring software architectures projects crisis 
wiley 
bernd allen 
object oriented software engineering uml patterns java 
pearson prenticehall 
jim buckley chris 
taxonomy framework assessing programmers knowledge software systems 
proceedings th ieee international workshop program comprehension iwpc 
stuart charters claire knight nigel thomas malcolm munro 
visualisation informed decision making code components 
proceedings th international conference software engineering knowledge engineering pages 
acm press 
bibliography siddhartha chatterjee william 
architecture web accessible simulation environment 
ieee computer 
andrea chavez catherine gio wiederhold 
software component licensing primer 
ieee software 
hao chen shi ying jin liu wei wang 
se sc specific search engine software components 
proceedings fourth international conference computer information technology 
guy 
live learn psychology growth change everyday life 
milton keynes philadelphia open university press 
aosd steering committee 
aspect oriented software development community conference 
aosd net february 
extreme component 
extreme component website 
www com 
extreme component 
jcalendar 
www com docs calendar html may 

software ip works 
edition 
www 
com november 
microsoft 
com component object model technologies 
www 
microsoft com com january 
microsoft 
microsoft net homepage 
www microsoft com net february 
michael dennis freeze martin griss 
hypertext selecting reusable software components 
proceedings third annual acm conference hypertext pages 
acm press 

website 
www com november 
damiani 
hierarchy aware approach faceted classification objected oriented components 
acm trans 
softw 
eng 
methodol 
drew dean edward felten dan wallach 
java security hotjava netscape 
proceedings ieee symposium security privacy 
devanbu 
ultimate reuse nightmare honey got wrong dll 
th symposium sofware pages may 
mackworth 
system animating lisp programs 
computer graphics image processing 
pg 
john domingue paul 
staging software visualizations web 
proceedings vl 
bibliography john david palmer 
learning complex behavior 
boston allyn bacon 
matthew robert 
evaluating scalable vector graphics software visualisation 
master thesis school mathematics computer science victoria university wellington new zealand 
jan van 
reuse dimensions 
proceedings symposium software reusability pages 
acm press 
roger ebert 
review 
com apps 
dll article aid 
guy 
com evolution component services 
ieee computer july 

multi agent system infrastructure software component market place ontological perspective 
sigmod rec 

classification framework business components 
proceedings rd annual hawaii international conference system sciences 
peter richard richard white editors 
content science 
press 
free software foundation 
free software foundation website 
www gnu org february 
apache software foundation 
apache jakarta tomcat project 
jakarta apache org tomcat index html february 
apache software foundation 
apache xml project 
xml apache 
org february 
eclipse foundation 
eclipse org website 
www eclipse org february 
william frakes thomas pole 
empirical study representation methods reusable software components 
ieee transactions software engineering august 
erich gamma richard helm ralph johnson john vlissides 
design patterns elements reusable object oriented software 
addison wesley 
mitra 
understanding frameworks exploration exemplars 
international workshop computer aided software engineering pages 
allen gardner gardner 
structure learning sign stimuli sign language 
mahwah erlbaum associates 
bibliography david 
reflections dimensions trust trustworthiness online consumers 
database 
robert glass 
software crisis 
ieee computer april 
robert glass 
reuse wrong picture 
ieee software march april 
globus sam 
evaluation visualization software 
computer graphics 
gnu 
gnu website 
www gnu org directory java html may 
object management group 
history corba 
www omg org history corba htm february 
jiang guo 
survey software reuse repositories 
proceedings seventh ieee conference workshop engineering computer systems april 
mark jochen rick bolot 
recognizing supporting roles cscw 
cscw proceedings acm conference computer supported cooperative pages 
acm press 
heiko hahn klaus 
drivers inhibitors development software component industry 
proceedings th euromicro conference 
van der mei 
performance monitoring java applications 
proceedings third international workshop software performance pages 
acm press 
richard helm yo lle maarek 
integrating information retrieval domain specific approaches browsing retrieval object oriented class libraries 
conference proceedings object oriented programming systems languages applications pages 
acm press 
scott henninger 
iterative refinement find reusable software 
ieee software september 
scott henninger 
evolutionary approach constructing effective software reuse repositories 
acm trans 
softw 
eng 
methodol 

rpm package manager 
www rpm org february 
daniel hoffman paul 
tools techniques java api testing 
proceedings australian software engineering conference april 
se hong javier lerch 
laboratory study consumers preferences purchasing behavior regards software components 
database 
bibliography ellis horowitz john munson 
software reusability chapter expansive view reusable software 
acm press frontier series 
michael kevin 
web software engineering process management 
proceedings thirtieth annual hawaii international conference 

case tools 
commun 
acm 
imdb 
attack clones trailers 
www imdb com title tt trailers november 
inoue yokomori fujiwara yamamoto makoto matsushita 
component rank relative significance rank software component search 
proceedings th international conference software engineering 
ivar jacobson martin griss patrik jonsson 
software reuse architecture process organization business success 
addison wesley 
dean jerding john stasko thomas ball 
visualizing interactions program executions 
proceedings th international conference software engineering pages 
acm press 
timothy jones jim welsh 
software visualisation language editor 
proc 
software visualisation pages adelaide australia 
department computer science university 
rebecca 
software reuse motorola 
ieee software 
ahmed juergen 
moose task driven program comprehension environment 
proceedings th annual international computer software applications conference compsac 
kapadia jos fortes mark 
purdue university network computing hubs running unmodified simulation tools www 
acm trans 
model 
comput 
simul 
dan mackay robert james noble 
lightweight web case tool sequence diagrams 
proceedings 
claire knight malcolm munro 
comprehension virtual environment visualisations 
technical report department computer science durham university 
claire knight malcolm munro 
program comprehension experiences gxl comprehension comprehension 
proceedings th international workshop program comprehension iwpc 

case study applying systematic method cots selection 
proceedings th international conference software engineering pages 
ieee computer society 
bibliography victor basili 
defining factors goals criteria reusable component evaluation 
proceedings conference centre advanced studies collaborative research page 
ibm press 
bogdan korel 
black box understanding cots components 
proceedings seventh international workshop program comprehension 
ieee 
oliver horst dreyer 
evaluating usefulness ease web inspection data collection tool 
proceedings fifth international symposium software metrics 
lee kim sang shin 
facilitating reuse software components repository technology 
proceedings tenth asia pacific software engineering conference 
wee cheng khoo yi sun 
automated generation test programs closed specification classes test cases 
proceedings th international conference software engineering pages 
rob jeff margaret anne storey wu 
plugging visualization experiences integrating visualization tool eclipse 
proceedings acm symposium software visualization pages ff 
acm press 
ling liu zhan 
framework specification class testing 
proceedings eighth ieee international conference engineering complex computer 
john long 
software reuse 
sigsoft softw 
eng 
notes 

www com february 
daniel dio antonio francisco eduardo de almeida 
survey software components search retrieval 
proceedings th euromicro conference 
chris er david rosenblum 
wren environment component development 
proceedings th european software engineering conference held jointly th acm sigsoft international symposium foundations software engineering pages 
acm press 
macromedia 
macromedia trial downloads 
www macromedia com index cfm product december 
timothy yih chen emden gansner jeffrey korn 
web portal site reverse engineering 
proceedings eighth working conference reverse engineering 
darko marinov khurshid 
testera novel framework automated testing java programs 
proceedings th international conference automated software engineering 
bibliography stuart marshall 
understanding code reuse 
master thesis school mathematical computing sciences victoria university wellington new zealand 
stuart marshall robert 
help people test drive code 
technical report victoria university wellington 
michael 
extracting software re information visualisation tools 
technical report victoria university wellington october 
bsc report 
mcilroy 
mass produced software components 
report nato software engineering conference pages 

uml visualization debugging environment concurrent java programs pages 
springer verlag berlin heidelberg 
annika wagner 
visualizing synchronization uml 
proceedings ieee international symposium visual languages 
nils meier 
instantj 
directory fsf org java instantj html november 
bertrand meyer 
components 
ieee computer january 
bertrand meyer 
grand challenge trusted components 
proceedings th international conference software engineering pages 
ieee computer society 
bertrand meyer christine 
component development buzz spark 
ieee computer july 
amir 
learning software library user selected examples 
amir david notkin 
illustrating object oriented library reuse example tool approach 
automated software engineering pages 
sun microsystems 
java debugger interface api 
java sun com se 
docs guide jpda jdi july 
sun microsystems 
java tutorial applets 
java sun com docs books tutorial html december 
sun microsystems 
java overview 
java sun com products overview html december 
sun microsystems 
javadoc website 
java sun com se javadoc january 
microsystems 
javabeans 
java sun com products javabeans january 
bibliography mili estelle ah ki robert godin hamid 
nail faceted controlled vocabulary component classification retrieval 
proceedings symposium software reusability pages 
acm press 
mili mili ali mili 
reusing software issues research directions 
ieee transactions software engineering 
mili ali mili roland 
storing retrieving software components refinement system 
ieee transactions software engineering 
roland andreas heinz dominik 
goal driven combination software comprehension approaches component development 
proceedings symposium software reusability pages 
acm press 
johan moe david carr 
understanding distributed systems execution trace data 
johan moe david carr 
execution trace data improve distributed systems 
software practice experience 
conradi ole henrik schwarz 
empirical study software reuse vs defect density stability 
proceedings th international conference software engineering 
antoine clark thomborson 
framework obfuscated interpretation 
proceedings second workshop australasian information security data mining web intelligence software pages 
australian computer society 
myers 
art software testing 
john wiley sons 
thomas joseph ricardo jim nez peris marta mart nez tarhio 
www delivery mechanism interactive visualization instructional modules report working group visualization 
supplemental proceedings conference integrating technology computer science education working group reports supplemental proceedings pages 
acm press 

net dbx web debugger mpi programs low bandwith lines 
ieee transactions parallel distributed systems september 
robert richard 
unit testing frameworks 
proceedings rd sigcse technical symposium computer science education pages 
acm press 
incorporated object mentor 
junit 
www junit org january 
bibliography rainer thomas schmitt 
automatic program visualization object sequence diagrams java debug interface chapter pages 
springer verlag heidelberg 
alessandro james jones mary jean harrold 
visualization data deployed software 
proceedings acm symposium software visualization pages ff 
acm press 
sven peter thomas 
business perspective component trading criteria critical success factors 
proceedings th eu conference 
flores 
vel zquez 
web education learning experience chapter 
hershey pa information science pub 
park kapadia renato figueiredo rudolf eigenmann jos fortes 
integrated web executable parallel programming tool environment 
proceedings acm ieee conference supercomputing cdrom page 
ieee computer society 
andrew patterson michael lling john rosenberg 
introducing unit testing 
proceedings th annual conference innovation technology computer science education pages 
acm press 
paul david evans 
net security lessons learned missed java 
proceedings th annual computer security applications conference 
wim de pauw doug john vlissides 
modeling object oriented program execution 
lecture notes computer science 
wim de pauw nick mitchell martin gary srinivasan 
drive analysis running programs 
ibm watson research center 
petre blackwell green 
cognitive questions software visualisation 
martin johann harald gall 
analyzing understanding architectural characteristics com components 
proceedings th ieee international workshop program comprehension iwpc 
martin johann thomas 
run time data program comprehension 
proceedings th ieee international workshop program comprehension iwpc 
andy podgurski lynn pierce 
retrieving reusable software sampling behavior 
acm trans 
softw 
eng 
methodol 
jeffrey joseph hancock 
business case software reuse 
ibm systems journal 
oxford university press 
oxford english dictionary 
dictionary oed 
com january 
bibliography price small baecker 
taxonomy software visualisation 
proceedings fifth hawaii international conference system sciences january 
rub prieto az 
implementing faceted classification software reuse 
commun 
acm 
ramachandran 
testing reusable software components object specification 
software engineering notes march 
ravichandran marcus 
software reuse strategies component markets 
commun 
acm 
steven reiss 
program development system supports multiple views march 
steven reiss 
overview bloom 
proceedings acm sigplan sigsoft workshop program analysis software tools engineering pages 
acm press 
steven reiss 
event performance analysis 
proceedings th ieee international workshop program comprehension 
steven reiss 
jive visualizing java action 
proceedings th international conference software engineering 
steven reiss 
visualizing java action 
proceedings acm symposium software visualization pages ff 
acm press 
steven reiss 
generating java trace data 
proceedings acm conference java grande pages 
acm press 
steven reiss 
encoding program executions 
proceedings rd international conference software engineering pages 
ieee computer society 
steven reiss 
exploring program traces 
proceedings workshop new paradigms information visualization manipulation conjunction eighth acm internation conference information knowledge management pages 
acm press 
bongard claude 
development life cycle reuse 
proceedings acm symposium applied computing pages 
acm press 
st phane ducasse 
dynamic information iterative recovery collaborations roles 
technical report iam 
mary beth rosson john carroll 
reuse uses smalltalk programming 
acm trans 
comput hum 
interact 
rubin daniel jr survey web security 
ieee computer september 
bibliography patrick schroeder pat bogdan korel 
generating expected results automated black box testing 
proceedings th ieee international conference automated software engineering 
gary wim de pauw ravi 
information exploration tool performance analysis java programs 
technical report ibm watson research center 
murali sitaraman steven atkinson gregory bruce weide timothy long paolo wayne scott pike joseph hollingsworth 
reasoning software component behavior 
proceedings sixth international conference software reuse 
springer verlag berlin heidelberg 
harry 
program comprehension purpose testing 
proceedings th ieee international workshop program comprehension 
mikhail memon 
obfuscation design intent object oriented applications 
drm proceedings acm workshop digital rights management pages 
acm press 
tim maher 
form framework creating views program executions 
proceedings ieee international conference software maintenance 
component source 
component source website 
www 
com 
joel stasko 
student built algorithm animations learning aids 
proceedings eighth sigcse technical symposium computer science education pages 
acm press 
john stasko kraemer 
methodology building application specific visualizations parallel programs 
technical report graphics visualization usability center college computing georgia institute technology 
andreas 
evaluation java security model 
proceedings th annual computer security applications conference 
john steven chandra bob fleck andy podgurski 
capture replay tool observation testing 
proceedings international symposium software testing analysis pages 
acm press 

storey fracchia ller 
cognitive design elements support construction mental model software exploration 
international workshop program comprehension pages 

storey wong fracchia ller 
integrating visualization techniques effective software exploration 
pages 
alexander 
component evolution versioning state art 
sig soft softw 
eng 
notes 
bibliography giancarlo francesco marco 
taxonomy identifying software component uncertain partial specifications 
proceedings acm symposium applied computing pages 
acm press 
giancarlo luigi paolo 
standardizing reuse software processes 
swanson 
reusable software catalog interface 
proceedings acm symposium applied computing pages 
acm press 
szyperski 
component software object oriented programming 
addison wesley 
clemens szyperski 
component software object oriented programming 
acm press 
clemens szyperski 
invited papers frontiers software practice component technology 
proceedings th international conference software engineering may 
boris bogdan korel bader 
automated black box test generation 
proceedings th annual international computer software applications conference compsac 
christos nicolas gold paul keith bennett 
system comprehension program comprehension 
proceedings th annual international computer software applications conference 
vincent jos van 
software component market internet current status conditions growth 
sigsoft softw 
eng 
notes 
tracz 
program salesman software reuse 
addison wesley 
rob van frank van der linden jeff kramer jeff magee 
component model consumer electronics software 
ieee computer 
bill 
inside java virtual machine 
mcgraw hill osborne media 

risks challenges component software development 
commun 
acm 
maria jain 
design retrieval assembly component software development 
commun 
acm 
von mayrhauser marie vans 
comprehension software maintenance evolution 
ieee computer august 
bibliography robert walker gail murphy bjorn freeman benson wright swanson jeremy 
visualizing dynamic software system information high level models 
proceedings th acm sigplan conference object oriented programming systems languages applications pages 
acm press 
gordon walter stephen marks 
experiential learning change theory design practice 
wiley 
ju wang 
component software engineering 
journal computing small colleges 
elaine weyuker 
testing component software cautionary tale 
ieee software september october 
wikipedia 

en wikipedia org wiki february 

certification software components 
ieee transactions software engineering june 
yao 
semantic approach software reusable component classification retrieval 
proceedings nd annual southeast regional conference pages 
acm press 
ye 
empirical user study active reuse repository system 
international conference software reuse pages 
ye gerhard fischer 
context aware browsing large component repositories 
proceedings th annual international conference automated software engineering ase 
ye gerhard fischer :10.1.1.1.6877
supporting reuse delivering task relevant personalized information 
proceedings th international conference software engineering pages 
acm press 
andreas zeller 
isolating cause effect chains computer programs 
proceedings tenth acm sigsoft symposium foundations software engineering pages 
acm press 
