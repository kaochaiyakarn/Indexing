compact data structures fast queries daniel blandford cmu cs february school computer science carnegie mellon university pittsburgh pa thesis committee guy blelloch chair christos faloutsos danny sleator ian munro waterloo submitted partial fulfillment requirements degree doctor philosophy 
supported part national science foundation part aladdin center www aladdin cmu edu project www cs cmu edu aci ccr ccr 
views contained document author interpreted representing official policies expressed implied national science foundation 
keywords data compression text indexing meshing applications dealing large data structures benefit keeping compressed form 
compression benefits allow representation fit main memory swapping disk improves cache performance allows data fit cache 
data structure useful allows application perform fast queries updates data 
thesis describes compact representations types data structures including variable bit length arrays dictionaries separable graphs ordered sets text indices meshes 
representations support fast queries support fast updates 
structures come strong theoretical results 
structures come experimental results showing compression results 
compressed data structures usually close fast uncompressed counterparts faster due caching effects 
acknowledgments advisor 
thesis committee 
people helped including ann blandford benoit hudson rebecca lambert william tom murphy vii allison 
parents 
vi contents preliminaries terminology 
processor model 
variable length coding 
difference coding 
decoding multiple gamma codes 
rank select 
graph separators 
compact dictionaries variable length keys data 
arrays 
dictionaries 
cardinal trees 
experimentation 
discussion 
compact representations ordered sets 
representation dictionaries 
supported operations 
block structure 
representation 
vii applications 
experimentation 
compact representations graphs 
real world graphs separators 
static representation 
representation 
representation adjacency queries 
implementation 
experimental setup 
experimental results 
separator algorithms 
indexing structures 
static representations 
dynamic representations 
timing summary 
randomized graphs 
algorithms 
discussion 
index compression document reordering 
definitions 
algorithm 
experimentation 
compact representations simplicial meshes dimensions 
standard mesh data structures 
representation edges 
representation vertices 
implementation 
viii experimentation 
discussion 
compact parallel delaunay tetrahedralization 
algorithm 
parallel version 
data structure 
experimentation 

bibliography ix chapter applications dealing large data structures benefit keeping compressed form 
compression benefits allow representation fit main memory swapping disk improves cache performance allows data fit cache 
data structure useful allows application perform fast queries updates data 
considerable previous compact data structures :10.1.1.37.4181:10.1.1.37.6762
previous exclusively theoretical structures complex implement suffer high associated constant factors 
compression techniques previous ad hoc usually specific data structure compressed 
uses unified approach difference coding achieve practical compact representations wide variety structures 
thesis describes compact representations types data structures including variable arrays dictionaries separable graphs ordered sets text indices meshes 
representations support fast queries support fast updates 
structures come strong theoretical results variable bit length dictionaries generalize dynamic dictionaries variablelength bit strings 
ordered set structure supports wider range operations previous compact structures sets 
graph structures represent generalization previous dynamic compact structures known :10.1.1.37.4181:10.1.1.37.6762
structures come experimental results showing compression results 
compact data structures usually close fast uncompressed counterparts faster due caching effects 
data structures united common theme difference coding see section represent data difference previously known data 
example compact graph structure chp arrays sn space bits operations si dictionaries lookup exp max si 
sn tn cardinal trees log ti lookup exp cardinality ordered sets log parent parent child exp delete log si si log sn union intersect block metric graphs separable static adjacent graphs edge separable plus exp delete text indices additional compression original index simplicial meshes shaped exp delete simplicial meshes shaped exp delete table space bounds operations supported data structures 
structures marked space bounds depend locality vertex labeling see section details 
structure represents neighbors vertex difference neighbor label original vertex label 
structures combined relabeling scheme ensures differences encoded small 
relabeling effect shown visually length arrays dictionaries represent general framework creating compressed data structures 
represents improvement structures need built ad hoc 
describe data structures compact meaning number bits constant factor optimal bound 
structures bounds corresponding structures summarized table 
arrays dictionaries chapter 
design compact data structures useful building blocks variable bit length array dictionary structures 
array structure maintains set bit strings numbered 
permitting constant expected amortized constant time update operations 
dictionary structure permits constant time lookup expected constant time map operations keys data variable length bit strings 
case space usage constant factor optimal 
represents generalization dynamic dictionaries variable length bit strings match optimal constant high order term space usage 
variable bit length data structures possible implement wide variety compressed data structures fast queries 
example compressed representation cardinal trees degree vary node described section 
finding parent kth child node takes constant time space usage constant factor optimal 
applications appear thesis 
section presents experimental results dictionary store variable bit length data describing edges tetrahedral mesh see chapter details 
dictionary implemented various types difference codes representing different tradeoffs compression speed 
byte code described section dictionary factor space efficient naive hashtable structure 
small input sizes dictionary factor slower hashtable larger input sizes nearly equivalent speed 
difference due caching effects dictionary fit cache better hashtable 
ordered sets chapter 
important application data compression compact representation ordered sets 
chapter presents compact representation sets integers fixed range 
representation supports wide range operations maintaining data compressed form 
technique modifying existing ordered set data structures balanced trees maintain data compressed form supporting operations time bounds 
example applying technique functional implementation produces compressed data structure supports rapid set union intersection operations 
time required compute union intersection sets optimal log block metric carlsson levcopoulos petersson 
space required set log bits matches information theoretic lower bound 
improvement dynamic compressed set structures munro pagh hashing support fast union intersection 
representations ordered sets useful applications 
particular search engines maintain posting lists describe possible search term set documents containing term 
posting lists represented ordered sets document numbers 
compact functional described provide means maintain posting lists compressed form permitting fast union intersection operations 
section contains experimentation describing performance compressed red black trees stl implementation functional 
largest problem size tested insertion deletion elements 
compressed red black trees took twice long space uncompressed trees 
quality compression better denser sets predicted space bound 
separable graphs chapter 
great deal interest compact representations graphs :10.1.1.37.4181:10.1.1.37.6762
difference coding possible create different compact representations separable graphs 
graph defined separable subgraphs partitioned approximately equally sized parts removing relatively small number vertices 
representations relabeling vertices graph separators shown encoding vertex neighbors difference original vertex 
representation simple static structure edge separators second general structure vertex separators 
third representation representation supporting adding removing edges expected amortized time degree 
variable bit length array structure chapter 
fourth representation dynamic structure supports adding removing edges expected amortized time variable dictionary structure chapter 
static representations bits separable graphs 
dynamic representations bits space bound depends labeling vertices remaining graph updated 
static representations described improvement deo kao lu separators graph compression support queries 
generalization jacobson munro raman chuang support queries compressed planar graphs general case separable graphs :10.1.1.37.6762
dynamic representations describe compressed dynamic graph representations know 
section contains detailed experimentation third representations 
byte code static representation slower standard neighbor array representation uses factor space 
dynamic representation uses factor space linked list representation 
time performance linked list representation strongly dependent locality linked list pointers 
compressed dynamic representation usually faster linked list linked list speed linked list laid order 
text indices chapter 
idea separator reordering chapter applied problem index compression 
gives heuristic technique uses document relabeling reduce space representing posting lists ordered sets described chapter 
posting lists kept compressed difference coding 
difference coding produces best compression data compressed high locality numbers stored lists clustered randomly distributed interval 

fact binary interpolative code moffat designed take advantage locality 
locality produced similar documents close numbering 
reordering technique documents accomplish 
section contains experimentation involving compressing index disks trec database 
reordering algorithm runs matter minutes improves compression quality 
material published previous subject 
authors addressed topic 
contributions discussed section 
reordering neighbors differences reordering neighbors differences compression techniques relabeling step ensure vertex labels graph locality 
decreases cost difference coding edges 
meshes chapter 
difference coding compact representations triangular tetrahedral meshes 
standard mesh representations minimum pointers bytes triangle pointers bytes tetrahedron 
compact representations described little bytes triangle bytes tetrahedron 
important applications meshes limited amount ram available 
chapter describes mesh representations 
storing difference encoded triangles tetrahedra variable bit length dictionary structure described chapter constant expected amortized time insertion deletion simplices 
representation difference coding storing cycle neighbors vertex cycle vertices edge 
representation takes expected time dealing vertex degree compression favorable constant 
know dealing dynamic compressed meshes 
section contains experimentation involving representation compresses cycles 
representation construct delaunay meshes 
representation slower shewchuk triangle code representation slightly faster beta version shewchuk pyramid code 
parallel meshing algorithm chapter 
delaunay meshing algorithm chapter parallelized 
variable bit length dictionary structure modified support locks prevent concurrent access 
experimentation shows resulting algorithm rapidly generate mesh tetrahedra vertices randomly chosen unit cube 
algorithm took seconds processors hp gs smp machine speedup compared performance processor 
data including vertex coordinates mesh connectivity data queue fit memory footprint gb ram 
chapter preliminaries chapter discusses concepts useful document 
terminology thesis dealing graph denote number vertices denote number edges degree vertex written 
loss generality assume vertices degree 
bitstring denote number bits string 
denote dictionary entry mapping key data 
applications key data may tuple 
logarithms base 
processor model assume processor word length bits log total number bits consumed data structure 
assume bit word point memory allocate 
assume processor supports operations including bit shifts multiplication division powers bitwise xor 
theoretical bounds table lookup operations 
table lookup operation lookup table size entries 
entry table contains result operation bitstring corresponding entry 
examples table lookup operations section 
entry contains bits total space lookup table bits 
simulating word size log reduced low order term running constant time 
note possible simulate smaller words larger words constant overhead packing multiple small words larger 
unary binary gamma nibble 











decode gamma loop return int left unary binary gamma nibble codes 
right pseudocode decode gamma algorithm 
variable length coding variable length code represents positive integer variable number bits 
example variable length code unary code represents zeroes followed 
example binary code represents lg bit binary representation examples codes shown 
variable length codes compression useful concatenate large numbers codes storage 
convenient prefix free codes 
prefix free code variable length code exist positive integers code prefix code prefix free codes property codes integers concatenated resulting string unique decoding 
example binary code prefix free code string read concatenation codes concatenation codes single code cetera 
possible convert binary code prefix free code prepending codeword number zeroes equal codeword length minus 
code gamma code 
gamma code wide class prefix free codes see :10.1.1.51.7802
theoretical thesis gamma codes easy describe conceptually easy encode decode 
decoding gamma codes 
lookup table size log possible decode gamma codes time length code parameter 
bitstring concatenation gamma codes algorithm decode gamma finds size code value represents 
step compute location algorithm precomputed lookup defined follows bitstring size gives location contains 
algorithm examines bit chunks finds chunk containing 
algorithm uses table find bit position deduces total bit length gamma code 
algorithm extracts code shifts 
code extracted decoding equivalent reinterpreting binary integer 
algorithm shown 
applications examine values encoded data structures number bits structure 
applications table word size log giving space usage log 
time required decode gamma log 
byte aligned codes 
gamma codes easy describe theory implementation large lookup tables undesirable 
convenient class byte aligned codes 
codes sizes fall byte boundaries making easy manipulate 
codes special bit versions general bit code encodes integers sequence bit blocks 
describe bit version 
block starts continue bit specifies block code 
integer encoded checking equal single block created continue bit binary representation bits 
block created continue bit binary representation mod remaining bits mod implemented bitwise 
block followed code implemented bitwise shift 
bit version code particularly fast encode decode memory accesses byte aligned fewer continue bits 
bit version nibble code bit version code space efficient somewhat slower require bit manipulation encoding decoding 
optimization improve time performance bit code code subtract iteration 
store binary representation mod block followed necessary code space permits faster encoding decoding operations require bit shifts addition subtraction 
refer variant byte code 
performance codes compared detail section 
rest thesis assume variable length codes prefix free codes 
difference coding variable length codes way compactly represent values average small 
applications data represented small values possible represent value difference previously known values 
resulting difference small 
known difference coding 
common form difference coding encoding set integers set 
information theoretic lower bound space needed represent elements possibilities log bits assuming log 
xn integers stored sorted order xi xi 
stored directly remaining values represented difference previous value 
xn xn 
codes concatenated single bitstring storage 
gamma codes require lg bits represent value differences represented gamma codes total space required lg lg xi xi bits 
worst case greatest space usage expression occurs xis equally spaced xi im 
space usage log bits constant factor optimal bound information theory 
fact necessary gamma codes achieve performance code log bits store value suffice 
call code logarithmic code 
example goal encode set values 
subsequent chapters explore applications difference coding 
decoding multiple gamma codes suppose set integers xk difference coded concatenated bitstring section describes quickly access encoded data 
particular consider problem value find greatest xi necessary decode sum gamma codes summing codes total reaches algorithm return value xi bit position gamma code xi xi 
method solving problem decode gamma operation section time 
decode codes total length require decode gamma code length time 
section describe sum gamma fast operation uses powerful table lookup step decode codes total length time 
decode multiple gamma codes sum gamma fast algorithm lookup codes codes defined follows bitstring size sum codes gives sum full gamma codes codes gives bit position full gamma code tables sum gamma fast algorithm decode sum gamma codes 
algorithm encounters gamma code size greater codes evaluates zero applies decode gamma algorithm subroutine 
sum gamma fast sum codes codes decode gamma 
sum return loop return pseudocode sum gamma fast algorithm 
sum gamma fast algorithm decodes bits code lookup steps 
lookup step decodes code second lookup step decodes code 
time needed decode bits sum gamma fast 
algorithm decodes chunks bits sum gamma codes decoded reaches exceeds point algorithm requires array additional tables sum 
give sum bit position respectively maximal number consecutive gamma codes sum algorithm uses separate tables value appropriate tables algorithm computes returns result time 
pseudocode algorithm shown 
remains bound space lookup tables 
lookup tables described stores entries value tables allocated total cost bits 
section applications largest values stored expression low order term running constant time 
rank select quite straightforward store group prefix free codes access time concern 
codes concatenated large bitstring codes prefix free uniquely decoded 
applications necessary access individual codes particular access th code stored time 
problem studied extensively usually called select problem 
bitstring size bits select query returns position th queries resolved select data structure created preprocessing munro algorithm time answer select queries auxiliary data structure bits 
select data structure permits access individual codes follows 
bitstring size equal code begins position 
locations set 
location th code select 
inverse select operation called rank 
bitstring size bits rank returns number occur position jacobson showed rank queries resolved time bit rank data structure 
practice find bit data structures high associated constants regardless need maintain bit bitstring bound auxiliary data structure moot 
experiments generally bit data structures devising 
graph separators class graphs closed subgraph relation 
defined satisfy separator theorem constants graph vertices cut set vertices separates graph components vertices 
thesis particularly interested compression classes graphs nc 
class class planar graphs satisfies separator theorem 
results apply classes example miller demonstrated mesh rd separator size 
define graph separable member class satisfies nc separator theorem 
class graphs bounded density vertex member edges 
lipton rose tarjan prove class graphs satisfies log separator theorem bounded density 
separable graphs bounded density 
type graph separator edge separator 
class graphs satisfies edge separator theorem constants graph vertices set edges removal separates graph components vertices 
edge separators general vertex separators graph edge separator size vertex separator size similar bounds hold converse 
thesis deal edge separators show theoretical results graphs vertex separators 
theoretical purposes assume existence graph separator algorithm returns separator bound 
experimental purposes find metis heuristic graph separator library works 
chapter compact dictionaries variable length keys data dictionary problem maintain element set keys si associated data satellite data ti 
dictionary dynamic supports insertion deletion lookup operation 
interested dynamic dictionaries keys data variable length bitstrings 
main motivation dictionaries building blocks various applications 
example application representation cardinal trees nodes varying cardinality 
applications variable bit array dictionary structure appear sections 
assume machine word length log number bits represent collection 
assume size string si ti bitstrings si ti 
significant involving data structures near optimal space supporting fast access :10.1.1.14.5337
dictionary problem particular studied case fixed length keys 
information theoretic lower bound representing elements universe log log log 
cleary showed achieve bits expected time lookup insertion allowing satellite data 
structure technique quotienting involves storing part key hash bucket part stored reconstructed index bucket containing key 
munro described static structure bits requiring time lookup structure increasing space cost bits 
structure support satellite data 
pagh showed static dictionary bits query time supported satellite data ideas similar cleary structure easily 
raman rao described dynamic dictionary structure bits supports lookup time insertion deletion expected amortized time 
structure allows attaching fixed length bit satellite data elements case space bound chapter guy blelloch 
bits 
considers variable bit keys data 
variable bit dictionary structure store pairs si ti space max si log ti 
note si constant ti zero simplifies 
dictionary supports lookup time insertion deletion expected amortized time 
dictionary simpler structure array structure supports array locations 
lookup update operations 
denote ith element array ai 
case location store bitstring 
data structure uses space ai machine word length 
structure supports lookups worst case time updates expected amortized time 
note bitstrings length trivial 
cardinal trees 
example application representation cardinal trees aka tries node different cardinality 
queries request kth child parent vertex 
attach satellite bitstrings vertex 
updates add delete kth child 
integer labeled tree space bound log log parent cardinality respectively 
appropriate labeling vertices reduces log asymptotically optimal 
generalizes previous results cardinal trees varying cardinality 
match optimal constant order term 
experimentation 
experimental results dictionary structure trace operations performed simplicial meshing algorithm 
analyze structure performance difference codes optimized speed compression 
compare structure naive hashtable hashtable slightly time efficient structure uses factor space 
arrays define variable bit length array structure maintains bitstrings supporting update lookup operations 
update changes bitstrings potentially changing length data 
lookup returns bitstrings user 
array representation supports strings size ai performs lookups time updates expected amortized time 
strings size allocated separately bit pointers stored structure 
memory allocation system capable allocating freeing bits memory time may space keep track allocation 
known 
overview 
overview array structure 
partition strings ai blocks contiguous elements containing average bits data block 
maintain blocks conventional data structure hashtable bits block 
keep auxiliary bit array allows determine block contains element constant time 
keep auxiliary data block allows locate element block constant time 
operations support update constant time 
structure detail 
structure consists parts set blocks index bitstrings array stored blocks 
index allows quickly locate block containing array element 
blocks 
block bi encoding series bitstrings increasing order ai ai ai block stores concatenation strings bi aiai ai information start location string 
suffices store second bitstring contains position bitstring ak ends position bi 
block bi consists pair bi 
define size block bi ai 
maintain strings array blocks size maintain invariant blocks structure adjacent meaning block contains ai contains ai sum sizes greater index structure 
index array structure consists bit array hashtable 
practice optimized space efficient variant hashtable 
array maintained string ai string block bi structure 
case hashtable maps bi 
hashtable bits words block maintained hashtable 
support insertion deletion expected amortized time lookup worst case time 
cuckoo hashing dynamic version perfect hashing scheme properties 
expected worst case lookup bounds acceptable standard implementation chained hashing 
bit select bit rank 
assume processor supports special operations bit select bit rank defined follows 
bitstring length bits bit select returns position ones range 
bit rank returns number ones range 
operations mimic function data structures described section 
processor support operations implement constant time similar table lookup described section 
operations 
observing block contain bitstrings blocks maximum size bitstring contains bit 
position distance nearest direction find nearest left 
compute bit select bit rank 
find nearest right 
compute bit select 
operations take constant time 
access string ak structure searches block bi containing ak 
simply search nearest left structure performs hashtable lookup access target block bi 
block located structure scans index string done bit select 
find location ak 
ak updated block bi rewritten 
bi smaller result update may need merged left neighbor right neighbor 
case takes constant time 
bi large result update ak split blocks 
structure may create new block position position new ak large 
maintain size invariant may necessary join bi block left join rightmost new block block right 
operations blocks take time shifting copying done bits time 
access operations take worst case time updates take expected amortized time 
define total length bitstrings structure ai 
structure contains bits plus bits block blocks total space usage 
gives theorem theorem variable bit length array representation store bitstrings length ai ai bits allowing accesses worst case time updates amortized expected time 
dictionaries variable bit length array structure implement space efficient variable bit length dictionaries 
section describe dictionary structures store set bitstrings sn si log 
handle strings length greater log allocating memory separately storing bit pointer structure 
structures space bits max si log ti 
discuss straightforward implementation chained hashing permits expected query time expected amortized update time 
implementation dynamic version perfect hashing scheme improves query time worst case time 
quotienting 
representing sets fixed length elements space bound known represent elements size bits requires log bits 
method achieve bound quotienting element uniquely hashed bitstrings log bit index hash bucket contains log bits 
contain bits describe add data structure necessary store bucket specified idea quotienting described knuth section exercise contexts 
previous quotienting schemes concerned variable length keys strings produce length properties need 
chapter develop variable bit length quotienting scheme 
scheme need number hash buckets power 
number bits assume hash buckets structure 
number entries grows shrinks resize structure standard doubling halving scheme hashing 
purposes hashing convenient treat bitstrings si integers 
accordingly reinterpret necessary bitstring binary representation number 
distinguish strings different lengths prepend si interpreting number 
denote padded numerical representation si xi 
say family hash functions elements universal random pr pairwise independent random pr domain range 
wish construct hash functions function hash function binary representation xi contain fewer bits binary representation xi 
possible reconstruct xi xi xi 
clarity break xi words containing low order bits xi containing remaining high order bits 
hash functions xi xi div xi mod xi xi xi xi pairwise independent hash function range example xi axi mod mod prime randomly chosen functions inverted straightforward manner xi show family drawn universal follows 
pr pr pr probability zero pairwise independence 
pr note selecting function requires log random bits 
dictionaries 
dictionary data structure hash table consisting variable bit length array hash function insert si ti structure compute bucket insert ti necessary handle possibility multiple strings hash bucket 
handle prepend string ti gamma code described section indicating length 
increases length strings constant factor 
concatenate strings bucket store result appropriate array slot 
concatenation strings bucket size greater allocate memory separately store bit pointer array slot 
gamma code length element read constant time lookup table described section 
length element total size data structure lookup table word size log table size log log allowing time decoding 
takes time decode element bucket reading gamma code length extracting element shifts 
bucket expected size elements hash function universal lookups element accomplished expected time insertions deletions accomplished expected amortized time 
bitstring stored si size max si bitstring ti size ti 
variable bit length array increases space constant factor total space variable dictionary structure max si log ti 
perfect hashing 
variable bit length arrays implement version perfect hashing scheme 
hash functions maps log log maintain variable bit length array buckets store pair ti bucket indicated multiple strings collide bucket total length bits store concatenation strings bucket chained hashing 
length greater bits allocate separate variable bit length array store elements 
bucket contained items new array slots maintain size hash function array described dietzfelbinger 
primary array store bit pointer secondary array bucket 
charge cost pointer bit overhead array hash function cost bits stored bucket 
space bounds structure follow bounds proved structure allocates array slots structure requires bits unused slot 
space requirement structure dominated bits required store elements set 
access elements stored secondary arrays takes worst case constant time 
access elements stored primary array problematic potentially bits stored bucket contain strings meet worst case bound necessary find correct string constant time 
solve problem table lookup similar described section 
table needed range allow searching string gamma codes target code entry contain index index gamma code 
total space log time needed query 
simulating log choosing table usage lower order term running time 
gives theorem theorem variable bit length dictionary representation store bitstrings size bits max si log ti allowing updates amortized expected time accesses worst case time 
cardinal trees cardinal tree aka trie rooted tree node slots children filled 
generalize standard definition cardinal trees allow node different denoted 
node want support returning parent th child 
want support deleting inserting leaf node 
consider operations time bounds hold sequence operations compression achieved depend labeling vertices 
tree changes shape significantly vertices may need relabeled maintain space bounds 
dictionary representation cardinal trees 
vertex store dictionary entry dictionary maps pair 
encode pair values gamma code value concatenate form bitstring 
child store entry 
representation support cardinality queries parent queries child queries 
lemma representation describe supports parent child queries time insertion deletion leaves expected amortized time 
variable bit length dictionary space bits log log 
proof 
space usage variable bit length dictionary structure max log 
type dictionary entry store 
cost storing absorbed log 
cost storing vertex log 
cost storing child cost storing vertex handled log 
second type entry store 
absorbed log 
cost storing vertex log 
cost charged child vertex cost bits charged log 
tree separated set trees size removing single node 
recursively applying separator cardinal tree defines separator tree ts nodes 
integer labeling nodes inorder traversal ts 
call labeling tree separator labeling 
lemma tree separator labelings trees size log log max 
proof 
consider separator tree ts es labeling 
node denote degree 
ts denote subtree ts rooted ts size piece chosen separator 
correspondence edges edges es 
particular consider edge es vertex child corresponds edge ts 
need account log difference log 
ts labels subtree sequentially 
partition edges classes calculate cost edges class 
ts edge log log ts log log max 
second ts charge edge node charged node ts log ts pointer child 
note tree node ts ts cost ts cost 
total charge 
summing classes edges gives log max 
theorem cardinal trees tree separator labeling stored bits log 
proof 
interested edge cost ec log 
substituting lemma gives ec log max lemma gives required bounds 
experimentation log log log understand time space efficiency dictionary structure tested real world application algorithm perform delaunay tetrahedralization described fully chapter 
structure necessary map edges va vb blocks data 
edges inserted deleted data updated 
variant dictionary structure support operations 
tests captured traces updates lookups involved constructing mesh vertices 
traces test variable bit length dictionary structure implemented nibble byte hashtable updates lookups time space time space time space table time seconds space bytes vertex store update data edge tetrahedral delaunay mesh 
coding techniques byte aligned nibble aligned codes described section 
byte aligned code optimized time performance nibble aligned code preferred high compression ratio 
test ran lookups trace byte data larger amount data original application 
compared results standard bucketed hash table 
bucketed hashtable initially faster loses advantage large sizes suspect requires memory fit cache 
results experiments shown table implementation details 
dictionary structure 
data structure represent information modification variable bit length dictionary structure 
edge va vb mapped bucket array buckets 
quotienting save log bits cost storing key described section vb va va store key bucket number base hash function random number table size table 
additionally note meshing algorithm shows considerable locality access frequently performs accesses vertices similar labels 
accordingly restrict hash function smaller range 
effectively partitions buckets array groups size determined 
keep information associated group discussed 
description dictionary structure section specifies buckets elements variable bit length array structure buckets cause space penalty 
length array structure significant constant overhead application keep buckets sufficiently full buckets cause problems 
initially bucket allocated fixed number bytes 
space required bucket allocated additional blocks memory secondary pool blocks required 
byte block stores byte pointer block 
hashing trick see section details 
preserve memory locality secondary pool blocks allocation structures kept separately bucket group 
space cost allocation structure amortized cost buckets group 
original meshing application contains great deal data bucket form vertex lists data item accordingly uses bucket group size 
application uses data bucket amortize allocation structure larger group size 
byte aligned code space efficient time efficient nibble code 
accordingly allocate space dictionary byte aligned code 
experimentation chose allocate bytes bucket initially code allocate additional memory blocks bytes 
allocate secondary blocks bucket expand secondary block pool necessary 
nibble code space efficient byte code dictionary require space 
nibble code initially allocate bytes bucket secondary blocks bucket 
case sizes chosen bucket groups require additional blocks allocated secondary block pool 
hashtable 
compare structure naive hashtable 
key data pair structure uses listnode containing byte word va vb data byte pointer node 
bit architecture rounded nearest word size making bytes 
bit architecture bytes 
bucket uses byte pointer 
variable bit length dictionary structure keep buckets hashtable 
discussion data structures variable bit length array dictionary structure serve useful building blocks structures 
structures strong theoretical bounds lookup amortized expected update operations 
experimentation experimentation chapters shows variants structures useful practice 
practical applications modify structure discussed section 
divide structure groups improve locality access 
variable dictionary structure underlying variable bit length array structure choose settings keep buckets dictionary close full 
memory allocator assign blocks store difference codes 
details implementation dictionary structure chapter 
chapter compact representations ordered sets chapter describe data structure compactly represent ordered set sn si si universe 

data structure supports wide variety operations operate purely functional setting 
purely functional setting data overwritten 
means data fully persistent 
data structure applications especially design search engines 
memory considerations serious concern search engines 
web search engines index billions documents fraction total number pages internet 
space search engine representation inverted index data structure maps search terms lists documents containing terms 
entry posting list inverted index list document numbers documents containing specific term 
query multiple terms entered search engine retrieves corresponding posting lists memory performs set operations combine result reports user 
may desirable maintain documents ordered example ranking pages importance 
difference coding described section lists compressed array bits bits edge representations suited merging lists different sizes 
data structure describe represent posting list search engine 
structure supports dynamic operations including set union intersection maintaining data constant factor information theoretic bound 
operates purely functional setting search engine perform set operations posting lists spending time memory copies sets 
significant research compact representation sets taken informationtheoretic bound shows representing set size requires log log bits 
munro demonstrate structure optimal high order term space usage supports lookup worst case time insert delete expected amortized time 
chapter guy blelloch 
pagh simplifies structure improves space bounds slightly 
structures hashing support ordered access data example support searching precise key searching key greater search key 
pagh structure support operation described section statically allowing insertions deletions 
assume unit cost ram model word size log 
set union intersection problems directly related list merging problem received significant study 
carlsson levcopoulos petersson considered block metric block represents minimum number blocks ordered lists need broken recombined ordered list 
metric show informationtheoretic lower bound log time complexity list merging comparison model 
moffat petersson wormald show list merging problem solved log time structure supports fast split join operations 
split operation ordered set value splits set sets containing values containing values greater join operation sets values value joins set 
operations said fast run log min time 
fact actual list merging algorithm requires split join operations run log time 
chapter representations ordered sets 
section simple representation variable bit length dictionary section 
simple describe support full range operations need posting list data structure 
second representation described section section compression technique improves space efficiency structures ordered sets taken base structure supporting basic operations technique improve structure space bound log bits 
technique allows wide range operations long supported base structure 
section gives experimental results second representation 
show versatility compression technique applied separate data structures red black trees functional 
representation dictionaries describe representation ordered sets variable bit length dictionary section 
represent ordered sets integers range 

addition lookup operations ordered set needs efficiently support queries depend order 
consider finger searching 
key finds min finger key key finds min returns finger 
finger searching takes log time 
represent set red black tree elements 
refer vertices tree value element stored vertex refer size set loss generality assume 
element denote parent left child right child red black flag respectively 
represent tree dictionary containing entries form 
add parent pointers violating space bound case unnecessary 
straightforward traverse tree top bottom standard way 
straightforward implement rotation inserting deleting constant number dictionary elements 
assuming dictionary queries take time implemented log time 
hand data structure finger searching implemented log time additional log space 
membership takes time 
insertion deletion take log expected amortized time 
call data structure dictionary red black tree 
remains show space bound structure 
lemma set integers 
size arranged order red black tree log log 
proof 
consider elements set 
organized set levels 
ll li li li say organization proper level covering set 
consider sum log differences cross pointers level count pointers red black trees pointers 
set 
define min log 
logarithms concave sum maximized elements evenly spaced 
log 
proper level covering set gives li li li log li li log log log represents total log difference summed pointers 
analysis bounds similarly defined previous pointers 
call cross pointers 
account pointer red black tree cross pointers 
partition red black tree levels number black nodes path root node 
gives proper level covering 
node distance children distance previous element level 
account cost left child previous pointer right child pointer 
sum log differences child pointers sum log differences previous cross pointers 
gives desired bound 
theorem set integers 
size represented dictionary red black tree compressed dictionary uses log bits supports find queries log time finger search queries log time insertion deletion log expected amortized time 
proof 
outline recall space compressed dictionary bounded max log 
keys log bits size data stored dictionary bounded lemma 
gives desired bounds 
representation described powerful supports operations allowed red black tree 
easily purely functional 
representation describe support greater range operations 
supported operations ordered set structures support operations search search return greatest element equal greater equal insert return set 
delete return set 
handle finger element perform search search log time 
return greatest element split element return sets plus join sets return weighted rank operation assumes weight provided element inserted 
element operation finds yw 
unweighted variant weights considered 
weighted select operation assumes weight provided element inserted 
operation finds greatest yw returns associated sum 
unweighted variant weights considered 
ordered dictionary structure log bits store values 
blocking technique demonstrate produces ordered set structure log bits 
constant factor information theoretic lower bound 
technique requires target machine word size log 
reasonable log bits required distinguish elements technique lookup table size log parameter 
applications thesis table size entries simulate log choose table size low order term 
assume related 
decode gamma codes size log constant time explicitly count cost log space usage 
data structure works follows 
elements structure difference coded described section stored fixed length blocks size log 
element block kept uncompressed 
blocks kept dictionary structure element key 
data structure needs know actual implementation dictionary 
query consists searching appropriate block dictionary searching block 
provide framework dynamically updating blocks inserts deletes ensure block full empty 
example inserting block overflow block 
requires split new block inserted dictionary 
operations blocks correspond directly operations tree 
table lookup implement block operations efficiently 
structure support wide range operations depending operations dictionary supports 
cases cost operations instructions operations input structure supports search insert operations structure supports operations 
supports supports insert delete finger structure supports operations 
supports split join structure supports operations 
bounds split join log min structure meets bounds despite calls operations 
structure supports rank 
structure supports select 
algorithms need weighted versions number entries block weight 
catenable list structure kaplan tarjan adapted support operations 
time bounds worst case log search insert log defined log min 
structure meets bounds 
example representation simpler dictionary structure supports operations time listed expected case 
purely functional 
third example representation skip list dictionary structure supports operations time bounds expected case purely functional 
encoding block size 
case universe size head encoded bits 
block structure representation consists structures nested form structural bootstrapping 
base structure block 
section describe block structure operations supported blocks 
section describe blocks kept ordered dictionary structure support efficient operations 
block structure dictionary structure combined structure implement operations block structure additional operation dictionary supports weighted versions rank select 
clarity refer operations blocks prefix operations dictionary structure prefix operations combined structure prefix 
block encoding 
block bi encoding series values increasing order vk 
block encoded log bit representation called head followed difference codes section vk vk 
see example 
say size blocksize total length difference codes contained block 
particular interested blocks size log bits 
important time bounds operations blocks fast take time proportional number values block 
table lookup fast decoding described section table word size log parameter 
blocks size log sum gamma fast algorithm section allows access value block log log time 
cost lookup tables gamma fast log bits 
denote maximum possible length difference code 
case gamma codes log bits 
sections assume gamma codes 
define operations blocks 
operations require constant time assuming constant blocks size log 
operations increase size blocks describe section block sizes bounded 
bsearch bsearch value block operations return greatest value equal greater equal application gamma fast routine 
value block operation inserts head algorithm encodes head difference adds code block 
algorithm searches value vj precede gamma code vj vj deleted replaced gamma codes vj vj 
shift operations may needed room new codes 
shift affects log bits requires constant time 
block value vj contained operation deletes vj vj head successor decoded new head algorithm searches vj 
deletes gamma codes vj vj vj vj replaces gamma code vj vj 
part block may need shifted 
insert case requires constant number shifts 
block size bits operation splits new block size searches code starts position second array stored table entry 
decoded head codes placed successors deleted contains bits codes contained bits contains bits 
takes constant time codes copied log bits time 
block operation returns head blast block operation scans returns final value 
block value operation splits new block values greater values chosen search position operation returns join operation takes blocks values greater greatest value concatenates finds greatest value represents head gamma code appends code appends remaining codes takes constant time codes copied log bits time 
support operation gamma fast lookup tables need augmented sum gamma codes chunk table needs contain information number codes decoded 
find rank element block algorithm searches element keeping track number elements chunk skipped 
support operation gamma fast lookup tables need augmented addition information needed chunk needs array containing decoded values 
table needed entries log log bits total log bits alter tables asymptotic space complexity 
find element rank algorithm searches chunk containing element accesses appropriate index array 
representation represent ordered set sn si si approach maintains set blocks bi bi sbi sbi sbi 
values bk maintained size block 
block block permitted smaller 
recall log maximum possible length gamma code 
property maintained operations performed lemma set 
assignment bi bi size bi total space blocks log 
proof 
bounding space gamma codes 
cost gamma code differences pair consecutive elements log si si 
sum maximized values evenly spaced interval point sum log log log 
gamma codes contained blocks subset ones considered head block gamma coded 
log bits head bits gamma codes log amount additional space heads half gamma codes 
blocks bi maintained ordered dictionary structure key block head 
refer operations prefix differentiate operations blocks interface representation 
may log bits store value 
value stored contains log bits increases space bound constant factor 
representation supports operations 
described functional easily change block algorithm delete structure copy modify copy reinsert structure 
search algorithm calls returning greatest block head return return result 
search algorithm calls returning greatest block head return call bsearch produces value return value return head result 
insert algorithm calls returning block contain 
block head algorithm uses find block 
algorithm calls size algorithm calls insert new block 
delete algorithm calls returning block contains target element algorithm calls size algorithm uses delete find predecessor join blocks 
turn may produce block larger size case operation operation needed case 
rare circumstances deleting gamma coded element block may cause grow size bit 
causes block exceed size handled case 
define finger element consist finger block containing algorithm block contains returns result 
algorithm returns result 
algorithm returns result 
join structures algorithm checks size 
size algorithm uses remove predecessor join resulting block oversized 
join resulting block back 
algorithm joins successor similar method 
algorithm join structures 
split element algorithm calls producing structures 
split operation returns block algorithm uses delete head uses join returns 
algorithm calls 
produces additional block block joined 
rank weighted rank block defined number elements contains 
algorithm find block contain returns sum 
select size block defined number elements contains 
algorithm uses find block containing target appropriate offset find target 
lemma ordered universe 
ordered dictionary structure comparison ordered set structure uses log bits store values blocking technique produces structure uses log bits 

blocked set structure supports operations instructions calls operations 
supports blocked set structure supports instructions call 
supports finger union null return null return sb union sb pseudocode operation 
blocked set structure supports operations instructions calls finger 

supports operations blocked set structure supports operations instructions calls operations 
supports operation blocked set structure supports operation instructions call 
supports operation blocked set structure supports select operation instructions call 
proof follows descriptions 
applications combining operations possible implement efficient set union intersection difference algorithms 
example implementation union shown 
split join run log time set operation algorithms run log time possible number blocks break lists list 
block metric carlsson 
described catenable ordered list structure kaplan tarjan modified support operations described worst case time 
split search routine support define finger result structure split support weighted rank select node structure store weight subtree 
representation structure supports operations worst case time log bits 
structure may somewhat unwieldy practice 
expected case worst case bounds acceptable efficient alternative 
support split join operations flipping pointers left spine trees node left spine points parent left child 
split key algorithm travels left spine reaches key greater splits insert times delete times space needed standard blocked standard blocked standard blocked table performance standard implementation versus blocked implementation averaged runs 
time seconds space bytes value 
normal 
seidel aragon showed expected path length traversal log 
copying path traversed purely functional 
experimentation implemented blocking technique red black trees 
gamma code nibble code described section 
decode blocks nibble nibble lookup table described 
large problems table improve performance 
maximum block size bytes minimum size bytes 
byte store number block total bytes block 
combined blocking structure separate tree structures 
purely functional implementation 
priorities generated hash function keys 
node maintains integer key left pointer right pointer total bytes node 
blocked structure node keeps pointer block 
block bytes total space usage bytes node 
second tree structure implementation red black trees provided redhat linux implementation standard template library 
int unsigned char template blocked structure set int template unblocked equivalent 
red black insert times delete times space needed standard blocked standard blocked standard blocked table performance standard red black tree implementation versus blocked red black tree implementation averaged runs 
time seconds space bytes value 
tree node includes key pointers left right parent byte indicating color node 
compiler allocates memory data structures multiples requires total bytes node unblocked implementation bytes blocked implementation 
ran simulations ghz processor gb ram 
tree structures tested time needed insert delete elements 
universe sizes varying numbers elements 
elements chosen uniformly elements set inserted deleted order 
calculated time needed insertion deletion space required implementation computed average runs 
results implementations shown table 
blocked version uses considerably space non blocked version improvement factor depending density set 
slowdown caused blocking varies usually 
fact blocked variant runs faster 
suspect caching memory issues 
results red black tree implementations shown table 
space improvement factor 
slowdown 
note stl red black tree implementation significantly faster implementation 
part structure purely functional persistent 
red black tree structure persistent 
data structure implemented serial merge algorithm described section 
computed time needed merge sets varying sizes universe size results shown union time standard blocked table performance serial merge algorithm implemented standard blocked 
values averaged runs 
universe size time seconds 

slowdown caused blocking 
chapter compact representations graphs interested representing graphs compactly supporting queries updates efficiently 
goal store large graphs core memory standard algorithms requiring random access 
representations applications computation large graphs link graph web telephone call graphs graphs representing large meshes addition medium size graphs devices limited memory map graphs hand held device 
furthermore application limited physical memory compact representations faster standard representations better cache characteristics 
experiments confirm case realworld graphs 
random graphs space saved graph compression quite limited informationtheoretic lower bound representing random graph log number vertices minimum number edges number edges complement 
bound matched difference encoded adjacency lists sparse graphs approach saves small constant factor standard adjacency lists :10.1.1.51.7802
fortunately graphs practice random considerable savings achieved advantage structural properties 
probably common structural property real world graphs small separators 
described section graph small separators subgraphs partitioned approximately equally sized parts removing relatively small number vertices 
expected separator size random graph 
planar graphs separators play important role partitioning dimensional space dimensional triangulated meshes 
fact considerable compressing planar graphs see related 
graphs strictly planar crossings telephone power networks tend small separators 
generally nearly graphs represent connections low dimensional spaces small separators 
example dimensional meshes separators nearest neighbor graphs dimensions 
furthermore graphs pre defined embeddings chapter done guy blelloch ian 
low dimensional spaces small separators 
example link structure web small separators experiments show 
chapter interested compact representations separable graphs described section 
describe possible representations bits supporting constant time degree queries listing neighbors constant time neighbor 
representations support constant time adjacency queries 
assume graphs unlabeled free number vertices 
graph strictly separable component effectively separated representations compress components separable 
computational model random access machine constant time operations log bit words 
take advantage log bit parallelism algorithms 
related 
considerable compressing unlabeled graphs 
turan showed vertex planar graphs compressed bits 
constant front high order term improved keeler westbrook kao lu describe technique optimal order term 
results generalize graph constant genus 
results sub classes planar graphs trees triangulated meshes planar graphs 
dense graphs naor describes representation reduces lower order term required adjacency matrix 
considers implementing fast queries 
jacobson showed planar graphs represented bits permitting adjacency queries log time 
munro raman improved time adjacency queries time :10.1.1.37.6762
chuang improved constant high order term space bound 
techniques representations balanced parentheses 
techniques extend general case graphs small separators 
separators compress graphs considered 
deo showed separators compress graphs bounded genus bits 
kao lu planar graph separators compress planar graphs optimal number bits low order term 
chakrabarti describe experimental approach compressing graphs represented sparse matrices 
techniques support queries 
additional related special case representing link structure web 
case authors taken advantage high degree similarity individual web pages 
authors developed techniques representing outlinks page difference outlinks page 
exploiting similarity allows strong compression boldi vigna get bits link pages counting indexing structure 
compressed nodes mean multiple nodes decompressed query 
clear general separable graphs similarity property exploit 
chakrabarti consider graph compression perspective data mining examining compressed representation graph seek gain insight underlying structure 
graph separator technique described 
structures 
data structures recursively separating graph separators vertices numbering subgraph 
properties small separators edges connect vertices close numbering 
take advantage property encoding edges 
time construct representation depends time needed recursively separate graph aspects take linear time 
polylogarithmic approximation separator size sufficient bounds leighton rao separator gives polynomial time separator graphs satisfying edge separator theorem 
special graphs efficient solutions known planar graphs shaped meshes 
practice fast heuristics graphs 
static graph representations difference coded adjacency list described section 
sort neighbor indices vertex store differences adjacent pairs neighbors logarithmic code 
vertex encodings concatenated indexed select structure see section fast access 
graphs allow edge separators show relabel vertices recursive decomposition edge separator tree 
show relabeling combined difference coding reduces cost adjacency table bits 
permits degree queries time neighbor queries time neighbor 
support constant time adjacency queries describe separate structure directing graph vertices bounded outdegree storing edges vertex 
graphs require vertex separators vertex separator tree relabel graph 
vertex degree assigned shadow labels adjacency list refers uses different label 
auxiliary data structure making table lookup map shadow labels unique label vertex time 
show space required bits 
adjacency queries handled edge separator case 
representations described static 
third graph representation version representation variable bit length array structure section 
permits dynamic updates vertices neighbors vertex rewritten expected time degree vertex 
say representation edges inserted deleted space usage representation depends locality new edges respect initial ordering 
fourth representation representation permits dynamic updates individual edges expected time 
variable bit length dictionary structure section 
edges compressed stored dictionary linked list structure allows access individual elements time 
implemented third data structures described results extensive experimentation 
compare methods finding separators indexing structure 
results different prefix codes 
compare performance representations machines different cache characteristics 
compare code array representation variants linked list representation 
experimental results algorithms making application 
experiments show representations dominate standard representations terms space query times 
dynamic representation slower adjacency lists updates 
section discuss static graph representations 
section discuss dynamic representations 
section describe details specific implementation 
sections report experiments analyzing time space static dynamic graphs 
comparisons wide variety graphs including graphs taken finite element meshes vlsi circuits map graphs graphs router connectivity link graphs web 
graphs sparse 
analyze query times measure time depth search dfs graph 
picked measure requires visiting edge exactly direction common subroutine algorithms 
static graphs compare static representation adjacency arrays 
adjacency array stores vertex array pointers neighbors 
arrays concatenated large array vertex pointing block 
representation takes factor space adjacency lists requiring word directed edge vertex 
static representation compare codes encoding differences gamma codes codes nibble codes byte codes 
different codes represent tradeoff time space 
averaged test graphs static representation byte codes uses bits edge code uses bits edge 
compares bits edge adjacency arrays 
due caching effects time performance adjacency arrays depends significantly ordering vertices 
vertices ordered randomly static representation byte codes times faster adjacency arrays dfs depending machine 
vertices ordered separator order compression byte code times faster adjacency arrays 
dynamic graphs compare dynamic representation optimized implementation adjacency lists 
performance dynamic separator representation depends size blocks storing data 
results settings optimized space time 
representation optimized space uses bits edge optimized time uses bits edge averaged graphs 
compares bits edge adjacency lists 
adjacency arrays time performance adjacency lists depends significantly ordering vertices 
furthermore adjacency lists performance depends significantly order edges inserted adjacent edges cache line 
runtime separator representation depend insertion order 
hard summarize time results say performance time optimized representation ranges times faster adjacency lists dfs 
separator ordering linear insertion machine large cache line size 
random ordering random insertion 
time insertion separator representation times slower adjacency lists 
section describe experimental results analyzing performance algorithms 
maximum bipartite matching algorithm second implementation page page rank algorithm 
algorithms graph times pays static representation 
compare static representation nibble codes adjacency arrays adjacency lists 
algorithms representation runs fast faster saves factor space 
experiments run physical memory speedup disk access 
real world graphs separators edge separator set edges removed partitions graph equal sized parts see various definitions equal 
similarly vertex separator set vertices removed incident edges partitions graph equal parts 
minimum edge vertex separator graph separator minimizes number edges vertices removed 
informally say graph separators subgraphs minimum separators significantly better expected random graph size 
having separators indicates graph form locality edges attach near vertices far vertices 
sparsity having separators probably universal property real world graphs 
separator property graphs purposes including vlsi layout nested dissection solving linear systems partitioning graphs parallel processors clustering computer vision 
finding minimum separator graph np hard algorithms find approximations 
briefly review graphs separators 
reason graphs separators communities local structure 
link graphs web separators links local domain form community computer science researchers information gardening 
just true level local true hierarchically 
graphs social networks similar properties 
graphs include citation graphs graphs graphs friendship relations 
fact watts strogatz conjecture locality main properties graphs social networks 
reason graphs separators embedded low dimensional space 
meshes various forms simulation finite element meshes embedded dimensional space 
meshes planar satisfy vertex separator theorem 
shaped meshes known satisfy vertex separator theorem 
graphs representing maps roads power lines pipes internet embedded little dimensions 
road maps close planar pittsburgh 
power line graphs internet graphs crossings separators 
graphs representing connectivity vlsi circuits lot locality ultimately laid dimensions small constant number layers connections 
understood size layout depends critically separator sizes 
clearly certain graphs separators 
expander graphs definition small separators 
static representation consider kinds queries degree queries neighborhood queries adjacency queries 
degree query returns degree vertex 
neighborhood query lists neighbors vertex 
adjacency query tests vertices adjacent 
primary data structure difference coded adjacency list represented ordered set encoded described section 
assume vertices integer labels 
vertex neighbors vd sorted order data structure encodes differences vd vd contiguously memory 
differences encoded logarithmic code described section 
value negative store sign bit value 
start encoded list store code number entries list 
form adjacency table concatenating adjacency lists order vertex labels 
access adjacency list particular vertex need know starting location 
vertices total bits lists keeping log bit pointer vertex exceed space bound select data structure described section store start locations bits 
lemma adjacency table supports degree queries time neighborhood queries time degree vertex queried 
proof 
select operation allows access adjacency list vertex constant time 
log bit value decoded constant time gamma routine section takes time decode contents list 
edge separators 
discussing case graphs admit edge separators 
data structure case highly practical basis experimentation 
describe extension vertex separators 
note practice real world graphs tested edge separable 
algorithm builds edge separator tree target graph recursively computing edge separator subgraph 
resulting separator tree contains leaf vertex graph 
vertices labeled order left right traversal separator tree 
lemma suppose edges graph encoded way edge uses log bits 
member class edge separable graphs vertices labeled edge separator tree total space encode edges bits 
proof 
node separator tree contains vertices separator contains edges 
edges connects pair vertices apart labeling cost edges separator log 
graph edge separable separator guarantees side partition contain vertices 
upper bound number bits encode edges graph vertices 
satisfies recurrence log recurrence solves induction assuming nc 
consider adjacency table representation represents neighbors direct differences 
lemma space usage representation bits 
adjacency table representation sorts vertices represents differences 
representation improvement direct difference representation uses bits 
labeling vertices sum edge costs property log kn call labeling compact 
shown edge separator tree produces compact labeling classes graphs edge separable 
property useful discussions dynamic graphs 
adjacency queries 
difference coded adjacency table described find neighbors vertex optimal time 
resolving adjacency queries takes time requires decoding adjacency list see contains vertex 
answer adjacency queries constant time convert target graph directed graph bounded indegree 
lemma class undirected graphs satisfies separator theorem possible direct edges graph class resulting graph bounded degree 
proof 
fact section class graphs satisfying theorem bounded density 
algorithm directs edges graph ensure result bounded degree 
graph density bound algorithm selects set vertices degree 
half vertices property 
algorithm greedily directs edges vertices edges point vertices cause vertices exceed edge bound add edges vertices algorithm subtracts repeats process remaining graph 
vertices eliminated process complete vertex degree greater 
handle adjacency queries build edge adjacency table vertex lists label corresponding edge 
start full adjacency table bits described discard neighbors corresponding edges 
test vertices adjacent algorithm examines adjacency list information returns true vertex appears list 
takes time lists constant length 
remains calculate space usage new table 
neighbor vi discarded list differences vi vi vi vi replaced difference vi vi 
differences integral log vi vi log vi vi log vi vi asymptotically space usage decreases 
gamma codes exist cases deleting entry vi return va vb ea va va eb ea va sep va vb sep vb ta va sep ea tb vb sep eb return ta tb algorithm example partition produces 
list may increase length list bit 
contribute bits table 
new table formed discarding entries table size bits new table size bits 
gives lemma class undirected graphs satisfies separator theorem edge adjacency table graph class uses bits supports adjacency queries time 
vertex separators 
deal general case classes graphs allow vertex separators 
algorithm builds separator tree target graph uses order vertices 
algorithm building separator tree 
loss generality assume graph separator algorithm returns separator vertex side target graph clique 
target clique assume separator contains vertices remaining vertex left side partition 
algorithm describe produces separator tree separator vertices level included subgraphs level 
call partitions edges base case contains single edge separator tree leaf edge 
consider single vertex degree time appears separator edges partitioned sets vertex copied recursive calls 
vertex appear leaves appear separators appear internal nodes separator tree 
total appearances define binary tree vertex call shadow tree vertex 
example shown 
label appearance vertices separator tree recursively vertices left vertices separator vertices right 
note vertex degree receive labels time appears separator tree node shadow tree 
call label assigned root shadow tree root label label representative separator tree shadow tree corresponding vertex degree 
vertex 
labeling representatives sparse select rank data structures see section efficiently convert dense representation 
refer labels assigned leaves shadow tree shadow labels vertex 
note vertex degree root label shadow label 
property separator tree vertex bounded density graph assigned contiguous labels 
property holds vertex degree assigned labels giving total labels bounded density graphs 
graph separable graphs separator tree property 
represent graphs data structures 
shadow adjacency table map root label vertex adjacency list shadow labels 
second root find structure map shadow label label root 
shadow adjacency table 
shadow adjacency table contains difference coded adjacency list vertex accessed root label vertex 
vertices shadow labels leaf separator tree contains adjacency list contains adjacency list contains lemma classes graphs satisfying separator theorem vertex member shadow adjacency table bits 
proof 
consider adjacency list shadow tree vertex degree correspondence labels adjacency list leaves shadow tree corresponding labels differ 
charge difference adjacent pair adjacency list labels common ancestor corresponding leaves shadow tree 
ancestor separator graph vertices difference property difference code uses log bits 
treat difference list special case charge bits root label 
note charges node shadow tree twice 
charged log bits appearance vertex separator graph vertices 
recall target graph separator guarantees side partition contain vertices 
upper bound number bits encode graph vertices 
satisfies recurrence log recurrence solves induction assuming nc 
number bits encode lengths list bounded total number edges logarithm concave function 
note separators polylogarithmic approximations best cut recurrence solves 
root find structure 
shadow adjacency table find set shadow labels corresponding neighbors root label 
describe data structure maps shadow labels root labels 
structure allows perform lookups min log time vertex degree show improve structure perform lookups time 
allow root lookups assign label pointer parent encoded difference labels indexed select data structure 
bit token label indicate root shadow tree 
parent label separator graph vertices pointer log bits property 
charge child pointers parent resulting recurrence lemma bits 
parent pointers climb tree shadow label root 
separator tree log levels high height shadow tree number nodes contains total time min log 
achieve constant time bound blocking structure 
divide labels categories location separator tree 
category label determine size pointer allocate children 
labels appearing separators graphs containing log vertices placed category allocate full log bit root pointer children 
labels appear separators graphs containing log log log vertices placed second category children label differs log children log log log log bit offset pointer 
pointers point topmost second category label ancestor child label question label guaranteed category parent parent 
labels graphs containing nb log log vertices considered leaf labels placed third category 
encoding vertices explicitly encode graphs appear 
consider maximal block contiguous leaf labels leaf block 
examine leaf block remove parent pointers point locations outside block labels pointers marked roots shadow trees 
table lists distinct leaf blocks data structure replace individual leaf blocks pointers table 
leaf blocks parent pointers removed nb vertices individual block requires nb bits encode 
means distinct leaf blocks size pointer required leaf block nb bits 
nb pointers space bound 
examine table contains leaf blocks 
provide shadow label leaf block log nb bit pointer greatest ancestor block 
shrink number graphs table strip parent pointers pointed leaf graphs 
include pointers appendix leaf table pointer 
space pointers charged second category labels tree 
index pointers application select data structure 
leaf block store label entry modulo nb call vl 
charge log nb space nb space table pointer 
leaf block contains table pointer appendix vl 
shadow label procedure find root shadow tree 
select data structure find pointer leaf block containing compute vl modulo nb find index entry corresponding entry contains pointer greatest ancestor ancestor root examine appendix leaf block find greatest ancestor select data structure find greatest category ancestor needed 
operations require constant time 
lemma root find structure allows constant time lookup root label corresponding shadow label uses bits 
proof outline 
log labels receive log bit pointers log log labels receive log log bit pointers space pointers 
nb leaf table pointers nb bits space 
table contains entries contains nb pointers log nb bits total space log nb sublinear 
time bound described 
adjacency queries handled edge shadow adjacency table 
edge separator case see lemma directing graph vertices constant degree 
discard shadow adjacency table entries corresponding edges 
theorem class graphs satisfying separator theorem vertex member represented bits supporting adjacency queries degree queries time neighborhood queries time neighbor 
proof 
resolve degree queries neighborhood queries shadow adjacency table 
extracting degree shadow adjacency table takes time encoded extracting neighborhood takes time lemmas 
resolve adjacency queries edge shadow adjacency table 
adjacency query vertices need examine second table table 
takes time lists constant length 
representation variable bit length array structure section build graph representation supports insertion deletion edges graph 
insertions deletions dynamic space bound depends vertex labeling remaining compact 
describe representation 
static data structure data vertex concatenated stored chunk memory separate index allow finding start vertex 
dynamic data structure data vertex simply stored variable bit length array structure 
new representation old supports degree queries time neighbor listing time neighbor 
addition new representation allows insertion deletion edges rewriting data associated vertices 
inserting deleting edge requires expected time 
space bound data structure log bits 
compact labeling graph kn see lemma 
graph compressed edge separable initial labeling compact constant space bound structure depends labeling remaining compact 
note graphs having fixed embedding low dimensional space labeling takes advantage embedding remain compact long edges locality 
representation adjacency queries variable bit dictionary structure section build graph representation supporting adjacency queries neighbor queries 
theorem vertex graphs compact labeling stored bits allowing updates amortized expected time queries worst case time 
proof 
describing graph structure uncompressed form describe compressed 
structure represents graph dictionary edges 
edges incident vertex cross linked doubly linked list 
consider vertex ordering neighboring vertices vd 
represent edge vi dictionary entry vi vi vi 
vi key vi vi associated data 
define vd vertex include entry vd 
representation support adjacency testing neighbor listing insertion deletion edges functions dictionary 
pseudocode operations shown 
uncompressed form dictionary consumes entries vertex degree total number entries 
space 
adjacent return lookup null vp vn lookup return vn vp vn lookup return vn vp vn lookup insert vp insert vn vp vn lookup vpp lookup vp lookup vn insert vp vpp vn insert vn vp delete pseudocode support graph operations 
compression 
compress structure difference coding simply store dictionary entry differences respect say store entry vi vi vi dictionary store vi vi vi 
variable bit length dictionary store entries 
encoding entry requires log bits dictionary absorbs cost quotienting 
space proportional cost encoding vi vi vi edge vi dictionary 
compress differences representing gamma codes sign bits 
cost encode edge logarithmic code log 
edge appears times structure total cost encode edges log 
compact labeling log kn see lemma 
implementation separator trees 
implemented base algorithms constructing edge separator trees 
algorithms top graph recursively compute edge separators 
remaining algorithm bottom collapses edges graph combining vertices 
algorithm considered bfs generates separators breadth search bfs 
algorithm finds extremal vertex vn starting bfs random vertex vertex encountered 
algorithm starts second bfs vn continues visited half vertices graph 
taken partition 
apply bfs separator recursively produce separator tree 
second algorithm metis uses metis graph partitioning library construct separator tree 
metis uses multilevel partitioning technique graph coarsened coarse graph partitioned result projected back original graph kernighan lin refinement 
class partitioning heuristic best known time 
apply metis recursively produce separator tree 
third algorithm bu bottom begins complete graph repeatedly collapses edges single vertex remains 
heuristics decide order collapse edges 
experimentation settled priority metric number edges number original vertices contained resulting process collapsing edges creates separator tree merged vertices children resulting 
improve performance variant bu call bu bpq uses bucketed priority queue log buckets 
certain degree freedom way construct separator tree partition graph arbitrarily decide side partition left right child tree 
take advantage degree freedom optimization called child flipping 
child flipping algorithm traverses separator tree keeping track nodes containing vertices appear current node numbering 
nodes correspond left child current node left ancestor right child current node right ancestor 
nodes nl nr current node children denotes number edges vertices nodes child flipping heuristic rotates ensure en nr en nr heuristic applied separator tree postprocessing phase 
indexing structures 
algorithms select data structure map vertex numbers bit position start appropriate adjacency list 
henceforth call indexing structure 
implemented versions representing different tradeoffs space required lookup time 
simplest indexing structure direct stores array offset pointers vertex 
pointer uses log bits giving total log bits 
memory access required locate start vertex making method fast 
implemented structure indirect uses bits constant access time 
significantly simpler bit structure munro 
index vertices divide blocks log vertices 
divide blocks subblocks contains minimal number vertices totaling log bits constant store log bit pointer block global array store log bit pointer subblock start parent block 
block contains bit vector bit vertex 
vertex bit set vertex subblock 
requires bits 
consider settings indirect indirect 
find location vertex perform array lookup find location block containing target vertex 
examine block bit vector see subblock vertex find subblock offset subblock pointers decode subblock 
takes constant time determining subblock decoding subblock implemented table lookup log bits constant time 
compromise indexing structures consider class structures called allocating full pointer group vertices representing remainder offsets differences 
structure uses word pointer vertices fits bit offsets second word 
offsets doesn fit bits stored second word pointer 
structure stores start locations sixteen vertices bit words 
word contains offset vertex sixteen vertices represented 
second word contains bit offsets vertex starts vertices 
words contain twelve bit offsets remaining twelve vertices 
twelve vertices stored offset relative vertices encoded 
example start vertex encoded offset start vertex 
point offsets fit space provided stored table contains pointer 
codes decoding 
considered logarithmic codes representations 
addition gamma code considered code nibble code byte code described section 
implemented variant huffman code 
store frequency table huffman tree entire range possible differences truncated table entries 
gaps larger coded escape sequence stored flat log bits 
cases fewer gaps length 
decode huffman codes decoding table width bits 
leaves huffman tree represented codewords length leaves represented weight tree 
codeword longer bits decoding table gave pointer eighth level tree remainder word decoded tree 
dynamic structure 
dynamic structure manages memory blocks fixed size 
data structure initially contains array memory block vertex 
additional memory needed store data vertex vertex assigned additional blocks allocated pool spare memory blocks 
blocks connected linked list 
allocate additional block vertex part previous block store pointer new 
hashing technique reduce size pointers bits 
efficiently technique requires constant fraction blocks remain empty 
requires hash function maps address pairs addresses spare memory pool 
representation tests values range result hash unused block 
uses value pointer block 
hash function drawn uniform family memory pool full probability technique fail practice hash function pa mod address prime table random numbers size memory pool 
sufficient fill pool slightly 
help ensure memory locality separate pool contiguous memory blocks allocated vertices graph 
pool runs memory resized 
pools memory blocks fairly small resizing relatively efficient 
graph operations high locality repeated insertions vertex may max graph edges degree source auto mesh mesh mesh ibm circuit ibm circuit ca street map pa street map web links web links lucent routers scan routers table properties graphs experiments 
inefficient repeatedly encode decode neighbors vertex 
implemented variant structure uses caching improve access times 
vertex queried neighbors decoded stored temporary adjacency list structure 
memory structure drawn separate pool list nodes limited size 
pool managed fifo mode 
modified vertex flushed pool written back main data structure compressed form 
maintain uncompressed adjacency lists sorted order neighbor label facilitate writing back 
experimental setup graphs 
drew test graphs experiments sources mesh graphs online graph partitioning archive street connectivity graphs census bureau tiger line data graphs router connectivity scan project graphs webpage connectivity google programming contest data circuit graphs circuit benchmark suite 
circuit graphs initially hypergraphs converted standard graphs converting net clique 
properties graphs shown table 
edges list number directed edges graph 
directed graphs take degree vertex number elements adjacency list 
machines compiler 
experiments run machines bit processors quite different memory systems 
uses ghz pentium iii processor ghz bus gb ram 
second uses ghz pentium processor ghz bus gb ram 
pentium iii cache line size bytes pentium effective cache line size bytes 
pentium supports quadruple loads hardware prefetching effective loading consecutive blocks memory useful random access 
pentium performs better experiments strong spatial locality factor processor speed indicate particularly experiments spatial locality 
code written compiled redhat linux 
benchmarks 
times depth search times reading inserting edges 
select dfs visits edge visits vertices non trivial order exposing caching issues better simply reading edges vertex linear order 
implementation dfs uses character array length mark visited vertices stack store vertices return 
traverse graph 
reading edges times accessing vertices linear order accessing random order 
cases edges vertex read linear order 
inserting insert different orders linear transpose random 
linear insertion inserts edges vertex second 
transpose insertion inserts edges vertex second 
note edge vertex goes adjacency list vertex random insertion inserts edges random order 
compare performance data structure standard linked list array data structures leda package 
small differences implementation significant differences performance describe important details implementations 
adjacency lists 
singly linked list data structure 
data structure uses vertex array length access lists 
array element contains degree vertex pointer linked list neighbors vertex link list contains words integer index neighbor pointer link 
memory management links free lists space wasted header tail words 
space required words bits machines 
assuming deletions sequential allocation returns consecutive locations memory important understanding spatial locality 
experiments measured dfs runtimes inserting edges orders linear transpose random 
insertion orders described 
insertion orders major effect runtime accessing linked lists times dfs vary factor due insertion order 
linear insertion links vertex adjacent physical memory locations giving high degree spatial locality 
means adjacency list traversed links cache reside cache line previous link 
especially true experiments pentium byte cache lines cache line fit links 
random insertion assuming graph fit cache accessing link cache memory accessed completely random order 
measured runtimes vertices labeled orders randomized separator 
randomized labeling integer labels assigned randomly 
separator labeling labeling generated graph separator compression technique 
separator labeling gives better spatial locality accessing vertex array visited array dfs 
loading data vertex load data nearby vertices cache line 
edge neighbor access vertex nearby ordering cache 
linear insertion separator labeling improves locality accessing links dfs 
links neighboring vertices fall cache lines 
surprised strong effect labeling separators performance 
performance varied factor graphs low degree machine byte cache lines 
adjacency array 
adjacency array data structure static representation 
stores edges vertex edge array integer edge index neighbor 
edge arrays vertices stored order vertices 
separate vertex array points start edge array vertex 
number edges vertex determined difference pointer edge array vertex edge array vertex 
total space required adjacency array words 
static representations sense talk different insertion orders edges 
ordering vertex labeling significant difference performance 
linked list data structure measured runtimes vertices labeled randomized separator order 
linked lists separator ordering improved performance significantly factor 
leda 
ran experiments leda version 
experiments leda graph object forall outedges forall vertices loops edges vertices 
code compiled flag leda checking 
analyzing space leda data structure formula leda book page bytes 
note comparing space time leda really fair leda features data structures 
example directed graph data structure leda stores linked list edges edges vertex 
data structures store edges 
leda stores edges doubly linked list allowing traversal direction simpler deletion edges 
experimental results experiments measure tradeoffs various parameters data structures 
includes type prefix code static dynamic cases block size caching dynamic case 
study version difference encodes edges relative source vertex previous edge 
applications need control ordering edges 
example compact representation simplicial meshes described chapter encodes edges relative source vertex 
separator algorithms 
analyzing efficiency techniques parameters concern query times time create structures space usage 
space usage components space adjacency lists space indexing structure 
time create structure dominated time order vertices 
time space tradeoff time order vertices space needed adjacency table spending time ordering produces better compression encoded lists 
space time tradeoff space indexing structure dfs metis cf bfs bu bpq bu cf degree space space space space space space auto ibm ibm ca pa lucent scan avg table performance time compression achieved ordering algorithms compared depth search ordering 
space bits edge encoding edges seconds times normalized 
space encode degree vertex listed separately bits edge 
array structure rand sep byte nibble huffman graph space space space space space space auto ibm ibm ca pa lucent scan avg table performance static algorithms compared performance adjacency array representation 
space bits edge time dfs normalized column seconds 
list array direct indirect indirect space space space space auto ibm ibm ca pa lucent scan avg performance various direct indirect indexing schemes pentium iii 
space measured bits edge seconds times normalized 
graphs compressed gamma codes 
time needed queries space indexing structure gives faster query times 
experiments demonstrate tradeoffs 
timings pentium iii 
table illustrates tradeoff time needed generate ordering space needed compressed adjacency lists ordering 
experiments gamma codes compression 
addition separator schemes discussed section include simple ordering depth search post order numbering graphs 
general bu cf metis cf produce highest quality orderings cf indicates performs child flipping 
bottom technique bu cf significantly faster 
include results bu bpq child flipping approximate priorities ordering bu cf factor faster 
bfs algorithm regular graphs badly highly irregular graphs 
rest experiments chose bu cf ordering gave best performance test graphs significantly faster metis cf 
indexing structures illustrates tradeoff query time space needed indexing structure compares query times standard uncompressed data structures 
measure query time time execute depth search dfs 
reasonable measure requires visiting edges 
compare performance representations standard linked list array graph representations 
linked list representation uses bit words edge neighbor label pointer linked list 
array representation stores neighbor indices vertex contiguously large array lists vertices placed direct graph space space space auto ibm ibm ca pa lucent scan comparison indexing structure structures implemented new codebase pentium iii 
space bytes vertex time seconds required dfs 
graphs compressed nibble codes 

uses bit word edge 
representations array index vertices additional bit word vertex 
note linked lists suited insertions deletions representation arrays best suited static graphs 
versions dfs byte bits vertex mark visited 
results show direct indexing structure compressed representation slightly faster linked list representation 
surprising overhead decoding adjacency lists cache locality significantly better loading single cache line decode edges 
representation slower array representation 
surprising array representation spatial locality edges vertex adjacent memory decoding overhead 
note graph sizes representations graphs fit physical memory fit cache lucent scan 
indexing structure saves factor space direct structure requiring little extra time conclude practical indexing structures tested 
completing experiments migrated new codebase supporting wider variety coding techniques 
new codebase developed indexing structure 
table presents comparison structure direct structures 
indirect structures complex performed poorly reimplement testing 
structure saved bits vertex structure causing virtually slowdown 
accordingly exclusively experiments 
graph space space space space space space auto ibm ibm ca pa lucent scan avg table performance dynamic algorithm nibble codes various block sizes 
size give space needed bits edge assuming blocks leave secondary hash table full time needed perform dfs 
times normalized column seconds 
static representations table presents results comparing space dfs times static representations graphs pentium 
tables summary results wider set operations pentium iii pentium 
table times normalized column seconds 
average times bottom row averages normalized times large graphs weighted heavily 
times dfs 
adjacency array representation times vertices ordered randomly rand separator ordering sep 
seen ordering affect performance factor graphs low average degree pa ca factor averaged graphs 
indicates ordering generated graph separation useful compression critical performance standard representations see pronounced effect adjacency lists 
advantage separator orders enhance spatial locality previously studied sparse matrix vector multiply studied graph algorithms 
adjacency arrays ordering affect space 
static representation times space different prefix codes byte nibble gamma 
results show byte codes significantly faster codes twice fast fastest code 
surprising byte codes take advantage byte instructions machine 
difference large pentium iii factor 
noted gamma codes better codes terms time space 
include results code version byte code encodes edge difference target source difference target previous target 
increases space differences larger require bits encode 
furthermore difference requires sign bit 
increases time bits decode sign bits need extracted 
effects worsen space bound average time bound average 
comparing adjacency arrays separator structures see separator representation byte codes factor faster adjacency arrays random ordering slower separator ordering 
pentium iii byte codes faster factors respectively see table 
compressed format byte codes means require memory throughput adjacency arrays 
gives byte codes advantage pentium iii neighbors get loaded cache line requiring fewer main memory accesses 
pentium effective cache line size memory throughput large advantage reduced 
table section describes time cost simply reading edges graph effect cache locality 
dynamic representations key parameter dynamic representation selecting size blocks store difference codes 
large blocks inefficient contain unused space small blocks inefficient require proportionally space pointers blocks 
addition time cost traversing block 
cost includes time computing hash pointer potential time cache larger blocks faster 
table presents time space range block sizes 
results nibble codes pentium processor 
results codes pentium iii qualitatively time pentium iii sensitive block size 
space reported section size backup memory full include unused memory reported space 
expected graphs high degree larger block sizes efficient graphs smaller degree smaller block sizes efficient 
hard dynamically decide block size average degree graph size backup memory needs grow dynamically anyway 
note time space tradeoff depending time space important user want larger blocks time smaller blocks space 
table presents results comparing space dfs times dynamic representations graphs pentium 
gives timings linked lists corresponding labeling orders labeling insertion orders 
space orders 
table gives space time settings dynamic data structure time opt space opt 
time opt uses byte codes block size optimizes time 
space opt uses space efficient nibble codes block size optimizes space 
adjacency array representation vertex label ordering large effect performance adjacency lists factor 
addition label ordering insertion ordering large difference performance adjacency lists 
insertion order cause factor difference performance graphs high average degree auto ibm ibm pick setting optimizes time space 
time gains larger blocks vanishingly small large cost regards space 
space optimal optimize ts linked list structure random order sep order space opt time opt rand trans lin rand trans lin block time block time graph space size space size space auto ibm ibm ca pa lucent scan avg table performance dynamic algorithms compared linked lists 
graph give space time optimal block size 
space bits edge time dfs normalized column seconds 
factor averaged graphs assuming vertices labeled separator ordering 
effect insertion order previously reported page magnitude difference surprising largest factor previously seen reported 
note magnitude significantly pentium iii smaller cache line size average factor 
actual insertion order course depend application indicates selecting insertion order critical 
note users insert linear order better static representations allow insertion linear order 
data structure insertion order significant effect performance 
layout memory independent insertion order 
order dependence due hash collisions secondary blocks 
hash try pseudo random group location backup blocks little effect performance 
fact experiments shown showed noticeable effect dfs times different insertion orders 
space optimal dynamic implementation factor compact adjacency lists significantly faster linked lists cases factor faster randomly inserted edges 
pentium linked lists linear insertion separator ordering take time space optimal dynamic representation time time optimal dynamic representation 
pentium iii linked lists linear insertion separator ordering take factor time space optimal dynamic representation time time optimal dynamic representation 
times insertion reported tables 
read find insert graph dfs linear random linear random transpose space byte nibble gamma table summary space normalized times various operations pentium 
read find insert graph dfs linear random linear random transpose space byte nibble gamma table summary space normalized times various operations pentium iii 
timing summary 
tables summarize time complexity various operations data structures discussed 
structure list time required dfs time required read neighbors vertex examining vertices linear random order time required search vertex neighbor time required construct graph linear random transpose insertion 
times normalized time required dfs adjacency list random labeling normalized times averaged graphs dataset 
list refers adjacency lists 
leda refers leda implementation 
list leda array rand uses randomized ordering vertices uses separator ordering 
times dfs read find reported list leda linear insertion edges best case 
dyn refers version dynamic data structure cache edges vertices adjacency lists 
cached refers version 
structures space efficient block size time efficient 
array refers adjacency arrays 
byte nibble gamma refer corresponding static representations 
note cached version dynamic algorithm generally slightly slower linear transpose insertions faster non cached version 
insertions operations cache locality 
linear insertion cached dynamic representations factor times slower adjacency lists pentium factor slower pentium iii 
leda significantly slower space efficient representations previously mentioned leda features representations 
randomized graphs emphasize fact real world graphs separators created randomized versions graphs test set 
randomized versions vertex count edge count degree distribution original graphs edges randomly assigned follows 
vertex receives number slots equal degree previous graph 
edge randomly assigned slots set empty slots 
duplicate edges self edges discarded process reduces edge count randomized graphs slightly 
graphs compared compression achieved original graph randomized graph 
compute compression achieved byte codes codes counting cost index 
compare naive rate log bits edge achieved flat code 
cases compression significantly worse graph randomized 
google graph undirected version 
original random graph byte byte log auto ibm lucent google table compression bits edge achieved codes various real world graphs 
edges graph randomized remove locality degree distribution maintained compression worsens significantly 
algorithms describe results algorithms need potentially large graphs google pagerank algorithm maximum bipartite matching algorithm 
meant represent somewhat realistic application graphs simple dfs 
pagerank 
simplified version pagerank algorithm 
algorithm involves finding eigenvector sparse matrix matrix representing link structure pages web normalized uniform matrix normalized parameter algorithm 
eigenvector computed iteratively maintaining vector computing step ri ri 
step implemented multiplication vector sparse matrix representing links followed adding uniform vector normalizing resulting vector account degrees needs normalized 
standard representation sparse matrix adjacency array previously described 
compare adjacency array implementation implementations 
ran algorithm google link graph iterations 
representation computed time space required 
lists results 
pentium iii static representation byte code best 
pentium array ordered labeling gives fastest results byte code gives compression sacrificing speed 
bipartite matching 
maximum bipartite matching algorithm representing graph network flow depth search find augmenting paths 
takes bipartite graph vertices left vertices right assigns capacity edge 
edge implementation maintains indicate current flow edge 
loops vertices left set dfs find augmenting path vertex 
finds pushes unit flow updates edge weights appropriately 
conceptually graph directed implementation needs maintain edges directions implement depth search 
avoid best case runtime stack store vertices visited dfs entire bit array visited vertices need cleared time 
optimization suggested leda book page 
implemented optimization level bfs dfs 
improved performance time sec space representation piii dyn dyn dyn dyn gamma nibble byte table performance pagerank algorithm different representations 

strided loop left vertices prime number stride 
reduced locality greatly improved performance average depth dfs find unmatched pair reduced 
graph static static representations sufficient 
ran algorithm byte code nibble code adjacency array implementations 
bit array flow flags accessed indexing structure accessing adjacency lists 
dynamically sized stack dfs storing visited vertices dfs 
store bit edge direction indicate current flow bit vertex mark visited flags bit vertex right mark matched 
maximum bipartite matching algorithm run modified version google graph 
copies created vertex left right 
links google graph point left vertices right ones 
results 
memory listed total memory including representation graph index flow flags flow flags visited matched flags stacks 
representations assume layout auxiliary data difference space due graph representation 
space needed stacks small largest dfs involves vertices 
discussion summarize feel important surprising results experiments 
note simple fast separator heuristic purposes 
compression sensitive quality separator applications separators nested dissection 
nested dissection sophisticated time sec space representation piii nibble byte table performance bipartite maximum matching algorithm different static representations 
tors typically 
interesting study theoretical properties simple heuristic 
bounds sloppy approximations separators sufficient separator size kn give required bounds actual separators smaller 
note real world graphs able find small separators smaller expected random graphs 
property real world graphs properly noted 
experiments indicate additional cost needed decode compressed representation small insignificant compared costs algorithm simple depth search 
noted situations compressed representations faster standard representations operations needed decoding 
performance bottleneck accessing memory bit operations decoding 
place standard representations slightly faster dfs separator orderings linear insertion pentium 
somewhat surprised large effect different orderings performance pentium adjacency lists adjacency arrays 
performance differed factor apparently purely caching effects number edges traversed identical dfs fixed graph 
differences indicate performance numbers reported graph algorithms specify layout memory ordering vertices 
differences indicate significant attention needs paid vertex ordering implementing fast graph algorithms 
note separator ordering graph compression improving performance adjacency lists adjacency arrays 
surprising compression memory layout take advantage locality graphs accesses close ordering 
analysis consider applications significant quantity information needs stored graphs large weights edges labels vertices 
clearly data diminish advantages compressing graph structure 
note data compressed 
fact locality separator labeling useful compression 
example web graphs vertices nearby vertex ordering share large prefix url 
similarly finite element meshes vertices nearby vertex ordering nearby space difference encoded 
ideas chapter clearly generalized structures simple graphs 
example reordering separator idea chapter simplicial mesh data structure chapter difference coded adjacency lists 
adapted core setting 
decrease total memory usage compression important core setting compressing data increase amount fit cache 
locality provided reordering useful algorithm 
complication arise involves algorithm perform reordering reordering algorithms assume graph structure held ram 
problem addressed crude partitioning algorithm high levels sophisticated reordering algorithm subgraphs reached manageable size 
chapter index compression document reordering chapter interested compression inverted indices 
inverted index collection posting lists subset set 
compressed posting lists stored individually may need accessed individually 
properties index possible improve compression individual lists 
chapter describes heuristic relabeling technique uses permutation relabel elements order improve compression posting lists 
possible representations compressed posting lists discussed chapter 
chapter focus quality compression achievable index 
accordingly chapter consider compression difference coded representation discussed section compact chapter 
reordering technique describe apply structures chapter 
compact inverted indices important design search engines memory considerations serious concern 
web search engines index billions documents fraction total number pages internet 
space search engine representation inverted index maps search terms lists documents containing terms 
posting list inverted index list document numbers documents containing specific term 
query multiple terms entered search engine retrieves corresponding posting lists memory performs set operations combine result sorts resulting hits priority measure reports user 
naive posting list data structure simply list document numbers corresponding term 
require log bits document number efficient 
save space document numbers sorted compressed difference coding described section chapter guy blelloch 

general difference coding algorithm get best compression ratio differences small large 
authors noted achieved document numbers posting list high locality 
authors designed methods explicitly take advantage locality 
methods achieve significantly improved compression documents term high locality 
compression methods far devoted passive exploitation locality inverted indices 
study improve compression ratio difference coding inverted index permuting document numbers actively create locality individual posting lists 
way accomplish apply hierarchical clustering technique document set cosine measure basis document similarity 
algorithm traverse hierarchical clustering tree applying numbering documents encounters 
documents share term lists close tree close numbering 
similar graph reordering algorithm chapter 
implemented idea tested indexing data trec ad hoc track disks excluding congressional record 
tested variety codes combination difference coding 
algorithm able improve performance best compression technique fourteen percent simply reordering document numbers 
improvement offered algorithm increases size index believe improvement larger real world indices greater 
conceptually order index algorithm divided parts 
part build graph constructs document document similarity graph index 
second part split index calls metis graph partitioning package recursively partition graphs produced build graph 
uses partitions construct hierarchical clustering tree index 
third part algorithm order clusters applies rotations clustering tree optimize ordering 
numbers documents simple depth traversal clustering tree 
levels apply optimizations heuristics ensure time memory requirements algorithm scale 
practice constructing full hierarchical clustering infeasible parts algorithm combined single recursive procedure pass clustering tree 
related 
research originally published previous dealing index compression reordering 
authors examined subject 
published concurrently presenting reassignment method traveling salesman problem 
achieved compression original ordering reordering phase took longer reorder documents second collection documents achieve documents second compression similar collection 
blanco heuristics improve tsp algorithm notably dimensionality reduction singular value decomposition 
algorithm achieving compression collections documents speed documents second 
unclear algorithm ram requirements compare 
note largest index test able algorithm reorder documents gb ram 
blanco incorrectly claim documents 
algorithms faster thirds memory algorithm default settings best algorithm achieved compression 
note compression quality deteriorates larger indices algorithm achieves better compression larger indices 
remainder chapter organized follows 
section formalizes problem 
section describes algorithm detail 
section demonstrates performance algorithm run trec database 
definitions describe inverted index set terms tm 
term ti associated list ti document numbers di ti 
document numbers range di interested cost representing documents difference code 
define si di si ti sequence documents di rearranged si si si sorted version sequence documents di 
convenience define si 
encoding scheme requires bits store positive integer write cost encoding index follows ti si si wish minimize creating permutation reorders document numbers 
convex useful encoding schemes means need cluster documents improve locality index 
algorithm document similarity 
point viewed inverted index set terms contains subset documents 
convenient consider set documents contains subset terms 
specifically consider document element th element document document contains term ti 
eventually algorithm need compute centers mass groups documents convenient allow documents contain fractional amounts terms represent document element algorithm uses cosine measure determine similarity pair documents cos build graph 
similarity measure build graph algorithm construct similarity graph 
large databases creating full graph edges feasible 
documents contain small fraction total set terms 
reasonable graph sparse edges similarity graph weight zero 
especially true remove common stopwords consideration described 
save space build graph uses method generate graph 
consider index bipartite document term graph build graph needs generate document document graph 
term document term graph algorithm eliminates term inserts edges weighted cosine measure form clique node neighbors 
eliminating terms document term graph build graph produced document document graph contains edge pair documents shares common term 
term ti contains ti documents build graph compute ti cosine measures computing edge graph 
algorithm improve bound slightly careful compute cosine measure worst case number cosine measures ti 
build graph need information order represent structure similarity graph 
particular lot documents index trivially similar share terms 
frequently occurring terms index important similarity measure 
removing edges corresponding terms impact quality ordering demonstrated section decrease required build graph considerably 
generating graph algorithm creates cliques neighbors terms threshold number neighbors 
terms simply deleted graph 
technique similar broder identifying near duplicate web pages 
pseudocode part algorithm shown 
split index 
build graph produced similarity graph step derive hierarchical clustering graph 
large number hierarchical clustering techniques choose example additional papers techniques designed data sets large ones dealing 
fact require input similarity matrix 
space time construct matrix size run clustering algorithm 
furthermore problem certain special features captured general clustering algorithms 
created hierarchical clustering algorithm graph partitioning 
naive hierarchical clustering algorithm follows 
index compute similarity graph index 
partition graph pieces 
continue partitioning subgraphs split index subsample build graph partition empty indices foreach cos cos add add return build graph new graph foreach foreach foreach new edge cos add return build graph split index algorithms 
pieces size 
resulting partition tree clustering hierarchy 
unfortunately algorithm uses memory 
build graph algorithm requires full memory infeasible apply full index 
split index uses sampling technique index recursive step subsamples fraction documents original index 
runs build graph partitions result 
done split index uses subgraph partition partition original index 
computes centers mass subgraph partitions 
partitions documents original index centers mass nearest 
pseudocode split index shown 
interesting point note split index document similarity graph node recursion tree 
offers build graph algorithm significantly flexibility creating similarity graph build graph needs create graph way partition 
allows build graph small value term occurs say times partition level partition split index computes documents containing term sides anyway 
build graph ignores term iterations 
order clusters 
split index produced hierarchical clustering order index uses clustering create numbering leaves 
performs inorder traversal tree 
step needs decide available partitions traverse 
essence order clusters algorithm looks node hierarchy decides swap children 
subtree variables consider 
denote children 
define il ir documents appear immediate left right final ordering 
recursion initialize il ir place equal weight term 
causes infrequently occurring terms pulled away middle ordering 
order clusters operates depth traversal take il left child left ancestor ir right child right ancestor 
order clusters tracks centers mass clusters order clusters il ir ml il ir cos ml cos cos ml cos return return assigns numbers documents index exactly documents 
order index il ir number split index order clusters il ir order index il order index ir order clusters order index algorithms 
rotates place similar clusters closer 
pseudocode order clusters main body algorithm shown 
experimentation compression techniques 
tested common difference codes see improvement algorithm provide 
codes tested include delta code golomb code arithmetic code 
codes described detail witten moffat bell :10.1.1.51.7802
tested binary interpolative compression method moffat 
code explicitly designed exploit locality inverted indices gained algorithm 
count cost storing sizes term cost invariant orderings 
count cost storing arithmetic table arithmetic coding cost negligible compared cost storing bulk data 
testing 
test algorithm ad hoc trec indexing data disks excluding congressional record 
data contained documents distinct words occupied gigabyte space uncompressed 
tested different orderings data combination difference codes described 
tested random permutation document numbers baseline comparison 
second tested default ordering trec database 
noted significant improvement random ordering indicating considerable locality inherent trec database 
third tested ordering produced algorithm 
results shown 
analysis 
golomb code near optimal encoding randomly distributed data fact best code random ordering 
golomb code convex benefit locality 
random identity ordered binary delta golomb arith interp improvement bits edge algorithm offers different coding schemes disks trec database 
index random identity ordered improvement improvement size random identity improvement offered algorithm increases size index measured documents increases 
locality inherent trec database interpolative code efficient code identity ordering 
interpolative coding bits edge improvement best encoding random document ordering 
ordering produced algorithm interpolative code needed average bits edge encode data improvement best coding random ordering improvement best coding identity ordering 
index size 
measure effect index size algorithm tested algorithm various subsets full index 
subsets formed evenly subsampling documents full dataset 
subset evaluated best compression random identity ordered permutation documents 
random permutation best coded golomb code identity ordered permutations coded interpolative codes 
shows results tests 
interestingly improvement offered algorithm increases size index increases 
parameter tuning 
algorithm uses parameters 
parameter threshold determines sensitive build graph algorithm term size 
term ti ti algorithm consider calculating cosine measures add edges similarity graph 
table shows performance algorithm subset full dataset containing rand time delta arith interp performance bits edge different values sixteenth trec indexing data 
rand time delta arith interp performance bits edge different values sixteenth trec indexing data 
note algorithm running time greater 
aggressive subsampling results unbalanced partitions increasing recursion depth algorithm 
sixteenth documents different values 
choosing causes edges included similarity graph increasing beneficial index studied 
chose safe 
second parameter determines aggressively algorithm subsamples data 
index size algorithm extracts elements build 
table shows performance algorithm different values 
algorithm perform badly large clear tradeoff time space quality 
chose experiments suitable balance concerns 
graph compression 
algorithm enhance performance difference coding graph compression 
chapter discussed separator algorithms graphs manipulated main memory 
algorithm subsampling techniques applied graphs larger compression produced weaker 
graph compression vertex graph algorithm stores adjacency list vertices share edge vertex 
vertices numbered natural apply difference code compress list 
view vertices terms adjacency lists posting lists apply clustering technique vertices graph 
test clustering technique graph data trec dataset trec wt web code random identity clustered ordered binary delta golomb arith interp performance algorithm trec wt web track 
clustered column describes performance algorithm final rotation step 
data track 
track represented directed graph web pages hyperlinks edges 
best compression stored edges edges vertex adjacency lists 
number edges vertex variable number edges meaning adjacency lists dense compressed 
performance algorithm link representation shown table 
chapter compact representations simplicial meshes dimensions chapter interested compressed representations meshes permit dynamic queries updates mesh 
goal solve larger problems standard random access mainmemory algorithms 
data structures representing dimensional simplicial meshes 
simplicial mesh mean pure simplicial complex dimension manifold possibly boundary 
data structures support standard operations meshes including traversing neighboring simplices inserting deleting simplices ability store data simplices 
class shaped meshes bounded degree operations take constant time 
data structures compact designed disk storage save factor standard representations 
compressed meshes important applications space required represent large unstructured meshes memory limiting factor size mesh 
standard representations tetrahedral meshes example require bytes vertex 
previous deals larger meshes maintaining mesh external memory 
avoid thrashing requires designing algorithms access mesh carefully orchestrated 
external memory algorithms designed algorithms complicated main memory counterparts significantly slower :10.1.1.147.3224
field compressed meshes received considerable attention 
dimensions example methods compress tetrahedral mesh byte tetrahedron bytes vertex including vertex coordinates 
techniques designed storing meshes disk reducing transmission time representing mesh main memory 
support dynamic queries updates mesh compressed form 
chapter guy blelloch david clemens 
data structures described section 
take advantage separator properties shaped meshes results graph compression see chapter 
particular technique uses separators relabel vertices vertices share simplex labels close value 
pointers difference encoded variable length codes 
case mesh representations 
representation storing edge triangles contain edge 
described section 
representation radially storing neighboring vertices vertex 
described section 
representations generalize readily greater dimensions 
section describes implementation data structure representation stores neighboring vertices vertex 
section presents experimental results 
implementation uses bytes triangle bytes tetrahedron measured range mesh sizes point distributions 
experiments representation part incremental delaunay algorithms 
variant standard bowyer watson algorithm exact arithmetic predicates shewchuk geometric tests 
experiments delaunay refinement algorithm removes triangles small angles adding new points 
space reported terms total space including space vertex coordinates data structures required algorithm 
results gbyte memory summarized follows 
generate delaunay mesh triangles gbytes mesh gbytes vertex coordinates gbytes auxiliary data algorithm 
compared triangle code efficient know algorithm uses factor memory 
slower triangle divide conquer algorithm faster incremental algorithm 
generate delaunay mesh tetrahedra gbytes mesh gbytes vertex coordinates gbytes auxiliary data 
compared pyramid code algorithm uses factor memory faster 
generate refined delaunay mesh triangles angle 
version dynamically generates new labels uses extra level indirection datastructure 
data structure conjunction external memory algorithms 
describe implementation simplicial meshes ideas extend higher dimensions 
topics discussed briefly section 
standard mesh data structures numerous approaches representing unstructured meshes dimensions 
specialized simplicial meshes general polytope meshes 
purpose comparing space usage review common data structures 
complete comparison structures kettner 
dimensions approaches triangles edges 
simplest data structure triangles 
triangle pointers neighboring triangles pointers vertices 
assuming data needs stored triangles edges data structure uses pointers triangle 
storing data requires extra pointers 
shewchuk triangle code cgal triangulation data structure triangle data structure 
distinguish neighbors vertices triangle handle triangle typically needs include index 
data structure triangle example includes index pointer neighbor low bits neighbor query returns neighbor triangle returns orders held 
closely related data structures edges including doubly connected edge list winged edge half edge quad edge structures 
addition triangulated meshes data structures polygonal meshes 
data structures edge maintains pointers neighboring vertices neighboring edges cyclically neighboring faces vertices 
edge maintain pointers neighboring faces edge data 
space efficient data structures maintain edge pointer neighboring vertices just neighboring edges face vertex 
assuming data needs stored face edge requires pointers edge manifold triangulation equivalent pointers triangle triangle structure 
half edge data structure cgal leda maintains structures edge direction 
half edges cross referenced requiring extra pointers edge 
winged edge quad edge structures maintain pointers neighboring edges requiring pointers edge triangle 
dimensions analogous data structures tetrahedra faces edges 
simplest data structure structure tetrahedron 
tetrahedron pointers adjacent tetrahedra corner vertices 
assuming data requires pointers tetrahedron 
data structure pyramid cgal 
face edge data structures called boundary representations reps 
boundary representations general tetrahedron data structures allowing representation polytope meshes tend take significantly space 
dobkin laszlo suggest data structure edge face pairs general requires pointers edge face 
tetrahedral meshes data structure optimized pointers face adjacent faces rotating edges corner vertices 
corresponds pointers tetrahedron 
weiler radial edge representation cell tuple representation map representation take space 
summary efficient standard data structures simplicial meshes pointers triangle pointers tetrahedron 
extra pointer required store data triangles tetrahedra 
representation edges section discuss representation edges 
representation similar graph representation section generalization somewhat different 
uncompressed representation describe compress 
edge mesh part faces triangles 
faces representation stores key data pair dictionary structure 
similar winged edge structure vertex labels pointers 
orientation mesh needs maintained vertices kept consistent order order matter 
faces missing vertex face replaced special token 
save space edges kept consistent direction dictionary stores store 
proper direction edge determined simple test example edges stored 
structure supports operations search insert follows search finds vertices form face single dictionary lookup 
insert adds face requires updating dictionary entries 
entry dictionary token replaced appropriate vertex entry created token 
delete deletes face requires updating dictionary entries replacing appropriate vertices tokens 
entry tokens data slots deleted 
interface supports traversing mesh repeated invocations 
variable bit length dictionary structure allows time expected amortized time 
data stored mesh including dictionary entries 
compress data structure difference coding encode relative dictionary store tuples form 
differences gamma coded described section sign bit indicates difference negative 
variable bit length dictionary store encoded entries described section 
dictionary absorbs log bit cost representing remains account gamma coded differences charge cost storing edge cost storing edge cost storing edge 
edge charged times cost case log 
gives theorem simplicial mesh representation variable bit dictionary uses bits skeleton set edges mesh 
vertices mesh compact labeling described section representation mesh bits 
note shaped meshes fixed dimension bounded degree small separators separator tree algorithm section guaranteed find compact labeling 
meshes planar small vertex separators meshes bounded degree small edge separators 
log representation permits dynamic insertions deletions bit space bound depends labeling remaining compact 
reason describe representation similar graph representations sections 
practice shaped meshes possible find labeling advantage spatial embedding vertices 
edge separators algorithms cuts partition vertices relabeling 
edges meshes high locality gives labeling practice 
details section 
generalization 
representation natural generalization storing faces triangles mesh 
face part tetrahedra 
tetrahedra representation stores tuple dictionary structure 
save space face stored ordering example ordering insert supported just case 
data structure compressed difference coding structure stores variable bit length dictionary 
examine space usage representation 
dictionary absorbs log bit cost representing quotienting 
charge cost storing face charge cost face face 
face charged times time charge max log log log log log log 
gives bound log log log skeleton set faces mesh 
fact prove stronger bound space usage lemma skeleton set faces simplicial mesh 
skeleton set edges mesh 
mesh representation space usage log log log bits space usage log bits 
proof 
wish charge cost face adjoining edges 
edge assigned charge log 
define strongest edges face edges greatest difference vertices 
example strongest edges 
note log log log log charge log log log cost face strongest edges 
ensure edge charged times 
star vertex vi set simplices edges faces tetrahedra containing vi 
closure star vi set simplices vi lower dimensional simplices contained 
define link vertex vi vi vi set faces edges vertices share tetrahedra vi contain vi 
vi vi vertices edges link vi correspond set edges faces containing vi mesh 
vi dimensional surface euler rule applies know vi vi 
direct edges vi way ensure vertex vi indegree greater 
done iteratively step find vertex vi degree 
euler rule guarantees possible 
direct edges containing delete edges vi 
termination edges directed vertex received indegree greater 
recall vertices vi correspond edges containing vi mesh edges vi correspond faces 
face vi vj vk face strongest edges vi vj vi vk examine corresponding edge vj vk vi 
edge directed vj charge cost face edge vi vj charge edge vi vk 
edge charged times endpoints edge charged faces 
charge case log edge 
total space log bits 
case skeleton mesh compact labeling representation mesh bits 
representation vertices section discuss mesh representation vertices 
representation storing cycle neighbors order vertex mesh 
cycle neighbors vertex known link 
similar half edge structure weiler 
note vertex labels pointers higher dimensional simplex structures allowing compress vertex labels 
uncompressed representation describe compress 
vertex mesh representation stores cycle neighboring vertices 
cycle ordered radially vertex orientation complex clockwise 
holes mesh cycle vertex may split multiple paths connected vertices 
path stored separately 
entry vertex begins gamma code degree vertex 
structure supports operations search insert follows search finds vertices form face requires searching cycle neighbors predecessor successor insert adds face requires updating entry vertex 
example entry vertex searched path pb path pc pb pc new paths length created contain missing vertices 
paths pb pc concatenated 
process applied cycle neighbors vertices neighborhood corresponding difference code data vertex 
entry degree vertex 
entries offsets neighbors 
delete deletes face requires updating entry vertex 
example entry vertex searched path containing path split resulting paths length deleted 
process applied cycle neighbors vertices interface supports traversing mesh repeated invocations 
time required operation bounded degree meshes 
compress data structure difference coding store entry store shown 
differences gamma coded sign bit concatenated 
entry vertex contains multiple paths paths concatenated entry gamma code followed flag indicate path ends begins 
entry vertex stored variable bit length array structure described section 
analyze space usage representation observe edge stored twice entry entry case cost gamma code log 
cost storing gamma code degree vertex bits edge 
total space log bits 
section vertices mesh compact labeling described section representation mesh bits 
generalization 
representation mapped vertex cycle neighbors vertex 
representation maps edge cycle neighbors edge 
words edge mesh representation stores set vertices share face 
known link edge 
cycle ordered radially edge orientation complex clockwise 
similar dobkin laszlo mesh structure 
save space edges kept consistent direction dictionary stores store 
proper direction edge determined simple test example edges stored 
operations search insert implemented case searches updates performed edges vertices 
example inserting mesh entries edges need updated 
updates just matter joining paths inserts splitting paths deletes 
note considerable redundancy storage described 
resolve search structure query edge get result case 
decrease space requirement structure simple optimization structure stores representative subset edges mesh 
specifically stores edges labels odd 
edges called representative edges 
permits structure resolve queries triangle contain vertices odd labels 
case compress structure difference coding 
representative edge associated cycle vertices store table entry variable bit length dictionary structure described section 
stored log bit representation values gamma coded concatenated 
dictionary absorbs cost storing remains account differences 
face contributes gamma coded values representation entry cycle edge entry cycle entry cycle 
gamma coded values size log log log 
space cycles vertex labels log log log bits lemma log bits 
table entry edge stores additional term requires log bits space bound 
storing gamma code number vertices cycle requires bits edge 
total space usage log bits 
compact vertex labeling reduces bits 
data added mesh including dictionary entries 
example data associated tetrahedron data stored vertices table entry edge 
tetrahedron multiple representative edges associate data data needs stored representative edges chosen fixed manner lookup easy 
compressed data structure 
specifically data stored edges representative edge structure stores data edges order preference 
implementation decide structures implement examined space usage structure 
assume average cost difference code structure count number difference codes structure 
representation edges uses table entry edge 
encoding free quotienting codes stored edge 
generalization structure uses table entry face 
free cost codes stored face 
representation vertices uses codes edge stores entry entry generalization potentially stores face times entries edge chance stored expected space usage codes stored face 
small overhead edge stored negligible compared expense face 
representation edges stronger time bounds runs time time degree vertex examined uses space particularly 
accordingly chose implement representation vertices 
generating labels 
space bounds compressed structure log bits 
achieving compression structure relies having compact ordering described section 
achieve algorithm vertices technique cuts 
set points technique finds axes greatest diameter 
finds approximate median coordinate partitions points side median 
points side labeled points side 
done recursively produce labeling points near similar labels 
similar separator tree labeling scheme section coordinates vertices edges 
vertices known algorithm begins algorithm assign sparse labeling initial vertices 
new vertex added assigned label close labels neighbors 
triangulation 
compressed data structure implemented follows 
difference encoding structure uses nibble code store values described section 
necessary store extra bit value accomplished shift operation particular value negative difference coder stores absolute value plus sign bit sign 
vertex represented nibble code degree vertex followed nibble codes differences vertex neighbors 
implementation stores additional special case bits neighbor provide information triangle precedes link 
bit set indicate gap link indicates triangle preceding neighbor mesh 
bit set data associated triangle preceding neighbor 
case code neighbor followed nibble code representation data 
optimization note vertices special case bits set 
implementation stores bit degree vertex indicate special case bits set bits omitted encoding vertex 
block blocks total size needed space number extra blocks needed vertices uniform distribution total space required allocate blocks needed 
variable bit length array implementation somewhat different described section 
version section developed extremely short bitstrings able pack multiple bitstrings array slot avoid wasted space due buckets 
application bitstring represents vertex blocks problem 
concern efficiently allocating additional storage buckets 
array implementation stores nibble codes vertex array containing byte block vertex 
block overflows storage needed greater bytes additional space allocated separate pool byte blocks 
byte block stores pointer block sequence 
implementation uses hashing technique ensure pointer needs larger byte 
requires hash function maps address pairs addresses spare memory pool 
implementation tests values range result hash unused block 
uses value pointer block 
certain assumptions hash function memory pool full probability technique fail find vertices labeled sparsely new labels generated dynamically implementation hash mapping labels vertex data blocks 
byte memory allocated label label byte contains hash pointer data block vertex 
bit stored block indicate current block sequence 
block bit stored degree vertex subsequent blocks stored eighth bit byte pointer block 
tradeoff sizes blocks 
large blocks inefficient contain unused space small blocks inefficient require space pointers blocks 
addition cost associated computing hash pointers searching unused blocks memory pool 
shows tradeoff factors delaunay triangulation algorithm run uniformly distributed points unit square 
chose block size gives efficient space 
improve efficiency lookups implementation uses caching system 
query update block blocks blocks size allocated number blocks size allocated vertex mesh percentage blocks blocks associated appropriate vertex decoded 
information represented uncompressed form list vertex link element list 
lists kept fifo cache maximum capacity nodes 
update operations may affect lists cache 
lists encoded back blocks flushed cache 
tetrahedralization 
main difference structure structure need keep track edges vertices 
structure sufficed keep array slot vertex structure need allocate space edge stored representation 
true hashing dictionary structure keep track edges 
data structure keeps map vertex representative edges 
stored difference coded list corresponding neighbors 
code neighbor followed code number encoding representative edge pointer block containing data edge 
pointer stored hash trick keep pointer sizes small 
representative edge block allocated memory pool capability allocate additional blocks needed 
edge queried implementation loads list vertex edge cache 
need decompress edges adjoining vertex 
number needed representative edge quite variable data structure allocates pools byte blocks reduce wasted space 
number blocks pool determined experimentally shown 
data structure ensures pool free space block allocated pool data structure looks larger 
initial block vertex comes separate array containing blocks size 
dynamic point generation 
support dynamic point generation expanded label space 
total vertices generated allow possible labels 
label receives byte hash pointer label points initial data block corresponding vertex 
initial vertices spread evenly label space 
incremental delaunay algorithm 
implemented delaunay triangulation algorithm dimensions compressed data structure 
employ known bowyer watson kernel incrementally generate mesh 
course algorithm delaunay triangulation current maintained 
incremental step inserts new vertex mesh determining faces tetrahedra violate delaunay condition 
faces form delaunay cavity 
edges faces bound cavity called horizon 
mesh modified removing faces cavity connecting new vertex horizon 
cavity connected local search current mesh 
point inserted cavity determined search starting face contained achieve optimal runtime bounds idea clarkson shor maintain association point inserted mesh face tp contains search cavity start tp 
algorithm keeps history mesh uses history locate tp inserted 
contrast keep mesh history maintain association points containing faces tp current mesh 
incremental step points faces cavity new faces tests tests accounts dominant cost algorithm 
carefully implemented idea described extended dimensions 
implementation require extra memory lists points time point vertex mesh list 
memory store vertex mesh list node 
algorithm maintains queue faces interiors contain points 
faces contain points added mesh algorithm terminates 
scenario points known 
generate labels input points cuts coordinate directions described earlier 
runtimes reported section include preprocessing step 
delaunay refinement 
test implementation performance case new points dynamically generated runtime implemented delaunay refinement code style ruppert 
augment delaunay triangulation adding badly shaped triangles maintaining delaunay property 
initial triangulation built walk mesh check quality face queuing ones satisfying preset minimum angle bound 
queue triangulation phase algorithm store list triangles split 
new point generated algorithm assigns new label considering horizon vertices cavity created calculating value minimizes sum log norms finds closest label 
pure triangulation code vertices known store point coordinates level vertex arrays densely 
refinement code fill arrays open address hashing takes prohibitively long 
require extra memory additional map label space vertices 
distribution pts extra blocks time uniform normal line uniform normal line number extra byte blocks needed store triangular delaunay meshes various point distributions structure runtime implementation 
experimentation report experiments pentium ghz system running redhat linux kernel gnu compiler version 
geometric operations incircle tests shewchuk adaptive precision geometric predicates 
single precision floating point numbers represent coordinates 
problem setting size results experiments consistent multiple runs 
report ranges results identical runs 
delaunay 
tested implementation data drawn distributions assess memory needs non uniform data sets 
ran tests distributions uniformly random normal line singularity 
details distributions 
report number extra overflow byte blocks store delaunay meshes various point distributions runtime implementation 
seen runtime varies number extra blocks varies 
furthermore number extra blocks comes number default blocks needed vertex 
experiments set number extra blocks available number default blocks 
extra blocks fill capacity 
setting total space require mesh bytes vertex bytes triangle 
compare runtime memory usage implementation shewchuk triangle code efficient code reported boissonnat 
report runtime incremental code vs triangle divide conquer incremental implementation 
report total memory codes break memory simplicial mesh point coordinates queue 
just third memory code runs slower triangle divide conquer implementation order magnitude faster triangle incremental implementation 
code memory represent mesh store coordinates queue 
runtime sec triangle divide conquer triangle incremental incremental code problem size elements runtime uniformly random points peak memory mbyte triangle code problem size elements memory uniformly random points memory mbyte total simplicial complex point coordinates queue problem size elements breakdown memory uniformly random points distribution pts bytes time uniform normal line uniform normal line number bytes needed occupied blocks store tetrahedral delaunay meshes various point distributions runtime implementation 
delaunay 
tested implementation point distributions 
structure allocate memory blocks different size 
compare memory needs various point distribution report number bytes store occupied blocks 
runtimes differ memory needed nearly independent distribution 
distributions tested meshes contained roughly tetrahedra vertex 
compare implementation uniform random data shewchuk pyramid code figures show runtime memory usage 
breaks memory usage code 
comparison implementation runs slightly faster uses third memory 
representation mesh uses total memory bytes tetrahedron slightly bytes vertex distribution tested point coordinates queue account respectively 
delaunay refinement 
delaunay refinement code compare runtime memory pure delaunay code shown figures 
figures show problem size terms final number faces mesh 
pure delaunay code points known initially refinement code points known initially generated labeled fly described section 
refine mesh minimum angle runtimes versions identical 
need memory refinement code 
additional memory needed map labels vertices slack point coordinate array level vertex array needed hashing technique 
note version pyramid beta release 
runtime sec pyramid code problem size elements runtime uniformly random points peak memory mbyte pyramid code problem size elements memory uniformly random points memory mbyte total simplicial complex point coordinates queue problem size elements breakdown memory uniformly random points runtime sec pure delaunay delaunay refinement problem size final elements runtime pure delaunay vs delaunay refinement peak memory mbyte pure delaunay delaunay refinement problem size final elements memory pure delaunay vs delaunay refinement discussion representation described alternative external memory core representations mesh factor fitting memory relative standard representation 
representation advantage allows random access mesh significant penalty part standard memory algorithms code just exchanging mesh interface 
conjunction external memory techniques 
large problems representation conjunction external memory techniques 
representation ordering vertices designed local quad oct tree decomposition blocks memory vertices laid ordering nearby vertices mesh appear page 
problem data vertex overflows dictionary structure assigns new block overflow data hash locality 
chapter correct essentially breaking large dictionary vertices array smaller ones vertices 
representation algorithms strong bias accessing mesh locally see amenta choi rote tend spatial locality virtual memory fit physical memory 
generalizations dimensions 
idea storing link dimensional simplex generalizes arbitrary dimension 
compression technique generalizes arbitrary dimension ineffective large dimensions 
size difference codes depends separator sizes turn depends dimension 
choosing effective way select representative subset dimensional simplices depend dimension need considered representation dimensions greater 
done experimentation analyze effectiveness techniques dimensions greater compare representations representations 
vertex relabeling schemes 
system cuts relabeling vertices effective crude 
improved child flipping optimization discussed chapter 
essentially making cut relabeling algorithm information past cuts decide side cut receive higher part label space 
improvement involve labeling vertices hilbert curve 
experimented briefly hilbert curve library relabel vertices relabeling time required great compared increase compression provided 
authors able successfully hilbert curve relabel vertices tetrahedral mesh locality 
point location 
addition hilbert curves describe technique rapid point location locality vertex labels 
find tetrahedron containing vertex locate nearest point hilbert space walk mesh destination 
mesh structure locality vertex labels possible combine technique produce savings time points allow point location space queue replaced compact structure 
grateful jonathan shewchuk commenting letting pre release version pyramid 
done part project project members contributed ideas 
chapter compact parallel delaunay tetrahedralization chapter compact data structure representing meshes accompanied sequential algorithm structure delaunay triangulation 
chapter show parallelize algorithm 
describe changes algorithm data structure 
case experimental results 
increase problem size number processors factor vertex insertion rate increases factor 
call speedup measurement runs different job sizes algorithm performs log distributions test 
amount performed processor run times greater amount performed processor run ratio underestimates somewhat actual speedup algorithm 
results useful applications dealing large meshes 
example quake project hexahedral meshes size grid points 
application uses core algorithm generate mesh uses decrease number elements mesh 
structure manipulate tetrahedral meshes size main memory processors generated mesh containing vertices tetrahedra seconds gb ram 
vertices chosen uniformly random unit cube 
compactness data structure preserved structure chapter bytes vertex mesh data structure uses bytes vertex counting overhead faster decoding synchronization 
addition space vertex coordinates bytes vertex temporary storage meshing algorithm bytes vertex total memory footprint algorithm bytes vertex 
significant improvement standard representations require bytes vertex just meshing data 
algorithm construct delaunay mesh set points generalization delaunay refinement described sequential version apply parallel case 
tested algorithm uniform gaussian line singularity distributions see details 
distributions time space usage nearly independent distribution 
tested algorithm real world data set grid points quake project 
fact vertices grid points posed challenges application able overcome small random perturbations 
algorithm shared memory parallel version incremental insertion algorithm chapter 
review course algorithm delaunay triangulation current maintained 
incremental step inserts new vertex mesh determining elements violate delaunay condition 
idea clarkson shor maintain association vertices tetrahedra containing vertices 
keep queue tetrahedra interiors contain points threads draw tetrahedra random queue processing 
threads lock pieces mesh prepare insert vertex thread unable obtain lock aborts insertion draws different job queue 
implemented optimizations improve parallel performance algorithm 
particular bootstrap algorithm growing mesh sequentially pyramid algorithm shewchuk sufficiently large avoid excessive contention threads 
run parallel point location associate vertices simplices mesh 
main incremental algorithm begins point location step complete 
information data structure stored vertex label difference coding compression 
improve quality difference coding preprocess input vertices relabeling cuts vertices close spatially similar labels 
basic data structure variant representation section 
structure modified improve data locality divided groups vertices hashing performed group 
edge stored hashtable corresponding group containing 
groups locked individually prevent concurrent access multiple threads 
chapter describe changes parallelize algorithm 
discuss locking mechanism means decreasing contention threads locks 
experimental results section results running algorithm varying queueing disciplines varying point distributions 
analyze speedup time space efficiency algorithm processors 
related 
significant previous parallel delaunay algorithms main approaches avoid conflicts threads 
approach divide conquer mesh recursively partitioned regions partition built separate processor 
border regions constructed separately 
aggarwal described algorithm constructed border joining regions built 
chen described algorithm assigned certain points regions resulted duplicate meant joining regions involved discarding duplicate triangles 
blelloch lee describe algorithm projects points paraboloid compute lower convex hull derive border building regions 
algorithms dimensions 
second technique parallel delaunay meshes involves incremental insertion bowyer watson kernel 
algorithms incremental insertion avoid collisions assigning region mesh processor 
operations involving multiple regions mesh handled messagepassing processors 
technique necessary perform load balancing regions ensuring region border small 
done 
region processor technique nave produce parallel algorithm message passing architecture 
detail involved minimizing latency interprocessor communication problem avoid concern shared memory machine 
greater scale largest mesh times larger theirs 
describe incremental insertion algorithm assign region processor processors draw global queue similar 
report speedup processors 
algorithm uses dag data structure point location algorithm associates points tetrahedra save memory 
give survey related 
consider space efficiency representations 
compact dynamic mesh representation know described chapter 
compressed meshes 
considerable involving compressed meshes 
dimensions methods compress tetrahedral mesh byte tetrahedron bytes vertex including vertex coordinates 
techniques designed storing meshes disk reducing transmission time representing mesh main memory 
support dynamic queries updates mesh compressed form 
option handling larger meshes maintain mesh external memory 
avoid thrashing requires designing algorithms access mesh carefully orchestrated 
external memory algorithms designed 
particular note bucketed randomized insertion order scheme amenta improves memory locality core tetrahedralization algorithm altering insertion order vertices 
insertion order combine form improved core algorithm compressed data structures strong memory locality 
discuss section 
algorithm sequential version algorithm described detail chapter summarize 
locality 
purposes involving compression quality locality memory access important ensure vertices close spatially share edges mesh similar labels 
ensure preprocessing step relabeled vertices cuts 
set points algorithm finds axes greatest diameter 
finds approximate median diameter partitions points median 
points side labeled points side 
done recursively parallel produce labeling points near similar labels 
similar separator technique graph relabeling section occurs edges added graph 
vertices known algorithm begins algorithm assign sparse labeling initial vertices 
new vertex added assigned label close labels neighbors 
previous results delaunay refinement algorithm technique algorithm parallel straightforward fashion 
sequential insertion 
employ known bowyer watson kernel incrementally generate mesh 
algorithm maintains delaunay triangulation current times 
incremental step inserts new vertex mesh determining elements violate delaunay condition 
elements form delaunay cavity 
faces bound cavity called horizon 
mesh modified removing elements cavity connecting new vertex horizon 
achieve optimal runtime bounds idea clarkson shor maintain association point inserted mesh tetrahedron tp contains search cavity starts tp 
tetrahedron keep data indicating points contained 
maintain queue tetrahedra contain points 
step algorithm draws tetrahedron front queue 
algorithm checks tetrahedron mesh update deleted tetrahedron added queue 
algorithm extracts point tetrahedron performs insertion 
uses idea described points cavity new tetrahedra 
new tetrahedra contain points added back queue 
algorithm expected log runtime elements insertion picked random 
parallel version 
parallel version algorithm sequential version thread draws queue 
avoid overlapping reads writes threads data locks ways mesh queue 
data locks test locks wait locks thread fails acquire lock aborts operation waiting lock free 
meshing data structure stores edges variable bit length dictionary structure described section 
improve memory locality vertices divided groups size vertex group hashtable store edge data 
experiments 
vertex group store lock thread may access group time 
space cost lock amortized vertices group 
thread explores cavity point secures lock vertex encounters 
recall vertices relabeled vertices similar labels close vertices cavity may share locks 
thread encounters vertex locked thread aborts insertion releases locks returns tetrahedron queue 
thread secured locks cavity performs insertion normal releases locks finished 
queue secured locks prevent concurrent access 
parallel version processors queue contains 
experimented queue configurations see section details 
separate lock thread accesses queue probes random acquires lock 
thread operates queue adding number tetrahedra processed randomly extracting tetrahedron processing releases lock 
rare cases may necessary thread allocate memory calls malloc 
example needed hashtable overflows 
thread wait acquires global lock 
time algorithm thread waits acquire lock 
contention 
mesh small compared number threads operating danger contention multiple threads may compete vertices long time thread able acquire vertex locks perform insertion certain area mesh 
may result large tetrahedra remaining untouched vertices areas mesh fine resolution 
thread acquires locks handle tetrahedron associated cavity large 
addition obvious inefficiencies space required hold full cavity cache considerable places strain caching memory allocation structures undesirable 
easy solution contention problem hold threads back start algorithm 
experimentally find restricting density threads vertices mesh sufficient eliminate contention entirely 
unfortunately causes types slowdown initial vertex insertions thread active mesh 
see problem consider time complexity vertex insertion 
assume finding cavity vertex requires constant time insertion 
case bounded degree meshes absence contention 
random data example cavity contains average tetrahedra 
algorithm perform tests vertices lay deleted tetrahedra 
vertices inserted expected vertices insertion require tests 
particular insertion performed requires tests vertices 
performing tests thread inefficient 
bootstrapping pyramid 
run algorithm parallel need build mesh sufficiently large threads 
separate tetrahedralization algorithm serial pyramid algorithm shewchuk 
algorithm different associate vertices tetrahedra insert vertex walks mesh plane side tests locate tetrahedron contain bootstrapping algorithm works follows 
vertices processors relabel vertices cuts standard algorithm 
sample vertices insertion pyramid 
perform sampling random labels assigned cuts sample evenly spaced intervals 
produces evenly spaced distribution 
pyramid mesh data structure built perform point location remaining vertices associate tetrahedra mesh 
processor performs point location contiguous block vertices 
involve modifying mesh produces conflicts threads 
shewchuk point location routine allows walk tetrahedron mesh 
vertices high spatial locality due reordering cuts walk vertex tetrahedron contained vertex 
cost point location quite low 
vertices mapped tetrahedra pyramid mesh structure deallocated 
queue allocated tetrahedra inserted 
space pyramid reused queue add total space cost algorithm 
parallel insertion algorithm begins normal 
tradeoff insertion vertices shewchuk mesh walking code code 
total points points inserted mesh inserting vertex code requires spent tests points cavity new tetrahedra 
cost insertion pyramid serial time equivalent pk 
optimize performance select costs balanced 
solving expression pk yields experimental setup valid 
experimentally find best performance 
processors initial mesh needs roughly vertices avoid contention 
accordingly bootstrapping vertices tests 
cleanup 
algorithm nears termination may occur region mesh contains vertices 
case algorithm may encounter contention 
prevent threads leave mesh number remaining vertices decreases thread leaves mesh fewer vertices remain 
insertions quite rapid involve tests cause significant slowdown 
data structure summarize data structure represent meshes 
structure adapted chapter 
modifications 
hash edges structure explicitly 
previous implementation stored pointer edge bucket corresponding vertex 
new data structure hashes full edge described section 
second divide hashtable groups containing data vertices assign data lock group 
third simplified memory allocation system 
representation chapter system allocated memory blocks size bytes depending space required 
new representation allocates fixed length blocks size bytes 
fourth take special care avoid thread contention memory pages allocating data vertex group contiguous memory 
data structure supports operations add adds oriented tetrahedron mesh associated data application label point contained tetrahedron 
find searches mesh tetrahedron containing oriented triangle 
returns associated delete deletes tetrahedron mesh 
lock attempts lock vertex returns boolean indicating success failure 
unlock releases locks owned calling thread 
sequential version algorithm structure stores link set edges simplices 
link edge oriented cycle vertices connect endpoints edge see example 
edges stored edges vertices having odd parity kept dictionary structure 
permits resolve find queries triangle contain edge 
edges stored direction determined hash function 
vertices link edge stored vertex label compressed difference coding respect difference code byte aligned code section :10.1.1.51.7802
chose code rapid encode decode described section 
data tetrahedron stored described section 
application data label point contained tetrahedron 
data difference encoded respect codes data vertices edge link concatenated 
resulting bit string stored variable bit dictionary structure described section 
points 
may occur tetrahedron contains point 
represent points linked list 
keep array point contained tetrahedron index point tetrahedron point 
point list stored tetrahedron mesh data structure 
memory locality 
environment multiple threads accessing data structure important ensure memory accesses involved query go small set cache lines 
hashtables notoriously poor memory locality address divide vertices vertex groups size 
experiments 
vertex group allocated hashtable neighborhood corresponding difference code data edge 
entry degree vertex 
entries offsets neighbors 
variable bit length dictionary data associated hashtable kept contiguous block 
rare cases hashtable may require resizing case additional memory allocated 
settings chose happens roughly time 
edges stored hashtable corresponding vertex 
hashtable data keep data lock shared vertices vertex group thread acquire lock order read write hashtable 
caching 
improve efficiency lookups implementation uses caching system 
query update codes associated appropriate edge decoded 
information represented uncompressed form linked list listnode vertex link edge 
lists kept cache specific thread performing query update 
update operations may affect lists cache 
part update application may delete simplices producing holes mesh maintain invariant edge links written cache full cycles 
cache flushed new vertex insertion complete 
experimentation experimental setup 
ran experiments psc edu pair hp gs smp machines ghz ev processors 
operating system tru unix 
openmp library provide parallel functionality 
code written compiled fast arch ev tune ev omp 
gbytes ram available processor 
space usage discussed sufficient build mesh vertices processor 
processors total runtime parallel loop sec sec sec init fails dig fails rep fails table performance measurements processor algorithm 
inserted vertices processor 
exact arithmetic predicates shewchuk geometric tests 
additionally beta version shewchuk pyramid code bootstrap main parallel algorithm 
main results 
ran algorithm points uniform distribution processors 
cases points processor 
fixed amount bootstrapping vertices run 
processor case algorithm took seconds average vertices second 
processor case algorithm averaged vertices second processor 
vertex insertion rate increased factor 
ratio underestimates speedup algorithm amount vertex inserted log distributions test 
accounting discrepancy get speedup 
decompose runtime algorithm factors see table 
total runtime listed includes steps algorithm reordering termination 
time measurement includes parallel loop bootstrapping reordering initialization phases 
convenience analysis divide parallel loop stages involves inserting total 
note involves slightly fewer insertions include vertices bootstrapping 
give number vertices inserted processor second 
higher cost earlier steps due large amount point location performed steps 
give measures contention 
lock failure classed initialization failure thread fails obtain lock vertices initial tetrahedron dig failure thread fails obtain lock subsequent vertex performing insertion 
failure occurs immediately previous failure classed repeat failure 
give average number type failure processor 
processor run inserted points producing tetrahedra 
far know largest tetrahedral delaunay mesh generated 
init rep maximum runtime discipline fails fails queue size main loop fifo fifo qr qr rand rand table impact various queueing disciplines algorithm vertices processors 
queueing disciplines 
algorithm central queue threads draw tetrahedra processing 
avoid concurrency issues queue divided number thread wishes access queue chooses randomly finds 
discuss issues involved design queue 
considered possible queueing disciplines queue 
considered standard fifo queueing discipline 
concern algorithm completion insertion threads may add queue large number tetrahedra share vertex newly inserted point 
threads attempt handle tetrahedra resulting single push threads encounter locked vertices abandon job 
second discipline considered random queue rand tetrahedra added tail queue extracted random point queue 
ensured threads access patterns random 
unfortunately experimentally led larger queue sizes fifo queue large numbers garbage tetrahedra longer existed mesh collected queue removed near algorithm 
third option considered queue random discipline qr compromise disciplines 
thread initially attempt draw tetrahedron front queue tetrahedron failed due contention thread draw random point queue 
addition experimenting various queueing disciplines performed experiments varying numbers queue 
fifo queueing discipline problem occurred multiple threads accessed short amount time increasing number hoped event 
processors experimented 
results experiments shown table 
classify lock failures initial failures repeat failures depending thread encountered lock failure just prior current 
increase failures fifo queueing discipline quite dramatic increase queue size random disciplines equally 
corresponding increase runtime fairly small failures occurred significant performed 
chose minimize space processor vertices additional distribution time bytes uniform normal line processors vertices additional distribution time bytes uniform normal line table space time required algorithm various distributions 
queue experiments fifo queueing discipline 
space usage 
algorithm allocates space purposes 
vertex coordinates bytes vertex byte floating point values 
array link vertices tetrahedron uses bytes vertex 
queue allocate entries vertex containing integers total bytes vertex 
find fourth vertex tetrahedron algorithm performs lookup 
mesh structure divides vertices groups group allocates structure bytes bytes vertex 
includes blocks memory storing difference codes byte block byte blocks vertex described section structures handle allocation memory pointer additional block memory necessary 
includes data lock 
hashtable group overflows additional memory allocated heap 
chose settings occurs groups tests table overflow larger input sizes 
cost additional bytes vertex 
algorithm allocates fixed size structures caches pools linked list nodes memory negligible 
total space cost algorithm bytes vertex meaning tetrahedron computation gb ram 
point distributions 
tested algorithm different distributions data including uniform gaussian line singularity distributions 
details distributions 
distribution ran vertices processor vertices processors 
computed total runtime required number additional bytes memory vertex allocated 
numbers addition bytes vertex required cases 
results shown table 
ran tests real world data set grid points octree decomposition generated quake project 
problem computing tetrahedral mesh grid points proved difficult algorithm designed handle perfectly flat tetrahedra result vertices lie vertices square 
handle introduced small random perturbations added small random value coordinate vertex 
doing encountered difficulty tetrahedralization 
insertion random boundary contention time perturbation size rep fails sec fully random contention aborted table performance algorithm fully random points unit cube versus points derived quake project 
points provided large boundary resulting contention lock bounding vertices 
adding randomness point locations boundary visible boundary vertices making problem tractable 
algorithm begins single tetrahedron artificial boundary vertices chosen tetrahedron contains points inserted 
points inserted vertices connect boundary mesh 
random distributions tested pose problem boundary mesh vertices 
octree decomposition data boundary mesh larger 
degree vertices grew large significant contention processors attempting perform insertions near boundary mesh 
decreased performance algorithm considerably 
able solve problem adding randomness points 
smallest distance points octree decomposition data units added random value vertex coordinate 
doing decreased boundary mesh reasonable size 
results shown table 
interesting feature octree decomposition data labeling 
random data preprocessing step algorithm points cuts described section 
octree decomposition data step unnecessary points came preordered labeling produced compression superior relabeling algorithm provided 
uniformly random points reordering mesh data vertices required blocks edge data 
octree points reordering mesh data required blocks edge data 
octree points reordering mesh data required blocks left hashtables somewhat 
accordingly results table labeling provided data 
core algorithms 
algorithm data structure extended core setting vertices relabeled locality memory accesses insertion close 
keeping representation compressed means fit ram 
unfortunately algorithm described performs insertions random order 
improved biased randomized insertion order provide locality insertions 
queues algorithm need replaced series log groups queues level 
high degree meshes 
shown algorithm behaves distributions long maximum degree vertex bounded 
mesh contains vertices high degree octree decomposition data discussed section competing threads suffer contention high degree vertices 
experimentally code tolerant vertices total degree total vertices shared processors performance suffers degree grows larger 
part problem coarse grained locking mechanism divide data structure hashtables force threads lock hashtable access 
allocate hashtable vertices store data edge hashtable corresponding vertices 
require thread acquire lock vertices adjoining cavity performing update 
correctness necessary lock edges adjoining cavity vertices 
conservative locking mechanism able exploit tolerate high degree vertices 
necessary distribute edges high degree vertex evenly hashtables sacrifice memory locality properties representation 
improvement exist meshes vertices high degree 
clear parallel incremental insertion algorithm handle meshes efficiently 
chapter bibliography adler mitzenmacher 
compressing web graphs 
data compression conference dcc pages 
aggarwal chazelle guibas yap 
parallel computational geometry 
algorithmica 
alpert 
circuit benchmark suite 
acm international symposium physical design pages apr 
alpert kahng 
directions netlist partitioning survey 
vlsi journal 
amenta choi rote 
incremental constructions con 
proc 
acm symposium computational geometry june 
aragon seidel 
randomized search trees 
proceedings th annual symposium foundations computer science pages 
arge 
external memory data structures 
proc 
european symposium algorithms pages 
baker 
list processing real time serial computer 
communications acm 

polyhedron representation computer vision 
proc 
national computer conference pages 
benoit demaine munro raman 
representing trees higher degree 
wads pages 
blanco 
document identifier reassignment dimensionality reduction 
ecir pages 
blandford blelloch 
index compression document reordering 
data compression conference dcc pages 
blandford blelloch 
compact representations ordered sets 
soda pages 
blandford blelloch 
compact representations simplicial meshes dimensions 
international meshing roundtable pages sept 
blandford blelloch 
compact representations separable graphs 
proceedings annual acm siam symposium discrete algorithms pages 
blandford blelloch 
experimental analysis compact graph representation 

blandford blelloch 
dictionaries variable length keys data applications 
symposium discrete algorithms 
blelloch burch crary harper miller 
persistent triangulations 
journal functional programming sept 
blelloch miller 
design implementation practical parallel delaunay algorithm 
algorithmica 
blelloch maggs woo 
space efficient finger search degree balanced search trees 
soda pages 

boissonnat devillers 
triangulations cgal 
computational geometry 
boldi vigna 
framework compression techniques 
bookstein klein 
modeling word occurrences compression concordances 
proc 
ieee data compression conference page mar 
borodin ostrovsky rabani 
subquadratic approximation algorithms clustering problems high dimensional spaces 
acm symposium theory computing pages july 
bowyer 
computing dirichlet tessellations 
computer journal 

representing geometric structures dimensions topology order 
proc 
acm symposium computational geometry pages 
broder glassman manasse zweig 
syntactic clustering web 
sixth int world wide web conference pages cambridge july 
broder kumar maghoul raghavan rajagopalan stata tomkins wiener 
graph structure web 
www computer networks 
munro 
membership constant time minimum space 
siam journal computing 
buchsbaum tarjan 
data structural bootstrapping linear path compression catenable heap ordered double ended queues 
proc 
rd ieee symp 
foundations computer science pages 
carlsson levcopoulos petersson 
sublinear merging natural merge sort 
proceedings international symposium algorithms sigal pages tokyo japan aug 
carter wegman 
universal classes hash functions 
journal computer system sciences pages 
chakrabarti papadimitriou modha faloutsos 
fully automatic cross associations 
proceedings tenth acm sigkdd international conference knowledge discovery data mining 
chakrabarti zhan blandford faloutsos blelloch 
new mining tools large graphs 
sdm workshop link analysis counter terrorism privacy 
chen chuang wu 
efficient parallel implementations delaunay triangulation high performance fortran 
proceedings th siam conference parallel processing scientific computing 
chilimbi hill larus 
cache conscious structure layout 
proceedings acm sigplan conference programming language design implementation pages 
nave 
simultaneous mesh generation partitioning delaunay meshes 
proceedings eighth international meshing roundtable pages 
nave 
parallel delaunay mesh generation kernel 
international journal numerical methods engineering 

task parallel implementation bowyer watson algorithm 
proceedings fifth international conference numerical grid generation computational fluid dynamic related fields 

chuang garg 
kao 
lu 
compact encodings planar graphs canonical orderings multiple parentheses 
lecture notes computer science 
clarkson shor 
applications random sampling computational geometry ii 
discrete computational geometry 
cleary 
compact hash tables bidirectional linear probing 
ieee trans 
comput 
ferragina mehlhorn meyer ramos 
randomized external memory algorithms geometric problems 
proc 
acm symposium computational geometry pages june 
deering 
geometry compression 
proc 
siggraph pages 
dehne hutchinson maheshwari dittrich 
reducing complexity simulating coarse grained parallel algorithms 
proc 
ipps spdp pages 
deo 
structural approach graph compression 
mfcs workshop communications 
dietzfelbinger karlin mehlhorn auf der heide rohnert tarjan 
dynamic perfect hashing upper lower bounds 
siam comput 
dobkin laszlo 
primitives manipulation dimensional subdivisions 
algorithmica 
edelsbrunner 
geometry topology mesh generation 
cambridge univ press england 
elias 
universal codeword sets representations integers 
ieee transactions information theory march 
pagh sanders spirakis 
space efficient hash tables worst case constant access time 
stacs 
fredman 
storing sparse table worst case access time 
jacm 

devillers 
progressive lossless compression arbitrary simplicial complexes 
proc 
siggraph 
golomb 
run length encodings 
ieee transactions information theory july 
goodrich 
vitter 
external memory computational geometry 
proc 
ieee symposium foundations computer science pages nov 
google 
google programming contest web data 
www google com programming contest 
grossi vitter 
compressed suffix arrays suffix trees applications text indexing string matching 
focs pages 
gu 
harvard graphics archive mesh library 
www cs deas harvard edu mesh 
guibas stolfi 
primitives manipulation general subdivisions computation voronoi diagrams 
acm transactions graphics 
guibas sedgewick 
dichromatic framework balanced trees 
proc 
th ieee symposium foundations computer science pages 

real time compression triangle mesh connectivity 
proc 
siggraph pages 
han 
tseng 
comparison locality transformations irregular codes 
proc 
languages compilers run time systems scalable computers pages 

implementation evaluation efficient parallel delaunay triangulation algorithm 
proceedings ninth annual symposium parallel algorithm architectures 

kao 
lu 
linear time succinct encodings planar graphs canonical orderings 
siam discrete mathematics 

kao 
lu 
fast general methodology information theoretically optimal encodings graphs 
siam computing 
snoeyink 
face compressing polygon meshes properties 
proc 
siggraph pages 
project 
www cs cmu edu 
jacobson 
space efficient static trees graphs 
th focs pages 
kaplan tarjan 
purely functional representations catenable sorted lists 
proc 
th annual acm symposium theory computing pages may 
gotsman 
spectral compression mesh geometry 
proc 
siggraph pages 
karypis kumar 
fast high quality multilevel scheme partitioning irregular graphs 
technical report tr international computer science institute 
keeler westbrook 
short encodings planar graphs maps 
discrete applied mathematics 
kettner 
generic programming designing data structure polyhedral surfaces 
computational geometry theory applications 
knuth 
sorting searching volume art computer programming 
addison wesley publishing reading ma 

practically oriented parallel delaunay triangulation computers shared memory 
computers graphics 

optimistic parallel delaunay triangulation 
visual computer 
lee park park 
improved parallel algorithm delaunay triangulation distributed memory parallel computers 
parallel processing letters 
leighton rao 
approximate max flow min cut theorem uniform multicommodity flow problems applications approximation algorithms 
focs pages 

dimensional generalized combinatorial maps cellular quasi manifolds 
international journal computational geometry applications 
lipton rose tarjan 
generalized nested dissection 
siam journal numerical analysis 
lipton tarjan 
separator theorem planar graphs 
siam applied mathematics 

lu 
linear time compression bounded genus graphs information theoretically optimal number bits 
soda pages 
hellerstein 
core build topological data structure polygon soup 
proc 
symposium solid modeling applications pages june 
mehlhorn 
leda platform combinatorial geometric computing 
cambridge university press 
miller 
teng thurston vavasis 
separators sphere packings nearest neighbor graphs 
journal acm 
moffat petersson wormald 
tree mergesort 
acta informatica 
moffat 
exploiting clustering inverted file compression 
proc 
data compression conference pages mar 
moffat 
binary interpolative coding effective index compression 
information retrieval july 
muller preparata 
finding intersection convex polyhedra 
theoretical computer science 
munro 
tables 
th fst tcs volume lncs pages 
springer verlag 
munro raman :10.1.1.37.6762
succinct representation balanced parentheses static trees planar graphs 
th focs pages 
naor 
succinct representation general unlabeled graphs 
discrete applied mathematics 

parallel unstructured mesh generation 
amd 
openmp 
www openmp org 
page brin motwani winograd 
pagerank citation ranking bringing order web 
technical report stanford digital library technologies project 
pagh 
low redundancy static dictionaries constant query time 
siam journal computing 
pagh 
cuckoo hashing 
esa 
rossignac 
implant compression progressive tetrahedral mesh connectivity 
proc 
visualization pages 
ailamaki lopez tu hallaron 
efficient query processing unstructured tetrahedral meshes 
pugh 
skip lists probabilistic alternative balanced trees 
workshop algorithms data structures pages 
rachel psc edu 
www psc edu machines marvel rachel html 
raman raman rao 
succinct indexable dictionaries applications encoding ary trees multisets 
soda 
raman rao 
succinct dynamic dictionaries trees 
icalp pages 
rosenberg heath 
graph separators applications 
kluwer academic plenum publishers 
rossignac 
connectivity compression triangle meshes 
ieee transactions visualization computer graphics 
ruppert 
delaunay refinement algorithm quality dimensional mesh generation 
algorithms 
scan project 
internet maps 
www isi edu scan mercator maps html 
seidel aragon 
randomized search trees 
algorithmica 
shewchuk 
pyramid mesh generator software 
www cs berkeley edu 
personal communication 
shewchuk 
triangle engineering quality mesh generator delaunay 
proc 
workshop applied computational geometry pages philadelphia pa may 
shewchuk 
adaptive precision floating point arithmetic fast robust geometric predicates 
discrete computational geometry 
shi malik 
normalized cuts image segmentation 
ieee transactions pattern analysis machine intelligence 


chen 

chung 
inverted file compression document identifier reassignment 
inf 
process 
manage 
silicon graphics 
standard template library 
www sgi com tech stl index html 
orlando 
assigning document identifiers enhance compressibility web search engines indexes 
sac proceedings acm symposium applied computing pages new york ny usa 
acm press 
simon 
partitioning unstructured problems parallel processing 
computing systems engineering 

development maintenance tiger database experiences spatial data sharing bureau census 
sharing geographic information pages 
strehl ghosh 
scalable approach balanced high dimensional clustering market baskets 
proceedings th international conference high performance computing pages london uk 
springer verlag 
suel yuan 
compressing graph structure web 
data compression conference dcc pages 
rossignac 
grow fold compressing connectivity tetrahedral meshes 
computer aided design 
taubin rossignac 
geometric compression topological surgery 
acm transactions graphics 
toledo 
improving memory system performance sparse matrix vector multiplication 
ibm journal research development 
tu hallaron 
computational database system generating unstructured hexahedral meshes billions elements 
proceedings sc 
tu hallaron lopez 
database oriented method generating large octree meshes 
proc 
international meshing roundtable pages sept 
tur succinct representations graphs 
discrete applied mathematics 
ullman 
computational aspects vlsi 
computer science press rockville md 
census bureau 
ua census tiger line file download page 
www census gov geo www tiger ua html 
vitter 
external memory algorithms data structures dealing massive data 
acm computing surveys june 
voorhees harman 
overview eighth text retrieval conference trec 
proceedings eighth text retrieval conference trec pages 
walshaw 
graph partitioning archive 
www gre ac uk walshaw partition 
watson 
computing dimensional delaunay tesselation application voronoi polytopes 
computer journal 
watts strogatz 
collective dynamics small world networks 
nature 
weiler 
edge data structures solid modeling curved surface environment 
ieee computer graphics applications jan 
weiler 
radial edge structure topological representation non manifold geometric boundary modeling 
geometric modeling cad applications pages 
north holland 
wishart 
efficient hierarchical cluster analysis data mining knowledge discovery 
computer science statistics july 
witten moffat bell :10.1.1.51.7802
managing gigabytes compressing indexing documents images second edition 
morgan kaufmann publishing san francisco 

