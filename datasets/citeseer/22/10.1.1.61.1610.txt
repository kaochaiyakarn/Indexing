open modules modular reasoning advice jonathan aldrich carnegie mellon university pittsburgh pa usa jonathan aldrich cs cmu edu 
advice mechanism advanced object oriented aspect oriented programming languages augment behavior methods program 
advice help programs modular separating crosscutting concerns effectively challenges existing ideas modularity separate development 
study challenge new simple formal model advice appears languages aspectj 
add module system designed leave program functionality open extension advice possible enabling separate reasoning code module 
system open modules directly facilitate separate component development viewed model features certain aop ides provide 
define formal system reasoning observational equivalence programs advice show clients unaffected semantics preserving changes module implementation 
model yields insights nature modularity presence advice provides mechanism enforceable contracts component providers clients setting suggests improvements current aop ides 
modularity advice common lisp object system introduced construct called advice allows developer externally augment behavior method 
advice comes flavors advice run execution method body advice wraps method body advice runs method body 
general advice view change parameters result method control method body executed allowing rich set adaptations implemented mechanism 
examines advice context aspect oriented programming aop widely application advice today 
goal aop modularize concerns crosscut primary decomposition software system 
aop systems allow developers modularize crosscutting concerns single locally defined module advice mechanism allow definitions module affect methods defined system 
aop general advice particular provide benefits reasoning concerns scattered tangled code conventional systems questions raised ability reason evolve code subject advice 
advice appears reasoning effect calling method challenging example intercept call change semantics 
turn evolving aop systems tool support error prone seemingly innocuous changes base code break functionality aspect advises code 
example important issue separate development ensuring improvements bug fixes third party component integrated application breaking application 
unfortunately developer component know deployed change potentially break fragile pointcuts client solve problem prohibiting advice third party components prefer compromise answers research question 
developers specify interface library component permits uses advice possible allowing component changed meaningful ways affecting clients 
important issue protecting internal invariants component implementations presence advice 
example consider java standard library carefully designed provide sandbox security model running untrusted code 
general unsafe user load code advises standard library advice attacker bypass sandbox 
possible solution ensuring security java library prohibit advice standard library 
unfortunately rule prohibit useful applications advice 
better solution problem allow advice possible preserving internal invariants java standard library 
formal model modularity address second research question 
developers specify interface library component permits uses advice possible ensuring correctness properties component implementation 
research questions imply solution prohibits certain uses advice case separate development 
practice applications may able reuse library component get prohibitions 
think option developers conscious choice developer know writing aspect may break new version component released writing aspect resilient new releases 
similarly user uploading code know code includes advice guaranteed violate java sandbox code contains advice violate sandbox ought signed trusted principal 
research aimed providing developers users informed choices 
outline contributions section describes open modules novel module system advice provides informal answers research questions 
open modules module system supports beneficial uses advice ensuring security properties component implementation maintained verifying advice component affected behavior preserving changes component implementation 
answers precise section proposes tinyaspect novel formal model aop languages captures core advice constructs omitting complicating details 
section extends tinyaspect open modules precisely defining semantics typing rules system 
section describes formal system reasoning observational equivalence modules presence advice 
result show complete behavioral equivalence reasoning done module basis system advice providing precise answer research question 
precisely defines changes component affecting clients answering research questions 
section discusses lessons learned formal model 
section describes related section concludes 
open modules propose open modules new module system languages advice intended open extension advice modular implementation details module hidden 
goals openness modularity tension case separate development try achieve compromise 
aop systems advice way reach module boundaries capture crosscutting concerns 
propose adopt advice constructs limit respect module boundaries 
order capture concerns crosscut boundary module aop pointcut abstraction represent sets events external modules may interested advising 
suggested kiczales exported pointcuts form contract module client aspects allowing module evolved independently clients long contract preserved 
shows conceptual view open modules 
ordinary module systems open modules export list data structures functions animate 
addition open modules export pointcuts denoting internal semantic events 
example moves pointcut void int int void animate motion pointcut moves package shape fig 

conceptual view open modules 
shape module exports functions pointcut 
clients place advice external calls exported functions exported pointcut calls internal module 
triggered shape moves 
shape move multiple times execution animate function clients interested fine grained motion information want pointcut just placing advice calls animate 
exporting pointcut module maintainer making promise maintain semantics pointcut module implementation evolves just maintainer maintain semantics module exported functions 
open modules open respects 
interfaces open advice calls interface functions outside module advised clients 
second clients advise exported pointcuts 
hand open modules encapsulate internal implementation details module 
usual module systems functions exported module public interface called outside module 
addition case separate development calls functions module advised outside called function public interface module 
example client place advice external calls calls function shape module 
concurrent kiczales mezini propose notion aspect aware interfaces ordinary functional interfaces augmented information advice applies module 
point local development setting analysis tools aspectj plugin eclipse compute aspect aware interfaces automatically program information 
shows case local development tool support benefits open modules attained restrictions aspects 
aspect depends internal calls defined tools simply add new pointcut module aspect aware interface new aspect conforms rules open modules 
provide canonical definition open modules distinguish contribution previous definition open modules open modules describes module system allows external advice interactions module outside world including external calls functions interface module allows external advice pointcuts interface module allow external modules directly advise internal events module calls module functions module including calls exported functions 
formally modeling advice order reason formally precisely modularity need formal model advice 
attractive models purpose operational semantics provide simple direct formalization amenable standard syntactic proof techniques 
jagadeesan proposed operational semantics core aspectj incorporating different kinds pointcuts advice objectoriented setting 
model rich ideal specifying semantics full language aspectj 
define prove soundness strong equivalence reasoning framework language doing prohibitively difficult complex model 
walker propose simpler formal model incorporating just lambda calculus advice labeled hooks describe advice may apply 
foundational calculus model ideal studying compilation strategies aop languages 
model low level lacks essential characteristics advice aop including obliviousness property advice applies explicit labels 
low level nature language means certain properties source level languages aspectj including modularity properties study hold calculus 
previous small step operational models aspects inappropriate purposes 
tinyaspect developed new functional core language aspect oriented programming called tinyaspect 
tinyaspect language intentionally small making feasible rigorously prove strong properties soundness logical equivalence section 
tinyaspect leaves features full languages directly model advice constructs similar aspectj 
model retains declarative nature oblivious properties advice existing aop languages helping ensure techniques developed model extended full languages 
names expressions fn declarations val pointcut pointcuts call general exp types unit decl 
types pcut 
types pc general types fig 

tinyaspect source syntax focused studying modular reasoning advice omit powerful pointcut constructs aop languages aspectj 
include simple pointcuts representing calls particular function order show pointcuts interface module contribute separate reasoning presence advice 
system easily extended forms static pointcuts extension dynamic pointcut language constructs cflow scope 
shows syntax tinyaspect 
syntax modeled ml 
names tinyaspect simple identifiers 
expressions include monomorphic lambda calculus names functions function application 
core add primitive unit expression base case types 
add primitive booleans integers completely standard way constructs encoded lambdas 
constructs orthogonal aspects omit simplicity sake 
aspect oriented programming languages including aspectj pointcut advice constructs second class declarative 
accurate source level model tinyaspect program sequence declarations 
declaration defines scope includes declarations 
declaration empty declaration value binding pointcut binding advice 
val declaration gives static name value may advised declarations 
pointcut declaration names pointcut program text 
pointcut form call refers call function declaration pointcut form just alias previous pointcut declaration declaration names pointcut describing calls function binds variable argument function specifies advice run place original function 
inside body advice special variable proceed bound original value function choose invoke original function desired 
val fib fn int call fib int fib fib proceed advice cache calls fib val fn val fn val fn pointcut call fib int proceed fig 
fibonacci function written tinyaspect aspect caches calls fib 
tinyaspect types include unit type function types form 
syntactically distinguish pointcut types declaration types order enforce second class nature constructs computed functions simulate fully general 
fibonacci caching example illustrate language writing fibonacci function writing simple aspect caches calls function increase performance 
compelling example aspects standard literature simple language 
shows tinyaspect code fibonacci function 
integers booleans statements added illustrate example 
tinyaspect include fixpoint operator defining recursion advice express thing 
fib function define base case ordinary function definition returning 
place advice intercepts calls fib handles recursive cases 
body advice checks see argument greater returns sum fib fib 
recursive calls intercepted advice original function allowing recursion properly 
case argument advice invokes proceed original number scope advice declaration special variable proceed refers advised definition function 
call proceed forwarded original definition fib returns 
lower half aspect caches calls fib allowing normally exponential function run linear time 
assume cache data structure functions checking result cache value looking argument cache storing new argument result pair cache 
caching code reusable declare pointcut names function calls cached expression values fn declaration values dv val dv pointcut call dv evaluation contexts val bind pointcut general values dv call fig 

tinyaspect values contexts case calls fib 
declare advice pointcut checks see argument cache 
advice gets result cache returns 
value cache advice calls proceed calculate result call fib stores result cache returns result 
semantics tinyaspect advice declared declaration invoked 
client calls fib caching advice invoked 
caching advice calls proceed advice recursively defines fib invoked 
advice turn calls proceed original function definition invoked 
advice recursive call fib call intercepted caching advice 
cache works exactly expect invoked recursive calls fib able effectively avoid exponential cost executing fib na way 
operational semantics define semantics tinyaspect precisely set small step reduction rules 
rules translate series source level declarations values shown 
expression level values include unit value functions 
tinyaspect advice applies declarations functions 
crucial modular reasoning result described declarations hidden module interface class functions 
need keep track declaration usage program text declaration represented label 
operational semantics auxiliary environment keeps track advice applied declaration 
pointcut value take form calls particular declaration 
formal system model execution declarations replacing declarations declaration values distinguish symbol binding 
shows contexts reduction may occur 
call value reduction proceeds left hand side application righthand side 
reduction occurs value declaration proceeding declarations 
pointcut declarations atomic define evaluation context declarations follow 
fn app lookup domain val val val pointcut call pointcut call call fn proceed domain call fig 

tinyaspect operational semantics pointcut ctx describes operational semantics tinyaspect 
machine state pair advice environment mapping labels values expression advice environments similar stores keep track mapping declaration labels declaration values modified advice declarations 
notation order look value label denote functional update environment 
reduction judgment form read advice environment expression reduces expression new advice environment rule function application standard replacing application body function substituting argument value formal normally treat labels values rule want avoid looking advised 
position invoke function represented label rule lookup look label value current environment 
rules reduce declarations declaration values val declaration binds value fresh label adds binding current environment 
substitutes label variable subsequent declaration leave binding reduced expression type preservation easier prove easy extend tinyaspect module system need retain bindings 
pointcut declaration simply substitutes pointcut value variable subsequent declaration 
declaration looks advised declaration current environment 
places old value binding fresh label re binds original body advice 
inside advice body special variable proceed replaced refers original value advised declaration 
original var label fn empty fn val val pc proceed call pc unit unit domain app bind pointcut pc fig 

tinyaspect typechecking env declaration redirected advice advice invoke original function calling proceed 
rule shows reduction proceed context defined 
typechecking describes typechecking rules tinyaspect 
typing judgment expressions form read variable context declaration context expression type maps variable names types maps labels types similar store type 
rules expressions standard 
look types variables labels respectively 
standard rules give types expression functions applications 
interesting rules declarations 
give declaration signatures declarations sequence variable type bindings 
base case empty declaration empty signature 
val bindings ensure expression typed type typecheck subsequent declarations assuming bound variable type 
pointcuts similar rule ensures expression typed pointcut denoting calls function type 
val pointcut binding value typing rule subsequent declarations see bound variable substituted 
advice rule checks declared type matches argument type pointcut checks body typed assuming proper types variables proceed 
judgment states formed environment typing values types 
judgment soundness theorem analogous store typings languages 
type soundness state progress preservation theorems 
theorems quantify expressions declarations metavariable quantify types declaration signatures metavariable progress property states expression typed value take step new expression 
theorem progress 
value exists 
proof 
induction derivation type preservation property states expression typed reduces expression new environment new expression environment typed 
theorem type preservation 
exists proof 
induction derivation 
proof relies standard substitution weakening lemmas 
progress type preservation imply type soundness 
soundness means way typed tinyaspect program get stuck go wrong gets bad state 
type soundness theorem slightly stronger previous result walker guarantee type safety lack run time errors 
walker advice lower level exception construct soundness theorem includes possibility program terminate uncaught exception 
formalizing modules extend tinyaspect open modules module system allows programmers enforce abstraction boundary clients implementation module 
module system modeled closely names 
declarations 
structure modules struct functor decl 
types 
module types sig module values mv struct dv functor contexts 
structure struct mv fig 

module system syntax values contexts structure cache functor sig pc int int struct int definition structure math struct val fib fn int call fib int fib fib proceed structure cache struct pointcut call fib sig fib int int fig 
fibonacci open modules ml providing familiar concrete syntax benefiting design advanced module system 
distributed development setting module system places restrictions aspects order provide strong reasoning guarantee section 
local development setting module interfaces computed tools place true restrictions developers 
shows new syntax modules 
names include simple variables qualified names module expression 
declarations include structure bindings types extended module signatures form sig list variable type bindings module signature 
order module expressions include name struct list declarations expression seals module signature hiding elements listed signature 
describes functor takes module signature argument returns structure shape struct val fn val fn val animate fn 
pointcut moves call sig description shape shape location unit animate shape path unit moves pc shape location unit fig 
shape library exposes position change pointcut module may depend functor application written function application form 
fibonacci revisited shows reusable caching aspect defined functors 
cache functor accepts module single element pointcut calls function signature int int 
advice advises pointcut argument module fib function encapsulated inside math module 
module implements caching instantiating cache module structure binds pointcut calls fib 
math module sealed signature exposes fib function clients 
sealing module sealing operation effect type system level operational level 
type level hides members module signature respect similar sealing ml module system 
sealing operational effect hiding internal calls module distributed development setting clients advise module explicitly exports corresponding pointcut 
example clients math module able tell caching applied placed advice math fib 
math sealed external advice math fib invoked external calls function internal recursive calls 
ensures clients affected implementation module changed example adding removing caching 
exposing semantic events pointcuts shows shape example described modeled tinyaspect 
clients shape library advise internal functions module sealed 
allow clients observe internal semantically important events motion animated shapes module exposes events signature moves pointcut 
clients advise pointcut depending internals shape module 
module implementation changed moves pointcut updated client aspects triggered way 
explicitly exposing internal events interface pointcut means loss obliviousness distributed development case author module anticipate clients interested event 
hand better non aop language interface pointcut defined way affect actual implementation module opposed invasive explicit callback external calls interface functions advised 
sealing enforces abstraction boundary module clients allowing programmers reason change independently 
system allows module export semantically important internal events allowing clients extend observe module behavior principled way 
operational semantics shows operational semantics open modules 
rules module values mv mean struct declaration values dv functor 
path lookup rule finds selected binding declarations module 
assume bound names distinct rule easy ensure renaming variables appropriately 
modules advised need create labels structure declarations just substitute structure value variable subsequent declarations 
rule functor application uses substitution 
rule sealing uses auxiliary judgment seal generate fresh set labels bindings exposed signature 
fresh set labels insures clients affect external calls module functions advising new labels advise calls internal sealed module 
bottom diagram rules defining sealing operation 
operation accepts old environment list declarations sealing declaration signature 
operation computes new environment new list declarations rules structured declaration list rule handles declaration appeals recursively definition sealing handle remaining declarations 
empty list declarations sealed empty signature resulting empty list declarations unchanged environment 
second rule allows declaration bind bind represents val pointcut struct omitted signature clients see 
rule sealing value declaration generates fresh label maps old value variable binding returns declaration mapping variable 
client advice new label affect external calls internal refer old label bind dv struct dv functor mv mv seal empty path structure mv structure mv mv seal seal dv struct dv sig struct seal seal bind omit domain seal val val struct seal seal seal pointcut call pc pointcut call seal ds seal seal structure struct ds sig structure struct seal seal structure functor structure functor sig fig 

module system operational semantics name struct sig struct functor structure str fig 

open modules typechecking seal clients change 
rule pointcuts passes pointcut value clients unchanged allowing clients advise label referred pointcut 
rules structure declarations recursively seal internal struct declarations leave functors unchanged 
sub reflex sig sig sub sig sub decl typechecking sub trans sub omit fig 

signature subtyping sub contra typechecking rules shown largely standard 
qualified names typed binding signature module structure bindings declaration signature signature bound module 
rule struct simply puts sig wrapper declaration signature 
rules sealing functor application allow module passed context supertype signature expected 
shows definition signature subtyping 
subtyping reflexive transitive 
subtype signatures may additional bindings signatures constituent bindings covariant 
subtyping rule functor types contravariant 
type soundness extended open modules tinyaspect enjoys type soundness property base system 
theorems proofs similar omit 
reasoning equivalence example programs section helpful understanding benefits tinyaspect module system intuitive level 
able point concrete property enables separate reasoning clients implementation module 
asking implementation module correct changes module affecting clients asking equivalence module implementation specification module implementations 
purposes assume specification implementation reducing questions comparing implementations 
definition limited specifications intended leave behavior implementor leave flexible definition 
natural definition equivalence called observational equivalence contextual equivalence meaning client context distinguish different implementations component 
simple way define contextual equivalence program termination observable variable expressions program contextually equivalent client contexts client terminate linked implementations component run forever linked implementations 
formalize follows definition contextual equivalence expressions contextually equivalent written contexts 
definition contextually equivalent modules distinguished client 
contextual equivalence adequate answer change module affect clients optimized implementation module semantically equivalent implementation 
diverges diverges domain domain fl fl logical equivalence fig 

logical equivalence program text contextual equivalence intuitively captures semantics equivalence useful proving modules equivalent requires quantifying possible clients 
give useful set logical equivalence rules reason module isolation possible clients 
prove rules sound respect natural useful contextual equivalence semantics 
briefly outline logical equivalence rules prove different implementations module observationally equivalent 
defines logical equivalence tinyaspect expressions 
expressions diverge logically equivalent 
expressions equivalent empty context reduce environment value pairs note formal system models functional behavior distinguish implementations different performance characteristics 
obey value equivalence relation defined 
note equivalence rules apply closed expressions significant limitation expressions free variables easily re written functions functors 
equivalence relation values somewhat complex values equivalent depends environment bindings free labels value labels clients advise 
example math module equivalent module caching clients advise internal recursive calls fib equivalent clients advise calls 
define value equivalence judgment form represents set hidden labels client advise 
type labels client advise 
equivalence judgment includes values corresponding environments values equivalent may depend private labels 
similar judgment second logical equivalence rule defined verifies environments map labels logically equivalent values 
second rule sets labels environments free values compared set free labels written fl 
math module label generated fib function part module sealing operation free module value labels including captures advice recursive calls fib hidden 
technical explanation special semantics tinyaspect sealing operation important internal calls public functions module available advice 
rule shows critical importance keeping advice second class tinyaspect 
system second class advice clients advise free labels module value shown rule 
pointcuts advice class function compute pointcut dynamically return clients advise pointcut 
keeping track functions clients advise extremely difficult setting 
rules logical equivalence value environment pairs defined 
rules consider machine configurations equivalent alpha conversion label names environment 
rules similar typical logical relations rules important difference 
tinyaspect supports limited notion state advice mechanism logical equivalence defined bisimulation 
equivalent functions produce equivalent results equivalent arguments trigger advice client accessible labels sequence arguments 
way saying possibly infinite traces pairs client accessible label argument value triggered logically equivalent functions equivalent 
bisimulation defined inductively types usual logical relations function type may trigger advice labels types bigger rules unit fn fn fn fn dv val dv val dv pointcut call dv pointcut call pc mv dv structure mv dv structure dv struct dv struct sig domain domain fig 

logical equivalence machine values interpreted coinductively ordinary types rules ordinary types designed monotonic ensure greatest fixpoint equivalence relation exists 
inductive definition equivalence module types module definitions advised best knowledge coinductive interpretation logical equivalence rules novel 
rule states unit values equivalent 
second states assume non private label equivalent 
labels judged equivalent value looking label environment 
functions equivalent invoked fresh label execute label bisimilar way machine expression equivalence judgment 
usual logical relations rule function equivalence rule quantifies logically equivalent pairs arguments non monotonic incompatible inductive definition equivalence 
fig 

logical equivalence machine expressions empty declarations equivalent 
val declarations equivalent bind variable label labels generated fresh declaration choose equal proving equivalence 
label exposed val declaration visible private set labels 
pointcut structure declarations just check equality components 
declaration forms ensure subsequent declarations equivalent 
order modules equivalent declarations inside equivalent 
functors usual logical relations rule functors equivalent produce logically equivalent module results closed module arguments 
definition formed equivalence module types defined inductively coinductively coinduction base case functions modules 
shows rules logical equivalence expression environment pairs 
rules enforce bisimilarity respect values returned function functor values passed non private label 
definitions similar weak bisimilarity calculus ordinary reductions lookups private labels corresponding transitions standard notion weak bisimilarity 
rule states expressions equivalent take number non observable steps written reduce values equivalent 
non observable step relation equivalent ordinary reduction lookup rule may applied labels advised clients 
second rule allows expressions take steps indicated superscript superscript zero steps resulting observationally equivalent expressions 
rule states equivalent expressions point need look label order continue verify values labels applied equivalent contexts equivalent fresh label representing result application due client advice substituted contexts 
definition equivalence coinductive infinite sequence second third rules conclude non terminating expressions logically equivalent 
defined logical equivalence state soundness theorem relating logical contextual equivalence theorem soundness logical equivalence 

space reasons give brief sketch proof soundness 
details available companion technical report 
proof proceeds establishing bisimulation programs consist context logically equivalent embedded values 
bisimulation invariant states programs structurally equivalent embedded closed values logically equivalent 
key lemma theorem states bisimulation sound bisimulation invariant preserved reduction 
observe logically equivalent expressions diverge reduce logically equivalent values 
case context surrounding expressions diverge expressions contextually equivalent case 
case expressions reduce values context obey bisimulation invariant described 
soundness bisimulation implies expressions diverge reduce logically equivalent values 
expressions contextually equivalent case 
applying logical equivalence definition logical equivalence ensure changes implementation module application preserve application semantics 
example consider replacing recursive implementation fibonacci function implementation loop 
aspectj module system include dynamic semantics sealing operation seemingly innocuous change preserve semantics application aspect broken fact fib longer calls recursively 
open modules ensure change affect enclosing application logical equivalence rules prove 
module sealed fib bound fresh label forwards external calls internal implementation fib 
show implementations module logically equivalent showing matter argument value fib function called function returns results invokes external label way 
external label fresh unused fib function reduces proving ordinary function equivalence easily done induction argument value 
apply abstraction theorem show clients unaffected change 
discussion section reconsider research questions light formal model open modules logical equivalence definition 
formal model represent tool support provided ides consider tools enhanced light model 

developers specify interface library component permits uses advice possible ensuring critical properties component implementation 
declaring explicit pointcuts interface component describe supported internal events 
pointcuts form contract component provider client provider promises client obeys rules open module system system desired properties upgrades component preserve client functionality 
client side contract enforced compiler component provider side verified logical equivalence rules principled extension full aop language proper interface declared logical equivalence rules show prove full functional correctness module completely modular way aspect aware interface computed appropriate specification form implementation available 
course answer limited give formal rules core language full languages far complex 
system prove correctness compiler optimizations constructs expressed core language 
system may foundation richer set equivalence rules applied full system 
formal rules system may helpful showing engineers reason informally correctness changes aspect oriented program 
system yields strong theoretical support intuitive notion changes module affect clients long functions compute result trigger pointcuts way original module 

developers specify interface library component permits uses advice possible allowing component changed meaningful ways affecting clients 
kind interface defined question 
context software evolution logical equivalence rules ensure proposed change module affect module clients clients unknown 
long client code obeys open module interface broken upgraded version component 
note client free choose bypass open module rules compiler open modules issue warning compile code anyway 
case client lose guarantee upgrades preserve correctness client code gain ability reuse adapt component flexible ways permitted open module system 
depending precise circumstances reuse benefits outweigh potential costs fixing code breaks upgrade 
tool support 
parnas argued primary goal modularity ease software evolution 
model developed shows evolving module implementation involve changing pointcuts act module capture events new module implementation correspond events captured original pointcut original module specification 
currently ide aids process identifying pointcuts pointcuts changed definition points making implementation task non local 
model suggests improvement ides providing editable view portion pointcut intersects module source code allow changes local way 
language design 
modularity result suggests number guidelines aop language designers want preserve modular reasoning 
declarative second class advice tinyaspect easier reason class advice 
second language class functions advice affect function declarations functions allows module system scope effect advice 
languages distinguish advice affects interface module invasive forms advice affect module implementation 
related formal models 
closely related formal models foundational calculus walker model aspectj jagadeesan discussed section 
formal models aop mmel provides big step semantics method call interception object oriented languages 
wand give untyped denotational semantics advice dynamic join points 
aspects modules 
walker extended calculus walker support module system 
type system includes novel feature controlling advice read change arguments results advised functions 
design pointcuts class advice applies functions providing flexibility compared tinyaspect pointcuts second class advice applies declarations 
design choice difficult prove logical equivalence properties making pointcuts class tying advice functions allows join points escape module explicitly exported module interface 
system functions advised function declaration explicitly permits system oblivious respect 
contrast tinyaspect allows advice function declarations functions exported module providing significant oblivious extensibility compromising modular reasoning 
lieberherr describe aspectual collaborations construct allows programmers write aspects code separate modules compose third module 
propose full aspect oriented language system richer flexible semantics formally defined 
module system encapsulate internal calls exported functions provide strong abstraction boundary open modules 
researchers studied modular reasoning explicit module systems 
example clifton leavens propose engineering techniques reduce dependencies concerns aspect oriented code 
studied analyzing base code advice separately interfaces similar open modules analyzing advice affected change code 
module system standard ml 
tinyaspect sealing construct similar freeze operator close module extensions module calculi jigsaw 
name open modules indicates modules open advice functions pointcuts exposed interface 
open classes related term indicating classes open addition new methods 
described tinyaspect minimal core language reasoning aspect oriented programming systems 
tinyaspect source level language supports declarative aspects 
small step operational semantics language proven type system sound 
described proposed module system aspects formalized module system extension tinyaspect proved module system enforces abstraction 
abstraction ensures clients affect depend internal implementation details module 
result programmers separate concerns code reason concerns separately 
acknowledgments gregor kiczales mira mezini shriram krishnamurthi ralf mmel mitch wand karl lieberherr david walker tim curtis clifton derek dreyer todd millstein robert harper anonymous reviewers comments material 
supported high dependability computing program nasa ames cooperative agreement ncc nsf ccr army research office number daad entitled perpetually available secure information systems 
aldrich 
open modules modular reasoning advice 
carnegie mellon technical report cmu available www cs cmu edu aldrich aosd dec 

bobrow gabriel keene kiczales moon 
common lisp object system specification 
sigplan notices september 

bracha 
programming language jigsaw mixins modularity multiple inheritance 
ph thesis dept computer science university utah 

clement kersten 
aspect oriented programming 
ecoop workshop analysis aspect oriented software july 

clifton leavens 
observers assistants proposal modular aspect oriented reasoning 
foundations aspect languages april 

clifton leavens chambers millstein 
multijava modular open classes symmetric multiple dispatch java 
object oriented programming systems languages applications october 

walker 
aspects information hiding modularity 
princeton university technical report tr 

filman friedman 
aspect oriented programming quantification obliviousness 
advanced separation concerns october 

kiczales 
addressing practical software development issues aspectj pointcut interface 
advanced separation concerns july 

jagadeesan jeffrey 
untyped calculus aspect oriented programs 
european conference object oriented programming july 

kiczales hilsdale hugunin kersten palm griswold 
overview aspectj 
european conference object oriented programming june 

kiczales lamping mendhekar maeda lopes 
loingtier irwin 
aspect oriented programming 
european conference object oriented programming june 


attacking fragile pointcut problem 
european interactive workshop aspects software september 

krishnamurthi greenberg 
verifying aspect advice modularly 
foundations software engineering nov 

mmel 
semantical approach method call interception 
aspect oriented software development apr 

lieberherr lorenz 
aspectual collaborations combining modules aspects 
computer journal september 

milner 
communicating mobile systems calculus 
cambridge university press 

milner tofte harper macqueen 
definition standard ml revised 
mit press cambridge massachusetts 

walker zdancewic 
theory aspects 
international conference functional programming 

wand kiczales 
semantics advice dynamic join points aspect oriented programming 
transactions programming languages systems september 
