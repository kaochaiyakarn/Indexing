rewriting calculus part ii loria inria campus scienti que bp es nancy france 
mail loria fr claude kirchner loria inria campus scienti que bp es nancy france 
mail claude kirchner loria fr calculus integrates uniform simple setting rst order rewriting calculus nondeterministic computations 
abstraction mechanism rewrite rule formation main evaluation rule matching modulo theory seen rst part motivations de nitions basic properties calculus 
second part rst devoted calculus encoding conditional rewrite relation 
extend calculus rst operator purpose detect rule application failure 
extension allows express recursively rule application encode strategy rewriting processes 
extended calculus give operational semantics elan programs 
conclude overview ongoing works calculus 
keywords rewriting strategy non determinism matching rewriting calculus lambda calculus rule language 
second part rewriting calculus description study applications 
refer rst part part seen part encode calculus representation nite derivation 
need want able represent calculus generic search normalization derivations exist 
generally want formal representation rewriting strategies ones elan pro 
extend calculus rst operator purpose detect rule application failure 
extension allows express recursively rule application encode strategy rewriting processes 
extend encoding conditional rewriting complicated rules conditional rewrite rules local assignments elan language 
non determinism elan handled mainly basic strategy operators represented calculus means sets 
show nally calculus provides semantics elan programs 
structured follows 
section extend basic calculus new operator de ne term traversal xed point operators existing operators 
igpl vol 
pp 
oxford university press encoding non conditional conditional term rewriting operators de ned section section 
calculus nally section order give operational semantics rules elan language 
conclude providing research directions main interest development formalism context elan generally rewrite languages asf sdf kli ml mil maude stratego vis cafeobj fn 
recursion term traversal operators part shown reduction rewrite theory exists corresponding reduction calculus term reduces term rewrite theory build term reduces term fvg 
method constructing term depends reduction steps theory representation calculus derivation trace 
want go give method constructing term knowing priori derivation want answer question rewrite theory exist term term reduces term rewrite theory reduces set containing term 
means wish describe calculus reduction strategies mainly normalization strategies 
allow get particular natural encoding normal conditional term rewriting 
want answer speci question rewrite theory exist term term normalizes term rewrite theory reduces set containing term 
de nition normalization strategies general done meta level calculus allows represent derivations object level 
shown part calculus contains calculus computable function normalization expressible formalism 
bring matching power non determinism increased ease expression functions expression uniform formalism combining standard rewrite techniques higher order behaviors 
computing normal form term rewrite system rewrite rules applied repeatedly position term rule applicable 
ingredients needed de ning strategy iteration operator applies repeatedly set rewrite rules term traversal operator applies rewrite rule position term operator testing set rewrite rules applicable term 
follows describe operators functionalities de ned calculus 
start auxiliary operators introduce operators correspond functionalities listed 
auxiliary operators de ne auxiliary operators sections 
operators just aliases de ne complex terms giving compact clear de nitions recursion operators 
rst operators identity denoted id applied term evaluates singleton containing term id ftg 
term id rewrite rule id similar way de ne strategy fail fails applied term leads fail third binary operator represents sequential application terms 
term form represents application term result application de ne operator sections generally employ abbreviations operators expanded form show corresponding reductions 
operator introduce new operator role select arguments rst applied term evaluate 
arguments evaluate nal result evaluation 
evaluation rules describing operator auxiliary operator 
know currently express operators basic calculus conjecture possible 
irst ail ht ht ftg contains redexes free variables hi fig 

operator simplicity considered operators hi variable arity similar binary operators 
application term term returns result rst successful application arguments term evaluates evaluate evaluates term term 
evaluation terms leads evaluation terminate evaluation term terminate 
definition set st terms extends set basic terms rules terms term terms ht term 
set terms denoted st 
de ne st calculus considering new operators corresponding evaluation rules definition set function symbols set variables theory st terms having decidable matching problem call st calculus calculus de ned non empty subset st st terms higher order substitution application terms de ned part theory set evaluation rules st ire cong ail distrib batch lat irst ail evaluation strategy guides application evaluation rules 
follows consider st calculus st calculus syntactic matching rewrite rules restricted form rst order term 
examples evaluation st terms containing operators extended calculus 
example non deterministic application rules term represented calculus application fa dg 
term reduced term fb dg represents non deterministic choice terms 
want apply rules deterministic way speci ed order term example reduction irst ire lat fbg notice rewrite rules applied successfully empty set term nal result rst tried rewrite rule 
example consider case rules argument lead empty set result irst ire ail ire lat fcg example rules argument applied successfully result obviously empty set irst ire ail hi operator test explicitly applicability term rule term allows recover failure continue evaluation 
example de ne term try id applied term evaluates result evaluate ftg evaluates 
term traversal operators de ne operators apply term position term 
rst step de nition operators push application term level deeper term 
possible calculus due rule cong want de ne generic operator applies term sub terms term form un independently head symbol de ne term traversal operators behavior described rules 
operators inspired operators system described 
application term term un results successful application term terms precisely un hff un ff gi un ff fig 

term traversal operators calculus applied rst evaluate empty set 
exists particular function arguments constant term reduces empty set ail hi term applied term un term applied arguments evaluate 
exists reduces result empty set 
apply constant sub terms term reduces fcg fcg consider calculus nite signature denote fc set constant function symbols ff fm set function symbols arity term traversal operators expressed calculus appropriate terms 
de nitions considered id id id id fm id id fm id id fc fm obtain reductions id id fm id id irst id id id id cong ff ff ail hff ff fc fm distrib cong ff lat ff operator correspond exactly de nition just seen similar result obtained applying terms term 
lemma term traversal operators expressed st calculus 
proof 
consider reductions evaluation rules describing behavior obtain hff ff gi hff ff gi hf gi lat ail hi exists ground term containing redex reduction obtained hff ff gi hff ff ff gi ff ail hff depending evaluation strategy terms reduced empty set chosen alternative compact representation 
consider de nition obtain hff ff hff ff hf lat ail hi term exists ground term containing redex reduction obtained hff ff hff ff hf ff lat ff ail hff notice results reductions application term arguments term operators identical 
terms ground terms containing redex nal result reductions case failure ff operators applied constant obtain hi fc iterators de nition evaluation normalization strategies example top bottom application term top position deepest positions term 
moment possibility applying term arguments term un sub terms explicitly speci ed depth 
depth term known priori apply term deepest positions term want apply term sub terms maximum depth term de ne recursive operator reiterates application terms pushes application deeper terms 
start presenting term describing recursive applications calculus 
starting xed point combinators calculus de ne term recursively applies term 
classical xed point combinator calculus bar xy called turing xed point combinator tur 
term corresponds calculus term 
calculus term reduction calculus similar reduction oint checked follows 
ire fy distrib ire ff gg lat obtained desired result application rule ire reduction replaced reduction sub term 
reduce 
term obtain derivation terminate redex selected reduction 
operational approach want new constructions lead nonterminating reductions 
term obviously lead nite reductions strategy order obtain termination desired behavior 
strategy applies evaluation rules sub term form reduction possible 
operational point view strategy dicult implement obviously ecient calculus term represented extended form dicult identify 
considered independent term behavior described evaluation rule corresponding reduction oint strategy suggested previously easily implemented 
strategy satisfying termination condition easier implement initially apply evaluation rules top positions terms evaluation rule applied top position reduce sub terms deeper positions 
follows generally outermost strategy 
clear strategy prevents nite reductions due operator ensure termination untyped calculus 
mentioned previously main goal section representation normalization strategies terms want describe application term positions term de ne appropriate term propagates application term sub terms term 
multiple applications want de ne operators bottomup topdown describing application term sub terms term starting deepest positions respectively top position want nd term recursively applies term sub terms top position result term term initially applies term top position term sub terms result term 
term applied sub terms application lead failure 
propose rst naive de nitions operator comment encountered problems 
analyze obtained reductions de ne operators describing desired behavior 
rst natural possibility de ne term sds 
consider term sds sds sds application term 
derivation obtained sds sds sds sds sds sds 
sds fx sds sds sds sds sds see derivation term sds recursively applied sub terms initial term term applied top position result 
applications term leads failure failure propagated empty set obtained result derivation 
con uent strategy ones part derivation possible term sds reduced set element 
condition obviously respected set element example sds fa bg fg sds sds want prevent evaluation term sds set element satisfy condition de ne term sd 
respectively sd sd sd fa bg term sd sd fa bg reduced term fg sd sd case sds sd 
fa bg 
fa bg distrib 
hf gi term rst argument operator hi contains free variable reduced evaluation rule 
term set propagation set symbols performed case operator sd reduce term sd sd sd consequently obtain reduction sd sd sd sd sd sd 
sd fx sd ig fh sd ig fh sd sd ig example strategy initially applies evaluation rules top positions terms derivation obtained sd fa idg fh fa idg sd fa idg sd fa idg ig distrib fhf sd fa idg sd fa idg id sd fa idg sd fa idg gig ire fhf id sd fa idg sd fa idg gig lat sd fa idg sd fa idg gig fh fa idg ig sd fa idg gig ffb ag sd fa idg gig fb ag fa idg sd fa idg gig fb ag fb ag gig fg notice application sd guarantee applications term deepest sub terms rst ones reduced 
example try apply evaluation rules top position derivation example obtain applying evaluation rule ire sd fa idg sd fa idg ire sd fa idg sd fa idg fb ag ff fb ag innermost reduction 
disadvantage non con uence case operator sds eliminated operator hi de nition operator sd obtained desired behavior type iterator 
evaluation term sd applications term sub term evaluated failure propagated empty set obtained result reduction 
want keep unchanged sub terms application term evaluates term id way example de ning operator bu bu 
id id manner previous cases obtain operator bottomup bottomup bu corresponding description section 
lemma bottomup operator describing application term sub terms term bottom manner expressed st calculus 
proof 
analyze reductions application term bottomup constant functional term arguments 
complete proof cir 
top reduction immediately obtained take term td 
id id de ne term topdown td lemma topdown operator describing application term sub terms term top manner expressed st calculus 
singular applications term traversal operator de ne similar terms apply speci term position term bottom top way 
see operators built operator convenient construction normalization operators 
term bottom case bu 
de ne operator applies term bottom way bu bu previous operators term bu bu lead nite reduction appropriate strategy employed 
operator apply evaluation rules rst top position possible deeper positions 
state lemma bu operator describing application term sub term term bottom manner expressed st calculus 
example application bu reduced fh ig term fbg 
application rule leftmost innermost position term represented term bu corresponding evaluation bu bu bu ig fbg bu ig ig fg want de ne operator applies speci term position term top way term td 
obtain immediately operator td td td case application td application term rst tried top position case failure applied deeper term previously state lemma td operator describing application term sub term term top manner expressed st calculus 
repetition normalization operators previous sections de ned operators describe application term position term bu operators allow recover failing evaluations 
want de ne operator applies repeatedly strategy term call repeat behavior described evaluation rule repeat repeat repeat xed point operator previous section de ne term 
describing repeat operator repeat approach obvious drawbacks 
termination evaluation guaranteed strategy previous operators 
strategy applies evaluation rules rst top position application right sub term left sub term obtain desired result 
rightmost outermost strategy non terminating derivation obtained repeat repeat repeat second evaluation terminates result empty set 
point evaluation application term reduced empty set strictly propagated term repeat reduced empty set 
order overcome problems de ne operator called repeat behavior de ned evaluation rules 
repeat repeat repeat reduced repeat repeat reduced fig 

operator repeat need operator similar repeat stores non failing result application possible returns result 
modify term 
id de ne term repeat forget assume application reduced applying evaluation rules top position argument term get lemma operator repeat describing repeated application term result expressed st calculus 
example repeated application rewrite rules term represented term repeat fa cg evaluates follows repeat fa cg fh repeat fa cg fa cg id ig fh repeat fa cg fbg id ig repeat fa cg fa cg id ig id ig repeat fa cg fcg id ig id ig repeat fa cg fa cg id ig id ig id ig repeat fa cg id ig id ig id ig id ig id ig id ig id ig fcg operators easy de ne speci normalization strategies 
example innermost strategy de ned im repeat bu outermost strategy de ned om repeat td corollary operators im om describing innermost outermost normalization expressed st calculus 
ingredients needed describing normalization term rewrite theory term described section de ned im om operators represent normalization term rewriting theory terms im om example denote set rewrite rules fa xg represent im leftmost innermost normalization term set rules derivation obtained im repeat bu fh repeat bu bu id ig fh repeat bu fg id ig fhf repeat bu id ig repeat bu bu id igg id ig repeat bu fg id ig id ig repeat bu bu id ig id ig id ig repeat bu fbg id ig id ig id ig repeat bu bu id id ig id ig id ig repeat bu id id ig id ig id ig id id ig id ig id ig id ig id ig id ig id ig id ig id ig id ig fbg term rewriting theory con uent result reduction term im set representing possible results reduction term rewriting theory elements result set represents result reduction rewriting theory application order rewrite rules example consider set fa xg non con uent rewrite rules 
term im representing innermost normalization term set rewrite rules reduced fb cg 
term om representing outermost normalization reduced fb cg 
ingredients necessary describe concise way normalization process induced rewrite theory 
course standard properties termination con uence rewrite system allow get uniqueness result 
approach di ers de ne normalization case unique normal form termination warranted 
general get termination uniqueness normal form 
st calculus shown section 
nite derivation term rewriting mimicked appropriate term represents trace reduction 
interesting nd derivation 
encoding rewriting st calculus interested build term describing reduction term rewriting term set rewrite rules knowing priori intermediate steps derivation st calculus operators de ning innermost outermost normalization strategies 
proposition rewriting theory tr rst order ground terms normalized set rewrite rules im reduced set containing term 
proof 
induction number reduction steps term example consider rewrite system containing rewrite rules rue term reduces rue rewrite system term reducing ft built shown section 
xed point operators 
case corresponding term rue approach build term im rue ag case obtain empty sets additionally sets element obtained equational matching unitary reduction strategy section 
order ensure con uence 
reduction strategy undesired results obtained 
encoding conditional rewriting shown term rewriting reduction described reduction calculus 
section give representation calculus conditional rewriting reductions 
propose methods de ning term contains information needed reduction including condition evaluation normally performed meta level 
main diculty resides fact conditional rewriting reduction relation recursively applied order evaluate condition ring conditional rule 
approach explicit description rewriting see section 
terms order describe conditional rewriting reduction complicated case 
detailed description concise term normalization process conditions obtained normalization operators section 
de nition conditional rewriting conditional rewriting relations designed mainly di er way conditions understood 
consider normal conditional rewriting de ned follows 
definition normal rewrite system composed conditional rewrite rules form elements variables satisfying condition var var var ground substitution satisfying var dom normal form boolean rue alse 
conditional rewrite system composed rules application rewrite rule term occurrence consists matching substitution left hand side rule term jm ii normalizing instantiated condition provided resulting term rue iii replace jm denoted re encoding mentioned main diculty encoding conditional rewriting precise evaluation process condition 
case normal rewriting means computing normal form condition 
denote term instantiated proper substitution normalizes term fug term instantiated accordingly normalized rewrite theory term boolean condition rewrite system completely de ned booleans br term constants rue alse 
reduction rewrite theory known de ne section term evaluates fug ft ff 
term describing reduction term conditional rewrite rule represented term ft rue alse simpler suggestive rue case reduces ff representation matching fails result application empty set 
reduces ft result reduction obviously cases application representation extend proposition 
show derivation conditional rewriting theory representable appropriate term 
proposition conditional rewriting theory tr rst order ground terms exist terms un built rewrite rules intermediate steps derivation ft construction approach proposition 
obviously convenient need method allows build term corresponding rewrite reduction knowing priori reduction steps 
order build term term rewrite rules normalization operators de ned section 
example de ne im example assume set rules describing order integers denoted consider rewrite rule applied term reduces instantiated condition reduces rue rewrite rule rue 
consider condition normalized corresponding reduction calculus rue im ire rue im rue ft batch ff rue rue gg ire fffg ggg lat fg conditions rewrite rules normalized set conditional rewrite rules including current rule de nition rewrite rules representing normalization intrinsically recursive realized operator im 
xed point operator described section represent application set rewrite rules normalization conditions 
set rewrite rules rn rn represent subset non conditional rewrite rules respectively subset conditional rewrite rules form 
de ne term 
im fl rue mg rn fl mg rn fl ng respectively im describing normalization term rewrite rules term im 
normalization strategy conditions abstracted variable im reduced variable instantiated im 
initial term conditions reduced im 
instantiation possibly reiterated conditional rules suppose application conditional rules 
obtain result similar proposition method construction corresponding term initial term set rewrite rules 
proposition conditional rewriting theory tr rst order ground terms normalized set rewrite rules im reduced set containing term 
example consider set rewrite rules containing rewrite rule rue conditional rewrite rules 
term reduces rewrite rules show corresponding reduction calculus 
method obtain term 
im ff rue rue rue show main steps reduction term im 
obtain immediately reduction im im nal result obtained term im ff rue im rue im rue rue im rue im term im proceed previously reduce term im ff rue im rue im intermediate reduction rue im rue im easily obtain im ft previous term reduced rue ft fbg im im fbg ft come back reduction initial term get rue im rue ft fg obtained result conditional term rewriting 
starting results section give section representation elaborated rewrite rules elan language conditional rewrite rules local assignments 
rewriting calculus semantics elan elan rewrite rules elan name expresses dynamism arrow environment specifying prototyping deduction systems language labeled conditional rewrite rules strategies control rule application 
elan system ers compiler interpreter language 
elan language allows describe natural elegant way various deduction systems vit bkk 
experimented non trivial applications ranging decision procedures constraint solvers cas logic programming kr automated theorem proving ck speci cation exhaustive veri cation authentication protocols cir 
elan rewrite rules conditional rewrite rules local assignments 
local assignments constructions allow applications strategies terms 
general syntax elan rule cond cond elan expression reduced boolean value 
conditions reduced true value local variables assigned success application strategy right hand side local assignment fail rewrite rule applied 
notice square brackets elan indicate label rule distinguished square brackets calculus represent application rewrite rule term 
partial semantics elan program rewriting logic mes conveniently elan rules conditional ones strategies expressed calculus elan program just term 
results evaluation term correspond possible results execution initial elan program 
example example labeled elan rule describing possible naive way search minimal element list sorting list rst element min rule min nil sl sort head sl strategy sort sorting strategy 
operator head supposed described con uent terminating set unlabeled rewrite rules 
sl assigned result application set labeled rules guided strategy sort assigned result application set unlabeled rules guided strategy implicit built innermost strategy 
evaluation strategy evaluating conditions leftmost innermost standard rewriting strategy 
non determinism handled mainly basic strategy operators dont care choose denoted dc returns results chosen unfailing strategy arguments dont know choose denoted dk returns possible results 
variant dont care choose operator choose operator denoted returns results rst unfailing strategy arguments 
strategy operators implemented elan allow simple concise description user de ned strategies 
example concatenation operator denoted builds sequential composition strategies strategy fails fails returns results applied results operator repeat describe repeated application strategy 
repeat iterates strategy fails returns obtained result 
rule elan considered basic strategy strategy operators available describing computations 
simple example illustrating way dk strategies 
example strategy dk applied term elan provides results 
strategy applied term result obtained 
strategy applied term yields result 
non deterministic strategies explore exhaustively search space problem nd paths described speci properties 
example proving correctness needham schroeder authentication protocol ns look possible attacks behaviors session 
example just rules protocol give strategy looking possible attacks detailed description implementation cir 
example consider rewrite rules describing needham schroeder authentication protocol aims establish mutual authentication initiator responder communicate insecure network presence intruders 
strategy looking possible attacks applies repeatedly non rewrite rules describing behavior protocol initiate intruder intruder selects results representing attack 
repeat dk initiate intruder non deterministic application described operator dk 
result strategy repeat 
set possible behaviors protocol session messages intercepted faked intruder 
strategy just checks term received input represents attack trying apply rewrite rules corresponding negation desired invariants selects previous set results representing attack 
calculus representation elan rules rules system elan expressed calculus 
rule conditions local assignments represented conditional rule expressed section 
rules local assignments elan rewrite rules local assignments conditions form represented term term term corresponding strategy calculus 
rst representation syntactically replaces variables right hand side rewrite rule de ned local assignment term instantiates respective variable 
second representation variable de ned local assignment bound rewrite rule applied corresponding term 
example elan rule derive derive represented terms derive derive derive derive moment notice usefulness free variables rewrite rules 
representation elan rule local assignments possible variable allowed free rule free variables right hand side rewrite rule enables parameterization rewrite rules strategies strategy applied known rule 
example consider elan rule derive consider strategy derive dk 
application strategy derive term gives results application rule term provides non deterministically results representation rule fa cg fa cg applied reduces follows fa cg fa cg ire fa cg fa cg distrib ff gg ire lat ffb cg fb cgg ffb fb cg fb cg fc cg fc lat fb cg set represents exactly results obtained elan 
consider general elan rules containing local assignments conditions local variables combination methods conditional rules rules local assignments done carefully 
representation closed rst example obtained incorrect results example 
example consider description automaton set rewrite rules describing transition state 
potential execution double transition initial state nal state passing non nal intermediate state described elan rule double dk nf term represents state obtained carrying transition behavior easily represented elan set unlabeled rules describing operator nf 
note set rewrite rules describing nal states suppose nal state 
rst representation approach rule local assignments coding method conditional rules section obtain term corresponding previous elan rule rue fs im nf fs term applied leads reduction rue fs im nf fs rue fs im nf fs rue fs im nf fs rue im nf rue ff alse ff rue alse rue rue gg rue rue gg elan obtain result represented term problem example double evaluation term fs replacing local variable condition right hand side rule 
term evaluated set element elements satis es condition set replaces corresponding variables right hand side rule subset elements satisfying condition considered 
need mechanism evaluates local assignments rule 
approach combining second representation approach rule local assignments representation conditional rules 
losing generality consider elan rule form label dxe dxe elan rule expressed term ft rue dxe alse im dxe simpler rue dxe im dxe represents set rewrite rules modulo normalize conditions 
order simplify presentation supposed rules set rewrite rules form operator im sucient de ne normalization set 
consider conditional unlabeled rules operator im employed 
way transformation applied elan rewrite rule corresponding reduction illustrated example considering new representation 
example elan rewrite rule example represented term rue im nf fs applied term leads reduction rue im nf fs ire rue im nf fs rue im nf fs rue im nf rue im nf ire ff rue im nf rue im nf gg rue alse rue rue gg representation result obtained elan 
result example obtained evaluation rule ire applied distribution set fs 
con uent strategies section 
forbid reduction correct result obtained 
representation allows correct transformation elan reductions reductions gives hint implementation details rewrite rules 
hand implementation ensure correctness result hand take account eciency problems 
instance representation example correct obviously ecient representation example due double evaluation application 
elan evaluation mechanism complex distinguishes labeled rewrite rules unlabeled rewrite rules 
unlabeled rewrite rules normalize result applications labeled rewrite rule term 
evaluating local assignment elan rewrite rule term rst normalized speci ed set unlabeled rewrite rules strategy applied normal form 
time labeled rewrite rule applied term elan evaluation mechanism normalizes result application respect set unlabeled rewrite rules 
elan rewrite rule example represented calculus term im rue im nf fs im represents set unlabeled rewrite rules modulo normalize local assignments 
general strategies local assignments considered local assignments rule strategies respective rewrite rule 
representation elan rule local calls strategies de ned rule parameterized de nition respective strategies 
example rule local assignments form label represented term label free variable instantiated set strategies program containing rule labeled label 
elan strategies programs elementary elan strategies cases direct representation calculus 
identity id failure fail concatenation directly represented calculus operators id fail respectively de ned section 
strategy dk sn represented calculus set fs sn strategy sn term sn de ned section 
iteration strategy operator repeat easily represented operator repeat strategies evaluation local assignments strategies expressed rewrite rules 
elan strategies represented terms way elan rewrite rules 
example elan strategy example immediately represented term repeat intruder suppose initiate intruder representations calculus corresponding elan strategies 
representation user de ned strategies elan program approach xed point operator similar case conditional rules section 
consider elan program containing strategies sn set labeled rules term representing program 
fs body ng body represent right hand sides strategies strategy replaced rule label replaced representation rule elan strategy operator replaced correspondent calculus 
sum transformation elan program term 
definition consider elan 

signature corresponding calculus obtained operator declarations elan program 

starting unlabeled rules form sort build term rnn 
im fl rue ng innermost normalization set unlabeled rules represented term rnn encoding extended incremental way rules containing conditions local assignments 
encoding simpli ed program contain unlabeled conditional rules case term im fl ng rules local assignments simpli ed elementary rules 

labeled rule form label sort build term label 
rue im nn im nn 
strategy form body build term represents right hand side body strategy strategy symbol replaced rule label label replaced representation label rule elan strategy operator replaced correspondent calculus 
elan program de ning strategies sn represented term 
fs ng represents encoding strategy application strategy elan program term represented term term representing program name strategy execution program evaluating term strategy leads results un term reduced set term fu ung 
example elan module interpretations rules strategies elan program 
example module automaton describes automaton states non deterministic transitions described set rules containing rules labeled 
operator de nes state deterministic manner behavior described set unlabeled rules 
states nal final closed closed 
double transitions intermediate non nal non closed state described rules double respectively double module automaton import global bool sort state operators global state state state final state bool closed state bool global follow state bs gen double state bs cond double state bs rules bool global final false closed false final true closed false final false closed true final false closed true final true closed true rules state state global double follow final double follow closed strategies state implicit follow dk gen double follow follow cond double dk double double denote set unlabeled rules de ned imported modules bool describing operations booleans 
set unlabeled rules module automaton represented term final false final true closed false closed trueg note rc rules labeled double double represented rules double im rc rue im rc final follow im rc respectively double im rc rue im rc closed follow im rc strategies module automaton represented terms follow follow fs gen double gen double follow follow cond double cond double double obtain term representing elan program automaton automaton 
gen double cond double execution program automaton evaluating term strategy cond double corresponds reduction term automaton cond double elan obtain execution results reduction corresponding term leads set 
example relatively simple elan module representative main features elan language 
methodology complicated rules strategies handled 
notice provides particular precise description rewriting primitives including semantics conditional rewriting language 
best knowledge rst explicit full description rewrite programming language 
st calculus extension calculus appropriate de nitions term traversal operators xed point operator 
enables apply repeatedly set rewrite rule consequently de ne term representing normalization set rewrite rules 
starting representation showed st calculus de ne conditional rewriting give semantics elan modules 
course applied frameworks including rewrite languages asf sdf ml maude stratego cafeobj production systems non deterministic transition systems 
starting rst results rewriting calculus explored subsequent papers di erent directions calculus explicit substitutions typed rewriting calculi 
cir proposed version calculus substitution application described level evaluation rules 
starting calculus explicit substitutions particular calculus developed calculus explicit substitutions called calculus showed calculus con uent conditions calculus 
explicit substitution setting interesting case calculus substitution renaming mechanism handled explicitly substitution explicitly represented 
extremely useful computing substitution expensive associativity commutativity matching algorithm exponential size terms 
derivation may fail searching right instance conditional memorizing substitution mandatory 
allows particular calculus explicit substitutions language describe proof terms elan computations 
calculus terminating untyped case 
order recover property imposed ck strict discipline term formation introducing type term 
type system calculus showed subject reduction strong normalization properties reduction typed term terminating preserves type initial term 
additionally new presentation la church calculus ckl type systems placed cube extends cube barendregt 
quite interestingly typed calculus uses rule arrow 
provides solution identi cation 
sets represent non determinism mentioned structures 
example want represent results application di erent results multisets order results signi cant list structure suitable 
started study description calculus having parameter matching theory structure results shown expressive power ckl 
precisely analyzed correspondence calculus object oriented calculi object calculus abadi cardelli ac calculus objects fisher honsell mitchell fhm 
approach proposed allows representation objects style mentioned calculi elaborate objects behavior described matching power 
new emergent framework calculus ers original view point rewriting higher order logic opens new challenges understand related topics 
go study calculus combination rst order higher order paradigms investigation relationship calculus higher order rewrite concepts crs hor deepened 
second directions investigated mention analysis properties calculus matching theory elaborate syntactic matching 
generic description conditions imposed matching theory order obtain con uence termination calculus de ned show conditions satis ed particular theories associativity commutativity 
models rewriting calculus de ned studied compared ones algebraic higher order structures 
mentioned previously conjecture st calculus expressed calculus semantics empty set rule application failure 
practical point view various instances calculus implemented rewriting tools 
realized implementation elan calculus experimented various evaluation strategies 
implementation order de ne object oriented paradigms 
dually object oriented version elan language realized dk semantics rewriting calculus 
shows new calculus attractive terms semantics unifying capabilities believe serve basic tool integration semantic logical frameworks 
acknowledgments el ene kirchner pierre etienne moreau christophe ringeissen team useful interactions topics vincent van suggestions pointers literature roberto david wolfram detailed useful comments preliminary version fruitful discussions 
grateful luigi comments exciting discussions calculus applications 
th er ese hardin nachum dershowitz interest helpful suggestions improvement 
special due referee complete careful reading constructive useful remarks 
ac abadi cardelli 
theory objects 
springer verlag 
bar barendregt 
lambda calculus syntax semantics 
studies logic foundation mathematics 
elsevier science publishers 
north holland amsterdam 
second edition 
bkk borovansk kirchner kirchner 
moreau vittek 
elan logical framework computational systems 
meseguer editor proceedings rst international workshop rewriting logic volume electronic notes tcs asilomar california september 
borovansk kirchner kirchner 
moreau 
elan rewriting logic point view 
research report loria november 
br rusinowitch 
implicit induction conditional theories 
journal automated reasoning 
cas castro 
une approche de la esolution de probl emes de satisfaction de contraintes 
th ese de doctorat universit universit henri poincar nancy france 
clavel eker lincoln meseguer 
principles maude 
meseguer editor proceedings rst international workshop rewriting logic volume asilomar california september 
electronic notes theoretical computer science 
cir 
specifying authentication protocols elan 
workshop modelling veri cation france december 
cir 
calcul de applications 
th ese de doctorat universit universit henri poincar nancy 
ck kirchner 
theorem proving computational systems case predicate prover 
workshop ccl dagstuhl germany september 
ck kirchner 
simply typed rewriting calculus 
rd international workshop rewriting logic applications kanazawa japan september 
electronic notes theoretical computer science 
ckl kirchner 
matching power 
october 
submitted 
ckl kirchner 
rho cube 
foundations software science computation structures lecture notes computer science genova italy april 
dk dubois kirchner 
objects rules strategies elan 
proceedings second amast workshop algebraic methods language processing iowa city iowa usa may 
dershowitz okada 
rationale conditional equational programming 
theoretical computer science 
fhm fisher honsell mitchell 
lambda calculus objects method nordic journal computing 
fn futatsugi nakagawa 
overview cafe speci cation environment algebraic approach creating verifying maintaining formal speci cations networks 
proceedings st ieee int 
conference formal engineering methods 
kirchner kirchner vittek 
designing constraint logic programming languages computational systems 
van hentenryck saraswat editors principles practice constraint programming 
newport papers chapter pages 
mit press 
kli klint 
asf sdf meta environment user guide 
technical report cwi 
kr kirchner ringeissen 
rule constraint programming 
fundamenta informaticae september 
mes meseguer 
conditional rewriting logic uni ed model concurrency 
theoretical computer science 
mil milner 
proposal standard ml 
proceedings acm conference lisp functional programming 
ns needham schroeder 
encryption authentication large networks computers 
communications acm 
pro team 
elan home page 
www page 
elan loria fr 
tur turing 
functions conversion 
journal symbolic logic 
visser el benaissa 
core language rewriting 
kirchner kirchner editors proceedings second international workshop rewriting logic applications volume www elsevier nl locate entcs volume html pont france september 
electronic notes theoretical computer science 
vis visser 
strategic pattern matching 
narendran rusinowitch editors rewriting techniques applications rta volume lecture notes computer science pages trento italy july 
springer verlag 
vit vittek 
elan un cadre logique pour le de langages de programmation avec contraintes 
th ese de doctorat universit universit henri poincar nancy october 
van van 
comparing combinatory reduction systems higher order rewrite systems 
hoa volume lecture notes computer science pages 
springer verlag 
contents 
recursion term traversal operators 
auxiliary operators 
operator 
term traversal operators 
iterators 
multiple applications 
singular applications 
repetition normalization operators 
st calculus 
encoding rewriting st calculus 
encoding conditional rewriting 
de nition conditional rewriting 
encoding 
rewriting calculus semantics elan 
elan rewrite rules 
calculus representation elan rules 
rules local assignments 
general strategies local assignments 
elan strategies programs 

received january 
