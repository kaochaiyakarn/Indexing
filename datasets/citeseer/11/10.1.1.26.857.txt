graphlog visual formalism real life recursion mariano consens consens db toronto edu alberto mendelzon mendel db toronto edu query language called graphlog graph representation data queries 
queries graph patterns 
edges queries represent edges paths database 
regular expressions qualify paths 
characterize expressive power language show equivalent stratified linear datalog order logic transitive closure non deterministic logarithmic space assuming ordering domain 
fact classes coincide previously known 
show graphlog extended incorporate aggregates path summarization describe briefly current prototype implementation 
literature theoretical computational aspects deductive databases additional power provide defining querying data grown rapidly years 
gone design languages interfaces additional power available convenient form 
propose language called graphlog graph representation databases queries 
graphs natural representation data application domains example transportation networks project scheduling parts hierarchies family trees concept hierarchies hypertext 
graphlog evolved earlier language proposed differs general data model negation computational tractability 
graphlog queries ask patterns absent database graph 
pattern called query graph defines set new edges new relation added graph pattern 
graphlog queries sets query graphs called graphical queries 
edge query graph represents base relation defined query graph 
graphlog suited graphical interface users draw query graphs screen 
prototype implementation interface described section 
simplicity power language rest main principles 
edges query graph match edges paths database graph 
regular expressions qualify paths 
second recursive definition new edges graphlog query author partially supported united nations programme development basic sciences uruguay 
published proceedings acm sigact sigmod symposium principles database systems pp 

edge query graph defined directly indirectly referring new edge defined current query graph 
design graphlog deliberate choice avoiding full power horn clauses stratified negation 
important characterize set expressible queries 
achieving characterization side benefit clarified relationship known query classes queries expressible stratified linear datalog queries computable non deterministic logarithmic space queries expressible transitive closure operator plus order logic turn coincide class expressible graphlog 
fact close relationship linear datalog transitive closure somewhat folk theorem years 
jan shown evaluate linear rule transitive closure computation 
procedure quite complex due optimizations technique intended achieve 
negation mentioned 
ullman ull gives construction map single linear rule transitive closure problem 
considers rules single idb predicate body negation 
connection linear programs transitive closure considered ck fact proof theorem derive results negation considered 
result establishes simple translation procedure takes account stratified negation 
linear program procedure outputs program recursive rules transitive closures 
immerman results power transitive closure operator show queries computed stratified linear datalog programs assuming ordering domain exactly computable non deterministic logarithmic space size database 
ordering domain show linear datalog programs non deterministic logarithmic space data complexity datalog ae improving results kan showed datalog ae 
results reflect favourably design graphlog linear stratified datalog believed express real life recursive queries 
incorporated language ability compute aggregate functions summarize paths 
test case considered detail application graphlog particular domain hypertext systems encouraging results described cm 
graphlog query language databases naturally viewed graphs 
particular relational database identify sets objects interest relationships represented mapping objects nodes relationships edges 
example shows graph representation flights schedule database 
flight number associated cities connects predicates departure arrival times flight predicates departure arrival respectively 
unary predicate capital tells cities national capitals 
known datalog ae fact datalog ae stage logn stage logn ae result shows stage tc datalog stage datalog 
capital capital arrival departure vancouver buenos aires toronto arrival arrival departure departure departure arrival graph representation flights schedule database 
example think labels edge types carrying additional information 
cases additional attributes nodes edges example chosen represent flight relationship cities gives departure arrival times labeling edge literal form flight 
general tuple 


represented edge nodes 
ai 
bj labelled 
ck 
precise definition kind graphs considering representing databases 
definition directed labeled multigraph ln le ffl finite set nodes finite set edges ln set node labels le set edge labels incidence function function associates edge pair nodes node labeling function function ln associates node label ln ffl edge labeling function function le associates edge label le profit graph representation database express queries 
analogy tableau queries define relation means tuple distinguished variables answer template tuples database want expressions describe graph pattern distinguished edge define relation 
definition directed labeled multigraph distinguished edge ffl ln le ffl feg ln le ffl directed labeled multigraph ffl ffl le formally define graph patterns directed labeled multigraphs distinguished edge isolated nodes having properties 
nodes labeled sequences variables 
edge labelled literal positive negative occurrence predicate applied sequence variables constants closure literal simply literal followed positive closure operator 
literal closure literal 
closure literals may appear nodes labelled sequences length 
distinguished edge labelled positive non closure literal 
definition query graph directed labeled multigraph distinguished edge ln le ffl ln set sequences variables le set literals closure literals set positive literals isolated nodes exist feg ffl positions arity closure literal 
example shows query graph 
different kinds literals labeling edges 
literal desc necessarily positive literal labeling distinguished edge 
distinguished edge query graph graphically represented bold line 
literal descendant labeling edge positive closure literal notice dashed edge edges labeled closure literals drawn dashed lines 
literal descendant labeling edge negative closure literal 
note representing negative literals crossing edges labeled showing negative literals positive ones 
person unary predicate 
intuitively query graph expresses query returns ternary predicate desc descendants person descendants person 
section mentioned intentions interpreting query graph graph pattern satisfied defines relation means distinguished edge 
observe force mapping nodes node labels sequence variables appear node 
circumstances cluttered picture faster editing graphs repeating node labels improve readability 
believe correspondence preferred far intuitive identify nodes variables 
person desc descendant descendant descendants descendants 
read query graph follows edges graph pattern relation defined distinguished edge holds 
interpretation naturally corresponds way read rules logic program 
correspondence requires mapping edge appropriate predicate 
mapping edges labeled closure literals requires particular attention 
match edges query graph labeled closure literals paths graph database 
corresponding predicate defined rules expressing transitive closure predicate literal labeling edge 
light discussion define translation function associates stratified datalog program query graph 
definition logical translation function function query graphs logic programs fe 
ln le ffl rule 
ffl 
resp 
resp 

resp 
resp 

resp 
resp 
rules precisely notation stands sequence equality resp 
inequality atoms pair variables component sequence 
note equality atoms seldom 
desc descendant tc descendant tc person 
descendant tc descendant 
descendant tc descendant descendant tc 
descendants descendants datalog 
jx jy jzj jx jx jw jx repeated variables jxj jy jzj jw rules example program listed result applying logical translation function query graph 
closure literals descendant translated idb predicate descendant tc rule defining descendant literal corresponding edge query graph 
literals appear negated edge label negative literal idb defined rules descendant tc edge label closure literal 
query graph corresponds logical rule rules expressing slight generalization transitive closure 
step specify query course express set rules means set graphs 
definition graphical query finite set query graphs edge labels contain classes predicate symbols idb predicates denoted ones appear label distinguished edge query graph edb predicates denoted ones appear label distinguished edge query graph 
logical programs associate graphical query graph information structure 
definition dependence graph graphical query directed graph nodes idb edb predicates appear edge labels query graphs edge resp 
iff query graph distinguished edge labeled resp 
labeling non distinguished edge definition logical translation function defined query graphs extended operate graphical queries simply union rules generated query graph 
arrival departure feasible feasible connected feasible flight connections 
semantics graphical query determined usual semantics associated set stratified datalog rules 
allow expressions graphlog query language graphical queries acyclic dependence graph 
note disallow explicit recursion recursion implicit closure literals 
definition graphlog query language defined set graphical queries dependence graph acyclic 
meaning graphical query meaning program stratified datalog semantics 
example shows graphical query query graphs query graph contained separate region box graphical query 
query applies database 
query graph defines predicate feasible flights flight arrives departure second 
second defines predicate connected cities sequence feasible flights 
wanted include directly connected cities draw query graph 
consider means avoiding drawing query graphs situations 
language considerably concise changing semantics generalizing literals closure literals arbitrary regular expressions 
step step follows 
new operators introduced definable terms basic language added convenience 
want edge query graph represent predicate operator denoting alternation predicates jp note care taken variables appear referred ghost variables query graph vanish idb predicate replaces alternation 
expression jp constitutes scope ghost variables 
ghost variable occur outside scope 
useful shortcut avoid drawing edges nodes represent path variables labeling nodes 
simply write sequence predicates appear path just edge 
order introduce composition predicates denoted introduce operator changes direction arrow edge query graph inversion predicate denoted gammap usefulness inversion operator appreciated combined composition 
addition particularly useful closure 
closure literal labeling edge query graph stands path graph representation database ground literals value appropriate valuation want sequence ground literal labels values path arbitrary project component variable predicate want avoid extra query graph 
underscore stand place variables want project 
constructs considered far considerably useful combination 
define set expressions results combined usage 
definition path regular expression short expression generated grammar gamma eje ee stands literal 
new operators defined term ones seen kleene closure denoted equivalent expression optional operator applied yields 
equivalent expression je 
father mother friend residence local family friends toronto finding local family friends 
aspects deserve attention 
restrictions apply ghost variables presence negation allows universal quantification paths query graph 
consider graphlog expressions graphical queries contain query graphs labels underscore literals know extensions add language convenience succinctness 
example suppose interested finding friends friends ancestors people live toronto residence predicate meaning person lives city parent predicate predicates father representing father mother representing mother giving name hospital relationship started 
shows graphical query query graph having nodes 
necessary query graphs nodes 
notice underscore position corresponding hospital mother relation 
variable position variable ghost variable asked ancestors fathers ancestors mothers descendants hospital 
example represents query software development environment 
nodes represents software modules functions libraries 
predicate module means function belongs module predicate calls local means function calls function defined locally module 
predicate calls means calls external function 
library means function library query shown defines predicate self meaning module uses directly indirectly async io library calls indirectly modules 
note translation datalog considering far safety equivalent logic program requires restricting occurrence negation outermost subexpression async io module calls module module calls local calls library self circularly modules invoking code async io library 
expressive power section results expressive power graphlog 
detailed exposition con 
introduce transitive closure queries properties 
definition transitive closure formula formula roe oe domain relational calculus query sequence variables length free oe bound roe transitive closure operator meaning roe transitive closure oe 
relational calculus extended transitive closure formulas denoted tc 
relationship complexity classes sets queries expressed language particularly relevant 
consider language ptc obtained tc allowing positive negation signs applications transitive closure operator 
result requires presence order relation domain imm 
lemma ptc set queries expressed formulas form zt roe vector necessarily distinct free variables substituted components transitive closure oe set existential order queries denoted te 
presence order 
domain constants language denoting resp 
values domain shown imm ptc 
te 
notice iff order formula 
introducing fo formula get rid constants surprising result imm imm ptc tc ptc closed complement 
lemma shows nondeterministic logspace closed complement long standing open problem complexity theory instance answers context sensitive languages closed complement au 
collect theorem consequences result 
theorem imm imm tc 
te 
provided order relation result ch shows query tests size database domain transitive closure query 
conclude lemma tc ae definition special cases datalog programs 
definition linear logic program rule recursive subgoal 
tc logic program linear program recursive idb predicate head exactly rules form 
xn 
yn 
xn 
yn 
xn 
yn 
xn 
zn 
zn 
yn rules referred tc rules 
set queries expressed linear resp 
tc datalog programs denoted datalog resp 
tc datalog 
parallel complexity logic programs studied kan 
shown datalog ae complete problems expressible datalog 
linear datalog programs express datalog queries nc ptime fact 
consider stratified linear resp 
tc logic programs expressions get restriction datalog denoted sl datalog resp 
stc datalog 
relation transitive closure queries stratified tc datalog queries holds lemma tc stc datalog study expressive power graphlog relate stratified datalog sublanguages considering 
called piecewise linear programs ull term linear logic program refer programs rule idb subgoal 
lemma tc stc datalog graphlog sl datalog datalog denote subset graphlog graphical queries negated literals edge query graphs corollary 
corollary tc datalog datalog datalog main contribution section improve results lemma consequences 
give algorithm translates stratified linear datalog program equivalent stratified tc datalog program 
idea translation comes informal description evaluation single linear rule transitive closure computation ull 
constants translation process represent signature predicates 
signatures allow codification predicates wider carries information predicates signature tells tuples wider predicate original predicates 
reason introducing constants simplify signature mechanism 
emphasize constants necessary 
signature techniques constants expense increased complexity developed ch presents technique inequalities shm develops signature mechanism datalog equalities inequalities 
light discussion algorithm results paying attention presence constants 
algorithm translation sl datalog stc datalog 
input stratified linear datalog program output equivalent stratified tc datalog program method step determine dependence graph 
strongly connected components scc choose predicates 

remaining procedure finding 
distinct constants 
maximum arities idb notation stands sequence constants example shows known generation example 
input algorithm result program 
algorithm creates edge start node nodes reachable initialization rule sg rule procedure 
note constant sg signature scc recursive rules rule head predicate add maximum arity predicates 
pn recursive rule 
xn 
yn 
add rule 
yn gamman 
xn gamman 
non recursive rule 
xn 
add rule 
xn gamman 
add tc rules predicate predicate add rule gamman translation sl datalog stc datalog 
sg person 
sg parent sg parent 
generation query linear datalog 
sg sg parent parent 
sg person 


sg sg 
generation query tc datalog 
predicate sg predicates edges corresponding linear recursive rule sg predicate added program rule procedure 
rule defining predicate sg tc datalog program introduced rule procedure tc rules predicate express path initial values sg node sg 
correctness algorithm proved showing equivalence input output logic programs induction iterations naive evaluation strongly connected component dependency graphs programs 
theorem algorithm correctly translates sl datalog program equivalent stc datalog program time polynomial size input 
corollary algorithm correctly translates datalog expression equivalent tc datalog program 
theorem tc stc datalog graphlog sl datalog proof existence algorithm shows sl datalog stc datalog 
results lemma conclude proof 
consequence theorem lemma bound data complexity graphlog 
lemma graphlog ae result theorem specialized monotone queries 
corollary tc datalog datalog proof result consequence property algorithm corollary corollary 
position improve data complexity result linear datalog 
lemma datalog ae proof lemma datalog tc datalog 
definition tc datalog ae stc datalog lemma shows stc datalog tc 
considering result lemma proves tc ae conclude datalog ae 
results complexity tightened presence order relation 
lemma tc stc datalog graphlog sl datalog proof lemma know ptc definition ptc tc 
result lemma conclude tc theorem affected presence order relation completes proof chain equalities hypothesis 
interesting consequence theorem theorem graphical query graphlog 
equivalent edge closure literal label 
know algorithm linear datalog program find equivalent tc datalog program application transitive closure exists property having sided equivalent program undecidable class decidable nau 
hand stratified linear programs constants order relation collapse equivalent programs application transitive closure argument applied previous paragraph 
diagram summarizes relationships expressive power query languages considered 
sets queries expressed relational calculus fixpoint formulas datalog inflationary semantics denoted fo fp datalog respectively 
relative height picture represents expressive power query languages shown omitting technical details presence order relation simplify diagram sets queries right hand side diagram monotone incomparable ones left hand side 
main result prove languages enclosed large ellipses equivalent expressive power 
aggregation summarization justify claim real life queries title need include additional features aggregation path summarization 
mq cq datalog fp tableau pe graphlog tc datalog stc datalog datalog fo sl datalog tc ye datalog datalog ype relative expressive power query languages considered 
introducing aggregation graphlog defined extension datalog incorporates aggregate functions 
proved extension captures class order queries aggregates 
defined graphlog aggregates translating query language logic programming sets ldl tz 
ldl provides facilities necessary defining aggregation logic programming framework 
problem logic programming sets arbitrary exponential data complexity see bee 
proposal retains polynomial time data complexity 
expressive power results section apply aggregate operators considered 
kinds applications require aggregation sets values appearing edge labels capability summarize information paths 
example find length shortest path nodes 
approach integrates aggregation path summarization uniformly 
space allow complete description illustrate example 
example consider task scheduling database storing data tasks affect represented predicate affects duration scheduled start task predicates duration scheduled start 
durations scheduled starts measured days initial day 
affects duration scheduled start duration duration delayed start ds earlier start max sum earlier start scheduled start max ds delay ds task affect tasks 
shows define graphlog predicate delayed start ds answers question delay ds task affect tasks 
query graph simply moves duration task new edge defined task affects 
second query graph defines predicate earlier start longest sum durations paths 
query graph new start time task task delayed ds defined simple calculation 
prototype implementation original effort consisted specialization smalltalk tm graph editor product ada editing query graphs displaying database graphs 
resulting editor supports graph cutting pasting text editing node edge labels node edge repositioning reshaping scrolling large graphs storage retrieval graphs text files graph editor available query evaluation component developed support edge queries 
simple queries containing nodes edge connecting edge may labelled arbitrary regular expression 
algorithms search database answers discussed mw 
user interface lets user display database displaying answer graphlog query 
graph part window query graph 
answers may displayed highlighting qualifying paths directly database graph viewing separate window turning union new graph queried 
possibility supports iterative filtering large complex graphs 
current prototype handles arbitrary graphlog queries including aggregation summarization 

shows queries database flights nodes cities edges flights 
binary predicate airline example edge labelled aa buenos aires lima means flight cities 
queries small windows top display 
large window displays result leftmost query define loop labelled rt scale going city back city scale sequence canadian pacific flights rome tokyo 
result displayed highlighting database window instances new edge 
graphlog system graphs held main memory smalltalk tm objects 
system interface processing graphlog queries top neptune hypertext front hypertext machine ham ds 
ham general purpose transaction multi user server hypertext storage system 
interface queries large graphs may posed 
described graphlog query language characterized expressive power 
doing established equivalence expressive power graphlog stratified linear datalog nondeterministic logarithmic space transitive closure 
results imply graphlog amenable efficient parallel implementations 
furthermore implementations benefit existing transitive closure computation linear datalog optimization see ull 
interesting research direction application graphlog data models complex objects object identity 
complexity results suggest graphlog may provide trade computational complexity expressive power 
current proposals bee require exponential time fail express transitive closures 
exception polynomial time restricted language ak proposal uses inflationary semantics negation natural simpler stratified semantics 
ada sam adams 
version 
knowledge systems 
ak serge abiteboul paris kanellakis 
object identity query language primitive 
technical report inria april 
au aho ullman 
universality data retrieval languages 
proc 
th acm symp 
principles programming languages pages 
bee beeri 
data models languages databases 
proc 
nd int 
conf 
database theory lecture notes computer science pages 
ch chandra harel 
structure complexity relational queries 
journal computer system sciences 
ch chandra harel 
horn clause queries generalizations 
logic programming 
ck stavros cosmadakis paris kanellakis 
parallel evaluation recursive rule queries 
proceedings fifth acm sigact sigmod symposium principles database systems pages 
cm mariano consens alberto mendelzon 
expressing structural hypertext queries graphlog 
proceedings second acm hypertext conference pages 
cruz mendelzon wood 
recursive queries recursion 
larry kerschberg editor proceedings second international conference expert database systems pages 
con mariano consens 
graphlog real life recursive queries graphs 
master thesis department computer science university toronto 
ds delisle schwartz 
neptune hypertext system cad applications 
proceedings acm sigmod international conference management data pages 
sigmod 
imm neil immerman 
languages capture complexity classes 
siam journal computing 
imm neil immerman 
descriptive computational complexity 
technical report department computer science yale university new haven 
imm neil immerman 
nondeterministic space closed complementation 
third structure complexity theory conference 
jan jagadish agrawal ness 
study transitive closure recursive mechanism 
proceedings acm sigmod annual conference management data pages 
sigmod 
kan kanellakis 
logic programming parallel complexity 
minker editor foundations deductive databases logic programming pages 
morgan kaufmann publishers 
anthony klug 
equivalence relational algebra relational calculus query languages having aggregate functions 
journal acm 
mw mendelzon wood 
finding regular simple paths graph databases 
proc 
th international conference large data bases pages 
nau naughton 
sided recursions 
proceedings sixth acm sigact sigmod symposium principles database systems pages 
shm shmueli 
decidability expressiveness aspects logic queries 
proceedings sixth acm sigact sigmod symposium principles database systems pages 
assoc 
comp 
machinery 
tz tsur zaniolo 
ldl logic data language 
proceedings twelfth international conference large data bases 
ull ullman 
principles database knowledge base systems volume 
computer science press md 
ullman van gelder 
parallel complexity logical query programs 
proc 
th ann 
symp 
foundations computer science pages 

