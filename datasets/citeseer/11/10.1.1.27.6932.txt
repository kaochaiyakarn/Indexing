comparing semantics linda languages nadia busi roberto gorrieri zavattaro dipartimento di scienze dell informazione universit di bologna zamboni bologna italy simple calculus generative communication introduced primitives contains conditional input operation tests presence absence output reminiscent inp predicate linda 
study different semantics output operation called instantaneous ordered unordered compare approaches different points view 
investigate associated behavioural semantics characterizing coarsest congruence contained barbed bisimulation 
obtain results instantaneous case coarsest congruence variant asynchronous bisimulation ordered unordered semantics obtain small variant classic synchronous bisimulation 
obtained congruences pairwise different 
compare expressiveness approaches 
list class coordination primitives directly implementable calculus instantaneous semantics ordered 
show calculus turing powerful instantaneous ordered approaches case unordered semantics 
conclude exists strict expressiveness hierarchy semantics 
keywords coordination languages semantics linda behavioural equivalences expressiveness concurrent languages 
generative communication realized means insertion withdrawal elements shared multiset peculiar feature family supported esprit working group 
extended revised version bgz 
author 
mail cs unibo 
preprint submitted elsevier preprint february ordination languages gc linda gel prominent representative 
communication mechanism adopted proposals coordination platforms java programming language sun javaspaces js ibm spaces 
generative communication principles sender communicates receiver shared data space called tuple space ts short emitted messages collected receiver consume message ts message generated process independent existence tuple space explicitly withdrawn receiver fact insertion ts message equally accessible processes bound 
communication asynchronous sender may proceed just performing emission message ts 
similarly receiver input message ts time hand shake synchronization ts receiver completes communication sender receiver side effect removing message ts 
non blocking output operation sends message tuple space blocking input operation removes message ts linda offers conditional input predicate called inp checks current status ts required message absent value false returned hand message behavior operation value true returned 
represent predicate means construct inp directs flow control depending presence absence message ts respectively 
presents investigation possible semantics generative communication process algebraic setting particular care output operation opinion received attention 
conceptually execution linda output primitive seen composed phases emission message sending ts rendering actual presence ts denote hai 
semantics going investigate inspired previous related proposals asynchronous object calculus ht informal semantics linda reported manual sca 
different semantics may summarized follows ffl instantaneous mean message ts 
parallel composition operator 
instance consider process wants input process composed parallel immediately input message approach adopted asynchronous calculus ht bou obtained means simple syntactic restriction language outputs prefixes 
intuitively semantics bit strange execution complexity certain actions depends syntactic continuation 
consider non output prefix single atomic step executes action puts tuple ha ts executes action puts messages ha ha ts 
ffl ordered emission rendering message form single autonomous atomic action internal step agent way order emission respected rendering order 
implementation simple sender sends message waits ts emission message realized means synchronous hand shake communication sender ts 
approach received operational treatment bgz 
ffl unordered emission rendering message distinct autonomous actions 
emits message agent internal step free proceed message ts hhaii takes internal step hai 
implementation operation trivial process sends message ts proceeds waiting message reach ts emission realized means asynchronous communication sender ts 
order emission may respected rendering order instance process executes sequence may rendered emission rendering best knowledge know process algebra studying semantics approach 
approaches equally interesting think worthwhile compare formally 
aim twofold 
hand compare interpretations output operator respect behavioural semantics hand analyse relative expressive power 
final result interpretations basically different point view behavioural semantics expressive power 
detail investigate behavioural semantics commonly approach characterize coarsest congruence contained barbed bisimulation ms coarse equivalence equates processes bisimilar reduction steps offer pair related states observable actions 
prove variant asynchronous bisimulation acs right semantics instantaneous semantics correct semantics cases variant classic synchronous bisimulation mil inputs outputs treated symmetrically 
resulting congruences pairwise different included 
regarding expressive power show precise hierarchy variants calculus instantaneous semantics expressive calculus ordered semantics turn expressive calculus unordered semantics 
separation result achieved showing series constructs directly implemented process algebra instantaneous semantics 
discuss possibility implementing linda rd rdp operators non consuming counterparts inp respectively test set operator 
second separation result basic 
show instantaneous ordered semantics possible encode random access machine ram ss turing equivalent formalism 
hand possible prove calculus turing powerful unordered semantics simply sketch proof idea petri net semantics calculus interested reader consult bgz 
structured follows 
section introduce syntax process algebra operational semantics primitive comparing differences instructive example 
section studies behavioural semantics section discusses expressiveness calculus 
section reports conclusive remarks appendix collects proofs theorems section 
language operational semantics mess ranged denumerable set message names ar ranged set program variables 
define agents denoted terms obtained grammar hai jp pna inp rec agents consist parallel composition messages ts denoted agent hai concurrent programs denoted sharing tuples 
restriction operator pna order possibility defining scope message names 
program terminated program usually omitted sake simplicity program starting coordination primitive inp parallel composition programs 
jq qjp ii jq jr qjr iii iv na pna nb pnb na vi jq na fn vii pna nb fresh viii rec rec table structural congruence 
coordination primitives represented usual prefixes inp requires sort construct 
fact inp program requires message consumed removed program executed chosen 
recursive agents defined agent variables standard operator recursion rec usual restrict closed terms guarded recursion mil 
agent denotes set containing possible agents 
set free names denoted fn defined follows fn fn fn jq fn fn fn hai fag fn pna fn fag fn fn fag fn fn inp fag fn fn fn rec fn different operational semantics language kind output prefix sketched 
semantics steps 
define structural congruences agents relation captures fact example order terms parallel composition effects behaviour 
define labeled transition hai gamma 
gamma 
inp gamma 
inp gamma 
ff gamma 
pna ff gamma 
na ff gamma 
pna gamma 
na gamma 
gamma jq gamma 
jq gamma 
gamma 
jq gamma 
jq ff gamma 
jq ff gamma 
jq ff ff gamma 
ff gamma 
table operational semantics 
systems specifying agents evolve means actions performed program 
structural congruence instantaneous semantics smallest congruence satisfying rules viii table ix table 
structural congruences ordered unordered semantics denoted defined smallest congruence satisfying viii 
labelled transition systems kind agent label gamma 
label fg fa ranged ff fi set possible labels represents internal action stand input output test absence operations respectively 
labelled transition relation gamma 
instantaneous semantics smallest satisfying axioms rules table gamma 
ordered semantics satisfying axiom table gamma 
unordered semantics considers axioms rules 
indexes distinguishing structural congruences transition relations omitted clear context 
axiom shows tuple hai able give contents environment performing action labeled axioms define possible input actions message action labeled execution successful inp operation respectively 
process executing inp find required message guess absence performing action labeled axiom 
rule states actions containing name performed agent pna 
agent willing perform action restricted name operation local step computation labeled instantaneous ix ordered gamma 
unordered gamma 
hhaii gamma 
hai table semantics primitive 
agents offer message words search finished local name rule 
hand composed parallel agent executability jq depends inability offer message guess wrong executed rule 
rules usual synchronization complementary actions local actions parallel composed agents possibility executing actions structurally congruent agents 
rules recursion semantics defined congruence rule viii applies unfolding step recursively defined program 
rule uses negative premise easy see transition system specification strictly gro exists unique transition system agreeing 
rules differentiate semantics table 
instantaneous approach messages considered available moment output operation performed 
obtained introducing rule structural congruence stating program starting prefix putting tuple hai parallel continuation program 
rule ix may relate guarded terms unguarded ones rec rec consider guarded terms program variable occurs inside prefix inp construct 
ordered approach output operation consists local non blocking action labeled creates tuple hai 
way sequence output executed messages rendered order emitted 
unordered approach execution output operation emitting message directly generate corresponding tuple hai creates agent message available non predictable delay 
agent denoted hhaii able perform internal action labelled hai 
example example inspired sca allows show differences semantics 
consider difference order emission messages def inp def inp observe restricted names ensures inp operations names executed locally 
instantaneous semantics messages available instant testing process consumes executes inp primitive required message consumed 
inp continuation ordered semantics messages available order emitted 
case test performed inp operation gives rise different results 
presence message ensured available continuation inp operation presence absence tuple instant inp executed depends order execution operations inp primitive performed operation message continuation consumed continuation 
unordered semantics shows third kind behaviour messages available unpredictable order search performed inp operation give rise success failure behaviours agents different semantics summarized showing possible continuations inp operator instantaneous ordered unordered syntax agents extended case unordered output semantics allowing agent hhaii function returning free names extended adding fn hhaii fag 
behavioural semantics section problem defining observational semantics different operational semantics considered 
show means example standard notion bisimulation mil satisfactory language 
example example term rec agent observable behaviour consists infinite sequence steps 
term part syntax language easily encoded agent rec nb possible solution 
consider agents def rec inp def rec agent recursively performs possible transitions labelled respectively hand agent outgoing transitions labelled easy see standard bisimulation distinguishes terms agent derivation labelled allowed extra transition add possible behaviours agent 
particular difficult see behaviour possible contexts words distinguished external observer 
extra transition performed hai available environment environment left unchanged execution step 
agent able mimic behaviour performing labelled transition 
example example shows standard bisimulation treats standard label strong calculus 
order overcome limitation consider modified bisimulation treats label approach justified fact label introduced helping sos formulation semantics conceptually internal step performed particular contexts 
bisimulation kind equates agents satisfactory general 
example consider terms def def inp represents output operation internal step happens term nb 
agents equated bisimulation distinction labels agents distinguished term def produce message hci 
happens produce hbi soon hai available 
examples shows need investigate new notion standard bisimulation concrete bisimulation distinguish labels idea follow commonly approach consists investigating coarsest congruence contained barbed bisimulation ms coarse equivalence equates processes bisimilar reduction steps offer pair related states observable actions 
ms proved ccs mil obtained equivalence corresponds classical notion bisimulation 
show setting coarsest congruence contained barbed bisimulation bisimulation equate agents example 
order define barbed bisimulation introduce notion reduction commitments 
language consider reductions usual derivations labeled labeled fact derivation gamma 
indicates tuples hai available external environment 
stand external environment considered able formally gamma 
iff gamma 
gamma 
consider weak notion reduction abstracts away number derivations needed iff gamma 
attention paid order identify observable 
linda languages notion uncoupled interaction shared data space ts natural consider ts observable part system 
words external observer allowed directly interact processes communicate introducing consuming testing actual state ts 
model permitting observe presence certain kind tuple hai corresponding ability performing transition labelled iff gamma 
interesting observe notion commitment essentially defined acs setting asynchronous calculus channel communication considered generative communication shared data space 
define weak commitment order able denote possibility certain commitment reduction steps iff resulting definition barbed bisimulation definition binary symmetric relation agent barbed bisimulation implies ffl gamma 
exists gamma 
ffl agents barbed bisimilar written ffl exists barbed bisimulation stated investigate coarsest congruence contained barbed bisimulation semantics 
ordered case part take account ordered semantics prove case coarsest congruence contained ffl bisimulation 
definition binary symmetric relation agent bisimulation implies ffl ff gamma 
ff exists ff gamma 
ffl gamma 
exists delta gamma 
delta gamma 
agents bisimilar written exists bisimulation coarsest congruence contained barbed bisimulation asynchronous calculus asynchronous bisimulation acs 
bisimulation allows input action matched internal step bisimulation true 
difference due fact asynchronous calculus process receive message similar proof appeared bgz recall consequent proofs :10.1.1.51.321
immediately emit 
allows process simulate input action followed instantaneous emission consumed message internal action 
happen ordered output instantaneous emission allowed 
formalized proposition 
proposition agent gamma 
proof induction proof transition gamma 
reason structural congruence shorthand copies agent composed parallel stands jp fa need propositions 
indicates agent having derivation labelled perform step labeled contains tuple hai 
shows agent able perform consecutively steps labeled occurrences tuple hai contained 
proposition agent gamma 
proof induction proof transition gamma 
proposition agent 
gamma 
gamma 
gamma 
hai 
proof proof uses double induction number successive derivations labeled proceed induction proof th derivation gamma gamma 
order prove bisimulation coarsest congruence contained barbed bisimulation unordered case assert congruence prove agents barbed bisimilar context bisimilar 
proposition bisimulation congruence 
proof congruence result omitted standard mil 
theorem agents 
jr ffl qjr agent proof complete proof appendix sketch structure 
agents satisfying premises theorem 
fn fn observe finite 
show pair contained bisimulation particular define agent relation sjr ffl jr fn fn lg bisimulation 
pair jr barbed bisimilar qjr fn fn subsets corollary bisimulation coarsest congruence contained barbed bisimulation ordered semantics 
proof congruence contained ffl show 
fact jr qjr agent congruence 
ffl follows jr ffl qjr 
theorem holds 
unordered case unordered semantics bisimulation coarsest congruence contained barbed bisimulation 
easy see propositions hold unordered semantics 
case facts required 
fact agents gamma 
gamma 
gamma 

fact agent hhaii gamma 
gamma 
times hai new version theorem adapted unordered semantics 
theorem agents 
jr ffl qjr agent proof proof reported appendix follows structure proof theorem 
corollary bisimulation coarsest congruence contained barbed bisimulation unordered semantics 
proof proof corollary theorem theorem 
instantaneous case instantaneous semantics coarsest congruence contained barbed bisimulation asynchronous bisimulation 
definition binary symmetric relation agent asynchronous bisimulation implies ffl gamma 
exists gamma 
ffl gamma 
exists delta gamma 
delta exist gamma 
gamma 
ffl gamma 
exists delta gamma 
delta gamma 
delta exist gamma 
gamma 
ffl gamma 
exists delta gamma 
delta gamma 
jhai delta exist gamma 
jhai gamma 
jhai agents asynchronous bisimilar written exists asynchronous bisimulation stated asynchronous bisimulation acs input step matched labelled transition provided new tuple emitted immediately consumption step 
similarly instantaneous semantics new tuple rendered immediately consumption step asynchronous bisimulation allows matching input operations internal steps asynchronous bisimulation 
reason called equivalence asynchronous 
new matchings allowed asynchronous bisimulation understood considering name appearing def inp def na agents distinguished instantaneous semantics perform internal step computation having influence environment order equate agents asynchronous bisimulation introduce new matchings 
example labelled step matched transition labeled possible tuple hbi generated immediately having consumed equivalent continuation chosen message environment 
order prove asynchronous bisimulation coarsest congruence contained barbed bisimulation instantaneous case proceed ordered unordered semantics 
assert congruence prove agents barbed bisimilar context asynchronous bisimilar 
proposition asynchronous bisimulation congruence 
theorem agents 
jr ffl qjr agent proof proof reported appendix follows structure proof theorems 
corollary asynchronous bisimulation coarsest congruence contained barbed bisimulation instantaneous semantics 
proof proof corollary theorem theorem 
interesting note inp construct restriction operator definition context proof coarsest congruence allows conclude results obtained valid eliminate operators language 
drop inp construct syntax immediately clear label meaningless bisimulation asynchronous bisimulation collapse standard mil asynchronous bisimulation acs respectively 
conclude inp removed language coarsest congruence contained barbed bisimulation standard bisimulation intended semantics ordered unordered asynchronous bisimulation case instantaneous interpretation 
comparing equivalences equivalence instantaneous semantics ordered unordered semantics infer different equivalences language iff instantaneous semantics iff ordered semantics iff unordered semantics show examples congruences different included 
example consider agents def inp def inp def instantaneous semantics agents equivalent unique behaviour agents messages consumed new message emitted 
case ordered semantics equivalent generate message emit 
unordered semantics equivalent generate message emit 
example shows possible prove inverse inclusions false shown agents reported example 
example sake readability example prefix internal choice phi operator part syntax language encoded 
particular program term agent forced perform internal labelled step activating possible encoding represented agent na free name hand programs term phi activate performing labelled step 
possible encoding phi jin na name appear free consider agents def inp def phi phi phi phi difficult see unordered semantics particular gives rise exactly transitions words syntactic representation derivation tree 
equivalent case instantaneous ordered semantics cases 
prove def inp def phi phi case ordered semantics transitions instantaneous semantics equivalent expressiveness language section analyze expressive power calculus different semantics 
compare instantaneous ordered semantics 
proceed studying possibility encoding remaining linda primitives rd rdp non consuming versions inp respectively 
show instantaneous semantics possibility emitting instantaneously new tuples permits implementation operators ordered semantics 
show language extended explicit rd rdp operators exist coordination primitives provided linda sort atomic test set operator encoded instantaneous semantics ordered 
recall result bgz language turing powerful instantaneous ordered semantics expressive model random access machine ram ss case unordered semantics language turing powerful 
comparing instantaneous ordered semantics compare instantaneous ordered semantics analyzing problem implementing linda rd coordination primitive 
encoding rd primitive linda language linda provides non consuming input operator rd bgz operator modelled means new prefix rd introduce extending definition concurrent programs follows rd semantics extended considering axiom rule rd gamma :10.1.1.51.321
gamma 
gamma 
jq gamma 
jq axiom introduces new label observable action performed rd prefix 
label different standard label way synchronizes labels rule indicates process performing derivation left unchanged way tuple hai consumed 
rd coordination primitive encoded instantaneous semantics simply considering input operation followed immediate ts consumed tuple 
easy see example rd jhai ffl jhai fact agents able perform reduction step leading agent structural congruent jhai 
general inductively define encoding rd mapping agents terms contain new rd prefix prove adequacy encoding 
basic terms hai encoding simply returns agents composed agents different rd encoding applied definition reduction remains new label transition labelled performed empty environment tuple hai required 
inp rd inp rd rd 
unique non trivial case rd rd rd correctness encoding instantaneous semantics proved showing rd indistinguishable context 
context agent hole denotes term obtained filling hole proving adequacy encoding need point facts 
fact agent 
gamma 
jhai 
fact agent 
instantaneous semantics ff gamma 
rd ff gamma 
rd rd gamma 
rd ff rd ff gamma 
ff gamma 
rd gamma 
rd ff theorem agent 
context instantaneous semantics ffl rd 
proof show relation rd rd pg barbed bisimulation 
reason structural congruence fact immediately follows sufficient show gamma 
gamma 
consider case rd case treated similar way 
agent involved reduction step context changes context 
gamma 
rd rd agent involved context agent ff gamma 
fact cases analyse 
case rd ff gamma 
rd rd gamma 
rd rd second case ff rd gamma 
rd reduction gamma 
consists synchronization read operation performs output action gamma 
context 
fact gamma 
ensures fact jhai 
applying structural rules possible put agents syntactically contact loss generality suppose jp 
fact jhai ensures substitutivity jp 
synchronization leads agent observe left unchanged 
consider agent rd structurally congruent rd 
derivation rd gamma 
rd agent able perform reduction step gamma 
rd 
sufficient observe rd order prove rd primitive implemented ordered semantics consider problem implementing particular agent called tester presence show implemented ordered semantics making rd primitive 
definition agent tester presence tuple hai iff jhai message names indicating presence tuple hai fact absence tested respectively 
agent clearly tester presence tuple hai def rd encoding tester ordered semantics 
observe sequence reduction steps permitted ordered interpretation invalidates item definition gamma 
gamma 
gamma 
prove way implement tester presence ordered semantics making rd primitive 
point fact recall proposition 
fact agent 
jin jin proposition states agent interpreted ordered semantics gamma 
means ordered semantics possible instantaneously emit new tuples consumption step 
true instantaneous semantics consider program having derivation gamma 
hai clear lemma analyzes agent gamma 
fact indicates agent contains tuple hai derivation gamma 
ensures able consume tuple hai 
prove consume internal tuple looking external 
formally derivation gamma 
jhai holds 
lemma agent interpreted ordered semantics 
gamma 
gamma 
jhai prove agent satisfies definition able consume tuple hai ts 
proposition agent interpreted ordered semantics 
jhai exists jhai proof jhai exists jhai gamma 
gamma 
gamma 
proceed induction base case jhai jhai easy see implies contradiction strictly greater 
inductive case consider step jhai gamma 
cases analyze 
case jhai gamma 
thesis directly follows inductive hypothesis applied fact jhai weakly commit second case gamma 
suppose analyze tha case fact gamma 
ensures lemma gamma 
jhai 
thesis directly follows inductive hypothesis applied fact jhai weakly commit fact gamma 
ensures proposition 
able prove possible ordered semantics implement tester presence tuple hai theorem agent interpreted ordered semantics 
message name tester presence tuple hai 
proof contradiction suppose tester presence tuple hai 
item definition ensure jhai proposition exists jhai fact 
fact ensures branch inp chosen way tuple ht emitted invalidating definition 
show rd operator sufficient cover gap expressivity instantaneous ordered semantics 
order prove consider problem encoding linda rdp primitive 
encoding rdp primitive linda language linda provides non consuming input predicate rdp 
bgz model operator extending definition concurrent programs follows rdp semantics extended adding axioms rdp gamma :10.1.1.51.321
rdp gamma 
axiom indicates tuple hai available agent rdp behaves axiom 
rdp coordination primitive encoded instantaneous semantics simply considering inp operation required tuple consumed immediately reintroduced ts 
example easy see instantaneous semantics rdp ffl inp rdp jhai ffl inp jhai 
case reduction step leading permitted second case terms structurally congruent jhai 
rdp operator inductively define encoding rdp mapping generic agents terms new rdp construct 
encoding exists unique non trivial case rdp rdp inp rdp rdp theorem agent 
context instantaneous semantics ffl rdp 
proof observe fact holds rdp substituted rd reasoning followed proof theorem prove relation rdp rdp pg barbed bisimulation order prove rdp primitive implemented ordered semantics consider problem implementing particular agent called tester absence show implemented ordered interpretation making new rdp primitive 
definition agent tester absence tuple hai iff jhai message name indicating absence tuple hai 
agent clearly tester absence tuple hai def rdp encoding inp tester ordered semantics 
observe sequence reduction steps permitted ordered interpretation invalidates item definition rdp gamma 
gamma 
gamma 
prove way implement tester absence ordered semantics making rdp primitive 
order prove consider initial language extended rd prefix 
proceeding proof need observe agent able perform derivation labeled fact agent 
exists gamma 
lemma states agent contain rdp constructs able perform derivation able perform labeled due fact derivations labeled induced inp term term allows derivation labeled words agent testing absence certain tuple able consume 
lemma agent 
gamma 
exists gamma 
prove agent satisfies definition able consume tuple hai ts 
proposition agent interpreted ordered semantics 
jhai exists jhai proof exists gamma 
gamma 
gamma 
proceed induction base case implies contradiction jhai strictly greater 
inductive case consider reduction step gamma 
corresponding labeled transition ff gamma 
ff ff ff ff thesis directly follows inductive hypothesis 
fact applied jhai jhai weakly commit ff fact lemma exists gamma 
way tuple hai consumed jhai gamma 
fact ensures proposition holds presence rd operation 
able prove possible ordered semantics implement tester absence tuple hai theorem agent interpreted ordered semantics 
message name tester absence tuple hai 
proof similar proof theorem proposition proposition 
show rdp operator sufficient cover gap expressivity instantaneous ordered semantics 
words linda coordination primitives considered instantaneous semantics language expressive 
order prove consider problem encoding sort test set operator atomically tests absence tuple produces case available 
encoding atomic test set primitive consider test set operator atomically verifies absence certain tuple available produces new occurrence 
atomic test set operator modelled language extending definition concurrent programs follows semantics extended adding axioms gamma 
gamma 
tuple hai available agent evolves axiom new occurrence hai emitted agent evolves single step axiom 
test set primitive encoded instantaneous semantics simply rdp operation instantaneously produce new tuple having tested absence 
easy see example rdp possible derivations leading structurally equivalent agents 
fact second agent derivations rdp gamma 
rdp gamma 
general inductively define encoding mapping agents terms contain test set operator prove adequacy encoding 
encoding exists unique non trivial case rdp time correctness encoding stronger agent encoding derivations leading structurally congruent terms 
theorem agent 
instantaneous semantics ff gamma 
ff gamma 
proof induction proof derivation 
order prove atomic test set primitive implemented ordered semantics consider problem implementing particular agent called mutually exclusive producer show implemented ordered interpretation 
definition agent mutually exclusive producer tuple hai iff jm jin message name indicating occurrences tuple hai detected 
idea underlying mutually exclusive producer able produce new occurrence tuple presence producer enabled perform emission operation 
producing tuple mutually exclusive producer way verify presence concurrent producer 
agent clearly mutually exclusive producer tuple hai def computations tuple hbi hai 
mutually exclusive producer begins computation verifies absence hbi immediately produces occurrence hbi enabled produce hai second agent verifies presence hbi terminates producing hai 
encoding rdp mutually exclusive producer ordered semantics 
observe sequence reduction steps permitted ordered interpretation invalidates item definition rdp jin gamma 
jin gamma 
jin ht prove way implement producer calculus extended rd rdp ordered semantics 
lemma states ordered semantics new tuples emitted execution derivation words way instantaneously emit new tuples execution test absence 
lemma agent interpreted ordered semantics gamma 
prove ordered semantics agent able produce tuple hai composed parallel occurrence tuples hai produced 
proposition agent interpreted ordered semantics 
exist jp gamma 
gamma 
proof exists gamma 
gamma 
gamma 
proceed induction base case ensures exists gamma 
jp gamma 
qjp gamma 

inductive case consider reduction step gamma 
corresponding labeled transition ff gamma 
ff ff ff jp gamma 
jp gamma 
jp thesis directly follows inductive hypothesis applied ff fact holding presence rdp operator gamma 
lemma ensures jp gamma 
jp gamma 
jp thesis directly follows inductive hypothesis 
able prove possible ordered semantics presence rd rdp operators implement mutually exclusive producer tuple hai theorem agent interpreted ordered semantics 
message name mutually exclusive producer tuple hai 
proof contradiction suppose mutually exclusive producer 
item definition ensures proposition exist jp gamma 
gamma 
fact holding presence rd rdp operators jp jin jin gamma 
jin gamma 
gamma 
invalidating item definition 
conclude complete language linda possible implement atomic test set operator intended semantics ordered 
atomic test set coordination primitive interesting point existence entire class coordination primitives embedded instantaneous semantics ordered 
particular think generalize test set operator way 
positive natural number atomic test set operator able atomically test absence tuple hai case absent produce occurrences tuple 
instantaneous semantics test set operator embedded approach described test set operator 
consider example agent rdp times able produce occurrences tuple hai immediately having tested absence tuple 
proof technique standard test set operator possible prove test set operator embedded positive natural number intended semantics ordered 
comparing ordered unordered semantics ram computational model consisting finite set registers hold arbitrary large natural numbers program sequence simple numbered instructions arithmetical operations contents registers conditional jumps 
perform computation inputs provided registers registers program supposed contain value computation 
execution program begins instruction continues executing instructions sequence jump instruction encountered 
execution stops instruction number higher length program reached happens program executing instruction program instruction require jump current instruction requires jump instruction number appearing program 
program terminates result computation content registers specified outputs 
min shown instructions sufficient model recursive function ffl succ add content register ffl contents register zero decrease go instruction jump instruction example program computes sum registers putting result register note third instruction corresponds unconditional jump register contains value computation contents modified program succ encode ram language ordered instantaneous interpretations 
translation model contents registers program counter means tuples register contains number tuples hr tuple space instruction execute th ts contains tuple hp model instruction proceed way succ instruction register position represented agent consumes program counter tuple adds tuple hr updates program counter adding tuple hp instruction position modeled agent consuming program counter tuple performs inp message operation succeeds tuple hr withdrawn tuple space agent updates program counter adding hp jump th instruction performed adding hp recursion operator representation instructions permits reuse 
succ def rec def rec inp agent modeling program inputs nm hp ij hr ij times hr ij nm times unordered case implementation ram correct unordered semantics problems updating program counter 
consider execution program instructions succ register empty moment th instruction executed 
implementation succ instruction creates tuples hr new program counter tuple hp tuple hp available hr instruction execute jump tuple hr available 
instantaneous ordered semantics kind problems arise program counter tuple available simultaneously instantaneous case ordered case tuple hr unordered semantics order rendering tuples predictable wrong jump performed 
say implementation correct unordered semantics assert ram implementable way 
fact semantics language turing powerful bgz show problem termination decidable unordered semantics 
proof divided steps define net semantics terms contextual nets nets extended arcs testing presence absence tokens place see bp 
semantics defined style bg bgz preserves interleaving behaviour possibility deadlock 
contextual net semantics mapping finite standard nets preserves deadlock 
deadlock decidable finite nets conclude termination problem decidable unordered semantics 
research different interpretations output operation studied compare point view behavioural semantics expressive power 
think necessary step order equip formal semantics linda deeper understanding class linda coordination models javaspaces js spaces 
instance manual sca linda unclear real interpretation primitive 
illustrative example consider inp 
assume ordered semantics input possible hbi ts execution inp enable differently assume unordered semantics guarantee hbi ts language adopted bgz slight variation calculus considered uses input guarded replication guarded recursion contain restriction proof non turing equivalence easily adapted 
possible executed 
choice semantics solved sca similar publications nar 
instance page sca read returns tuple added tuple space supporting claim intended semantics ordered 
hand page sca comment program reported page expresses concern similar possible executability validating intended semantics ordered 
similar contradictions regarding shared memory implementations nar lines page said ensured followed predicate operation tuple succeed supporting intended semantics unordered 
lines page read time tuple visible processes indeterminate 
existing shared memory implementations operation completed immediately validating ordered semantics approach 
interpretations discussed consider instantaneous semantics corresponds way asynchronous communication modeled previous proposals asynchronous process algebras ht bou 
setting approach theoretical relevance implementation unrealistic circumstances requires atomic emission unbounded amount new tuples 
point view behavioural semantics obtained congruences pairwise different includes 
regarding expressive power shown precise hierarchy semantics 
particular listed coordination primitives direct implementation instantaneous semantics ordered shown calculus turing powerful intended semantics instantaneous ordered case unordered interpretation 
approach problem termination deadlock decidable 
observe direct comparison operational semantics help deciding properties programs 
instance clear transition systems program semantics precise relation transition system ordered semantics obtained pruning transitions unordered turn transition system instantaneous semantics obtained pruning transitions ordered semantics 
deadlock free unordered semantics proven decidable property deadlock ordered instantaneous semantics 
plan investigate issue 
mention left research investigation interesting implementations output operation nar tuple generated process means operation visible process time linda operation executes tuple guaranteed visible process variable latency period past 
study carried extended cope coordination primitives rd rdp linda operators described section far behavioural semantics concerned studied bgz ordered case :10.1.1.51.321
proofs section theorem agents interpreted ordered semantics 
jr ffl qjr agent proof agents satisfying premises theorem 
fn fn observe finite 
show pair contained bisimulation particular define agent def ag ag ag ag ag relation sjr ffl jr fn fn lg bisimulation 
pair jr barbed bisimilar qjr fn fn subsets agents ag defined follows ag def rec ag def rec ag def rec ag def rec ag def rec fresh distinct names tuples hb called presence tokens agent ag able generate consume corresponding presence token hb agent ag ag ff gamma 
gamma 
performs transition step corresponding presence token produced single reduction step 
order prove bisimulation observe symmetric ffl proceed case analysis possible derivations ff gamma 
proving case able reply definition bisimulation 
ffl gamma 
consider sequence derivations agent sjr perform presence agent ag term ag ag ag ag ag sjr gamma 
ag jr def gamma 
ag jr def gamma 
jr def observe agent jr barbed bisimilar sjr jr gamma 
gamma 
gamma 
ffl jr generate consume presence token hb 
immediately clear agent ag involved reductions jr reduction step consist consumption tuple hai performed prefix ag consumed tuple hai contain tuple 
gamma 
jr second third reduction steps consist generation withdrawal presence token hb respectively 
observe jr ffl jr fn fn ffl gamma 
restrictive suppose hai easy see gamma 
term hai infer derivation 
hai 
consider sequence reduction steps renames tuples hai appearing sjr tuples hc fresh 
renaming performed agent ag term ag ag ag ag ag sjr gamma 
gamma ag jr def gamma 
gamma ag jr def gamma 
gamma ag jr def gamma 
gamma ijr def gamma 
hc ijr def observe alternatively steps presence token hb generated consumed 
agent jr barbed bisimilar sjr jr gamma 
gamma 
gamma 
ffl sequence reductions performed jr presence token hb alternatively generated consumed steps times 
agent ag able involved steps guard performed times tuples hc created 
requires gamma 
gamma 
gamma 
def proposition hai 
hc ijr agent able generate new tuple hai ag consumed performing derivation gamma 
term ag ag ag ag ag gamma 
hc ag jr def gamma 
hc ag jr def gamma 
hc ag jr def gamma 
hc ijr def observe follows proposition gamma 
offer equivalent reduction steps gamma 
gamma 
gamma 
ffl fact presence token hb appears reduction steps implies steps performed ag implies tuple hai generated ag consumed reduction step 
consumption performed agent context 
second case agents ag performs operation involved 
implies contradiction ffl see observations presence tokens proof gamma 
requires steps order generate new presence token hb tuple hai removed means derivation gamma 
conclude hc ijr 
tuples hc renamed hai agent ag term ag ag ag ag ag gamma 
gamma hc ag jr def gamma 
gamma hc ag jr def gamma 
gamma hc ag jr def gamma 
gamma hc def gamma 
def observe alternatively steps presence token hb generated consumed 
agent barbed bisimilar gamma 
gamma 
gamma 
ffl sequence reductions performed presence token hb alternatively generated consumed steps times 
agent ag able activated times 

ensures ffl hai hai observed hai 
gamma 
ensures gamma 
hai 
ffl gamma 
def fa gamma 
subset cardinality set avoid derivation gamma 
matched reduction step label different introduce ts tuples hai disallowing perform derivations 
proposition agent sjr execute sequence reduction steps agents ag generate tuples hl term ag ag ag ag ag agent ag ag ag ag lnl ag sjr gamma 
ag jr def gamma 
ag jr def gamma 
sj hl ij hb ij ag jr def barbed bisimilar agent jr allow sequence reductions jr gamma 
gamma 
gamma 
ffl order generate presence tokens hb agents ag involved hl ij hb ij ag jr agent able perform reduction due gamma 
gamma 
hl ij hb ij ag jr def agent allow reduction step gamma 
ffl usual observations presence tokens allow state involved reduction step agents ag step remove tuples hl observe 
step inferred agent output input step agent environment synchronize steps 
derivation labeled performed presence environment tuple hai remember definition gamma 
implies 
derivation labeled hl ij hb ij ag jr gamma 
tuples hl presence tokens hb removed 
term nfl ag jr gamma 
nfl hl ij hb ag jr def gamma 
nfl hl ij nfl hb jr def gamma 
jr def ffl gamma 
gamma 
gamma 
ffl consumption presence tokens steps ensures agent involved 
jr observe jr ffl jr ensures ffl gamma 
proof previous case difference set defined def fb gamma 
ag 
case message name element simulate step derivation labeled fact new definition possible derivations gamma 
gamma 
theorem agents interpreted unordered semantics 
jr ffl qjr agent proof agents satisfying premises theorem fn fn observe finite 
consider term defined proof theorem 
show relation sjr ffl jr fn fn lg bisimulation proving main differences proof ordered case due fact context emits tuple step required tuple effectively rendered ts 
example observations presence tokens adapted 
agent ag able generate consume corresponding presence token hb agent ag ag ff gamma 
gamma 
gamma 
performs transition step corresponding presence token produced reduction steps 
order prove bisimulation observe symmetric proceed case analysis possible derivations ff gamma 
consider case gamma 
cases easy adaptations unordered semantics corresponding cases treated proof theorem 
ffl gamma 
restrictive suppose hai easy see gamma 
hai 
consider sequence reduction steps divided phases 
terms defined analysis case gamma 
proof theorem 
phase tuples hai appearing sjr replaced new term hhc ii sjr gamma 
gamma ag jr def gamma 
gamma ag jr def gamma 
gamma ag jr def gamma 
gamma ag jr def gamma 
gamma def gamma 
hhc def reduction steps phase performed ag phase tuples hai second phase term hhaii emitted gamma 
hhc ag jr def gamma 
hhc ag jr def gamma 
hhc ag jr def gamma 
hhc def phase requires reduction steps performed ag third phase term involved tuple hai rendered consumed gamma 
hhc def gamma 
hhc def steps terms hhaii involved 
fourth phase terms hhc ii replaced term hhaii gamma 
gamma hhc ijr def gamma 
gamma hhc ag jr def gamma 
gamma hhc ag jr def gamma 
gamma hhc ag jr def gamma 
gamma hhc ag jr def gamma 
gamma hhc def gamma 
def phase agent ag terms hhc ii involved 
phase terms hhaii reduced hai gamma 
def gamma 
gamma def gamma 
def fact jr barbed bisimilar sjr ensures jr gamma 
gamma 
gamma 
ffl phases treated way proceeded proof theorem 
hhc hhc hai observe phase prove general terms jr ffl jr hai hai result 
third phase context involved remember observations presence tokens terms hhc ii 
reductions performed term gamma 
gamma 
hhc 
fact permits apply fact 
gamma 
proposition ensures gamma 
hai 
fourth phase treated 
fact context terms hhc ii surely involved reduction steps 
way easy see phase context involved hhaii gamma 
gamma 
times jr ffl jr ensures remember hai observations analysis phase allows state hai 
hhaii gamma 
gamma 
times hai fact substitutivity hai 
analysis third phase proved gamma 
hai gamma 
theorem agents interpreted instantaneous semantics 
jr ffl qjr agent proof agents satisfying premises theorem 
fn fn observe finite 
show pair contained asynchronous bisimulation particular define agent def ag ag relation sjr ffl jr fn fn lg asynchronous bisimulation 
pair jr barbed bisimilar qjr fn fn subsets agents ag defined follows ag def rec ag def rec fresh distinct names observe agents ag defined proof theorem 
observation presence tokens changed changed semantics agents ag defined different way 
proof ordered case presence tokens ensured possible detection step context presence token rendered reduction step 
steps new agent immediately detected 
ag moves presence token instantaneously appears 
ag involved computation initially available presence token consumed 
ordered unordered semantics observe symmetric proceed case analysis possible derivations ff gamma 
omit analysis case gamma 
treated way proof ordered semantics 
analysis adapted agent different considers agents ag observed defined way proof theorem 
ffl gamma 
def fb gamma 
jr ffl ag subset cardinality set avoid derivation gamma 
matched reduction step label reason consider computation tuples hbi produced 
agent sjr execute sequence reduction steps agents ag generate tuples hl sjr gamma 
ag ag ag def gamma 
sj hl ij hb ij ag ag lnl ag def gamma 
sj hl ij nfl hb ij nfl ag ag lnl fl ag def gamma 
sj hl ijr def barbed bisimilar agent jr allow sequence reductions jr gamma 
gamma 
gamma 
ffl order produce presence tokens hb consume agents ag involved reduction steps 
hl ijr 
second phase term ag produce tuple hai consumed means derivation gamma 
gamma 
ag hl ag ag def gamma 
hl ijr def gamma 
hl ijr def agent allow reductions gamma 
gamma 
gamma 
ffl steps surely induced agent ag presence token rendered step consumed second 
ensures hl ijr 
third step crucial 
term involved surely changes available presence tokens 
term involved 
proceed case analysis possible ways agent infer reduction step 
delta gamma 
gamma 
case zj hl ijr case jhai second 
tuples hl consumed corresponding agents ag gamma 
nfl hl ag ag ag def gamma 
hb ij ag lnl ag ag def gamma 
nfl hb ij nfl ag lnl fl ag ag def gamma 
jr def barbed bisimilar agent allow sequence reductions gamma 
gamma 
gamma 
ffl order produce presence tokens hb consume agents ag involved reduction steps 

ensures jr ffl 
gamma 
gamma 
jhai delta gamma 
fag case hl ijr 
proceeding way previous case possible prove jr ffl 
definition implies contradiction reduction gamma 
inferred derivation gamma 
delta gamma 
case hl ijr 
proceeding case difference tuple hbi removed term hl ijr easy prove ffl 
definition true gamma 
jr ffl 
ffl gamma 
proof essentially previous case differ ences 
definition set changed def fb gamma 
jr ffl second consists changing intermediary phase term involved 
phase reduced single step performs derivation gamma 
way term forced perform kinds derivation gamma 
gamma 
case proved jr ffl jr second case ffl jr definition gamma 
jr ffl jr ffl gamma 
proof previous case difference set defined def fb gamma 
jr ffl jr ag case message name element simulate step derivation labeled anonymous referees helpful comments 
acs amadio castellani sangiorgi 
bisimulations asynchronous calculus 
theoretical computer science 
bou boudol 
asynchrony calculus 
technical report inria sophia antipolis 
bg busi gorrieri 
petri net semantics calculus 
proc 
concur volume lncs pages springer verlag 
bgz busi gorrieri zavattaro 
truly concurrent view linda interprocess communication 
technical report ublcs department computer science university bologna 
bgz busi gorrieri zavattaro 
semantics output operation generative communication 
proc 
coordination volume lncs 
bgz busi gorrieri zavattaro :10.1.1.51.321
process algebraic view linda coordination primitives 
theoretical computer science 
bgz busi gorrieri zavattaro 
expressiveness linda coordination primitives 
information computation appear 
bp busi 
causal semantics contextual nets 
proc 
world scientific 
ciancarini gorrieri zavattaro 
calculus generative communication 
proc 
st ifip conf 
pages 
chapman hall 
gel gelernter 
generative communication linda 
acm transactions programming languages systems 
gc gelernter carriero 
coordination languages significance 
communications acm 
gro groote 
transition system specifications negative premises 
theoretical computer science 
hansen 
bisimulations asynchronous mobile processes 
tech 
report basic research computer science brics rs 
ht honda tokoro 
object calculus asynchronous communication 
proc 
ecoop volume lncs pages 
springer verlag 
js sun microsystem javaspaces specification 
available java sun com products javaspaces july 
mil milner 
communication concurrency 
prentice hall 
ms milner sangiorgi 
barbed bisimulation 
proc 
icalp volume lncs pages springer verlag 
min minsky 
computation finite infinite machines 
prentice hall englewood cliffs 
montanari rossi 
contextual nets 
acta informatica 
nar 
informal operational semantics linda 
technical report yaleu dcs tr department computer science yale university 
sca scientific computing associates 
linda user guide manual 
scientific computing associates 
ss shepherdson sturgis 
computability recursive functions 
journal acm 
wyckoff lehman ford 
spaces 
ibm systems journal 
available www almaden ibm com cs tspaces ibm almaden research center ibm 
