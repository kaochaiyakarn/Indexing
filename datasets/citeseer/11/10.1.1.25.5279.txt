source level debugging techniques tools optimized code clara ines computer science university new orleans computer science rice university submitted graduate faculty arts sciences partial ful llment requirements degree doctor philosophy university pittsburgh university pittsburgh faculty arts sciences committee chairperson dissertation clara ines defended august approved dr mary lou dr rajiv gupta dr panos chrysanthis dr thomas gross cmu ii copyright clara ines iii source level debugging techniques tools optimized code clara ines ph university pittsburgh compilers increasingly rely optimizations achieve high performance technology debug optimized code continues 
problem debugging opti mized code twofold errors optimized program originate source program introduced optimizer 
tools developed help ap plication programmers debug optimized code optimizer writers debug optimizers point view source program 
dissertation rst analyzes ects optimizations complexities maintaining correspondences source optimized code statements 
avariety code transformations considered including classical aggressive statement level transformations loop transformations inlining 
mapping technique developed determining correspondences source optimized code statements code transformations performed 
mappings capture impact optimizations statements instances useful wide range optimizations 
complementary debugging techniques optimized code developed experimentally evaluated 
techniques mappings ec techniques rely dynamic static information 
rst technique called comparison checking oriented help optimizer writers debug validate optimizers 
technique compares values computed unoptimized optimized executions source program detects semantic di erences versions 
technique modi ed check di erent levels optimizations tailored speci optimizations particular global register allocation 
second technique full reporting source level debugger optimized code helps application pro nd errors source programs optimized code executes 
technique reports expected values previously developed source level debuggers optimized code 
techniques demonstrated compiler performs iv set global statement level optimizations source programs 
techniques restrict set optimizations applied optimized code modi ed setting breakpoints 
experimental results performed demonstrate approaches ective practical 
am indebted advisors mary lou rajiv gupta sup port encouragement friendship guidance graduate studies 
dissertation possible 
am grateful panos thomas gross took time committee provided suggestions concerning research 
sisters parents angela ivan overwhelmingly faith ability achieve goals putting years 
husband ralf love understanding importance research god giving opportunities 
vi parents angela ivan 
vii table contents list figures 
xi list tables 
xiv 
overview research 
organization dissertation 
background related 
source level debugger 
prior source level debuggers 
transparent behavior limiting optimizations 
transparent behavior inserting code 
transparent behavior undoing optimizations 
exposing ects optimizations 
detecting managing ects optimizations 
static information 
dynamic information 
relative debugging 
bisection debugging 
prior tools debugging optimizers 
prior dissertation 
ects program transformations 
terminology 
statement level optimizations 
ects modifying statements 
ects deleting statements 
ects moving statements 
code hoisting transformations 
code sinking transformations 
summary moving statements 
loop transformations 
ects duplicating loop bodies 
ects modifying iteration space 
ects merging splitting loops 
ects altering index bounds loop 
summary loop transformations 
inlining 
viii summary 
capturing ects program transformations mappings 
mappings 
generating mappings 
ects statement level optimizations 
example 
ects loop transformations 
ects duplicating loop bodies 
ects modifying iteration space 
ects merging splitting loops 
ects altering index bounds loop 
series code transformations 
ects inlining 
summary 
comparison checking 
comparison checker overview 
comparison checking scheme example 
annotations 
supporting statement level optimizations 
check annotation 
save sopt annotation 
delay checkable annotations 
delete annotation 
check self annotation 
algorithms place annotations statement level optimizations algorithm introduce check delay checkable annotations 
algorithm introduce check self annotations 
algorithm introduce save annotations 
algorithm introduce delete annotations 
supporting loop transformations inlining 
implementation experiments 
summary 
register allocation checking 
register allocation checker overview 
annotations 
check annotation 
register assign annotation 
load annotation 
store annotation 
register move annotation 
combining annotations 
annotation placement 
register allocation checker example 
summary 
ix source level debugger 
challenges reporting expected values 
overwritten early optimized program 
written late optimized program 
computed unoptimized program optimized program 
fulldoc approach 
reportability debug information 
simply reportable 
overwritten early 
written late 
reportable deleted path 
path sensitive reportability deleted 
path sensitive reportability written late 
computing reportability debug information 
determining statements overwrite early write late 
computing 
computing lateatbkpts 
computing 
computing 
computing 
computing 
computing 
supporting loop transformations inlining 
implementation experiments 
summary 

summary contributions 

bibliography 
list figures source program unoptimized optimized program versions example example prior mappings 
constant propagation example 
dead code elimination example 
code hoisting transformation examples 
code hoisting transformation examples cont 
code hoisting transformation examples cont 
local instruction scheduling example sinking 
code sinking transformation examples 
loop unrolling example 
loop interchange example 
strip mining example 
loop distribution example 
loop normalization example 
inlining example 
loop invariant code motion mapping example 
partial dead code elimination mapping example 
loop interchange mapping example 
partial redundancy elimination mapping example 
mappings unoptimized optimized code example 
xi loop unrolling 
loop interchange ects initial 

mappings 
strip mining ects initial 

mappings 
loop normalization ects initial 

mappings 
comparison checking system 
program example comparison checking 
comparison checker algorithm 
comparison checking scheme example 
annotated unoptimized optimized code example 
types annotations 
types annotations 
algorithm introduce check delay checkable annotations 
algorithm introduce check self annotations 
algorithm introduce save annotations 
algorithm introduce delete annotations 
annotated loop reversal example 
annotated loop unrolling example 
program example register allocation checking 
register allocation checker algorithm 
annotations example 
register allocation checker example 
overwritten early example 
written late example 
computed optimized program example 
fulldoc strategy respect user inserting breakpoints 
fulldoc strategy respect breakpoints hit 
xii fulldoc strategy respect user queries 
debug information 
overwritten early example 
reportability debug information overwritten early example 
overwritten late example 
lateatbkpts reportability debug information overwritten late example 
dead code elimination example 
reportability debug information example 
reportability debug information example 
reportability debug information example 
reportability debug information example 
algorithm compute reportability debug information 
overwritten late example 
loop reversal example 
expected values reportable 
xiii list tables dead code elimination ects mappings labels statement level optimization ects ect mappings labels 
statement level optimizations move statements outer loops ect mappings labels 
partial redundancy elimination ects mappings labels 
statement level optimizations ects mappings 
loop invariant code motion ects mappings 
partial dead code elimination ects mappings statements moved loop boundaries 
partial redundancy elimination ects mappings 
loop transformation ects 

mappings 
loop transformation ects 

mappings cont 
execution times minutes seconds 
percentage local variables breakpoint reportable 
static statistics 
runtime statistics 
xiv chapter optimizations introduced compilers years ago di culty debugging optimized code recognized 
di culty grown development increasingly complex code optimizations path tive optimizations code speculation aggressive register allocation 
importance debugging optimized code increased years production com apply optimizations achieve high performance 
today software applications complex consist millions lines code 
optimizations required time memory constraints imposed systems 
current trends processor design increasingly rely compiler optimizations achieve high performance 
code transformations restructure programs reduce number instructions executed exploit locality ective caches registers uncover parallelism various levels granularity overlapping computations 
example classical optimizations applied types architectures reduce number instructions executed 
code reordering register allocation loop transformations applied superscalar vliw architectures uncover instruction level parallelism exploit locality 
loop transformations applied parallel architectures uncover loop level parallelism exploit data locality 
debugging optimized code di cult lack ective debugging tools support optimized code 
output execution optimized code incorrect tools exist help programmer determine origin error 
program mers typically assume unoptimized version program executes correctly optimized version optimizer responsible change seman tic behavior 
input semantic behaviors unoptimized program optimized program version corresponding statements executed programs compute values 
di erences semantic behaviors un optimized optimized program versions caused application unsafe optimization error optimizer error source program exposed optimization 
instance reordered operations certain conditions cause ow ow produce di erent oating point values 
optimized program may crash instruction reordering 
example statement may moved loop optimized code runtime program crashes statement divides zero 
application optimization may assume source code transformed follows programming standard ansi standard code error introduced optimization 
optimizer may contain error implementation particular optimization 
lastly execution optimized program may uncover error detected unoptimized program 
example code transformations change data layout program 
change may cause uninitialized variable assigned di erent values unoptimized optimized programs causing program versions behave dif 
number reasons program may execute correctly compiled optimizer turned fail optimizer turned application programmers intend ship optimized code fully optimized version fully debugged 
optimization incorrectly implemented caused error optimizer responsible error 
situation programmer optimizer writer optimizer debugged 
task debugging optimizer di cult tedious 
optimizer writer rst locate incorrect code op program 
lack source level debugging tools optimized code optimizer writers typically resort examining debugging assembly code locate incorrect code optimized program 
optimizer writer determine code transformation produced incorrect code subsequently locate er ror code transformation 
unfortunately little done help isolate analyze errors optimizer isolating errors optimizer remains open problem 
error originates source program application programmer responsible error 
case programmer debug optimized code determine cause error 
application programmers typically knowledge optimizations applied source program understand application optimizations ect source program examining debugging assembly code locate incorrect code optimized program option 
application programmers rely source level debugging tools debug optimized code 
unfortunately conventional source level debuggers help debug understand execution behavior optimized code 
conventional source level de allows user suspend execution program examine suspended program state respect source program 
unoptimized version source program debugged executed debugger simply reports actual contents locations requested variables breakpoints values user expects observe 
debugging executing optimized version actual content variable location breakpoint di er value user expects observe unoptimized version debugged executed optimiza tions move modify insert delete code optimized program 
situations debugger mislead user actual value reported break point 
conventional source level debugger allows user modify values variables execution program ects optimizations variable modi cation allowed debugger executes optimized code 
inadequate support debugging optimized code reason software companies may deliver optimized code 
optimized version shipped customers bugs arising customer di cult correct reasonable amount time 
program crashes resulting core le useless way correlate optimized program source program 
approaches debugging optimized code proposed aimed avoiding problems debugging optimized code helping program mers understand execution behavior optimized code 
approach oriented application programmers programmer turn optimizations devel opment software application turn optimizations production version gain performance bene ts provided optimizations 
words debug un optimized version program ship optimized version 
approach avoids problems associated debugging optimized code 
unfortunately application apparently free errors optimized behavior may behav ior unoptimized program 
mentioned earlier situation application programmer assume errors optimizer responsible change behavior 
optimizer turned unoptimized version shipped performance bene ts optimizations lost 
fact programmer experiences situation times con dence lost optimizer programmer typically optimizer programs 
optimizer may cor rect unoptimized version program may contain error exposed optimizer 
clearly case shipping incorrect unoptimized program version application program debugged 
approach equally unsatisfactory execute optimized code require programmer su ciently knowledgeable optimizations 
pro grammer determine debugging query issued get expected response source level debugger 
optimizer writer may able utilize approach application programmer seldom familiar optimizations ac burdensome task 
debugging optimized code point view source code approach allows programmer debug optimized code point modi ed version source program displays ects optimizations 
programmer familiar di program greatly di er source program 
approach bene ts optimizer writers information understand source program transformed 
approach burdensome application programmers 
researched approach debugging optimized code specialized source level debugger attempts report expected values determined optimized code report expected value determined 
progress development debuggers report ex pected values 
early techniques focused determining expected values infor mation computed statically 
techniques proposed information collected execution static information improve reportability values :10.1.1.38.9648
despite progress techniques able report possible expected values variables breakpoints source program optimizer writer application programmers easily debug optimized code point source code 
design source level debugger optimized code debugging capabilities unoptimized code remains open problem 
optimizers continue perform sophisticated optimizations exploit demanding architectural features demand tools help optimizer writers debug validate optimizers increasing 
need tools help programmers determine origin error optimized code increasing 
application programmers continue rely optimizations achieve high performance importance debugging optimized code point view source program increases 
programmer able debug optimized code point view source program 
programmer able suspend execution optimized program source statements query expected values source variables suspended execution points 
optimized program programmer identical version released 
words debugging purposes optimizer restricted apply certain set code transformations applicability code transformation restricted 
optimized program generally desired nal version program optimized code modi ed setting breakpoints debugging 
overview research optimized code dissertation explores open problems area debugging debugging validating optimizers source level debuggers optimized code determining origin error optimized code 
dissertation develops di erent source level debugging techniques tools optimized code optimizer writers debug optimizers application program mers debug optimized code point view source program 
particular dynamic information static information explored develop ective source level debugging techniques optimized code 
dynamic information bene ted optimizers dynamic information provides opportunities apply optimiza tions 
similarly dynamic information increase ectiveness source level debugging techniques optimized code 
dynamic information expensive terms overhead static information minimize amount dynamic information utilized 
dissertation considers source programs written programming lan guage 
techniques demonstrated compiler performs set global statement level optimizations source programs 
techniques restrict set optimizations applied optimized code modi ed setting breakpoints 
presenting techniques tools debug optimized code tation analyzes ects optimizations complexities maintaining corre source optimized code statements 
avariety code transfor mations considered including statement level optimizations loop transformations inlining 
statement level optimizations include speculative code motion path sensitive optimizations 
mapping technique developed capturing correspondences tween source optimized code statements code transformations applied 
particular mappings capture impact optimizations statements instances useful wide range optimizations 
complementary debugging techniques optimized code developed im plemented experimentally evaluated 
rst technique called comparison checking aimed helping optimizer writers debug validate optimizers 
comparison check ing technique compares values computed unoptimized optimized executions source program detects semantic di erences versions 
tech nique modi ed check di erent levels optimizations high intermediate low level check optimization phase tailored speci optimizations particular global register allocation 
optimizer debugged validated errors optimized code responsibility application programmer 
second technique full reporting source level debugger optimized code developed help application programmers nd errors source programs optimized 
debugger reports expected values previously developed source level debuggers optimized code 
report expected values reportable previously developed debuggers statically computed information utilized guide debugger gathering dynamic information 
static dynamic information debugger report expected values breakpoints reportability ected values overwritten early due code hoisting register reuse written late due code sinking 
debugger report values path sensitive may computed path location value may di erent di erent paths 
dissertation consider user modi cation variables debugging session consider debugging core les 
organization dissertation remainder dissertation organized follows 
chapter presents background information source level debuggers explains problems imposed debuggers optimized code stem application compiler transformations 
chapter describes prior performed debugging optimized code including tools debugging optimizers source level debuggers optimized code 
relationship dissertation prior discussed 
chapter discusses ects optimizations complexities maintaining correspondences source optimized code statements 
chapter presents technique generating correspondences source optimized code statements captures ects optimizations 
chapter comparison checking technique debugging optimizers 
chapter discusses tailor comparison checker debug validate speci optimizations particular global register allocation 
chapter presents full reporting source level debugger optimized code 
directions research discussed chapter 
chapter background related previous debugging optimized code focused devel opment source level debuggers optimized code chapter rst provides background information source level debuggers describes problems inherent source level debuggers optimized code 
prior proposed debugging optimized code including tools debugging optimizers source level debuggers op code described 
relationship dissertation prior discussed 
source level debugger source level debugger tool helps users understand execution behavior target program terms source program 
debugger allows user control execution target program examine suspended program state respect source program 
breakpoints suspend execution program 
common form breakpoint control breakpoint speci es breakpoint condition terms source code speci ed line function source statements 
types breakpoints suspend execution program 
conditional breakpoint initiated location dependent predicate evaluates true 
conditional breakpoint useful user wants place breakpoint heavily executed region code 
example conditional breakpoint placed loop index condition initiate breakpoint variable value variable data breakpoint initiated variable referenced read written 
data breakpoint useful user wants suspend execution statement particular variable having insert explicit control breakpoint statement 
previous debugging optimized code addressed source level debuggers considered control breakpoints term debugger refers source level debugger term breakpoint refers control breakpoint remainder dissertation 
typically user starts debugging session inserting breakpoints source program instructing debugger execute target program 
execution target program reaches breakpoint debugger suspends execution program returns control user 
point user continue execution program examine control state data state suspended program 
user commands terms source program debugger convert source level query target level query 
debugger responses user terms source program 
debugger able insert breakpoint target program response breakpoint source code determine current execution point target program corresponds source location user requested breakpoint display contents storage location execution target program corresponds source variables user requested current breakpoint display current execution point target program terms source program 
achieve tasks debugger utilizes information relating source program target program 
compiler provides debug information includes information variables statements source program relates storage locations instructions target program 
conventional debuggers typically designed execute unoptimized version source program 
debuggers unoptimized code straightforward implement source program unoptimized version direct correspondence 
source level statement boundaries preserved variables unique memory storage locations 
execution program reaches breakpoint statements prior breakpoint executed statements breakpoint executed 
user queries values source variables debugger simply reports actual contents memory locations requested variables breakpoints values user expects observe 
consider source program fragment unoptimized version 
suppose user places source program unoptimized program fragment fragment 


optimized program fragment source program unoptimized optimized program versions example breakpoint statements source code breakpoint examines current values notice source level statement boundaries preserved unoptimized program 
statement source program maps statements unoptimized program statement maps statements statement maps statement debugger executes unoptimized program version breakpoint easily placed statements unoptimized program 
reaching breakpoint unoptimized program execution debugger displays expected values memory locations contain expected correct values 
optimized program version source program debugged executed conventional debugger simply report actual content requested variable location breakpoint expected value may di er actual value variable 
unexpected value reported debugger mislead user 
di culty faced debuggers reporting expected values variables caused ects optimizations move modify insert delete statements optimized program 
ects optimizations problems surface trying debug optimized code viewpoint source program 
code location problem relates determining position breakpoint optimized code corresponds breakpoint source code 
data value problem problem reporting values source variables user expects see breakpoint source code optimizer may reordered deleted statements computing values overwritten values register allocation 
consider source program fragment optimized version 
debugger problems reporting expected values regardless breakpoint placed optimized code 
breakpoint placed statements reaching breakpoint optimized program execution contains unexpected value 
user expects see value computed statement source program corresponding assignment statement optimized program occurs breakpoint old value reported user 
breakpoint placed statements reaching breakpoint contains unexpected value 
user expects see value assignment statement source program corresponding assignment statement optimized program moved code occurs breakpoint value shown user 
problems occur boundaries source level statements preserved optimized program 
statement source program maps statements optimized program statement maps statements statements overlap code location data value problems exist aforementioned conditions hold optimized program 
problems constrain debugging capabilities conventional debuggers 
ective debuggers report expected values source variables accurately 
prior source level debuggers problem debugging optimized code long recognized 
mentioned earlier previous focused development source level debuggers optimized code :10.1.1.38.9648
debuggers provide transparent behavior 
debugger provides transparent behavior respect optimization responses user queries responses unoptimized program version debugged 
transparent behavior di cult achieve approaches provide transparent behavior constrain optimizations modify optimized code 
providing transparent behavior debuggers expose ects optimizations user terms source program di erent version source program 
attempt provide transparent behavior possible debuggers detect manage ects optimizations 
approaches detect manage ects optimizations static information dynamic information 
transparent behavior limiting optimizations fritzson debugging system provides transparent behavior expense limiting optimizations source statement 
code location data value problems exist breakpoints placed source statement boundaries 
full debugging capabilities provided optimizations limited 
transparent behavior inserting code gupta considers debugging code reorganized trace scheduling compiler 
approach compromises debugging features optimizations 
user rst specify monitor commands view variables conditions speci ed points program 
ected traces recompiled monitor renaming code inserted optimized program 
program executed 
code location data value problems exist monitor renaming code inserted optimized program 
consider debugging parallelized fortran programs sequential source level program point view 
parallel transformations consid ered renaming scalar expansion loop interchange source level spreading global forward substitution loop loop fusion strip mining 
optimizations applied source level code 
program converted single assignment form allow tracking values program execution 
values reported values com delayed past breakpoint deleted values 
data value problems partially handled 
code location problems handled syntactic breakpoints 
syntactic breakpoint statement source program placed original location statement optimized program 
transparent behavior undoing optimizations pollock debugger inhibits compiler optimizations ect de requests 
consider programs optimized constant folding redundant store elimination global common subexpression elimination copy propagation loop invariant code motion 
annotated dags represent unoptimized optimized programs 
allow users insert control conditional breakpoints examine modify values variables single step edit code 
full debugging features possible spec ed point point 
debugging features rst speci ed program execution 
program incrementally compiled inhibit necessary compiler optimizations 
resulting program re executed 
cases debugger perform recovery variables 
code location data value problems exist fully optimized program debugged 
holzle chambers ungar approach involves debugging executing optimized code dynamically code provide full debugging ca 
full debugging features needed optimized code executed 
switching program codes occur interrupt points method loop bodies source level state reconstructed 
method applies programs written object oriented language self optimized global constant propagation constant folding global register allocation inlining cus splitting dead code elimination strength reduction global common subex pression elimination arithmetic expressions loads stores redundant computations cause observable side ects arithmetic ow loop unrolling delay slot lling 
list extensive applicability optimizations restricted source level state reconstructed interrupt points 
code location data value problems exist fully optimized program debugged 
exposing ects optimizations brooks hansen simmons take di erent approach debugging 
consider programs compiled convex fortran compilers levels optimizations 
source program assembly level program highlighted animated visually conveying ects optimizations program behavior 
optimization ects hidden 
program stepping provided levels expression statement block loop routine 
code location problems partially handled 
data value problems partially handled compiler generated tables live ranges determine values variables available 
recover variables deleted due strength reduction induction variable elimination 
optview generates optimized source program version programs conveys user ects copy propagation constant folding common subexpression elimination partial redundancy elimination dead code elimination code hoisting sink ing instruction scheduling 
related research ort debugger displays optimized version source program generated optview 
user commands debugger responses user respect optimized source program version 
uses invisible breakpoints recover variables evicted registers determine correct location variable location depends execution path user point view opti mized source program data value code location problems exist 
user aware optimizations 
detecting managing ects optimizations debugging techniques focus detecting ects optimizations pro expected behavior possible 
debugging techniques focus determining expected values information computed statically 
techniques proposed information collected execution static information improve reportability handle code location problems :10.1.1.38.9648
static information hennessy considers debugging programs written subset pascal optimizations applied intermediate code level 
annotated dags repre sent unoptimized optimized programs 
statically analyzing annotated dags hennessy classi es variables breakpoints current noncurrent determin ing variables endangered 
variable endangered breakpoint path variable may correct value due program transformation 
variable current endangered path variable noncurrent endangered paths variables classi ed current breakpoints reportable debugger variables contain expected values breakpoints 
setting breakpoints examining values source variables debugging features considered 
data value problems partially handled conservatively detecting recovering noncurrent variables 
algorithms developed detect recover noncurrent variables programs local optimizations common subexpression elimination redundant store elimination code reordering 
re covering values noncurrent variables possible 
techniques described detect recover noncurrent endangered variables programs global optimiza tions code motion loops induction variable elimination global dead store elimination 
techniques data ow analysis detect endangered variables 
hennessy technique local optimizations modify optimized code technique global optimizations inserts ag instructions determine dynamic avariable evicted register assigned register value assignment tov stored register 
program ow 
code location problems handled restricting placements breakpoints code generation 
coutant develops symbolic debugger programs optimized global register allocation induction variable elimination constant copy propagation instruction scheduling 
debugging features include inserting breakpoints examining values variables 
code location problems handled syntactic breakpoints 
data value problems partially handled compiler generated tables recovering eliminated variables due strength reduction induction variable elimination 
live range table determine variable value available 
values available partial information provided user try recomputing data 
table determine variable modi ed early late 
adl tabatabai gross consider ects global register allocation assignment residency problem determines variable assigned register breakpoint 
data ow analysis determine variable evicted register uninitialized 
detect recover endangered variables caused local instruction scheduling 
endangered variables classi ed 
avariable suspect breakpoint debugger able determine variable actual value expected value determine variable endangered breakpoint intermediate representation annotated ects caused local instruction scheduling 
solutions implemented compiler global optimizations including register allocation assignment branch optimizations constant folding unreachable code elimination local optimizations including common subexpression elimination value propagation instruction scheduling 
code location problems exist data value problems partially handled 
able detect endangered variables recover values interpreting instructions 
full recovery values achieved attempt recovery rolled back variables rolled back variables di cult recover 
interpret function calls transfer control current basic block interpretation di cult 
interpret loads values memory may endangered 
takes approach general previous dealing data value problem 
uses data ow analysis single graph rep resents unoptimized optimized programs determine variables current noncurrent endangered breakpoints 
data value problems partially handled 
source programs optimized local global common subexpression elimination constant copy propagation constant folding dead code elimination dead store elimination cross jumping local global instruction scheduling strength reduc tion code hoisting partial redundancy elimination induction variable elimination loop unrolling inlining optimizations change order basic blocks entered 
example loop interchange handled 
list extensive applicable intermediate code level 
code location problems handled syntactic breakpoints 
approach similar approach general gives correct answer circumstances 
static analysis loops unrolled unoptimized optimized control ow graphs distinguish di erent instances de nitions 
data ow analysis performed unrolled unoptimized optimized program control ow graphs determine variables current noncurrent breakpoints 
data value problems partially handled 
algorithms implemented compiler applies global common subexpression global copy constant propagation global dead store elimination loop invariant code motion composite breaking register allocation 
optimized program modi ed 
modi ed control ow graphs static analysis 
code location problems considered applicable syntactic semantic breakpoints 
semantic breakpoint statement source program placed point action speci ed statement occurs optimized program 
approach similar approach adl tabatabai gross 
variables classi ed current noncurrent suspect breakpoints data ow analysis intermediate representation annotated ects caused optimizations 
uninitialized variables considered 
assume code moved arbitrarily program 
assume compu tation introduced path exist 
approach implemented compiler applied loop unrolling peeling induction variable expansion constant propagation folding assignment propagation dead assign ment elimination strength reduction global register allocation local instruction scheduling linear function test replacement induction variable simpli cation induction variable elim partial dead code elimination partial redundancy elimination branch optimiza tions register coalescing 
software pipelining loop transformations loop interchange considered 
code location problems considered 
data value problems partially handled 
recovery techniques described 
adl tabatabai extends previous techniques handling code location problems recovery val ues 
describes handle speculative code motion respect data value problems 
dynamic information zellweger debugging system navigator handles cedar algol lan guage programs optimized inline procedure expansion cross jumping 
de features considers inserting breakpoints viewing procedure examining values variables 
data value problems exist variables ways current 
code location problems partially handled 
breakpoints transparent behavior partially provided compiler generated tables invisible breakpoints collect execution history 
cases zellweger system modify optimized program collect information execution path 
focused utilizing dynamic information static infor mation improve reportability values 
wu selectively take control optimized program execution emulate instructions optimized code order mimics execution unoptimized program :10.1.1.38.9648
execution reordering enables reporting expected values variables reportable debuggers 
code location problems avoided altering execu tion optimized program 
altering execution optimized program masks certain user optimizer errors 
data value problems partially handled 
emulation technique track paths report values reportability path sensitive 
approach implemented impact compiler applied instruction scheduling register allocation classical local global optimiza tions induction variable optimizations strength reduction common subexpression elimination constant folding copy propagation loop invariant code motion store copy optimizations 
dhamdhere developed dynamic currency determination technique report values variables reportable debuggers 
create minimal unrolled graph program timestamp basic blocks obtain partial history execution path precisely determine variables reportable breakpoints 
values overwritten early code hoisting register reuses reportable 
data value problems partially handled 
code location problems considered 
relative debugging guard relative debugger similar debugging approaches ad research programs executed values generated compared 
guard users compare execution program program execution program development version 
guard requires user formulate assertions key data structures versions specify locations data structures identical 
relative debugger responsible managing execution programs reporting di erences values 
guard implemented debugging platform provides interface process control state access breakpoint handling 
guard designed debug optimized programs easily extended 
optimizations low level user formulate assertions assembly level statements 
guard extended implement parallel relative debugger user formulate assertions 
primary di erence guard research scheme compares executions unoptimized optimized programs transparent user 
bisection debugging concept bisection debugging model goal identi cation semantic di erences versions program assumed correct 
bisection debugger attempts identify earliest point versions diverge 
handle debugging optimized code data values problems solved breakpoints 
prior tools debugging optimizers focused developing tools help debug optimizers 
bug nd developed help debug optimizers pinpointing functions produce incor rect code 
tool helps application writers compiling function highest level correct optimization 
achieve tasks functions placed separate les 
boyd whalley developed tools help debug optimizers 
rst tool identi es rst transformation optimization causes output execution incorrect 
addition tool identify location instance transformation applied 
aid identifying error implementa tion optimization graphical optimization viewer developed allows users view state generated instructions application transformations 
optimizer writer conclude speci instruc tions optimized code produce incorrect results tedious user potentially view states instructions ected transformation 
statically compares intermediate form program compilation pass veri es preservation semantics 
symbolically evaluates intermediate forms program checks symbolic evaluations equivalent 
translation validation system demonstrated context gnu gcc compiler performed optimization phase 
optimizations include branch optimization local global common subexpression elim loop unrolling loop inversion induction variable optimizations local global register allocation instruction scheduling procedure integration tail recursion elimi nation 
gcc version exhibit bugs register allocator loop unrolling 
cases translation validation system able detect bugs 
system detects false alarms necessarily errors 
system obviate need extensive compiler testing suites 
system careful instructions raise exceptions 
statement moved loop divides zero runtime remains undetected 
prior dissertation previous successfully handles code location data value problems faced source level debuggers optimized code 
prior ensure execution behaviors unoptimized optimized programs respect behavior source level program input 
prior help automatically pinpoint errors optimized code 
di erence proposed previous tracking unoptimized program optimized program version 
mappings track information source unoptimized program optimized program version 
mappings developed dissertation extensions mapping techniques previously developed source level debuggers optimized code capture correspondences statements unoptimized optimized programs statement instances 
prior statically analyzes mappings determine variables resident current noncurrent endangered 
results unoptimized code loop loop loop goto goto goto optimized code loop loop loop goto goto goto example prior mappings conservative dynamic information utilized correspondences statement instances programs captured 
utilizes dynamic information report expected values 
consider example loops interchanged unrolled optimized code result instances statements reordered deleted 
mappings statements source level debugger executes optimized code debugger ine 
breakpoint placed loop variables inside loop considered noncurrent values reported 
debugger knowledge values reported information loop iterations statement instances 
example user places breakpoint statement innermost loop unoptimized program requests value debugger report expected value regardless breakpoint placed optimized code 
debugger know value computed instances reordered split statements information instances correspond instances mappings di cult understand optimized program original unoptimized program 
dissertation develops mapping technique captures ects code transformations capturing correspondences statement instances 
mappings track instances statements mappings able capture ects transformations including loop transformations 
extra information needed develop powerful source level debugging tools optimized code utilize static dynamic information 
chapter ects program transformations source level debugging tools optimized code allow user debug optimized code point view source program 
develop tools correspondence source optimized code established 
establishing correspondence source program optimized code requires determining ects applied program transformations 
class program transformations considered include statement level optimizations loop transformations inlining 
statement level optimizations include speculative code motion path sensitive optimizations 
transformations move modify insert delete statements program code ect program statements number ways 
transformation ect position statement 
statement moved earlier position optimized program 
case statement execute optimized code unoptimized version source code 
transformation ect number times statement executes optimized code 
statement moved optimized code may execute times unoptimized code 
fact statement may execute unoptimized program optimized program vice versa 
transformation ect order multiple instances statement executed 
source program direct correspondence unoptimized version program remainder chapter determines ects transformations captured correspondence unoptimized optimized code established 
ects transformations determined analyzing position number order instances statement change particular context statement level optimizations loop transformations inlining 
terminology correspondence unoptimized optimized versions source program correspondences statements instances unoptimized optimized programs 
de nition execution statement called instance de nition statement unoptimized version source program statement optimized version derived program transformations 
exists instance instance denoted si compute value correspondence si corresponds statement moved branch loop boundary correspondence instances statement unoptimized optimized programs depends execution path taken 
de nition statement unoptimized version source program statement optimized version correspond 
di erent control dependences corresponding instances path sensitive 
statement level optimizations statement level optimizations constant propagation loop invariant tion dead code elimination partial redundancy elimination operate individual statements 
optimizations modify delete move statements program code may ect position number instances statement program code 
may ect correspondences statements unoptimized optimized code 
ects modifying statements optimizations simply modify statements ciency purposes ect correspondences statements unoptimized optimized programs 
example constant propagation optimization propagates constant assigned variable replacing uses variable constant 
unoptimized code variable assigned constant propagated statement constant propagation applied corresponding statement optimized code uses constant operands variable correspondence ected 
unoptimized code optimized code constant propagation example ects deleting statements optimization removes statement program code deleted state ment execute optimized code deleted statement corre optimized code 
example application dead code elimination removes statements program 
illustrated application dead code elimination removes statement correspondence optimized code execute optimized code 
unoptimized code optimized code dead code elimination example ects moving statements transformations move statements di erent positions program code code motion transformations include simple reordering statements straight line code segment moving statements branch boundaries moving statements loop boundaries 
change position statement causes statement execute earlier optimized code compared unoptimized program 
change position statement cause number instances crease decrease correspondence statement instances ected 
furthermore correspondence statement instances may path sen 
lastly statement unoptimized code correspond statements optimized code vice versa 
code hoisting transformations code motion transformations move statements earlier positions program code hoisting transformations 
statements moved earlier positions program execute earlier unoptimized program 
example local instruction scheduling moved statement optimized code 
result instance corresponds instance execute earlier unoptimized code optimized code local instruction scheduling example hoisting unoptimized code optimized code speculative code motion example code hoisting transformation examples code hoisting transformations move statements branch boundaries 
ects hoisting code branch boundaries depend nature trans formations 
example speculative code motion moves statements branches loop boundaries 
statement moved conditional optimized code 
correspond number times statement executes may number times executes 
cor instances path sensitive due di erence control dependencies depends path taken execution 
execute corresponding loop iterations statement instances correspond 
hand executed executed corresponding loop iterations instance correspondence unoptimized code 
examples illustrate ects code hoisting trans formations 
hoisted conditionals 
result corresponds statements optimized code correspondences instances instances path sensitive due di erence control cies 
similarly hoisted conditional 
correspond statement optimized code correspondences instances instances path sensitive 
unoptimized code optimized code code hoisting conditionals example unoptimized code optimized code code hoisting conditionals example code hoisting transformation examples cont 
code hoisting transformations move statements loop boundaries 
consider loop invariant code motion optimization moves loop invariant statements loops 
statement moved loop 
number times statement executes unoptimized code greater number times corresponding statement executes optimized code iteration instances statement correspond instance optimized code 
unoptimized code optimized code loop invariant code motion example unoptimized code optimized code partial redundancy elimination example code hoisting transformation examples cont 
partial redundancy elimination pre code hoisting transformation 
pre moves modi es computations away application transfor mation occurrences computations minimized paths 
statements inserted optimized code correspond existing statements unop code correspondences instances statements depend positions statements may path sensitive 
example fig ure computation statement partially redundant statement unoptimized code 
application pre creates new statement assigns partial redundant expression temporary uses temporary recomputing partial redundant expression statements pre applied correspondence correspondence ected 
corresponds correspondences instances instances path sensitive 
similarly corresponds code sinking transformations code motion transformations move statements positions pro gram code sinking transformations 
statements moved positions execute execution correspondences statements may ected 
exam ple local instruction scheduling moved statement code 
result instance corresponds instance executes unoptimized code optimized code local instruction scheduling example sinking partial dead code elimination pde sinks statement dead path may dead paths 
statements moved branch boundaries statement unoptimized program corresponds statements optimized program 
application pde moves statement inside conditional 
result number times statement executes may number times executes 
correspondence instances path sensitive 
execute statement instances correspond 
hand executed executed transformation resulted deletion instance execution 
unoptimized code optimized code partial dead code elimination example branches unoptimized code partial dead code elimination example loop code sinking transformation examples optimized code statement moved pde result statement executes fewer number times corresponding statement iteration loop instance statement corresponding instance optimized program instance earlier instances statement deleted pde summary moving statements summary application code motion transformations ects correspon dence unoptimized optimized versions program ways statements reordered statement unoptimized code execute corresponding statement executes optimized code 
new correspondences established statements unoptimized code 
statement unoptimized code correspond statements optimized code 
new correspondences established statements optimized code 
statement optimized code correspond statements unoptimized code 
number instances statement unoptimized code increase decrease optimized program 
correspondence statement instances change 
instances statement unoptimized code correspond instance optimized code 
instances statement unoptimized code correspondence optimized code 
corresponding statements di erent control dependences 
correspondence instances statement unoptimized optimized programs path sensitive 
instances statement unoptimized code may may correspondence optimized code vice versa 
establishment corresponding instances statements may established runtime 
loop transformations loop transformations operate loops unit ects state ment level optimizations ects 
application loop transformations duplicate loop bodies modify iteration space merge split loops alter index bounds loop result correspondences statements unoptimized optimized programs ected instances statement unoptimized program reordered distributed statements optimized program 
execution unoptimized optimized programs corresponding statements may execute earlier di erent order number instances may di er 
ects duplicating loop bodies loop transformations duplicate bodies loops ect correspondences statements unoptimized optimized programs loop peeling loop unrolling software pipelining 
statements loop body unoptimized program replicated optimized code instances statement loop body unoptimized program divided statements optimized program 
loop unoptimized program executes iterations corresponding loop optimized program 
example loop unrolling replaces loop body copies loop body 
number copies called unrolling factor loop increment adjusted increment unrolling factor 
consider example loop unrolled times loop header modi ed iterate half time 
notice statement loop body unoptimized code corresponds statements optimized code odd instances statement loop body unoptimized code correspond instances statement optimized code instances statement loop body unoptimized code correspond instances statement optimized code 
notice loop initializations correspond 
loop tests correspond odd instances loop test unoptimized code correspond instances loop test optimized code instances loop tests correspond 
loop increments correspond instances loop increment unoptimized code correspond instances optimized code 
unoptimized code optimized code statement loop unrolling example ects modifying iteration space statement statement loop transformations reorder instances statements loops loop reversal loop interchange strip mining 
result iteration space statements unoptimized program di er optimized program 
example loop interchange exchanges positions loops loop nest changes order loop iterations optimized code 
loops mized program interchanged optimized program 
statements loop bodies remain loops programs execute number times execution order instances di er programs 
loop headers loops ected 
corresponding loop headers inter changed loops appear di erent loop nest levels number instances corresponding loop headers di er programs 
statement instances header outer loop unoptimized code execute optimized code inner loop optimized code 
statement instances loop header inner loop unoptimized code execute optimized code outer loop optimized code 
loop transformation ects iteration space strip mining converts serial loop loops strips 
strips essentially series unoptimized code optimized code statement loop interchange example statement vector operations 
application strip mining ects correspondences statements unoptimized optimized programs instances statements unoptimized code grouped instance optimized code 
example loop strip mined strip size 
loop initializations programs correspond 
tenth instance loop test increment unoptimized code correspond instance loop test increment optimized code 
instances loop tests programs correspond 
instances assignment unoptimized code correspond instance vector assignment toc optimized code 
unoptimized code optimized code strip mining example ects merging splitting loops loop transformations split loops merge loops 
control ow changes number order instances statements loop bodies ected 
loop distribution divides loop loops loop headers 
statements loop optimized code enclose subset statements loop unoptimized code 
loop header unoptimized code corresponds loop headers optimized code 
example loop unoptimized code distributed optimized code 
notice instance loop headers unoptimized code corresponds instances optimized code 
unoptimized code optimized code loop distribution example ects altering index bounds loop loop transformations alter loop headers loop number order instances statements loop bodies remain 
example loop normalization changes loop header loop loop index initially incremented iteration 
loop unoptimized code normalized optimized code 
statements loop bodies execute number times order 
loop initializations loop increments correspondences loop test changed optimized code correspondence instances loop tests programs 
unoptimized code optimized code init limit step limit init step step statement statement loop normalization example summary loop transformations ects loop transformations ect correspondence mized optimized versions program way statement level trans formations 
correspondences statement instances change result reordering instances statement dividing instances statement unoptimized code statements optimized code 
inlining function inlining replaces calls function unoptimized code bodies function optimized code 
instances statements function unoptimized code correspond instances statements inlined optimized code instances call sites unoptimized code inlined optimized code correspondences optimized code 
example function inlined times 
statement function unoptimized code corresponds statements optimized code statements function unoptimized code execute number times corresponding statements optimized code 
unoptimized code procedure main call call procedure inlining example optimized code procedure main procedure summary chapter described ects transformations impact correspon dences statements unoptimized optimized programs 
ects transformations established analyzing position number order stances statement change particular context statement level optimiza tions loop transformations inlining 
application transformations ects correspondence unoptimized optimized versions program ways 
statements statement instances may correspondences 
statement unoptimized code relatively positioned corresponding statement optimized code 
statement un optimized code execute corresponding statement executes optimized code 
new correspondences established 
statement unoptimized code correspond statements optimized code statement optimized code correspond statements unoptimized code 
number instances statement unoptimized code increase decrease optimized program correspondences statement stances unoptimized optimized programs necessarily correspondence 
instances statement unoptimized code reordered opti mized code 
instances statement unoptimized code divided statements optimized code 
correspondence instances statement unoptimized opti mized programs path sensitive 
instances statement unoptimized code may correspondence optimized code vice versa establishment corresponding instances statements may established runtime 
establish correspondence unoptimized optimized versions program ects captured mappings discussed chapter 
chapter capturing ects program transformations mappings previous chapter described ects program transformations af fect correspondence unoptimized optimized versions program 
chapter ects captured mappings establish correspondences statements unoptimized optimized versions program 
map pings established transformations applied 
number transformations may applied order mappings re ect combined ects transforma tions 
mappings record individual transformations applied order applied 
mappings unoptimized optimized programs time optimization summarize ects previously applied transformations 
program transformations change correspondences state ments instances statements unoptimized optimized programs map pings associate corresponding statements corresponding instances statements unoptimized optimized programs 
mappings associate statement pro gram zero statements program 
similarly mappings associate instance statement program zero instances statement program 
program transformations divide stances statement unoptimized code statements optimized code mappings identify sequences instances statement 
program transformations reorder instances statement mappings identify ordered sequences instances statement 
program transformations change relative position statement mappings explicitly capture change posi tion 
mappings control ow graphs unoptimized optimized programs analyzed determine relative positions corresponding statements 
similarly mappings control ow graphs analyzed determine correspondences instances statements path sensitive 
mappings mappings represented labeled edges corresponding statements unoptimized optimized programs 
labels identify instances unoptimized program corresponding instances optimized program 
mapping components association statement unoptimized code correspond ing statement optimized code association instances statements 
mapping statement unoptimized program optimized program form ordered sequence instances ordered sequence ordered sequences mappings express correspondences stances statements 
number elements sequences may may di er 
example correspondence instances number 
corresponding instances may appear order di erent order reverse order 
number instances consecutive subsequence instances sequence corresponds single instance 
noted corresponding statement instances computed statically mappings potential dynamic instances 
instances sequences may execute instances execute mappings capture dynamic correspondences 
refer instances statement loop iterations instances execute speci ed number instances statement executed governed loops enclosing statement instances ordered order iterations loops 
statement program viewed respect looping structure enclosed 
loss generality program assumed enclosed loop iteration denoted 
statement identi ed nested loop nest ln collection loops enclosing numbered successively outermost innermost loop number loop nest levels 
iteration loop nest uniquely identi es instances statement instances statement ordered order iterations loop nest ordered sequence instances statement loop nest ln speci ed dimensional vector 
element vector subscripted element subscript represents ordered sequence iterations loop li 
order vector elements speci ed determines order instances sequence 
element form denotes instance executes iteration loop li 
denotes instances execute iterations loop li 
denotes instance executes iteration loop li 
denotes instance executes th iteration loop li constant 
flower upper step denotes instances execute sequence iterations lower lower step lower step upper step upper loop li 
represent statement unoptimized program statement optimized program denote instance statement respectively 
examples mapping labels generated transformations code reordering 
indicates iteration loop nest corresponds loop reversal indicates iteration loop nest corresponds loop invariant code motion 
indicates iteration loop nest corresponds instances map instances indicating iteration instances correspond instance vector describing instances dimensions programs assumed implicitly enclosed loop iteration 
partial dead code elimination 
indicates corresponds instances map instances indicating iteration instance corresponds instance decreasing sequence denoted similarly 
unoptimized code optimized code loop invariant code motion mapping example unoptimized code optimized code partial dead code elimination mapping example unoptimized code optimized code loop interchange mapping example loop interchange loop body 
indicates corresponds 
instances map instances indicating iteration corresponds instance loop interchange loop header 
indicates corresponds illustrated 
readability ease explanation notations refer vectors rest chapter 
elements dimensional vector form shorthand vector notation 
example denoted 

notation loop nesting level vector important explanation mappings generated 
cases consecutive sequence elements vector form 
case subscript range refer elements 
example denoted cases sequence instances element vector refers important explanation mappings generated ii refer sequence instances element optimized program initially starts identical copy unoptimized program initial mappings corresponding statements programs 
initially mappings 

labels corresponding statements enclosed loops 
mappings change code transformations applied 
mappings individual transformations determined semantics transformations respect unoptimized program 
mappings individual transformations mappings series transformations determined 
subsequent code transformation applied mappings changed re ect composition previous mappings ects previously applied transformations ects current transformation 
generating mappings code transformations applied order times desired applicable 
code transformation applied label mapping may change new mapping may established 
label mapping depends ap plied code transformation positions corresponding statements mapping ected statement 
section describes ects mappings single initial transformation applied 
subsequent section describes ects mappings series transformations applied 
ects statement level optimizations tables show ects mappings result applying initial statement level optimization statement unoptimized program 
initial mapping corresponding statement optimized program form table dead code elimination ects mappings labels transformation resulting mapping dead code elimination delete table statement level optimization ects ect mappings labels transformation resulting mapping label code reordering basic block 
speculative hoisting acyclic 
scheduler constant propagation folding 
copy propagation 
partial dead code elimination loop 
partial redundancy elimination loop 
table displays ects mappings result applying dead code tion 
transformation causes removal mappings corresponding statements optimized program deleted 
application statement level optimizations displayed table ect mappings 
ects applications code reordering basic block speculative hoisting acyclic scheduler constant propagation folding copy propagation partial dead code elimination corresponding statements loops partial redundancy elimination corresponding statements loops change mappings labels statements table statement level optimizations move statements outer loops ect mappings labels transformation resulting mapping label loop invariant code motion inner loop 
partial dead code elimination inner loop 
partial redundancy elimination inner loop alli 
moved loop boundaries new mappings established corresponding statements positioned loop boundaries 
table partial redundancy elimination ects mappings labels partial redundancy elimination resulting mapping label outer loop 
di erent loop nest alli 
table displays labels mappings generated result applying state ment level optimizations move statements outer loops create correspondences statements outer loops 
application loop invariant code motion moves state ment loop loop nest level outer loop nesting level 
loop invariant code motion applied statement iteration outer loop instances correspond instance label mapping changed 
application partial dead code elimination moves statements branch boundaries outer loop nesting level partial dead code elimination moves statement outer loop nest ing level iteration outer loop instance corresponds instance case label mapping changed application partial redundancy elimination modi es statement temporary recomputing expression 
state ment correspondence statement assigns redundant expression temporary 
outer loop loop nest level respect illustrated iteration loop instances correspond instance label mapping changed alli table displays remaining possible labels mappings generated result applying partial redundancy elimination 
inner loop loop nest level respect illustrated iteration innermost loop enclosing instance corresponds instance case label mapping changed ifs di erent loop nests illustrated iteration innermost loop enclosing instances correspond instance label mapping changed alli loop nest level innermost loop enclosing loop nest level innermost loop enclosing loop nest level innermost loop enclosing 
unoptimized code optimized code loop nest level 
loop nest level loop nest level loop nest level 
loop nest level 
loop nest level unoptimized code loop nest level loop nest level 
loop nest level unoptimized code loop nest level loop nest level 
loop nest level loop nest level loop nest level inner loop outer loop different loops optimized code loop nest level 
loop nest level 
loop nest level 
optimized code loop nest level loop nest level 
loop nest level loop nest level partial redundancy elimination mapping example loop nest level example mappings unoptimized program optimized version shown 
example running example subsequent chapters 
mappings illustrated labeled dotted edges corresponding statements programs 
unoptimized code optimized code mappings unoptimized optimized code example optimizations applied code 
constant propagation constant ins propagated shown copy propagation copy mins propagated shown dead code elimination dead constant copy propagation mappings removed 
loop invariant code motion doubly nested loop instances statement loops unoptimized code map instance statement optimized code 
partial redundancy elimination partially redundant map ping created notice mappings 
partial dead code elimination moved outer loop instance statement loops unoptimized code mapped instance statement optimized code 
ects loop transformations loop transformations operate loops unit application ects mappings statements loops including statements loop headers loop bodies 
section describes kinds mapping generated result applying initial loop transformation initial mappings form 

ects duplicating loop bodies body loop duplicated number instances statement loop body unoptimized code divided statements optimized code 
statement unoptimized code corresponds statements optimized code mappings updated re ect new correspondences instances statements 
example application loop unrolling unrolled loop nesting level times optimized code 
instances statement loop body nesting level unoptimized code divided follows 
odd instances denoted correspond instances optimized code label mapping changed 

gi 


instances denoted correspond instances mapping created label gi 


loop nest level 
loop nest level 
loop nest level loop nest level unoptimized code optimized code statement statement statement unoptimized code statement loop unrolling optimized code loop nest level level statement nest loop loop interchange ects initial 

mappings unoptimized code optimized code strip strip tj min strip strip strip strip strip mining ects initial 

mappings 
loop nest level loop nest level 
ects modifying iteration space iteration space loop reordered instances statement loop body unoptimized code reordered optimized code mappings updated re ect new correspondences instances statements 
example application loop interchange interchanged loop nesting level loop nesting level instances reordered optimized code 
reordering ect captured permuting elements vector speci ed label mapping re ect ordering optimized code 
label mapping changed 



loop nesting level stripped application strip mining 
instances statement loop body nesting level unoptimized code divided follows 
instances divided strips size strip strip instances corresponds instance label mapping changed 

fj min strip indices sequences re ect dependence inner loop limits outer loop index 
ects merging splitting loops merging splitting loops reorder split instances statements loops 
subsequently mappings statements ected 
instances statements loops reordered respect instances statements loops 
ects altering index bounds loop altering index bounds loop reorder split instances statements loop body 
subsequently mappings statements ected 
example application loop normalization illustrated ect mappings statements loop bodies label mapping remains 


loop nest level unoptimized code 
init limit step limit init step step statement statement optimized code loop normalization ects initial 

mappings series code transformations code transformations applied order times desired applicable 
transformations applied statements mapping label changed re ect composition previous mapping ects previously applied transformations ects current transformation 
table shows ects statement level optimizations mappings statements label application dead code elimination eliminates mappings application code reordering basic block speculative hoisting acyclic scheduler constant propagation folding copy propagation ect label mappings label remains table statement level optimizations ects mappings transformation resulting mapping label dead code elimination mapping delete code reordering basic block speculative hoisting acyclic scheduler constant propagation folding copy propagation tables show ects loop invariant code motion partial dead code elimination statements moved loop boundaries map ping labels 
statement moved optimized program mapping corresponding statement unoptimized program updated re ect composition previous mapping ects current transformation 
row assumes statements loop transformation applied 
row assumes statement inner loop respect row assumes statement outer loop respect dif ferent loop nests 
statements moved loops application loop loop nest level invariant code motion element im vector removed 
loop element encloses applied current element im vector similarly statements moved loop boundaries loop nesting level application partial dead code elimination elements ij vector removed 
loop enclosing element encloses applied current elements ij vector statements moved loop partial dead code elimination labels mappings ected 
table loop invariant code motion ects mappings initial mapping label resulting mapping label loop inner loop outer di erent loop nest im im im table partial dead code elimination ects mappings statements moved loop boundaries initial mapping label resulting mapping label loop inner loop outer di erent loop nest ij im ij outer di erent loop nest ij inner loop similarly partial redundancy elimination statement modi ed temporary recomputing expression statement corresponds assigns redundant expression temporary 
mapping created mapping utilized create mapping table displays labels mapping previous mapping tables shown figures display labels mappings generated result applying loop transformation mapping labels table partial redundancy elimination ects mappings resulting mapping label loop 
inner loop ii 
outer loop 
di erent loop nest 
form 

mappings statements loop bodies loop headers may ected 
table loop transformation ects 

mappings loop peeling time loop loop body ii 

ii 

loop initialization delete loop test ii ii ii loop increment loop unrolling unroll factor loop body ii 

ii 

loop initialization loop test ii ii ii loop increment loop body software pipelining number stages stage ii 

ii 

stage ii 

ii 

loop initialization delete loop test ii ii loop increment ii loop nesting level loop body conditional statements 

loop initialization loop increment loop test table loop transformation ects 

mappings cont 
loop reversal nesting level loop body fn ii 

loop initialization delete loop test fn ii ii ii loop increment fn loop interchange nesting levels loop body ii ii ii 

loop initialization loop test ii ii ii ii loop increment ii ii loop body loop distribution loop jamming 
loop initialization 
loop increment 
loop test 
strip mining loop nesting level loop body fj min strip loop initialization loop increment loop test loop body loop normalization 
loop initialization delete loop increment loop test delete 
ects inlining mappings extended support function inlining replaces calls function unoptimized code bodies function optimized code 
inlined body may optimized di erently inlined call site set mappings 
inlined call site separate mappings maintained statements function unoptimized code inlined copy optimized code 
function examined executed runtime appropriate set mappings selected utilized knowledge call site encountered program execution 
summary chapter described technique automatically identify statement instance correspondences unoptimized optimized code generate mappings re ecting correspondences code improving transformations applied 
mappings re ect ects transformations established analyzing position number order instances statement change particular context transforma tions applied 
restrictions placed order number transformations 
mappings support statement level optimizations inlining loop transformations 
correspondence unoptimized optimized versions program established mappings source level debugging techniques optimized code developed 
remainder dissertation focuses developing techniques help optimizer writers debug optimizers application programmers debug optimized code point view source program 
mappings utilized compile time runtime 
statically mappings control ow graphs unoptimized optimized programs analyzed determine corresponding statements relatively positioned respect determine corresponding statements path sensitive 
mappings generate annotations unoptimized optimized programs guide actions source level debugging tools optimized code 
runtime mappings utilized determine statements execute optimized program relate unoptimized program version 
chapter comparison checking novel technique called comparison checking chapter utilizes mappings previous chapter 
technique helps users validate debug optimizers verifying inputs semantics program changed application optimizations 
comparison checking technique deter mines semantics optimized version di er unoptimized program comparing internal execution behavior values computed un optimized program corresponding values computed optimized program inputs 
comparison checking scheme illustrated automatically executions unoptimized optimized versions source program inputs compares values computed corresponding executed statements program versions 
mappings described chapter specify statements cor responding unoptimized optimized programs 
semantic behaviors correct respect source program optimized program run high con dence 
hand semantic behaviors di er son checker displays statements responsible di erences optimizations applied statements 
optimizer writer information locate incorrect code optimized program determine transformation produced incorrect code 
semantic behavior unoptimized optimized program respect source program characterized outputs values computed source level statements unoptimized optimized program possible inputs 
semantic behaviors unoptimized optimized programs respect source program compared checking paths executed programs corresponding source level assignments compute values checker detect certain errors source program 
generate unoptimized program 
generate optimized program 
comparison checker executes unoptimized optimized programs performs comparisons inputs 
comparisons successful comparison checking system info statements optimizations related failed checks locate comparisons error optimizer 
unsuccessful read write corresponding locations outputs 
outputs values computed source level assignment statements branch predicates inputs compared 
addition assignments arrays pointers checking done ensure addresses values assigned correspond 
assignments source level variables compared exception dead values computed optimized code 
level checking allows comparison checking system locate earliest point unoptimized optimized programs di er semantic behavior respect source program 
checker detects earliest point execution corresponding source level statement instances compute values 
checker detect statements incorrectly optimized subsequently compute incorrect values 
consider unoptimized program fragment optimized version fig ure 
assume unoptimized program correct optimizer turned 
optimizer moves assignment ofx outside loop result applying loop invariant code motion 
optimized program executes returns incorrect output 
optimizer writer debug optimizer rst determining cause error optimized code 
checker di erence detected internal behavior unoptimized optimized programs line unoptimized program second iteration loop line optimized program 
checker indicates value assigned unoptimized program value assigned optimized program 
checker indicates loop invariant code motion ap plied statement optimizer writer examine unoptimized optimized versions program determine loop invariant code motion applied incorrectly 
optimizer writer error implementation loop variant code motion optimization rerun checker unoptimized optimized versions program 
unoptimized program fragment optimized program fragment int int 
print print program example comparison checking merits comparison checking system follows 
comparison fails earliest place failure occurred op involved reported 
information optimized program di ers unoptimized version bene ts optimizer writer debug ging optimizer 
internal values computed optimized code compared unoptimized program ner level testing provided just comparing outputs 
level checking nd errors optimized code cause output program incorrect 
optimizer writer greater con dence correctness optimizer 
wide range optimizations including classical optimizations register allocation loop transformations inlining handled technique 
optimizations performed source intermediate target code level 
comparison checker language independent 
technique applicable variety programming languages 
optimized code modi ed breakpoints recompilation required 
comparison checking scheme generally applicable wide range op simple code reordering transformations loop transformations 
chapter focuses mainly statement level optimizations 
chapter describes extend comparison checking scheme handle loop transformations inlining 
rest chapter organized presenting overview comparison checker section 
section describes annotations comparison checker guide checking values describes algorithms place annotations 
section presents experimental results 
comparison checker overview comparison checker scheme compares values computed mized optimized program executions ensure semantic behaviors pro grams 
automate scheme comparison checker determine values computed programs need compared de termine comparisons performed program executions perform comparisons 
achieve tasks sources information 
mappings corresponding instances statements unoptimized optimized programs described chapter utilized determine values computed programs compared 
mappings generated optimizations applied 
statements ected optimizations marked optimization applied checker report optimizations applied statements 
second code optimized generated compiler mappings automatically generate annotations unoptimized op programs guide comparison checker comparing corresponding values addresses 
program point program version annotations reached actions associated annotations point executed com parison checker 
annotations identify program points comparison checks performed 
third values compared computed order unoptimized optimized code mechanism saves values computed early 
values saved value pool removed longer needed 
annotations indicate values saved value pool discarded value pool 
high level conceptual overview comparison checker algorithm 
avoid modifying unoptimized optimized programs breakpoints extract values unoptimized optimized programs activate execute unoptimized program execute optimized program process annotations breakpoints process annotations breakpoints delay comparison check annotation save annotation save value computed 
save value computed 
delay annotation delete annotation switch execution optimized program discard saved value 
perform check value 
comparison check annotation delete value annotation perform comparison check discard saved value 
error report error comparison check annotation delayed check perform comparison check error report error 
switch execution unoptimized program 
comparison checker algorithm annotations associated program points unoptimized optimized programs 
execution unoptimized program drives checking execu tion optimized program 
execution begins unoptimized code proceeds breakpoint reached 
annotations unoptimized code checker determine value computed checked point 
breakpoint program point unoptimized code comparison check annotation indicates value computed statement checked 
default breakpoint program point unoptimized code associated annotation indicates value computed executed statement checked 
value checked optimized program executes corresponding value computed indicated comparison check annotation time check performed values 
execution optimized program values computed early corresponding value unoptimized code computed saved value pool directed save annotations 
delay comparison check annotation encountered indicating checking value computed unoptimized program performed current point value saved checking 
checker continues alternate executions unoptimized optimized programs 
annotations indicate values saved checking nally checked values removed value pool 
values computed statement instances deleted optimization checked 
unoptimized code delay checkable delete delete delete save annotated unoptimized optimized code check traces unoptimized optimized optimized code code trace code trace check save check check check check check save check delete check check check delete check check comparison checking scheme example comparison checking scheme example consider annotated unoptimized optimized code segments illustrates unoptimized optimized code example chapter 
assume statements shown source level statements loops execute single iteration 
breakpoints indicated circles 
breakpoints placed program points unoptimized optimized code associated annotations program points unoptimized code comparison checks performed 
switching unoptimized optimized program executions checker illustrated traces 
traces include statements executed breakpoints circled annotations processed 
arrows indicate switching programs 
unoptimized program starts execute continues executing checking deleted optimized program 
executes breakpoint reached checker determines annotation value computed checked point optimized program executes check processed occurs breakpoint 
values computed compared 
unop program resumes execution loop iteration begins 
executes breakpoint reached optimized program executes check processed 
number comparisons performed value computed breakpoint reached annotation save processed consequently value computed stored value pool 
optimized code continues executing breakpoint time annotation check processed 
values computed compared 
executes value checked 
executes breakpoint encountered 
optimized program executes value computed compared indicated annotation check breakpoint 
value saved value pool check 
programs continue executing similar manner 
annotations code annotations guide comparison checking values computed corre sponding statement instances unoptimized optimized code 
annotations identify program points comparison checks performed indicate values saved value pool available checks performed indicate value currently residing value pool discarded checks involving value performed 
set annotations complete placement annotations go hand hand comparison checking algorithm 
supporting statement level optimizations di erent types annotations needed implement comparison check ing strategy 
example example annotations shown dotted boxes 
annotations checker actions follow 
description indicates statement unoptimized code sopt statement optimized code 
check annotation check annotation associated program point code indicate check value computed statement performed 
cor responding value compared result executed statement optimized code 
example annotation check associated check annotation indicate check performed values statement unoptimized code corresponding statement optimized code remains original positions 
variation annotation check si sj annotation associated program point optimized code indicate check value computed statement performed value computed corresponding statements si sj optimized program 
corresponding value compared result executed statement optimized code value pool 
example annotation check associated original position statement optimized code 
check annotation check statements unoptimized code corresponding statements optimized code moved 
unoptimized code delay checkable delete delete delete save optimized code check save check check delete check check check check check check save check delete check check annotated unoptimized optimized code example save sopt annotation value computed statement sopt immediately compared corresponding value computed unoptimized code value computed sopt saved value pool 
situations value computed sopt compared multiple values computed unoptimized code 
saved values computed compared 
annotation save sopt associated sopt indicates value computed sopt saved 
statement unoptimized code loops invariant corresponds statement optimized code 
value computed immediately compared corresponding values computed unoptimized code executed prior execution 
annotation save associated delay checkable annotations value computed execution statement unoptimized code immediately compared corresponding value computed optimized code correspondence values immediately es value saved value pool 
annotation delay associated indicate checking value computed delayed saving value value pool 
point unoptimized code checking nally performed marked annotation checkable 
situations delay check needed correspondence statement instances established execution unoptimized code advanced 
statement inside nested loop unoptimized code moved loops optimized code partial dead code elimination 
situation value computed statement iteration nested loops compared value computed execution corresponding iteration nested loops determined execution unoptimized code exits loops 
checking value delayed 
situation delayed ciency reasons 
con sider example computation value moved loop loop 
case computed unop code execution optimized code advanced point loop value checked 
values computed inside loop saved resulting potentially large value pool 
avoid creation large pool checking value delayed loop shown 
unoptimized code optimized code 
save annotation 

check delete annotation delay types annotations unoptimized code optimized code 
checkable delete 
check delay annotation efficiency 
delete annotation associated program point unoptimized opt code indicate value computed previously stored value pool discarded 
value may multiple checks delete annotation introduced point relevant checks performed 
annotation delete appears loops optimized code point values computed statement unoptimized code compared corresponding value computed optimized code 
check self annotation check self annotation associated program point mized optimized code indicates values computed compared ensure values 
annotation mapping refers instances statement optimized unoptimized program 
loop enclosing begins execute rst value computed saved value pool 
subsequent values computed compared saved value 
tion causes value saved value pool delete annotation discard value value pool 
mapping statement refers instances annotation check self associated annotation delete introduced enclosed loop 
checking follows 
executes checking delayed computed value saved value pool 
rst time executes computed value saved value pool 
subsequent values computed compared saved value 
unoptimized program execution reaches program point value computed compared optimized program executes check encountered 
values computed compared point values discarded value pool 
delay checkable delete unoptimized code optimized code 
check self types annotations check delete depending position statement unoptimized code mapping referring instances check self annotation necessary illustrated 
mapping statement refers instances illustrated chapter check annotation perform comparison checks 
algorithms place annotations statement level optimizations selection placement annotations independent particular optimiza tions depend statement instances correspond relative positions corresponding statements unoptimized optimized programs 
mappings data ow analysis including reachability postdominance determine annotations 
annotations placed optimiza tions performed target code generated code emit annotations integrated separate phase compiler 
algorithms annotate unoptimized optimized programs 
algo rithms introduce check delay checkable check self save annotations consolidated applied time 
fourth algorithm introduces delete annotations applied algorithms applied 
ease tion algorithms separate control ow graphs gopt unoptimized optimized programs respectively 
algorithms easily modi ed handle representation programs single control ow graph 
algorithms terminology 
suppose mapping exists statement unoptimized program statement optimized program denoted statement rolled forward rolled back rolled forward rolled back respect determine rolled backward respect relatively positioned original position actual position compared gopt 
orhead denote corresponding original position gopt 
rolled backward respect path gopt exists orhead include backedges loops enclosing orhead 
backedge restriction ensures positions instance optimization considered 
enclosing loop cause incorrect examination instances successive iterations loop 
restricted notion path captured ath predicate 
de nition predicate ath true path program point program point gopt include backedges loops enclosing ath predicate statement respect rolled back ath orhead true 
statement respect rolled forward ath orhead true 
statement rolled back respect statement rolled forward respect statement rolled forward rolled back respect 
algorithm introduce check delay checkable annotations check delay checkable annotations direct comparison checker comparisons values computed unoptimized optimized programs performed 
execution unoptimized program drives checking execution optimized program annotations introduced statements unoptimized program 
algorithm shown takes input statement unoptimized program mappings unoptimized optimized control ow graphs gopt 
algorithm applied statement unoptimized program mapping 
mappings statement examined types tions introduced depend relative positions corresponding statements instances checked 
corresponding statement optimized code rolled forward check delayed ciency reasons 
mapping refers instance check delayed 
case delay necessary loop iteration determined unoptimized optimized code executes exits appropriate loop 
check delayed delay annotation introduced check checkable annotations introduced comparisons performed checking delayed check annotations introduced check annotations carefully placed ensure number check anno tations encountered runtime execution equals number comparisons need performed 
mapping corresponding statement optimized program rolled forward instance referred mapping rst conditions algorithm satis ed 
ensures instances checked extraneous little check annotations processed behalf optimized program execution 
remaining mappings statement check annotation associated program point optimized code represents original position statement algorithm introduce check self annotations check self annotation directs comparison checker check instances statement computed loop 
algorithm introduce check self annotations shown 
applied statements unoptimized optimized programs mappings takes input statement unoptimized optimized program mappings unoptimized optimized control ow graphs gopt 
statements optimized programs instances referred mappings check self annotations associated 
statements unoptimized code instances referred mappings corresponding statements rolled forward optimized code check self annotations associated 
statements unoptimized code instances referred mappings check self annotations associated 
algorithm introduce save annotations save annotations direct comparison checker save values comparison checks 
statements optimized program instances referred mappings rolled back respect corresponding statements unoptimized program save annotations associated 
algorithm introduce annotations shown 
takes input state ment optimized program mappings unoptimized optimized control ow graphs 
algorithm introduce delete annotations delete annotations direct comparison checker discard values value pool 
statements unoptimized optimized programs computed values saved value pool result delay save check self annotations delete annotations 
algorithm shown applied previous algorithms applied takes input mappings annotated unoptimized optimized control ow graphs 
statements unoptimized program delete annotations introduced unoptimized program similarly statements optimized program delete annotations introduced optimized program 
delete annotations carefully placed ensure appropriate values safely discarded 
delete annotations introduced comparisons involving value deleted performed 
mapping rolled forward respect mapping refers instance associate delay annotation delayed associate check annotations points gopt points postdominate original position ii points innermost loop li enclosing element representing li vector ofs associate checkable points remaining mappings associate check delay annotation associate checkable position annotation original position gopt algorithm introduce check delay checkable annotations mapping refers instances statement gopt associate check self annotation statement unoptimized program corresponding statement rolled forward associate check self annotation statement mapping refers instances associate check self annotation statement algorithm introduce check self annotations mapping refers instance mapping rolled back respect associate save annotation statement algorithm introduce save annotations statement unoptimized program mapping refers instance associate delete back edges loop li enclosing element representing li vector ofs delay introduced associate delete points postdominates checkable annotations statement optimized program save annotation introduced mapping refers instance associate delete back edges loop li gopt enclosing element representing li vector ofs save check self introduced associate delete points gopt postdominates ii mappings postdominates check annotations introduced mapping iii mapping refers instances delete annotation innermost loop li enclosing mappings elements representing li vectors delete annotation loop nest original position statement algorithm introduce delete annotations supporting loop transformations inlining previous sections support statement level optimizations 
support loop transformations annotations extended su xes handle instances statement unoptimized code reordered optimized code divided statements optimized code 
su xes describe speci instances sequences instances described mappings statements 
placement annotations extended follows 
instances statement unoptimized code reordered optimized code checking instances delayed 
mapping su added delay annotation indicate instances checks delayed order values computed instances saved value pool comparison checker 
ordering re ects ordering corresponding instances optimized code order comparison checks performed 
checkable annotation su indicates instances statement referred annotations 
example loop optimized code reversed instances statements unoptimized code reordered optimized code 
delay annotations placed instances statements 
checkable annotations placed loop indicate instances statements checks delayed ready checked 
unoptimized code optimized code delay delay delay checkable checkable checkable annotated loop reversal example check check check instances statement unoptimized code divided statements optimized code separate check delayed check utilized set divided instances mapping su added check annotation indicate instances statement unoptimized code checked 
example loop optimized code unrolled instances statements loop unoptimized code divided statements optimized code 
statement check annotations placed optimized code 
rst annotation refers odd instances second annotation refers instances 
statement loop test check annotation indicates checking odd instances instance 
statement loop increment check annotation indicates checking instances 
unoptimized code optimized code check annotated loop unrolling example check check check check function inlining replaces calls function unoptimized code bodies function optimized code supported 
call site separate mapping maintained statements function unoptimized code inlined copy optimized code 
analyzing mappings corresponding call site set annotations computed 
runtime function executed comparison checker selects follows appropriate set annotations knowledge call site encountered program execution 
implementation experiments comparison checker optimized code cop implemented including instruction mapping annotation placement checking 
lcc compiler application program extended include set optimizations loop invariant code motion dead code elimination partial redundancy elimination register allocation copy propagation constant propagation folding 
average optimized code generated optimized lcc executes faster execution time unoptimized code 
program optimized mappings generated 
generating target code lcc extended determine mappings unoptimized opti mized code breakpoint information annotations derived mappings 
code emit breakpoint information annotations integrated lcc library routines 
compilation optimization application program produce target code unoptimized program optimized program aux les containing breakpoint information annotations unoptimized optimized programs 
auxiliary les checker 
breakpoints generated value source level assignment computed array pointer addresses computed 
breakpoints generated save base addresses dynamically allocated storage structures malloc free 
array addresses pointer addresses compared comparing sets closest base addresses collected checker 
floating point numbers compared allowing inexact equality 
oating point numbers allowed di er certain small delta 
implemented fast breakpoints 
experiments performed assess practicality 
main concerns usefulness cost comparison checking scheme 
cop useful debugging optimizer implemented 
errors easily detected located implementation optimizations mappings annotations 
unsuccessful comparison values detected cop indicated source level statement computed value optimizations applied statement statements unoptimized optimized assembly code computed values 
terms cost slow downs unoptimized optimized programs speed comparison checker interest 
cop performs checking dur ing execution programs 
value address comparisons performed 
experiments cop ran hp unoptimized optimized programs separate sparc workstations running processor described section 
messages passed sockets mb network 
bu er reduce number messages sent executing programs checker 
integer spec benchmarks smaller test programs test cases 
table shows cpu execution times unoptimized optimized programs annotations 
average annotations slowed table execution times minutes seconds source unoptimized code optimized code cop length annotated annotated response program lines cpu cpu cpu cpu cpu time wc yacc go ksim compress li ijpeg spec benchmark test input set 
execution unoptimized programs factor optimized programs factor 
optimized program experiences greater overhead unoptimized program annotations added optimized program 
table shows cpu response times cop 
performance cop depends greatly lengths execution runs programs 
comparison checking took minutes hours terms cpu response times 
times clearly acceptable comparison checking performed line non interactively 
performance checker bounded processing platform speed network 
faster processor mb network consider ably lower times 
fact cop executes mhz pentium pro processor performance average times faster terms cpu time 
access faster network possible 
pool size measured experiments fairly small 
addresses compared pool size contains values programs 
addresses compared pool size contains values 
summary novel approach debug optimizers 
technique unoptimized optimized versions application program executed computed values compared ensure behaviors versions input 
values di erent comparison checker displays application program di erences occurred optimizations involved 
optimizer writer utilize information debug optimizer 
automation comparison checking scheme relies mappings described chapter annotations described chapter 
comparison checking scheme implemented executes unoptimized optimized versions programs 
experimental results demonstrate approach ective practical 
chapter comparison checking technique compared execution havior unoptimized version program optimized version program 
comparison checking technique utilized check di erent levels optimizations 
checking performed phases just optimizations phased 
example checking performed loop optimizations applied statement level optimizations applied low level optimizations ap plied 
phase checking reduce cost checking help optimizer writers debug optimizations applied phase checked 
furthermore comparison checking technique tailored help optimizers writers debug validate speci optimizations 
chapter comparison checking technique tailored global register allocation 
chapter register allocation checking comparison checking technique described previous chapter compared execution behaviors unoptimized version program optimized version program 
semantic behaviors di er comparison checker displays statements responsible di erences optimizations applied statements 
technique locate earliest point execution corresponding source level statement instances compute values indicate optimizations applied statement 
information helpful optimizations may applied statement detailed information optimizations may available 
provide ective infor mation comparison checking technique tailored help optimizer writers debug validate speci optimizations 
particular comparison checking technique tailored help debug validate implementation register allocation isa code transformation tedious di cult debug especially errors intermittent 
chapter register allocation checker developed extends comparison checking technique checker detect errors register allocator implementation determine possible cause errors 
register allocation checker incorporated comparison checker standalone tool 
register allocation checker similar comparison checker semantic behaviors unoptimized optimized programs compared 
register allocation checker saves di erent kinds information utilizes di erent set annotations track information variables assigned registers verify expected values variables optimized program execution 
level checking tracking allows register allocation checker locate earliest execution point unoptimized optimized programs di er semantic behaviors display user actual cause di erences 
register allocation technique implemented incorrectly incorrect behavior include wrong register evicting value register saving uses failing load value memory stale value 
stale value variable optimized program value variable computed register value variable register optimized program uses old value memory 
register allocation checker determine register allocator exhibits types behavior 
consider unoptimized program fragment optimized version 
assume unoptimized program correct register allocation turned 
register allocator assigns variables registers respectively optimized program copies value register register 
assume optimized program returns incorrect output 
checker di erence detected internal behavior unoptimized optimized programs line unoptimized code line optimized code 
checker indicates values unoptimized optimized programs di er indicates inconsistently evicted earlier execution optimized program 
checker indicates expected value register 
optimizer writer information debug implementation register allocation 
unoptimized code 

optimized code load load mul 
move load add 
add store program example register allocation checking register allocation checker overview register allocation checking scheme similar comparison checking scheme values computed unoptimized optimized programs checked register allocation checking scheme compares values variables programs tracks veri es information variables assigned registers optimized program execution 
automate scheme register allocation checker determine values computed programs need compared determine comparisons performed program executions perform comparisons track information variables assigned registers optimized program execution verify expected values variables optimized program execution 
tracking information includes maintaining program point execution optimized program current locations values variables variables memory locations hold stale values variables values registers evicted variables currently assigned registers 
achieve tasks mappings annotations utilized 
mappings comparison checker extended include correspondences uses variables unoptimized optimized intermediate programs 
mappings generated register allocation applied correspondence program versions changed application register allocation 
mappings capture ects register allocation optimizations check ing performed program registers allocated program registers allocated 
unoptimized program include application op assumed correct 
register allocation applied code generated compiler mappings automatically generate annotations optimized program guide register allocation checker comparing corre sponding values addresses tracking verifying information variables assigned registers program execution 
targeted program point optimized code reached actions associated annotations point executed register allocation checker 
high level conceptual overview register allocation checker algorithm 
algorithm similar comparison checker 
breakpoints extract values unoptimized optimized programs activate annotations 
annotations guide actions register allocation checker 
values assigned variables optimized code values tracked veri ed execution optimized program drives checking execution unoptimized program 
execution begins optimized code proceeds breakpoint reached 
depending annotation checker may track variables assigned registers evicted variables stale variables determine value computed checked current point execution optimized code 
value checked current point unoptimized program executes corresponding point execution reached time check performed values 
checker continues alternate executions unoptimized optimized programs 
values compared di er checker informs user possible causes di erence 
values tracked checker informs user inconsistencies stale value loaded unexpected value stored memory location 
inconsistency value avariable detected inconsistency propagated uses value 
annotations execute optimized program process annotations breakpoint check annotation execute unoptimized program equivalent execution point optimized program reached perform comparison check error report error cause error register assign annotation load annotation store annotation register move annotation update register variable information verify loaded stored value expected value inform user inconsistencies optimized program nished executing register allocation checker algorithm similar comparison checking technique code annotations guide check ing values unoptimized optimized code 
code annotations verify track values variables 
annotations identify program points compar ison checks performed indicate values variables registers tracked veri ed optimized code 
types annotations needed implement register allocation checking strategy 
example illustrates unoptimized optimized code example tions shown dotted boxes 
check annotation check annotation associated program point optimized code indicate check variable register performed 
register allocation checker execute unoptimized program equivalent program point reached 
corresponding value compared current value unoptimized code optimized code annotations 

load load mul 
move load add 
add check load load check check register assign register move load check check register assign check check register assign store check store annotations example optimized code 
example check annotation associated statement optimized code contents optimized code compared value unoptimized code 
check annotations check register loads stores uses assignments 
register assign annotation register assign annotation associated program point opti mized code indicate tracking information register updated 
register allocation checker records previous variable assigned evicted 
speci ed register allocation checker updates information indicate holds variable currently stored memory location holds stale value values currently registers evicted 
example register assign annotation associated statement optimized code variable tracked register optimized code 
load annotation load annotation associated load instruction optimized code track verify load information register register allocation checker records previous variable assigned evicted 
speci ed register allocation checker records holds variable currently stored values currently registers evicted 
tracking information checker veri es loaded value stale records information informs user stale value informs user current location expected value exists 
example load annotation associated statement optimized code track verify information register 
store annotation store annotation associated store instruction optimized code track verify store information register tracking information checker veri es hold expected value informs user hold expected value informs user current location exists 
register allocation checker records memory location holds current value 
example store annotation associated statement register move annotation register move annotation associated move instruction opti mized code track information register register allocation checker duplicates information pertaining register register example register move annotation associated statement optimized code track information register 
combining annotations check annotation associated store annotation checker veri es value register stored memory location variable program point optimized program matches value variable equivalent program point unoptimized program 
values match register currently holds variable checker informs user value optimized code incorrect 
value stale uninitialized wrong possibly correct value evicted register contains wrong value stored 
register currently hold variable checker informs user expected value variable resides register location variable wrong register address supplied instruction expected value evicted earlier saved memory value expected value earlier store 
check annotation associated load annotation treated similar manner 
check annotation associated register assign annotation checker veri es value assigned register program point optimized code matches value variable equivalent program point unoptimized code 
operands incorrect checker noti ed user uses unexpected values 
incorrect code generated 
annotation placement annotations placed optimized program follows 
mappings check register assign annotations placed variable assignment opti mized code check annotations placed variable optimized code 
instruction optimized code stores register register assign annotations placed program points check register assign anno tations placed 
instruction optimized code loads variable register check load annotations placed 
load instructions optimized code load annotations placed 
similarly instruction opti mized code stores memory location variable check store annotations placed 
store instructions optimized code store annotations placed 
move instruction optimized code register move annotations placed 
register allocation checker example consider annotated unoptimized optimized program segments fig ure illustrate unoptimized optimized code example fig ure 
breakpoints indicated circles 
annotations shown dotted boxes 
optimized program starts execute breakpoint reached 
checker determines annotation value loaded register compared value unoptimized code equivalent program point un optimized code 
unoptimized program executes breakpoint reached time checker compares value unoptimized program value optimized code 
values checker determines load annotation information regarding tracked 
checker records holds value currently stored 
stored register checker records evicted registers 
loaded value stale checker informs user stale value location expected value variable exists 
optimized program continues execution breakpoint reached 
checker processes load annotation recording latest variable evicted 
optimized unoptimized programs continue executing similar manner 
unoptimized code optimized code annotations load load mul 
move load add 
add store check load load check check register assign register move load check check register assign check check register assign check store register allocation checker example notice breakpoint reached checker processes register move annotation records holds value stored 
breakpoint checker processes load annotation records evicted 
breakpoint checker processes check annotation executing unoptimized program breakpoint reached time value unoptimized code compared 
values di er checker informs user evicted expected value optimized code 
summary register allocation checker provides ner level checking helps optimizer writer debug validate implementation register allocation 
level checking tracking enables checker locate earliest execution point unoptimized optimized programs di er semantic behavior display user actual cause di erences 
example register allocation checker inform user stale value wrong register value evicted register saved uses 
register allocation checker incorporated comparison checker standalone tool optimizations applied 
chapter source level debugger chapter mappings described chapter utilized develop source level debugger optimized code extends class reportable expected values previous reporting expected values computed optimized program 
value source variable computed optimized program execution reportable breakpoints source code value variable reportable 
expected values breakpoints reportable reportability ected values overwritten early written late 
expected values breakpoints reportable values path sensitive value may computed path location value may di erent di erent paths 
values reportable deleted path optimization 
cases debugger reports value deleted 
level reporting considered full reporting debugger developed dissertation called fulldoc full reporting debugger optimized code 
design source level debugger complex compar ison checker number reasons 
comparison checker uses expected values computed unoptimized optimized programs certain program points order perform comparison checks debugger needs able report ex pected values computed breakpoints reportable ranges 
comparison checker delays comparison checking values computed un optimized program corresponding values computed optimized code 
case debugger user queries variable breakpoint expected value computed optimized code debugger delay reporting expected value 
comparison checker utilizes annotations automate checking values computed programs compared minimize runtime overhead debugger debugger deal reportability expected values ected current user breakpoints 
fulldoc extends class reportable expected values judiciously static dynamic information 
strategy determine static pro gram analysis values optimizer placed position values may reportable 
reportability ofthese values may depend run time debugging information including placement breakpoints paths taken program execution 
execution invisible breakpoints employed gather dynamic information aids reporting placed values 
schemes transparent user debugging session employed enable full reporting 
report values overwritten early respect break point code motion register reuse fulldoc saves values overwritten deletes soon longer needed reporting 
fulldoc saves values expected values breakpoint 
report values written late respect breakpoint code sink ing fulldoc prematurely executes optimized program report value saving values overwritten roll ahead execution reported subsequent breakpoints 
reportability breakpoint dependent execution path optimized code fulldoc dynamically records information indicate impact path reportability ofa value able report values path sensitive computation value location dependent path 
fulldoc technique non invasive code executes code optimizer generated 
emulation technique instructions executed di erent order problem masking user optimizer errors avoided 
capabilities fulldoc follows 
value source variable computed optimized program execution reportable breakpoints source code value variable reportable 
fulldoc report expected values computed optimized program execution existing technique 
values computed optimized program execution values reported 
fulldoc incorporate existing techniques recover values 
runtime overhead minimized performing analysis compilation 
full doc utilizes debugging information generated compilation determine impact reportability values user breakpoints determine invisible breakpoints inserted report ected values 
techniques transparent user 
user inserts breakpoint reportability values ected breakpoint potential breakpoint fulldoc automatically inserts invisible breakpoints gather dynamic information report expected values 
user breakpoints placed source level statements regardless optimizations applied 
optimized program modi ed setting breakpoints 
breakpoints source code syntactically mapped optimized code 
wide range optimizations simple code reordering transformations loop transformations supported chapter focuses mainly statement level op hoist sink code including speculative code motion path sensitive optimizations partial redundancy elimination register allocation 
rest chapter organized section describing challenges reporting expected values examples 
section describes fulldoc approach 
sections describe debug information debug information computed 
section describes extend fulldoc support loop transformations inlining 
section presents experimental results 
challenges reporting expected values reportability value involved optimization ected 
register reuse code reordering code deletion 
execution path including loop iterations 
placement breakpoints 
section considers ect optimizations cause value variable overwritten early written late deleted 
cases impact path placement breakpoints considered 
section demonstrates fulldoc handles cases 
gures paths highlighted regions reportability ected 
reportability ected regions 
overwritten early optimized program avalue val variable overwritten early optimized program value val prematurely overwrites value 
application code hoisting optimization register reuse cause values overwritten early 
example consider unoptimized program optimized version refers th de nition speculatively hoisted result reportability ofx ected 
regardless execution path optimized code debugger report expected value breakpoint region simply displaying actual contents expected value value computed early causing previous value early actual value unoptimized program speculatively hoisted optimized program optimized program execution fulldoc debugging strategy save previous value discard saved value report saved value report current value true path taken execution overwritten early example path ect reportability 
assume breakpoint placed region expected value true path taken false path taken loop iteration 
computed branch actual value optimized code execution follows true path expected value reported false path taken value reported 
number loop iterations ect reportability 
expected value breakpoint region depends true path taken current loop iteration 
rst loop iteration expected value subsequent loop iterations expected value true path taken false path taken prior loop iterations 
computed loop actual value optimized code execution follows true path debugger report expected value subsequent loop iterations 
debugger report expected value dynamic currency determination expected value break points region reported value overwritten 
emulation technique report expected value region true path region technique path sensitive expected value reported region false path region due iterations 
fulldoc report expected values 
execution optimized code value overwritten early respect breakpoint fulldoc saves value value pool 
fulldoc saves necessary discards values longer needed reporting 
illustrates fulldoc strategy optimized program executes true path assuming loop executes time 
fulldoc saves assignment reports saved value breakpoints regions fulldoc discards saved value execution reaches original position breakpoints non highlighted path region fulldoc reports current value notice values saved long observable breakpoint inthe source program save discard mechanism automatically disambiguates value report breakpoints region currently saved breakpoint false path executed saved value reported 
currently saved true path executed current value reported 
notice saving strategy strategies performed respect user breakpoints 
words user insert breakpoints regions reportability ofx ected fulldoc save value written late optimized program avalue val written late optimized program compu tation val delayed due example code sinking partial dead code elimination 
suppose partially dead false path moved true branch 
result expected value breakpoint regions reportable optimized code 
consider breakpoint placed region expected value actual value optimized code true path taken false path taken 
execution follows true path unoptimized program optimized program partially dead optimized program execution fulldoc debugging strategy report current value save values executing program report executes remember computed path true path taken execution written late example report current value expected value reported 
reportability ected loop iterations ect overwritten early case 
dynamic currency determination expected value break points region reported provided true path taken regions emulation technique path sensitive expected value region reported 
fulldoc report values provided true path taken 
note values regions possibly reported schemes recovery techniques employed 
requested value written late respect breakpoint fulldoc prematurely executes optimized code saving previously computed values overwritten reported subsequent breakpoints 
illustrates fulldoc strategy optimized program executes true path 
breakpoints region fulldoc reports expected value executing optimized code saving previously computed values overwritten 
roll ahead execution stops executes 
breakpoints non highlighted path region fulldoc reports computed unoptimized program optimized program consider case statement deleted value computed optimized code 
example suppose dead unoptimized program deleted 
expected value breakpoint region reported optimized code 
unoptimized program optimized program dead optimized program execution remember computed path disregard path fulldoc debugging strategy report current value report value computed report current value false path taken execution computed optimized program example consider placing breakpoint region expected value region true path taken false path taken 
deleted actual value optimized code true path actual value expected value reported false path expected value reported 
emulation technique report expected value region path sensitive 
dynamic currency determination fulldoc report expected value breakpoints region true path taken 
illustrates fulldoc strategy optimized program executes false path 
breakpoint non highlighted paths fulldoc reports current value execution reaches original position fulldoc knows reportable regions reports expected value computed 
execution reaches fulldoc disregards non reportability information fulldoc approach fulldoc uses sources debug information debugging capabilities 
mappings corresponding instances statements unoptimized optimized programs described chapter generated optimizations applied 
second code optimized generated compiler static analysis applied gather information reportability expected values 
reportability debug information user breakpoints inserted special program points reached program execution user breakpoint reached 
third user inserts breakpoints source program static information mappings reportability debug info fulldoc set corresponding breakpoints set invisible breakpoints reportability affected fulldoc strategy respect user inserting breakpoints optimized code execution execution dynamic debug information indicating special points reached position user breakpoints enable full reporting 
illustrates fulldoc strategy respect user inserting break points 
user inserts breakpoints program executes pro gram execution fulldoc uses mappings determine corresponding breakpoints optimized code 
fulldoc uses reportability debug information determine impact reportability breakpoints potential breakpoints value overwritten early respect breakpoint fulldoc inserts invisible breakpoints save value execution long value reportable discard value longer needed 
reportability ofa variable respect breakpoint sensitive fulldoc inserts invisible breakpoints update dynamic debug information regarding reportability value 
illustrates fulldoc strategy user invisible break point reached 
user breakpoint reached fulldoc informs user 
invisible breakpoints reached fulldoc performs actions 
value overwritten early fulldoc saves value value pool discards value longer needed reporting 
value path sensitive full doc updates path sensitive info regarding reportability value depending execution path taken 
illustrates fulldoc strategy respect user queries user breakpoint 
fulldoc responds user queries static dynamic infor mation 
user requests value variable fulldoc uses reportability debug information dynamic debug information determine reportability value 
value available location memory register variable value pool fulldoc reports value 
reportability value path sensitive breakpoint fulldoc uses path sensitive information determine value reportable breakpoint 
requested value written late respect breakpoint fulldoc uses reportability debug information roll ahead execution optimized code saving previously computed values overwritten 
stops execution value computed reports value user computed 
value computed execution fulldoc informs user value reportable 
source program static information mappings reportability debug info fulldoc dynamic information value pool info path sensitive info user breakpoint invisible breakpoint fulldoc strategy respect breakpoints hit user queries source program static information mappings reportability debug info fulldoc dynamic information value pool info path sensitive info invisible breakpoint fulldoc strategy respect user queries breakpoint hit optimized code execution optimized code execution memory reportability debug information section describes reportability debug information computed static analysis optimized code provided fulldoc fulldoc employs information runtime collects dynamic debug information response user setting breakpoints requesting values variables break points 
debug information organized tables shown 
table contains debug information expected values variables re portable 
tables contain debug information reporting values variables overwritten may overwritten early 
tables contain debug informa tion reporting values variables written may overwritten late 
tables contain debug information determining values variables computed execution optimized code 
rest section describes tables detail 
variable reportable table information written late optimized code table information lateatbkpts simply reportable overwritten early optimized code table information computed unoptimized code optimized code table information debug information table indicates program ranges optimized code expected values source variables available reporting 
def loc def loc value variable reportable breakpoint provides location memory location register name value 
case value location matter execution path taken loc provides location 
possible location depends path taken execution reachable multiple de nitions stores value di erent location di erent register 
case execution path taken determines latest de nition encountered location value 
potential de nition location pairs defi loci provided case 
breakpoint set debugger activates recording de nition encountered def def 
inserting invisible breakpoints points 
invisible breakpoint hit execution debugger records latest de nition encountered previously recorded de nition 
overwritten early table indicates program ranges optimized code expected values source variables available values may overwritten early 
fes es overwrites early breakpoint bg es save discard fulldoc report values ected program ranges tables follows 
user sets breakpoint atb statement es overwrites early save discard points es activated inserting invisible breakpoints 
ensures values variables overwritten early respect breakpoint saved available reporting value pool case requested user 
note save discard points activated immediately breakpoint set user values may requested user breakpoint saved 
discard point reached path currently saved save point reached path debugger simply ignores discard point 
example illustrated section overwritten early handled case 
highlighted regions regions reportability ected 
breakpoints region reportability ected regardless execution path taken 
breakpoints region breakpoints unoptimized program discard point optimized program save point discard point overwritten early example id 
statement ids save current position discard original position original position reportability debug information overwritten early example reportability ofx path sensitive 
breakpoints region reportability path sensitive depends current loop iteration 
cases reportability ected handled tables 
save discard points illustrated id tables displayed 
written late lateatbkpts table indicates program ranges optimized code expected values source variables available values may late may execute 
lateatbkpts fls ls writes late breakpoint bg ls fulldoc report values ected program ranges tables follows 
assume user sets breakpoint atb 
statement ls lateatbkpts fulldoc rst determine ls written late respect instance breakpoint original position ls reached execution current position ls reached breakpoint hit ls written late 
information determined follows 
statement ls written late fulldoc inserts invisible breakpoints original current positions ls records original position ls encountered execution 
current position ls reached execution recorded information discarded 
suppose execution reaches user requests value variable written late statement ls lateatbkpts 
original position ls currently recorded late current instance breakpoint execution program rolls ahead points ls encountered 
point value just computed known de nitely computed recall sinking partially dead code cause situations arise 
overwritten early case save discard points activated breakpoint set points activated breakpoint hit request value written late 
example illustrated section reportability ofx region ected handled case 
points illustrated lateatbkpts tables displayed 
unoptimized program point optimized program point overwritten late example breakpoints lateatbkpts id 
statement ids id current position false path lateatbkpts reportability debug information overwritten late example reportable deleted path partial dead code removal performed value variable de ned deleted statement 
breakpoint variables values reportable matter execution path taken recorded statements removed paths dead code elimination partial dead code elimination respectively 
fv reportable deleted fv reportable late user requests value variable breakpoint fulldoc reports user value reportable statement computes deleted execution path 
example illustrated section reportability ofy ected region handled case 
table displayed 
example bility ected region handled case 
table displayed 
unoptimized program optimized program dead code elimination example breakpoints id 
reportability debug information example breakpoints id 
reportability debug information example path sensitive reportability deleted value may deleted path case reportable deleted path case reportable 
path sensitive case reportability information updated execution paths executed program points reached 
fds ds may deleted breakpoint bg ds fds ds may deleted user sets breakpoint atb invisible breakpoints set original positions deleted statement ds record positions encountered execution 
invisible breakpoints set de nition range ds stored ds 
ds reached execution recorded information discarded 
consider case breakpoint reached user requests value variable de ned statement ds 
dynamically recorded information shows original position ds encountered debugger reports value computed ds deleted 
debugger reports current value example reportability ofy region path sensitive handled case 
tables displayed 
breakpoints id 
statement ids id original position breakpoints id 
reportability debug information example strategy deleted statement prevents fulldoc setting invisible breakpoints late 
holds deleted statements reportability ected potential breakpoints reportability isnot necessarily ected invisible breakpoints set execution breakpoint fulldoc gathers appropriate dynamic information potential breakpoints 
table example displayed 
path sensitive reportability written late sinking code involve path sensitive reporting statement may sunk path 
case opposite previous late statement encountered reportable 
fls ls may late breakpoint bg ls fls ls may late user sets breakpoint atb debugger initiates recording late statements setting invisible breakpoints original new positions late statements 
debugger discard recorded information late statement ls ls encountered ls holds de nition range ls 
consider case breakpoint reached user requests value variable de ned statement ls 
dynamically recorded information shows late statement ls encountered debugger reports current value original position late statement encountered debugger reports value reportable 
example reportability region path sensitive handled case 
tables displayed 
strategy applies late statement ds prevents fulldoc setting invisible breakpoints late 
late table example displayed 
breakpoints id 
statement ids id original position breakpoints id 
reportability debug information example computing reportability debug information mappings compute reportability debug information 
algorithm gives overview debug information computed 
lines determine values overwritten early compute information 
lines determine values written late compute lateatbkpts 
lines determine rest debug information data ow analysis 
details particular steps follow 
source de nition dv dv overwrites early discard discard 
corresponding positions original de nitions reachable arhead dv optimized code dv arhead dv discard breakpoint path dv discard discard fdv dv writes late optimized code dv dv fp earliest possible program point paths orhead dv dv breakpoint paths orhead dv dv corresponding positions original de nitions reachable orhead dv optimized code lateatbkpts lateatbkpts fdv compute comparing ranges orhead dv arhead dv compute determining deleted late statements occur path compute reachability algorithm compute reportability debug information determining statements overwrite early write late 
determine values overwritten early due register reuse suppose dx de nition variable location register optimized code 
dx reaches assignment reassigned variable temporary overwritten early reassignment 
determine values variables overwritten early due code hoist ing optimizations original positions de nitions actual positions optimized program compared gopt 
arhead dv denote actual po sition de nition dv orhead dv denote corresponding original posi tion dv 
existence path arhead dv orhead dv include backedges loops enclosing arhead dv orhead dv determined 
backedge restriction ensures positions instance dv optimization considered 
restricted tion path captured ath predicate de nition 
ath arhead dv orhead dv true location program point arhead dv location hold value dv overwritten early dv optimized code 
example ath arhead orhead true overwritten early determine values variables written late optimized program original positions de nitions actual positions optimized program similarly compared gopt 
de nition dv existence path orhead dv arhead dv include backedges enclosing points determined 
ath orhead dv arhead dv true de nition dv written late optimized code 
example written late ath orhead arhead true 
computing 
value overwritten early dv optimized code save point associated position dv optimized code discard points associated corresponding positions original de nitions reachable dv optimized code 
reachable original de nitions similar reachable de nitions problem determined solving data ow equation succ gen rod fdv orhead dv bg gen rod kill rod fdv orhead de nition vg 
example original de nitions reachable optimized code arhead fx fore save point associated arhead discard points associated orhead orhead arhead head orhead 
save discard points dv computed breakpoints reportability ected dv determined 
dv lies paths save corresponding discard points dv 
easily computed solving data ow equation gopt pred fdv dv overwrites early save point bg fdv dv overwrites early discard point bg 
dv dv 
example breakpoint regions fx computing lateatbkpts 
de nition dv variable written late dv earliest points execution late value computed point reached known value computed execution 
point associated arhead dv 
points associated earliest points paths orhead dv appropriate instance dv execute 
oint dv arhead dv dv ath oint dv condition ensures point placed dv 
condition ensures rest points placed program points appropriate instance late statement execute 
condition ensures points placed earliest points 
set statements written late reachable reachable late easily computed solving data ow equation gopt succ gen rl fdv arhead dv bg kill rl fdv orhead dv bg 
gen rl kill rl consider example 
program point false 
notice condition ensures point placed region unoptimized program optimized program point point overwritten late example points dv computed breakpoints reportability ected dv dv may late may execute determined 
dv lateatbkpts lies paths orhead dv points dv corresponding positions original de nitions reachable dv optimized code paths points positions original de nitions paths points positions original de nitions excluded possible de nition dv sunk past position original de nition dv considered late respect breakpoints paths 
example point ofx arhead lateatbkpts fx breakpoint region lateatbkpts fx breakpoint region gopt lateatbkpts easily computed solving data ow equation pred gen la fdv orhead dv bg kill la fdv dv gen la kill la orhead de nition dv lateatbkpts dv 
example break point region lateatbkpts fx computing 
mappings construct program ranges variable value correspond unoptimized code real range optimized code actual range 
comparing ranges program ranges optimized code corresponding regions value variable available reporting identi ed 
breakpoint program range variable com puted performing data ow analysis propagate locations memory registers variables program ranges 
computing 
determine values variables reportable breakpoint application dead code elimination deleted statements propagated reportability ected regardless execution path taken opti mized control ow graph gopt solving data ow equation pred gen kill fdv orhead dv dv fdv orhead de nition vg 
breakpoint dv dv del 
example breakpoint region 
equation gopt similarly computed solving data ow pred gen nrl kill nrl gen nrl fdv orhead dv dv overwritten kill nrl fdv orhead de nition vg 
breakpoint dv dv late dv lateatbkpts 
example breakpoint region lateatbkpts 
computing 
determine values variables may reportable path deleted data ow equation gopt rst computed pred fdv orhead dv dv fdv orhead de nition vg 
dv dv dv dv del 
example breakpoint region 
equation gopt similarly computed solving data ow pred gen ml kill ml gen ml fdv orhead dv dv overwritten kill ml fdv orhead de nition vg 
dv dv dv dv late dv lateatbkpts 
example breakpoint region 
computing 
variable deleted statement ds points ds corresponding positions original de nitions reachable orhead ds 
example original position orhead 
similarly variable late statement ls ls corresponding positions original de nitions reachable orhead ls 
computing 
deleted statement dv dv lies paths orhead dv corresponding positions original de ni tions reachable orhead dv optimized code 
easily computed solving data ow equation gopt pred fdv orhead dv dv fdv orhead de nition vg 
dv dv 
example breakpoint regions 
similarly computed 
statement dv written late dv lies paths orhead dv corresponding positions original de nitions reach able orhead dv optimized code 
easily computed solving data ow equation gopt pred gen pbl kill pbl fdv orhead dv dv overwritten kill pbl fdv orhead de nition vg 
dv dv 
example breakpoint regions 
supporting loop transformations inlining loop transformations inlining loops transformed functions inlined prematurely executed 
debugger rolls ahead execution optimized program 
statement instances prematurely executed saved order corresponding instances unoptimized program 
values overwritten roll ahead execution saved reported subsequent breakpoints 
reportability debug information extended indicate program ranges optimized code loops transformed functions inlined start points execution roll forwarding program ranges expected values variables reportable computed transformed loop inlined code respect unoptimized program 
example loop optimized code reversed 
suppose breakpoint placed user loop unoptimized code instance breakpoint user requests value debugger roll forward execution optimized program entire loop executes 
values source variables computed debugger saves values order computed unoptimized code 
debugger returns control user 
instance breakpoint debugger reports user expected value breakpoint debugger reports expected value computed optimized program execution 
breakpoint breakpoint unoptimized code optimized code loop reversal example implementation experiments fulldoc debugging strategy save reorder values source variables executing program loop executes 
instance breakpoints display expected values computed fulldoc implemented rst extending lcc compiler pro grams set optimizations including coloring register allocation loop invariant code motion dead code elimination partial dead code elimination partial redundancy elim copy propagation constant propagation folding 
lcc extended perform analyses needed provide debug information fulldoc previous section 
fulldoc implemented debug information generated lcc fast breakpoints implementation invisible breakpoints 
experiments performed measure improvement reportability expected values suite programs yacc spec benchmarks 
purpose evaluation user breakpoint placed source statement improvement reportability fulldoc technique uses static information determined 
breakpoint reasons reportability ected reported improvement fulldoc technique techniques report overwritten values path sensitive values compared 
table shows benchmark percentage values reported statically computed information fulldoc 
rst row gives percentages values deleted paths reportable fulldoc noted fulldoc recover values debuggers 
rows give percentages values reportability ected overwritten early code hoisting row register overwritten early row 
debugger include mechanism saving values overwritten early able report values 
rows give percentages values reportability ected statements computed values ected partial dead code elimination 
row indicates percentages values reportable paths sunk values 
row indicates percentages values reportable paths sunk values computed 
row indicates percentages values reportable paths reportability ofthe values sunk path sensitive 
debugger include mechanism roll ahead execution optimized program able report values 
rows give results reportability ected path sensitive information 
seventh row gives percentages reportable path sensitive deletes 
case values may deleted paths executed 
eighth row gives results location value path sensitive 
technique include path sensitive information fail report values 
row gives total percentages reported 
average fulldoc report local variables source breakpoint debugger static information report 
table percentage local variables breakpoint reportable problems yacc compress go ksim ijpeg static full static full static full static full static full info doc info doc info doc info doc info doc deleted paths code hoisting reg overwrite code sinking rf del path path sens late path sens delete path sens location total shows benchmark percentage values reported statically computed information timestamping technique emulation technique fulldoc 
fulldoc report values techniques statically computed information 
fulldoc report values emulation technique path sensitivity register overwrites handled 
fulldoc report values dynamic currency determination technique early overwrites preserved roll ahead mechanism employed 
percentage local variables breakpoint reportable yacc compress go ksim ijpeg expected values reportable table presents statistics static analysis fulldoc 
rst rows show number source statements percentage source statements reportability ected optimizations 
rows give number entries tables generated runtime 
noted largest table register overwrites 
row shows increase compilation computing debug information averaged 
table shows average number invisible breakpoints source code statement encountered execution 
numbers shown various types invisible breakpoints 
numbers indicate overhead incurred runtime invisible breakpoints 
rows display overhead imposed roll ahead execution optimized program 
average source assignment statements executed roll 
maximum number statements executed roll forward ranges values means number values saved roll ahead moment 
average roll ahead source assignment statements ranges statements 
size table static statistics yacc compress go ksim ijpeg 
source statements statements ected number code hoisting table reg overwrite entries code sinking rf path sens late path sens delete path sens location increase compile time value pool holding values overwritten early small maximum size ranging entries entries indicating optimizations moving code far 
table runtime statistics yacc compress go ksim ijpeg breakpoints reportability ected avg 
code hoisting invisible reg overwrite breakpoints code sinking rf source path sens late statement path sens delete path sens location duplicates removed source assignments executed roll forwards maximum roll forward length average roll forward length experiments show table sizes required hold debug formation increase compile time compute debug information quite modest 
runtime cost fulldoc technique maximum fast breakpoint source level statement possible values requested user possible breakpoints reasonable 
payo fulldoc technique substantial reports values best previously known techniques 
presence pointer assignments source program increase fulldoc overheads strategies rely determining ranges variables ected 
control equivalent code motion assignments introduced new paths removed paths ranges reportability values ected presence pointer assignments statically determined 
case reportability variable ected reportable range possibly pointer assignment code deletion non control equiv code motion fulldoc strategy dynamically track range reportability value variable ected 
summary chapter presents fulldoc full reporting debugger optimized code reports expected values computed optimized program 
value source variable computed optimized program execution reportable breakpoints source code value variable reportable 
experimental results show fulldoc report values techniques relying static information existing techniques limit dynamic information 
fulldoc improvement existing techniques achieved statically computing information guide gathering dynamic information enables full reporting 
values fulldoc reported computed optimized program execution deleted paths path executed 
chapter compilers apply optimizations improve performance programs application creates challenges debugging optimized code 
debugging optimized code necessary production compilers apply optimizations achieve high performance current trends processor design increasingly rely compiler optimiza tions achieve high performance 
cases optimized version program execute execute reasonable amount time 
application program mers intend ship optimized code optimized code debugged 
errors may masked version program debugged 
prior debugging optimized code focused development source level debuggers optimized code 
problem debugging optimized code twofold errors optimized program caused errors original source program introduced optimizer 
optimizer may apply unsafe transformation error may exist implementation optimization 
source level debugging techniques developed help application programmers debug optimized code point view source program help optimizer writers debug optimizers complex pieces software tedious debug 
source level debugging techniques developed modify optimized code setting breakpoints transparent user support aggressive optimizations 
summary contributions developing source level tools debug optimized code hampered di culties establishing correspondence source optimized code 
dissertation analyzed ects optimizations complexities maintaining correspondence unoptimized optimized code 
scope research covers variety code transformations including statement level optimizations loop trans formations inlining 
statement level optimizations include speculative code motion path sensitive optimizations 
optimizations dynamic memory management opti considered 
mapping technique developed tracking correspondences unoptimized optimized code statements code trans formations performed 
mappings capture impact optimizations statements instances useful wide range optimizations 
dissertation explored dynamic information develop source level debugging techniques help optimizer writers application programmers debug optimized code 
mappings developed dissertation develop complementary source level debugging tools optimized code im plemented experimentally evaluated 
techniques support aggressive optimizations including speculative code motion path sensitive optimizations loop transformations previously developed techniques 
rst technique developed help debug optimizers called comparison check ing approach compares values computed unoptimized op executions source program detects semantic di erences versions 
comparison fails earliest place failure occurred optimizations involved reported 
optimizer writer utilize information debug optimizer optimizer writer greater con dence correctness optimizer 
internal values computed optimized code compared unoptimized program ner level testing provided nd errors optimized code cause output program incorrect 
automation comparison checking scheme relies mappings developed dissertation annotations guide actions comparison checker 
technique restrict set optimizations applied optimized code modi ed setting breakpoints 
comparison checking scheme implemented executes unoptimized optimized versions programs 
experimental results demonstrate approach ective practical 
fact scheme proved useful debugging optimizer implemented 
comparison checking technique modi ed check di erent levels optimizations 
just optimizations phased checking performed phases 
example checking performed loop optimizations applied statement level optimizations applied low level optimizations applied 
phase checking reduce cost checking help optimizer writers debug optimizations applied phase checked 
furthermore comparison checking technique tailored help optimizers writers debug validate speci optimizations 
dissertation described tailor comparison checker global register allocation 
register allocation checker detect errors register allocator implementation determine possible cause errors 
example register allocation checker inform user stale value wrong register value evicted register saved uses 
register allocation checker scheme compares values computed unoptimized optimized program executions tracks veri es information variables assigned registers program execution 
register allocation checker incorporated comparison checker standalone tool 
second technique full reporting source level debugger optimized code called fulldoc application programmers nd errors source programs 
debugger provide expected program state previously developed source level debuggers optimized code 
value source variable computed optimized program execution reportable breakpoints source code value variable reportable 
fulldoc improvement existing techniques achieved statically computing information guide gathering dynamic information enables full reporting 
technique demonstrated compiler performs set global statement level optimizations source programs 
technique restrict set optimizations applied optimized code modi ed setting breakpoints 
techniques transparent user 
user inserts breakpoint reportability ected breakpoint potential breakpoint fulldoc automatically inserts invisible breakpoints gather dynamic information report expected values 
experimental results show fulldoc report values techniques relying static information existing techniques limit dynamic information 
values fulldoc reported computed optimized program execution deleted paths path executed 
number open interesting research problems 
mappings dissertation develop comparison checker source level debugger optimized code mappings bene number applications 
problems research include extending debugging techniques provide debugging features support aggressive optimizations programming languages 

mappings developed dissertation develop tools bene anumber applications 
di cult understand inspect optimized code isolation unop code 
unoptimized code available di cult especially knowledge transformations applied wrote program 
mappings develop tool enables understanding inspection optimized code indicating statement instances unoptimized code correspond statement instances optimized code 
mappings enhance programming environment tools 
example interactive programming environment tools developed assist users parallelizing programs 
tools help users decide restructure programs analyzing performing transformations detect exploit parallelism 
integrating map pings gives users better understanding ects applied transformations visually seeing di erences new version original pro gram version 
extra information help users better informed decisions verify decisions correct 
mappings design program development tools 
example pro le performance analysis tools identify performance bottlenecks 
results conveyed users terms unoptimized program 
case pro ling optimized code mappings convey results pro led optimized code terms unoptimized program 

dissertation covers aggressive optimizations previously de veloped source level debugging techniques optimized code issue optimization coverage 
example production compilers produce predicated code code dynamically optimized need develop source level debugging tools support optimizations addressed 
support dynamic optimizations require dynamic updating map pings unoptimized optimized code dynamic analysis mappings unoptimized code optimized code 
terms source level debug ger predicated code require invisible breakpoints capture execution control ow optimized code 

source level debugger developed dissertation support modi cation variables ectively support asynchronous breakpoints core les 
debugger report expected values deleted optimized code 
research extend source level debugger techniques include debugging features 
design source level debugger optimized code debugging capabilities unoptimized code remains open problem 

dissertation focused source programs 
interesting consider impact features programming languages developing source level debugging tools optimized code 
problems encountered language avoided java 
example memory uninitialized java optimizations reorder oating point operations java 

comparison checker tailored help users nd errors implementation global register allocation 
interesting see tailor comparison checker help users nd errors optimizations 

comparison checker embedded debugger 
case response time checker appropriate debugger 
number comparisons reduced 
amount checking limited checking certain regions source level code speci ed user 
strategy useful unnecessary check entire program 
example testing programs typically executed di erent inputs checking entire program input may redundant unnecessary 
region de ned statements ected application code transformations 
approach optimization dependent 
analysis techniques need designed determine values may ected program changes 
approach optimization independent check values guaranteed unoptimized op program executions 
static analysis techniques need developed analyze versions program determine values execution need checked 
values guaranteed checked 
course conservative approach taken 
checks analysis guarantee value eliminated 

techniques explored ectively develop comparison checking technique parallelized code 
harder problem optimized code execution behavior sequential code compared parallelized code 
program executions easily orchestrated parallel version required perform serial execution 
extracting values shared memory problem values memory extracted values overwritten processes 
distributed memory communication values comparison checker may optimized practicality purposes 

need gather dynamic information source level debugger comparison checker support hardware provided access program state control execution program 
example hardware assisted breakpoints provided 
new mechanism developed allow debugger execute context debugged program set breakpoints extract program state going operating system 

currently debug information supplied optimizing compiler debug ger incorporated existing debug formats dwarf debug formats 
debug formats extended 

comparison checking technique developed dissertation designed unoptimized optimized versions program comparison checking technique possibly extended handle di erent program versions 
version derived form version programming edits programming tools source source translators 
mappings developed establish relationship program versions 
bibliography bibliography dwarf debugging information format 
industry review draft unix international programming language special interest group sig 
abramson foster sosic relative debugging application development large numerical models 
proceedings ieee supercomputing december 
abramson sosic debugging tool software evolution 
case th international workshop computer aided software engineering pages july 
abramson sosic debugging testing tool supporting software evolution 
journal automated software engineering 
abramson foster sosic new methodology debugging scienti applications 
communications acm november 
abramson sosic 
watson implementation techniques parallel relative debugger 
proceedings international conference parallel architectures compilation techniques october 
adl tabatabai source level debugging globally optimized code 
phd dissertation carnegie mellon university 
technical report cmu cs 
adl tabatabai gross detection recovery endangered variables caused instruction scheduling 
proceedings acm sigplan conf 
programming languages design implementation pages june 
adl tabatabai gross evicted variables interaction global register allocation symbolic debugging 
proceedings th popl conference pages january 
adl tabatabai gross source level debugging scalar optimized code 
proceedings acm sigplan conf 
programming languages design implementation pages may 
allen kennedy porter eld warren conversion control dependence data dependence 
proceedings th popl conference pages january 
bala duesterwald banerjia dynamo transparent dynamic optimization system 
proceedings acm sigplan conf 
programming languages design implementation pages june 
boyd whalley isolation analysis optimization errors 
proceedings acm sigplan conf 
programming languages design implementation pages june 
brooks hansen simmons new approach debugging optimized code 
proceedings acm sigplan conf 
programming languages design implementation pages june 
burke choi fink grove hind sarkar serrano sreedhar srinivasan whaley jalape dynamic optimizing compiler java 
proceedings java pages june 
bug nd debugging optimizing compilers 
sigplan notices january 
chang mahlke chen warter hwu impact architectural framework multiple instruction issue processor 
proceedings th international symposium computer architecture pages may 
debugging optimized code misled 
phd dissertation university california santa cruz 
technical report ucsc crl 
debugging optimized code misled 
acm transactions programming languages systems 
mcdowell detecting unexpected data values optimized code 
technical report board studies computer information sciences university california santa cruz october 
coutant doc practical approach source level debugging globally optimized code 
proceedings acm sigplan conf 
programming languages design implementation pages june 
dhamdhere dynamic currency determination optimized programs 
acm transactions programming languages systems november 
fraser hanson retargetable compiler design implementation 
benjamin cummings 
fritzson systematic approach advanced debugging incremental compilation 
proceedings acm sigsoft sigplan software engineering symposium high level debugging pages 
gross bisection debugging 
proceedings workshop pages may 
gupta debugging code reorganized scheduling compiler 
structured programming 
hennessy symbolic debugging optimized code 
acm transactions programming languages systems july 
holzle chambers ungar debugging optimized code dynamic deoptimization 
proceedings acm sigplan conf 
programming languages design implementation pages june 
gupta capturing ects code improving transformations 
proceedings international conference parallel architectures compilation techniques pages 
springer verlag october 
gupta comparison checking approach avoid debugging optimized code 
acm sigsoft symposium foundations software engineering european software engineering conference pages 
springer verlag september 
gupta fulldoc full reporting debugger optimized code 
th international static analysis symposium pages 
springer verlag june july 
kessler fast breakpoints design implementation 
proceedings acm sig plan conf 
programming languages design implementation pages june 
mackenzie debug format 
free software foundation contributed cygnus support 
necula translation validation optimizing compiler 
proceedings acm sigplan conf 
programming languages design implementation pages june 
park schlansker predicated execution 
technical report hpl hp laboratories palo alto ca may 
high level debugging parallelized code code liberation 
phd dissertation university pittsburgh april 
technical report 
debugging parallelized code code liberation techniques 
proceedings acm onr sigplan workshop parallel distributed debugging may 
practical approach symbolic debugging parallelized code 
proceedings international conference compiler construction april 
pollock high level debugging aid incremental optimizer 
st annual hawaii international conference system sciences volume pages january 
interactive debug requirements 
proceedings acm sig soft sigplan software engineering symposium high level debugging pages 
sosic program directing 
proceedings acm sigplan conf 
programming languages design implementation pages june 
sosic procedural interface program directing 
software practice experience july 
sosic design implementation directing platform compiled programs 
computing systems spring 
sosic abramson guard relative debugger 
software practice experience february 
tice non transparent debugging optimized code 
phd dissertation university california berkeley 
technical report ucb csd 
tice graham optview new approach examining optimized code 
proceedings acm sigplan workshop program analysis software tools engineering june 
control data dependence program transformations 
phd dissertation university illinois urbana il 
warren design fds interactive debugging system 
technical report rc ibm yorktown heights yorktown heights july 
debugging globally optimized programs data flow analysis 
proceedings acm sigplan conf 
programming languages design implementation pages june 
wu interactive source level debugging optimized code 
phd dissertation university illinois urbana champaign 
wu patil olsen hwu new framework debugging globally optimized code 
proceedings acm sigplan conf 
programming languages design implementation pages may 
zellweger interactive high level debugger control flow optimized programs 
proceedings acm sigsoft sigplan software engineering symposium high level debugging pages 
zellweger interactive source level debugging optimized programs 
phd dissertation university berkeley may 
published xerox parc technical report csl 

