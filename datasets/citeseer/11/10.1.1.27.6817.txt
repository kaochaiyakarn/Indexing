join calculus language distributed mobile programming fournet microsoft research georges gonthier inria rocquencourt applied semantics summer school september lecture notes give overview join calculus semantics proof techniques 
join calculus language models distributed mobile programming 
characterized formal notion locality strict adherence local synchronization direct embedding ml programing language 
local synchronization means travel set destination interact reach destination required ecient implementation 
join calculus ml function bindings pattern matching specify program synchronizations 
remarkable identities complex theory process equivalences admits remarkable simpli cation applied join calculus 
prove identities argue equivalences join calculus rationally organized tiered hierarchy 
illustrate mobility extensions core calculus allow programming agent creation migration 
brie calculus extended model distributed failures hand cryptographic protocols 
notes contain extensive tutorials jocaml system extension ocaml ml system join calculus model 
contents core join calculus concurrent functional programming 
synchronization pattern matching 
asynchronous core 
operational semantics 
re exive chemical machine 
basic equivalences may testing equivalence 
trace observation 
simulation coinduction 
bisimilarity equivalence 
bisimulation proof techniques 
hierarchy equivalences equivalences 
fair testing 
coupled simulations 
notions congruence 
summary hierarchy equivalences 
labeled semantics open syntax chemistry 
observational equivalences open terms 
weak labeled bisimulation 
asynchronous bisimulation 
discriminating power name comparison 
distribution mobility computing locations 
attaching meaning locations 
concurrent programming conventions 
basics 
modules 
join patterns 
control structures 
data structures 
word typing 
exceptions 
distributed programming distributed model 
locations mobility 
termination failures failure recovery 
lecture notes give overview join calculus emphasis operational semantics observational equivalences 
join calculus started attempt take models methods developped concurrency theory adapt apply programming systems distributed wide area network 
plan start milner pi calculus extend constructs locality mobility bring bear considerable body process calculi equivalences problem programming mobile agents :10.1.1.36.865
course obvious highly asynchronous nature wide area networks uncertainties available bandwidth latency possibility local failures suggested changing pi calculus ccs communication model 
idea model stick basic protocol suites decouple transmission synchronization synchronization issues resolved locally 
natural primitives doing higher order setting message passing function calling pattern matching suggested strong link programming language ml 
connection allowed reuse signi cant portion ml programming technology notably ml type system programming part project 
join calculus born synergy asynchronous process calculi ml 
ideas adapted source took new meaning highly asynchronous framework join calculus 
connection ml illuminates interaction functional imperative features implications typing 
highly chemical machine model yields operational re exive chemical machine instance join calculus 
intricate lattice equivalences synchronous asynchronous calculi simpli es remarkably pure asynchronous setting join calculus point concentrate single tiered hierarchy equivalences tier clearly argued 
lecture notes summary results rationale joins coherent 
section gradually introduce join calculus concurrent extension ml describe common synchronization patterns give chemical semantics 
section de ne motivate main notions observational equivalences illustrate main proof techniques establishing equivalences processes 
section re ne framework reasoning processes 
introduce intermediate notions equivalence account fairness gradual commitment organize equivalences hierarchy discriminative power 
section supplement framework labeled semantics discuss relation 
section nally re ne programming model account locality information agent migration 
appendix appendix consist extensive tutorials jocaml system 
jocaml latest implementations join calculus 
jocaml language extends ocaml sense ocaml programs modules just special kind jocaml programs modules 
tutorials largely practical counterparts theoretical material sections 
examples tutorials freshly ground compiled executed current release jocaml 
encourage reader try examples 
core join calculus join calculus designed process calculus distributed mobile computation turned close match ml impure functional programming 
notes connection motivate explain computational core calculus 
introduce primitives join calculus showing mesh typical mini ml calculus similar jocaml language appendix caml language 
show variety synchronization primitives easily encoded join calculus 
argue general join calculus encoded asynchronous fragment function calls just form message passing 
allow limit formal semantics join calculus asynchronous core 
conclude section exposing remarkably simple computational model underlies formal semantics join calculus model guarantees distributed computation faithfully represented join calculus 
concurrent functional programming starting point small ml syntax call value polyadic lambda calculus expressions variable function call local value de nition ex local recursive function de nition notation stands possibly empty comma separated tuple xn variables similarly tuple expressions 
casually assume usual hindley milner type system ensures functions called proper number arguments 
depart lambda calculus ml style function de nition primitive expressions trivially recovered def choice consistent usual ml programming practice allow integrate smoothly primitives side ects join calculus primitives provides syntactic place state function 
immediate bene values calculus consist names globally free variables de ned function names 
allows omit altogether curried function calls syntax function variable call replaced function name call value computation 
going join calculus extension functional calculus concurrency 
concurrency obviously entails doing computations parallel rst thing need add parallel composition launching computations parallel 
immediately realize expression expression denotes computation returns result natural way de ning unique result ad hoc ways see subsection 
need extend calculus second sort processes computations aren expected produce result don terminate 
fact operands processes 
want allow expressions launch processes processes compute expres sions minimal concurrency extension processes compute expression ex local recursive function de nition parallel composition inert process expressions run spawn process minimal syntax invoking abstraction process quite awkward involves computing expression calls function body execute run avoid add process abstraction construct mirror function abstraction construct di erent keyword def di erent call brackets enforce separation expressions processes 
processes ph ei execute process def process abstraction expressions def process abstraction operationally executing process really means computing parameters shipping value def new copy process body started 
term channel process de ned def message send process call ph ei 
calculus allows body function contain subprocess point view returning value computation just sending data away special channel extend calculus return primitive just 
messages carry tuple values return primitive gives notation returning values function just need extend bind tuple variables result tuple valued functions 
processes return return value function call compute expression expressions local de nition note tuple may empty functions perform side ects write matching statement omit part returns return closest lexically enclosing function 
return statements convenient write function bodies processes expressions 
extend def construct allow direct de nition functions processes 
processes def ex recursive function de nition expressions def ex recursive function de nition def ex equivalent ex run conversely ex equivalent def ex return preparation section take def form primitive treat ex form abbreviation def 
synchronization pattern matching despite formal elegance formalism developped far limited expressiveness 
allows generation concurrent computation provides means joining results computations having kind interaction matter 
spawned process completely oblivious environment 
stateful primitives proposed encapsulating inter process interaction concurrent variables semaphores message passing rendez vous futures monitors just name 
join calculus distinguishes basic ml programming pattern matching provide declarative means specifying interprocess synchronization leaving state inside processes belongs 
concretely done allowing joint de nition functions channels matching concurrent call message patterns nutshell allowing operator left 
de nition symbol 
syntax doing bit complex partly want allow multiple patterns create new categories de nitions join patterns 
processes def process function de nition expressions def process function de nition de nitions execution rule alternative de nitions empty de nition join patterns message send pattern ey function call pattern synchronization meaning joint de nition time messages concurrently sent channels process run parameters see statement depends somewhat multiple returns handled 
set contents messages respectively 
pattern may join results concurrent computations 
def def hxi hyi return hf hg sin cos example call starts processes compute value parallel send local channels respectively 
messages sent local def run return process returns pair caller 
function call pattern rule process body may contain return call functional core 
code asynchronous pi calculus channel follows def return pi calculus channel supports di erent operations sending receiving need join calculus names implement channel name sending function name receiving value 
meaning joint de nition call returns value sent xhi message 
note pi calculus term denotes primitive send operation channel gets encoded xhi sends message ordinary channel name join calculus 
primitive pi calculus reception process runs ug receiving single message gets encoded example bound value execution calls messages 
behaviour deterministic join calculus semantics ensure call grabs message message ful lls call def rule consumes join pattern specify available paired 
leftover calls messages simply wait messages call complete calculus order complete 
summarize running xh xh xh print print print leftover xh message print leftover xh message join calculus semantics allows possibilities 
hand xh xh print print xh message sent rst call completed 
higher order constructs encapsulate encoding single newchannel function 
def newchannel def receive return return send receive newchannel fairness assumptions implied usual process equivalences see section 
join calculus data structures encode channel objects tuple join calculus names implement operations 
jocaml probably return record 
kind higher order abstraction allows return names de ne object behaviour ones remain private 
especially common idiom keep state object single message function names methods 
state remains private trivial ensure exactly state message available 
example join calculus encoding shared variable object 
def newvar def put return get val hvi return return put get note state joined call run method easy ensure method runs time state message method returns 
classical monitor construct 
join calculus allows considerably exibility de nition synchronization behaviour objects 
natural di erent channel names denote di erent synchronization states object 
compare instance encoding place bu er shared variable 
def def put full hvi return get full hvi return return put get join calculus gives additional exibility describing synchronization behaviour object 
instance state may times divided concurrent asynchronous state messages method calls may joined messages 
short may petri net nite state machine describe behaviour 
example place bu er concurrent input output coded def def put hi hvi return hvi hi get hvi hi return val hv return put get note concurrent objects just programming idiom speci join 
instance get actors model methods asynchronous put methods code inside state state contains function processes method message returns function processing message 
def def mail hvi return mail synchronize calls model instance ccs synchronous channels note specify calls return statements return 
def def send receive return send return receive return send receive ada rendez vous modeled similarly case acceptor task sends message processing function result returned caller task 
def def call accept return call return accept return call accept ensures acceptor suspended rendez vous processing completed message processing function freely access acceptor imperative variables con ict 
accept ada statement modeled accept 
theory adding constructs imperative variable concurrent lambda calculus section gives formalism equivalent join calculus terms expressiveness 
advantages join pattern construct 
speci synchronization device taken primitive say place bu er devices coded terms primitive 
encodings usually abstracted functions available form abstraction 
means synchronization behaviour application relies non primitive devices hidden side ects functions 
contrary join calculus encodings explicit synchronization behaviour encoding devices 
join calculus gives general language writing synchronization devices devices just common idioms language 
easier turn type device kinds devices combine devices provide method rendez vous concurrent object 
join calculus syntax favors statically binding code synchronization event 
increases referential join calculus programs code easily lexical lookup functions channels involved event 
words code gives rst approximation happens corresponding functions called corresponding messages sent longer code better approximation 
noted devices static code short 
pi calculus asynchronous channel encoding probably worst case 
says value sent returned call properties channel inferred dynamic con guration program 
main motivation join calculus design join calculus synchronization performed locally 
contention messages calls resolved site holds joint de nition 
transmission messages calls returns hand cause contention 
see section property required calculus modeling distributed systems fortiori mobility 
property reason ccs pi calculus external choice operator absent list encodings device intrinsically creates non local contention join calculus encoding necessarily include cumbersome mechanism resolving contention see :10.1.1.36.865
point global choice rarely needed device join calculus provides versatile local choice form alternative rules 
note choice pi calculus enjoy locality property models monitors actors locality 
contention senders hand receivers hand misnomer course language synchronization side ects 
resolved simultaneously locally sender receiver site 
join calculus encoding introduces channel de nition site resolution take place 
asynchronous core spite simpli cations section syntax general join calculus large complex 
preferable carry simpli cations trying formulate precise operational semantics calculus 
particular semantics rendez vous type de nitions calls synchronized going painful describe formally 
standard trick operational semantics ev denote state computing expression function call ev 
neatly need new syntax states clearly run rendez vous calls ev need new syntax 
matter ll need new syntax case running process contains return primitives 
ll need special rules allow messages possibly de nition go inner processes 
fortunately avoid de ning function calls message protocol 
take literally analogy introduce return primitive implement return message send continuation channel 
function call implemented message carrying arguments continuation channel 
precise wiring continuations specify exactly evaluation order 
assume function name fresh channel name return continuation channel reuse function name call channel 
cps continuation passing style self reduction join calculus speci ed equations ex def join patterns en def vn en def fhv vn return en def vn en hv vn def def def def run def def pfu vg equations general assumption spurious variable captures names vn fresh names de ned bound free def equations 
expanded repeatedly de nitions translate alpha conversion full join calculus process equivalent asynchronous join calculus process involve function calls return run primitives 
addition choosing evaluation order translation assigns semantics multiple returns returns executed function call calling context executed times di erent return values 
feature may useful implementing say fail retry construct really compatible stack implementation function calls jocaml instance puts severe syntactic restrictions return statements 
processes asynchronous message def local de nition parallel composition inert process de nitions reaction rule composition void de nition join patterns message pattern synchronization syntax join calculus apply internal encodings remove complex features join calculus alternative de nitions way join patterns ary messages 
simpli cations really simplify operational semantics fact cases behaviour encoding signi cantly complex behaviour encoded term 
case cps encoding just simply providing asynchronous join calculus extra syntax called top section 
operational semantics asynchronous join calculus expressions variables altogether away expressions syntactic class 
remaining syntax summarized quite regular messages parallel composition processes patterns plus de nitions processes 
precise binding rules asynchronous join calculus similar ml rule hfx 
hfx binds variables fx xn variables tuple distinct tuples pairwise disjoint 
rule de nes channel names pn 
ii de nition def jn pn recursively binds pn channel names de ned jn pn denote rv set variables bound join pattern dv set channel names de ned de nition ii 
denote fv set free names variables process similarly fv denote set free variables de nition convention take dv fv 
formal equations rv dv fv fv 
eliminated synchronous primitives internal translation operational semantics needs de ne operations sending message channel name triggering de nition rule join pattern ful lled 
operation means moving message sending site de nition site 
operation quite trivial rst appear simple move con ict scoping rules join calculus message arguments locally de ned channel names def def lambda calculus problem solved combining sending triggering operations replacing xg 
solution join calculus general rule need messages sites trigger def hx def def hqi solution rst discovered pi calculus lies doing things way moving contents outer de nition inside inner extend scope argument de nition include message channel 
operation called scope extrusion 
fairly complex operation involves doing preliminary alpha conversion avoid name captures moving full de nition messages associated 
contrast trigger operation means selecting particular rule assembling group messages match rule join pattern simply replacing appropriate instance arguments substituted parameters rv rule 
simpler operation real computational contents core join calculus distributed join calculus moving message sites impact computation subtle ways see section 
operation rearranges order subterms way preserves bindings 
selecting assembling steps operation viewed similar rearrangements 
note rearrangements take place guarded subterms subterms process appears right hand side de nition rule denote structural equivalence relation alpha conversion rearrangement unguarded subterms preserve bindings entire operational semantics join calculus expressed single rule def def maps variables rv channel names second premise replaced necessary shift messages de nitions trigger step 
gives additional exibility writing transition sequences allows keep syntactic shape term undoing rule selection steps moving back process original place triggering messages 
relation easily axiomatized equivalence relation alpha equivalent alpha equivalent def def def def def provided dv fv def def def provided dv fv re exive chemical machine operational semantics just described may technically sound convenient manipulate quite give intuitively satisfying account execution join calculus processes 
reason order simplify exposition lumped hidden trivial rearrangements equivalence number operations occur real implementation 
programmed parallelism operator turned actual parallelism multiple kernel virtual machine threads 
join calculus thread terminate null process message send 

alpha conversions required scope extrusion implemented dynamically allocating new name local de nition 

selection de nition containing rule triggered done thread scheduling 

selection actual rule de nition done nite state automaton tracks set names messages arrived 
automaton enables scheduling de nition 
messages routed de nition sorted name queued 
concern implementation issue hidden resolved 
instance asynchronous pi calculus equivalence semantics similar join calculus 
single reduction rule unguarded contexts xhevi ey seen section despite similarities join calculus semantics possess important locality property implemented global synchronization 
term operational semantics masks fact essence describe global computation steps 
section address issue exhibiting computational model join calculus call re exive chemical machine rcham 
model address issues directly resort structural denotational equivalence issues implementation dependent described convincingly high level model issue require model thread scheduling issue require model data structures organize threads issue meaningless 
show structural properties rcham ensure properly resolved actual implementation 
state rcham tracks various threads execute join calculus program 
apparent discussion rcham contain kinds threads process threads create new channels sending messages represented join calculus process terms de nition threads monitor queued messages trigger rules represented join calculus de nition terms specify data structures organize terms just rcham state consist pair multisets de nition threads process threads 
de nition chemical solutions chemical solution pair multiset dm jg join calculus de nitions multiset fjp pn jg join calculus processes 
intrinsic reordering multiset elements structural equivalence need deal issues 
operational semantics rcham de ned reordering 
rcham derives name close parallel operational semantics reaction rules molecular chemistry 
elegant chemical metaphor rst coined carried quite far message atom channel name valence 
parallel composition 
mn atoms simple molecule process complex molecule 
de nition rule reaction rule speci es simple molecule may react turn new complex molecule 
rule speci es reaction pattern solely reaction molecule 
course virtual world conservation mass may arbitrarily large small 
multisets composing rcham state chemical solutions multiset reordering brownian motion 
rcham re exive state contains solution molecules interact multiset rules de ne interaction furthermore multiset dynamically extended new rules new rules set inspected changed extended 
computation rcham compactly speci ed rules 
convention rule computation step shows processes involved step rest solution remains unchanged implicit 
rule str def bit exception side condition formally means dv fv fv global state rcham 
ways local operation address space random number speci implementation rcham 
de nes di erent kinds computation steps str null str par str top str str def def react side conditions str def substitutes distinct fresh names dv react substitutes names rv 
re exive chemical machine rcham reduction steps describe actual chemical interaction correspond join calculus reduction steps heating steps describe molecules interact solution correspond part join calculus structural equivalence 
heating reversible converse steps called cooling steps str rules de ne kinds steps symbol 
direct correspondence scope extrusion obviously linked str def commutativity associativity parallel composition consequence multiset reordering 
structural equivalence heating rules direct operational interpretation str par str null correspond forking process threads issue 
str def corresponds allocating new address de nition issue forking new de nition thread 
str str top correspond entering rules synchronization automaton de nition issue part 
exception cooling steps similar operational interpretation tie back rcham computation join calculus 
exception str par steps aggregate simple molecules appear join pattern str par steps model queuing sorting performed synchronization automaton de nition pattern appears issue part 
denote steps join 
observations connection direct join calculus operational semantics supported theorem re exive transitive relation denoted usual 
theorem join calculus processes rcham solutions respectively 
ii iii iv join corollary 
pn join calculus computation sequence exist chemical solutions sn join join join sn examine issues deliberately abstracted 
rcham chams general assumes atoms interact brought random motion 
ne theory real implementation chance 
rcham theorem rcham computation relies magical mixing join react steps 
cases show magic needs invoked join steps brings atoms routed de nition valence match nite number join patterns de nition 
react simply selects matching nite set completed matches assembled de nition 
synchronization decisions de nition nite xed set compiled nite state automaton see extensive discussion implementation issue 
keep chemical metaphor de nitions enzymes biochemistry enable reactions sparse solution providing xed reaction site reactants assemble 
interesting note pi calculus cham aspects similar rcham fails locality property exactly count relies solely multiset reordering assemble senders receivers channel 
basic equivalences far join calculus calculus name 
argued faithful elegant model concurrent programming 
true calculus implies ability equational reasoning calculate 
achieve equip join calculus proper notion equality join calculus expressions model concurrent programs equality form program equivalence 
unfortunately nding right equivalence concurrent programs tall order 
programs equivalent exactly properties particular possible replace system ecting system behaviour visible way 

conversely equivalent possible exhibit system replacing results perceivable change behaviour 

equivalence technically tractable need standard complete proof techniques establishing identities 

equivalence generate rich set identities won calculate 
expect counterpart lambda calculus beta equivalence 
unfortunately goals contradictory 
taken goal force syntactic equality certainly fails goal 
compromise 
give top priority goal wouldn sense calculus equations 
goal priority calculus requires inordinate amount orts establish basic identities wouldn useful 
furthermore interesting program equivalences proven equational reasoning reasonable set identities important reasoning rst principles tractable 
goal comes third position means compromise soundness 
consider equivalences preserve observable properties certain level abstraction 
common examples abstractions sequential programs observing runtime constant factor 
complexity observing runtime termination observing return values partial correctness 
obviously carefully spell set properties preserved determines equations calculus extent calculus 
comes priority list neglect goal 
abstractions involves correctness proof formal model provides relative guarantee 
proof useful fails allows nd errors system 
goal sure failures traced actual errors odd technical property equivalence 
reason goal comes proof process tractable rst place debugging approach sense 
priorities set absolute sense consider equivalences strike di erent compromises goals 
study subsections may testing optimizes goals expense goals bisimilarity equivalence simplify bisimilarity ces goal get better balance goals 
may testing fact coarser bisimilarity practice attempt prove bisimilarity case failure degrade may testing try get counterexample 
sections study equivalences complete hierarchy summarized 
may testing equivalence rst equivalence consider follows rigidly priorities set coarsest equivalence preserves observations turns proof techniques subsections 
see may testing ful lls goal failure may testing equivalence materialized nite counter example trace 
may testing equivalence preserves properties described terms nite number interactions message exchanges case join calculus known safety properties 
restriction may severe follows directly choice syntax semantics join calculus 
noted section deliberately chose away scheduling algorithm 
absence hypothesis scheduling practice impossible decide complexity termination progress properties 
liveness properties just abstractions timing properties system really needs satisfy timing properties fairly reliably obtained experimentally clear successful proof identify features system point simpli cations safely 
actual implementation 
sense exclude liveness properties reconsider decision scheduling assumptions 
testing may testing refers way safety properties characterized formal de nition may testing equivalence 
represent safety property test 
process succeeds 
equivalent test succeeds succeeds 
formal need formal syntax tests formal semantics succeeds 
restricted properties described terms nite message exchanges certainly carried join calculus programs contexts 
join calculus contains lambda calculus boldly invoke church thesis assume test 
represented pair 
join calculus execution context channel name 
uses signal success succeeds may send xh 
message 
evaluation contexts evaluation contexts simply join calculus process terms hole 
inside de nition guarded called static context 
obey grammar 
evaluation contexts 
hole 
left parallel composition 
right parallel composition def 
process function de nition formally context hole sorted set captured names 
process process obtained replacing hole 
alpha converting bound names 
clash fv 
contains channel names example bound channel names 
free channel names means replacing 
conversion whatsoever 
drop subscript common case 
structural equivalence reduction relations extended contexts 
sort proviso alpha conversion names 
allowed 
substitution relation similarly extended contexts 
context type convention allow write reduction identity hole preserved fact 

similarly really means suitably large evaluation contexts special case program contexts 
simply process terms possibly guarded hole 
equivalence relation implies program context 
called congruence preorder called precongruence 
congruence describe equations subprograms 
equivalences congruences evaluation contexts means describe equations subsystems fact congruences exception occurs extension join calculus name testing 
output observation success test signaled output speci message event de ned syntactically 
de nition output predicates join calculus process channel name 
xhevi tuple names evaluation context 
capture 
ii predicate tests syntactically immediate output called strong barb weak barb predicate tests possibility output 
strong barb de ned structural equivalence def xhevi ev dv 
say relation preserves barbs implies structural equivalence preserves barbs 
may testing preceding de nitions de nition may testing straightforward 
de nition may testing preorder equivalence join calculus processes may execution context 
channel name implies 
may execution context 
channel name preorder may called may testing preorder equivalence may called may testing equivalence 
may testing preorder may indicates behaviours included formalize implements 
obviously may may may largest symmetric subrelation may easy example may testing note structural equivalence implies may testing equivalence implies preserves barbs 
token note drop sorts de nition may 

test property 

consider contexts alpha needed substitute rst non trivial example show simple case beta conversion def may def pf test 
de ne 
def def 
fx ug 
need show obvious 
general may converse suppose reduction involve message including pf de nition uses proof carried appears general context notion general context reduction section 
gives strong beta equivalence def def may def ef hvi may def ef rf def ef may ef obviously def may trace observation de ned may testing terms evaluation contexts barbs allowed stay close possible intuitive description exhibit compliance goals 
style de nition really suit goals 
general proving may quite intricate involves reasoning arbitrary long reduction arbitrarily large context 
double quanti cation may issue showing simple general reduction laws quickly unmanageable wants show say correctness nite state protocol 
precludes automated model checking tools 
may fails tester 
witnesses failure 
existence 
partly ful lls goal illustrates problem programs indirectly means third unrelated program 
de nition may gives clue deriving witness failing proof attempt 
section alternative characterization may may mitigates proof problem largely solves counter example problem 
characterization formalizes fact stated informally may preserves properties nite interaction sequences 
formalize sequences traces de ne trace set process show may corresponds inclusion trace sets may equality 
informally trace simply input output sequence account higher order nature join calculus de nition involved 
de nition traces trace nite sequence jn mn trace element def single message hy join pattern 
ii set distinct pattern variables rv pairwise disjoint disjoint set jk distinct 
iii channel name de ned jk particular 
dually jk rv set fy jk rst part condition iii stated dv 
intuitively element trace correspond reduction behaves roughly join de nition reduction input output names rv formally bound trace 
matching process run rv names substituted fresh names jk arguments actual outputs 
de nition trace sets trace jn mn allowed process notation substitution maps names rv distinct names fv names channel names sequence 
evaluation contexts sort note convention set notation implies identity hole preserved reduction 
trace set tr set allowed traces 
tr ft tg main motivation complex set de nitions result theorem trace equivalence processes may tr tr consequently may tr tr 
theorem allows reach goal may fails nite input output trace allowed barred principle look trace enumerating traces search turned proof technique may involve trying arbitrary large contexts may amenable model checking 
note technique involves arbitrary long traces sense fails meet goal 
example technique prove correctness compilation way join way joins def xhi yhi thi thi zhi zi may def xhi yhi zhi zi terms trace start zi consist outputs inputs xhi yhi zhi 
case jn terms exactly set traces 
simulation coinduction respects improvement basic de nition trace sets really help constitutes real diculty may proofs quanti cation arbitrary long reduction sequences hidden de nition barbs shape term changes reduction step hard reason ect successive reduction steps 
kind hand argument rst examples turn incorrect complex cases 
rigorous equivalence proof necessary analyse reduction steps case time 
calculi analysis structural induction syntax join calculus inappropriate structural equivalence 
base analysis triggered rule set messages match pattern invariant structural equivalence 
section characterization may testing time appropriate step step analysis 
avoid complexity higherorder traces revert modeling interaction arbitrary evaluation contexts 
note barely add complexity proof interaction highly stylized theorem shows 
formulate new characterization turn technique coinductive de nition concurrent program equivalences 
simply means invoke tarski theorem de ne equivalence greatest xed point monotonic functional beauty de nition immediately gives generic method proving nd sub xpoint relation implies get monotonic rely de nitions form appears positive subformulas 
case relation sub xpoint implies property denote 

distributes conjunction generally de ne equivalences conjunction properties coarsest relation 
fact encountered 
barb preservation implies 

congruence evaluation contexts 


symmetry 
observation get rst coinductive de nition may greatest symmetric relation preserves barbs congruence evaluation contexts 
note property really means contained xed relation case barb inclusion relation de ned implies 
rst characterization may merely rephrase de nition 
improve prove extremely convenient introduce diagrammatic notation 
describe property lay relations occuring dimensional diagram 
indicate negatively occuring universally quanti ed relations solid lines positively occuring existentially quanti ed relations dashed lines 
instance property expressed diagram cs cs main property interested commutation reduction relation called simulation 
de nition simulation relation join calculus terms simulation term diagram note call simulation called weak simulation simulation relation commutes single step reductions 
counting steps sense asynchronous setting join calculus simply drop weak adjective rest notes 
say relation preserves immediate barbs implies simulation property replace barb preservation immediate barb preservation coinductive characterization may theorem may testing preorder simulation greatest simulation evaluation context precongruence preserves immediate barbs 
improvement consider immediate barbs necessary consider reduction steps 
appear pushed problem simulation property case simple tiling argument theorem relation simulation allows study reductions structural equivalence 
illustrate power new characterization show theorem may testing preorder precongruence may testing equivalence full congruence 
lemma lemma typed tuple distinct variables matches arity def xhevi may pf may may closed substitution 
lemma holds typing assumption involved proof 
just take relation consisting pairs processes structurally equivalent def xhevi pf satisfying hypotheses lemma 
obviously congruence evaluation contexts 
trivially preserves strong barbs 
pf def xhevi show simulation consider reduction def xhevi def xhevi rule xhevi pf pf conversely pf rst case rule matches ys replaced xs 
xhevi ect substitutions bring back rst case 
may deduce lemma 
establish theorem need careful de nition multi general context 
general context 
sort term may contain holes 
substitution domain di erent holes may di erent bindings alpha conversion structural equivalence reduction extended general contexts fv 

term obtained replacing hole 
alpha converting bound names avoid capturing names fv consider candidate relation may may rg 
trivially closed evaluation contexts 
barb simulation properties consider case unguarded holes 

obtained replacing unguarded holes 

similarly 
replacing 

may applications lemma may may consider pair 
xh 

similarly reduction step take place 
step 

may simulation may bisimilarity equivalence despite success proofs lemma theorem general coinductive approach allow avoid reasoning arbitrarily long traces 
simply hiding asymmetry simulation condition 
condition allows prove may candidate relation simulation may course proving simulation easier proving may requires reasoning sequence really attain goal need di erent equivalence 
fundamental reason ed may passes goal restrictive notion soundness ignoring sort liveness properties 
label correct programs grossly erroneous 
example de ne join calculus internal choice process di erent processes def hi hi write may equation states program randomly decides equivalent works 
example error obvious may testing similarly ignores large class quite subtle malign errors called deadlock errors 
deadlocks occur subset components system working altogether waiting input proceeding 
type error easy commit hard detect testing catastrophic consequences 
nondeterministic sequential system problem dealt complementing may testing testing adds predicate barbs def 
testing interesting asynchronous concurrent computations inasmuch confuses diverging behaviors 
refer detailed study may testing join calculus 
turns simple technical solution problems willing compromise goal simply require symmetry simulation 
de nition bisimulation simulation converse simulation 
coarsest bisimulation respects immediate barbs congruence evaluation context called bisimilarity equivalence denoted 
confusion arises simply refer bisimilarity 
de nition bisimilarity avoids dummy simulation candidates simulation implies advance lockstep making exactly choices time 
erroneous nil avoided similar way 
equation hold program may 
fact show section strong assumption scheduling fairness preserves liveness properties meet goal fairly 
classes errors entirely notably livelocks situations components endlessly sending useless messages producing useful output 
detect livelocks components send useless messages cases randomized scheduling usually avoid deadlocks 
unfortunately previously perfect situation respect goals compromised 
example equations seen far valid way way join compilation fails check allow messages argument 
way join emulate decision way merger group values deciding go 
compilation correct preserve liveness properties fails technical reasons failure 
bisimulation proof techniques basic de nition bisimulation give rough idea prove bisimilarity equation 
number established techniques showing bisimilarity notably deal contexts abd captures close large diagrams 
consider problem quantifying arbitrary contexts 
section extension join calculus new equivalence avoid need consider arbitrary contexts altogether 
time show really issue 
suppose want show candidate relation terms 
soon starts exchanging messages 

intermingled 
structural equivalence decompose 
clear situation intricate take 
def dc mc 
def dp mp def dq mq mc mp mq simple molecules bound names fresh dc may de ne free names notations see elements shape def dc dp mc mp def dc dq mc mq allow extrusions 
simply allow dc mc contain channel names exported de ned dp dq may require applying di erent substitutions dc mc account di erent names clear setting reduction step analysis especially complicated presence arbitrary context 
classify reduction steps categories 
reductions unknown rule dc unknown messages mc 
reductions unknown rule dc messages mp 
reductions known rule dp unknown messages mc 
reductions known rule dp known messages mp rst cases easy syntactically similar reduction performed right hand term 
second case messages mp matched messages mq possibly internal computation known rules dq known messages mq cases may harder need match reduction precisely 
case exact number valence unknown messages determined known rule messages messages similarly available note cases correspond directly output input internal steps trace labeled semantics 
extra required arbitrary contexts amounts generic placeholders dc mc description candidate bisimulation extra trivial case 
furthermore simplify relation hiding parts common dp dq mp mq inside dc mc respectively 
equivalent context labeled bisimulation technique 
nal proof technique evaluation context congruence relation shape contain alpha variants def dp mp def dq mq avoid clashes components new context 
added 
easily handled completing pairs injective renamings 
reduction diagrams established hold extended renamings avoid name clashes 
fact renamings reserve set private bound names dp dq de nitions 
second technique explore facilitates diagram proof part possible meet bisimulation requirement smaller relation 
general idea equational reasoning close diagrams proof theorem 
unfortunately unrestricted simulation diagrams unsound def xhi yhi xhi consider singleton relation def xhi yhi yhi analog lemma 
simulation preserves immediate barbs 
preserve barbs certainly simulation 
allow measure equational reasoning de ne restrictive notion simulation :10.1.1.36.865
notion really valid semantic interpretation step counting convenient technical expedient allows important equations inside simulation diagrams important beta reduction 
de nition tight simulations relation tight simulation means de nition expansion expansion simulation converse called compression tight simulation 
coarsest expansion denoted 
tight bisimulation tight bisimulation converse tight bisimulation 
coarsest tight bisimulation denoted 
technical de nitions nd diagrams theorem simulations relation tight simulation relation expansion relation bisimulation equations established may fact valid compressions close diagrams 
particular beta reduction compression 
theorem compression 
general context capture names free ffg fv ex eu ex ef hierarchy equivalences section develop framework proving properties programs written join calculus 
provide useful intermediate equivalences barbed equivalence 
give ner labeled semantics purely inductive proofs equivalence 
discuss trade di erent de nitions equivalences 
section gure summarizes results hierarchy equivalences ordered inclusion 
developments speci join calculus 
applied calculus small step reduction semantics notion observables 
fact versatility semantics provides convenient tools considering new calculi variants existing calculi 
equivalences 
concurrency theory diversity calculi equivalences 
refer instance glabbeek classi cation weak equivalences 
restricted setting asynchronous concurrent programs natural choices de nition process equivalence choices record previous works exclusively rely resulting equivalence 
order choose variant adapted problem hand need understand signi cance choices 
example di erent styles de nition may yield equivalence provide di erent proof techniques 
conversely slight changes de nition may strongly ect resulting equivalence invalidate expected properties 
introducing useful variants equivalence underlying choices 
context closures discussed previous section may interested classes context 
evaluation contexts easy interpret testing scenario general properties may useful lemmas strong reductions 
technically main di erence di erent free variables appear guard may instantiated name 
join calculus inessential relays name ect case extensions join calculus section 
conversely may convenient consider smaller classes contexts establish context closure 
instance may constrain names appear context considering contexts chosen free variables contexts local names clash processes hand contexts single de nition 
write congruence relation 
usual equivalences congruences plain relation symbols 
dotted relation symbols non congruence sibling relations 
consider congruence contexts referred full congruence 
basic observations notion basic observation largely arbitrary 
far distinct predicate name tests presence message sent name natural choices 
consider common alternatives 
fortunately details observation irrelevant considering relations closed application evaluation contexts 
separate processes way reasonable notion observation expressible particular contexts observe evolve processes observation 
existential barbs initial barbed equivalences definitions testing equivalences single predicate indexed family :10.1.1.36.865:10.1.1.36.865
single observable action written single existential predicate collectively tests presence message free name 
accordingly family predicates de ne existential predicate def obtain existential variants observation equivalence 
instance may largest relation closed application evaluation contexts re nes suggested existential equivalences coincide basic equivalence context closed 
instance speci cally detect testing context restricts free names may may consider equivalences existential variant weaker 
transient barbs join calculus strong barbs appear messages free names names meant de ned context 
due locality property barbs preserved reduction 
usually case process calculi ccs pi calculus messages free names disappear result internal reduction 
instance reduction xhi erases barb transient barbs may harder interpret terms observation scenarios complicate hierarchy equivalence see 
enforce barbs derived committed predicate def predicate de nition 
rely congruence property available turn transient barbs permanent ones 
pi calculus instance def process fresh relations internal states far considered pure testing semantics may ner semantics requires exact correspondence internal states 
appearance bisimulation raises questions get coarser correspondence internal states 
suitable cases asynchronous algorithms typically series local messages simulate atomic distributed state transition 
messages received independently gradual commitment state transition introduces transient states rules bisimulations 
section explain retain bene ts coinductive de nitions cases 
correspondence depend context 
previous section de ned largest barb preserving bisimulation closed application evaluation contexts 
equivalence chosen calculus join calculus 
traditional de nition ccs pi calculus :10.1.1.36.865:10.1.1.36.865
de ne largest barbed bisimulation written take largest subrelation closed application evaluation contexts written 
opinion original stage de nition drawbacks bare bisimulation sensitive choice observation predicates correspondence internal states may depend context 
diagrams detail situation context applied left stable relation bisimulation congruence 
conversely bisimulation congruence relation right retains congruence property matching reductions allows repeated application contexts reductions 
coarser alternative de nitions obtain simple inclusion conversely far obvious inclusion holds bisimulation 
section sketch proof join calculus 
conversely show case simple variants 
de nitions yield equivalence induce distinct proof techniques 
experience leads simpler proofs interaction context reduction context may change remains class considered candidate bisimulation congruence 
fair testing ready re ne de nition testing equivalences 
seen may testing useful guaranteeing safety properties guarantee useful happens re ected equation may fair testing strengthen predicate incorporate notion fairness 
fair predicate detects process retains possibility emitting def fair predicate tests permanent weak barbs 
processes test implies conversely reductions deterministic coincide nite computation coincide 
predicate induces equivalence named fair testing de ned largest congruence respects fair predicates fair def ranges evaluation contexts 
similar de nitions appear 
instance xhi xhi fair xhi xhi fair xhi xhi fair 
particular notion fairness embedded fair testing deserves explanations may fair predicates state existence reductions leading particular message don provide reduction strategy 
interpret successful observation eventually emits message xhi 
consider nite traces emit disregard nite trace 
intuitively model set barbs nite nite fair traces strong notion fairness 
example fair testing equivalence def thi xhi thi thi thi fair xhi rst process provides alternatives de nition message xhi emitted message thi re emitted reverts process initial state 
possible select second stuttering branch alternative nite computations emit xhi 
possibility emitting remains fair evaluation strategy eventually select rst branch 
fair testing versus may testing fair testing may unrelated may testing strictly ner fair may 
relations di erent seen xhi xhi 
said fair testing largest congruence relation re nes may fair predicates 
congruence property non deterministic contexts form def def zhi def xhi establish property fair testing holds ccs pi calculus actors similar equivalence proposed main semantics 
regards discriminating power fair testing appealing equivalence distributed systems stronger may testing detects deadlocks remains insensitive termination livelocks 
note fairness departs liveness properties typically guaranteed implementations cf 
restrictive scheduling policy jocaml 
fair testing su ers drawback direct inductive proofs dicult nested quanti ers de nition fair tests context 
see section feature fair testing coarser bisimilarity equivalence fair 
equations interest established inductive manner interpreted terms may fair testing scenarios 
precisely going establish tighter characterization fair testing terms coupled simulations 
coupled simulations relation fair testing bisimulations initially studied ccs instance authors introduce notion fair testing testing terminology weak bisimulation equivalences incorporates particular notion fairness identify problem gradual commitment general sensitivity branching structure undesirable property bisimulation nally establish observational equivalence ner fair testing propose simulation sucient condition establish fair testing 
independently coupled simulations proposed address similar issues coarse simulation equivalence require exact correspondence internal choices abstracts branching structure induced bisimulation :10.1.1.36.865
setting barbed counterpart weakly coupled simulations sensitive divergence :10.1.1.36.865
similar equivalence appears asynchronous pi calculus establish correctness encoding choice operator :10.1.1.36.865
de nition pair relations barbed coupled simulations simulations respect barbs satisfy coupling conditions 
relation barbed coupled equivalence coupled simulations 
relation union barbed coupled equivalence 
relation union barbed coupled equivalences obtained context closed simulations 
de nition stated readable manner diagrams simulation coupling requirements sim cpl sim cpl special case coupling diagrams trivially veri ed fact barbed bisimulation particular immediately obtain 
typically discrepancy describe processes transient state bisimilar initial state nal state 
instance derived operator internal choice diagram precise relation fair testing coupled simulations intriguing 
equivalences applied problems typically study distributed protocols high level atomic steps implemented negotiation distributed components steps perform gradual commitment 
de nitions di erent advantages fair testing arguably natural coupled simulations coupled simulations established induction 
hard establish barbed coupled simulations re ne fair barbs 
proof uses simulations directions re ects alternation quanti ers de nition fair barbs 
lemma barbed coupled simulations 
proof reductions simulated coupling condition de nition respects weak barbs case weak bisimulation add precongruence requirements de nition barbed coupled simulations obtain barbed coupled simulations congruence take largest congruence contained barbed coupled similarity written 
de nition previous lemma inclusions fair turns congruence relation coupled simulation strictly ner di erence appears soon internal choices spawned visible actions 
counter example especially simple asynchronous ccs invite reader check processes outcome internal choice visible communication choice immediately performed left context applied know context provide message case simulate step getting message communicating reducing right 
simulate step doing processes inert 
contrast reduction occurs left context chosen simulate right uniform manner 
similar counter example holds join calculus 
theorem summarizes relation fair testing barbed coupled similarities theorem fair 
conclude section proof inclusion fair develop semantic model coupled simulations 
rst consider family processes behavior especially simple 
say process committed internal reduction may visibly ect set names fx fx committed sense converged determines behavior 
process associate semantics collects sets names committed derivatives def fx fx example singleton xhi yhi pair fxg fyg case weak barbs decreases reduction :10.1.1.36.865
predicates recovered follows preorder de ned def de nition may testing fair testing preorders immediately obtain may fair preorders coincide 
lemma fair proof nite sets names de ne context def def thi xhi nns xhi thi show fair tests exactly set names semantics fv rst clauses de nition compete single message may triggered 
rst clause thi immediately triggered second clause preempt reduction consuming message name third clause detects presence message name ns 
predicate holds derivatives keep possibilities emit message thi don messages names produce message name outside fair fv fv establish set names entails set names may contain anyway 
fair context closure fair testing fair converse inclusion follows characterization fair barbs fair useful relate proof process consider series processes fx strictly increases series length series bounded number names free series maximal pre inclusion 
conclude maximal series processes fx establish semantics re nes barbed coupled similarity 
lemma coupled barbed simulations 
proof successively check preserves barbs simulation meets coupling diagram 
assume 
barbs recovered semantics implies 
weak simulation trivially holds de nition decreases reductions stable singleton reduction reductions simulated absence reduction 
empty hypothesis process fsg provides coupling condition composing lemmas obtain fair satisfying coinductive characterization fair testing congruences single barbed bisimilarity coupled barbed similarities associated proof delicate 
pragmatically proof technique associated stronger relation convenient available 
notions congruence nally resume comparison relations dependence de nition 
study bisimulations weaker obtained considering nite number observation predicates 
single barbed bisimilarity largest weak bisimulation re nes barb detects ability send message free name 
equivalence partitions join calculus processes classes characterized predicates 
congruence single barbed bisimilarity just fair testing equivalence fair contrast congruences weak bisimulations 
existential contexts check preserves nominal barbs preserves existential barbs 
establishes 
obtain pair distinct bisimulation congruences big di erence observation predicates turns predicates nite number weaker notion bisimulation congruence 
nullary names write bisimilarity re nes strange notion essential prove precisely going establish theorem clearly obtain corollary 
rst build family processes equivalent retain property reduction 
informally show nitely ways hesitate messages branching semantics 
de ne operator maps nite set processes set strict partial internal sums def jp lemma weak bisimulation set processes relation implies set retains property 
set collects iterated results contains processes related proof rst show summands summand bisimulation deduce 
processes summand bisimulation fact violate summand fact imply contradict 
symmetry summand summand show 
induction violates 
direct consequence bisimilarity separates numerous processes nite behavior 
build nite set processes follows def xhi yhi pn def pn 
def pn size layer pn grows exponentially 

contains nitely processes related pn pn pn fpg construction rank series reduction matched series reductions starting construction captures processes nite behaviors bisimilarity classes exhibited classes processes reach nite number classes 
note construction applies single barb bisimilarity starting set obtain third unrelated process xhi rank construction stops 
lemma states process ectively communicate integer environment exclusive barbs discriminating power bisimulation 
rely encodings booleans integers la church inside join calculus 
integer associate representation assume integers come operations integer associate particular equivalence class hierarchy processes 
write process receives integer conveys integer evolving characteristic class 
intuitively context transforms integer indexed barbs int regular name join calculus barbs lemma evaluation context integers statements equivalent 


establish lemma program evaluation context follows locate derivatives hierarchy processes def def def zi zhi yi xi def zhi zi xi yi name encode process processes symmetric permutations names represent 
integer associated ternary sum nested binary sums layer encoded integer received reduction triggers de nition int yields initial ternary sum time reduction consumes single message de nition int inert 
lemma uses result restrict class contexts considered congruence properties contexts free nullary variables 
lemma nite set names 
evaluation context processes free variables 
order establish bisimulation need retain congruence property matching reduction steps 
apply context applying bisimulation hypothesis single context able emulate behaviour context selected reductions 
call context universal context 
details construction appear 
rst step de ne integer representation process written build interpreter takes integer representation encoding evaluation environment binds free names fv 
lemma relates source process interpreted representation result surprising inasmuch join calculus expressive power 
care required restrict types may appear interface 
lemma established ner labeled bisimulation de ned section 
omit details encoding interpreter 
lemma nite set types closed decomposition 
de nition process free variables typed fv fe environment fv def eh second step reduce quanti cation contexts rst quanti cation processes speci context forwards messages quanti cation integers substituting interpreter process 
universal context uses internal choice select integer manifest choice integer barbs run interpreter input environment manifests barb integer barbs 
stage disappearance speci integer barbs allows bisimulation keep track behavior context 
lemma universal context nite set names evaluation context processes fv fv implies combining encodings eventually obtain controversial bisimulation property nally 
summary hierarchy equivalences anticipating labeled semantics section summarize results equivalences 
tier hierarchy correspond notion equivalence ner lower tiers 
stating proving equational properties setting hierarchy provides guidance 
instance proof may involve lemmas expressed equivalences ner easier establish labeled comparison names bisimilarity equivalence internal choice visible actions coupled barbed congruence internal choice interleaved visible actions fair testing fair fairness may testing may hierarchy equivalences join calculus nal result 
conversely counter example may easier exhibit tier lower required 
reader may interested applications techniques establish challenging equations scope notes 
refer detailed proof security distributed cryptographic implementation join calculus series fully encodings variants join calculus correctness proof implementation ambients jocaml coupled simulations 
labeled semantics labeled transition systems traditionally provide ne semantics process calculi 
seen auxiliary semantics reduction calculus er advantages purely inductive proofs models synchronization trees 
hand speci calculus hand may turn discriminative asynchronous programming 
variants labeled semantics join calculus relate notions labeled observational equivalence comparing discriminative power contexts labels 
refer detailed presentation 
open syntax chemistry introduce re ned semantics open rcham explicit interactions environment 
interactions environment receive ned names process emitted free names environment emit messages names 
call interactions extrusions intrusions respectively 
keep track de ned names visible environment de nitions join calculus marked extruded names extrusions open processes plain process defs open de nition parallel composition syntax open join calculus occur 
turn intrusions allowed names marked extruded 
re ned syntax join calculus processes form defs set names de ned extruded environment 
informally extruded names represent constants input interface process 
rst example consider process def xhi yhi 
interface contains extruded name free names message consumed environment exporting def xhi yhi def fxg xhi yhi known environment considered local anymore environment emit free environment modify extend de nition 
new transition enabled def fxg xhi yhi xhi def fxg xhi yhi xhi process input messages perform transitions consume message emit message def fxg xhi yhi xhi def fxg xhi yhi yhi def fxg xhi yhi extend rcham extrusions intrusions explicit bookkeeping extruded names 
de nition open chemical solutions ranged triples written multiset de nitions subset names de ned multiset open processes disjoint sets extruded names de ned interface open solution consists disjoint sets free names fv extruded names xv de ned table 
functions dv 
fv 
xv 
extended multisets terms unions terms multisets 
chemical rules open rcham de ne families transitions open solutions ranges labels form xhevi 
structural rules rule react unchanged apply open solutions 
rule str def performs bookkeeping exported names enforces lexical scoping discipline scope extrusion name exported 
applied open solutions structural rules capture intended meaning extruded names messages sent extruded names moved inside outside de ning process 
instance structural rearrangement xhevi defs defs xhevi join patterns rv xhevi fu vg dv xhevi fxg rv rv rv dv dv dv de nitions dv dv fv dv fv dv dv dv fv fv fv processes fv fv fv xv xv fv xv xv xv xv fv def ina fv fv dv xv fv xhevi fx xv defs ina xv xv xhevi chemical solutions fv fv fv dv xv xv xv scopes open join calculus str null str par str top str str def defs react ext int fxg fxg side conditions reacting solution str def substitutes distinct fresh names dv react substitutes names rv ext name free dv int names free fresh extruded 
open rcham extruded name long names captured dv 
addition rules ext int model interaction context 
rule ext messages emitted free names received environment messages export de ned name previously known environment causing scope de nition opened 
explicit set label transition xhevi 
names distinct name appears interface transition names extruded converted anymore behave constants 
rule resembles open rule restriction pi calculus important constraint due locality messages emitted free names consumed ext names de ned open solution consumed react :10.1.1.36.865
rule int enables intrusion messages exported names names 
viewed disciplined version input rules proposed honda tokoro asynchronous pi calculus enables intrusion message 
side condition int requires messages clash local names processes 
implicitly may rely silent conversion local names original meaning intrusion :10.1.1.36.865:10.1.1.36.865
observational equivalences open terms notions reduction equivalence de ned sections easily extended open processes de nitions additional requirement related processes exported names 
little sense compare processes incompatible interfaces open deadlocked solution def fyg xhi yhi 
context closure properties easily extended take account open contexts 
note apply context implicitly assume resulting open process formed 
extrusions strong barbs direct correspondence ev fact open syntax provides convenient notations give selective give access de ned names processes compared introduce interesting new equation 
consider instance bisimilarity equivalence open terms lemma processes de nitions tuple names de ned plug fresh name :10.1.1.36.865
statements equivalent 
def def 
def def 
fv def dv dv dv dv dv def def rst formulation compact relies open terms 
second formulation explicit communication extruded names environment message fresh name plug third formulation closed application evaluation contexts direct proofs bisimilarity equivalence see 
weak labeled bisimulation design open join calculus equipped standard notion labeled bisimilarity de nition relation weak simulation 

labels shape xhevi fv 
relation weak bisimulation weak simulations 
weak bisimilarity largest weak bisimulation 
simulation clause intrusions weak bisimulation sensitive input interfaces implies xv xv 
simulation clause extrusion consider labels set extruded names clashes free names inasmuch transitions simulated standard technicality ect intuitive discriminating power bisimulation names converted extrusion 
opposed contextual equivalences possible tell processes weakly bisimilar comparing labeled synchronization trees reasoning possible contexts 
example process performs extrusion distinct labels 
likewise def rst process emits free name label emits local name gets extruded label 
range proof techniques available reduce size relation exhibit proving labeled :10.1.1.36.865
instance reason restriction input interface 
de nition mention contexts weak bisimilarity closed application context 
theorem weak bisimilarity congruence 
proof generic mobile process calculi absence external choice see asynchronous pi calculus relies simpler closure properties closed application evaluation contexts closed renamings 
refer details 
immediate corollary place labeled bisimilarity hierarchy equivalence justify auxiliary proof technique observational equivalence weak bisimulation reduction steps respects barbs closed application contexts 
inclusion strict seen paradigmatic example bisimilarity equivalence def emitting free name emitting bound name forwards messages receives extra internal move observable 
contrary weak bisimilarity separates processes respective extrusion labels reveal free extruded 
contexts open join calculus identify names messages powerful contexts required reconcile semantics see section 
asynchronous bisimulation order prove processes bisimilar large candidate bisimulation nuisance requires analysis numerous transition cases 
unfortunately weak bisimulations open chemical solutions typically large 
example process react int side conditions substitute names rv dv rules str null par def ext 
join open rcham extruded name nitely derivatives real computation performed 
consider equivalence def def processes bisimilar join pattern triggered regardless messages environment may send confronted nite models sides distinct chemical solution multiset messages far 
problem weak bisimulation motivates alternative formulation labeled equivalence 
join open rcham modify open rcham allowing inputs immediately trigger guarded process 
example processes inert extrusion trivially bisimilar 
applied re nement labels input obtain dubious result 
solution xhi yhi zhi fx yg zhi progress rst messages xhi yhi performing silent step consumes messages local message zhi solution 
xhi yhi trigger process solution inert 
suggests join inputs transitions xhi yhi zhi fx yg zhi xhi yhi xhi yhi zhi fx yg hand solution xhi yhi zhi fxg zhi truly inert environment access trigger case re nement suppresses input transitions 
join open rcham de ned table replacement intrusion rule 
contrast rule int new rule react int permits intrusion messages messages immediately trigger process 
formalized allowing labels parallel compositions messages 
solution contains complementary process combination matches reaction rule transition occurs triggers reaction rule 
int restrict intrusions messages extruded names 
identify intrusions case silent steps rule react omitted new chemical machine 
maintain distinction internal moves proper input moves discussion 
sequel shall keep symbol open rcham join open rcham may drop subscript ambiguity arise 
open process di erent models instance process def fxg xhi yhi transition join open rcham nite series transitions xhi xhi xhi 
open rcham 
comparison transition systems yields correspondence intrusions proposition open process 


xn xn 

xv accordingly adapt de nition labeled bisimulation de nition new join open rcham 
consider processes def def xhi yhi yi def def xhi yhi yi assume fv 
initial open rcham processes weakly bisimilar 
new join open rcham de nition weak bisimulation hold input xhi emitting 
consider weak bisimulation uses join input labels single ones input xhi yhi separated 
turns weak bisimulation discriminates join open rcham 
order retain asynchronous semantics weak bisimulation relaxed process may simulate react int transition immediately consume messages 
leads de nition de nition relation asynchronous simulation 
labels fv 

xv xv 
relation asynchronous bisimulation asynchronous simulations 
asynchronous bisimilarity largest asynchronous bisimulation 
de nition usual clause silent steps omitted subsumed clause intrusions 
hand clause explicitly requires related solutions extruded names 
asynchronous bisimilarity weak bisimilarity coincide 
validates asynchronous bisimulation ecient proof technique 
theorem conclude discussion variants labeled bisimulations mention ground bisimulation obtained restricting intrusions labels convey fresh names 
rst observed pi calculus asynchrony brings interesting property regards number transitions consider ground variant coincide basic 
property holds join calculus providing proof techniques chemical solution exactly intrusion extruded name weak bisimulation intrusion active partial join pattern asynchronous bisimulation 
discriminating power name comparison labeled bisimilarity ner bisimilarity equivalence process calculi semantics coincide add operator name comparisons 
section extend syntax join calculus accordingly style :10.1.1.36.865
def def extend chemical machines new reduction rule 
compare technical drawback extension renamings preserve weak bisimilarity anymore 
instance xhi applying renaming xhi 
accordingly weak bisimilarity congruence anymore 
instance context def def yi zhu ui separates xhi 
consider equivalences closed application evaluation contexts 
presence comparisons lemma labeled bisimilarity closed application evaluation contexts regards observational equivalence bisimilarity equivalence largest barb preserving bisimulation open join calculus name comparison closed application plain evaluation contexts 
bisimilarity equivalence separates def context def labeled bisimilarity clearly remains ner bisimilarity equivalence 
interestingly converse inclusion holds theorem name comparison establish theorem suces show label evaluation context speci cally captures label 
intrusions easy suces parallel context 
extrusions delicate inasmuch context join calculus de ne name order detect output transition name case handled creating permanent relay messages name 
additional care relay detected name matching family contexts separate aspects name 
name 
def def hxi 
length matches arity assuming fv process uses free name forwards messages context able discriminate process sends name name matching extra capability supplied auxiliary message hxi 
lemma captures essential property lemma accommodating extrusions open processes xv xv interface 
informally contexts residuals contexts test labels form 
context label easily prove labeled bisimulation 
proof theorem harder notion bisimilarity equivalence see section characterize synchronization tree single context characterizing label isolation 
explains similar results apply processes image nite transitions 
distribution mobility distributed programming main purpose join calculus distribution resources kept implicit far 
described semantics just argued join calculus built locality implemented asynchronous manner 
section gives explicit model distributed programming 
extend join calculus locations primitives mobility 
resulting calculus allows express mobile agents move physical sites 
agents programs core images running processes communication capabilities internal state 
general easy merge concurrency theory distributed systems resulting distributed join calculus signi cantly complex plain join calculus 
intuitively location resides physical site contains group processes de nitions 
move atomically location site 
represent mobile agents locations 
agents contain mobile sub agents represented nested locations 
agents move current sub agents locations dynamic tree structure 
calculus treats location names rst class values lexical scopes case channel names scope name may extend locations 
location controls moves move location providing name target location typically communicated selected processes 
distributed join calculus core programming language opposed speci cation language design strongly uenced implementation issues 
de nition atomic reduction steps attempts strike balance expressiveness realistic concerns 
reliable detection physical failures re ned operational semantics fully implemented 
notes omit speci discussion implementations refer appendix programming examples 
computing locations re ne rcham steps 
partition processes de nitions local solutions 
model suces representing local computation di erent sites global communication 
introduce structure account creation migration local solutions attach location names solutions organize tree nested locations 
re ned syntax chemical semantics appear gures 
distributed solutions distributed re exive chemical machine multiset 
write global state solutions connected commutative associative operator represents distributed composition 
local solution distinct label explain role labels 
solution evolves internally chemical rules join calculus 
technically chemical context law extended enable computation local solution side condition str def requires globally fresh names substituted de ned names 
local solutions interact new rule comm models global communication 
rule states message emitted solution port name remotely de ned forwarded solution contains de nition message assemble pattern messages consume locally familiar react rule 
step decomposition communication re ects happens actual implementations message transport message processing distinct operations 
consider name de ned local solution 
condition preserved chemical semantics simpli es usage rule comm message rule applies delivers message unique receiving location 
actual mapping channel names de ning locations maintained implementation 
contrast models distributed systems detail explicit routing messages calculus 
language design viewpoint believe bookkeeping routing information low level activity best handled implementation level 
distributed join calculus locality property routing information simple safely omitted language 
remote message passing rst example local solutions model simplistic print matches available printers job requests 
described rule def assume machines user machine issues print request server machine hosts laser printer registers 
represent printer code 
series chemical steps comm comm react comm rst step forwards message user machine machine de nes job likewise second step forwards message 
synchronization occurs messages local reduction step 
result new message sent laser printer forwarded received 
example illustrates notion global lexical scope 
model fact laser initially private printer machine preliminary local structural step machine def str def second comm step series extends scope laser server gains ability send messages printer 
contrast semantics guarantees process may send messages 
locations nested 
assuming location mapped host machine agent migration naturally represented update mapping locations machines 
instance location contains running code mobile agent may migrate machine hosts location providing particular service anticipation intense exchange messages locations 
model locality hierarchical locations attached parent location machine 
migration request expressed new process construct go name target location guarded process triggered completing migration 
migration subjective inasmuch applies location runs process go 
regards distributed programming situations levels moving resources useful 
example server may move machine continue service machine goes termination machine locations modeled mechanisms migration 
agents naturally sub agents spawn parts computation machines 
mobile agent returns client machine instance may contain running processes resources logically contents agent integrated client client moves fails contents carried away discarded accordingly 
implementor viewpoint hierarchical model implemented ef ciently model machine keep track local hierarchy locations 
model provides additional expressiveness programmer assemble groups resources move machine 
may explain implementations mobile objects provide rich dynamic structure controlling migration instance allowing objects temporarily attached cf 
:10.1.1.103.9804
illustrate advantages nested agents case concurrent migrations client creates agent go get information server parallel server goes machine 
location structure migration client server dynamically replaced migration particular machine machine currently hosts server 
case server moves arrival agent agent left 
mapping locations machines depends scheduling di erent migrations migration server yields guarantee machine server 
hierarchical structure nested migrations commute agent guaranteed remain server long explicitly request migration 
location tree order deal locality represent locations syntactic de nitions considered local chemical solutions interact 
location names relate structures 
assume countable set location names location names 
write nite strings location names paths 
location names rst class values 
channel names created locally sent received messages lexical scope 
introduce new locations extend syntax de nitions new location constructor def gathers de nitions location visible outside location running code location name de ned uniquely identi es location 
informally de nition corresponds local solution path local solution 
say pre 
multisets solutions labeled paths distinct pre uniquely identi ed rightmost location name 
conditions ensure solutions ordered relation form tree 
con gurations local solution path contents parallel composition processes asynchronous message go migration request def local de nition parallel composition inert process join calculus de nition reaction rule sub location named contents composition void de nition join pattern ey message pattern synchronization syntax distributed join calculus comm go go ab str loc side conditions comm dv go occur path str loc occur path fdg fpg content solution local rules unchanged distributed composition associate commutative 
distributed rcham new structural rule str loc relates representations locations 
left right rule takes de nition creates running location initially contains single de nition single running process right left str loc freezing ect location 
rule side condition requires solution form implicit chemical context contrast de nition may contain 
side condition guarantees syntactically captures subtree location rule applies 
note rule str def side condition apply de ned location names 
guarantees newly de ned locations fresh names locations folded back de ning processes leave running 
formed required reaction rules de ning channel name belong single local solution local solutions distinct paths 
addition frozen locations solution require locations solution distinct location names appear path local solution 
constrain syntax de nitions accordingly formed de nition conjunctions require dv dv contain port names de ned instance de nitions xhi xhi ruled 
example nested locations describe series structural rearrangements enable actual reduction steps 
assume occur def str def str loc str def par xi str loc ca xi comm ca xi react ca qf xi def qf xi moving locations bookkeeping location tree handled special case structural rearrangement express migration relocation branch location tree 
extend syntax processes new primitive migration chemical semantics second reduction rule operates chemical solutions rule go 
informally location moves current position tree new position ba just location name argument 
target solution identi ed name arrives guarded process triggered 
side condition forces preliminary application rule str loc fold guarantees branch moves 
attaching meaning locations presentation locality structure descriptive distributed semantics keeps track locality information location particular process de nition ect result computation 
formally erase locality information relate simple semantics distributed semantics 
care required rule migration attempts may delay block processes 
conclude brie re ned models locality turn conditions computation partially observed 
partial failure failure detection calculus extended simple fail model failure crash physical site causes permanent failure locations 
location halt 
failure location detected running location allowing programmable error recovery 
supplement syntax distributed processes constructs failure asynchronous failure detection processes halt local failure fail remote failure detection put optional failed marker front location name paths add side condition path contain front chemical reduction rule failed location sub locations migrate communicate perform local steps 
addition provide chemical rules new constructs halt halt detect fail side conditions halt occur path marker occur go marker occurs model failure partially supported jocaml 
inasmuch failures reported permanent location failures programming model relatively simple 
instance single delivery message guaranteed sender fails programmer consider larger units failure 
failure detection provides useful negative information location failure detected location may interact task may taken location interfering failed location 
contrast timeouts pragmatically useful trivially modelled asynchronous setting just reduction steps provide negative guarantee 
authentication secrecy interpreting locations security principals developed model authentication variant join calculus 
variants consider static parallel composition locations 
distributed join calculus name belongs single location de nes location receive messages sent name locations notice messages 
addition message carries mandatory rst parameter contains location name meant name sending location receiver authenticate sender 
properties enforced modi ed comm rule secure comm yi yi dv 
rst parameter overwritten correct sender identity modula secure network objects 
secrecy authenticity properties provide strong basis reasoning security distributed programs semantics depends global chemical conditions necessarily met practical implementations communicating untrusted remote machine way check running correct implementation 
main technical result properties faithfully implemented standard cryptographic primitives assumptions network 
result expressed terms bisimilarity equivalences 
lecture notes partly derived previous works collaboration mart abadi sylvain laneve fabrice le jean jacques evy luc didier emy alan schmitt 
abadi fournet gonthier 
secure implementation channel abstractions 
manuscript web research microsoft com fournet subsumes :10.1.1.36.865
abadi fournet gonthier 
secure implementation channel abstractions 
proceedings lics pages 
ieee june 
abadi fournet gonthier :10.1.1.36.865
secure communications processing distributed languages 
proceedings ieee symposium security privacy pages may 
abadi fournet gonthier 
authentication primitives compilation 
proceedings popl pages 
acm jan 
agha mason smith talcott 
foundation actor computation 
journal functional programming jan 
amadio castellani sangiorgi 
bisimulations asynchronous calculus 
theoretical computer science :10.1.1.36.865
berry boudol 
chemical machine 
theoretical computer science 
boreale sangiorgi 
congruence properties calculus 
theoretical computer science 
brinksma rensink vogler 
fair testing 
lee smolka editors th international conference concurrency theory concur volume lncs pages :10.1.1.36.865
springer verlag 
brinksma rensink vogler 
applications fair testing 
editors formal description techniques ix theory applications tools volume ix 
chapman hall 
cardelli gordon 
mobile ambients 
proceedings fossacs volume lncs pages 
springer verlag 
le 
jocaml mobile agents objective caml 
asa ma pages 
ieee computer society oct 
fournet 
join calculus calculus distributed mobile programming 
phd thesis ecole polytechnique palaiseau nov 
inria tu 
available research microsoft com fournet 
fournet gonthier 
re exive chemical machine 
proceedings popl pages 
acm jan 
fournet gonthier 
hierarchy equivalences asynchronous calculi extended 
larsen winskel editors proceedings th international colloquium automata languages programming icalp volume lncs pages aalborg denmark july 
springer verlag 
fournet laneve 
bisimulations join calculus 
appear tcs available research microsoft com fournet oct 
fournet 
evy schmitt 
asynchronous distributed implementation mobile ambients 
proceedings ifip tcs sendai japan aug 
extended report available research microsoft com fournet 
fournet 
join calculus language version beta 
source distribution documentation available join inria fr june 
glabbeek 
linear time branching time spectrum ii semantics sequential systems silent moves extended 
pages 
manuscript preliminary version available ftp boole stanford edu pub spectrum ps gz 
hennessy 
typed language distributed mobile processes 
proceedings popl pages 
acm jan 
honda tokoro 
asynchronous communication semantics 
wegner tokoro nierstrasz editors proceedings ecoop workshop object concurrent computing volume lncs pages 
springerverlag 
honda yoshida 
combinatory representation mobile processes 
proceedings popl pages 
honda yoshida 
reduction process semantics 
theoretical computer science 
jul migration light weight processes emerald 
ieee operating sys 
technical committee newsletter special issue process migration 
jul levy hutchinson black 
fine grained mobility emerald system 
proceedings th acm symposium operating systems principles pages november 
laneve 
may testing join calculus 
technical report ublcs university bologna mar 
revised may 
le 
jocaml system prototype 
software documentation available pauillac inria fr jocaml 
le 
compiling join patterns 
nestmann pierce editors high level concurrent languages volume electronic notes theoretical computer science nice france sept 
elsevier science publishers 
appear 
milner 
communication concurrency 
prentice hall new york 
milner :10.1.1.36.865
communication mobile systems calculus 
cambridge university press cambridge 
milner parrow walker :10.1.1.36.865
calculus mobile processes parts ii 
information computation sept 
milner sangiorgi :10.1.1.36.865:10.1.1.36.865
barbed bisimulation 
kuich editor proceedings icalp volume lncs pages 
springer verlag 
natarajan cleaveland :10.1.1.36.865:10.1.1.38.5795
divergence fair testing 
proceedings icalp volume lncs 
springer verlag 
nestmann pierce :10.1.1.36.865
decoding choice encodings 
pages 
revised full version report ercim 
parrow sj :10.1.1.36.865
multiway synchronization veri ed coupled simulation 
cleaveland editor third international conference concurrency theory concur volume lncs pages 
springer verlag 
parrow sj :10.1.1.36.865
complete axiomatization cs congruence 
mayr wagner editors proceedings stacs volume lncs pages 
springer verlag 
sangiorgi :10.1.1.36.865
expressing mobility process algebras order higher order paradigms 
ph thesis university edinburgh may 
sangiorgi :10.1.1.36.865
bisimulation proof method 
revised version technical report ecs lfcs university edinburgh 
extended appears proc 
mfcs lncs 
sangiorgi milner :10.1.1.36.865
problem weak bisimulation 
cleaveland editor proceedings concur volume lncs pages :10.1.1.36.865
springer verlag 
van doorn abadi burrows wobber 
secure network objects 
proceedings ieee symposium security privacy pages may 
concurrent programming part manual tutorial jocaml 
chapter presents small local examples 
chapter deals distributed features 
assumed reader previous knowledge ocaml 
conventions examples jocaml source statements followed output obtained top level compiler prompted print types 
jocaml top level provides interactive environment ocaml top level 
order try examples type top level launched command concatenate source chunks le ml compile ml command ml nally run produced code command 
option enables output inferred types 
basics jocaml programs processes expressions 
roughly processes executed asynchronously produce result expressions evaluated synchronously evaluation produces values 
instance ocaml expressions jocaml expressions 
processes communicate sending messages channels port names 
messages carried channels zero values channels values 
contrast process calculi pi calculus derived programming language pict channels processes listen de ned single language construct 
allows considering implementing channels functions usage 
jocaml programs rst organized list top level statements 
top level statement declaration ocaml binding channel binding expression 
top level statements terminated optional triggers evaluation interactive mode 
simple channel declarations channels port names main new primitive values jocaml 
important categories port names asynchronous synchronous port names 
synchronous names return values asynchronous channels 
users create new channels new kind def binding confused ordinary value binding 
right hand side de nition channel process spawned message sent additionally contents messages received bound formal parameters 
instance de nition asynchronous echo channel def echo 
print int val echo new channel echo type type asynchronous channels carrying values type int 
presence de nition channel name indicates channel asynchronous 
indication channel de nition channel 
sending integer echo res instance process print int prints integer console 
ocaml expression print int returns value necessary append discards value 
echo asynchronous possible know actual printing takes place 
de nition synchronous print follows def print print int reply val print int unit type print functional type int unit takes integer argument returns empty result 
print function introduced def binding 
de ned name print synchronous return value 
mechanism return values synchronous channels di erent functions uses reply construct semantics send back zero values result 
rst di erence plain ocaml functions implicitly return value guarded expression explicit reply 
message sending print synchronous sense knows console output occurred print returns answer 
processes just saw synchronous names return values asynchronous channels 
message sending synchronous channels occurs inside expressions functions message sending asynchronous channels occurs inside processes 
processes new core syntactic class jocaml 
basic process sends message asynchronous channel channel echo just introduced 
declarations expressions allowed top level processes turned expressions spawning introduced keyword spawn followed process curly brackets 
spawn echo spawn echo processes introduced spawn executed concurrently 
program may echo echo 
output may depending implementation 
concurrent execution occurs inside processes parallel composition operator 
provides concise semantically equivalent alternative previous example spawn echo echo composite processes include conditionals matching match local binding 
def 

process grouping done curly braces 
spawn echo echo echo program may echo integers order :10.1.1.36.865
grouping necessary process 
restrict scope evaluation occurs independently process echo expressions important syntactic class jocaml class expressions 
contrast processes expressions evaluate results 
expressions occur top level 
expressions occur right hand side value bindings arguments message sending 
apart ocaml expressions basic expression sends values synchronous channel behave ocaml function 
synchronous channels return answer zero results channel print introduced 
print print val int program expressions evaluation returns single value integer 
expressions print print return empty results value 
sense respect synchronization top level phrases evaluated textual ordering program rst outputs outputs 
synchronous channels considered functions instance sequence print print sequences may occur inside processes 
general form sequence inside process expression process result expression discarded 
expression sequence may write spawn print print echo sequence may terminated empty process denoted empty sequence characters 
alternative previous example written spawn print print print print int de nition echo channel considered process 
concrete syntax processes expressions purposely similar 
noticeable exception grouping expressed curly braces case processes ordinary parentheses case expressions 
grouping necessary sequence parallel composition branch instruction grouping expression process process expression expression expression depending process expression 
rule applied considering matching 
channels guarded process channel de nition spawn messages stuttering echo channel def echo twice 
echo echo val echo twice possible de ne directly channel referring channel echo ocaml function print int 
case necessary enclose print int new de nition echo twice def echo twice 
print int print int val echo twice grouping necessary binds tightly def echo 
print int echo echo val echo mixing synchronous asynchronous calls spawn echo print print spawn echo twice observe processes execute concurrently perfectly valid output 
printing constraint synchronous character print 
synchronous asynchronous channels di erent types type checker ags error channel wrong context 
spawn print file ex ml line characters expecting asynchronous channel receive int unit channels polyadic respect arguments results exist 
instance print accepts argument returns empty result 
channel arity argument result shown type 
def reply val int int int int ocaml polyadic results exploited polyadic value bindings 
instance program print console print int val int val int type behave functions synchronous names support functional programming style 
traditional example fibonacci function 
def fib reply fib fib print int fib val fib int int contrast value bindings channel de nitions potentially recursive 
port names rst class values jocaml 
sent messages port names returned results 
result higher order ports written def twice def reply reply val twice type twice polymorphic includes type variable replaced type 
twice synchronous channel takes synchronous channel function type argument returns result type 
instance type integers type strings ocaml string concatenation def succ reply def double reply twice succ twice double print int print string val succ int int val double string string xxxx modules current implementation jocaml relies module system ocaml 
users create modules compile separately link executable program 
instance users may write module stutter exports channels echo print 
ideally users rst specify names exported module stutter types writing interface le stutter mli 
val echo val print int unit interface stutter mli compiled issuing command stutter mli 
produces object interface le stutter cmi 
implementation le stutter ml contains actual de nitions stutter echo stutter print 
def echo 
print int print int def print print int print int reply implementation le stutter ml compiled issuing command stutter ml compile link option 
produces object implementation le stutter 
module stutter properly compiled implementation le user ml 
stutter print spawn stutter echo stutter echo implementation le user ml compiled user issuing command user ml 
compilation uses compiled interface stutter cmi 
executable produced command stutter user links modules stutter user 
alternatively produced step command stutter user ml 
running may produce output join patterns join patterns signi cantly extend port name de nitions :10.1.1.36.865
join pattern de nes ports simultaneously speci es synchronization pattern de ned ports 
instance source fragment de nes synchronizing port names fruit cake def fruit 
cake 
print string print newline val cake val fruit trigger guarded process print string print newline messages sent fruit cake 
spawn fruit apple cake pie apple pie parallel composition operator appears join patterns processes 
highlights kind synchronization pattern matches 
join de nitions fruit cake provide simple mean express non determinism 
spawn fruit apple fruit cake pie cake pie apple cake names appear console combinations fruits correct 
composite join de nitions specify synchronization patterns 
def apple 
pie 
print string apple pie 
pie 
print string pie val pie val apple val observe name pie de ned 
pie potentially takes part synchronizations 
de nition expressed keyword 
internal choice performed invocation pie spawn apple pie pie join patterns programming paradigm concurrency jocaml 
allow encoding concurrent data structures 
instance code de nes counter def count 
count reply count 
get count reply get spawn count val unit unit val count val get unit int de nition calls remarks 
join pattern may mix synchronous asynchronous message synchronous message reply construct specify name replies new reply name construct 
case single synchronous name pattern construct optional 
instance necessary previous example 
second usage name count typical way ensuring mutual exclusion 
moment assume active invocation count 
invocation active count holds counter value message counter ready incremented examined 
operation performed counter pending operations postponed operation performed left counter consistent state 
consequence counter may consistently threads 
spawn def wait 
get print string 
print newline spawn wait val wait 
ensuring correct counter behavior example requires programming discipline initial invocation count 
simultaneous invocations count mutual exclusion lost 
initial invocation count counter 
avoided making count get names local create counter de nition exporting get hiding count advantage lexical scoping rules 
def create counter def count 
count reply count 
get count reply count reply get get create counter val create counter unit unit unit unit int val unit unit val get unit int programming style reminiscent object oriented programming counter thing called object internal state count argument exports methods external world get 
constructor create counter creates new object initializes internal state returns exported methods 
consequence counters may allocated independently 
control structures join pattern synchronization express common programming paradigms concurrent sequential 
control structures concurrency locks join pattern synchronization emulate simple locks def new lock def free 
lock reply unlock free reply free reply lock unlock val new lock unit unit unit unit unit threads try acquire lock performing synchronous call channel lock 
due de nition lock consumes name free thread get response time 
thread attempts acquire lock blocked thread lock releases synchronous call unlock res invocation free 
ocaml possible introduce bindings keyword 
bindings recursive 
give example lock usage introduce channels output string arguments times def double def reply reply def print port print string thread delay reply print double double double double print port val double val print port string unit val print string unit thread delay calls prevents thread running long print strings 
consider threads printing printing 
spawn print print threads execute concurrently outputs may mix depending scheduling 
lock delimit critical section prevent interleaving 
lock unlock new lock spawn lock print unlock lock print unlock val lock unit unit val unlock unit unit barriers barrier common synchronization mechanism 
basically barriers de ne synchronization points execution parallel tasks 
simple barrier synchronizes threads def join join reply join reply join val join unit unit val join unit unit de nition includes reply constructs mention port mandatory 
threads print ba ab matching parenthesis spawn print string join print string join print string join print string join ab bi directional channels bi directional channels appear process calculi 
asynchronous pi calculus instance channel value sent asynchronously written received bound variable guarded process written 
process send receive channels know 
contrast jocaml process knows channel send messages unique channel de nition receives messages 
scope pi calculus channel name de ned new operator 
operator exist jocaml join de nitions binding constructs 
bi directional channels de ned jocaml follows def new pi channel def send 
receive reply reply send receive val new pi channel unit unit pi calculus channel implemented join de nition port names 
port name send asynchronous send messages channel 
messages received making synchronous call port name receive 
translate pi calculus process new print get spawn sc rc new pi channel sd rd new pi channel sc sc rc sd rd print int synchronous pi calculus channels encoded just easily asynchronous ones suces send synchronous def new pi sync channel def send receive reply receive reply send reply send receive val new pi sync channel unit unit unit loops join patterns useful expressing various programming control structures 
rst examples deal iterations integer interval 
simple loops asynchronous loops execution order iterated actions irrelevant actions asynchronous 
def loop 
loop def echo star 
print string spawn loop echo star val loop int val echo star execution order matters sequential loop preferable def loop loop reply reply def print print int print string reply loop print val loop int int unit val print int unit loop produces result result computed inside reply constructs accumulated 
example computes sum squares integer def sum def iter reply iter reply reply iter def square reply val sum int int int int val square int int print int sum square port name de nitions iter belong functional programming style :10.1.1.36.865
particular various iterations loop body computing execute concurrently iterations performed 
integer addition associative commutative summing order various matters 
asynchronous iteration leading program opportunities concurrent execution def sum def add 
dr total dr reply total reply def loop 
add loop loop reply total print int sum square val sum int int int int observe loop result accumulated synchronous name total :10.1.1.36.865
argument reply sum consists call total 
trick enables synchronous sum return result asynchronous loop 
fact current jocaml language places strong restrictions positioning reply constructs de nitions direct reply sum sub de nition add 
dr total rejected compiler def sum def add 
dr total 
dr total reply sum def loop 
add loop loop file ex ml line characters reply channel external def sum distributed loops sharing loop agents requires 
informally de ne agent computing unit 
section agent represented synchronous channel 
realistic setting di erent agents reside di erent computers 
agent paradigm serves allocate computing resources see section chapter 
instance agents square square 
agent square fast machine square slow machine computing squares une cient way 
additionally square square di er marginally console output square outputs square outputs starts just answering 
def square print string reply def square print string def total 
wait reply def mult 
mult wait print string reply val square int int val square int int sharing loop agents allocating iterations performed 
channel sum returns register channel wait channel 
agent registers sending computing channel register 
nal loop result returned wait 
def sum def add 
dr total reply dr total reply dr wait reply total def loop 
register 
add register loop loop reply register wait val sum int int unit int di erence asynchronous sum loop previous section resides replacement de nition def loop 
join pattern de nition def loop 
register 
consequence agents square square may compete loop iterations provided invocations register square register square active 
register wait sum spawn register square register square print int wait val register int val wait unit int distributed loop satisfactory take relative computing speed square square account allocating iterations :10.1.1.36.865
add jobs spawned asynchronously di erent iterations performed agent executed concurrently 
result iteration space partitioned evenly square square illustrated output 
leads poor load balance fast square stands idle loop slow square overwhelmed 
better solution agent execute share sequence concurrently 
achieved slightly modi ed de nition loop register def sum def add 
dr total reply dr total reply dr def wait reply total def loop 
register 
loop add register loop reply register wait val sum int int unit int new de nitions register launched computed 
contrast loop launched immediately agent grab iteration soon possible 
register wait sum spawn register square register square print int wait val register int val wait unit int data structures explore expressive power message passing jocaml consider encoding data structures :10.1.1.36.865
practice state art built data structures inherited ocaml jocaml internal encodings 
pairs polymorphic pairs encoded quite easily jocaml advantage port name arity 
def create def get reply reply get val create unit exposed type pair synchronous port name takes zero arguments returns values 
synchronous name create returns name values store pair 
content pair retrieved sending message arity zero def fst reply snd reply val fst unit val snd unit pairs fashion considering constructor create destructors fst snd create print int fst string length snd val unit int string encoding data structures object oriented style convenient programming style expressing encodings data structures jocaml socalled object oriented style 
object internal hidden state exports methods synchronous names operate internal state 
consider instance encoding lists def cons def head reply tail reply self reply false head tail reply self nil def head reply failwith head nil tail reply failwith tail nil self reply true head tail reply self val cons unit bool unit unit val nil unit unit bool unit unit internal state list cell emptiness status true false plus appropriate subcomponents 
emptiness status exposed directly external world 
methods head tail give access subcomponents non empty list cell fail 
observe name self introduced pack methods reply cons nil 
types results nil cons 
kinds list cells values type 
lists directly retrieving methods def list concat reply reply list concat val list concat unit bool unit string unit string type recursive 
re ects fact lists recursive data structures 
precisely type cons cell creator cons recursive 
recursive type lists strings appears naturally writing function traverses lists 
source fragment shows create string lists def replicate elem reply cons elem replicate elem print string list concat replicate val replicate int unit bool unit unit mutable data structures object states represented join patterns altered invoking appropriate methods 
de nition cell 
method get examines content cell put alters 
def create ref def state 
get state reply state 
put new state new reply state reply get put val create ref unit unit internal state cell content stored message channel state 
lexical scoping keep state internal cell 
gi pi create ref gs ps create ref val gi unit int val pi int unit val gs unit string val ps string unit concurrent fifo ready sophisticated example data structure encoding jocaml 
de ne new kind list cells 
cell holds element 
created stands rst position list name see re ecting status activated 
element cons ed front list cell additionally holds pointer previous element see pattern 
set prev prev 
cell destroyed see kill returns content pointer previous cell exists boolean set true destroyed cell list 
def new cell def 
set prev prev inside prev reply inside 
prev kill reply prev false 
kill reply self true self reply set prev kill reply self val new cell unit unit unit bool fo data structure provides methods put get 
method put stores argument fo method get retrieves element fo 
internal state fo empty name empty activated contains elements internally non empty fos name state activated 
name state holds arguments fst pointer rst cell element list lst pointer cell element list 
elements stored fo cons ed front fst see put retrieved elements taken element list see get 
empty 
get pattern 
consequence attempt retrieve element empty fo error answering get simply postponed fo lls 
def fifo def empty 
put fst new cell state fst fst reply state 
fst lst put new fst new cell set rem fst set new fst state new fst lst reply state 
fst lst get set rem lst prev cell rem cell empty state fst prev reply empty reply put get val fifo unit unit unit fo point view elements retrieved order stored 
concurrent setting means thread performs get row retrieved elements come order compatible order thread feeds fo 
spawn put get fifo print int get print int get print newline get get put put put put program prints integers set increasing order 
word typing jocaml type system derived ml type system surprise ml programmers 
key point typing la ml parametric polymorphism 
instance polymorphic identity function def id reply val id type id contains type variable instantiated type time id 
type variable generalized type variable 
instance program variable instantiated successively int string id id print int print string val int val string words rst occurrence id type int int second type string string 
experienced ml programmers may wonder jocaml type system achieves mixing parametric polymorphism mutable data structures 

consider jocaml encoding cell def state 
get state reply state 
set new state new reply val get unit val state val set unit type variable appears inside types state get set pre xed underscore 
type variables non generalized type variables instantiated 
occurrences state type 
instantiated type type replaces types appears types get set 
wide scope instantiation guarantees various port names type contains state get set consistently 
speci cally instantiated type int sending message state 
type get unit int rest program shown type 
consequence program type check runtime type error printing integer believing string avoided def state 
get state reply state 
set new state new reply spawn state get print string file ex ml line characters expression type int type string non generalized type variables appear type de ned port names share type variable 
type variable generalized 
def port 
arg 
val arg val port workaround encapsulate faulty names port name de nition de nes name 
restores polymorphism 
def def port 
arg 
reply port arg val unit non generalized type variables appear types identi ers de ned value binding 
def echo 
print int echo string 
print string spawn echo echo string val val val val val echo val echo string interesting notice invoking twice produces di erent sets port arg port names types contain di erent type variables 
programmers explicit di erent type instantiations performed silently compiler case generalized type variables 
exceptions processes mapped threads run time important specify behaviours presence exceptions 
exceptions behave ocaml ocaml expressions 
exception expression behaviour depend synchrony process 
process asynchronous exception printed standard output asynchronous process terminates 
process ected 
spawn failwith bye bye print string done uncaught exception failure bye bye process synchronous process waiting result process receive exception propagated ocaml function 
def die failwith die reply try die print string dead val die unit dead processes may waiting result exception raised case instance reply constructs syntactically guarded shared expression raises exception 
cases exception duplicated thrown threads reversing joins forks 
def failwith die reply reply spawn try print string hello try print string hello val unit 
