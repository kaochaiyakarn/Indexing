polymorphic record calculus compilation atsushi ohori kyoto university motivation provide type theoretical basis developing practical polymorphic programming language labeled records labeled variants 
goal establish polymorphic type discipline ecient compilation method calculus labeled data structures 
de ne second order polymorphic record calculus extension girard reynolds polymorphic lambda calculus 
develop ml style type inference algorithm predicative subset second order record calculus 
soundness type system completeness type inference algorithm shown 
results extend milner type inference algorithm damas milner account ml polymorphism harper mitchell analysis xml 
establish ecient compilation method polymorphic record calculus rst de ne implementation calculus records represented vectors elements accessed direct indexing variants represented values tagged natural number indicating position vector functions switch statement 
develop algorithm translate polymorphic record calculus implementation calculus type information obtained type inference algorithm 
correctness compilation algorithm proved compilation algorithm shown preserve typing operational behavior program 
results standard ml extended labeled records compiler implemented 
categories subject descriptors programming languages formal de nitions theory programming languages language classi cations applicative languages programming languages language constructs features data types structures general terms languages additional key words phrases compilation polymorphism record calculus type inference type theory 
labeled records labeled variants widely data structures essential building blocks various data intensive applications database author version published acm transactions programming languages systems 
preliminary summary results article appeared proceedings acm symposium principles programming languages title compilation method ml style polymorphic record calculi 
partly supported japanese ministry education scienti research 
author address research institute mathematical sciences kyoto university ku kyoto japan email ohori kyoto ac jp permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission acm 
copy republish requires fee speci permission 
acm acm transactions programming languages systems pages 
polymorphic record calculus compilation 
gramming 
despite practical importance existing polymorphic programming languages properly support data structures 
standard ml milner contains labeled records form labeled variants allowable operations restricted monomorphic ones 
example consider simple function name records name name name syntax selecting name eld record function polymorphic sense applied terms record type containing name eld fname string age intg fname string oce intg 
way writing function ml fun name name name ml syntax name 
program rejected current ml compiler programmer explicitly speci es type restricts possible argument values records xed set labels fun name fname string age intg name unfortunately writing type speci cation cumbersome eliminates exibility functions operating records name 
analogous situation exists labeled variants 
variant types disjoint union types want treat values di erent types uniformly 
signi cant advantage labeled variants simple disjoint union types support exible programming designating kind value symbolic label 
example consider variant value payment de ned payment value tagged variant label pound 
payment treated value various di erent variant types real dollar real yen inti variant types containing pound real eld 
unfortunately form exible programming unavailable existing polymorphic languages restrict variant values monomorphic 
standard ml example variant type may de ned datatype pound real yen int de nition ties variant labels pound yen particular type 
consequence value payment de ned type value variant types 
standard ml programming commonly adopted ad hoc strategy get problem de ne variant type containing possible components omit cases manipulating variant values 
approach introduces runtime exceptions match failure essentially type errors caught compile time 
highly desirable extend polymorphic programming language allow polymorphic manipulation labeled records labeled variants 
article term record polymorphism refer form polymorphism required polymorphic manipulation labeled records labeled variants 
goal provide basis develop polymorphic programming language acm transactions programming languages systems 

atsushi ohori supports record polymorphism 
technical challenges achieving goal 
rst development static type system represent record polymorphism 
second development ecient compilation method polymorphic operations records variants 
article provide solutions problems 
rest section shall explain problems outline solutions article 
part article preliminary presentation kinded abstraction type inference compilation ohori 
static type system record polymorphism record polymorphism property labeled eld access polymorphic applied labeled data structure containing speci ed eld 
example function name accesses name eld record value payment accesses pound branch case statement types forms name fname 
payment real 
conventional polymorphic type systems represent set possible types shapes represent polymorphic nature programs containing terms 
cardelli observed form polymorphism captured de ning subtyping relation allowing value supertypes 
approach supports certain aspects method inheritance provides basis object oriented programming 
cardelli wegner extended approach second order type system 
type inference systems subtyping developed mishra mitchell 
clear mechanism record polymorphism coupled strong mechanism subtyping 
presence subtyping static type longer represents exact record structure runtime value 
example term true fa trueg fb false cat type fb runtime value presumably fa trueg 
property may problematic want deal operations equality test depend exact structure values 
shall discuss section subtyping complicates implementation 
alternative approach initiated wand extend ml style polymorphic typing directly record polymorphism 
idea developed number type inference systems jategaonkar mitchell ohori buneman emy wand 
type systems general polymorphic type scheme inferred typable untyped term containing operations records 
appropriate instantiation inferred type scheme untyped term safely value various di erent types 
approach captures polymorphic nature functions records integrates record polymorphism type inference relieves programmer writing complicated type declarations required explicit second order calculi 
acm transactions programming languages systems 
polymorphic record calculus compilation 
fun move modify ffx move fx color red fx int int color fun transpose modify modify ffx gg transpose fx direction theta gg fx real real direction real theta fun dist case square square polar ri ffx real ffr polar real dist fx color green gi real fig 

example programs inferred types 
proposed type inference systems mechanism row variables wand variables ranging nite sets eld types 
row variables base development idea ohori buneman placing restrictions possible instantiations type variables 
formalize idea kind system types re ne ordinary type quanti cation kinded quanti cation form type variable constrained range set types denoted kind mechanism analogous bounded quanti cation cardelli wegner 
kind universal kind denoting set types record kind form ffl 
gg denoting set record types contain speci ed elds variant kind form hhl 
ii denoting set variant types contain speci ed elds 
mechanism allows represent polymorphic types various record operations 
example function name value payment types name gg payment indicating name function takes value record type containing name eld returns value type may type payment polymorphic value having variant type containing pound real component 
mechanism terms polymorphically 
addition labeled eld access kinded abstraction represent polymorphic record modi cation update operations modify creates new record modifying value eld leaving elds unchanged 
typing shows polymorphic nature construct 
modify ffl gg combination features allows exible programming sacri cing advantage static typing existence ml style complete type inference algorithm 
shows examples typings involving labeled records variants ml style polymorphic function declaration 
form programming possible proposals ml style polymorphic record calculi row variables mentioned earlier 
advan acm transactions programming languages systems 

atsushi ohori tage formulation yields uniform treatment explicitly typed calculi ml style type inference systems 
type inference algorithms de ned second order types explicitly treat ml binding 
emy formally treats ml binding 
relationships explicitly typed second order system investigated 
kinded abstraction extend second order lambda calculus girard reynolds record polymorphism show extension preserves basic properties second order lambda calculus 
develop ml style type inference system predicative subset second order lambda calculus 
results extend type inference algorithm milner type system ml polymorphism damas milner analysis relationship ml polymorphism predicative second order system harper mitchell 
connections allow transfer various known results polymorphic type discipline record polymorphism 
mentioned row variables appear better suited represent various powerful operations records 
type systems row variables exible emy uses sorted equational theory row variables 
polymorphic record eld access record modi cation polymorphic variants type system provides polymorphic typings equivalent 
example function name typing system name name pre sorted row variable representing possible rows nite sets record elds contain name eld pre indicates existence name eld type typing equivalent typing calculus sense denote set ground instances 
system powerful represent operation extends record new eld removes existing eld record representable type system 
restricted form record extension operation supported jategaonkar mitchell 
explicitly typed second order calculi extensible records proposed cardelli mitchell harper pierce 
unavailability extension operations limitation type system 
record calculi row variables appear dicult compile 
author knowledge known systematic compilation method record calculi 
signi cant advantage type system allows develop ecient compilation method compile labeled eld access direct index operation shall explain subsection 
addition record extension operations various forms record concatenation operations proposed harper pierce emy wand 
inclusion operations signi cantly complicates type theoretical analysis compilation 
obvious powerful operations really needed 
example database programming typical application area labeled records play important role form operations commonly considered record concatenations natural join row variables may suitable mechanism 
possible acm transactions programming languages systems 
polymorphic record calculus compilation 
generalize relational natural join operation general record structures buneman ohori extend polymorphic type system generalized natural join buneman ohori ohori buneman 
sure operation polymorphic core programming languages 
operations considered article support wide range programming records maintaining existence ecient compilation method 
claim calculus proposed article serves basis developing practical polymorphic language record polymorphism 
believe type system extended recursive types support various features object oriented programming discussed cardelli cardelli wegner 
issue outside scope article author investigate 
compilation method record polymorphism second technical challenge developing practical programming language record polymorphism compilation 
important property labeled records ability access element record position label symbolic name 
statically typed monomorphic language cause diculty compilation 
actual position labeled eld statically determined type record labeled eld access easily compiled index operation usually implemented single machine instruction 
language record polymorphism compilation dicult problem 
consider function name 
actual arguments di er position name eld appears impossible compile function function performs index operation 
straightforward approach sets possible labels represent record potentially large structure empty slots 
cardelli took strategy represent records pure calculus subtyping 
approach useful studying formal properties record polymorphism unrealistic practice 
naive approach directly implement intended semantics labeled eld access dynamically searching speci ed label record represented association list labels values 
obvious drawback approach ineciency runtime execution 
eld access basic operation frequently invoked method unacceptable serious application development 
realistic approach dynamic eld lookup form hashing 
emy ecient dynamic eld lookup method form hashing similar extendible hashing fagin showed eld selection implemented relatively small runtime overhead execution time extra memory usage 
reasonable implementation technique various record calculi static determination position labeled elds impossible 
drawback method labeled eld access incurs extra runtime overhead program completely monomorphic positions labels statically determined 
unfortunate forced pay extra penalty monomorphic labeled eld access move supposedly advanced language acm transactions programming languages systems 

atsushi ohori polymorphic type system 
drawback hashing guarantees arbitrary records 
remy technique example large records elds 
polymorphic record calculus basis practical programming languages develop compilation method achieves compactness representation records eciency execution labeled eld access 
connor considered problem context explicitly typed language subtyping suggested implementation strategy 
provide systematic method deal arbitrary expressions consider type inference system 
second goal article develop compilation method establish compilation achieves intended operational behavior polymorphic record calculus 
strategy translate polymorphic record calculus implementation calculus 
implementation calculus labeled record represented vector values ordered canonical ordering set labels elds accessed direct indexing 
variant value represented value tagged natural number indicating position vector functions switch statement 
deal polymorphic eld selection polymorphic variants implementation calculus contains index variables index abstraction 
example untyped term name name name fname joe oce name fname age phone translation algorithm produces implementation code name name joe name index variable index abstraction index expression joe vector representations records elds ordered lexicographical ordering labels name name index application supplying appropriate index values index variable similarly untyped term payment case payment dollar case payment real int yen xi translated code implementation calculus payment hi switch payment switch payment real int xi polymorphic variant payment represented term containing index abstraction index value supplied index applications payment payment select corresponding function function vector switch statement elements sorted lexicographical ordering variant labels 
compilation method works arbitrary records variants introduce runtime overhead monomorphic programs 
polymorphic record functions variants requires extra function applications pass index values applying 
shall show development acm transactions programming languages systems 
polymorphic record calculus compilation 
extra index applications done polymorphic terms instantiated 
believe cost negligible 
general idea passing index values suggested connor 
original contributions establish systematic compilation algorithm constructs correct implementation term type correct raw term polymorphic record calculus establish correctness formally 
outline development establish rigorous typing discipline record polymorphism section de ne second order lambda calculus record polymorphism call show subject reduction property 
de ne section polymorphic record calculus de ne call value operational semantics 
typing derivations correspond terms predicative regarded extension core xml harper mitchell record polymorphism 
operational semantics serves canonical model evaluating record calculus 
damas milner style polymorphic type discipline shown sound respect semantics 
re ne robinson uni cation algorithm incorporating kind constraints type variables uni cation give algorithm infer typable raw term principal typing corresponding explicitly typed term prove soundness completeness 
constructed term contains necessary type information compilation 
section develop compilation algorithm prove correctness 
rst de ne implementation calculus call value operational semantics 
calculus serves ecient machine record calculi 
particular record eld access case branch selection performed direct indexing 
order establish correctness compilation algorithm calculus polymorphically typed functional calculus 
develop algorithm compile explicitly typed calculus intermediate language 
subtlety intermediate language compiling shown ohori translation ml typings core xml terms coherent phenomenon occurs construction term term 
sources failure coherence free type variables appear typing 
eliminating vacuous type variables selecting appropriate canonical term crucial obtaining correct compilation algorithm 
compilation algorithm shown preserve typing 
furthermore establish compilation preserves operational behavior program applying idea logical relations set appropriate relationship operational semantics operational semantics 
see mitchell survey logical relations applications 
shows relationship calculi de ned article 
type system compilation method article standard ml extended polymorphic record operations compiler sml implemented modifying standard ml new jersey acm transactions programming languages systems 

atsushi ohori implementation calculus ml style calculus explicit calculus second order calculus type inference compile restrict fig 

relationship calculi 
system appel macqueen :10.1.1.55.9444
shows ways writing function name sml val name name val name fn fname fun name fname val name fn fname second de nition uses standard ml pattern machining mechanism 
part interactive session implemented system 
fname pattern matches record containing name eld fname represents kinded quanti cation agg notation sml signi es may elds confused 
shall describing various formal systems 
section describes outline implementation demonstrates usefulness examples 

polymorphic type discipline records variants section de nes second order polymorphic record calculus proves basic syntactic properties 
types kinds kinded substitutions sets types ranged kinds ranged syntax fl 
hl 
ffl 
gg hhl 
ii stands set base types countably nite set type variables set labels fl 
record types hl 
variant types second order types type variable quanti ed set types denoted kind universal kind denoting set types 
ffl 
gg hhl 
ii record kind variant kind respectively 
labels 
appearing type kind pairwise distinct order occurrence insigni cant 
construct binds type variable set free type variables type kind denoted ftv ftv respectively 
second order types de ned ftv ftv ftv 
acm transactions programming languages systems 
polymorphic record calculus compilation 
formed ffl ffl 
gg fl 
ffl fl 
formed hhl ii hl 
hl 
hhl ii hl 
formed fig 

kinding rules second order calculus ftv types kinds de ned usual 
say type closed ftv 
identify types di er names bound type variables adopt usual bound variable convention type variables assume set bound type variables distinct di erent free type variables property preserved substitution 
calculus free type variables kinded kind assignment mapping nite set type variables kinds 
regard kind assignment set pairs type variable kind write empty kind assignment 
type variables appearing properly kinded 
expressed condition 
kind assignment formed dom ftv dom dom denotes domain function explicitly say implicitly assume kind assignment appearing rest development formed 
write kft kg formed dom ftv dom 
write kft 
kft ft 
ft note kft 
implies ftv type formed kind assignment ftv dom 
notion naturally extended syntactic objects containing types substitutions formedness condition de ned separately 
type kind denoted derivable set kinding rules 
note formed type substitution simply substitution function nite set type variables types 
write 
substitution maps substitution extended set type variables letting dom turn extended uniquely record types variant types function types 
result applying substitution second order type type obtained applying free type variables 
bound type variable convention simply take 
follows identify substitution extension types write equal functions types 
maintain domain dom substitution means domain original nite function substitutions write substitution dom dom dom dom acm transactions programming languages systems 

atsushi ohori dom dom 
assume operation associates right means 
type discipline type variables kinded kind assignment conventional notion substitutions re ned incorporating kind constraints 
substitution formed kind assignment dom formed kinded substitution pair kind assignment substitution formed kind assignment speci es kind constraints result substitution 
kinded substitution ground 
usually write ground kinded substitution 
kinded substitution respects kind assignment dom 
notion speci es condition substitution applied respects applied type kinded yielding type kinded lemma easily proved 
lemma 
kinded substitution respects 
simple corollary respects respects respects seen de nitions kind assignment regarded constraint possible substitutions type variables respect 
view formedness condition kind assignments weak sense allows cyclic kind assignments ft ffl gg ffl ggg sense useless ground substitution respects 
fact adopted stronger formedness condition kind assignments requiring kind assignment form ft 
formed ft 
reason taken approach stronger condition complexity type inference algorithm increase due formedness checking kind assignment time types uni ed 
current de nition formedness kind assignments allows delay check circularity type variable abstracted 
notation kft kg introduced purpose appear specifying rule type abstraction 
approach change set derivable closed typings yields sound type system detects type errors program 
comment issue de ne uni cation algorithm section 
terms reduction typing rules set terms grammar fl 
mg modify hl mi case hl 
mi constant base type kinded type abstraction 
variant term hl mi type speci cation necessary preserve explicit typing calculus 
record expression case expression order elds acm transactions programming languages systems 
polymorphic record calculus compilation 
type dot fl 
mng modify modify fl 
mng fl 

mng case case hl mi hl 
mn fig 

reduction rules second order system insigni cant 
identify terms di er names bound variables assume bound variable convention term variables 
write term obtained substituting free occurrences write ftv set free type variables term type abstraction de ned ftv ftv ftv ftg 
de nitions terms usual 
equality symbol syntactic equality terms types 
article deal equational proof system cause confusion 
de nition terms included constants base types 
inclusion constants general types complicate type system 
constant having polymorphic type requires special treatment operational semantics compilation shall develop 
hard extend general constants assuming constant operational behavior compilation scheme 
extension signi cantly complicate presentation framework giving additional insight 
reason consider constants base types 
reduction axioms calculus 
say reduces step written obtained applying reduction axioms subterm omit routine formal de nition 
reduction relation 
de ned re exive transitive closure 
reduction system church rosser 
seen observation 
easily veri ed reduction relation induced dot modify case church rosser 
easily veri ed relation commutes reduction relation generated type reduction known church rosser hindley roger theorem barendregt ch entire relation church rosser 
reduction system include rule lambda abstraction 
easy way include extensionality rules type abstraction records variants 
presence record polymorphism straightforward inclusion rules causes con uence subject reduction property fail 
example included type rule terms ffa int ffa di erent normal forms having di erent types 
system types may depend type variables free type variables need extend notion free type variables type 
type formed set essentially free type variables denoted smallest set satisfying acm transactions programming languages systems 

atsushi ohori var formed const formed abs fx app tabs kft kg ftv tapp record fl 
mng fl 
ng dot ffl gg modify ffl gg modify variant hhl ii hl mi case hl 
case hl 
mn fig 

type system second order calculus ftv 
ftv 
intuitively contains directly kind constrains speci ed example essentially free ft ffl ggg 
notion naturally extends syntactic structures containing types 
type assignment mapping nite set variables types 
write fx 
xn type assignment binds 
write fx fx provided dom 
type system de ned proof system derive typing form 
set typing rules 
rule tabs condition ftv equivalent kft kg assumption kft kg 
write derivable proof system 
polymorphic type discipline records subtyping type system property 
proposition 

derivation unique 
proof 
proceed induction structure case follows induction hypothesis fact ffl gg 
cases straightforward 
acm transactions programming languages systems 
polymorphic record calculus compilation 
basic properties hold proved routine induction 
lemma 
formed 
kft kg ftv ftv ftv 
kft kg 
fv dom 
fx fv 
formed fx 
corresponding lemma holds calculi shall de ne article 
lemma shows typings closed kind respecting kinded substitutions 
lemma 
respects 
proof 
suppose respects proof induction structure case formed respects formed 

case ft kg ftv 
bound type variable convention assume appear formed respects formed ft formed ft respects ft kg 
induction hypothesis ft 
ftv rule tabs 
case induction hypothesis bound type variable convention 
lemma 
typing rule tapp 
dom desired 
case ffl gg 
induction hypothesis 
lemma ffl gg 
rule dot 
cases modify hl mi similar cases easily follow induction hypotheses 
lemma holds calculi shall de ne article 
substitution lemma 
acm transactions programming languages systems 

atsushi ohori lemma 
fx proof 
suppose fx proof induction structure case kft kg fx ftv fx 
lemma implies kft kg induction hypothesis kft kg ftv ftv fx typing rule tabs case fx ffl gg induction hypothesis typing rule dot cases modify hl mi shown similarly cases proved lemma similarly second order lambda calculus 
properties prove subject reduction theorem 
theorem 


proof 
proved showing reduction axiom preserves typing 
suppose 
fx lemma 
type suppose 
kft kg bound type variable convention appear free kinded substitution respects kft kg lemma 
dot suppose fl 
mn 

fl 
ffl gg 
de nition kinding 
modify suppose modify fl 
mng 

fl 
fl 
ffl gg 
de nition kinding typing rule record fl 

mn 
case suppose case hl mi hl 
mn 

hl mi hl 
typing implies hl 
hhl ii de nition typing rule app 
acm transactions programming languages systems 
polymorphic record calculus compilation 
show simple examples terms calculus 
eld selection function name variant term payment section represented terms name gg name pay ment typings name gg pay ment hhp ound appropriate type applications terms polymorphically 
expressions containing name payment section represented terms 
name gg name string fname string oce intg fname joe oce name string fname string age int phone intg fname age phone name payment payment real dollar real dollar real payment real yen inti real real int yen int payment calculus equational proof system de ned 
believe semantic framework second order lambda calculus bruce breazu tannen coquand extended calculus soundness completeness equational proof system proved 
detailed studies semantic properties calculus scope article 
main focus ml style type inference system compilation 
turn rst 

ml style type inference system section de ne ml style implicitly typed polymorphic record calculus show typing derivations correspond terms predicative give type inference algorithm prove soundness completeness 
give call value operational semantics prove soundness type system ml style polymorphic record calculus set raw terms ranged syntax fl 
modify hl ei case hl 
ei damas milner presentation ml divide set types monotypes ranged ranged follows fl 
hl 
acm transactions programming languages systems 

atsushi ohori formed ffl 
ffl 

gg fl 

ffl 
fl 

formed hhl 
ii hl 

hl 

hhl 
ii hl 

formed fig 

kinding rules ml style type inference system follows indicate fact type restricted monotype usage metavariable set kinds grammar 
ffl 
gg hhl 
ii kind assignment mapping nite set type variables kinds 
set kinding rules 
note secondorder calculus kind denotes subset monotypes type variable ranges monotypes 
polytype formed say generic instance written 

substitution dom ft 
kft 
respects kft 

easily checked formed re nement usual de nition generic instance 
expected property proved lemma 
lemma 
formed closure denoted cls pair 
ft 
ft 

note cls formed type assignment mapping nite set variables 
set typing rules 
type system polymorphic generalization abstraction separated rules gen 
possible combine single rule 
presentation adopted advantage making easier prove various properties induction typing derivations 
lemma allows strengthen type assignment proved routine induction typing derivation lemma 
fx fx example terms name payment section typings name gg acm transactions programming languages systems 
polymorphic record calculus compilation 
var formed const formed app abs fx record fl 
eng fl 
ng dot ffl gg modify ffl gg modify variant hhl ii hl ei case hl 
case hl 
en gen cls fx fig 

typing rules ml style record calculus hhp ound principal typings automatically inferred type inference algorithm shall show 
operational semantics model ml style programming language require stronger property type soundness subject reduction property property evaluation closed term type yields value type 
establish property de ne call value operational semantics evaluation contexts felleisen prove type soundness theorem respect semantics 
semantics serves evaluation model polymorphic programming language records variants 
gives de nitions set values ranged set call value evaluation contexts ranged ev call value axioms 
denotes empty context ev term obtained placing hole context ev 
step evaluation relation ev de ned exist ev ev ev ev ev write ev 
re exive transitive closure ev write ev 
ev show type soundness respect operational semantics rst acm transactions programming languages systems 

atsushi ohori fl 
vg hl vi ev 
ev ev ev fl 
ev 
ev modify ev modify ev hl ev case ev hl 
ei ev ev ev fl 
vng ev ev modify fl 
vng fl 

vng ev case hl vi hl 
en ev ev ev fig 

call value operational semantics de ne type indexed family predicates closed values 
closed type value set de ne value induction follows constant fl 
ng fl 
vn 
hl 
ni hl 
kn ground substitution dom ft 
satis es ft 
closed type assignment 
environment function dom dom dom value environment write term obtained substituting free occurrence function dom write ffx 
vg extension theorem 
ground substitution respects environment proof 
proved induction typing derivation 
proof proceeds cases terms rule derivation 
case rules const de nition 
ground substitution respecting environment 
case var 
suppose 

dom ft 

lemma 
bound type variable convention 
ground substitution respecting ft 
suppose assumption 
kn de nition predicate ss case abs 
suppose derived fx 
element suppose de nition evaluation contexts acm transactions programming languages systems 
polymorphic record calculus compilation 
fx 
vg fx 
vg fx environment induction hypothesis proves case app 
suppose derived suppose de nition evaluation contexts induction hypothesis value de nition evaluation contexts induction hypothesis value de nition predicate case dot 
suppose derived ffl gg 
suppose de nition evaluation contexts induction hypothesis value ground substitution respecting lemma ffl gg 
implies ground record type form 

de nition 



case gen suppose derived cls 


kn kft 

bound type variable convention assume ft 
appear 

ground substitution dom ft 
respects ft 
ground substitution respects kft 
environment 
induction hypothesis proves de nition cases modify variant similar dot 
case case similar app 
cases record follow corresponding induction hypotheses 
theorem corollary 
corollary 
value type 
says typed program closed term type evaluates value type particular typed program produce runtime type error 
explicitly typed calculus corresponding de ne explicitly typed calculus corresponding calculus intermediate language compilation set types kinds kinding rules set terms ranged syntax 
poly fl 
mg modify hl mi case hl 
mi 
polymorphic instantiation poly polymorphic generalization 
development compilation algorithm easier require type speci cation eld selection term eld modi cation term 
set free acm transactions programming languages systems 

atsushi ohori var fx 
tn 

tn fx 
tn formed 
tn respects kft 
ng const formed app abs fx record fl 
mng fl 
ng dot ffl gg modify ffl gg modify variant hhl ii hl mi case hl 
case hl 
mn gen cls fx fig 

typing rules explicitly typed record calculus type variables term written ftv 
polymorphic generalization term de ned ftv poly 
ftv ft 
de nitions terms usual 
set typing rules 
regarding 
nested type application 

poly nested type abstraction determined regarded typing rules derivable correspondence terms 
ml corresponds core xml harper mitchell corresponds sense proved similarly corresponding proof harper mitchell 
proposition 
correspondence terms typing derivations kinded uni cation order develop type inference algorithm need re ne robinson uni cation algorithm incorporate kind constraints type variables 
kinded set equations pair consisting kind assignment set pairs types formed say acm transactions programming languages systems 
polymorphic record calculus compilation 
substitution satis es kinded substitution uni er kinded set equations respects satis es 
general uni er uni er uni er substitution respects de ne kinded uni cation algorithm style gallier snyder transformation 
system rule transforms tuple form sk consisting set type equations kind assignment substitution necessarily formed kind assignment sk 
intended roles components keeps set equations uni ed speci es kind constrains veri ed records solved equations form substitution sk records solved kind constraints veri ed specifying rules treat functions sk sets pairs 
notations 
range functions nite set labels types 
write ffg fff gg denote record type identi ed record kind identi ed respectively 
similar notations variant types variant kinds 
functions write function dom dom dom dom dom 
gives set transformation rules 
kinded set equations 
algorithm rst transforms system sk rules apply 
returns pair reports failure 
theorem proof deferred appendix 
theorem 
algorithm takes kinded set equations computes general uni er exists reports failure 
careful reader may noticed required stronger occur check condition eliminating type variable 
example rule ii required ftv 
requiring stronger condition corresponds disallowing kind assignments having cyclic dependencies ft ffl gg ffl ggg mentioned section 
rationale approach stronger condition increase complexity uni cation algorithm due extra check acyclicity time substitution generated 
uni cation repeatedly performed slow type inference algorithm 
approach allows useless open terms ft ffl int typability closed terms change create problems 
extend type system recursive types regular trees courcelle allowing cyclic kind assignments essential 
buneman ohori possible usefulness recursive programming record polymorphism vasconcelos vasconcelos extends kinded uni cation nite regular trees 
type inference algorithm kinded uni cation milner type inference algorithm extended record polymorphism 
gives algorithm wk acm transactions programming languages systems 

atsushi ohori sk sk ii sk sk ftv iii fff gg fff gg sk jl dom dom fff gg sk fff gg iv ff fff gg sk ff jl dom ff ff ff ff sk fff gg dom dom ftv ff ff ff sk jl dom sk dom dom vi hhf ii hhf ii sk jl dom dom hhf ii sk hhf ii vii hf hhf ii sk hf jl dom hf hf hf hf sk hhf ii dom dom ftv hf viii hf hf sk jl dom sk dom dom ix sk sk notation form appeared left hand side rule assume disjoint 
fig 

transformation rules kinded uni cation 
ously infers typable raw term principal typing sense theorem corresponding explicitly typed term de nition implicitly assumed algorithm fails uni cation recursive calls subterms fail 
term type erasure denoted erase term obtained erasing type information 
de nition erase obtained extending clauses inductively term constructors 
erase 
erase erase erase erase erase modify modify erase erase acm transactions programming languages systems 
polymorphic record calculus compilation 
wk dom failure tn 
sn tn 
sn fresh kfs 
sn kn 
sn wk wk kft ug fx tg fresh 
wk wk wk fresh 
wk fl 
eng wk wk 
kn sn 
fl sn 

sn 

mng fl sn 

sn 

ng wk wk ft ffl ggg fresh 
wk modify wk wk ft ffl ggg fresh modify 
wk case hl 
en wk wk 
kn sn 
ug sn 
hl 
sn 
ng 
fresh kn sn 
case sn 

sn 

sn wk hl wk ft hhl iig hl fresh wk wk cls wk fx poly fig 

type inference algorithm 
acm transactions programming languages systems 

atsushi ohori erase hl hl erase erase poly erase erase erase erase algorithm sound complete sense 
theorem 
wk properties hold respects erase respects respects 
wk fails respects proof deferred appendix 
section showing examples 
example eld selection function name variant term payment algorithm computes data wk name ft ggg name wk ft rst example type variable introduced type inference process irrelevant nal result 
typings 
ft ggg name ft ggg name ft hhp ound ft terms bound type variables abstracted 
results type inference expression containing name payment section 
wk name name name fname joe oce name fname age phone name gg poly name gg name string fname string oce fname joe oce name string fname string age int phone intg fname age phone string string wk payment case payment dollar case payment real int yen xi acm transactions programming languages systems 
polymorphic record calculus compilation 
payment poly case payment real dollar real dollar real case payment real yen inti real real int yen int xi real int 
compilation section develops algorithm compile ml style polymorphic record calculus implementation calculus de ned 
implementation calculus de ne implementation calculus directly indexable vectors switch statements integer tags ecient machine polymorphic record calculi 
shall see index values computed statically compilation algorithm de ned need treat rst class values 
introduce new syntactic category indexes ranged treat specially stands set index variables natural numbers 
set raw terms ranged syntax fc 
cg modify hi ci switch 
fc 
vector representation record index expression retrieving element index value vector switch 
analyzes integer tag variant applies corresponding function value index abstraction index application 
call value operational semantics de ned evaluation contexts ranged ev set values ranged call value context rewriting axioms form ev ev 
say evaluates step written ev ev ev ev ev ev write ev 
re exive transitive closure ev write ev 
ev write gives mutual recursive de nitions set values call value evaluation contexts set context rewriting axioms type system establish correctness compilation algorithm de ned subsection de ne type system implementation calculus 
represent labeled records labeled variants implementation calculus assume total order set labels restrict record type fl 
variant type hl 
satisfy condition acm transactions programming languages systems 

atsushi ohori fv 
hi 
ev 
ev ev ev fv 
ev 
ev modify ev modify ev hi ev switch ev 
ev ev ev ev ev fv 
vng ev ev modify fv 

vn ev fv 

ng ev switch hi 
cn ev ev ev ev ev fig 

call value evaluation operational semantics 
usual choice lexicographical ordering string representations labels 
forms de ne index label record term record type vector ith element eld 
variant variant type value tagged integer manipulated switch statement containing vector functions jth element corresponds function variant 
example record type consists age eld type int name eld type string form int name index name record type 
possible term type includes joe corresponds fname joe age similarly variant type pound variant type real dollar variant type real form real pound index pound type 
switch statement type consists vector functions dollar pound order pound variant type represented corresponds monomorphic term type account polymorphic operations introduce new form types idx index values 
record type variant type type denotes index write index value denoted idx 
example name int name 
type variable idx denotes possible index values depending instantiations unde ned 
set types implementation calculus syntax fl 
hl 
idx idx denotes functions take index value denoted idx yield value type index values rst class objects necessary included index types idx separate types 
set kinds kinding rules type system calculus de ned proof system acm transactions programming languages systems 
polymorphic record calculus compilation 
forms judgments typing judgment idx index judgment kind assignment type assignment previous calculi 
index assignment mapping set index variables index types form idx 
type formed ftv dom type form idx appearing record kind variant kind containing eld type 
formed formed kft 
formed type formed type assignment formed type formed set typing rules 
concerned type inference adopt general natural rule gen proof subject reduction property slightly easier 
write derived system 
easily veri ed formed type system show subject reduction property useful establishing compilation algorithm preserves operational behavior usage machine implement need stronger property type soundness 
type soundness respect operational semantics compiled term follow correctness compilation shall establish 
reduction axioms 
say reduces step written obtained applying reduction axioms subterm reduction relation 
de ned re exive transitive closure 
substitution lemmas useful proving subject reduction theorem 
lemma 
fx proof 
proof induction typing derivation interesting case variable axiom 
cases similar lemma 
suppose fx var axiom 
case trivial 
suppose 

dom ft 
respects kft 
monotype derived gen kft 
ft 
appear lemma lemma 
lfi idx idx proof 
induction typing derivation show case rule index 
cases modify variant acm transactions programming languages systems 

atsushi ohori ivar lfi idx idx iconst idx fl 
ng iconst idx hl 
var fx fx formed const formed app abs fx lfi idx idx idx idx record fc 
cng fl 
ng index ffl gg idx modify ffl gg idx modify variant hhl ii idx hi ci switch hl 
switch 
cn gen kft 
ng 
ftv fx fig 

typing rules implementation calculus 
index fc 
cng modify modify fc 
cng fc 

cng switch switch hi ci 
cn fig 

reduction rules implementation calculus acm transactions programming languages systems 
polymorphic record calculus compilation 
shown similarly 
cases follow directly induction hypothesis 
suppose lfi idx derived rule index lfi idx ffl gg lfi idx idx 
induction hypothesis cases considered 
suppose ffl gg idx 
typing rule second suppose de ned dom 
case idx typing rule 
theorem 


proof 
sucient show theorem monotypes 
proof similar theorem substitution lemmas 
compilation algorithm develop compilation algorithm type information obtained type inference 
type inference algorithm converted term explicitly typed term contains type information necessary compilation 
compilation algorithm algorithm compile terms terms 
explained strategy compiling polymorphic functions containing polymorphic record operations insert appropriate index abstractions 
strategy polymorphic function type compiled term having type obtained inserting necessary index abstractions indicated kinded type quanti ers 
establish relationship formally type source code type compiled code rst de ne auxiliary notions 
set index types contained kind denoted de ned set 
fff gg jl dom hhf ii jl dom de nition extended kind assignments follows 

tn kg type corresponding type de ned 

idx 
idx idx 
idx set index types 
tn ordered idx precedes idx particular monotype example 
ffa bool ffa gg acm transactions programming languages systems 

atsushi ohori ffa bool ffa gg idx idx idx de nition extended type assignments follows fx jx dom kind assignment de ne index assignment lk determined lk fi idx 
compilation algorithm algorithm takes lk computes term implementation calculus 
lk property idx lk pair mentioned algorithm unique deterministic algorithm 
compilation preserves types shown theorem 
theorem 
lk succeeds lk proof 
induction structure show cases variables eld selection generalization 
cases variants modify expressions shown similar eld selection 
cases follow corresponding induction hypotheses 

suppose 




de nition 
idx 
idx 
idx 

rule var lk idx 
idx 
mentioned algorithm 
idx type variable dom property lk idx lk type variable case lk idx 
algorithm succeeds 
im lk 
im suppose ffl gg 
induction hypothesis lk lk mentioned algorithm 
type variable dom 
ffl gg fff gg contains property lk idx lk type variable integer case lk idx 
lk succeeds lk poly suppose poly 

cls 


idx 
idx lk lk fi idx 
idx 
fresh 
induction hypothesis lk lk lk poly succeeds 
im applying rule lk repeatedly lk 
im idx 
idx lk formed ftv lk acm transactions programming languages systems 
polymorphic record calculus compilation 


idx 
idx lm 
tn unde ned idx 
im fx fl 
mng fc 
mn unde ned idx modify unde ned idx modify hl mi unde ned idx hi ci case hl 
mn switch 
mn poly 
tn 
tn idx idx lm 
tn lfi idx 
idx lm 
im fresh 
im fx fig 

compilation algorithm 
acm transactions programming languages systems 

atsushi ohori 
lk 
desired 
combining result theorem 
corollary 
wk lk succeeds lk result shows compilation algorithm maps term type term type compilation preserves monotypes 
eliminating vacuous type variables typing algorithm translates kinded typing kinded typing serve compilation algorithm subtle point taken care 
related problem coherence breazu tannen 
shown ohori damas milner system ml coherent respect core xml true relationship 
see harper mitchell related discussion 
source failure coherence free type variables typing derivation appear type type assignment result typing 
type variables cause problem applying compilation algorithm developed previous subsection 
see consider raw term 
type inference algorithm produces typing ft ffl corresponding typing ft ffl int kinded type variable introduced typecheck polymorphic eld selection appear type assignment result type instantiated 
consequence closed term translated open term containing free index variable denoting position determined 
solution problem re ne milner style type inference algorithm section eliminate redundant vacuous type variables 
say type variable vacuous dom 
assume prede ned base type choice unimportant 
typing vacuous type variable typing ftv 
written ft kg 
de ne canonical instance follows ffg fff gg hf hhf ii eliminate typing applying kinded substitution 
set vacuous type variables mutual cyclic dependency acm transactions programming languages systems 
polymorphic record calculus compilation 
sequence 
ftv repeating process 
obtain sequence kinded substitution 
de ne canonical instantiation kinded substitution kn 

de nition results easily proved 
lemma 
canonical instantiation typing respects lemma 
corollary 
canonical instantiation shows set vacuous type variables cyclic dependency eliminate ecting typing property term 
call canonical instance identify program closed typing form re ne type inference algorithm de ned previous section just type abstraction top level takes canonical instance inferred typing exists reports type error 
program closed typing derivation contain kind assignment cyclic dependency process change typability programs 
program form re ned type inference algorithm produces closed typing poly regard closed typings units separate compilation 
re nement compilation algorithm previous subsection serves compilation algorithm corollary 
corollary 
typed program wk succeeds succeeds show examples compilation 
term name type inference process produces program poly name gg gg program compilation algorithm produces result poly name gg typing gg idx name program acm transactions programming languages systems 

atsushi ohori name name name fname joe oce name fname age phone converted program seen previous section name gg poly name gg name string fname string office fname joe oce name string fname string age int phone intg fname age phone compilation algorithm produces result name name joe name expected typing evaluates joe 
example program involving polymorphic variant vacuous type variable elimination 
program point fx gi case point square square polar ri converted program point fx real poly fx gi fx real case point fx real fr gi fx real square square polar fr ri compilation algorithm produces code point hi gi switch point square square note vacuous type variable elimination properly performed polar branch case statement unused eld extension compiled index expression default index value 
correctness compilation section shown compilation algorithm preserves typing 
section shows compilation algorithm preserves operational behavior program 
shown type system sound respect operational semantics preservation operational behavior establish type system sound respect operational semantics compiled code terms base types desired property simply original term compiled term evaluate constant value 
need generalize arbitrary types including 
strategy apply idea logical relations lift relationship arbitrary types 
acm transactions programming languages systems 
polymorphic record calculus compilation 
closed type term set erm set fm de ne type indexed family relations fr term erm induction follows 
conditions holds fl 
fl 
fc 
cn hl 
hl hi 

idx 
idx ground substitution satisfying ft 


js idx 
note type soundness theorem theorem subject reduction theorem theorem term erm term erm furthermore de nition closed type assignment environment function dom dom dom term environment function dom dom dom erm formed closed index assignment 
environment uniquely extended function de ned dom dom setting value jl dom 
write extension dom 
relation extended environments 
relation environments environments dom theorem proof deferred appendix 
theorem 
typing 
lk ground substitution respects pair environments erase lk program 
corollary 
typed program wk succeeds succeeds de ne set observable types syntax fl 
hl 
acm transactions programming languages systems 

atsushi ohori relation essentially identity modulo representation records variants program observable type compiled term evaluates essentially value 

implementation polymorphic typing compilation method article extended standard ml polymorphic record operations implemented compiler called sml sml extension standard ml new jersey compiler appel macqueen :10.1.1.55.9444
extended language deals features standard ml including pattern matching weak type variables explicit type declarations freely mixed polymorphic record operations 
preserves ef ciency original compiler extends polymorphic manipulation records 
sml produces code monomorphic record operations 
polymorphic manipulation records necessary perform extra function application pass necessary index values 
occur polymorphic record functions instantiated 
believe overhead due index applications cases negligible 
simple iteration example function name show meaningful di erence execution speed compared corresponding monomorphic function written standard ml new jersey 
calls name sml take seconds number calls name fname string age intg string standard ml new jersey takes seconds 
implementation article claim method provides theoretically sound practical basis extending ml record polymorphism 
sml include polymorphic variants 
current de nition standard ml couples monomorphic variants de ned datatype declarations language features including user de ned recursive types pattern matching constructor binding 
consequence polymorphic variants requires substantial language changes new class syntactic objects role largely overlaps ml datatypes 
include essential redesign standard ml 
limitation current version sml evaluate inside index abstraction necessary preserve order evaluation 
current version sml author adopted strategy implement index abstraction ordinary closure creation mechanism new jersey system 
implement completely operational semantics de ned article necessary develop new evaluation scheme index abstraction index application 
shall discuss possible strategies overcome limitations 
rest section outlines extension standard ml implementation sml compiler 
acm transactions programming languages systems 
polymorphic record calculus compilation 
extension standard ml standard ml type expressions extended kind constraints 
done introducing syntax type variables having record kind fl ty 
ty fl ty 
ty represent type variable equality type variable kind assignment form fa ffl ty 
ty gg 
fb ffl ty 
ty gg 
respectively ty 
ty restricted equality types 
sml syntax appear allowed 
standard ml contains records eld selection 
syntax record formation identical article 
addition ml provides pattern record operations pat 
fl pat 
fl pat 
pat part ml syntax exible records ml parlance confused 
syntax eld selection function explained 
sml patterns expressions freely type speci cations shown example fun firstname fname val firstname fn fname shows interactive session sml user input prompted system output printed format val value type 
addition sml introduces term constructor fl 
eng nested eld modi cation modify 
modify 
syntax chosen compatible rest language de nition 
shows programming examples 
second half example demonstrates usefulness record polymorphism data intensive applications database programming 
particular function demonstrates sql style database query language cleanly integrated polymorphic record calculus 
interested reader referred buneman ohori discussion polymorphism type inference database programming 
implementation strategies implementation done modifying standard ml new jersey compiler version 
main modi cation consists replacement type inference module new incorporates kinded uni cation compilation algorithm re nement pattern match compilation value binding 
new type inference module closely follows algorithm article additional re nements standard ml equality types weak acm transactions programming languages systems 

atsushi ohori simple examples fun point point point val fn int 
int 
val int int color green val color green color string int int int database examples fun wealthy salary 
val wealthy fn salary int 
bool fun young age val young fn age int 
bool fun wealthy andalso young val fn age int salary int 
bool fun select display pred fold fn pred display nil val select fn list bool list fun select name val fn age int name salary int 
list list fig 

interactive programming session sml polymorphism 
integrate features actual kind type variable sml consists product record variant kind equality ag weakness measure 
re nement record polymorphism freely mixed features 
needed re ne compilation pattern matching value binding 
consider example simple binding val independently compiler produce binding types fa bg fb bg index abstraction insertion polymorphic generalization done separately corresponding portion code 
achieve ect sml compiler transforms ml value binding form val pat expr pat pattern containing variables fx 
xn form val 
expr fn pat 
fn pat xn inner binding ordinary binding transformed method described article 
compiler transforms outer val binding acm transactions programming languages systems 
polymorphic record calculus compilation 
eliminating vacuous type variables separately typing variable performing index abstraction polymorphic type generalization component corresponding separately nally translating binding implementation calculus 
actual implementation steps done step type information original term 
example example transformed binding val default index value introduced process vacuous type variable elimination explained earlier 
similar treatment necessary mutually recursive function de nitions form fun pat expr 
fn pat transformed code val 
rec pat expr 
fn pat 
rec pat expr 
pat expr construct mutually recursive functions polymorphic generalization 
binding transformed term implementation calculus similar way case complex value binding explained 
treatment sml allows record polymorphism freely mixed arbitrary complex value binding mutually recursive function de nitions 
prototype sml system available kyoto university 
interested reader copy readme le ftp kyoto ac jp directory pub member ohori anonymous ftp consult web page www kyoto ac jp ohori html 

polymorphic type discipline records variants extension girard reynolds second order lambda calculus de ned ml style polymorphic record calculus corresponds predicative second order system 
type system ml style record calculus shown sound respect operational semantics 
calculus type inference algorithm proved soundness completeness respect polymorphic type system 
developed ecient compilation method ml style polymorphic record calculus 
compilation method translates type correct term polymorphic record calculus term calculus records represented directly indexable vectors variants represented values tagged natural number index vector functions switch statement 
correctness acm transactions programming languages systems 

atsushi ohori compilation algorithm shown applying idea logical relation set desired relation operational behavior polymorphic record calculus implementation calculus 
results standard ml extended polymorphic record operations full scale prototype compiler implemented 
number issues considered 
brie mention 
complete implementation 
mentioned previous section major limitations current sml implementation lacks polymorphic variants faithful operational semantics de ned article evaluate inside index abstraction 
basic techniques implementing polymorphic variants required polymorphic records technical diculty introducing 
fact pure variants encoded records regarding variant type hl 
fl 
tg encoding variant constructors case statements analogous standard encoding booleans conditional statements 
implemented implementation mechanism polymorphic records 
labeled variant type standard ml coupled user de ned recursive types 
coupling works labeled variants restricted monomorphic incompatible polymorphic manipulation labeled variants possibility polymorphic manipulation eliminated 
incorporate polymorphic variants standard ml need redesign language separate mechanism labeled variants user de ned recursive types 
currently considering proper syntax corresponding formal de nition standard ml polymorphic labeled variants 
challenging re ne sml faithful operational semantics de ned article 
developed complete implementation technique believe possible develop reasonably ecient system evaluates inside index abstractions treating index abstraction index application specially 
brie explain possible strategy 
observation implementation polymorphic variants restrict attention polymorphic record operations 
compilation algorithm property produces implementation term form occurs inside ordinary lambda abstraction evaluation involve evaluation evaluation done follows 
evaluating system rst allocates dummy entry environment evaluates yield closure environment contains closure saved template 
application function actual index value implemented making copy template closure updating entry environment needed develop method propagate technique nested index abstraction form 

author intends develop systematic method achieve desired semantics useful various type program specialization discussed 
type inference program specialization 
compilation method acm transactions programming languages systems 
polymorphic record calculus compilation 
article characterized specialization polymorphic functions type information 
respect shares motivation paradigm intentional type analysis harper morrisett 
framework runtime type analysis general 
example certain features overloading comfortably represented framework 
interesting issue method combined framework 
papers ecient implementation polymorphic languages explicit type information 
examples include polymorphic unboxed calculus ohori specialize polymorphic functions size information obtained type inference mixed representation optimization leroy inserting appropriate box unbox coercions guided type information tag free garbage collection tolmach translating raw term explicitly typed second order term specialization haskell type classes wadler blott type information hall peterson jones list representation optimization hall shao 
program translations approaches appear share general structure detailed comparison may shed light general property type inference approach program specialization 
compilation method may applied optimizing soft type system cartwright fagan wright cartwright 
soft type system types implicitly treated elements variant type 
checking type tag runtime approach allows exible typing conventional static typing 
compilation method polymorphic variants reduce cost runtime check 
compilation calculus subtyping 
extend compilation technique polymorphic type discipline subtyping important paradigm exible treatment labeled records labeled variants 
exibility subsumption rule sub inherent diculty compiling calculus containing rule 
see diculty consider expression fa abc trueg fb true abc boolean expression 
existence subsumption rule expression type fb 
actual set labels value denoted expression depends value denoted set label statically determined 
impossible determine statically necessary index value program subsumption rule typing judgment form fl 
longer implies denotes record value having exact type fl 
similar problem arises compiling calculus allows heterogeneous collections buneman ohori 
observation suggests compilation incorporate degree dynamic type testing runtime 
approach combine method intensional acm transactions programming languages systems 

atsushi ohori type analysis harper morrisett 
application labeled data structures 
exible typing compilation method record polymorphism may applicable systems labels play important role 
common lisp steele parameters function may labeled 
straightforward model simple labeled parameters labeled records 
common lisp allows optional arguments default values 
feature easily modeled simple type discipline 
approach represent features record calculus extend optional eld selection operation behaves record containing eld evaluates default value polymorphic type discipline compilation method extended support construct 
kaci developed lambda calculus supports exible labeled parameter passing mechanism labeled currying labeled partial application allowed 
extended optional arguments developed compilation method 
interesting research investigate possibility combining approach 
approach may applicable object oriented programming 
calculus record subtyping considered formal model object oriented programming class represented record type object represented record containing methods method invocation done eld selection 
model feature method inheritance achieved exible typing eld selection 
kinded typing allows similar exible typing eld selection believe second order record calculus extended recursive types features serve appropriate basis type systems object oriented programming 
kinded typing complicated interaction function type ecient compilation algorithm calculus believe record calculus properly extended simpler practical alternative calculus subtyping 
appendix proofs major theorems theorem 
algorithm takes kinded set equations computes general uni er exists reports failure 
proof 
rst show algorithm returns kinded substitution general uni er kinded set equations 
easily veri ed transformation rule preserves property tuple sk 
sk formed kind assignments formed formed substitution dom dom sk dom sk dom 
establish property holds tuple transformation rule preserves properties tuples 
acm transactions programming languages systems 
polymorphic record calculus compilation 
kinded substitution respect satis es respect sk 
set uni ers sk 
case rule trivial ix follow assumptions 
rules vi viii shape rules ii iv respectively proofs corresponding proofs 
show properties rules ii iv 
rule ii 
sk sk ftv property 
satisfy respect 
satis es formed formed respects property premise rule respects sk respects sk property 
substitution 
satis es satis es kind assignment kinded substitution 
suppose satis es dom respects respects 
similarly respects sk respects sk 
uni er sk uni er sk 
rule iii 
fff gg fff gg sk jl dom dom fff gg sk fff gg property 
satisfy jl dom dom respect fff gg satis es respects fff gg fff gg property premise rule respects sk 
respects sk fff gg property 
substitution satisfying satis es satis es 
kind assignment kinded substitution 
dom respects respects 
similarly respects sk respects sk 
satis es jl dom dom fff gg fff gg fff gg fff gg 
proves property 
rule iv 
acm transactions programming languages systems 

atsushi ohori ff fff gg sk ff jl dom ff ff ff ff sk fff gg dom dom ftv ff property 
respect ff satisfy ff jl dom ff ff ff satis es ff respects dom dom satis es jl dom fff gg 
respects fff gg property premise rule respects sk respects ff sk 
proves property 
property 
substitution satisfying ff satis es satis es ff ff 
kind assignment kinded substitution 
ff dom respects respects ff 
similarly respects sk respects ff sk 
proves property 
conclude proof correctness algorithm 
kinded set equations 
suppose algorithm terminates 
sk transformed sk repeated applications transformation rules 
property trivially holds 
kinded substitution dom dom respects trivially satis es 
property respects sk 
uni er sk 
property uni er 
uni er 
property uni er sk 
uni er sk general 
conversely suppose algorithm fails 
transformed sk sk rule applies sk 
clear de nition rule sk uni er property uni er 
termination proved showing transformation rule decreases complexity measure lexicographical pair consisting size set dom total number occurrences type constructors including base types theorem 
wk properties hold respects erase respects respects 
wk failure respects acm transactions programming languages systems 
polymorphic record calculus compilation 
proof 
property rst statement follows directly proof property relationship type systems 
routine matter show algorithm fails term typing term 
follows show properties rst statement 
proof induction structure show cases cases modify hl similar case cases essentially corresponding proof ml damas milner 
case suppose wk 

kfs 



fresh 

property 
trivially respects 
respects ft 

property 
suppose respects bound type variable convention assumption 
fresh assume 

appears dom fs jt dom 
dom ft 


sn 
respects 

respects kfs 

proves property 
case suppose algorithm succeeds 
wk ft ffl ggg fresh wk 
property 
theorem respects ffl gg 
induction hypothesis respects lemma respects lemma 
rule dot 
property 
suppose respects ffl gg 
induction hypothesis respects 
ffl gg 
consider fresh ffl gg dom 
respects ft ffl ggg 

uni er ft ffl ggg 
theorem respects desired 
case hl suppose algorithm succeeds hl wk wk hl ft hhl iig fresh 
property 
induction hypothesis ft hhl iig hhl ii typing rule ft hhl iig hl acm transactions programming languages systems 

atsushi ohori property 
suppose respects hl typing rules hhl ii 
induction hypothesis respects 
fresh hhl ii 
respects ft hhl iig 
desired 
case suppose wk 
wk cls wk fx poly property 
induction hypothesis respects rule gen induction hypothesis respects fx show dom formed de nition type inference algorithm uni cation algorithm appear ftv dom 
suppose 
simple induction derivation shown ftv ftv dom 
case formed respects lemma respects lemma 
typing rule property 
suppose respects cls fx de nition cls write ft 
ft 

induction hypothesis respects 
de nition cls written ft 
ft 

bound type variable convention ft 
ft 

respects ft 

restriction dom ft 
substitution 

show formed ft 
formed show ftv ft 

suppose ftv 
ftv ftv 
de nition 
assumption ftv 
ft 

shown induction construction 
ft 
ft 
formed 
similar argument shown formed ft 
ft 
respects ft 



lemma fx 

acm transactions programming languages systems 
polymorphic record calculus compilation 
fx respects respects apply induction hypothesis conclude respects 
proves property case expression 
theorem 
typing 
lk ground substitution respects pair environments erase lk proof 
induction structure case 

suppose 
type system 
kn 


respects kft 

idx 
idx 
lk idx 

suppose lk 

im assumption 
kn de nition lk 
respects 
respects kft 

ground substitution respecting ft 
de nition lk 
im desired 
case suppose fx suppose lk lk fx 
erase 
bound variable convention de nition evaluation contexts lk lk lk 
pair related elements 

suppose type soundness theorem theorem subject reduction theorem theorem terms types respectively de nition evaluation contexts lk lk fx 
lk fx 
lk 
fx 
fx 
fx induction hypothesis lk case suppose suppose lk lk lk 
induction hypotheses erase erase de nition relations erase case fl 
mng 
suppose fl 
mng fl 

suppose acm transactions programming languages systems 

atsushi ohori lk fl 
mng fc 
cn 
erase 
de nitions reduction systems fl 
fc 
cn furthermore fl 
fl 

similarly fc 
cn 
induction hypotheses fl 
fc 
cn fl 
ng case suppose ffl gg 
suppose lk lk lk idx 
erase 
induction hypothesis lk lk lk lk 
suppose lk ffl gg ground record type form 

de nition 



index proves lk case poly 


idx 
idx suppose poly 
kft 
suppose lk poly 
im kfi idx 
idx lm 
erase 
ground substitution dom ft 
respects ft 
respects kft 
induction hypothesis kft 
ng kft 
kn lk fi idx 
idx kft 
ng lk fi idx 
idx lm 
kft 
ng 
lk de nition evaluation 
lk lk 
type variable type system lk appear subterm forms fc 
modify fc 
switch hi 

lk 
property holds subject reduction property theorem violated 

lk 

im lk 


lk 
induction hypothesis de nition relation implies 
im 
kn acm transactions programming languages systems 
polymorphic record calculus compilation 
case suppose fx erase erase lk lk fx 
desired result follows induction hypotheses 
cases modify hl mi similar acknowledgments author minamide careful reading draft article providing useful comments jacques helpful discussions 
author anonymous referees helpful comments improving presentation article 
appel macqueen 
standard ml new jersey 
proceedings rd international symposium programming languages logic programming lecture notes computer science vol 

springer verlag berlin 
barendregt 
lambda calculus syntax semantics rev ed 
studies logic foundations mathematics vol 

north holland amsterdam 
breazu tannen coquand 
extensional models polymorphism 
inf 
comput 

breazu tannen coquand gunter scedrov 
inheritance explicit coercion 
inf 
comput 

bruce meyer mitchell 
semantics second order lambda calculus 
inf 
comput 

buneman jung ohori 
powerdomains generalize relational databases 
theor 
comput 
sci 

buneman ohori 
polymorphism type inference database programming 
acm trans 
database syst 
appear 
cardelli 
semantics multiple inheritance 
inf 
comput 

cardelli 
extensible records pure calculus subtyping 
theoretical aspects object oriented programming gunter mitchell eds 
mit press cambridge mass 
cardelli mitchell 
operations records 
proceedings mathematical foundation programming semantics 
lecture notes computer science vol 

springer verlag berlin 
cardelli wegner 
understanding types data abstraction polymorphism 
acm comput 
surv 
dec 
cartwright fagan 
soft typing 
proceedings acm conference programming language design implementation 
acm new york 
connor dearle morrison brown 
object addressing mechanism statically typed languages multiple inheritance 
proceedings acm oopsla conference new orleans la 
acm new york 
courcelle 
fundamental properties nite trees 
theor 
comput 
sci 

damas milner 
principal type schemes functional programs 
proceedings acm symposium principles programming languages 
acm new york 
fagin nievergelt pippenger strong 
extendible hashing fast access method dynamic les 
acm trans 
database syst 

felleisen friedman kohlbecker duba 
syntactic theory sequential control 
theor 
comput 
sci 

acm transactions programming languages systems 

atsushi ohori 
mishra 
type inference subtypes 
proceedings esop 
lecture notes computer science vol 

springer verlag berlin 

label selective lambda calculus optional argument compilation method 
rims preprint research 
mathematical sciences kyoto univ kyoto japan 
gallier snyder 
complete sets transformations general uni cation 
theor 
comput 
sci 

kaci 
typed polymorphic label selective calculus 
proceedings acm symposium principles programming languages 
acm new york 
girard 

une extension de interpretation de odel analyse son application elimination des coupures dans analyse th eorie des types 
nd scandinavian logic symposium 
north holland amsterdam 
hall 
hindley milner type inference optimize list representation 
proceedings acm conference lisp functional programming 
acm new york 
hall hammond peyton jones wadler 
type class haskell 
tech 
rep univ glasgow glasgow scotland 
harper mitchell 
type structure standard ml 
acm trans 
program 
lang 
syst 

harper morrisett 
compiling polymorphism intensional type analysis 
proceedings acm symposium principles programming languages 
acm new york 
harper pierce 
record calculus symmetric concatenation 
proceedings acm symposium principles programming languages 
acm new york 
jategaonkar mitchell 
type inference extended pattern matching subtypes 

inform 

leroy 
unboxed objects polymorphic typing 
acm symposium principles programming languages 
acm new york 
milner 
theory type polymorphism programming 
comput 
syst 
sci 

milner tofte harper 
de nition standard ml 
mit press cambridge mass mitchell 
type inference type containment 
semantics data types 
lecture notes computer science vol 

springer verlag berlin 
mitchell 
type systems programming languages 
handbook theoretical computer science van leeuwen ed 
mit press cambridge mass 
ohori 
simple semantics ml polymorphism 
proceedings acm ifip conference functional programming languages computer architecture london england 
acm new york 
ohori 
semantics types database objects 
theor 
comput 
sci 

ohori 
compilation method ml style polymorphic record calculi 
proceedings acm symposium principles programming languages 
acm new york 
ohori buneman 
type inference database programming language 
proceedings acm conference lisp functional programming snowbird utah 
acm new york 
ohori buneman 
static type inference parametric classes 
proceedings acm oopsla conference new orleans la 
acm new york 
extended version theoretical aspects object oriented programming gunter mitchell eds 
mit press cambridge mass 
ohori 
polymorphic unboxed calculus machine polymorphic languages 
rims preprint research 
mathematical sciences kyoto univ kyoto japan 
acm transactions programming languages systems 
polymorphic record calculus compilation 
peterson jones 
implementing type classes 
proceedings acm conference programming language design implementation 
acm new york 
emy 
typechecking records variants natural extension ml 
proceedings acm symposium principles programming languages 
acm new york 
emy 
typing record concatenation free 
proceedings acm symposium principles programming languages 
acm new york 
emy 
ecient representation extensible records 
proceedings acm sigplan workshop ml applications 
acm new york 
emy 
type inference records natural extension ml 
theoretical aspects object oriented programming gunter mitchell eds 
mit press cambridge mass 
reynolds 
theory type structure 
paris programming 
springer verlag berlin 
robinson 
machine oriented logic resolution principle 
acm 
shao reppy apple 
unrolling lists 
proceedings acm conference lisp functional programming 
acm new york 

type inference subtypes 
proceedings acm symposium principles programming languages 
acm new york 
steele 
common lisp language 
digital press burlington ma 
tolmach 
tag free garbage collection explicit type parameters 
proceedings acm conference lisp functional programming 
acm new york 
vasconcelos 
process calculus approach typed concurrent objects 
ph thesis dept computer science keio univ yokohama japan 
wadler blott 
ad hoc polymorphism ad hoc 
proceedings acm symposium principles programming languages 
acm new york 
wand 
complete type inference simple objects 
proceedings nd ieee symposium logic computer science ithaca new york 
ieee new york 
wand 
corrigendum complete type inference simple object 
proceedings rd ieee symposium logic computer science 
ieee new york 
wand 
type inference records concatenation simple objects 
proceedings th ieee symposium logic computer science 
ieee new york 
wright cartwright 
practical soft type system scheme 
proceedings acm conference lisp functional programming 
acm new york 
received april revised september accepted october acm transactions programming languages systems 
