recovery distributed systems optimistic message logging checkpointing david johnson willy zwaenepoel department computer science rice university box houston texas message logging checkpointing provide fault tolerance distributed systems process communication messages 
presents general model reasoning recovery systems 
model prove set recoverable system states occurred single execution system forms lattice unique maximum recoverable system state decreases 
model algorithm determining maximum recoverable state prove correctness 
algorithm utilizes logged messages checkpoints finds maximum recoverable state possible 
previous recovery methods optimistic message logging checkpointing considered existing checkpoints may find maximum state 
furthermore utilizing checkpoints messages received process checkpointed may need logged 
algorithm adds communication overhead system previous methods 
model algorithm message logging protocol pessimistic optimistic full generality required optimistic logging protocols 
supported part national science foundation cda ccr office naval research contract onr 
message logging checkpointing provide fault tolerance distributed system process communication messages 
message received process saved message log stable storage state process occasionally saved checkpoint stable storage 
coordination required checkpointing different processes message logging checkpointing 
execution process assumed deterministic received messages processes assumed execute fail processors 
typically systems pessimistic protocol message logging 
message synchronously logged received blocking receiver message logged blocking receiver attempts send new message received messages logged :10.1.1.134.8089
recovery pessimistic message logging straightforward 
failed process reloaded checkpoint messages originally received process checkpoint written replayed log order received failure 
messages process state originally receiving 
messages sent process duplicates sent failure ignored 
systems optimistic message logging protocol 
receiver message blocked messages logged asynchronously receipt example grouping messages writing stable storage single operation 
current state process recovered messages received process checkpointed logged 
processes may depend states recovered failure recovery optimistic message logging difficult pessimistic logging 
dependencies processes arise communication system part state process may included message 
process receives message current state process depends state sender message sent 
process received message failed process sent state latest state recovered orphan process time failure 
recovery orphan process rolled back state message caused orphan received 
rolling back process may cause processes orphans rolled back recovery 
domino effect uncontrolled propagation process rollbacks avoided guarantee progress system spite failures 
recovery optimistic message logging construct combination process states recovered process orphan 
optimistic logging protocols avoid synchronization delays message logging outperform pessimistic logging protocols absence failures 
recovery procedure required optimistic logging protocols complex pessimistic protocols failure occurs 
presents general model reasoning distributed systems message logging checkpointing provide fault tolerance 
model prove set recoverable system states occurred single execution system forms lattice unique maximum recoverable system state decreases 
model algorithm determining unique maximum recoverable system state prove correctness 
algorithm finds maximum recoverable system state utilizing logged messages checkpoints 
previous fault tolerance methods optimistic message logging checkpointing considered existing checkpoints may find maximum state 
furthermore utilizing checkpoints messages received process checkpoint recorded may need logged 
algorithm adds communication overhead system optimistic methods 
model algorithm message logging protocol pessimistic optimistic full generality required optimistic logging protocols 
section presents model reasoning systems section describes algorithm finding maximum recoverable system state 
algorithm recover failure system discussed section 
section relates message logging checkpointing methods section summarizes contributions 
model section presents general model reasoning behavior correctness recovery methods message logging checkpointing 
model dependencies states processes result communication system 
state process represented dependencies state system represented collection process states 
model assume particular message logging protocol applies equally systems pessimistic optimistic message logging methods 
processes assumed execute fail processors connected communication network reliable delivery messages network required 
process states execution process divided separate intervals messages process receives 
interval called state interval process deterministic sequence execution started receipt message process 
execution process single state interval completely determined state process time message received contents message 
process may send number messages processes state interval 
process state interval process uniquely identified sequential state interval index simply count number messages received process 
processes may dynamically created destroyed process identified globally unique process identifier 
logically identifiers assumed range system processes 
creation process modeled receipt message number process termination modeled receipt final message sequence real messages received process 
messages sent process tagged current state interval index 
process receives message sent process state process depends state process time message sent 
state process represented current set dependencies processes 
process dependencies represented dependency vector hffi hffi ffi ffi 
ffi total number processes system 
component process dependency vector ffi set maximum index state interval process process currently depends 
process dependency state interval process ffi set possible state interval indices 
component process dependency vector set index process current state interval 
dependency vector process names state intervals process directly depends resulting receipt message sent state interval sending process 
maximum index state interval process process depends recorded execution process state interval deterministic state interval naturally depends previous intervals process 
processes cooperate maintain dependency vectors tagging messages sent current state interval index sending process remembering process maximum index tagging message received process 
single execution system current dependency vector process uniquely determined state interval index process 
component dependency vector process decrease failure free execution system 
system states system state collection process states process system 
process states need existed system time 
system state said occurred execution system component process states individually occurred execution 
system state represented theta dependency matrix ffi ffi ffi ffi 
ffi ffi ffi ffi 
ffi ffi ffi ffi 
ffi 
ffi ffi ffi 
ffi row ffi dependency vector state process included system state 
component process dependency vector index current state interval diagonal dependency matrix ffi set current state interval index process contained system state 
set system states occurred single execution system 
system history relation oe partial order set system state precedes relation occurred execution 
relation oe expressed terms state interval index process shown dependency matrices representing system states 
definition ff fi system states ff fi oe system history relation differs lamport happened relation orders system states result events events state intervals started receipt message constitute events 
illustrate partial order shows system communicating processes 
horizontal lines represent execution process time progressing left right 
arrow processes represents message sent process number arrow gives index state interval started receipt message 
message received process message message received process message consider possible system states state message process process process process time system history partial order 
message message received 
received message state message received message 
system states represented dependency matrices fl 


fl fl 


fl system states incomparable system history relation 
shown comparison circled values diagonals dependency matrices 
execution system state state occurred message message received 
system history lattice system state describes set messages received process 
system states meet written represents system state occurred execution system process received messages received expressed terms dependency matrices representing system states copying row corresponding row original matrices depending matrix smaller entry diagonal row 
definition ff fi system states meet oe oe ff ff fi fi likewise system states join written atb represents system state occurred execution system process received messages received expressed terms dependency matrices representing system states copying row corresponding row original matrices depending matrix larger entry diagonal row 
definition ff fi system states join atb ff ff fi fi continuing example section illustrated meet join states represented dependency matrices 





theorem introduces system history lattice formed set system states occurred single execution system ordered system history relation 
theorem set ordered system history relation forms lattice 
greatest lower bound upper bound proof follows directly construction system state meet join definitions 
consistent system states process states composing system state need existed time system states may represent impossible state system 
system state called consistent seen instant outside observer preceding execution system initial state regardless relative speeds component processes 
recovery failure system recovered consistent system state 
ensures total execution system equivalent possible failure free execution 
model process communication messages processes execute deterministically received messages system state consistent component process received message sent system state sent deterministic execution sender 
process execution deterministic state interval true process received message sent sender current state interval contained system state 
messages shown system state sent received cause system state inconsistent 
messages handled normal mechanism reliable message delivery underlying system 
particular suppose message received process state process observed form system state suppose process sent message message show receipt message received system state state inconsistent message message shown received sent 
message received state effect message seen consistent 
definition consistent system state expressed terms dependency matrices representing system states 
system state consistent process process depends state interval process process current state interval 
dependency matrix column element column row larger element diagonal matrix column row process current state interval index 
definition ffi system state consistent ffi ffi example consider system processes execution shown 
state process observed curve intersects line representing execution process resulting system state represented dependency matrix ffi fl fl system state consistent process received message state interval process sent process current state interval 
message sent process sent process deterministic execution 
terms dependency matrix shown ffi greater ffi system state represented matrix consistent 
set set consistent system states occurred single execution system 
consistent theorem set ordered system history relation forms sublattice system history lattice 
proof ff fi system states definition ff ff fi fi suffices show atb process process process time inconsistent system state 
oe 
definition occurred execution system element dependency vector process decrease execution process oe min ff fi oe ff oe fi oe ff ff oe fi fi oe min ff fi oe oe 
definition ff fi max ff fi 
atb message logging checkpointing system executes messages recorded stable storage message log 
message called logged data index state interval started process received recorded stable storage 
logged messages remain stable storage longer needed recovery possible failure system section 
predicate logged oe true message started state interval oe process logged 
process created initial state saved stable storage checkpoint state interval 
process independently checkpointed times execution 
checkpoint remains stable storage longer needed recovery possible failure system section 
state interval oe process checkpoint process stable storage state interval index larger oe 
definition effective checkpoint state interval oe process checkpoint stable storage process largest state interval index ffl ffl oe 
state interval process called stable recreated demand information currently stable storage 
true received messages started state intervals process state interval recorded effective checkpoint logged 
predicate stable oe true state interval oe process stable 
definition state interval oe process stable ff ffl ff oe logged ff ffl index state interval process recorded effective checkpoint state interval oe 
stable process state interval oe recreated restoring process effective checkpoint state interval index ffl replaying sequence logged messages state intervals ffl oe ascending order 
checkpointing process need coordinated logging messages received process 
particular process may checkpointed time state interval recorded checkpoint stable regardless previous messages received process logged 
state interval oe process stable effective checkpoint records state interval ffl state intervals ff process ffl ff oe stable state intervals fi ffl process may stable 
checkpoint process includes complete current dependency vector process 
logged message contains state interval index sending process time message sent tagging message complete dependency vector stable state interval process known messages started state intervals effective checkpoint logged 
recoverable system states system state called recoverable component process states stable resulting system state consistent 
recover state system possible recreate states component processes system state meaningful possible occurred failure free execution system initial state 
definition ffi system state recoverable stable ffi set set recoverable system states occurred single execution system 
recoverable consistent system states recoverable theorem set ordered system history relation forms sublattice system history lattice 
proof theorem 
state interval process stable process state intervals stable 
forms sublattice 
current recovery state recovery state system restored recoverable state possible information available order minimize amount necessary complete recovery 
system history lattice corresponds notion time theorem establishes existence single maximum recoverable system state ordering 
theorem unique maximum recoverable system state proof unique maximum simply unique forms sublattice system history lattice 
definition time current recovery state system state system restored failure occurs system time 
model current recovery state system unique maximum system state currently recoverable 
lemma single execution system current recovery state decreases 
proof ae current recovery state system time 
dependencies added state receipt new message cause receiving process new state interval resulting new system state 
system state remain consistent 
logged messages checkpoints removed longer needed state interval ae process remain stable longer needed 
system state remain recoverable 
set forms lattice new current recovery state established state greater discussed section domino effect uncontrolled propagation rollbacks necessary recover system state failure 
model occurrence domino effect take form propagation dependencies prevent current recovery state advancing 
lemma establishes sufficient condition preventing domino effect 
lemma messages received process eventually logged possibility domino effect system 
proof ae current recovery state system time 
state intervals oe process oe ae messages eventually logged state interval oe process eventually stable definition 
lemma current recovery state decreases definition new system states oe eventually recoverable new current recovery state 
domino effect avoided current recovery state eventually increases 
outside world execution processes may interact outside world consists outside system 
examples interactions outside world include receiving input human user writing information user display terminal 
interactions outside world modeled messages received outside world sent outside world 
messages outside world received process logged way messages received process 
messages sent outside world treated way sent processes system messages outside world may cause irreversible side effects 
guarantee state outside world consistent state system restored recovery message sent outside world delayed known state interval sent rolled back 
committed releasing outside world 
lemma establishes safe commit message sent outside world 
lemma current recovery state system ae message sent process state interval oe ae may committed 
proof follows directly lemma definition 
garbage collection operation system checkpoints logged messages remain stable storage longer needed possible recovery system 
may removed stable storage doing interfere ability system recover needed 
lemmas establish done safely 
lemma ae current recovery state 
process ffl state interval index effective checkpoint state interval ae process checkpoint process state interval index oe ffl needed recovery system may removed stable storage 
proof follows directly lemma definitions 
lemma ae current recovery state 
process ffl state interval index effective checkpoint state interval ae process message begins state interval oe ffl process needed recovery system may removed stable storage 
proof follows directly lemma definitions 
recovery state algorithm theorem shows system message logging checkpointing provide fault tolerance unique maximum recoverable system state 
maximum state current recovery state state system restored failure 
time current recovery state exhaustive search combinations currently stable process state intervals maximum consistent combination search expensive practice 
recovery state algorithm finds current recovery state efficiently 
recovery state algorithm invoked process state interval stable new checkpoint recorded process state interval messages received effective checkpoint interval logged 
uses dependency vectors stable process state intervals form new dependency matrices represent consistent system states recoverable 
centralized algorithm information collected execution system 
process state intervals considered algorithm stable information algorithm recorded stable storage 
algorithm restartable handle number concurrent process failures including total failure 
algorithm incremental uses existing known maximum recoverable system state advances possible fact new process state interval stable 
new state interval oe process stable algorithm determines new current recovery state exists 
attempts find new recoverable system state state process advanced state interval oe 
system state exists current recovery state system changed 
algorithm records index state interval process identifier lists checked 
new recoverable system state algorithm searches greater recoverable system states appropriate lists 
new current recovery state maximum recoverable system state search 
finding new recoverable system state heart recovery state algorithm procedure find rec 
recoverable system state ae stable state interval oe process oe ae find rec attempts find new recoverable system state state process advanced state interval oe 
including stable state intervals processes necessary new system state consistent applying definition consistent system state definition 
procedure succeeds consistent system state composed set process state intervals currently stable 
state process advanced new recoverable system state greater state system history lattice 
input procedure find rec consists dependency matrix recoverable system state ae process identifier state interval index oe ae stable state interval process dependency vector stable process state interval process ae xx conceptually find rec performs steps 
new dependency matrix ffi matrix row replaced dependency vector state interval oe process 
loop step consistent 
loop exists ffi ffi shows state interval ffi process depends state interval ffi process greater process current state interval ffi find minimum index ff stable state interval process ff ffi state interval ff exists exit algorithm return false 
replace row dependency vector state interval ff process 
system state represented consistent composed entirely stable process state intervals 
recoverable greater return true 
efficient implementation procedure find rec shown 
implementation operates vector rv full dependency matrix representing system state 
rv contains diagonal element row corresponding dependency matrix 
find rec called rv contains state interval index process recoverable system state 
dependency vector stable state interval process represented vector dv row matrix replaced outline corresponding single element rv changed find rec 
maximum element column matrix maintained vector max max contains maximum element column corresponding matrix 
function find rec rv oe rv oe max max rv dv oe max rv ff minimum index ff max stable ff state interval ff exists return false rv ff max max max dv ff return true procedure find new recoverable state 
lemma function find rec called known recoverable system state ae state interval oe process oe ae find rec returns true exists recoverable system state ae oe ae oe returns false 
find rec returns true return rv ae proof predicate loop determines dependency matrix corresponding rv max consistent definition 
condition false loop terminates matrix consistent column element larger element diagonal column 
find rec returns true system state returned rv consistent 
system state recoverable initial component process state intervals stable stable process state intervals replace entries execution find rec 
loop invariant maintained function find rec top loop iteration recoverable system state ae exists oe ae rv ae max 
invariant hold initially consistent state rv max state ae rv ae rv max 
subsequent iteration loop invariant maintained choosing smallest index ff max state interval ff process stable 
matrix consistent ff max 
choosing minimum ff components dv ff minimized component dependency vector decrease execution process 
replacing row matrix dv ff components max minimized recoverable consistent state exists condition ae max hold state interval ff max process currently stable recoverable system state exist ae max 
exactly condition procedure find rec returns false 
suppose state interval oe process depends state interval ffi process procedure find rec searches minimum ff ffi index state interval process currently stable 
set process state intervals currently stable dependency state interval ffi process transferred state interval ff process including case ff ffi state interval oe process said currently transferred dependency state interval ff process definition state interval oe process dependency vector hffi transferred dependency state interval ff process ff ffi state interval ff process stable exist stable state interval fi process ff fi ffi transitive closure transferred dependency relation state interval oe process describes set process state intervals may iteration loop procedure find rec invoked state interval 
subset state intervals exact subset execution depends order loop finds satisfies predicate 
complete algorithm function find rec complete recovery state algorithm stated 
algorithm shown uses vector crs record state interval index process current recovery state system 
process created entry crs initialized 
state interval oe process stable state interval advance old current recovery state crs algorithm checks new current recovery state exists 
execution vector store maximum known recoverable system state copied back crs completion algorithm 
invoked algorithm calls find rec old current recovery state identification new stable process state interval 
old current recovery state maximum known recoverable system state new stable state interval interval oe process find rec returns false greater recoverable system state exists state process advanced state interval oe 
current recovery state system changed shown lemmas 
lemma state interval oe process stable current recovery state changes ae ae oe ae oe 
proof contradiction 
suppose new current recovery state ae oe 
state interval stable current recovery state process new current recovery state state interval oe process state intervals stable state interval oe process stable 
system state recoverable state interval oe process stable 
oe current recovery state state interval oe process stable contradicting assumption original current recovery state 
current recovery state changed ae oe 
lemma state interval oe process stable initial call find rec recovery state algorithm returns false current recovery state system changed 
proof lemma current recovery state changes ae ae state interval oe process stable ae oe 
false return find rec indicates recoverable system state exists ae oe oe current recovery state changed 
oe crs exit crs find rec oe fi dv oe fi crs defer fi defer fi oe exit defer oe fi oe gamma stable fi defer fi fi fi gamma fl remove rv find rec rv rv defer fi gamma stable fi defer fi fi fi gamma crs recovery state algorithm invoked state interval oe process stable 
associated state interval fi process advance known current recovery state set defer fi records identification stable process state intervals depend state interval fi process current recovery state system ae fi fi ae defer fi records set stable process state intervals fi component dependency vector 
defer sets initialized empty set corresponding process created 
find rec returns false new process state interval stable state interval entered defer set 
algorithm uses sets limit search space new current recovery state 
initial call find rec recovery state algorithm returns true new greater recoverable system state 
additional calls find rec search recoverable system states exist greater returned call find rec 
new current recovery state system state returned call find rec returned true 
algorithm uses result lemma limit number calls find rec required 
lemma ae existing current recovery state system state interval oe process stable 
stable state interval process ae xx recoverable system state ae exists ae xx state interval process depend state interval oe process transitive closure transferred dependency relation 
proof state interval process advance old current recovery state part recoverable system state state interval oe process stable 
depend state interval oe process transitive closure transferred dependency relation fact state interval oe stable affect 
ffi maximum index state interval process state interval process related transitive closure 
clearly new recoverable system state exists ae ae ffi definitions component dependency vector decreases execution process 
ffi oe system state recoverable state interval oe stable contradicting assumption ae likewise ffi oe exist exist state interval oe process stable state interval ffi stable state interval oe stable 
cases lead contradiction recoverable system state exist dependency transitive closure 
loop recovery state algorithm uses defer sets traverse transitive closure transferred dependency relation backward state interval oe process state interval process visited traversal depends state interval oe process transitive closure 
state interval process transferred dependency state interval oe process transferred dependency process state interval depends interval oe process transitive closure 
traversal uses set record process state intervals traversal performed 
emptied new current recovery state copied back crs 
traversal dependency true results find rec obtained traversed 
state interval process considered advance maximum known recoverable system state find rec called search new greater recoverable system state process advanced state interval 
recoverable system state exists traversal state interval continued find rec return false state intervals depend state interval process transitive closure 
lemma state interval fi process depends state interval process transitive closure transferred dependency relation recoverable system state ae exists ae xx recoverable system state ae exists ae fi 
proof follows directly definition transferred dependency definition 
state interval fi process transferred dependency state interval process transferred dependency process state interval depends state interval process transitive closure 
dependency recoverable system state exists ae xx recoverable system state exists exist 
exist 
theorem recovery state algorithm executed time state interval oe process stable complete time crs ae ae new current recovery state system 
proof theorem holds system begins execution crs initialized process created 
likewise new process created execution system correctly added current recovery state setting crs 
state interval oe process stable initial call find rec returns false current recovery state remains unchanged lemma 
case recovery state algorithm correctly leaves crs unchanged 
call find rec returns true current recovery state advanced result new state interval stable 
ae old current recovery state state interval oe process stable ffi system state returned call find rec 
oe lemma 
system state may new current recovery state set recoverable system states forms lattice 
loop recovery state algorithm finds new current recovery state searching forward lattice recoverable system states backtracking 
search performed traversing backward transitive closure transferred dependency relation information defer sets 
state interval process examined loop recoverable system state exists state process advanced state interval traversal state interval continued 
lemmas loop considers stable process state intervals new recoverable system state exist 
completion loop traversal completed recoverable system state new current recovery state 
algorithm copies state crs 
example shows execution system processes 
process checkpointed state interval checkpoints written 
total messages received system messages logged 
state interval process stable current recovery state system composed state interval process 
recovery state algorithm crs defer sets empty 
message process process logged state interval process stable dependency vector recovery state algorithm executed calls find rec oe state interval process 
find rec sets rv max 
max rv stable state interval ff process needed consistent system state 
state interval process currently stable find rec returns false 
recovery state algorithm changes defer exits leaving crs unchanged 
process checkpointed state interval state interval stable 
dependency vector 
recovery state algorithm calls find rec sets rv max 
state interval ff process stable find rec returns false 
recovery state algorithm sets defer exits leaving crs unchanged 
message process process logged state interval process stable dependency vector 
recovery state algorithm calls find rec sets rv max 
max rv stable process process process example system execution 
state interval ff process required 
state interval process minimum stable state interval 
dependency vector rv max updated yielding value 
system state consistent find rec returns true 
maximum known recoverable system state increased 
set initialized defer loop algorithm begins 
state interval process checked advance call find rec skipped 
sets defer defer added making state interval process checked loop 
procedure find rec called sets rv max returns true 
maximum known recoverable system state updated call 
set defer added defer fl leaves empty 
loop terminates value left copied back crs 
system state represented value crs new current recovery state system 
example illustrates unique feature recovery state algorithm 
algorithm uses logged messages checkpoints search maximum recoverable system state 
messages received execution system logged current recovery state advanced due checkpoint process 
fact remaining messages need logged current recovery state advanced receipt 
failure recovery recovery state algorithm recovering number process failures system including total failure processes 
recovery state surviving processes surviving messages received logged may advance current recovery state 
surviving information volatile included computation current recovery state current recovery state reflects information recorded stable storage 
state process fail written stable storage additional checkpoint process received messages remain failure logged logged stable storage 
recovery state algorithm executed process state interval stable result current recovery state maximum possible recoverable system state including additional information survived failure 
restore state system current recovery state states failed processes restored orphan processes rolled back 
failed process restored restarting effective checkpoint state interval current recovery state replaying log messages received checkpoint recorded 
logged messages recovering process deterministically restore state state interval process current recovery state 
process currently executing state interval state interval process current recovery state orphan 
complete recovery orphan process forced fail restored state interval current recovery state way failed processes 
additional processes fail recovery recovery may restarted information recorded stable storage 
related optimistic message logging methods methods support fault tolerance optimistic message logging checkpointing published literature 
partially motivated strom yemini optimistic recovery sistla welch proposed new optimistic message logging method part aspects strom yemini system 
system unique finds maximum recoverable system state 
systems occasionally checkpoint processes system consider existing checkpoints finding current recovery state 
algorithm includes checkpoints logged messages search may find recoverable system states algorithms 
systems assume reliable delivery messages network channel pair processes lose reorder messages 
definitions consistent system state strom yemini require messages sent received sistla welch require sequence messages received channel prefix sent 
model assume reliable delivery applied common real distributed systems guarantee reliable delivery ethernet network 
needed reliable delivery incorporated model simply assuming message immediately message receipt 
strom yemini optimistic recovery message sent tagged transitive dependency vector size proportional number processes 
process required locally maintain knowledge message logging progress process log vector periodically broadcast process appended message sent 
system tags message current state interval index sender 
information equivalent log vector maintained recovery state algorithm uses additional communication required log message 
communication transitive dependency vector log vector allows control recovery centralized may result faster commitment output outside world additional communication may add significantly failure free overhead system 
optimistic recovery includes incarnation number part state interval index identify number times process rolled back 
preserves uniqueness state interval indices recoveries allows recovery different processes proceed synchronization 
model processes synchronize recovery notified reuse indices rolled back state intervals 
sistla welch proposed alternative recovery algorithms optimistic message logging 
algorithm tags message sent transitive dependency vector strom yemini system algorithm tags message sender current state interval index system 
find current recovery state process sends information message logging progress processes second algorithm exchanges additional messages essentially distribute complete transitive dependency information 
process locally performs computation find current recovery state 
results messages algorithm messages second number processes system 
contrast algorithm requires additional communication necessary log message stable storage 
additional communication system allows control recovery centralized 
current recovery state frequently determined output outside world committed quickly 
increased communication sistla welch algorithms may add substantial failure free overhead system 
pessimistic message logging methods system general required pessimistic message logging protocol model applied recovery state algorithm correctly finds maximum recoverable system state 
simpler algorithm find current recovery state pessimistic logging protocol 
current recovery state composed stable state interval process system protocol prevents system entering state system state composed way consistent 
protocols system predecessor publishing mechanism receiver message blocked message logged state interval stable process begins execution state interval 
sender message logging protocol process blocked attempts send new message messages received logged :10.1.1.134.8089
prevents process receiving message sent state interval sender stable ensures system state consistent 
optimistic message logging removes need synchronization execution message logging optimistic methods outperform pessimistic methods failures infrequent 
methods general approach message logging checkpointing methods called state machine approach assumes program execution input deterministic program state time input input 
approach time warp system virtual time method message logging checkpointing 
virtual time designed support synchronization required particular distributed applications discrete event simulation provide general purpose process fault tolerance 
checkpointing message logging provide fault tolerance distributed systems 
global checkpoint composed independent checkpoint process system recorded set checkpoints forms consistent system state 
system recovered restoring process state global checkpoint 
removes need log messages received system commit output outside world global checkpointing performed frequently may substantially degrade failure free performance system 
process execution may blocked checkpointing order guarantee recording consistent system state 
message logging removes need synchronization checkpointing allows checkpointing performed frequently sacrificing ability commit output outside world 
different forms logging checkpointing support recovery systems atomic transactions 
logging stable storage record state changes modified objects execution transaction 
typically entire state object recorded logical logging records names operations performed parameters recovery processes logged messages 
logging may proceed asynchronously execution transaction forced stable storage transaction commit 
similar operation optimistic message logging requirement system state recoverable output may committed outside world 
transaction commit additional synchronous logging required ensure atomicity commit protocol necessary message logging checkpointing methods 
extra logging reduced special commit protocols presumed commit presumed abort protocols 
recover transaction logging entire transaction may lengthen recovery times may prevent recovery transactions running times exceed mean time failures system 
smaller transactions may avoid problems increases amount logging frequency stable storage synchronization 
quicksilver system addresses problems allowing individual transactions checkpointed execution 
avoids need entirely transaction recovery transaction checkpoint record consistent state processes involved transaction global checkpoint checkpointing systems message logging 
recording consistent transaction checkpoint may significantly delay execution transaction due synchronization needed record consistent state 
optimistic message logging allows messages logged asynchronously blocking process execution 
improves failure free performance system pessimistic message logging methods requires complex recovery procedure 
optimistic message logging methods constitute beneficial performance tradeoff environments failures infrequent failure free performance primary concern 
recovery state algorithm recovery procedure improve earlier fault tolerance optimistic message logging strom yemini sistla welch 
methods allow centralized control recovery may allow output outside world committed earlier add significantly communication system 
systems checkpoint processes system consider existing checkpoints determining current recovery state system 
algorithm considers checkpoints logged messages may find recoverable system states systems find 
proven model section algorithm finds maximum possible recoverable system state 
furthermore utilizing checkpointed states messages received process checkpointed may need logged demonstrated example section 
unifies existing approaches fault tolerance message logging checkpointing published literature including pessimistic message logging optimistic methods :10.1.1.134.8089
model reason types fault tolerance methods properties independent message logging protocol deduced proven 
shown set system states occurred single execution system forms lattice sets consistent recoverable system states sublattices 
unique maximum recoverable system state 
rick john carter matthias felleisen jerry fowler pete keleher alejandro schaffer helpful discussions material comments earlier drafts 
comments referees helped improve clarity presentation 
philip bernstein hadzilacos nathan goodman 
concurrency control recovery database systems 
addison wesley reading massachusetts 
anita borg jim sam 
message system supporting fault tolerance 
proceedings ninth acm symposium operating systems principles pages 
acm october 
anita borg wolfgang blau wolfgang ferdinand herrmann wolfgang oberle 
fault tolerance unix 
acm transactions computer systems february 
mani chandy leslie lamport 
distributed snapshots determining global states distributed systems 
acm transactions computer systems february 
roger wayne gregory chan 
recovery management quicksilver 
acm transactions computer systems february 
david jefferson brian beckman fred wieland leo blume mike phil pierre kathy jack van warren john herb younger steve 
distributed simulation time warp operating system 
proceedings eleventh acm symposium operating systems principles pages 
acm november 
david jefferson 
virtual time 
acm transactions programming languages systems july 
david johnson willy zwaenepoel :10.1.1.134.8089
sender message logging 
seventeenth annual international symposium fault tolerant computing digest papers pages 
ieee computer society june 
richard koo sam toueg 
checkpointing rollback recovery distributed systems 
ieee transactions software engineering se january 
leslie lamport 
time clocks ordering events distributed system 
communications acm july 
butler lampson howard sturgis 
crash recovery distributed data storage system 
technical report xerox palo alto research center palo alto california april 
mohan lindsay obermarck 
transaction management distributed database management system 
acm transactions database systems december 
brian oki barbara liskov robert scheifler 
reliable object storage support atomic actions 
proceedings tenth acm symposium operating systems principles pages 
acm december 
michael powell david presotto 
publishing reliable broadcast communication mechanism 
proceedings ninth acm symposium operating systems principles pages 
acm october 
brian randell 
system structure software fault tolerance 
ieee transactions software engineering se june 
david russell 
state restoration systems communicating processes 
ieee transactions software engineering se march 
richard schlichting fred schneider 
fail processors approach designing fault tolerant distributed computing systems 
acm transactions computer systems august 
fred schneider 
state machine approach tutorial 
technical report tr cornell university ithaca new york june 
appear proceedings workshop fault tolerant distributed computing lecture notes computer science series springerverlag new york 
prasad sistla jennifer welch 
efficient distributed recovery message logging 
proceedings eighth annual acm symposium principles distributed computing 
acm august 
appear 
alfred spector 
distributed transaction processing system 
jean pierre banatre editors distributed operating systems theory practice volume nato advanced science institute series computer systems sciences pages 
springer verlag berlin 
available technical report cmu cs department computer science carnegie mellon university pittsburgh pennsylvania january 
robert strom yemini 
optimistic recovery distributed systems 
acm transactions computer systems august 

