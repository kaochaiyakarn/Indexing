proof systems calculus logics mads dam dept teleinformatics royal institute technology sweden study problem verifying general temporal functional properties mobile dynamic process networks cast terms pi calculus 
expressive power calculus derives combination name generation communication handle mobility dynamic process creation 
introduce calculus extension modal mu calculus name equality inequality order universal existential quantification primitives name input output appropriate temporal logic pi calculus 
compositional proof system scope verifying dynamic networks pi calculus agents properties specified logic 
proof system consists local part roughly classical sequent calculus extended data structures private names rules support process structure dependent reasoning 
addition proof system contains rule discharge close founded cycles proof graph 
proof system shown sound general weakly complete non recursive fragment specification logic 
obtain weak completeness result recursive formulas finite control calculus processes 
examples considered 
example milner encoding data types pi calculus specifically natural numbers 
encoding interesting point view verification essential distinguishing features pi calculus including dynamic process creation 
corresponding encoding natural numbers calculus propose encoding type natural numbers calculus establish type correctness properties 
second example consider garbage collecting unbounded buffer dynamically create destroy buffer cells show establish absence spurious output system 
study problem verifying general temporal functional properties mobile dynamic process networks 
network processes created process interconnection topology modified partially supported swedish foundation strategic research junior individual 
partly done swedish institute computer science 
sics box kista sweden 
email mfd sics se 
execution 
mobility achieved mechanism generating interprocess links passing processes 
instance calculus links primitive names communication channels programming language erlang links serve communication channels process identifiers 
combination mobility dynamic creation processes powerful 
case calculus witnessed encodings calculus data types functions objects higherorder processes 
power extensively everyday programming practice dynamically set data process structures adapt applications systems change environments support fault tolerance code replacement running systems name just scenarios cf 

cost power unbounded essential growth state spaces processes compute rendering analyses global state space exploration general impossible 
alternative explored ccs take compositional proof approach 
extend approach calculus show compositional proof system built scope verifying quite general properties calculus processes 
important note ambitious difficult task 
approaches verification deal satisfactorily kind problem settings computationally simpler calculus 
claim give definite answer problem required stable methods criteria measuring usefulness 
claim possible approach set criteria soundness weak forms completeness non trivial examples address adequately solve problem 
investigation cast terms judgments form gamma oe open calculus term oe general temporal formula gamma sequence assumptions governing agent variables free set channel names local verification setting inherently compositional behaviour defined properties constituent parts determined gamma 
temporal specifications extension modal calculus name equality inequality order universal existential quantification primitives name input output lines 
proof system judgments sound weakly complete recursion free formulas general formulas show proof system sound general weakly complete finite control processes 
ccs proof system proof system consists large number proof rules account roughly modal fragment plus single rule discharge handle fixed points 
illustrate scope proof system means examples 
example milner encoding data types calculus shows type natural numbers encoded 
inherent interest natural numbers example interest exercises important aspects calculus dynamic process creation name generation scope extrusion communication temporal logic fixed points alternation quantification equality inequality input output 
illustrates important point proof system capacity uniformly prove properties pertaining infinite collections essentially distinct agents 
example surprisingly subtle trivial arrive suitable encoding property representing natural number formally prove type correctness properties consider 
second example consider bounded particular unbounded buffers show main example absence spurious output unbounded directional buffer garbage collecting sense buffer elements empty terminated 
chosen setting calculus introduced section 
largely standard version polyadic calculus recursive process definitions incorporating standard conditional 
proceed introduce calculus version order calculus style park extended calculus specific primitives 
section example specifications notably examples specifications addressing basic buffer properties order preservation absence spurious output absence message loss formalisation type natural numbers 
proceed modal fragment proof system shape judgments semantics proof rules example derivations 
modal fragment proof system grouped naturally collections rules 
logical rules governing order connectives largely standard 
structural rules slightly extent rules equality inequality somewhat interesting way private names handled 
collections rules rules transition modalities rules modalities reflecting name input output io modalities 
modal fragment proof system shown sound weakly complete section 
proceed consider fixed points 
section semantics proof rules fixed point formulas introduced 
handling fixed points follows novel approach introduced 
approach exploits approximation ordinals explicit way paving way logical account far simpler elegant story 
proof rules grouped collection local rules providing support fixed point unfolding unfolding approximated formulas 
second final part proof system consists single rule discharge providing roughly formal correlate founded induction 
section go prove weak form completeness reducing proofs global model checking oriented version proof system known complete proofs compositional system 
section contains verification examples pertaining natural number buffer examples section contains pointers 
proofs main completeness results deferred appendices 
preliminaries pi calculus section introduce calculus syntax operational semantics 
syntax assume denumerable sets agent abstraction identifiers channel names denote vectors processes abstractions concretions generated syntax notation largely standard 
standard notation conditional place matching mismatching notations common calculus contexts 
avoid excessive proliferation box notation modal operators 
agents interpreted relative environment determines agent identifier defining equation delta alternative recursive definitions bang operator easily definable identity possible little involved derive recursively defined processes bang 
binding calculus binding operators ffl abstractions binds ffl restrictions binds 
agent expressions considered renaming bound names 
fn bn free names bound names names free bound respectively 
pfa vectorized form pf bg notation uniform simultaneous substitution names 
actions action ff internal action input action output action shape ah ci actions derived notation clauses delta delta delta delta ahc delta delta delta delta hc delta delta delta hc ip means identifications possible rewrite process shape ff binding conventions functions fn bn extended actions obvious way 
transition semantics intended semantics quite known ccs original calculus papers ffl inert process incapable performing transitions 
ffl ccs choice construction transition transition ffl ff agent offering just transition labelled ff resulting state 
ffl actions shape represent internal unobservable actions 
actions shape represents input actions actions shape ah ci represents output actions 
ffl case ff hbi process concerned emitting private name receiver causing scope extruded extended possibly involving alpha conversions encompass receiving process 
ffl parallel composition offering transitions separately internal transitions arising synchronous communication communications cause input output actions matched 
ffl conditional 
ffl declares new name ffl invocation process defined example agent defined recursive agent parametrised declares new local name passed environment name received resulting agent 
transition rules table 
table include symmetric versions rules sum com par 
assumed 
terms identified alpha conversion side conditions intending prevent confusion scope avoided 
example choice bound names transitions enabled ffl 
fd bg sum ff ff pre delta ff ff com ah cg par ff ff ff ff ff ff res ff ff ff open ah ah id pf ag ff ff delta table transition rules ffl 
fd cg ffl fd bg fd cg conclude section introducing running examples 
example buffers place buffer reads name input port delivers output port buf buf inductively buf buf place place buffer abstraction similar buf buf buf buf place buffer abstraction 
unbounded buffers need able allocate new buffer cells dynamically buf buf buf data item input buf new buffer cell allocated deallocated 
clearly wasteful 
may consider unbounded buffer cells organised linked list shown fig 

main component buffer cell holds value waits output terminate communicate upstream receive new output port new link ho 
buffer cells start cells responsible creation buffer cells garbage collecting unbounded buffer consists initially just start cell example natural numbers consider encoding natural numbers milner encoding data types polyadic calculus cf 

idea represent natural number located name process expects names say proceed synchronize signal receiver value output location natural number signal value 
define constants zero succ way zero zhi succ location zero inputs names attempt output second zero channel 
similarly succ receives names attempt output successor channel passing location represent natural number agent zero succ zero zero zero variety operations naturals defined including addition multiplication basic copying operation copy nhs zero succ copy turns natural location natural location addition defined follows add hs copy succ add calculus section introduce logic specifying properties agents 
logic order version modal calculus extended operations describe input output behaviour 
syntax assume denumerable set predicate variables formulas oe calculus generated way oe oe oe oe oe oe oe oe oe oe oe oe oe oe oe grammar range names names range names names monadic formula strict alternation transition modalities shape oe oe io modalities shape oe oe oe oe require outermost modal operator transition modality 
connectives language order modal calculus name equality inequality universal existential name quantification boolean connectives modal operators parametrised greatest fixed points 
modal formula formula fragment fixed points predicate variables 
elementary formula formula order language equality names 
convenient treat elementary formulas differently formulas depend agent predicated 
connectives input free output input fresh name bound output respectively 
instance oe predicates abstraction taken mean applied name resulting agent satisfies oe 
observe bound oe 
similarly oe predicates concretion term states term shape equal oe holds continuation 
bound outputs operation oe 
operation oe introduced slightly different shape 
connective predicates abstractions means agent predicated inputs name fresh oe holds continuation 
modalities oe oe bind oe 
syntax handling transition labels subjects handling parameters objects 
alternative return detail devise connectives style milner combine modalities reflect action capabilities directly 
example formula expresses agent perform bound output channel received continuation satisfies 
bindings sentences oe range range modalities 
formulas considered alpha renaming bound predicate name variables 
name binders order quantifiers bound output connective fixed point operators 
instance oe names occur freely names bind occurrences oe 
loss generality assume fixed point formulas contain free names 
sentence formula contain free occurrences predicate variables 
specified restrict attention sentences 
predicate name interpretations names serve double role constants distinct names occurring freely top level process term regarded distinct variables names bound instantiated 
name interpretation mapping assigns names values names variables 
require name interpretations gamma range infinite set 
name said fresh range ag update maps acts bg fa delta delta delta observe operation gamma generally applied fresh 
name interpretations extended actions clause predicate variables depend semantics list argument names name interpretation 
predicate variable interpretation taken mapping ae maps 
ordered defined subset containment lifted pointwise functions 
semantics validity semantics terms mapping ae predicate variable interpretation name interpretation 
definition deltak table 
clauses bound input bound output notation fresh means occur freely oe fresh sentences oe ae immaterial abbreviate 
write oe place 
sentence oe said valid name interpretations sentences oe equivalent written oe kj 
clauses modal operators lead derived notation transition relation iff iq iff simplify transition modality clauses style fp abbreviations introduce derived forms delta delta ka fa ka fa ag gg ag gg koe koe fp fp fp ch iq fp implies fp implies fp ch implies iq ka bg ka ka fresh implies afc bg ka fb fresh bg agg kx ae oe ag oe fg table formula semantics isp delta isa delta 
delta delta observe isp holds processes isa non trivial abstractions free outputs bound outputs 
range typing formulas 
typing formulas said complementary isa 
alternative definitions set delta similarly delta 
definitions easily shown equivalent original ones proof system 
logic closed negation define operation usual de morgan rules plus ff oe ff oe isa ff oe ff oe isa oe oe isp oe 
oe isp isa oe oe isp oe oe isp isa classical negation number standard abbreviations oe oe delta oe available observe recursion variables general negated number times 
principle problem negation primitive 
choose mainly matter convenience proof rules cluttered stand harder read 
calculus modalities comparing earlier attempts define modal temporal logics calculus consider modal logic milner parrow walker 
basic modalities rendered framework follows ab oe delta oe ab oe delta oe oe delta oe oe delta oe 
oe delta oe 
oe delta oe refer operators mpw modalities 
leave aside issue reduction direction exists modal monadic formulas formulas logic 
trivially logic lacks modality bound input 
addition modality matter easily resolved 
logics calculus proposed milner dam amadio dam 
dependent sum product constructions proposed sigmaa oe delta oe oe oe delta oe oe delta oe primed versions quantifiers confuse standard order quantifiers 
observe absence bound input modalities logics strictly expressive separate free bound output 
modalities easily derivable 
leave details 
logical characterisation important property modal logic considered capability separate models 
shown mpw modalities characterise particular quite strong process equivalence called late bisimulation equivalence cf 

definition late bisimulation equivalence binary relation late simulation rp implies 
ff ff input action ff rq 
bg 
relation late bisimulation gamma late simulations 
late bisimilar delta rp late bisimulation second clause definition arities vectors required coincide 
observe simplicity definition input output actions relies heavily alpha conversion avoid accidental capture bound names 
equivalences appear calculus literature 
early bisimulation strictly weaker late bisimulation 
obtained swapping quantifications clause definition 
open bisimulation strictly stronger late bisimulation requires bisimulation relation closed substitution 
ground bisimulation standard ccs bisimulation equivalence applied calculus 
ground bisimulation avoids quantification entirely defining clauses strictly weaker early bisimulation equivalence 
substantially constrained version calculus eliminating conditional matching conditional special form continuation output prefix shown equivalences coincide 
obtain logical characterisation result proposition logical characterisation processes late bisimilar sentences oe name interpretations oe implies oe 
proof logical characterisation result proved logic constructed equations inequations conjunction disjunction mpw modalities 
adaptation result setting easy left 
suffices show formulas language respect bisimulation equivalence sense oe delta oe 
cater fixed points assertion need generalised say predicate interpretation ae respects delta ae delta ae 
show induction structure oe ae respects delta delta 
details induction difficult left reader 
constraining nesting transition io modalities similar characterisation early bisimulation 
effect formation late input mpw modality 
needs prevented shown 
example specifications section give examples agent properties specified logic 
example weak modalities easily derive modalities insensitive number initial transitions 
oe delta oe oe delta oe oe delta oe oe delta oe example wildcard input output wishes ignore identity names input output oe oe oe oe oe definition presupposes appear freely oe 
example buffer properties consider properties impose calculus buffer input channel producing output channel formulas example due joachim parrow personal communication 
ffl order preservation data item 
true res idea quite simple holds input takes effect 
fixed point holds invariantly transitions output 
ffl spurious output 
consider formula 
formula expresses roughly input output 
observe context calculus gives operational meaning notion authenticity trusted information emitted really received ffl lost input 



hold invariantly input holds 
property expresses transition enabled transition taken transition output continues hold 
fixed point eventually case hold eventually output 
example natural numbers wish define property nat possessing natural number object located 
keeping mind concrete representations example nat expected hold process circumstances ffl possible force synchronize immediately initial number steps 
ffl sequence labelled steps disable transition 
ffl transitions take arguments 
ffl fresh names provided properties hold ffl outgoing synchronisation possible 
ffl unary outgoing synchronisations possible 
ffl sequence internal steps disable transition 
ffl transition takes place result process 
ffl transition takes place new name output serving location predecessor 
claim points unambiguously pin intended behaviour natural number object fact points leave room debate 
resolving formalize intuition calculus 
describe behaviour natural number objects state machine wrapped inside fixed point reflecting foundedness property natural numbers 
propose definition nat oe delta 
oe 
nat delta 




isp nat delta nat nat definition uses higher order parameters manner goes syntax start section 
expense monolithic readable notation quite easy rewrite definition eliminate higher order abbreviations 
idea definition describe behaviour natural number object sort state machine formalizing sort natural number protocol 
state machine states nat nat outside state description fixed point reflect progress entire protocol runs 
description state bring actions enabled describe compositional manner type action effect performing action 
case studies performed years sort state description useful proving properties infinite state systems examples 
suppose possesses natural number object located enabled supplied fresh fresh supplied fresh say little behaviour resulting system unintended internal communications result 
important point main reason chosen include fresh input primitive 
continuing protocol offered 
offered result process protocol terminated 
offered new location output agent continue behave natural number object located fixed point option eventually selected natural number object ensured founded 
natural number type candidate type ephemeral natural numbers 
expressing property location natural number object event takes place easy embedding nat invariant 
variations definition nat possible 
instance insist nat permitted diverge 
proof system modal fragment closed correctness assertion assertion shape oe arbitrary process oe calculus sentence 
certain called finite control agents refrain creating new processes dynamically avoiding parallel compositions recursive contexts replication operator problem deciding validity closed correctness assertions decidable 
due fact choice names little garbage collection state spaces finite control agents finite 
interesting agents fall outside class finite control agents including natural number agents example unbounded buffers example processes created dynamically 
fact just dynamic process creation capability conjunction capability creating communicating new names gives calculus remarkable expressive power feature verification difficult 
limits global state exploration approaches verification merely chase transitions global states successful proving interesting properties non finite control agents 
consider instance unbounded buffer buf example 
temporal property depends buf continually able input new data items give rise unbounded state space quite trivially input action gives rise creation new component process 
may despite non finite control state space fact bounded 
example may consider process shape copy gamma delta delta delta succ zero perform bounded number actions despite dynamic process creation involved definition copy interesting correctness property copy collection facts instance copy represents natural number located fact copy type correct 
represents natural number located copy represents natural number located assertion closed correctness assertion scope model checking techniques explore global state spaces agent expression predicated open 
open correctness assertions need address general open correctness assertions allow correctness properties oe conditional properties parameters represents natural number located 
give handle dynamic process creation way suppose goal prove correctness assertion shape oe assume involves dynamic process creation number steps proof goal reduced shape instance may agent buf example 
idea apply cut guessing property fl hold reduce proof goals fl fl representing assertion holds conditional fl holding say instance choose fl oe turns case examples 
proof goal instance may consequently subgoal reason discharged 
turn involve dynamic process creation problem dealing feature may resolved want iterate approach keeping mind deal general open correctness assertions 
basic judgments idea worked ccs 
delicate issue generalising approach calculus deal private names name generation scope extrusion 
general wish verify properties process relative property allowed depend consider instance property copy natural number located natural number located take granted copy indistinguishable copy provided name clashes arise dependency lost 
need mechanism freeze extend scope cover formulas left turnstile 
suggested annotating turnstile restriction set purpose 
suggestion 
judgments take general form oe finite set names scope extending oe 
fact similar annotation introduced stirling 
annotation somewhat deeper function due richer name discipline calculus 
term variables open terms defining formally notion judgment semantics observe need extend basic syntax calculus open terms 
term variables range processes abstractions concretions 
terms may open involve term variables 
closed term term contain term variables may contain free names 
range consideration open terms leads extend calculus syntax slightly allowing parallel composition operator applied processes abstractions concretions cf 

done rewriting symmetric versions assumed added implicitly 
ic ic af bg assume symmetric versions rewrite rules added implicitly appeal alpha conversion prevent variable capture 
definition basic judgments validity basic judgment expression form gamma delta 
gamma fx oe oe finite set assumptions oe sentences 
fa finite set names restriction set 
delta finite set sentences 
open term 
agent variable occurs freely gamma delta occurs freely gamma contains assumption 
assumption shape oe 
semantics name interpretations extended general substitutions mapping names names term variables closed terms 
doing sets names term variables assumed distinct 
extend substitutions restricting names 
judgment gamma delta valid true written gamma delta substitutions oe ej notation sets gamma delta standard sequence notation writing 
gamma oe oe place gamma fx oe oe gamma delta delta place gamma delta delta basic judgment gamma oe delta oe elementary holding oe depend allow judgment abbreviated gamma oe delta 
restrictions sets scoping point concerning scope restriction sets deserves reiterated 
observe judgment shape oe oe may mention arbitrary name interpretation suppose oe 
occurrences oe refer name interpretation occurrences 
name occurring oe confused 
forming ej identified equal 
occurring hand identified distinguished name occurring freely ej agent bound 
scope oe extends oe 
reflected proof system rule alpha 
proof system modal fragment turn problem proving validity basic judgments restricting attention modal fragment 
proof system consist number clearly discernible parts 
group structural rules governing aspects assumptions 

group logical rules deal connectives conjunction disjunction quantifiers 

group rules name equality inequality 

group rules process modalities ff 
ff 

group rules input output modalities oe oe oe oe 
groups rules standard sequent style formalisation order logic equality 
adaptation completely trivial due presence agent terms variables restriction sets 
important delicate issue concerns choice rules include primitive 
strategy include rules needed completeness argument probably useful bear mind far definitive criterion may thought glance tangible criteria elegance orthogonality important detailed formulation rules 
go group rules turn 
structural rules minimal set rules introducing applying assumptions identity weakening cut bearing mind general rules affected presence restriction sets delta gamma oe oe delta gamma delta gamma oe delta gamma delta gamma delta gamma delta sets rules contraction permutation needed 
comment need weakening 
cut rule comes flavours 
cut essential accomodate reasoning agent structure general eliminable 
cut gamma fresh oe gamma oe delta gamma efp xg delta gamma introduce new pieces shorthand writing gamma condition gamma contain assumption fresh elementary formula expressing names distinct name occurring gamma delta 
illustrate complications involved cut rule assume judgments gamma fresh oe gamma oe delta valid substitution assumptions gamma validated name interpretation substitution validates condition fresh conclude pj oe 
occur gamma extended substitution xg fp validates gamma oe restriction set efp xg delta required 
second cut rule needed come consider logical fixed points discharge loop termination providing garbage collection restrictions longer 
modal fragment cut admissible seen completeness proof 
cut gamma fresh oe gamma oe delta gamma delta gamma fresh sense requiring names distinct names see soundness rule assume gamma fresh oe gamma oe 
process 
assume koe assumption koek 
kj desired 
third cut rule cut gamma oe delta gamma oe delta gamma delta occur gamma 
modal fragment cut admissible 
conjecture general 
rule cut derivable quite easily logical rules introduced section 
need rule reflect scoping rule restriction sets alpha gammaoe soe eoe delta gamma delta oe injective range oe disjoint fn gamma fn fn delta gammas oe extension oe agents restriction sets assumption sets gamma 
substitution rules injective substitutions unrestricted names term variables admissible 
logical rules approximation require standard rules introducing elementary connectives left right 
gamma oe delta gamma oe delta gamma oe delta gamma delta gamma oe delta gamma oe delta gamma delta gamma oe delta gamma oe delta gamma oe delta gamma ag delta gamma oe delta gamma oe delta gamma oe delta fresh gamma oe delta gamma oe delta fresh gamma ag delta gamma oe delta rules fresh shorthand condition free judgment case occur logic closed classical negation need rules reflect contradictory assumptions governing agent variable 
suggest rules left right dilemma gamma oe delta gamma oe delta gamma delta gamma oe delta gamma oe delta gamma delta rules needed reflect fact elementary formulas depend agent term predicated gamma oe delta gamma oe delta gamma oe gamma oe rules require oe elementary 
lemma rules derivable gamma oe delta gamma oe delta gamma oe delta gamma oe delta proof easy derivations weakening dilemma 
rules equality inequality equality inequality suggest axioms rule inference 
axioms express properties 
names equal 

possibly restricted names equal 

name identified name restriction set textually identical 

infinitely names 
addition rule substitution equals equals 
refl delta gamma delta irr delta gamma delta new delta gamma delta delta gamma delta delta delta delta subst cg cg cg cg efa cg cg see soundness new observe simultaneously case distinct names 
observe rule irr needed note derivability number useful proof rules 
lemma rules derivable eq delta gamma delta elem delta gamma oe oe delta oe elementary fn oe ineq ag ag ag gamma delta sym gamma delta gamma delta tr gamma delta gamma delta gamma delta sym gamma delta gamma delta dist gamma delta gamma delta gamma delta proof eq subst refl 
elem eq dilemma rules logical rules structural induction oe 
ineq weakening elem subst 
sym case slightly delicate previous ones 
prove gamma delta proof gamma delta 
observe gamma delta weakening 
observe gamma delta gamma delta subst 
proof complete cut 
remaining derivations easy exercises 
rules transition modalities arrive rules 
proof goals case shape gamma oe wildcard ranging 
observe shape quite general wish 
want permit sets modal formulas right turnstile single formula permitted 
restricted format chosen reasons 
modal proof rules general multi judgments unduly complicated 

restricted format suffices examples weak completeness results 
transition capabilities determined structure operational semantics earlier assumptions gamma variables occurring freely operational semantics determined induction structure hardly surprising general number rules governing proof goals shape gamma ff oe ff oe depends number primitive operators operator number operational semantics rules section determining behaviour 
proceed induction structure right hand agent term predicated give rules show typically modal cases quite general properties agent specific outermost connective inferred terms properties immediate constituents 
term variables case variable corresponds monotonicity rule familiar sequent style formalisations modal logic mon gamma oe oe oe gamma oe oe oe mon gamma oe oe gamma oe oe rules require gamma 
proviso rules clearly sound 
nil nil delta gamma oe summation plus gamma oe gamma oe delta plus gamma oe gamma oe gamma oe prefixing tau gamma oe gamma oe act delta gamma oe tau delta gamma oe delta gamma oe delta gamma oe act gamma oe gamma gamma oe act gamma oe gamma oe rules notation indicate optional sense transition labels indicated rule act reveals alpha required show 
valid judgment need alpha rename restricted act reduce goal shape resolved new 
parallel composition rules parallel composition shown table 
rule par comes symmetric version 
rules marked indicating subject side condition fresh 
appear free judgment typing formulas appear complementary 
typing formulas important role matching input output 
evident rule par 
par role implicit rule requires ancillary rule schema ar gamma gamma gamma oe ensure inputs matched outputs proper sort 
see soundness 
par assume antecedents rule valid 
assume substitution oe ej oe fj 
ej fj processes ej fj par gamma fresh isp gamma fresh oe gamma oe fl gamma fl par gamma fresh oe gamma fresh gamma fresh oe gamma fresh oe gamma oe fl gamma fl par gamma fresh isp gamma fresh isp gamma fresh oe delta delta delta gamma fresh oe gamma fresh delta delta delta gamma fresh gamma oe oe fl gamma fl gamma fl par gamma fresh isp gamma fresh isp gamma fresh oe delta delta delta gamma fresh oe gamma fresh delta delta delta gamma fresh gamma fresh oe delta delta delta gamma fresh oe gamma fresh oe delta delta delta gamma fresh oe gamma fresh delta delta delta gamma fresh gamma fresh delta delta delta gamma fresh gamma oe oe fl gamma fl gamma oe oe isa fl gamma oe oe isa fl gamma oe oe isa fl gamma oe oe isa fl gamma fl table proof rules parallel composition vs transition modalities assume complementary arities third fourth antecedents 
yg fl 
fj fl desired 
rule par sight complex 
closer inspection argue rule merely brings quite complex modal behaviour calculus parallel composition complexity inherent problem due specificities formalisation 
say simpler formulations 
fact may possible instance appealing directly operational semantics transition relation way chosen 
believe quite strongly truly compositional modal analysis calculus parallel composition perform sort quite convoluted case analysis brought par rule 
conditional cond gamma oe gamma oe gamma oe restriction new gamma oe gamma oe fresh identifiers fix gamma pf ag oe gamma oe delta final rules rule new trivial 
assume fresh gamma oe gamma oe 
koe pick fresh free 
fb ag 
koe assumption substituting uniformly ej 

rules process modalities clearly rule par complex 
quite intuitive 
prove property shape oe parallel composition describe sufficient detail formulas oe properties transition performed 
oe false 
formulas oe shown hold prescribed fashion shown compose correct way synchronisations result agents complementary types 
variations played formulation rules 
example consider version par ccs typing formulas restriction sets needed 
proposition rule derivable occur free gamma par gamma oe fl gamma oe fl gamma oe oe fl proof proof goal gamma oe oe fl get list subgoals gamma fresh oe oe isp gamma fresh oe oe isp gamma fresh oe oe oe gamma fresh oe oe gamma oe oe oe fl gamma oe oe fl prove logical equational rules mon 
subgoals trivial 
prove apply weakening eliminate old version apply arrive subgoal gamma oe fl desired 
small important difference rules par par par permit multiple assumptions term variables 
inessential modal fragment version multiple assumptions easily derived come consider recursive formulas distinction turn significant 
rules input output modalities rules needed conversion free bound input modalities rules input output modalities follow pattern established process modalities previous section 
introduced variables subject side condition appear gamma 
term variables rules term variables shown table 
side condition fresh mon mon means occur freely member delicate rules mon 
see sound assume simplicity gamma empty 
oe ng 
written fc bg oe fc ag fresh 
assume oe oe oe fc ag oe fc ag fc ag fresh 
fc bg fc ag showing required 
mon gamma oe oe gamma oe oe mon gamma oe oe gamma oe oe mon gamma oe oe gamma oe oe fresh mon gamma oe oe gamma oe oe fresh table monotonicity rules io modalities parallel composition rules parallel composition shown table 
input gamma oe gamma oe fresh gamma fresh bg gamma oe fresh context rule fresh abbreviation formula fa 
output gamma gamma oe gamma oe gamma oe gamma oe input modality conversion falling little outside patterns far established need rule convert free bound input modalities conv delta gamma oe oe fn gamma conv delta gamma oe oe fn gamma par gamma fresh isp gamma fresh oe gamma fresh oe gamma oe oe fl gamma fl par gamma fresh isp gamma fresh oe gamma fresh oe gamma oe oe fl gamma fl par gamma fresh isp gamma fresh oe gamma fresh oe gamma oe oe fl gamma fl fresh par gamma fresh isp gamma fresh oe gamma fresh oe gamma oe oe fl gamma fl fresh par gamma fresh oe gamma fresh oe gamma fresh gamma fresh gamma oe oe fl gamma fl par gamma fresh oe gamma fresh oe gamma fresh gamma fresh gamma oe oe fl gamma fl fresh table rules parallel composition vs io modalities example show derive rule matching bound output free input 
proposition rule derivable com gamma fresh oe gamma fresh oe gamma fresh gamma fresh gamma oe oe fl gamma fl fresh proof antecedents concerning fresh introduced resulting free inputs converted bound inputs conv com yield result 
examples section give little substantial proof example 
proof examples 
example consider processes passed private name returned back 
clearly judgment 
valid 
cut applied 



oe oe cut twice reduce subgoals oe oe oe oe 
prove apply act refl reduce new steps similar vein suffices complete proof proof similar 
prove reduce list subgoals oe oe oe oe oe oe oe oe isa oe oe 
par 
subgoals just instances 
just need monotonicity rule mon rules mon 
get delta delta delta delta delta delta 
fresh conv cut delta delta delta delta delta delta delta delta delta 
reduced com delta delta delta delta delta delta delta delta delta 
goals resolved immediately 
proceeding par reduce delta delta delta delta delta delta com reduce delta delta delta delta delta delta resolved easily par elementary reasoning 
variable naming observe shape rules proofs tend introduce long sequences variables example 
case transitions input output actions taken form application modal input output rule old variables immediately forgotten weakening 
examples follow reason identify variables assuming implicitly introduced assumptions concerning immediately forgotten renamed soundness completeness modal fragment pushing add rules discharge allow interesting recursive properties proved pause establish soundness completeness modal fragment 
proofs section deferred appendix soundness delicate rules shown proof system just state soundness fact 
proposition soundness modal fragment gamma delta proof system section gamma delta 
concerning completeness consider weak form gamma oe gamma elementary formulas gamma elementary gamma oe provable 
introduce basic tools 
definition partition finite set names 

hyp denotes sequence form oe oe oe form hyp 

gamma elementary 
gamma show property deals order part 
proposition include set non fresh names gamma oe 

oe boolean hyp oe hyp oe 

gamma oe hyp oe gamma 
point onwards shall explicit handling elementary connectives 
prove completeness kind decomposition lemma allowing decompose goal subgoals 
lemma decomposition include fn efe fn fn oe 
suppose efe closed suppose oe nonrecursive 
gamma hyp 
gamma efe oe oe oe modal depth exceeding oe 
gamma fresh oe 
gamma oe oe oe 
theorem completeness modal fragment suppose gamma delta gamma boolean formulas delta non recursive 
gamma delta 
proof rules recursive formulas proceed address fixed points 
approaches analysis verification calculus relies level approximation ordinals wellfounded induction knaster tarski fixed point theorem 

cases fixed point formulas unfolded possible determine suitable approximation ordinals provide progress measures satisfaction 
applies particular unfolding fixed point formulas left turnstile unfolding greatest fixed point formulas right 
approximation ordinals reflected explicitly proof system specific ordinal variables 
provides simple framework dealing variety complications including alternation fixed points importantly fact number complications related fixed point interference explain 
material section corresponding material 
reason proofs theorems left presentation 
ordinal approximations soundness fixed point induction relies known iterative characterisation greatest fixed points computed iterative limits ordinal approximations 
range ordinal variables 
name interpretations extended map ordinal variables ordinals 
range fixed point formula abstractions form oex oe 
new formulas introduced shape ordinal inequalities obvious semantics abbreviates usual 
approximated fixed point abstractions suppose oex oe oe ku ae koek xg jfj gamma ag succ 
ord 
ae limit ord 
condition 
dually oe ku ae koek xg jfj gamma ag succ 
ord 
ae limit ord 
side condition 
get basic monotonicity properties ordinal approximations proposition suppose 

greatest fixed point abstraction ku ae ku ae 
fixed point abstraction ku ae ku ae proof wellfounded induction 
importantly get straightforward application known knaster tarski fixed point theorem 
theorem knaster tarski suppose oex oe 
ku ae ae ff oe ae ff oe intended model countable quantification theorem restricted countable ordinals 
rules fixed point unfolding approximation main rules reason locally fixed point formulas unfolding rules 
come flavours fixed point abstraction concerned approximated nature position fixed point relative turnstile 
gamma gamma delta gamma delta lfp fresh gamma gamma delta gamma delta gfp fresh unf gamma gamma gamma ag delta gamma delta oex oe unf gamma gamma gamma ag delta gamma delta oex oe unf gamma gamma gamma ag delta gamma delta oe fresh unf gamma gamma gamma ag delta gamma delta oe fresh unf gamma gamma gamma oe ag delta gamma delta oe fresh unf gamma gamma gamma ag delta gamma delta oe fresh unfolding rules unf gamma gamma unf gamma gamma expected unfolding rules 
rules unfolding fixed point formulas occurring right turnstile dually greatest fixed point formulas occurring left 
cases proof task existential identify approximation ordinal making statement true unfolding rules merely serve delay 
hand case fixed point formulas occurring left turnstile greatest fixed point formulas occurring right task universal suggesting founded induction suitable proof strategy 
approximation rules gamma gamma serve introduce ordinal variables purpose 
having introduced ordinal variables need decremented approximated formulas unfolded 
purpose second pair unfolding rules unf gamma gamma unf gamma gamma 
ordinal approximations introduced certain positions judgment left fixed points right greatest ones positions approximated formulas unaffected local proof rules rules far discussed sufficient 
unfortunately due cut rules 
consider instance quite typical application process cut rule gamma gamma gamma xg example may greatest fixed point formula earlier application assigned ordinal variable second antecedent occurring left turnstile 
third pair unfolding rules needed handle situation 
addition rules useful add versions identity rules reflecting monotonicity properties ordinal approximations prop 
gamma gamma delta lfp gamma gamma delta gfp additionally set elementary rules needed support reasoning orderings including transitivity 
rules left presentation 
soundness proof uncontroversial refer 
theorem rules unf unf unf unf unf sound 
rule discharge addition local rules unfolding approximating fixed point formulas rule needed discharging valid induction hypothesis instances 
fundamental problem devising rule fixed points may interfere proofs elaborated 
problem illustrated 
formula assumed fixed point formula formula greatest fixed point formula 
node labelled interpreted locally fixed point interference instance induction hypothesis induction node labelled similarly uses induction node information relationship similarly node relating easily happens practice viz 
examples 
problem case unfolding fixed points interfere information provided unable cast proof proof founded induction nodes corresponding applications inductive hypothesis simple reason argument unsound 
hand knew node say casting exist nested induction problem arises practice illustrated examples 
example shows discharge fail fixed point interference 
example consider proof goal assumption states absence name passing needed illustrate problems infinite sequence transitions labelled contain finite number consecutive transitions labelled states infinite sequence transitions labelled contain finite number transitions mind consecutive 
false 
attempt build proof see construction breaks 
introduce abbreviations start refining subgoal rules unf unf 
continuing steps unfolding fixed point formulas treating conjunctions left right obtain subgoals subgoal refined rule mon unfolding unf approximating arrive judgment hope able discharge induction token refine expect able discharge inductively derivation fails preserve induction variable needed vice versa preserved path 
secondly give example showing discharge succeed 
example consider reversed proof goal stating infinite sequences transitions labelled contain finite number transitions infinite sequences transitions contain finite sequences consecutive transitions 
goal clearly valid 
abbreviations shall apply rules unf unf reduce subgoal continuing way preceding example arrive subgoals subgoals refined unf unf respectively case safe discharge judgments unfolding interfere rule discharge key task providing sound generally applicable rule discharge ffl task ensure discharged node determines progressing cycle proof structure node determines cycle cycle ordinal variable decreased recursive manner 
ffl second task ensure progress required safe discharge node undone cycles induced discharge node 
words traversing cycles induced node discharge critical progress ordinals belonging cycles regenerated 
possible games completely characterize conditions discharge safe 
game characterisation global condition useful proof construction main aim reported helpful trade complete global rule incomplete local 
versions rule discharge devised cf 
example applied ccs 
rule discharge 
rule discharge relies fixed arbitrary linear ordering fixed point formula abstractions assuming single fixed linear ordering restrictive recursive proof structures independent 
purpose examples theorems rest problem 
briefly discuss ways relaxing construction allow linear ordering built incrementally 
define critical notions regeneration progress discharge 
range proof structure nodes 
discharge applied facing proof goal rule applied node find elaborated node sense instance requires names term variables interpreted names substitution definition serves achieve 
definition regeneration progress discharge pi path elaborated 
suppose labelled gamma delta 
path pi regenerative name interpretation subformula gamma delta gamma subformula gamma delta gamma gamma require 
path pi progressive find subformula gamma delta gamma gamma 

gamma gamma 
node discharged node find substitution pi regenerative 
pi progressive 

assumptions oe gamma gamma xj oej assertions oe delta oej delta case term discharge node companion node 
definition slightly sloppy really identifying fixed point formula abstractions ordinal approximations explicitly stated 
condition states discharge take place node find ancestral node general condition node discharged provided cycle induced satisfies regeneration progress constraints 
observe efficient approximation condition test membership 
sj oej gamma oej delta respectively 
condition name interpretation extendable substitution making gamma delta identical weakened version gamma sn delta appear obvious way equality constraint restriction sets eased 
second cut rule cut explicitly garbage collect unused names proof elaboration proceeds 
progress condition requires existence cycle ordinal variable cycle value associated ordinal variable strictly decreased 
regeneration condition condition required ensure progress cycles formulas higher priority smaller ordering formula currently considered undone cycles nested 
concerning examples quite easy verify example linearisation fixed point formulas devised nodes discharged 
hand example linear ordering approximation ordinals 
observe linear ordering fixed point formula abstractions chosen quite freely 
expect correlation position linear ordering depth alternation viz 
example 
practice fact guide choosing suitable linear ordering 
show need require correlation priori 
construct examples cut proofs rule thumb 
compositional proof system obtained adding proof rules fixed points including rule discharge local rules section 
write gamma delta judgment gamma delta provable compositional proof system 
proof soundness proof system refer reader theorem soundness compositional proof system gamma delta gamma delta 
finite control completeness turn issue completeness consider generalisations completeness result theorem recursive formulas 
generalisation theorem seek general formulas finite control processes 
definition finite control agent say agent term uses agent identifier occurs occurs body identifier uses finite control agent closed agent term parallel operator occur body identifier notion finite control process direct generalisation notion finite state process case ccs 
completeness finite state ccs processes vs compositional proof system related proof system considered proved 
details formalisation particular rule discharge quite different proof system 
prove completeness finite control processes formulate model checker alternative non compositional proof system show whichever judgment provable model checker provable proof system preceding sections 
model checkers proof systems go considered proved complete finite control processes times 
similar techniques prove completeness version 
definition model checking judgments model checking judgment judgment form gamma oe formulas gamma elementary finite control 
define proof system apply model checking judgments 
proof system consists rules defining compositional proof system restricted model checking judgments excluding transition io modality rules 
proof system includes structural rules due restriction model checking judgments standard instance cut rules superfluous logical rules rules equality inequality 
transition rules replaced schemes poss gamma pj gamma oe inferred infer gamma oe nec gamma oe inferred pj gamma infer gamma oe rules gamma fresh bg gamma oe fresh rule discharge applies model checker modification 
effect conditions case degenerate model checker 
observe rules poss nec infinitary due quantification name interpretations 
name interpretations significant names fresh finite supply 
write gamma mc oe model checker proof gamma oe 
state soundness completeness model checker proof system proof theorem soundness completeness model checker model checking judgments gamma oe gamma mc oe gamma oe 
main obstacle proving completeness result seek need devise strategy choosing cut formulas order apply dynamic rules compositional proof system 
ways doing 
practice normally takes lazy approach just introduces logical variable stand required cut formula gradually instantiate variable need arises 
fact strategy may quite efficient suited parallel distributed implementations 
choose non lazy approach mainly proof easier 
processes assumed contain recursively defined contexts turns processes characterised completely case strong late bisimulation equivalence called characteristic formula 
shown case related calculus logic earlier 
assume finite control process 
assume formed process term name interpretation unique formula variable vis range sequences pairs process terms name interpretations pairs visited constructing characteristic formula 
formula char vis characteristic formula name interpretation visited list vis char vis xe vis xe oe oe oe describes potential transitions possible assuming oe describes property necessarily holding continuation oe char vis pj oe vis pj abstraction concretions define char vis fa char afb ag vis fn fa fn char vis char vis char vis char vis char vis abbreviate char char 
observe finite conjunctions disjunctions definition char 
reasons char vis ill defined computation char vis failed terminate easily happen care taken choosing names bound variables 
adopt conventions 
names linearly ordered time variable bound chosen minimal ordering 
identified appear freely shown char vis fact defined techniques 
just state fact 
proposition suppose finite control process 
char defined 
completeness proof need resort correctness property characteristic formulas 
leave proof quite easy lemma 
similar result proved 
statement lemma remainder section abbreviate hyp hyp set set names including free judgment consideration 
lemma finite control processes partitions hyp mc char embarking main completeness result need lemma pass results concerning terms substitutions results concerning open terms governed assumptions 
lemma finite control processes partitions hyp mc oe hyp char oe 
proof hint compositional proof model checker proof appealing monotonicity rules 
proof finite control completeness theorem deferred appendix theorem gamma mc oe gamma oe 
view theorem completeness finite control processes direct corollary corollary finite control completeness model checking judgments gamma delta gamma delta gamma delta 
natural numbers section consider specification nat section show proof systems formally demonstrate operations zero succ copy add satisfy desired properties 
observe zero succ simple static processes copy add 
proposition judgments derivable 
zero nat 
nat succ nat 
nat copy nat 
nat nat add nat concentrate section giving outline proof proving way 
proof quite straightforward proof variation theme 
main problem proof face process creation definition copy 
continuation copy contains term shape succ copy 
deal process cut replacing subprocesses succ copy state oriented descriptions continue proving correctness 
finding appropriate cut formula succ easy succ oe 
oe 
succ 

succ succ succ correctness succ easily proved proposition 
succ succ 
nat succ nat observe establishes proposition means process cut 
step find cut formula copy 
intention define property characterising sufficiently precise degree behaviour process term shape succ succ delta delta delta copy delta delta delta state machine oriented style specification 
machine predicated components state behaviour component corresponding successor processes component corresponding copy process 
component large extent execute concurrently 
propose definition cut formula generalized copy greatest fixed point formula 





nat 


nat nat definition equational terms 
definition easily rewritten proper greatest fixed point formula 
correctness reflected proposition proposition 
succ 
copy 
nat nat formal proof proposition quite sizable identified cut formulas routine 
observe proof uses process cuts 
proposition direct corollary proposition process cut 
may worthwhile clear intend advocate calculus calculus representations data types actual practice 
simpler accounts data types useful practical programming specification 
example serves illustrate fairly trivial data type processes executing parallel calculus representations data type embody simple sort mobility protocol behaviour correctness trivial 
observe connection achieve genuinely corresponding type correctness results effect results meta theory calculus reasoning internalised calculus proof system 
buffers section consider buffer properties style example 
consider instance formula describing absence spurious output 
task section show holds unbounded garbage collecting buffer 
usual creates processes dynamically process cut cut formulas reflect state machine behaviour 
start cells define sc sc sc sc sc buffer cells define bc 
bc bc bc 

straightforward task translate equational property descriptions proper greatest fixed point formulas 
task left reader 
main lemmas final correctness property item stated proposition proposition 
bc 
sc bc sc 
sc 
sc 
items proved straightforward manner 
exception 
goal directed proof starts desired judgment sc bc sc start approximating unfolding right hand side fixed point introducing conjunctions right 
result subgoals delta delta delta delta delta delta delta delta delta sc delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta observe steps give immediately cause discharge 
furthermore communication enabled may input may output identified assumption restriction set 
may output may input identified 
dispense subgoal 
subgoal possibilities input known distinct channels 
case input subgoal initial reasoning steps reduced delta delta delta sc bc sc resolved immediately 
second case input subgoal reduced delta delta delta sc bc sc discharged top level goal proposition 
subgoal need consider output obtain reduced subgoal delta delta delta sc bc sc need approximate unfold right hand side formula consider case action type turn 
analysis simpler done situation characteristic bc outputting case result enacting reductions corresponding scenario case subgoal shape delta delta delta sc sc instance generally easily provable fact parallel composition process affect behaviour 
regard absence spurious output garbage collecting unbounded buffer proved 
earlier modal temporal logic calculus includes 
milner parrow walker consider temporal connectives 
attempted automated model checking approach restricted finite control processes 
reconsidered model checking problem gave proof system non recursive formulas 
details different temporal logic somewhat different proof system cleaner symbolic approach essential efficiency practical applications 
important lines enquiry 
concerns practical applicability proof system 
sheer number rules involved proof system may 
hand rules intuitive number nature basic process formula connectives just lot cases considered 
judgment small easily comprehensible collection rules applicable 
far large majority proof steps entirely mechanical specific places choice points cut applications dilemma rule intelligence required 
proof system better geared computer aided tools pen 
sics currently extending reported core fragment ericsson erlang programming language including features asynchronous buffered communication data types natural numbers lists atoms pairing process identifiers pid dynamic pid creation process spawning sequential composition pattern matching 
equally important related line enquiry concerns source incompleteness proof system 
intuitively key problem proving properties parallel composition guess properties components 
possible find properties may case property divergence capability performing infinite sequence internal computation steps properties context free context sensitive inexpressible logic 
argued problem entire problem devising compositional proof systems futile 
subscribe view 
compositionality viewed matter compositionality useful tool brought bear warranted specific situation 
expressiveness source incompleteness 
case ought able prove completeness decidability judgments gamma oe oe fl ask derivability judgments decidable obvious implications utility approach 
results particularly important examples ones bring intuition principles exploring essential improvements basing solely global state exploration including instance approach 
observe completeness results finite control agents established suffice show power compositional proof system worse achieve simpler global approaches 
issues concern fundamentals proof system 
rules discharge needs better motivation giving 
really view discharge conditions finitary approximations conditions applying infinite proof structures leading automata characterisations 
shape local rules choice logical connectives open debate 
choose connectives 
certainly private input modality considered potentially valuable applications 
sense devise separate logical connective restriction 
concerning shape basic judgments important relativized turnstile 
restriction sets style order violate alpha convertibility presence free process variables 
hand expecting alpha convertibility open terms may unreasonable counterintuitive abandoning requirement judgments entire proof system may simplified considerably 
need obtain characterisations expressiveness lines explored modal calculus number authors 
concerning choice proof rules better completeness decidability results give sharper handles kind rules admitted 
promising approach embed directly proof system operational semantics proof rules style suggested simpson hennessy milner logic fixed points 
investigations direction ccs modal calculus reported 
progress direction useful remove apparent arbitrariness choice process calculus 
really expect able construct similar logics proof systems whichever versions calculus calculus matter want come 
logics proof systems equally attractive effort put choice version calculus remains faithful original calculus time permitting orthogonal treatments different modalities possible 
particular chosen avoid issue sorting 
calculus local deadlocks may arise case number arguments sending receiving actions match 
deeper relations sorting generally types static analysis techniques semantically proof systems ones consider outside scope 
due roberto amadio lars ake discussions related topics 
early parts developed collaboration roberto amadio reported 
helped matters formulating rule discharge 
due joachim parrow examples buffer specifications 
amadio dam 
modal theory types calculus 
proc 
lecture notes computer science 
henrik reif andersen colin stirling glynn winskel 
compositional proof system modal calculus 
proceedings ninth annual ieee symposium logic computer science pages paris france july 
ieee computer society press 
armstrong virding williams 
concurrent programming erlang second edition 
prentice hall international uk 
dam 
model checking mobile processes 
information computation 
dam 
proving properties dynamic process networks 
information computation 
dam 

parametric verification open distributed systems 
compositionality significant difference langmaack pnueli 
de roever eds springer 
dam 
compositional verification ccs processes 
proc 
psi 
janin walukiewicz 
expressive completeness propositional mu calculus respect monadic second order logic 
proc 
concur lecture notes computer science 
milner 
communication concurrency 
prentice hall international 
milner 
polyadic calculus tutorial 
technical report laboratory foundations computer science department computer science university edinburgh 
milner 
functions processes 
mathematical structures computer science 
milner parrow walker 
calculus mobile processes ii 
information computation 
milner parrow walker 
modal logics mobile processes 
theoretical computer science 
park 
finiteness mu 
theoretical computer science 
sangiorgi 
theory bisimulation calculus 
acta informatica 
davide sangiorgi 
calculus higher order calculus back 
proc 
tapsoft lecture notes computer science 
simpson 
compositionality cut elimination hennessy milner logic arbitrary gsos 
proc 
lics pages 
stirling 
modal logics communicating systems 
theoretical computer science 
walker 
objects calculus 
information computation 
appendix proofs section proposition include set non fresh names gamma oe 

oe elementary hyp oe hyp oe 

gamma oe hyp oe gamma 
proof soundness 
induction structure oe 
oe 
reduce hyp hyp fb ag 
reduced elementary reasoning set judgments hyp fbg fb ag required agree element set provable induction hypothesis 
oe 
hyp oe find hyp fb ag 
chosen case hyp fb ag ind hyp 
hyp oe hyp fbg fb ag case hyp fbg fb ag hyp fbg oe 
hyp delta delta delta oe definition hyp delta delta delta oe suffices cut prove hyp oe desired 
remaining cases quite easy 
induction complexity gamma 
gamma 
oe hyp oe 
direction 
gamma gamma 
suppose gamma oe gamma 
reduce goal hyp oe subgoals hyp hyp oe second subgoal easily dealt cut induction hypothesis showing hyp fl fl hypothesis gamma subgoal proved reduce hyp fb ag goals form hyp fbg fb ag agrees induction hypothesis reduced single goal gamma fa ag xm fam ag xm fb ag fb ag directly provable 
conversely need show gamma oe assumption hyp oe gamma 
reduce gamma oe gamma oe fa cut reduced gamma delta delta delta oe reduced gamma fb ag delta delta delta oe fresh cut gamma fb ag delta delta delta oe observe gamma gamma fb ag delta delta delta result follows induction hypothesis 
remaining cases left reader 
lemma decomposition include fn efe fn fn oe suppose efe closed suppose oe nonrecursive 
gamma hyp 
gamma efe oe oe oe modal depth exceeding oe 
gamma fresh oe 
gamma oe oe oe proof assume preconditions lemma hold 
proof induction modal depth oe structure structure oe 
order connectives dealt generic manner 
oe 
contradiction 
oe oe obtain gamma fresh oe gamma oe oe oe elementary reasoning proposition 
cases oe inequation oe similar 
oe gamma efe induction hypothesis find oe oe sufficiently small modal depth gamma fresh oe gamma oe oe done 
oe 
suppose obtain gamma efe 
induction hypothesis find appropriate gamma fresh gamma oe chosen gamma oe rules gamma oe oe oe 
case similar 
oe 
find gamma efe fb ag induction hypothesis find appropriate oe oe gamma oe gamma oe oe 
gamma oe oe oe done 
secondly deal process connectives generic manner assume assume gamma case symmetric 
gamma oe 
nd level induction hypothesis find oe oe gamma fresh oe gamma oe oe oe 
gamma proposition gamma oe oe cond elementary reasoning conclude gamma oe oe oe desired 
obtain gamma oe context identified 
nd level induction hypothesis find oe oe gamma fresh oe gamma oe oe oe 
gamma oe oe oe new gamma oe oe oe cond gamma oe oe oe desired 
remaining case case obtain gamma oe nd level induction hypothesis find oe oe gamma fresh oe gamma oe oe oe 
gamma oe oe oe irr gamma oe oe oe 
gamma oe oe oe desired 
obtain gamma oe nd level induction hypothesis find oe oe gamma fresh oe gamma oe oe oe gamma oe oe oe new 
gamma fresh oe fresh 
remaining connectives proceed induction modal depth agent structure 
oe 
continue induction structure ffl 
contradiction 
ffl gamma 
nd level induction hypothesis find oe oe desired properties 
gamma fresh oe gamma oe oe plus 
ffl contradiction 
ffl case gamma gamma 
outer level induction hypothesis act done 
ffl assume gamma case symmetrical 
outer level induction hypothesis find gamma fresh gamma fresh gamma 
obtain gamma fresh gamma fresh gamma par elementary reasoning 
nd level induction hypothesis find oe oe gamma fresh oe gamma oe oe fresh oe oe oe result obtained elementary reasoning cuts 
ffl contradiction 
ffl efa closed proceed induction structure oe 
previous case observing rules relevant modality correlates subcase attention case assume 
fb cg gamma fb cg 
gamma fb cg 
outer induction hypothesis find fresh gamma fresh gamma fresh gamma fb cg gamma fresh goal need show gamma par reduce subgoals gamma fresh gamma fresh isa gamma subgoals quite trivial resolved com reduce gamma new obtain subgoal gamma proved 
case communication free similar left reader 
oe 
similar case 
oe 
consider case identify formulas gamma fresh similarly formulas fl fl fl fl gamma fresh fl fl fl fl premises par derivable 
assume efe gamma 
cases interest 



fb cg 


fb cg 
cases symmetric 
case find outer level induction hypothesis fl gamma fresh gamma fresh fl gamma fl 
case find fl gamma fresh gamma fresh fb cg fl gamma fl 
case find fl gamma fresh gamma fresh fb cg fl gamma fl 
symmetric cases fl identified similarly 
define isa oe fb fb cg 
isa oe fb fb cg fb dg 
oe fb fb cg 
oe fb fb dg fb cg 
fresh abbreviates conjunction inequations occurs freely formulas fl fl defined symmetrically 
need show gamma fresh conjunct considered separately 
quite easy left aside 
third need show gamma fresh isa oe fb fb cg fb dg 
reduced gamma fresh fresh oe fb cg fb dg assume assuming fresh need show gamma fresh fb cg fb cg fb dg follows induction hypothesis 
remaining conjuncts verified similarly 
need show gamma fl fl fl fl par need show gamma fl gamma gamma isa fl gamma isa fl gamma fl isa gamma fl isa subgoals easily proven assumptions 
show reduce goal form gamma fl provable induction hypothesis 
proved similarly 
show reduce goal elementary reasoning subgoal form gamma fb fb cg 
fb fl fb cg 
show 
show gamma fresh oe fb cg fb fl fb cg 
reduced gamma fb cg fl fb cg turn reduced com gamma fb cg fl fb cg provable induction hypothesis 
just remains nd level induction hypothesis observing modal depth increased identify desired oe oe put desired proof cut 
routine 
oe 
proceed induction agent structure 
ffl deal blow abstraction cases contradictory 
remaining cases ffl relevant case abstraction process symmetrically 
write gamma fa bg 
fa bg smaller size nd level induction hypothesis applies produce gamma fresh fa bg gamma fresh isp gamma isp 
gamma fresh gamma isp desired par little elementary reasoning 
ffl gamma ffe bg nd level induction hypothesis find oe oe gamma fresh oe gamma oe oe ffa bg 
done 
ffl case proceed induction structure oe oe oe 
similar previous case 
appendix proof theorem theorem gamma mc oe gamma oe 
proof observe safe assume names fresh gamma determines unique gamma 
case dilemma rules apply sides reduce problem number problems possess property 
uniquely determined assume identity names 
substitution fe consider model checker node labelled gamma ej oe variables occurs linearly aim produce proof tree gamma delta oe delta show tree constructed root model checker node leaves discharged 
proof induction number occurrences ej structure model checker proof 
subcases base inductive steps outer induction common proceed directly case analysis structure model checker proof 
suppose axiom leaf instance refl irr new nec case ej 
case obtain gamma ej oe theorem 
leaves discharged considered 
assume internal node 
consider possible rule turn 
get rules unique model checker proof system 
poss assume oe oe model checker rule application infers gamma ej oe showing ej gamma oe observe form proceed induction size inference ej cases 
variable case obtain lemma gamma delta oe 

sum 
ej innermost induction hypothesis gamma delta oe plus gamma delta oe 

pre 
case gamma fj oe nd rd level induction hypothesis gamma delta oe tau act gamma delta oe 

par 
assume simplicity inference ej shape 
build proof tree node gamma delta oe apply cut reduce subgoals gamma delta char gamma delta char oe lemma know gamma mc char outermost induction hypothesis gamma delta char 
left 
unfolding lhs fixed point introducing left reduced gamma delta char oe turn reduced gamma delta char oe subgoal gamma delta isp proved theorem 
goal stands desired relation model checker node gamma oe remaining cases par easily proved similar fashion 

com free communication 
assume inference ej shape 
ej fb dg lemma obtain gamma mc char gamma mc char char char goal prove gamma delta oe cuts reduce gamma delta gamma delta gamma delta oe subgoals obtained outermost induction hypothesis 
par reduced subgoal gamma delta oe done communication needs completed 
observe char fd char efe dg fn fd fn char reduce gamma delta fb delta delta delta delta delta delta oe com boolean reasoning gamma delta char char fb dg oe case provably distinct free names absent done immediately observe char char done 

com bound communication 
assume inference ej shape 
ej fb dg proof follows previous subcase quite closely 
char char goal gamma delta oe reduced cuts outermost induction hypothesis judgment form 
previous subcase reduced subgoal form 
observe char unchanged 
com com observe alpha conversion identify bound bound reduce current goal gamma delta char fd bg fd delta delta deltag fd delta delta deltag delta delta delta oe boolean reasoning gamma delta char fd bg char oe required result 

res open 
assume inference ej shape fj ej reduction simple gamma delta oe gamma delta oe new 

id 
assume inference ej shape ag ej delta case reduction straightforward fix 
completes case oe diamond formula 
case oe box formula quite similar cases input output 
cases omitted 
need pay attention proper discharge hypotheses 
dealt quite simply observing structure model checker proof particular pattern unfoldings greatest fixed point formulas reflected structure compositional proof system proof particular leaves discharged proof correspond leaves discharged 

