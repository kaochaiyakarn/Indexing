proceedings th annual ieee symposium logic computer science 
typed calculus synchronous processes simon gay nagarajan doc ic ac uk 
rn doc ic ac uk 
department computing imperial college science technology medicine queen gate london sw bz propose typed calculus synchronous processes structure interaction categories 
aim develop calculus concurrency canonical sense typed calculus canonical functional computation 
show strong connections syntax logic semantics analogous familiar correspondence typed calculus intuitionistic logic cartesian closed categories 
fundamental study functional computation theoretical practical reasons 
foundational side elegant connections typed calculus intuitionistic logic cartesian closed categories leading propositions types paradigm development categorical logic 
practical point view compile time type reconstruction boon programmer languages standard ml haskell 
turning concurrency situation satisfactory 
generally accepted foundation typed concurrent programming canonical untyped calculus slow emerge 
difficulties constructing type system greater concurrent sequential case potential benefits wide range concurrent program properties hope specify types verify type checking 
examples deadlock freedom liveness fairness 
abramsky interaction categories established semantic foundation typed concurrency capability constructing types specify complex properties 
extends propositions types paradigm concurrency classical linear logic forming core type system classical linear logic sequent process interface description key idea proofs processes interpretation 
interaction categories types specifications objects processes morphisms interaction composition 
types viewed specifications typing rule categorical composition compositional proof rule specified property striking application idea development type system deadlock freedom 
ideas basis typed calculus synchronous processes 
ultimate goal research begun develop calculus typed concurrency may considered canonical sense typed calculus canonical functional computation 
addition close connection logic semantics curry howard isomorphism categorical logic correspondence 
calculus form considered canonical clear canonicity means concurrency 
represents successful step entire theoretical development spirit typed calculus 
syntax calculus inspired existing process calculi especially sccs linear realisability algebras 
types classical linear logic extensions relating time 
calculus operational semantics usual style yields notion typed bisimulation 
subject reduction theorem stating types unchanged transitions results dynamic subject reduction states transitions cause types evolve predictable ways static subject reduction states approximation type term number ports preserved 
define categorical semantics interprets typed term morphism category suitable structure 
appropriate categories synchronous interaction categories sproc see appendix 
correctness full abstraction results relate categorical semantics sproc operational semantics 
indicate standard results concerning construction initial models typed calculi syntactic categories transferred concurrent situation 
syntax signature sg process calculus specified data 
ffl collection ground types 
collection types defined grammar ff fl ff omega ff ff ff ff ffi ff fl ground type 
ffl collection ground actions 
collection actions defined grammar oe oe ground action 
ffl collection ground prefixes consists ground action pair ground types written pre oe fl fl subject restriction pre oe fl fl pre oe fl fl ground prefixes fl fl prefixes generated sg ground prefixes expressions pre ff fi derived ground prefixes means rules 
action represents idling corresponds type constructor ffi 
available prefix 
step define raw processes untyped process terms omega delta pn nil xn fix assume countable collection fx variables standard notions free bound variables grammar bound variables free raw processes ff equivalence 
proved processes generated sg expressions ff xn ff derived rules 
form proved process exactly specified proofs processes interpretation 
expression raw process ff types variables 
order ff unimportant 
expression read process interface ff xn ff confused usual notation intuitionistic sequents expression gamma means proved hypotheses gamma 
variable corresponds port process port type 
labelling ports way means process constructions able refer particular ports 
port place actions happen calculus clear distinction ports actions 
prefixing rule takes proved process fi prefix action forms process ff sccs action note change type governed prefix judgement containing pre ff fi 
reason change type caused prefixing calculus intended interpreted interaction category sproc 
type sproc contains safety specification set permissible finite traces satisfies safety specification satisfies specification def fs sg general specifications different difference reflected different syntactic types precise connection semantic specifications expressed syntactically judgement pre ff fi 
prefix rule hypothesis process just port 
process ports repeatedly derivation combines ports uses prefix combination rule prefix pair actions fl ffi fl ffi pre ff fl pre fi ffi pre ff fi fl ffi ff fi turn process fl ffi fl ffi cutting suitable process constructed identity axioms 
difference fl ffi fl ffi lies solely interface viewed process terms identified categorical semantics 
pre ffi ff ff pre ff fi pre ff fi pre ff fl pre fi ffi pre ff omega fi fl omega ffi pre ff fl pre fi ffi pre ff fi fl ffi prefixes generated process signature prefixing rule fi pre ff fi prefix ff multiplicative rules gamma ff fi par gamma ff fi gamma ff delta fi tensor omega gamma delta ff omega fi connection rules gamma ff delta ff cut delta gamma delta gamma ff ff cycle pn gamma axiom ff ff summation rules gamma gamma sum gamma nil nil ff ff xn ff xn ff recursion rule ff delta delta delta ff fix ff sequential guarded proved processes generated process signature tensor rule gives way combining ports 
time ports taken different processes resulting process interface formed interfaces original ones 
combining processes tensor synchronous product sccs possibility communication 
cut rule connects processes way communication allowed required 
sccs terms combination synchronous product restriction exactly interpretation cut put forward proofs processes seen definition composition sproc 
cycle rule cut ports process connected 
axiom rule produces process acts buffer wire useful rearranging interfaces 
sum rule sccs allows construction non deterministic combination processes processes interface 
nil rule allows nil processes introduced interface usual nil unit 
recursion rule simplified form allows single variable full calculus number mutually recursive definitions allowed 
cases standard restrict attention sequential guarded recursive definitions 
illustration calculus consider simple example synchronous fork gate connected 
gamma gamma convenient introduce double cut rule consists cut followed cycle 
delta denotes double cut ports processes effect simultaneously forming connections ports ports 
gamma ff fi delta ff fi delta gamma delta construction generalised obtain multi cut rule replace cut cycle rules syntax 
form syntax easily adapted situations cycle rule wanted may case types express subtle properties 
similar comment justifies distinguishing syntactically omega identified categorical semantics 
circuit fork fork delta boolean type ft fg 
course resulting process just wire correct type 
note distinction input output types actions sccs 
process fork defined informally recursive equation fork fork fork derivation fork begins process prefixes prefixes constructed prefix combination rules correct ground prefixes specified 
allow set traces permissible traces effectively ignoring safety specifications example prefixes involve type change 
construct process recursion rule build fix fix expression call fork 
process constructed similarly 
operational semantics operational semantics typed process calculus defined transition rules stands tuple actions 
transitions defined proved terms explicit types type proved term necessarily unique example pre ff fi pre fl fi nil fi ff nil fi fl proved terms 
main points note cut rule processes communicate performing action ports connected tensor rule actions processes combined par rule actions single process 
cycle rule similar cut matching actions come prefix pre ff fi ff fi par gamma ff fi gamma ff fi gamma ff fi gamma ff fi tensor gamma ff gamma ff delta fi delta fi omega gamma delta ff omega fi omega gamma delta ff omega fi cut gamma ff gamma fi delta ff delta fi delta gamma delta delta gamma delta cycle gamma ff ff gamma fi fi pn gamma gamma axiom pre ff fi ff ff fi fi summation gamma gamma gamma gamma gamma gamma gamma gamma recursion fix ff fi fix ff fi operational semantics typed process calculus process cycle par cut tensor 
prefix rule base case 
typed programming language usually subject reduction theorem states transitions reductions operational semantics alter types terms 
typed process calculus situation different transition rule prefix potential change types 
changes type process transitions arbitrary controlled pre expressions signature possible prove dynamic subject reduction theorem straightforward induction transition rules 
theorem dynamic subject reduction ff xn ff fi ym fi pre ff fi derivable 
leads general observation role subject reduction theorems theory typed programming languages 
point having types typed programs correctness property property preserved reductions programs remain correct evaluation 
correctness follows typability satisfaction particular type usual subject reduction theorems stronger necessary deduce correctness preserved evaluation necessary know typed program type reduction step 
general types process terms changed transitions aspect type term stays essentially number ports connectives combined 
static subject reduction result formal 
statement requires function maps types formal constructions involving single ground type follows fl ground type sg 
fl def ff def ff ffi ff def ff ff omega fi def ff omega fi ff fi def ff fi lemma pre ff fi derivable ff fi 
theorem static subject reduction ff xn ff fi xn fi fi ff 
proof theorem pre ff fi derivable lemma ff fi operational semantics calculus defined natural strong bisimulation notion equivalence 
fact variation strong typed bisimulation requires equivalent processes type 
purposes simply call strong bisimulation keep original notation 
proposition strong bisimulation congruence 
proof proposition straightforward essentially sccs 
follows definition operational semantics substitutions change strong bisimulation classes 
proposition gamma ff free 
syntax calculus allows certain process configurations described different ways 
example diagram represents result processes forming connection omega combine port resulting process port third process qj syntax described terms delta omega delta omega ports suitably named 
expected processes shown bisimilar 
syntactic distinctions form inevitably introduced textual notation represent dimensional structures exactly problem occurs linear logic sequent proofs proof nets 
instances bisimulation arising similar reasons 
source bisimilar processes cut elimination 
process configurations related viewed proof nets bisimilar example ff delta ff 
cut elimination corresponds fi reduction curry howard isomorphism process calculus transitions orthogonal fi reductions semantically fi reduction absorbed equality 
full list equivalences see 
categorical semantics typed process calculus semantics suitably structured category 
com pact closed category autonomous category omega coincide countable functor interprets exponential linear logic comonad comonoid structure 
additionally strict monoidal endofunctor ffi write ffi mon ffi omega ffi ffi omega associated isomorphisms 
endofunctor unique fixed point property fa fb unique fa oe fb fh commutes 
categorical formulation statement certain guarded recursive equations unique solutions suitable equation fh defines uniquely guarded recursion 
final requirement functor 
phi ffi 
conditions simplification general axiomatisation synchronous interaction categories 
yield commutative monoid structure nil homset omega distributes gamma preserves 
partial order homset defined def order preserved omega gamma structure process signature sg specified data 
ffl ground type fl sg object function deltak extended inductively types jff def jff omega fik def omega jff fik def jffi ffk def lists named ports jx xn def ja jan ffl ground prefix pre oe fl fl pair morphisms oe fl fl oe fl fl oe fl fl oe fl fl id id pre fl fl fl fl fl fl function deltak extended prefix judgements natural way example ffi ff ffk def id ffi ff ffk def id ff omega ff fi omega fi def mon gamma ff fik omega ff fi ff omega ff fi omega fi def ff fik omega ff fi mon proposition pre ff fi derivable ff fik ff fik id ff fik ff fik id proof induction derivation pre ff fi fact omega gamma preserve 
proved process gamma generated sg morphism jp gammak gammak defined induction derivation gamma 
note regroup omega omega omega canonical morphisms autonomous category ap evaluation currying respectively iso denote canonical isomorphism 
axiom ji ff ffk def 
cut jp delta gamma deltak def iso jp omega regroup id ap id iso 
cycle jpn gammak def jp iso id ap iso 
tensor jp omega gamma ff omega fi deltak def iso jp omega regroup iso 
par gamma ff fik def jp gamma ff fik summation jp gammak def jp gammak jq gammak 
prefix ffk def ff fik 
recursion consider fix ff 
delta delta delta ff constant process en possibly empty sum terms guarded prefixes 
term morphism ffi constructed prefixes 
je sum morphisms nil en nil form phi phi ffi phi delta delta delta coproduct property phi 
canonical morphism phi ffi phi delta delta delta constructed ffi 
morphism defined applying 
phi ffi structure interpret full version recursion rule lack space prevents describing 
point important appear syntax 
semantics sproc typed process calculus intended interpretation sproc 
structure sproc process signature sg defined follows 
process signature sg defines labelled transition system states ground types sg labels actions appearing ground prefixes fl fl pre fl fl labelled transition system considered directed graph labelled edges number connected components component set sigma actions consisting labels occur example sg ground types ground prefixes pre pre pre pre graph psi gamma gamma gamma gamma gamma case types connected component 
set labelled paths graph starting type defines safety specification process type satisfies follows dynamic subject reduction theorem 
practice starts desired safety specification represents set paths graph uses graph define suitable ground prefixes 
general ground type fl fl connected component containing fl 
object defined sigma def sigma fl def fs fl fl gamma 
fl prefix judgement pre fl fl fl fl defined id jfl fl fl defined id jfl conditions morphisms satisfy easily checked 
proved process gamma synchronisation tree tree gamma defined operational semantics 
key correctness result states sproc semantics produces tree trivial relabelling 
proposition correctness deltak semantics sproc proved process gamma jp gammak tree gamma 

proof induction derivation gamma 
case transition rules gamma sproc definition jp gammak 
corollary gamma proved process traces tree gamma gammak result links denotational equality strong bisimulation 
theorem full abstraction deltak semantics sproc proved processes gamma gamma gamma jp gammak jq gammak proof gamma tree gamma tree gamma jp gammak jq gammak proposition jp gammak jq gammak coincide sproc 
categorical logic significant aspect theory typed calculus close connection syntax semantics formalised construction syntactic categories proof various correspondence theorems 
progress similar connection interaction categories 
idea process theory process signature collection axioms expressions form gamma gamma gamma proved processes 
collection rules deriving equations theorems theory 
process calculus style case rules deriving instances bisimulation rules generating theorems 
notion model process theory suitable category form interaction category model provably equal processes equal interpretations 
process theory set possible construct category object type theory morphism ff fi equivalence class proved processes ff fi provable equality 
canonical model process theory category model satisfies universal property model theory category factors canonical model followed interaction category functor 
conversely interaction category process theory extracted operations moving theory category vice versa inverse 
theory worked version typed process calculus prefixing handled slightly differently commitment synchrony asynchrony 
related investigations foundations concurrency included types varying amounts emphasis 
milner action structures monoidal categories may connection linear types honda proposed typed calculus similar calculus ferrari montanari approach types changed transitions prasad described calculus type system girard lu 
key novelty approach combines propositions types view categorical semantics aims exploit interaction category view types specifications 
defined typed process calculus structure interaction categories 
addition operational semantics defined categorical semantics category satisfying certain axioms 
category sproc case obtain full abstraction theorem relating operational categorical semantics 
calculus extends original ideas proofs processes interpretation adapting syntax prefixing dynamic behaviour defined 
formulation syntax processes type system linear logic categorical semantics represents successful transfer curry howard isomorphism categorical logic correspondence concurrency 
theory interaction categories applied case studies cyclic scheduler dining philosophers order demonstrate type theoretic approach specification verification 
reported 
constructed systems studied describing components labelled transition systems combining direct application categorical combinators 
developed formal syntax construction typed concurrent systems 
syntax provides suitable basis automated type checking concurrent programs 
reasons decision study synchronous calculus 
synchronous interaction categories structure easier define 
syntactic point view asynchronous calculus slightly complex prefix combination rules needed 
soon possible formulate asynchronous version 
extension synchronous calculus delay monads ffi delta sproc corresponding milner construction ccs sccs investigated allows asynchronous processes constructed synchronous framework 
syntax calculus stages refinement may come designing syntax easy sufficiently powerful difficult task 
calculus terms proved processes explicitly typed 
investigate implicit typing develop type inference reconstruction scheme 
extend typed calculus incorporate mobile processes 
desirable able adapt typed calculus order define processes categories types just safety specifications example deadlock free category sproc 
samson abramsky influential ideas form basis 
mart abadi samson abramsky michel michael huth radha jagadeesan guy mccusker valuable comments draft 
simon gay funded epsrc studentship eu project coordination esprit bra raja nagarajan eu project confer esprit bra gratefully acknowledge support 
abramsky 
interaction categories extended burn gay ryan editors theory formal methods proceedings imperial college department computing workshop theory formal methods pages 
springer verlag workshops computer science 
abramsky 
interaction categories communicating sequential processes 
roscoe editor classical mind essays honour hoare pages 
prentice hall international 
abramsky 
interaction categories synchronous processes 
preparation 
abramsky gay nagarajan 
interaction categories foundations typed concurrent programming 
broy editor deductive program design proceedings marktoberdorf international summer school nato asi series computer systems sciences 
springer verlag 
appear 
marktoberdorf ps gz directory theory papers abramsky anonymous ftp theory doc ic ac uk 
abramsky 
proofs processes 
theoretical computer science 
abramsky jagadeesan 
new foundations geometry interaction 
information computation 
aczel 
non founded sets 
csli lecture notes 
center study language information 
barr 
autonomous categories volume lecture notes mathematics 
springer verlag 
crole 
categories types 
cambridge university press 
crole gay nagarajan 
internal language interaction categories 
hankin mackie nagarajan editors theory formal methods proceedings second imperial college department computing workshop theory formal methods 
appear 
ferrari montanari 
typed additive concurrency 
submitted publication 
gay 
linear types communicating processes 
phd thesis university london 

girard 
linear logic 
theoretical computer science 

girard lafont taylor 
proofs types volume cambridge tracts theoretical computer science 
cambridge university press 
hoare 
communicating sequential processes 
prentice hall 
honda 
types dyadic interaction 
concur lecture notes computer science 
springerverlag 
lambek scott 
higher order categorical logic 
cambridge studies advanced mathematics vol 

cambridge university press 
mac lane 
categories working mathematician 
springer verlag berlin 
milner 
calculi synchrony asynchrony 
theoretical computer science 
milner 
communication concurrency 
prentice hall 
milner 
action structures 
technical report laboratory foundations computer science department computer science university edinburgh 
milner parrow walker 
calculus mobile processes 
technical report laboratory foundations computer science department computer science university edinburgh 
prasad 
formulae types view communicating applicative programs extended summary technical report ecrc 
seely 
linear logic autonomous categories cofree coalgebras 
contemporary mathematics 
honda kubo 
language typing system 
proceedings th european conference parallel languages architectures number lecture notes computer science 
springer verlag 
appendix interaction category sproc brief sproc category synchronous processes 
full definitions 
object sproc pair sigma sa sigma alphabet actions sa sigma safety specification non empty prefix closed set traces 
process type written synchronisation tree labels sigma traces sa strong bisimulation notion equivalence 
define operations synchronisation trees labelled transition rules formal models synchronisation trees obtained example working aczel non founded set representation 
object omega sigma omega sigma theta sigma sa omega foe sigma omega fst oe sa snd oe sb duality trivial objects multiplicative connectives omega morphism process omega self dual sproc autonomous compact closed 
composition defined line slogan relational composition extended time 
defined labelled transitions matching actions takes place common type relational composition time step 
interaction interaction categories 
identity morphisms synchronous buffers received id left copy instantaneously transmitted right copy 
process id sort sigma defined sigma id id id obtained pruning id satisfies safety specification sa extend omega delta functors defining action morphisms follows 
omega omega omega defined omega omega 
tensor unit defined sigma fg correct notion point autonomous category morphism identify process type morphism omega defined application morphism ap omega obtained pruning ap identity morphisms ap defined sigma sigma ap ap definitions structural morphisms symm omega omega similar 
coincidence omega despite degeneracy usually seek avoid models linear logic useful connecting processes validates cycle rule allows arbitrary process networks constructed 
products sproc defined disjoint union alphabets terminal object empty alphabet 
self duality gives zero object 
delay functors manipulate temporal structure 
unit delay functor ffi sigma ffi fg sigma ffi ffflg fs sa assuming sigma define ffi ffi ffi ffi delay functors ffi allows delay action delta allows delay action structure monads correspond milner delay operators 
