linear scan register allocation massimiliano poletto laboratory computer science mit vivek sarkar ibm thomas watson research center describe new algorithm fast global register allocation called linear scan 
algorithm graph coloring allocates registers variables single linear time scan variables live ranges 
linear scan algorithm considerably faster algorithms graph coloring simple implement results code efficient obtained complex time consuming register allocators graph coloring 
algorithm interest applications compile time concern dynamic compilation systems just time compilers interactive development environments 
categories subject descriptors programming languages processors compilers code generation optimization general terms algorithms performance additional key words phrases code optimization compilers register allocation 
register allocation important optimization affecting performance compiled code 
example register allocation improve performance spec benchmarks order magnitude relative compiled poor register allocation 
unfortunately aggressive global register allocation algorithms computationally expensive due graph coloring framework chaitin interference graph worst case size quadratic number live ranges 
describe global register allocation algorithm called linear scan graph coloring 
live ranges variables function algorithm scans live ranges single pass allocating registers variables greedy fashion 
algorithm simple efficient produces relatively code 
useful situations compile time code quality research supported part advanced research projects agency contracts 
max poletto supported nsf national young investigator award awarded frans kaashoek 
synopsis algorithm appeared poletto 
permission digital hard copy part material fee personal classroom provided copies distributed profit commercial advantage acm copyright server notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
acm acm transactions programming languages systems vol 
september pages 
massimiliano poletto vivek sarkar important dynamic compilation systems just time compilers interactive development environments 
evaluate compile time performance linear scan algorithm run time performance resulting code 
evaluate compile time speed algorithm compare fast graph coloring allocator tcc dynamic compiler poletto 
evaluate quality generated code implemented algorithm machine suif compiler backend smith amarasinghe compare resulting code code obtained aggressive graph coloring algorithm performs iterated register coalescing george appel 
addition compare linear scan second chance binpacking traub type linear scan algorithm invests compile time order produce better code :10.1.1.1.9128
linear scan algorithm times faster fast graph coloring register allocator performs coalescing 
resulting code quite efficient benchmarks studied fast code generated aggressive graph coloring algorithm benchmarks 
comparison simple comparably fast register allocation schemes allocating available registers frequently variables result code times slower 
rest article organized follows 
section summarizes related global register allocation section outlines program model representation assumed 
details register allocation algorithm appear section 
section presents measurements algorithm performance 
section discusses extensions algorithm directions section summarizes main results 

related global register allocation studied extensively literature 
predominant approach proposed chaitin register allocation problem graph coloring problem 
nodes graph represent live ranges variables temporaries virtual symbolic registers candidates register allocation 
edges connect live ranges interfere live ranges simultaneously live program point 
register allocation reduces graph coloring problem colors registers assigned nodes nodes connected edge receive color 
graph colorable nodes deleted graph reduced graph colorable 
deleted nodes said spilled assigned registers 
basic goal register allocation graph coloring find legal coloring deleting minimum number nodes precisely deleting set nodes minimum total spill cost 
chaitin algorithm features coalescing technique eliminate redundant moves 
source destination move instruction share edge interference graph corresponding nodes coalesced move eliminated 
unfortunately aggressive coalescing lead graphs additional live ranges need spilled memory 
graph coloring briggs george acm transactions programming languages systems vol 
september 
linear scan register allocation appel focused removing unnecessary moves conservative manner avoid introducing spills 
simpler heuristic solutions exist global register allocation problem 
example lcc fraser hanson allocates registers variables highest estimated usage counts places stack allocates temporary registers expression doing tree walk 
linear scan viewed global extension special class local register allocation algorithms considered literature hsu fraser hanson motwani turn take inspiration optimal line replacement algorithm studied virtual memory belady 
original description linear scan algorithm poletto traub proposed complex linear scan algorithm call second chance binpacking traub :10.1.1.1.9128
algorithm evolution refinement binpacking technique years dec gem optimizing compiler 
high level binpacking schemes similar linear scan invest time compilation attempt generate better code 
second chance binpacking algorithm allocation decisions rewrites code pass 
algorithm allows variable lifetime split multiple times variable resides register parts program memory parts 
takes lazy approach spilling emits store variable live particular point register memory values variable consistent 
program point register hold value variable currently register registers allocated variables algorithm evicts variable allocated register 
tries find currently live avoid store live live range avoid evicting variable live 
binpacking emit better code linear scan compile time 
linear scan binpacking keeps track lifetime holes variables registers intervals variable maintains useful value register store value maintains information consistency memory register values reloaded variable 
algorithm analyzes information allocation spilling decisions 
furthermore linear scan perform additional resolution pass resolve conflicts nonlinear structure control flow graph assumptions linear register allocation pass 
section compares performance algorithms code generate 

program model article assume program intermediate representation consists rtl quads pseudo instructions 
register candidates live ranges represented unbounded set variable names virtual registers arithmetic operations performed directly virtual registers load store instructions necessary accessing virtual registers 
convention variables acm transactions programming languages systems vol 
september 
massimiliano poletto vivek sarkar live entry start node flow graph initialization procedure parameters captured explicit assignments start node 
variable renaming live range splitting performed linear scan algorithm 
may beneficial perform renaming phase renaming webs muchnick computing right number names auslander hopkins optional linear scan algorithm 
study required determine extent compile time overhead extra renaming phase justified accompanying run time improvement 
linear scan algorithm assumes intermediate representation numbered order 
possible ordering pseudo instructions appear intermediate representation 
depth ordering reverse order nodes visited preorder traversal flow graph aho 
rest article depth order 
choice instruction ordering affect correctness algorithm may affect quality allocation 
discuss alternative orderings section 
central linear scan algorithm notion live interval 
numbering intermediate representation variable instruction number live instruction number live information conservative approximation live ranges may subranges live ignored 
trivial live interval variable number pseudo instructions intermediate representation live interval correct takes time compute yields information 
live intervals lie spectrum trivial live interval accurate live interval information 
order chosen numbering pseudo instructions influences extent accuracy live intervals quality register allocation definition live intervals rely assumptions particular numbering 

linear scan algorithm live variable information obtained example data flow analysis aho live intervals computed easily pass intermediate representation 
interference live intervals captured overlap 
available registers list live intervals linear scan algorithm allocate registers intervals possible overlapping live intervals allocated register 
intervals overlap point reside memory 
details number overlapping intervals changes start points interval 
live intervals stored list sorted order increasing start point 
algorithm quickly scan forward live intervals skipping start point 
step algorithm maintains list active live intervals overlap current point placed registers 
active acm transactions programming languages systems vol 
september 
linear scan register allocation active foreach live interval order increasing start point length active register register removed pool free registers add active foreach interval active order increasing point endpoint return remove active add register pool free registers spill interval active endpoint spill endpoint register register spill location spill new stack location remove spill active add active location new stack location fig 

linear scan register allocation 
indentation denotes nesting level 
assume live intervals including endpoint information computed prior liveness analysis phase 
order increasing point 
new interval algorithm scans active 
removes expired intervals intervals longer overlap new interval point precedes new interval start point corresponding register available allocation 
active sorted increasing point scan needs touch exactly elements need removed plus halt soon reaches active remains empty encounters interval point follows new interval start point 
length active 
worst case scenario active length start new interval intervals active expired 
situation current live intervals active new interval spilled 
possible heuristics selecting live interval spill 
heuristic described remaining length live intervals 
algorithm spills interval ends furthest away current point 
find interval quickly active sorted increasing point interval spilled new interval interval active whichever ends 
straight line code live interval consists exactly definition followed heuristic produces code minimal possible number spilled live ranges belady acm transactions programming languages systems vol 
september 
massimiliano poletto vivek sarkar fig 

example set live intervals 
letters left variable names corresponding live intervals appear right 
numbers italics refer steps linear scan algorithm described text 
motwani 
case live interval may cover arbitrarily definitions uses spread different basic blocks heuristic appears 
contains pseudocode linear scan algorithm heuristic 
results section heuristic 
example consider example live intervals case number available registers 
algorithm performs allocation decisions times live interval denoted italicized numbers bottom 
step active registers 
step live intervals overlap variable spilled 
algorithm spills interval ends furthest away current point change active 
result step expired active making register available bis expired making register available variable allocated register 
algorithm spilled longest interval spilled memory 
complexity number variables live intervals candidates register allocation number registers available allocation 
seen pseudocode length active bounded linear scan algorithm takes assumed constant 
large current processors worthwhile understanding complexity depends recall live intervals active sorted order increasing endpoint 
worst case execution time complexity linear scan algorithm dictated time taken insert new interval active 
balanced binary tree search insertion point insertion takes log time entire algorithm takes log time 
alternative linear search insertion point takes time leading worst case complexity time 
asymptotically slower previous result may faster moderate values data structures involved simpler 
implementations evaluated section linear search 
acm transactions programming languages systems vol 
september 
linear scan register allocation 
evaluation section evaluates linear scan register allocation terms compile time performance quality resulting code 
methodology different infrastructures primarily measure compile time performance primarily measure run time performance generated code 
icode infrastructure 
convincing benchmark compile time performance requires algorithm implemented part compiler tuned efficient compile times 
result implemented algorithm icode runtime system tcc dynamic compiler poletto 
tcc implementation extension ansi enables dynamic code generation 
icode optimizing dynamic code generation system produces quality code low compile time overhead approximately cycles generated instruction 
sets benchmarks evaluate icode implementation 
previous experimental studies icode consists dynamic code kernels numerical methods matrix multiplication sorting benchmarks compare linear scan register allocation tuned graph coloring algorithm simple usage count register allocation scheme 
graph coloring algorithm tries fast overly penalizing code quality coalescing takes counts consideration removing nodes interference graph 
usage count algorithm allocates available registers variables compiler generated temporaries highest estimated usage counts places stack 
second set benchmarks consists pathological programs perform useful computation huge numbers simultaneously live variables register allocation difficult 
benchmarks compare performance graph coloring linear scan size allocation problem increases 
experiments unloaded sun ultra model workstation mb main memory mhz ultrasparc cpu 
times sum system user times reported system call 
values benchmark obtained mean trials 
standard deviation set trials negligible 
value trial computed timing large number runs provide seconds granularity dividing result number runs 
suif infrastructure 
benchmarks discussed relatively small run time performance similar register allocation algorithms 
order measure effect linear scan performance larger programs implemented machine suif smith optimizing scalar back infrastructure suif amarasinghe 
implementation compile various spec benchmarks spec acm transactions programming languages systems vol 
september 
massimiliano poletto vivek sarkar cycles generated instruction register allocation allocation setup live variable analysis ms hash dp binary pow dfa heap ilp query benchmark fig 

register allocation overhead dynamic code kernels 
denotes simple algorithm 
linear scan 
denotes graph coloring 
spec suites unix utilities 
compare linear scan register allocation graph coloring algorithm simple algorithm usage counts 
compare second chance binpacking traub :10.1.1.1.9128
graph coloring allocator implementation iterated register coalescing george appel developed harvard 
completeness report compile time performance suif implementation binpacking linear scan section underlying suif infrastructure designed efficient compile times 
benchmarks compiled suif machine suif 
measurements user time best runs unloaded dec alpha workstation mhz alpha processor mb ram 
compile time performance icode implementation 
illustrates overhead register allocation dynamic code kernels described section 
vertical axis measures compilation overhead cycles generated instruction 
larger values indicate larger overhead 
horizontal axis denotes different benchmarks written benchmark bars refers usage count algorithm refers linear scan register allocation refers graph coloring 
bar contains different regions live variable analysis refers traditional iterative live variable analysis appear column 
allocation setup refers necessary prior register allocation 
apply refers construction live intervals acm transactions programming languages systems vol 
september 
linear scan register allocation table allocation times linear scan binpacking file benchmark time seconds ratio linear scan binpacking binpacking linear scan swim swim li li tomcatv tomcatv compress compress espresso backprop alvinn fpppp fpppp fpppp coarsening live variable information obtained live variable analysis 
case refers construction interference graph 
register allocation case involves sorting variables usage count allocating registers ones left 
case refers linear scan live intervals 
case refers coloring interference graph 
liveness analysis allocation setup case essentially null function calls 
small positive values phases small differences live variable analysis overheads cases due slight variability measurements 
times individual compilation phases obtained repeatedly interrupting compilation phase interest subtracting time required previous phase dividing number interrupted compiles 
indicates linear scan allocation considerably faster simple fast graph coloring algorithm 
particular creating live intervals live variable information roughly similar building interference graph live variable information linear scan live intervals faster coloring interference graph 
benchmark graph coloring faster linear scan binary 
case code uses variables consists basic blocks faster build small interference graph extract live intervals liveness information basic block 
note binary actual time spent register allocation smaller linear scan graph coloring 
suif implementation 
table compares compile time performance suif implementation binpacking linear scan representative files benchmark set 
data graph coloring traub section provide convincing evidence binpacking linear scan faster graph coloring especially number register candidates grows :10.1.1.1.9128
times table refer core allocation routines include setup activities cfg construction liveness analysis compilation phase allocation 
cases linear scan roughly times faster binpacking 
acm transactions programming languages systems vol 
september 
massimiliano poletto vivek sarkar fig 

types pathological programs 
results difference algorithms 
simplicity linear scan implementation uses binpacking routine computing lifetime holes traub :10.1.1.1.9128
linear scan need full information lifetime holes just considers start variable live interval 
result aggressive linear scan implementation considerably faster 
example count lifetime hole computation compilation overhead fpppp binpacking linear scan binpacking linear scan 
pathological cases 
employed icode framework section compile pathological programs intended stress register allocators 
compiled programs different kinds structure illustrated 
kind labeled contains number overlapping live intervals simultaneously live variables 
kind labeled contains staggered sets live intervals live intervals overlap 
illustrates overhead graph coloring linear scan function number overlapping live intervals code type 
axes logarithmic 
horizontal axis indicates problem size vertical axis indicates time 
costs graph coloring linear scan comparable number overlapping live intervals small linear scan scales gracefully large problem sizes 
simultaneously live variables linear scan times faster graph coloring 
linear scan graph coloring appears suffer time required build color interference graph 
importantly reported overhead entire code generation process just allocating registers setting intermediate representation computing live variables generating code algorithms share common fixed cost reduces relative performance gap 
furthermore code generated allocators pathological case contains number spills 
compares overhead graph coloring linear scan programs live interval patterns type 
previous experiment linear scan case generates number spills graph coloring 
axes logarithmic vertical axis indicates time 
horizontal axis denotes number successive staggered sets live intervals 
different curves denotes different numbers simultaneously live variables example linear scan refers linear scan allocation 
increasing overhead graph coloring grows quickly acm transactions programming languages systems vol 
september 
time seconds graph coloring linear scan linear scan register allocation size simultaneously live variables fig 

overhead graph coloring linear scan function number simultaneously live variables programs type 
time seconds graph coloring graph coloring graph coloring graph coloring linear scan linear scan linear scan linear scan size number successive sets fig 

overhead graph coloring linear scan function program size programs type 
horizontal axis denotes number staggered sets intervals 
different curves denote values different numbers simultaneously live variables 
linear scan 
vertical space graph coloring curves increasing grows quickly corresponding linear scan curves 
data consistent results performance graph coloring degrades number simultaneously live variables increases 
run time performance acm transactions programming languages systems vol 
september 
massimiliano poletto vivek sarkar run time seconds lc lc lc lc lc lc ms hash dp binary pow dfa heap ilp query lc benchmark lc lc lc lc lc fig 

run time benchmarks compiled different register allocation algorithms 
denotes simple scheme usage counts 
denotes linear scan 
denotes graph coloring 
icode implementation 
shows run time performance code compiled icode implementation described section algorithms 
horizontal axis denotes different benchmarks benchmark different bars denote different register allocation algorithms labeled 
vertical axis logarithmic indicates run time seconds 
unfortunately dynamic code kernels small register pressure illustrate differences allocation algorithms 
algorithms generate code similar quality benchmarks dfa heap 
cases code emitted simple allocator usage count considerably slower created graph coloring linear scan 
suif implementation 
presents run time large benchmarks compiled suif implementation algorithms 
horizontal axis denotes different benchmarks logarithmic vertical axis measures run time seconds 
addition algorithms andc measured far data second chance binpacking traub label table ii contains data provides ratio run time benchmark compiled register allocation method relative run time benchmark compiled graph coloring :10.1.1.1.9128
measurements table ii indicate linear scan fair performance tradeoff 
considerably simpler faster graph coloring binpacking usually generates code runs speed generated complicated algorithms times faster generated simple usage count allocator 
acm transactions programming languages systems vol 
september 
run time seconds lc lc linear scan register allocation lc espresso li wc sort alvinn swim compress tomcatv fpppp benchmark lc lc lc lc fig 

run times static benchmarks compiled different register allocation algorithms 

denotes second chance binpacking 
table ii 
run times benchmarks function register allocation algorithm compiling benchmark time seconds ratio graph coloring usage counts linear scan graph coloring binpacking espresso compress li alvinn tomcatv swim fpppp wc sort 
discussion section addresses various extensions issues related linear scan allocation 
particular describe fast algorithm conservative approximate live interval analysis discuss effect different flow graph numberings spilling heuristics mention architectural considerations outline possible refinements linear scan allocation 
fast live interval analysis shows overhead linear scan register allocation due live variable analysis allocation setup coarsening live variable information live intervals 
result experimented alternative algorithm trades accuracy speed quickly builds conservative approximation live intervals requiring full iterative live variable analysis 
acm transactions programming languages systems vol 
september 
massimiliano poletto vivek sarkar 


fig 

acyclic flow graph 
nodes labeled depth numbers 
call algorithm scc liveness analysis decomposition flow graph strongly connected components 
relies simple observations proof 
consider acyclic flow graph nodes numbered depth order known reverse postorder aho shown example 
recall order reverse order nodes visited finished cormen preorder traversal graph 
assignment variable smallest depth number dfn dfn greatest dfn dfn example conservative live interval 
second observation pertains cyclic flow graphs definitions uses variable appear single strongly connected component flow graph live interval span exactly result compute conservative live intervals follows 
compute sccs flow graph scc construct set variables defined 
obtain scc dfn acyclic scc graph 
traverse sccs extending live interval variable respectively smallest largest sccs define algorithm appealing simple minimizes expensive bitvector operations common live variable analysis 
improvements compiletime relative linear scan impressive illustrated 
unfortunately quality generated code suffers approximate analysis 
difference minimal small benchmarks section prohibitive large benchmarks 
table iii compares run time applications compiled full live variable analysis applications compiled scc liveness analysis 
results indicate scc liveness analysis may interest quickly compiling small functions suitable replacement full live variable analysis large programs 
acm transactions programming languages systems vol 
september 
cycles generated instruction register allocation allocation setup live variable analysis linear scan register allocation ms hash dp binary pow dfa heap ilp query benchmark fig 

comparison register allocation overhead linear scan full live variable analysis scc liveness analysis 
table iii 
run time programs compiled linear scan allocation function liveness analysis technique benchmark time seconds ratio graph coloring scc analysis full liveness analysis espresso compress li alvinn tomcatv swim fpppp wc sort numbering heuristics mentioned section definition live intervals linear scan allocation holds numbering flow graph nodes just depth numbering discussed far 
depth order natural supports scc liveness analysis 
reasonable alternative linear layout order order pseudo instructions appear intermediate representation 
shown table iv linear depth order produce roughly similar code set benchmarks 
acm transactions programming languages systems vol 
september 
massimiliano poletto vivek sarkar table iv 
run time programs compiled linear scan allocation function flow graph numbering benchmark time seconds depth linear layout espresso compress li alvinn tomcatv swim fpppp wc sort table heuristic run time programs compiled linear scan allocation function spilling benchmark time seconds interval length interval weight espresso compress li alvinn tomcatv swim fpppp wc sort spilling heuristics spilling heuristic section uses interval length 
considered alternative spilling heuristic interval weight estimated usage count 
case algorithm spills interval estimated usage count new interval intervals active 
table compares run time programs compiled interval length interval weight spilling heuristics 
general results similar benchmark fpppp interval length heuristic significantly outperform interval weight 
course relative performance heuristics depends entirely structure program compiled 
interval length heuristic additional advantage slightly simpler require maintaining usage count information 
architectural considerations machines place restrictions registers instance certain registers may pass arguments return results certain operations target specific registers 
operations target specific registers handled pre allocating register candidates targets instructions modifying allocation algorithm take pre allocation account 
case linear scan acm transactions programming languages systems vol 
september 
linear scan register allocation scan encounters pre allocated live interval spill assign different register interval active uses register pre allocated interval 
live intervals coarse possible intervals need particular register overlap case best solution extend linear scan variable may reside different locations lifetime binpacking traub :10.1.1.1.9128
issue caller saved registers solved elegantly binpacking algorithm extends concept lifetime holes physical registers traub :10.1.1.1.9128
lifetime hole register region register available allocation lifetime holes caller saved registers simply include function calls 
linear scan lifetime holes 
simplest solution registers insert saves restores appropriate function calls register allocation 
solution introduce binpacking concept register lifetime hole allocate live interval register fits entirely register lifetime hole 
solution icode implementation section solution suif implementation section 
optimizations simple linear scan allocation lends refinements optimizations 
beneficial terms code quality probably live interval splitting 
splitting involve changes linear scan definition live intervals 
splitting variable live interval region flow graph live interval entire flow graph 
definition takes advantage holes variable lifetimes analogous binpacking second chance technique traub :10.1.1.1.9128
past renaming scalar variables including renaming ssa form cytron useful subsuming splitting useful register allocation 
possible optimization coalescing register moves 
live interval variable ends live interval variable begins program point contains copy assigned register subsequently spilled move eliminated register allocation 
difficult extend routine enable optimization 
order effective move coalescing depends live interval splitting splitting opportunities coalescing occur outside loops 
considered optimizations implemented 
key advantage linear scan algorithm fast simple produce relatively code 
additions linear scan slower complicated may improve generated code 
willing sacrifice compile time performance obtain better code second chance binpacking algorithm solution 

linear scan algorithm fast simple technique global register allocation 
coloring interference graph algorithm allocates registers acm transactions programming languages systems vol 
september 
massimiliano poletto vivek sarkar making single pass coarse live interval information 
measurements indicate linear scan algorithm significantly faster graph coloring algorithms generally emits code runs approximately speed generated aggressive graph coloring algorithm 
linear scan register allocation part tcc dynamic compilation system 
suited applications compile time code quality important just time compilers interactive development environments 
acknowledgments traub glenn holloway michael smith harvard university willingness discuss binpacking algorithm share machine suif register allocation infrastructure 
grateful frans kaashoek mit comments feedback support research 
anonymous referees helpful comments improved evaluation discussion sections 
aho sethi ullman 
compilers principles techniques tools 
addison wesley reading ma 
amarasinghe anderson lam lim 
overview suif compiler scalable parallel machines 
proceedings th workshop languages compilers parallel computing 
portland 
auslander hopkins 
overview pl compiler 
proceedings acm sigplan symposium compiler construction 

belady 
study replacement algorithms virtual storage computer 
ibm systems journal 
craig davidson grove hobbs 
gem optimizing compiler system 
digital equipment technical journal 
briggs cooper torczon 
improvements graph coloring register allocation 
acm transactions programming languages systems may 
chaitin auslander chandra cocke hopkins markstein 
register allocation coloring 
computer languages 
cormen leiserson rivest 
algorithms 
mit press cambridge ma 
cytron ferrante rosen wegman zadeck 
efficient method computing static single assignment form 
conference record th annual acm symposium principles programming languages 
austin tx 
fraser hanson 
retargetable compiler design implementation 
benjamin cummings redwood city ca 

register allocation usage counts 
communications acm november 
george appel 
iterated register coalescing 
acm transactions programming languages systems may 
hsu fischer goodman 
minimization loads stores local register allocation 
ieee transactions software engineering october 
acm transactions programming languages systems vol 
september 
linear scan register allocation motwani sarkar 
combining register allocation instruction scheduling technical summary 
tech 
rep courant institute new york university 
july 
tr 
muchnick 
advanced compiler design implementation 
morgan kaufmann san francisco ca 
poletto engler kaashoek 
tcc system fast flexible high level dynamic code generation 
proceedings acm sigplan conference programming language design implementation 
las vegas nv 
poletto hsieh engler kaashoek 
tcc language compiler dynamic code generation 
acm transactions programming languages systems 
appear 
smith 
extending suif machine dependent optimizations 
proceedings suif compiler workshop 
stanford ca 
www eecs harvard edu 
traub holloway smith 
quality speed linear scan register allocation 
proceedings acm sigplan conference programming language design implementation 
received february revised july accepted september acm transactions programming languages systems vol 
september 
