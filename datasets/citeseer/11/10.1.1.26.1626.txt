polymorphism type inference database programming peter buneman university pennsylvania atsushi ohori kyoto university order nd static type system adequately supports database languages need express general type program involves database operations 
achieved extension type system ml captures polymorphic nature eld selection technique generalizes relational operators arbitrary data structures 
combination provides statically typed language generalized relational databases may cleanly represented typed structures 
ml types inferred relieves programmer making type assertions may required complex database environment 
extensions may provide static polymorphic typechecking object oriented languages databases 
problem arises object oriented databases apparent need dynamic typechecking dealing queries heterogeneous collections objects 
extension type system needed generalized relational operations manipulating collections dynamically typed values statically typed language 
prototype language ideas implemented 
lacks proper treatment persistent data demonstrates wide variety database structures cleanly represented polymorphic programming language 
categories subject descriptors programming languages formal de nitions theory programming languages language classi cation applicative languages programming languages language constructs features data types construct data types database management logical design data models schemas database management languages database programming languages query languages general terms database programming languages type systems data models authors version article published acm transactions database systems 
peter buneman partly supported research nsf iri aro daa atsushi ohori supported oki electric industry royal society research fellowship university glasgow scotland 
author addresses peter buneman department computer information science university pennsylvania philadelphia pa atsushi ohori research institute mathematical sciences kyoto university ku kyoto japan 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission acm 
copy republish requires fee speci permission 
acm acm transactions database systems vol 
march pages 

peter buneman atsushi ohori additional key words phrases generalized relational algebra inheritance object oriented databases polymorphism record calculus type inference 
expressions cat name doe contain type errors applications primitive operations eld selection inappropriate values 
static type checking detection type errors program executed long advocated forms database programming schmidt albano atkinson buneman kim characterized complexity size data structures involved 
relational query languages checking type correctness query select name employee salary routinely carried compiler partial check correctness program intrinsic part optimization process 
typechecking straightforward type employee relation known database schema de nitions 
suppose de nitions unavailable 
query provides type information employee relation attribute name undetermined type numeric attribute salary 
express type information implied query 
equivalent problem express general type function function wealthy select name salary parameter constrained relation name numeric salary attribute 
describing general constraint possible current programming languages 
statically typed languages gives complete type function wealthy 
parameter wealthy restricting function applicable particular relation type dynamically typed languages type checking done compilation allowing possibility run time errors 
language ml polymorphic type system general type function described inferred de nition 
ml type system extend database operations describe type functions wealthy 
purpose show extend polymorphic type system ml database operations demonstrate extended type system provides practical basis database programming languages relational object oriented databases cleanly represented 
polymorphic type system important database programming generally working known schema xed set types 
see number reasons separate compilation external procedures 
frequently advantageous develop software components large systems independently 
acm transactions database systems polymorphism type inference database programming 
far possible check type correctness components separately 
rationale development systems modules packages number programming languages wirth appel macqueen :10.1.1.55.9444:10.1.1.55.9444
database context may want develop software independently schema type de nitions database 
having polymorphic type function wealthy describes precisely constraints placed schema query body function 
type wealthy describes checked code linked database 
schema evolution 
common problem database software maintenance need cope changes database schema 
advantageous able describe precise constraints existing software places schema order describe evolution possible identify code rewritten cope change schema 
polymorphic type wealthy describes precisely constraint enclosed query places database schema 
database programming languages 
growing interest database programming languages expressive type systems 
traditional approaches including object oriented languages derived type systems programming languages static schmidt albano object design dynamic components atkinson copeland maier 
approaches provides satisfactory account polymorphic nature database programming wealthy 
napier morrison attempts combine parametric polymorphism persistence polymorphism extend operations database structures 
see atkinson buneman survey various approaches type checking database programming 
type inference 
important point programming convenience 
ml type inference algorithm automatically infers untyped program general polymorphic type program 
provides programmer exibility dynamically typed languages lisp maintaining type safety eciency statically typed languages 
believe highly desirable extend ideas database context characterized complexity types involved 
describes prototype language machiavelli developed university pennsylvania embodies ideas 
preliminary sketch language ohori 
addition polymorphic type system machiavelli generalizes relational operators including join projection arbitrary complex objects contains mechanism represent statically typed programs heterogeneous collections 
shall describe machiavelli principles type system constructed type inference algorithm implement type system demonstrate expressive power database programming 
machiavelli implemented standard ml new jersey appel macqueen interpreter demonstrates material exception types cyclic data :10.1.1.55.9444:10.1.1.55.9444
related systems worth mentioning acm transactions database systems 
peter buneman atsushi ohori sml developed authors extension standard ml milner polymorphic record operations machiavelli 
compiler implemented modifying standard ml new jersey compiler ecient compilation method polymorphic record operations developed ohori ohori :10.1.1.26.4611
caml light extended emy include similar record operations formulation polymorphic typing records remy 
cpl kleisli system developed wong wong heterogeneous database integration principles programming collection types buneman 
type system derived integral part query rewriting system attempts reformulate programs exploit optimizations available query languages associated external data sources 
system scientists involved biomedical genomic databases hart wong 
illustrate program machiavelli consider function wealthy takes set records relation name salary information returns set name values occur records salary values 
example applied relation name joe salary name fred salary name helen salary machiavelli syntax set records get set fred helen character strings 
function written machiavelli syntax largely follows ml follows fun wealthy select name salary select form simple syntactic sugar basic machiavelli program structure see section 
types mentioned code machiavelli infers type information wealthy fd name salary int fd type type variables valid types wealthy may obtained substituting speci types restrictions types may substituted 
rst indicated decoration name salary int type variable allows certain record types substituted integer salary eld name eld type agree type output possibly elds 
name string salary int name string age int salary int name string string weight int salary int string string allowable instances type wealthy name string name string age int salary string fintg acm transactions database systems polymorphism type inference database programming 
allowable instances substitutions generate match constraints imposed decoration name salary int 
type variables instantiation controlled decoration called kinded type variables 
second constraint place type variables instantiated description types 
basic operations databases require computable equality available function types may unavailable certain base types 
description types essentially ml equality types types equality available operations available 
constraint details governs function types may appear description types 
order display type variables conventional programming fonts follow ml convention displaying ordinary type variables 
description type variables type fd name salary int fd displayed examples name salary int bg 
typing wealthy name salary int bg places restrictions wealthy may 
example rejected compiler 
wealthy name joe name fred wealthy name joe salary nonsense sum wealthy name fred salary name joe salary rst application salary eld missing second wrong type 
case nd suitable instantiation kinded type variable name salary int 
third case nd instantiation results variable bound string result wealthy type inappropriate argument sum 
close relationship polymorphism represented kinded type variables generic nature object oriented programming 
type scheme name salary int thought class functions polymorphic respect wealthy thought methods class 
purposes nding typed approach object oriented programming machiavelli type system similar goals systems proposed cardelli wegner cardelli cardelli wegner :10.1.1.117.695:10.1.1.116.1298:10.1.1.116.1298
important technical di erences important machiavelli subtyping uses polymorphic instantiation kinded type variables represent inheritance 
property allows capture exact polymorphic nature operations records enables extend type system various database operations natural join 
turning object oriented databases research centered discussion features atkinson principled attempt provide formal semantics 
looking features directly captured functional language relational extensions described 
class structure object oriented languages provides form abstraction inheritance immediately fall ml style type system 
second object identity provided relational model open issue requires addition type acm transactions database systems 
peter buneman atsushi ohori ml 
third interesting standpoint object oriented databases implicit requirement heterogeneous collections representable language 
believe issues satisfactorily resolved context type system advocating 
particular shall show heterogeneous collections appear inconsistent static type checking satisfactorily represented essentially apparatus developed handle relational data types 
organization follows 
section introduces basic data structures machiavelli including records variants sets shows relational queries obtained operations structures 
section contains de nition core language 
de nes syntax types terms describes type inference system 
section presents type inference process detail basic operations required records sets variants 
section language extended relational operations speci cally join projection derived basic set operations type inference system extended handle 
section discuss type system capture important aspect object oriented databases manipulation heterogeneous collections 
section concludes brief discussion applications ideas object oriented languages databases 

basic structures data representation language type system expressive represent various data structures violate rst normal form assumption underlying implemented relational database systems traditional theory relational databases 
example want able deal structures name ellen children jeremy christopher name children adam benjamin built records uniformly typed sets 
structure non rst normal form relation name eld contains record children eld contains set strings 
example description term section shall describe constructors enable build terms atomic data records variants sets 
shall describe cyclic structures created 
describe constructor shall say conditions constructs description term 
start basic syntactic forms machiavelli value function de nition exactly ml 
names bound values val val functions de ned fun fun factorial eq factorial function constructor fn create functions naming fn acm transactions database systems polymorphism type inference database programming 
evaluates 
form evaluates environment bound example evaluates 
form treated specially basis ml polymorphism 
implicit explicit polymorphic functions introduced 
polymorphic function de nition wealthy treated shorthand binding scope rest program 
labeled records labeled variants syntax labeled records vn stand labels 
labels record distinct order appearance insigni cant 
record description term elds description terms 
record construction primitives records 
rst eld selection selects eld record second modify eld modi cation modify creates new record identical eld value example modify name doe age age evaluates name doe age 
important note modify side ect 
function returns record 
construct enables modify record eld provides added exibility programming records 
shall frequent syntax pairs 
simply abbreviation record rst second 
triples generally tuples similarly constructed 
variants tag values order treat uniformly 
example values treated numbers tags indicate value interpreted real integer 
program may tags deciding operations perform tagged values real integer arithmetic 
syntax constructing variant operation analyzing variant case expression case 
en endcase variable scope operation rst evaluates yields variant binds variable value evaluates binding 
possible results type 
matching case clause selected 
optional omitted argument evaluated variant acm transactions database systems 
peter buneman atsushi ohori labeled type system ensures condition statically checked 
example case phone phone extension endcase yields 
note case endcase expression returns value 
variant description term description term 
sets sets machiavelli contain description terms sets description terms 
restriction essential generalize database operations structures containing sets 
basic expressions sets fg empty set fxg singleton set constructor union set union hom op homomorphic extension 
notation fx xn shorthand union fx union fx union 
fx 
hom requires explanation 
primitive function machiavelli similar pump operation fad bancilhon fold reduce functional languages de ned hom op fg hom op feg hom op union op hom op hom op 
example function check element satisfying property set de ned fun exists hom false function nds largest member set non negative integers fun max hom fn fn general result operation depend order elements set encountered op associative commutative idempotent operation identity side ects case exists max examples result hom independent order evaluation 
hom operations idempotent example fun sum hom fn idempotent easy construct programs outcome depends evaluation strategy breazu tannen subrahmanyam 
easy remove ambiguous outcomes insisting done implementation representation sets duplicated acm transactions database systems polymorphism type inference database programming 
elements 
equivalent putting condition third line de nition hom expressions denote disjoint sets 
unfortunately considerably complicates operational semantics language precludes possibility lazy evaluation 
resolution issue see breazu tannen subrahmanyam breazu tannen discuss semantic properties programs sets collection types 
shall occasionally incorrect applications hom con dent adoption alternative semantics ect typing issues main concern 
various useful functions de ned correct applications hom 
function map applies function member fun map hom fn ff xg union fg example map max ff gg evaluates 
selection function de ned fun lter hom fn fxg fg union fg extracts members satisfy property example expression lter evaluates 
addition examples hom de ne set intersection membership set set di erence fold cartesian product denoted prod sets powerset set subsets set 
form select 
xn sn xn may occur free provided spirit relational query languages list comprehensions miranda turner 
implemented map fn lter fn map fn xn prod sn see wadler related discussion syntax programming lists :10.1.1.33.5381
cyclic structures languages ability de ne cyclic structures depends ability reassign pointer 
machiavelli ideas separated 
possible create structure cycles rec construct val montana rec name montana big sky country capital name helena state record behaves nite tree obtained arbitrary unfolding substitution example expressions montana capital montana capital state montana capital state capital valid 
equality test acm transactions database systems 
peter buneman atsushi ohori database operations description terms generalize cyclic structures 
uniform treatment achieved treating description terms regular trees courcelle 
syntax rec denotes regular tree solution equation may contain variable ensure equation proper solution place restriction contain proper term constructor variables rec form 
believe shall comment section notion object identity databases equivalent implemented ml 
primitives new creation de referencing assignment 
new creates new assigns value returns value associated changes value associated database context correspond respectively creating object identity retrieving value object changing associated value object ecting identity 
uniqueness identity guaranteed uniqueness 
equal results invocation new primitive 
example create objects records john new name john age john new name john age john john john john true john john false associated values 
sharing mutability captured 
de ne department object new name sales building de ne employee objects john new name john age dept mary new name mary age dept john mary share object value dept eld 
update object seen john john dept modify john dept building re ected department seen mary 
statement mary dept building evaluates 
languages optional nil unde ned value 
option required explicitly introduced variant 
description terms regardless associated values 
acm transactions database systems polymorphism type inference database programming 

type inference polymorphism machiavelli type inference technique infer type information represents polymorphic nature untyped partially typed program 
hindley hindley established complete type inference algorithm untyped lambda expressions 
independently milner milner developed type inference algorithm functional programming language allowed polymorphic de nitions construct 
damas milner damas milner showed completeness type inference algorithm successfully ml functional programming languages augustsson milner turner hudak 
section give account damas milner type system extension machiavelli infer types programs involving records variants sets 
programs involve eld selection variants database operations machiavelli infers type information similar ml 
example de nition identity function fun id type system infers type id type variable stands arbitrary type notation represents set types obtained substituting various ground types type expressions contain type variables 
important property ml type system type consistent expression principal type inferred 
type instances types expression conversely type expression instance 
substantial example type inference function map section type 
map ag bg type variables represent description types 
type map indicates function takes function type set type returns set type description types 
map max ff gg legitimate application map 
type ag bg principal type map obtained substituting description types type variables example fintg int fintg type map map max ff 
possible ml type inference method infer type program involving eld selection variants operations relational algebra shall describe 
ml simplest function eld selection fun name name requires explicit type added argument diculty type system ml general represent relationship record type type elds 
wand attempted wand solve problem notion row variables variables ranging nite sets record elds 
system share ml property principal typing see ohori buneman jategaonkar mitchell wand remy analysis problem re nements 
wand general observation acm transactions database systems 
peter buneman atsushi ohori val joe name joe age status telephone val joe name joe age status telephone name string age int status int fun phone case status extension telephone endcase val phone fn status consultant telephone phone joe val int fun increment age modify age age val increment age fn age int age int increment age name john age val name john age name string age int fig 

simple machiavelli examples ohori buneman type inference method developed overcomes diculty extends method database operations syntactic conditions control substitution type variables 
type system re ned ohori ohori kinded typing allows represent principal types polymorphic operations :10.1.1.26.4611
machiavelli type system account record operations 
example function name type name name notation name describes record types containing eld name instance 
substitutions restricted conform description 
type represents possible types function name may taken principal kinded type name 
examples type inference records variants shown shows interactive session machiavelli 
input system prompted output preceded top level input value function binding variable name result evaluation expression 
output consists result inferred type 
de ne small language obtained combining data structures described previous section functional calculus giving type system 
expressions syntax programs expressions core language fn eq modify case endcase case endcase fg feg union hom acm transactions database systems polymorphism type inference database programming 
new rec stands standard constants including constants base types ordinary primitive functions base types 
stands variables language 
single value type unit returned expressions assignment 
binding val id syntactic sugar id 
recursive function de nition multiple arguments de ned standard method functional languages ml 
evaluation rules expressions obtained extending operational semantics ml provided tofte 
types description types set types machiavelli ranged set regular trees courcelle represented type expressions unit bd ref rec stands type variables 
unit trivial type value 
range respectively base types base description types language 
type expressions function types record types variant types set types 
rec body type expression variable may occur free entire expression denotes solution equation 
ensure type expression denotes unique regular tree place restriction rec contains proper type constructor variables rec form 
keeping syntax records shall notation abbreviation type rst second 
tuple types treated similarly 
database examples machiavelli types relation type int string color unit complex object type name string string children mutable object type rec ref id int name string children fpg note rec type constructor syntax denote solution equation 
consequence distinct type expressions may denote type 
example type expression denotes type rec ref id int name string children id int name string children fpg set description types ranged subset types represented syntax unit bd fg ref rec acm transactions database systems 
peter buneman atsushi ohori stands description type variables type variables instances restricted description types 
ref ranges syntax types previously 
syntax forbids function type base type description type description type ref 
int int description type ref coord int coord int move horizontal int description type 
type inference records variants legal machiavelli program corresponds untyped expression associated type inferred type inference system 
de nition implicit system requires steps rst give typing rules determine untyped expression judged type typed second develop type inference algorithm infers type consistent expression principal type 
readability develop description type system stages 
subsection describe type system expressions involve records variants subsection extend system records variants introducing kinding 
typing rules set rules derive typing judgments 
general expression contains free variables type depends types assigned variables typing judgment de ned relative type assignment free variables 
range type assignments functions nite subset variables types 
write function domain domain fxg typing judgment formula form expressing fact expression type type assignment typing rules operations machiavelli involve records shown 
note union types restricted description types indicated notation denotes expression obtained substituting free occurrences departure damas milner system damas milner generic types type expression form uses syntactic substitution expressions 
shown ohori mitchell proof system equivalent damas milner 
advantage treatment yields simpler proofs extended relational algebra shall show 
possible extend damas milner generic types records variants kinded type abstraction ohori ohori know extend technique conditional typing shall require database operations join projection :10.1.1.26.4611
note rule de ne typing expressions imply semantics expression de ned term substitution yield call name semantics 
choose usual call value semantics expressions 
proof system determines expressions type correct machiavelli programs involving operations records variants 
acm transactions database systems polymorphism type inference database programming 
const unit unit var domain abs fn app bool eq eq bool singleton feg fg union fg fg union fg hom fg hom new new ref deref ref assign ref unit rec rec fig 

typing rules expressions records variants acm transactions database systems 
peter buneman atsushi ohori simple type discipline proof system immediately yield decision procedure type checking expressions 
second step de nition type system give decision procedure 
hindley milner solve problem developing algorithm infers principal typing type consistent expressions 
substitution function type variables types 
substitution may extended type expressions identify substitution extension shall write expression obtained replacing type variable 
typing general domain domain substitution domain 
typing principal general derivable typing shows algorithm compute principal typing untyped expression machiavelli contain records variants database operations 
algorithm consists set functions typing rule main function typing 
typing rule rule rule synthesizes principal typing expression subexpressions 
generates equations typings subexpressions conform premises rule solves equations generates typing corresponding rule 
unify functions uni cation algorithm allpairs fa denotes set pairs domain domain jg 
notation denotes restriction function set domain 
example consider function app takes principal typings synthesizes principal typing 
rst generates equations require common variables type assignment equation type domain type type respectively set equations allpairs fa equation 
solves equations unify nds general solution equations exists form substitution returns type assignment type corresponding rule app 
main function typing style mitchell 
analyzes structure expression recursively calls subexpressions get principal typings calls appropriate function corresponds outermost constructor expression 
extra parameter typing environment records principal typings bound variables 
maintaining environment algorithm avoids repeated computation principal type inferring typing expressions form enables incremental compilation 
renaming type variables case domain ectively achieves ect computing principal typing occurrence example type inference algorithm compute principal typing function insert application val insert fn fn union fxg insert fg acm transactions database systems polymorphism type inference database programming 
papp unify allpairs fa fresh pabs domain domain fresh unify allpairs fa unify fs fresh unify allpairs fa fdg fresh fdg 
typing case domain type variables renamed fx tg fresh fn pabs typing papp typing typing typing typing feg typing union typing typing 
endcase fig 

type inference algorithm records variants acm transactions database systems 
peter buneman atsushi ohori shows sequence function calls results computation 
line top level call algorithm fn fn union fxg 
line rst recursive call subexpression result shown line 
lines contain call typing variable immediately returns principal typing 
singleton line type variable uni ed fresh description type variable line union uni es type variable type fd takes union type assignments 
line shows principal typing insert 
lines show process insert fg shorthand insert fn fn union fxg insert fg 
requires show algorithm described desired properties 
glossed important details treatment description type variables recursive types 
dealing issues rst show typing rules inference system may extended handle records variants 
kinded type inference records variants extend type system records variants need introduce kind constraints type variables 
set kinds machiavelli syntax hhl ii idea denotes set types denotes set record types containing set elds hhl ii denotes set variant types containing set variants extended type system type variables kinded kind assignment mapping type variables kinds 
write ft kn kind assignment maps 
type kind kind assignment denoted satis es conditions shown 
example legal kinding ft name age int name typing judgment re ned incorporate kind constraints type variables typing judgments form described previous subsection taken judgments form kind assignment mapping type variables appearing universal kind typing rules records variants extended type system 
rules constructors reinterpreted relative kind assignment example rule abs abs fn particular propagate kind assignment change involve kinding judgements form seen kinding constraints rules dot variant express conditions eld selection variant formation acm transactions database systems polymorphism type inference database programming 
typing fn fn union fxg pabs typing fn union fxg fn union fxg pabs typing union fxg union fxg typing fxg typing fxg typing fx fx fx fd fs fx fd fs fx fd gg fd pabs fx fd gg fd fx fd fd pabs fx fd fd fd fd typing insert fn fn union fxg insert fg fd fd typing insert fg insert fd fd insert fg insert fd fd papp typing insert insert fd fd typing fg insert fd fd insert insert fd fd papp typing insert insert fd fd typing insert fd fd insert insert fd fd fd fd insert fd fd int papp fd fd int fintg fintg fg insert fd fd fd papp fintg fintg fd fintg fd fd fintg fintg fig 

computing principal typing acm transactions database systems 
peter buneman atsushi ohori domain hhl ii domain hhl ii hhl ii fig 

kinding rules record en en dot modify modify variant hhl ii case case xn en endcase case hhl ii case xn en endcase fig 

typing rules records variants typed 
example legal typing ft name fn name says function fn name applied record type contains eld name returns value type note need recursive kinds represent recursive polymorphic types involving records variants 
represented kind assignment type variables may assigned kind containing type variables seen example fd children fdg fn union fxg children fdg cyclic dependency kind constraint instances description type variable restricted recursive types form rec children fpg 
example instance type scheme rec name string children fpg rec name string children fpg re ne type inference algorithm need re ne uni cation algorithm kinded uni cation 
strategy add kind assignment component uni cation check condition uni cation respects constraints speci ed kind assignments 
kinded substitution pair consisting kind assignment substitution intuitively kind assignment acm transactions database systems polymorphism type inference database programming 
kind constraints satis ed results applying substitution write 

substitution variables 
say kinded substitution respects kind assignment domain legal kinding 
example kind substitution ft ug 
name age int respects kind constraints ft name applied type constraint 
kinded substitution general respects composition substitutions de ned 
kinded set equations pair consisting kind assignment set pairs types 
kinded substitution uni er kinded set equations respects obtain result re nement robinson robinson uni cation algorithm 
theorem 
algorithm unify kinded set equations computes general uni er exists reports failure 
provide description algorithm acyclic types correctness proof ohori :10.1.1.26.4611
describe necessary extensions cyclic regular trees subsection 
algorithm unify style gallier snyder set transformation rules triples consisting kind assignment set type equations set solved type equations form ftv 
kinded set equations 
algorithm unify rst transforms rules apply 
returns empty reports failure 
range functions nite set labels types 
write respectively denote record type identi ed record kind identi ed gives set transformation rules record types function types 
rules variant types obtained record types replacing record type constructor record kind constructor variant type constructor variant kind constructor hhf ii respectively 
rules ii vi ordinary uni cation 
rule eliminates equation valid 
rule ii case variable elimination occur check condition appear succeeds generates point substitution 
applies type expressions involved moves equation solved position 
rules vi decompose equation complex types set equations corresponding subcomponents 
rules iii iv cases variable elimination similar rule ii variables non trivial kind constraint 
addition eliminating type variable rule ii rules check consistency kind constraints consistent generates set new equations equivalent kind constraints 
re ned uni cation algorithm extend type inference system 
re ne notion principal typings 
typing general domain domain substitution kinded substitution respects acm transactions database systems 
peter buneman atsushi ohori ii ft 
ug 


appear iii ft 


ft 

jl domain domain 
jl domain domain domain appears appears iv ft 


jl domain domain 
domain domain ftv vi jl domain domain domain fig 

transformation rules kinded uni cation domain 
typing principal general derivable typings type inference algorithm extended adding new functions compose principal type record variant operations extend main algorithm adding cases records variants 
shows necessary changes main algorithm 
shows new composition functions corresponding typing rules records variants 
functions de ned remain unchanged take kinded typings form appropriate kind assignments added components parameter uni cation algorithm result 
shows type inference process function fn name sal function implementation wealthy section 
re nement correctness type inference system explanation type inference far ignored constraint type variables denote description types 
necessary extension introduce description kind constructors hhl ii respectively denoting set description types description record types description variant types 
increases notational complexity extension easily incorporated uni cation algorithm type inference 
simpli cation description type inference algorithm assumption types non cyclic 
extend type inference algorithm recursive types need extend kinded uni cation algorithm acm transactions database systems polymorphism type inference database programming 
typing case domain type variables renamed ft ug fx tg fresh 
en typing typing en typing modify typing typing typing case en endcase typing pabs typing pabs typing en xn case en endcase typing pabs typing pabs typing en xn typing endcase fig 

main algorithm type inference records variants nite regular trees 
necessary extension similar needed extend ordinary uni cation algorithm regular trees huet involves de ning data structure represent regular trees changing cases variable elimination cases ii iv eliminating occur check replacing point substitution 
substitution 
rec rec regular tree solution changing cases decomposition cases vi generate equations set pairs corresponding subtrees regular trees 
ignored details dealing 
type inference method directly extended call value operational semantics expressions involving agree polymorphic type discipline binding 
milner observed original presentation ml type system milner straightforward application ml type inference method yields unsound type system 
solutions proposed tofte macqueen leroy weise 
di er detailed treatment idea type system restricts substitution type variables types way created polymorphic functions monomorphic 
mechanisms regarded new form kind constraint type variables believe safely incorporated type system 
radical solution leroy change semantics callby name damas milner polymorphic typing equivalently rule sound 
strategy adopted 
want intuitions merits mechanisms adopt simplest restrict constructor monomorphic types 
re nements complete static type inference ml extended acm transactions database systems 
peter buneman atsushi ohori kn unify 
kn allpairs fa ang 
unify ft fresh unify ft allpairs fa fresh ft hhl iig fresh kn unify 
kn ft ug allpairs fa ang ng fresh 
kn kn unify 
kn ft hhl iig allpairs fa ng fresh 
fig 

new functions synthesize principal typings acm transactions database systems polymorphism type inference database programming 
typing fn name sal pabs typing name sal name sal typing name typing sal name typing name ft ug fx ft ug fx name ft name fx sal typing sal typing sal ft sal fx int ft sal fx int ft sal int fx bool ft name fx ft sal int fx bool ft name sal int fx bool pabs ft name sal int fx bool ft name sal int bool fig 

examples type inference records records variants set data types stated result theorem 
raw term machiavelli 
typing principal typing typing reports failure typing 
just legal ml programs correspond principal typing schemes empty type assignment legal machiavelli programs correspond principal kinded typing schemes empty type assignment 
typings form machiavelli prints typing type type variables printed kind constraints formats type variables description type variables type variables description type variables type variables hhl ii description type variables hhl ii seen examples 
type output example acm transactions database systems 
peter buneman atsushi ohori fun name name val name fn name representation kinded typing scheme ft name fn name examples shown convention 
summarize progress point augmented type schemes ml description types exist ml limited form kinded type variables 
provided type system expresses generic nature eld selection allows sets uniformly treated language 
relational databases require operations far described turn 

operations generalized relations going show extend machiavelli include operations relational algebra speci cally projection natural join covered operations developed far 
points strategy 
rst going put ordering values description types 
ordering types somewhat similar cardelli cardelli sense part machiavelli polymorphism :10.1.1.116.1298:10.1.1.116.1298
apparent fact incorporated polymorphic eld selection ordering 
second point join complicates presentation type system increases complexity type inference problem requires extend notion kinded typing schemes conditional typing schemes ohori buneman adding syntactic conditions instantiation type variables 
similar problem observed wand uses record concatenation operation join 
see cardelli mitchell harper pierce remy polymorphic calculi record concatenation 
primarily concerned database operations inclination examine record joining operation naturally arises result generalizing relational algebra 
strategy section rst provide method generalizing relational algebra arbitrary description types 
provide additional typing rules associated order constraints types 
provide principal conditional typing scheme represents exact set provable typings 
describe method check statically satis ability constraints 
words able guarantee typechecked program cause run time type error 
generalizing relational algebra rationale wanting generalize relational operations keeping rest language polymorphic possible 
equality essential de nition operations limit ect description types 
generalize operations arbitrary description terms introduce polymorphic functions system acm transactions database systems polymorphism type inference database programming 
eq equality test join database join con consistency check project projection type intuition underlying generalization idea exploited buneman database objects partial descriptions real world entities ordered goodness description 
polymorphic type system represent generalized relational operations including cyclic structures developed ohori :10.1.1.26.4611
limit acyclic description terms 
rst consider join equality 
claim join relational model underlying operation computes join tuples 
regarding tuples partial descriptions realworld entities characterize special case general operations partial descriptions combines consistent descriptions 
example consider non tuples name joe name doe partial descriptions combination name joe doe 
upper bound ordering induced inclusion record elds join eq approach provides uniform treatment null values zaniolo biskup databases represent incomplete information 
represent null values extend syntax machiavelli terms null null value base type polymorphic null value variant types 
incomplete values built constructors description terms 
care taken imielinski ensure algebra extended operations null values provides semantics intended programmer 
characterizations depend particular data structure records 
de ned computable ordering set description terms join equality generalize arbitrary description terms 
obtain ordering rst de ne pre order acyclic description terms 
constants type null constants type null null base type dn description acm transactions database systems 
peter buneman atsushi ohori pname nut supplier sname smith city london sname jones city paris sname blake city paris pname bolt supplier pname blake city paris sname adams city athens pname nut supplier city paris qty pname bolt supplier city paris qty join pname nut supplier sname jones city paris sname blake city paris qty pname bolt supplier sname blake city paris qty fig 

natural join higher order relations fd 
fd 
fd fd dn rule expresses ordering extended sets 
fails anti symmetric ordering obtained induced equivalence relation regarding description term representative equivalence class 
take ordering induced 
representatives canonical having property contains set term members pairwise incomparable anti chain 
computable characterization join eq immediately gives de nitions general description terms computes canonical representative 
con checks existence join computable 
equality eq generalization structural equality sets null values 
shows example join complex descriptions 
importance de nition join faithful generalization join relational model 
buneman shown theorem 
rst normal form relations join natural join relational model 
projection relational model de ned projection set labels 
generalize operation projects complex description term type describes part structure de ne projection operation speci ed type 
recall syntax ground variable free description types unit bd fg ref rec projection operation indexed ground description type 
operation project takes value type bigger returns value type generalized form projection type 
simple projection relation obvious result project name doe age salary name jones age salary name string salary int acm transactions database systems polymorphism type inference database programming 
ordering just de ned projection speci ed project computable description type de nitions join projection generalized cyclic structures polymorphic algorithm generalized de nitions ohori :10.1.1.26.4611
summarize extensions language introduced constants null term constructors join con project 
machiavelli callby value operational semantics described section directly extended operation adding computation algorithms evaluation rules 
type inference relational algebra join project con polymorphic operations sense compute join projection various types 
represent de ne ordering ground description types represents ordering structure descriptions 
set acyclic description types inductive de nition ref ref de nition re ects de nition ordering description terms 
particular rule types re ects property expressions join denote value type 
may choices ordering variant types 
choice depend intended semantics construct partial description 
ordering types join project con con bool join project integrate operations polymorphic core machiavelli de ned section need take account operations type system 
explicitly introduce syntactic conditions substitution type variables forms constraint associated types operations exists fact need consider forms constraint exist nd type represent introduce syntactic conditions lessthan 
note di erence 
property relationship ground description types 
hand syntactic formula denoting constraint substitutions acm transactions database systems 
peter buneman atsushi ohori null null null hhii con con bool join join project project fig 

typing rules relational operations type variables ensure ground instance satis es property 
similar holds lessthan 
syntactic conditions type variables extend type system incorporate new operations 
typing judgements extended system form extra ingredient set syntactic conditions 
shows typing rules new operations 
rules remain de ned relative set conditions 
example rule abs abs fn particular rules propagate set conditions change contents 
conditions introduced involve ordering de ned ground types need interpret typing judgement extended system scheme representing set ground typings obtained substituting type variables appropriate ground types 
interpretation consistent treatment construct rule semantics described ohori 
ground substitution satis es condition description types satisfying lessthan description types satisfying 
satis es set conditions satis es member say ground typing instance ground substitution respects satis es dom 
seen de nition typing extended system subject set conditions associated 
emphasize fact call typing judgement extended type system conditional typing 
conditional typing scheme principal derivable ground typing instance 
result establishes complete inference principal conditional typing schemes 
theorem 
algorithm raw term returns failure tuple returns acm transactions database systems polymorphism type inference database programming 
fun join join join val join fn join name joe age oce val name joe age oce name string age int oce int project name string val name joe name string fig 

simple relational examples principal conditional typing scheme typing 
proof gives type inference algorithm machiavelli technique developed ohori buneman established theorem sublanguage machiavelli 
complete proof complete type inference algorithm reconstructed corresponding proof algorithm ohori 
gives simple examples typing schemes inferred machiavelli 
type way join join representation principal conditional typing scheme fn join join follows 
tempting identify legal machiavelli programs principal conditional typing schemes 
problem approach conditional typing schemes may satis able instance 
case term typing regarded term type error 
unfortunately checking satis ability set conditions np hard ohori buneman 
practical solution delay satis ability check set conditions type variables fully instantiated 
types type variables condition known satis ability eciently checked eliminated 
achieve complete static typechecking strategy type system satisfy property expression containing joins projections evaluation involves evaluation joins projections conditions associated types joins projections expression contain ground types 
cases type variables originate polymorphic function de nitions condition satis ed 
joins projections appearing body polymorphic function evaluated parameters operations bound values type variables originating polymorphic function de nition acm transactions database systems 
peter buneman atsushi ohori parts val pname bolt cost pname engine subparts qty pname string int composite subparts int qty int int suppliers val sname baker city paris sname string int city string supplied val suppliers int suppliers int fig 

part supplier database generalized relational model instantiated ground types expressions cause evaluation joins projections 
exception case expressions containing joins projections variants 
variants polymorphic values type variables may instantiated 
preserve complete static typechecking place restriction programmer supply type speci cation variants arguments join projection directly indirectly function abstraction function application 
type system easily enforce restriction rejecting expressions conditions involves type variables having variant kind 
identify legal machiavelli programs principal conditional typing schemes conditions contain type variables kind variant kinds 
approach yields practical solution typechecking polymorphic programs involving join projection 
additional restriction imposed restrict polymorphic function de nitions believe method preserves advantages polymorphic typing incurring algorithmic diculty checking satis ability conditions 
shows example database containing non records variants nested sets assume names parts suppliers supplied bound 
availability generalized join projection immediately write programs manipulate databases 
shows simple query processing database example gure 
note join relational operations non relations 
data operations freely mixed features language including recursion higherorder functions polymorphism 
allows write relative ease powerful programs type correctness checked compile time 
shows query processing example database polymorphic functions 
function cost part record set records arguments computes total cost part 
case composite part rst generates set records consisting subpart number cost uses hom acm transactions database systems polymorphism type inference database programming 
select base parts join parts val pname bolt pname string int composite subparts int qty int int list part names supplied baker select pname join parts supplied join suppliers suppliers sname baker fg bolt fig 

simple queries accumulate costs subparts 
order prevent set constructor collapsing subpart costs equal computed subpart cost paired subpart number 
note scope type variables limited single type scheme instantiations type cost independent type expensive parts 
apparent complexity type cost reduced naming large repeated sub expression 
proper integration data model programming language de ning function checking type consistency problematic 
functions cost expensive parts parameterized relation polymorphism allows applied di erent types 
particularly useful di erent databases structure cost information 
databases di er structure information functions uniformly applicable 

heterogeneous sets previous section provided extension polymorphic type system records enabled infer type correctness programs involve operations relational algebra notably projection natural join 
shall closely related mechanisms deal problem arises object oriented databases dealing heterogeneous collections 
problem arises apparently contradictory uses inheritance arise programming languages databases 
object oriented languages term describes code sharing assertion employee inherits person mean methods de ned class person applicable instances class employee 
databases notably data modeling techniques associate sets ext erson ext employee entities person employee inheritance employee person speci es set inclusion ext employee ext erson 
notions inheritance apparently contradictory 
example members ext employee instances employee members ext erson members instances person 
way relax mean instance allow instance employee instance person 
take ext erson acm transactions database systems 
peter buneman atsushi ohori function compute total cost part fun cost case cost hom fn select cost qty subparts eq endcase val cost fn composite subparts qty int int composite subparts qty int int int select names expensive parts fun expensive parts select pname cost val expensive parts fn composite subparts qty int int pname int fg expensive parts parts val engine fig 

query processing polymorphic functions acm transactions database systems polymorphism type inference database programming 
neous set members instances employee 
type systems manipulation heterogeneous collections dicult impossible losing information 
example type list erson type employee result insert type list erson rst element list type person 
problem appears languages subsumption rule cardelli statically type checked object oriented languages stroustrup claim ability represent heterogeneous collections important feature :10.1.1.26.9545:10.1.1.116.1298:10.1.1.116.1298
cases information recoverable recovered dangerous fashion type casting values basis information maintained programmer 
preliminary solution problem described authors buneman ohori :10.1.1.26.4611
approach simpli ed techniques developed preceding sections 
dynamic partial values shall exploit idea dynamic values proposed cardelli :10.1.1.116.1298
values carry type regarded pair consisting type value type 
formal system type systems dynamic developed abadi 
proposals operations dynamic values type dynamic dynamic coerce dynamic function dynamic creates value type dynamic value type operationally pairs value type 
conversely coerce takes pair returns value component provided type component raises exception 
standard dynamic values representing persistent data type external data guaranteed 
example coerce int read input stream add input raise exception 
approach heterogeneous collections generalize notion dynamic type structure visible 
type name string age int denotes dynamic values actual type bigger name string age int name string age int ordering represent types relational operators 
assertion name string age int means dynamic value known record name age elds available shall refer partially speci ed dynamic values partial values 
note partial value dynamic value carries complete type 
new type constructor allows mix partial values term constructors language 
example fp means set objects partial value complete type bigger ordering 
ordering types conjunction set type allows express heterogeneous collections 
assertion form fp name string age int means set records name string age int eld relational queries involving selection elds legitimate 
special case partial types introduce constant type denoting dynamic values information known completely dynamic value 
acm transactions database systems 
peter buneman atsushi ohori show partial types assume names partial types person name string address string employee name string address string salary int customer name string address string balance int suppose db set type initially information structure members set 
examples database may manipulated type safe language 
operation lter de ned selects elements partial type lter fp may query select name name address address employee db salary result query set complete records relation 
similarity form postgres stonebraker rowe may lter arbitrary kinds heterogeneous sets con ned extensionally de ned relations database :10.1.1.48.1422
interpretation partial types partial partial value type type 
property represent desired set inclusion type system 
particular person partial employee 
inclusion lter employee lter person hold heterogeneous set particular database db 
data model inclusion inheritance derived property type system achieved explicit association extents classes 
modifying technique give polymorphic type join de ne typing rules unions intersections heterogeneous sets 
adding partial type ordering meet join operations 
union intersection heterogeneous sets respectively meet join partial types 
type system infer appropriate partial type heterogeneous set obtained various set operations 
example typings inferred 
union lter customer db lter employee db fp name string address string intersection lter customer db lter employee db fp name string address string salary int balance int 
intersection de nable language inferred types automatically allow appropriate polymorphic functions applied result set operations 
example type intersection heterogeneous sets join types polymorphic functions applicable sets applicable intersection 
successfully achieve desired coupling set inclusion method inheritance 
acm transactions database systems polymorphism type inference database programming 
ability write functions fun select name name balance balance customer db salary type inference allows application function heterogeneous set members type salary int 
result uniformly typed set set type name string balance int application lter employee db valid application lter customer db type statically determined failure type inference 
subsections shall describe basic operations dealing sets partial values 
shall give typing rules extend machiavelli include partial values 
basic operations deal partial values introduce new primitive operations dynamic coerce fuse 
extend meaning existing primitives union 
dynamic 
construct partial value type type heterogeneous set may constructed name joe age dynamic name jane balance expression implicitly union result extended typing rules union expression type fp name string meet fp name string age int fp name string balance int remaining primitives may fail 
introduce exception handling mechanism adopt strategy operation succeeds return result singleton set fails return empty set 

description type exposes properties speci ed type returns singleton set containing partial value coercion possible empty set 
example name string dynamic name joe balance partial type fp name string expression select name type check select balance 
hom position construct lter operation mentioned earlier ties inclusion extents ordering types 
type parameters de ned language 
treated syntactic abbreviation lter hom fn union fg coerce 
coerces partial value denoted complete value type succeed type component operation succeeds return singleton set return empty set 
example coerce name string dynamic name jane balance yield empty set coerce name string balance int dynamic name jane balance return set name jane balance acm transactions database systems 
peter buneman atsushi ohori fuse 
combines partial values denoted succeed complete values equal 
partial type partial type fuse partial type 
dynamic name jane age balance name string age int name string dynamic name jane fuse singleton set type fp name string age int fuse return empty set 
fuse may de ne set intersection fun fuse hom fn fuse union fg fun intersection hom fn fuse union fg note fuse basic equality compute partial values equal complete values empty fuse 
extension language incorporate partial values extend de nition language 
set types extended include partial type constructor 
identify subset ranged may contain partial types 
bd ref set terms extended include operations partial values 

dynamic fuse coerce extend type system new term constructors partial values de ne ordering subset types represents types 
write denote partial rules de ne ordering ref ref rst rules derive order partial types directly ordering introduced section 
remaining rules lift ordering component wise description types 
examples ordering 
acm transactions database systems polymorphism type inference database programming 
dynamic dynamic fp coerce coerce fuse 
fuse union 
union fig 

typing rules partial values name string address string name string address string balance int acc int customer name string address string balance int acc int customer name string address string balance int salary int gives typing rules new term constructors 
new condition 
rules fuse denotes condition ground substitutions condition 
rule union denotes ground substitutions 
standard elimination operations introduced section database operations de ned section available types containing partial type constructor exception eld selection requires partial information types speci ed kinds 
expression type form eld safely extracted 
result eld selection base type 
compound type actual type eld expression case type result eld selection partial type 
recall typing rule eld selection dot rule applicable cases partial values need de ne kinding rule partial types 
base type 
rules de ned remain unchanged types may contain partial types 
record kind ranges partial types eld selection polymorphic partial types complete types 
extended language complete type inference algorithm 
necessary technique essentially typechecking join operation described previous section 
language uniformly integrate heterogeneous sets type system 
example function wealthy name salary int bg acm transactions database systems 
peter buneman atsushi ohori db val 
val employees lter employee db val employees 
fp name string address string salary int val customers lter customer db val customers 
fp name string address string balance int union employees customers val 
fp name string address string intersection employees customers val 
fp name string address string balance int salary int fun select name salary val fn salary int name bg fun select name balance val fn balance int name bg fun intersection val fn balance int salary int name bg intersection employees customers val 
fig 

programming heterogeneous sets de ned may applied heterogeneous sets type fp name string salary int gives examples involving partial values 

demonstrated extension type system ml kinded type inference allows record formation eld selection implemented polymorphic operations 
set type allows represent sets records relations number operations union di erence selection projection single attribute generalized non rst normal form relational algebra 
implemented particular technique ohori ohori compiling eld selection ecient indexing operation combined record operations mentioned extension standard ml new jersey appel macqueen :10.1.1.55.9444:10.1.1.55.9444:10.1.1.26.4611
extension type system conditional type schemes allows provide polymorphic projection natural join operations giving complete implementation generalized relational algebra 
argued operations important practical relation query languages 
product single column projection usually employed 
similar type inference scheme technique statically checking safety operations heterogeneous collections member collection dynamically typed values common structure 
approach described provides believe satisfactory account relational database programming aspects object oriented programming may brought framework polymorphically typed programming language may basis number investigations acm transactions database systems polymorphism type inference database programming 
principles database programming 
brie review 
types classes 
covered aspects objectoriented databases dealt important aspect classes object oriented programming abstraction code sharing 
ohori buneman statically typed polymorphic class declarations described 
implementation type class normally record type elds correspond instance variables object oriented terminology 
methods correctly implementation type ensured checking correctness eld selection described techniques may carried subclasses check code properly inherited superclass 
example de ne class person class person name string age int fun person name age string int person fun name name sub string fun age age sub int fun increment age modify age age sub sub sub special type variable ranging set subtypes person de ned 
inclusion sub variable type methods name age increment age re ects user intention methods inherited subtypes person 
extended type system infers typing method de ned class 
class person person string int person name string age int increment age notation form kinded type variable instances restricted set subtypes person 
regarded integration idea bounded type abstraction introduced cardelli wegner data abstraction :10.1.1.117.695
object oriented programming language de ne subclasses person class employee name string age int salary int isa person fun employee name age salary string int employee fun salary salary sub int fun add salary modify salary salary sub int sub declaration isa person class inherits methods name age increment age person 
prototype implementation machiavelli prints type information subclass de nition 
class employee isa person employee string int employee add salary salary int inherited methods name string acm transactions database systems 
peter buneman atsushi ohori age int increment age type system statically check type consistency methods inherited 
possible de ne classes subclasses classes 
class student name string age int grade real isa person fun student name age grade string int employee fun grade grade sub real fun set grade modify salary sub real sub class name string age int salary int grade real isa fun rf name age grade salary string int classes parameterized types type inference system described extended programs involving classes subclass de nitions 
possible addition idea treatment object identity 
held view object identity programming construct object creation update satisfactorily described operations ml number programming languages 
abiteboul bonner abiteboul bonner catalog operations objects classes described means simple approach object identity 
operations appear call passing abstraction 
example may think person object identities instances person class employee object identities instances employee class 
approach precludes possibility person student identities may fact may subset 
ability ask abstractions views underlying object appears call ability pass abstraction 
done believe possible implement operations suggested abiteboul bonner 
collection types 
original description machiavelli ohori attracted attention immerman hom basic operation computation sets 
reason hom simply small adequate collection operations sets base type system 
purpose type inference type checking fewer primitive functions better 
development record types set types independent primitive operations involve occur sections 
purposes equally record types conjunction lists bags collection type 
fact lists bags sets common object oriented programming object oriented databases object design supply primitive types 
acm transactions database systems polymorphism type inference database programming 
study commonality various collection types fruitful extension ideas provided 
may provide better ways structuring syntax wadler understanding commonality collection types watt trinder general approach query languages optimization types breazu tannen :10.1.1.33.5381
acknowledgments val breazu tannen deserves special 
contributed ideas greatly helped understanding type systems 
referees careful reading grateful helpful conversations serge abiteboul malcolm atkinson luca cardelli john mitchell rick hull aaron 
abadi cardelli pierce plotkin 
dynamic typing language 
acm transactions programming languages systems 
abiteboul bonner 
objects views 
proc 
acm sigmod conference pp 

albano cardelli orsini 
galileo strongly typed interactive conceptual language 
acm transactions database systems 
appel macqueen 
standard ml new jersey 
proc 
third international symposium programming languages logic programming pp 

atkinson bailey chisholm cockshott morrison 
approach persistent programming 
computer journal november 
atkinson bancilhon dewitt maier zdonik 
object oriented database system manifesto 
proceedings deductive object oriented database conference kyoto japan pp 

atkinson buneman 
types persistence database programming languages 
acm computing surveys 
augustsson 
compiler lazy ml 
proc 
acm symposium lisp functional programming pp 

bancilhon briggs khoshafian valduriez 
fad powerful simple database language 
proc 
intl 
conf 
large data bases pp 

biskup 
formal approach null values database relations 
advances data base theory vol 
new york press 
breazu tannen buneman naqvi 
structural recursion query language 
proc 
rd international workshop database programming languages pp 

morgan kaufmann publishers 
breazu tannen buneman wong 
naturally embedded query languages 
proc 
international conference database theory springer lncs pp 

breazu tannen subrahmanyam 
logical computational aspects programming sets bags lists 
proc 
international colloquium automata languages programming springer lncs pp 

buneman jung ohori 
powerdomains generalize relational databases 
theoretical computer science 
buneman libkin suciu tannen wong 
comprehension syntax 
sigmod record 
buneman ohori 
type system reconcile classes extents 
rd international workshop database programming languages pp 

morgan kaufmann publishers 
acm transactions database systems 
peter buneman atsushi ohori cardelli 
amber 
combinators functional programming lecture notes computer science pp 

springer verlag 
cardelli 
semantics multiple inheritance 
information computation 
special issue devoted symp 
semantics data types sophia antipolis france 
cardelli mitchell 
operations records 
proceedings mathematical foundation programming semantics lecture notes computer science pp 

cardelli wegner 
understanding types data abstraction polymorphism 
computing surveys dec 
copeland maier 
making smalltalk database system 
proc 
acm sigmod conference pp 

courcelle 
fundamental properties nite trees 
theoretical computer science 
damas milner 
principal type schemes functional programs 
proc 
acm symposium principles programming languages pp 

gallier snyder 
complete sets transformations general uni cation 
theoretical computer science 
harper pierce 
record calculus symmetric concatenation 
proc 
acm symposium principles programming languages pp 

hart wong 
query language genetic databases 
unpublished manuscript 
available www www cis upenn edu html 
hindley 
principal type scheme object combinatory logic 
trans 
american mathematical society 
mitchell viswanathan 
standard ml weak polymorphism imperative constructs 
proc 
ieee symposium logic computer science pp 

hudak peyton jones wadler boutel fairbairn fasel guzman hammond hughes johnsson kieburtz nikhil partain 
report programming language haskell non strict purely functional language version 
sigplan notices haskell special issue 
huet 
esolution equations dans les langages ordre 
ph 
thesis university paris 
barnes krieg bruckner 
rationale design programming language ada 
acm sigplan notices 
imielinski 
incomplete information relational databases 
journal acm oct 
immerman stemple 
expressiveness family nite set languages 
proc 
acm symposium principles database systems pp 

jategaonkar mitchell 
ml extended pattern matching subtypes 
proc 
acm conference lisp functional programming snowbird utah pp 

kim 
observations odmg proposal 
acm sigmod record 
leroy 
polymorphism names continuation 
proc 
acm symposium principles programming languages pp 

leroy weise 
polymorphic type inference assignment 
proc 
acm symposium principles programming languages 

semantic issues connected incomplete information databases 
acm transactions database systems sept 
macqueen 
weak 
note standard ml new jersey distribution package 
milner 
theory type polymorphism programming 
comput 
syst 
sci 

acm transactions database systems polymorphism type inference database programming 
milner tofte harper 
de nition standard ml 
mit press 
mitchell 
type systems programming languages 
van leeuwen ed handbook theoretical computer science chapter pp 

mit press elsevier 
morrison brown connor dearle 
napier manual 
tech 
rep department computational science university st andrews 
object design 
objectstore manual 
burlington ma 
object design ohori 
simple semantics ml polymorphism 
proc 
acm ifip conference functional programming languages computer architecture london england pp 

ohori 
study types semantics languages databases object oriented programming 
ph 
thesis university pennsylvania 
ohori 
semantics types database objects 
theoretical computer science 
ohori 
compilation method ml style polymorphic record calculi 
proc 
acm symposium principles programming languages pp 

ohori 
polymorphic record calculus compilation 
submitted publication 
available preprint rims rims kyoto university 
extended version ohori :10.1.1.26.4611
ohori buneman 
type inference database programming language 
proc 
acm conference lisp functional programming snowbird utah pp 

ohori buneman 
static type inference parametric classes 
proc 
acm oopsla conference new orleans louisiana pp 

extended version published mitchell gunter editors theoretical aspects object oriented programming pp 

mit press 
ohori buneman breazu tannen 
database programming machiavelli polymorphic language static type inference 
proc 
acm sigmod conference portland oregon pp 

remy 
typechecking records variants natural extension ml 
proc 
acm symposium principles programming languages pp 

extended version published mitchell gunter editors theoretical aspects object oriented programming pp 

mit press 
remy 
typing record concatenation free 
proc 
acm symposium principles programming languages pp 

robinson 
machine oriented logic resolution principle 
journal acm 
schmidt 
high level language constructs data type relation 
acm transactions database systems 
stonebraker rowe 
design postgres 
proc 
acm sigmod conference pp 

stroustrup 
programming language 
addison wesley 
tofte 
operational semantics polymorphic type inference 
ph 
thesis department computer science university edinburgh 
turner 
miranda non strict functional language polymorphic types 
functional programming languages computer architecture lecture notes computer science pp 

springer verlag 
wadler 
comprehending monads 
proc 
acm conference lisp functional programming pp 

wand 
complete type inference simple objects 
proc 
ieee symposium logic computer science ithaca new york pp 

wand 
corrigendum complete type inference simple object 
proc 
ieee symposium logic computer science pp 

acm transactions database systems 
peter buneman atsushi ohori wand 
type inference record concatenation simple objects 
proc 
ieee symposium logic computer science pp 

watt trinder 
theory bulk types 
tech 
rep department computing science glasgow university glasgow qq scotland 
wirth 
modula language modular multiprogramming 
software practice experience 
wong 
querying nested collections 
ph 
thesis department computer information science university pennsylvania 
zaniolo 
database relation null values 
comput 
syst 
sci 

acm transactions database systems 
