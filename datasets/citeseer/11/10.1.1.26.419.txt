research issues renovation legacy systems arie van deursen paul klint chris verhoef cwi box gb amsterdam netherlands university amsterdam programming research group kruislaan sj amsterdam netherlands arie cwi nl www cwi nl arie cwi nl www cwi nl wins uva nl adam wins uva nl 
goals tutorial give reader quick field software renovation ii show techniques compiler technology formal methods applied iii demonstrate research driven real life industrial case studies iv indicate challenging problems unsolved 
presentation demonstrations case studies discussed 
software renovation tomorrow technology bring yesterday software level today 
provide overview research area 
start section exploring need software renovation 
provide definitions basic terminology pointers important literature 
proceed discuss aspects software renovation detail 
section study increase understanding legacy system apply knowledge purpose migrating legacy object technology 
techniques type inference concept analysis play essential role 
section deal ways building renovation factories capable restructuring legacy systems millions lines code entirely automatic manner 
section conclude tutorial findings experience software renovation research 
initially triggered concerns regarding renovation software closely cooperated dutch banks inter national software houses telecommunications firms question prepare software system assets flexibility 
directly driven industrial needs 
setting stage legacy software world justify investments software renovation technology 
turns living software volcano large numbers language statements fp assembler fortran cobol visual basic perl smalltalk sql language total cobol assembler languages table 
function points versus lines code distribution languages new old software systems control lives 
admire sheer bulk volcano benefit fertile grounds surrounding suffering frequent lava steam poisonous gas uncertain going volcano large eruption 
figures collected jones provide insight size problem 
uses function point fp unit measurement software 
abstracts specific programming languages specific presentation styles programs 
correlation function points measurement lines code differs programming language summarized table 
point size windows equal theta fp 
total volume software estimated theta fp giga fp 
distribution various programming languages implement function points summarized table 
older languages dominate scene today giga fp written cobol 
hypothetically assume software written cobol get estimation cobol statements fp theta cobol statements total volume software 
measure software quality lack jones estimated average errors occur function point 
includes errors requirements design coding documentation bad fixes 
result theta programming errors giga bugs waiting chance burst sooner 
developing better ways developing new software solve problem 
industry approaches years age case computer science takes workers perform maintenance build new products 
current data table shows extrapolations number programmers working new projects enhancements repairs 
current decade programmers working repair projects 
forecasts predict third programmers working projects involving construction new software 
conclude importance maintenance gradual improvement software increasing deserves attention computer science education research 
year new projects enhancements repairs total table 
forecasts numbers programmers worldwide distribution activities goals tutorial goals tutorial give reader quick field software renovation show techniques compiler technology formal methods applied demonstrate research driven real life industrial case studies indicate challenging problems unsolved 
approach taken amsterdam solve variety problems area system renovation 
remainder define software renovation section sketch technological infrastructure section give pointers reading section 
software renovation 
chikofsky cross proposed terminology field re engineering 
term reverse engineering origins hardware technology denotes process obtaining specification complex hardware system 
today notion reverse engineering applied software 
forward engineering goes high level design low level implementation reverse engineering seen inverse process 
amounts analyzing software system identify system components interactions represent system higher level abstraction 
higher level abstraction achieved filtering irrelevant technical detail combining legacy code elements novel ways 
alternatively realized recognizing instances library higher level plans program code 
technique particular applied problem program comprehension aims explaining pieces source code maintenance programmers 
techniques debugging program analysis area slicing purpose 
problem explaining architecture legacy system indicating components interrelationships referred system understanding 
adaptation system goal system renovation 
done ways 
system restructuring amounts transforming system representation level abstraction 
essential aspect restructuring semantic behaviour original system new remain modification functionality involved 
alternative way perform renovation reverse engineering step called re engineering specification higher level abstraction constructed transformation applied design level followed forward engineering step improved design 
renovation factory collection software tools aim fully automatic renovation legacy systems organizing renovation process assembly line smaller consecutive renovation steps 
distinguish methodology technology system renovation 
deals process management aspects renovation typically identifies phases system inventory strategy determination impact analysis detailed planning conversion 
provides necessary techniques implement steps prescribed methodology 
methodology technology form symbiosis concentrate technological aspects system renovation 
tutorial deal system understanding section system renovation section 
asf sdf technical infrastructure renovation primarily asf sdf meta environment 
specification formalism asf sdf combination algebraic specification formalism asf syntax definition formalism sdf 
asf sdf specifications consist modules module sdf part defining lexical context free syntax asf part defining equations 
sdf part corresponds signatures ordinary algebraic specification formalisms 
syntax restricted plain prefix notation arbitrary context free grammars defined 
syntax defined sdf part module immediately defining equations syntax equations user defined 
equations asf sdf specification distinctive features conditional equations positive negative conditions 
non left linear equations 
list matching 
default equations 
possible execute specifications interpreting equations conditional rewrite rules 
semantics asf sdf innermost rewriting 
default equations tried applicable equations failed arguments match conditions failed 
powerful features asf sdf specification language list matching 
implementation list matching may involve backtracking find match satisfies left hand side rewrite rule conditions 
backtracking scope rewrite rule right hand side rewrite rule normalized normalization fails backtracking performed find new match 
asf sdf specifications interactive programming environment asf sdf meta environment 
environment specifications developed tested 
provides syntax directed editors parser generator pretty printer generator rewrite engine 
rewrite engine terms reduced interpreting equations rewrite rules 
overview industrial applications system 
reading general introductions renovation data reverse engineering migration legacy systems transition object technology software maintenance 
annotated bibliography current renovation literature 
workshops conferences interest working conferences reverse engineering 
european conferences maintenance reengineering 
international workshops program comprehension 
international conferences software maintenance 
regularly sessions maintenance renovation occur general software engineering conferences 
useful source journal software maintenance 
relevant information includes line database publications renovation including abstracts case tool vendor list useful tools reverse engineering 
home page sei reengineering centre overview georgia tech reverse engineering group presenting papers tools pointers groups 
description research activities related reengineering performed care computer laboratory computer science department tennessee technological university 
object identification key aspect software renovation letting legacy system developed technology decades ago benefit current advancements programming languages 
section look techniques help going system developed traditional procedural methodology system set principles object orientation 
www informatik uni stuttgart de ifi ps reengineering www ca software engineering vendor html www sei cmu edu reengineering www cc gatech edu reverse www csc edu challenges transition traditional cobol environment object oriented platform enhance system correctness robustness extendibility reusability key factors affecting software quality object technology enabler splitting large application reusable components accessed independently possibly replaced incrementally commercial theshelf components 
discusses highly practical reasons renovation 
short finding objects legacy systems key research area software renovation 
literature reports systematic approaches object identification partially automated 
typically involve steps identify legacy records candidate classes identify legacy procedures programs candidate methods determine best class method form cluster analysis 
problems application approaches actual systems 

legacy systems greatly vary source language application domain database system easy select identification approach best suited legacy system hand 

impossible select single object identification approach legacy systems typically heterogeneous various languages database systems transaction monitors 

limited experience actual object identification projects making new migration projects reveal problems encountered 
embarking object identification project select compose blend object identification techniques 
project new problems solved 
section look object identification issues detail support providing legacy system understanding section ways find types cobol system section techniques combining types selected legacy functionality arriving candidate classes section 
system understanding finding meaningful objects fully automatic way impossible 
higher level automation stronger components rely actual technical im course object technology create renovation problems features multiple inheritance unwieldy class hierarchies polymorphism severely complicate program analysis 
tutorial explore interesting topic 
example additional reason difficult find mainframe maintenance programmers young programmers coming university willing learn old technology want modern languages 
strictly speaking search classes 
term object identification commonly stick terminology 
lexical analysis repository syntax analysis dataflow analysis report generation cross referencing metrics style comments 
cluster analysis groups data functionality 
visualization call graph perform graph database usage 
legacy sources fig 

repository system understanding plementation legacy code 
purpose find object close application domain technical infrastructure 
tool support object identification aim full automation providing interactive system understanding assisting re engineer understanding components modules databases screens 
system consists related 
shows extractor query viewer approach reverse engineering tool sets 
extract sorts facts legacy sources database 
database turn queried relations interest visualized 
extractor phase syntactic analysis help unravel structure legacy code 
requires availability parser grammar legacy language case 
issues pertaining parser development discussed detail section 
parser available required fact extraction sufficiently simple lexical analysis methods may accurate simpler faster develop run tolerant respect unknown language constructs errors source code 
querying phase operations repository include relational queries restriction relations names matching regular expressions transitive closures example call relations lifting call relations procedures files crucial aspect querying filtering restricting relations items relevant understanding task hand task finding variables programs representing business entities rules 
heuristics filtering cobol domain example call graph metrics database usage discussed 
viewing phase derived relations shown re engineer various forms 
way metrics purpose pointing re engineer example programs complexity measure higher average 
alternative technique cluster analysis numeric distance items purpose grouping 
particular importance system visualization 
common area system understanding graph visualization display example call graphs database usage perform graphs interesting ways program visualization discussed eick example able visualize extremely large code portfolios representing source line just colored pixel 
main benefit phase tooling approach repository permits arbitrary querying making possible apply tool set wide variety renovation problems 
generally speaking system understanding session iterate phases example visualization see filtering techniques apply iteration 
obviously application system understanding tools goes mere object identification possibilities include generation interactive documentation quality assessment introducing novice programmers legacy application 
type inference object identification methods grouping procedures type arguments process 
unfortunately cobol untyped language blocking route object identification purposes 
remedy problem propose infer types cobol variables actual usage sight cobol may appear typed language 
variable occurring statements procedure division declared data division 
typical declaration may look follows tab 
tab pos pic occurs 
tab filled pic value 
variables declared 
tab name record consisting fields tab pos single character byte picture occurring times array length tab filled integer picture comprising bytes initialized value zero 
unfortunately variable declarations data division suffer number problems making unsuitable fulfill role types 
possible separate type definitions variable declarations variables record structure needed full record construction needs repeated 
violates principle type hides actual representation chosen 
absence type definitions difficult group variables represent kind entities 
possible variables byte representation converse hold conclude variables share byte representation represent kind entity 
addition important problems pertaining type definitions cobol limited means accurately indicate allowed set values variable ranges enumeration types 
cobol sections paragraphs procedures type explicit parameter declarations 
solve problems proposed type inference find types cobol variables actual usage 
start situation variable unique primitive type 
generate equivalences types usage variables compared relational operator infer belong type expression assigned variable type expression subtype expression 
primitive types distinguish primitive types elementary types numeric values strings arrays records 
initially declared variable gets unique primitive type 
types unique label variable occurrences unique names cobol program module variable names 
qualify variable names program names obtain uniqueness system level 
denote primitive type variable type relations looking expressions occurring statements equivalence relation primitive types inferred 
cases distinguished relational expressions equivalence inferred 
arithmetic expression equivalence inferred 
different array accesses equivalence inferred 
assignment infer subtype type generally mean equivalence class primitive types 
subtyping important avoid problem pollution derivation counter intuitive equivalences due commutativity transitivity equivalence relation 
system level analysis addition inferring type relations individual programs infer type relations system wide level 
relations ensure variable declared include file type different programs included 
furthermore infer types actual parameters program call module level listed clause subtypes formal parameters listed linkage section variables read written databases equivalent types 
related type inference cobol related earlier type inference various approaches detecting correcting year problems 
approach dealing year problem type theory 
detailed overview related 
clearly type inference cobol applications mere object identification explain types replace literal values symbolic constants year euro conversions language migrations maintenance monitoring 
street city house str ord prov cd ind cty odd 
name prefix bank city bank pay bank 
count area nr area 
mod dat fig 

concept lattice combining data fields programs concept analysis business applications written cobol data stored processed represent core system 
reason data records cobol programs starting point object identification approaches 
records turn combined procedures programs arriving candidate classes 
common way finding desired combinations cluster analysis 
mathematical concept analysis proposed alternative cluster analysis purpose legacy code analysis 
argued concept analysis avoids problems encountered cluster analysis purpose object identification 
concept analysis starts table indicating features set items 
builds called concepts maximal sets items sharing certain features 
possible concepts grouped single lattice called concept lattice 
smallest concepts consist items having potentially different features largest concepts consist different items features common 
example concept lattice shown 
lattice derived automatically loc cobol case study 
items lattice fields records read written file 
shown names concept 
features fields programs field fact type inferred field program program feature field 
programs written concept 
concept corresponds combination fields programs occurring legacy system 
concept candidate class 
connections classes correspond aggregation association inheritance 
see lattice help find objects browse concepts 
row just bottom element consists separate concepts containing single field 
example leftmost concept deals mortgage numbers stored field 
associated program comment lines program performs certain checks validity mortgage numbers 
program uses field ones 
example concept street bottom right different programs directly associated 
compute certain standardized extract street program takes care standardizing street names 
move lattice concepts larger contain items 
leftmost concept second row contains different fields mortgage sequence number written directly node fields lower concepts connected 
program uses fields search full mortgage relation records 
concept interest second row 
represents combination fields zip code house house number city code street city 
combination separate concept occurs different programs 
programs variables concept program associated 
corresponds common superclass concepts 
short lattice provides insight organization legacy system gives suggestions grouping programs fields classes 
human re engineer information select initial candidate classes data functionality available legacy 
crucial step cluster concept analysis apply correct filtering criteria order reduce overwhelming number variables sections programs databases relevant ones 
selection criteria may differ system system trying alternatives system investigated exactly system understanding tool set discussed section comes 
selection criteria arrive persistent data metrics derived call relation discussed 
docs tool tool tool tool 
tools native pattern language grammar development mass change factory original system system manager factory processing post component development generation generic factory transformations generic generic analyzers pretty printer project grammar preprocessing fig 

phases creation software renovation factories renovation factories soon architecture legacy system recovered understanding system increased techniques described previous sections position determine done 
abandoned 
reality close interplay analysis renovation analysis structured code yield precise analysis results analysis badly structured code 
uncommon analysis renovation iterative process 
simplicity treat section sequential steps concentrate factory approach renovation section 
discuss examples section 
system understanding inherently interactive ultimate goal completely automated renovation factory process millions lines code human interaction 
creation renovation factories practice needs program transformations program restructuring simple global changes calling conventions migrations new language dialects goto elimination control flow restructuring 
transformations affect millions lines code factory approach minimal human intervention desired achieve cost effective high quality solution 
recall section define renovation factory collection software tools aim fully automatic renovation legacy systems organizing renovation process assembly line smaller consecutive renovation steps 
legacy systems show lot variety regarding architecture programming languages database organization error handling calling conventions 
experience shows renovation project unique requires extensively tailored approach 
generation customization renovation factories major issue 
order promote flexibility reusability renovation factories built individual tools small general possible 
approach illustrated consists phases grammar development determine project grammar 
factory generation generate generic framework renovation factory 
amounts automatically deriving generic tools parser pretty printer frameworks analysis transformation project grammar 
component development develop dedicated tools factory specific project 
factory production environment configure run factory 
discuss phases turn 
grammar development grammars form basis factory generation approach 
practice completely non trivial obtain manage grammars 
included international standard may contained manual proprietary language may embedded source code existing tools compilers pretty printers 
problem grammars tend huge thousands grammars rules cover various language dialects various local language extensions 
grammar maintenance perspective standard lr parsing techniques unsuitable tend generate shift reduce conflicts modification grammar 
completely depend generalized lr parsing method provided asf sdf capable handling arbitrary context free grammars 
research issue obtain grammars languages cost effective manner 
labeled activity computer aided language engineering collection tools grammar extraction manipulation 
factory generation project grammar determined focus automatic generation components language parameterized frameworks generic analysis transformation pretty printing 
working order setting higher order analysis transformation functions 
generate grammar specific analysis transformation functions perform default operation language construct 
default behaviour overruled writing conditional equations define desired behaviour specific language constructs 
immediately raises question write equations formal specification expert programmer knowledgeable legacy languages project 
clearly necessary able describe certain patterns code facilitate analysis automatic change 
approach take automatically generate pattern language project grammar resembles language defined project grammar possible 
tight integration concrete syntax asf sdf express patterns syntax tree concrete syntax language reengineered 
way programmer knowledgeable language specify search replacement patterns conditional equations needing know formal machinery factory 
important complete control steps taken automated renovation process intermediate results handled 
automatically generate support form scaffolding similar inclusion pseudo code assertions comments traditional code development 
case see scaffolding extension project grammar allows representation intermediate results analysis transformation annotations program code 
component prototyping mentioned renovation factories built individual tools small general possible 
results better flexibility reuse increased control understanding tool 
apart general tools bringing program parts certain standard forms performing program simplifications developed tools upgrading embedded sql normalizing control flow embedded cics step step restructuring cobol code 
factory production environment final phase approach building renovation factory 
components developed prototyped need put operation efficient production environment 
size legacy systems issues scalability multi processor execution factory coming play 
important supporting technologies compilers turn prototype specifications efficient stand programs middleware optimized connection language oriented tools 
give pictures discussions renovation factories 
examples discuss examples 
example concerns grammar extraction factory generation proprietary language switching systems 
second example illustrates cobol factory extracting business logic programs separating computation coordination 
grammar development switching system language software hardware switching systems proprietary 
includes central processing units compilers operating systems developed house 
instance lucent technologies uses unix targeted proprietary processor 
maintain unix compiler 
phenomenon occurs ericsson developed central processor operating systems languages compilers 
difference situations ericsson uses tools widely processors 
result software renovation tools available large amounts software 
ericsson case ideal test case approach 
described previous section step generating renovation factory development relevant project grammar 
case concerns proprietary language ssl switching system language 
program ssl fact collection programs different languages combined single file 
complete reliable source ssl grammar source code ssl compiler 
steps needed extract grammar 
compiler source code reverse engineered grammar part identified 
essential grammar information extracted part compiler 
resulted extraction lexical context free production rules backus naur form bnf 
unfortunately grammar usable reengineering heavily oriented compilation 
instance compilation oriented grammar removes comments renovation comments seen part source retained final result renovation 
preparatory step reengineering intermediate ssl grammar generated renovation factory language bnf added number components useful reengineering grammars transformation bnf sdf syntax definition language asf sdf meta environment 
bnf factory retarget extracted ssl grammars 
bnf factory transform grammar sublanguages ssl minutes processing time standard workstation initial bnf version sdf version usable renovation purposes 
able parse sublanguage minutes processing time 
complete renovation factory sublanguage generated 
completed desired renovation components factory renovation programs particular ssl subset 
currently complete ssl grammar assembled combining embedded 
step generate complete ssl factory 
ssl factory ready fact generated compiler source code production line rapid development component tools facilitate automated solution software reengineering problems 
separating coordination computation cobol typical renovation problem migrate transaction systems mainframe networked pc environment 
systems strongly tied mainframes embedded languages cics deal transaction monitors data 
order migrate client server architecture necessary remove embedded cics code 
done code needs maintainable removing traces platform migration source code 
example discuss german ses gmbh eliminated dangerous cics code constructed migration tool separate coordination computation cics code removed 
main problems eliminate jump instructions code 
shows fig 

original cobol code go statements strongly simplified version spaghetti code original program 
code fragment representative quality code mainframes 
go 
depending case statement contains cases gos 
fact small fragment jump instructions 
restructuring method systolic algorithm remove gos steps way coordination computation separated logic program clear 
final output shown 
seen code changed dramatically 
superfluous code gone coordination separated computation 
paragraph hv provides coordination part program resembles main program evaluate 
evaluate statement result migrating original go 
depending statement original cases collapsed cases 
subroutines section see computations 
reachable coordination part run blocks access 
comparable preamble say pascal procedures declared 
fig 

final cobol code go removed original program intermediate steps carried remove jump instructions separate computations coordination available internet 
discuss kind restructuring detail 
tutorial covered variety issues area system renovation 
starting discussion economic need maintenance renovation approaches problems object identification system understanding grammar reengineering creation renovation factories 
observations field software renovation 
challenging aspect software renovation research number different areas proficiency required 
include historic programming languages systems cobol mainframe environment 
target new programming language technologies corba java current market standards 
line demonstration steps involved available adam wins uva 
nl systolic systolic html 
migration technology asf sdf meta environment 
software engineering theory commercial practice 
knowledge transfer coping conservatism cobol best unrealistic expectations new technology java solve migration technology say grammar 
clearly effect curricula software engineering 
concerning migration technology benefited asf sdf meta environment 
distinctive technical properties turned great significance renovation purposes techniques generic depend particular programming language cobol pl parameterized language definition 
result major parts renovation techniques directly reused different languages 
give example year problem resides probably systems written standard languages plus proprietary languages 
techniques formal underlying formal notions sorted signatures positive negative conditional rewriting 
program conversions instance expressed rewrite rules 
formalization increases quality analyses conversions 
syntactic analysis generalized lr parsing glr 
enables construction modular grammars parsers languages large grammars dialects cobol 
traditional parsing techniques lalr parser generators yacc bison lead increased maintenance problems large grammars time needed add language constructs needed new dialects prohibitive 
driving force software renovation strong need maintain parts software volcano 
implies software renovation research carried close cooperation industrial partners possession problems solved 
fortunately confident progress areas compiler programming language technology formal methods continue help offer right tools right time 
time analysis legacy systems provides empirical foundation programming language research 
uncovers effects positive negative years intensive programming language real world 
tried show software renovation research reveals new challenging problems 
techniques analysis code generation satisfactory perspective traditional compiler may longer satisfactory perspective interactive program understanding 
gigantic scale renovation projects presents implementation problems opportunities may inspire research years come 
largest challenge see try bridge gap research aimed building new software research aimed maintaining old software 
strongly believe integrated approach best way proceed 
implies introducing maintenance renovation considerations earlier software construction process usual today 
implies designing new languages programming environments amenable maintenance renovation 
acknowledgments wrote text represents colleagues cooperated cooperating 
direct indirect contributions current 
tobias kuipers commented initial drafts tutorial 

aiken 
data reverse engineering 
mcgraw hill 

bennett editors 
proceedings international conference software maintenance 
ieee computer society november 

bergstra heering klint editors 
algebraic specification 
acm press frontier series 
acm press operation addison wesley 

bergstra klint 
discrete time software coordination architecture 
science computer programming 

blaha quilici verhoef editors 
proceedings fifth working conference reverse engineering 
ieee computer society october 

van den brand van deursen klint van der meulen 
industrial applications asf sdf 
wirsing nivat editors algebraic methodology software technology amast volume lecture notes computer science pages 
springer verlag 

van den brand klint olivier 
compilation memory management asf sdf 
proceedings th international conference compiler construction cc lncs 
springer verlag 
appear 

van den brand klint verhoef 
core technologies system renovation 
jeffery editors theory practice informatics volume lncs pages 
springer verlag 

van den brand klint verhoef 
reverse engineering system renovation annotated bibliography 
acm software engineering notes 

van den brand klint verhoef 
term rewriting sale 
kirchner kirchner editors second international workshop rewriting logic applications electronic notes theoretical computer science 
springer verlag 

van den brand sellink verhoef 
control flow normalization cobol cics legacy systems 
lehner editors proc 
nd euromicro conf 
maintenance reengineering pages 
ieee computer society 

van den brand sellink verhoef 
current parsing techniques software renovation considered harmful 
tilley editors proc 
sixth international workshop program comprehension pages 
ieee computer society 

van den brand visser 
generation formatters context free languages 
acm transactions software engineering methodology 

brodie stonebraker 
migrating legacy systems gateways interfaces incremental approach 
morgan kaufman publishers 


user controlled software renovation factory 
verhoef editors proc 
third european conference software maintenance reengineering 
ieee computer society 
appear 


chen fowler koutsofios wallach 
ciao graphical navigator software document repositories 
bennett editors int 
conf 
software maintenance icsm pages 
ieee computer society 

chikofsky cross 
reverse engineering design recovery taxonomy 
ieee software 

cimitile de lucia di 
identifying objects legacy systems design metrics 
journal systems software 
appear 

van deursen heering klint editors 
language prototyping algebraic specification approach volume amast series computing 
world scientific publishing 

van deursen kuipers 
rapid system understanding cobol case studies 
tilley editors sixth international workshop program comprehension iwpc pages 
ieee computer society 

van deursen kuipers 
finding objects cluster concept analysis 
st international conference software engineering icse 
acm 
appear 

van deursen moonen 
type inference cobol systems 
baxter quilici verhoef editors proc 
th working conf 
reverse engineering pages 
ieee computer society 

van deursen woods quilici 
program plan recognition year tools 
proceedings th working conference reverse engineering wcre pages 
ieee computer society 

eick 
visualization tool 
ieee computer 

henglein mossin niss sorensen tofte 
anno type theory year conversion tool 
th annual symposium principles programming languages popl 
acm 
appear 

schmidt 
bringing objects cobol moore tool migration cobol object oriented cobol 
proc 
conf 
technology object oriented languages systems tools pages 
prentice hall 

fokkink verhoef 
conservative extension positive negative conditional term rewriting applications software renovation factories 
fundamental approaches software engineering lncs 
appear 

hart 
scaleable automated process year system correction 
proceedings th international conference software engineering icse pages 
acm 

heering hendriks klint rekers 
syntax definition formalism sdf manual 
sigplan notices 

jones 
estimating software costs 
mcgraw hill 

jones 
year software problem quantifying costs assessing consequences 
addison wesley 

klint 
meta environment generating programming environments 
acm transactions software engineering methodology 

klint verhoef 
evolutionary software engineering component approach 
horspool editor ifip wg working conference systems implementation languages methods tools pages 
chapman hall 

lakhotia 
unified framework expressing software subsystem classification techniques 
journal systems software pages march 

lindig snelting 
assessing modular structure legacy code mathematical concept analysis 
th international conference software engineering icse pages 
acm 

liu wilde 
identifying objects conventional procedural language example data design recovery 
international conference software maintenance icsm pages 
ieee computer society 

muller orgun tilley uhl 
reverse engineering approach subsystem structure identification 
journal software maintenance 

murphy notkin 
lightweight lexical source model extraction 
acm transactions software engineering methodology 

verhoef editors 
proceedings third european conference software maintenance reengineering 
ieee computer society march 

newcomb 
reengineering procedural object oriented systems 
second working conference reverse engineering wcre pages 
ieee computer society 

callahan jackson 
program understanding tool type inference 
th international conference software icse 
acm 

ong tsai 
class object extraction imperative code 
journal object oriented programming pages march april 


practical software maintenance best practices managing software investment 
john wiley sons 

rich waters 
programmer apprentice 
frontier series 
acm press addisonwesley 

sellink verhoef 
restructuring cobol cics legacy systems 
verhoef editors proc 
third european software maintenance reengineering 
ieee computer society 
appear 

sellink verhoef 
development assessment reengineering language descriptions 
proceedings th international automated software engineering conference pages 
ieee computer society 

sellink verhoef 
native patterns 
blaha quilici verhoef editors proceedings th working conference reverse engineering pages 
ieee computer 

reps identifying modules concept analysis 
international conference software maintenance icsm 
ieee computer society 



addison wesley 
german 

snelting 
concept analysis new framework program understanding 
proceedings acm sigplan sigsoft workshop program analysis software tools engineering paste 
sigplan notices 

snelting tip 
reengineering class hierarchies concept analysis 
foundations software engineering fse pages 
acm 
sigsoft software engineering notes 

tilley editors 
proceedings sixth international workshop program comprehension 
ieee computer society june 

tip 
survey program slicing techniques 
journal programming languages 


scenarios identification objects legacy systems 
baxter quilici verhoef editors th working conference reverse engineering pages 
ieee computer society 

woods quilici yang 
constraint design recovery software reengineering theory experiments 
kluwer academic publishers 
