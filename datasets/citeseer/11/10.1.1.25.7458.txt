improved spring graph embedding algorithm layoutshow java environment graph drawing thesis submitted faculty graduate studies partial fulfillment requirements degree master science thesis supervisor professor joseph liu graduate programme computer science york university keele street north york ontario canada copyright fl algorithms force directed placement virtual physical models effective techniques drawing undirected graphs 
spring algorithms subject thesis type force directed algorithms 
spring algorithms simple 
produce graphs approximately uniform edge lengths distribute nodes reasonably preserve graph symmetries 
problem algorithms depending initial layout possible find undesirable drawings associated local minimum criteria 
addition challenge determine layout stable order algorithm 
thesis develop simple effective cost function determine node layout quality quality entire graph layout execution spring algorithm 
cost function producing initial layout algorithm helping nodes move unwanted local minima providing robust stopping criteria 
furthermore part thesis develop layoutshow signed applet application graph drawing experimentation includes implementation spring algorithm call costspring 
iv foremost thesis supervisor joseph liu valuable comments ideas long discussions group 
andy asia weiss members examining committee time read thesis attending oral examination 
nserc provided financial support scholarship am truly grateful 
arne frick daniel michael himsolt clarifying concepts force directed graph drawing algorithms implementations course thesis 
parents believing role models hard dedication tremendous support understanding schooling years 
go sister brother law providing place years undergraduate studies possible pursue graduate school 
mike endless support understanding helping jclass chart storing back copies thesis just needed 
friends york university particularly rad laura matthew making undergraduate graduate years university enjoyable 
contents page iv acknowledgments list tables xi list figures xii chapter motivation 
objectives 
contributions 
outline thesis 
background force directed methods 
springs electrical forces 
vi barycenter method 
various force directed algorithms 
eades algorithm 
fr 
gem 
modeling graph theoretic distances kk 

simulated annealing dh 
time complexity algorithms 
previous experimental comparisons 
java graph drawing tools 
visualizing graphs java 
brown university graph drawing server gds 
tom sawyer software 
cost oriented spring layout algorithm node graph layout qualities spring algorithms 
node graph layout qualities 
applications measuring node graph layout quality cost function measuring node graph layout qualities choice cost function 
magnitude force cost 
kamada kawai energy cost 
davidson harel cost function 
vii cost function 
approximate cost value 
costspring algorithm drawing undirected graphs 
running time algorithm 
design implementation layoutshow layoutshow signed applet application graph drawing experimentation 
features 
outline 
layoutshow applet 
design system 
packages 
graph structures edu yorku layoutshow 
layout algorithms edu yorku layoutshow 
utility edu yorku layoutshow util 
graphical user interface edu yorku layoutshow gui 
bugs limitations 
experimental results outline experiments 
configuration 
hardware configuration 
software configuration 
viii efficiency costspring algorithm 
convergence 
moving node iteration 
stopping 
performance 
quality layouts costspring algorithm 
edge crossings 
uniformity edge lengths 
cost value 
graph drawing eigenvectors 
finding layout unwanted local minimum summary 
contributions 


appendices examples node layout cost values performance gem compared fr large graphs sample layouts generated costspring ix default values configurable parameters costspring gem fr list tables max min avg force magnitude graph layouts max min avg node layout cost values layouts 
classes package 
classes package 
classes util package 
classes gui package 
test suite graphs 
average number sub iterations node phase costspring running times iteration counts costspring gem fr number crossings layouts costspring gem fr 
running time number crossings algorithm 
time success ratio costchosen algorithm grid time success ratio costchosen algorithm grid time success ratio costchosen algorithm binary tree running times gem fr 
xi list figures binary tree jv jej 
binary tree jv jej 
maximum force magnitudes iterations fr 
graph layouts grid force magnitudes displayed maximum value iterations fr 
graph layouts grid cost values node outline cost spring algorithm 
synchronization drawer computer threads layoutshow usage package packages layoutshow 
internal structure object 
snapshot layoutshow main window 
snapshot layoutshow main window multiple 
evaluation convergence costspring gem fr sparse graphs evaluation convergence costspring gem fr normal graphs 
evaluation convergence costspring gem fr dense graphs xii evaluation method stopping costspring sparse graphs evaluation method stopping costspring normal graphs evaluation method stopping costspring dense graphs running times costspring gem fr sparse graphs 
running times costspring gem fr normal graphs 
running times costspring gem fr dense graphs 
longest edge shortest edge ratios sparse graphs 
longest edge shortest edge ratios normal graphs 
longest edge shortest edge ratios dense graphs 
edge length deviations sparse graphs 
edge length deviations normal graphs 
edge length deviations dense graphs 
graph layout cost values sparse graphs 
graph layout cost values normal graphs 
graph layout cost values dense graphs 
examples layout costs 
binary tree jv jej 
path jv jej 
cycle jv jej 
star jv jej 
binary tree jv jej 
path jv jej 
xiii cycle jv jej 
binary tree jv jej 
binary tree jv jej 
path jv jej 
binary tree jv jej 
cycle jv jej 
path jv jej 
binary tree jv jej 
wheel jv jej 
square grid jv jej 
hypercube jv jej 
dodecahedron jv jej 
triangular grid jv jej 
hypercube jv jej 
square grid jv jej 
jv jej 
hexagonal grid jv jej 
square grid jv jej 
square grid jv jej 
triangular grid jv jej 
triangular grid jv jej 
hexagonal grid jv jej 
xiv square grid jv jej 
complete graph jv jej 
complete graph jv jej 
complete graph jv jej 
hypercube jv jej 
hypercube jv jej 
xv chapter information form entities relationships grow complicated visualization assist understanding 
entities relationships respectively stored nodes edges graph problem visualization problem graph drawing 
computer automated graph drawing algorithms input adjacency information graph output positions graph nodes pleasing drawing graph 
years algorithms popular 
primarily due difficulties drawing graphs nodes hand graph editors 
addition availability libraries creating graphic user interfaces powerful computer graphics hardware taken away obstacles way computer automated graph drawing 
variety nature entities relationships need visualization sub divided graph drawing field areas straight line drawing undirected graphs hierarchical drawing directed graphs orthogonal drawing 
force directed spring algorithms developed drawing binary tree jv jej binary tree jv jej straight line undirected graphs subject thesis 
figures show layouts complete binary tree nodes generated spring algorithm 
layout undesirable local minimum 
examples variety graph layouts produced spring algorithm appendix motivation graph consists set edges set vertices 
edge graph pair pair ordered graph undirected 
undirected graph pair implies adjacent adjacent 
graph drawing algorithms find locations vertices graph generate pleasing drawing graph certain aesthetic criteria 
spring algorithms nodes graph viewed charged particles impose repulsive forces edges graph viewed springs causing attractive forces adjacent nodes graph 
spring algorithms iteration compute forces node displace nodes forces acting 
effect algorithms seek drawing graph forces node locally minimum 
spring algorithms may reach local minimum depending initial layout 
addition forces indicate direction movement node magnitude large limited algorithm force converge 
amount forces limited called temperature 
determining temperature nodes iteration spring algorithm called temperature scheduling 
addition initial layout temperature scheduling determining factor graph layout ends local minimum 
graph layout significantly improve algorithm terminate 
challenges currently spring algorithms face include initial placement nodes temperature scheduling algorithm termination criterion 
addition existing graph drawing softwares include spring algorithms support features facilitate experimentation algorithms 
features include running time algorithm execution number iterations node iteration animations variety different initial graph layout algorithms 
objectives objective thesis improve existing spring algorithms areas ffl reducing chances finding graph layouts undesirable local minima 
ffl finding robust method terminating spring algorithm layout converged 
furthermore intend develop software facilitate experimentation spring algorithms 
contributions developed improved spring algorithm costspring cost function determining quality node graph layout 
node qualities temperature scheduling 
graph layout quality terminating algorithm initial layout algorithm call costchosen 
initial layout algorithm aims reducing chances finding graph layouts unwanted local minima 
furthermore implement layoutshow signed applet application graph drawing experimentation 
followings main features software ffl variety spring algorithms fr kk gem costspring 
ffl initial layout algorithms randomized insert costchosen 
ffl node iteration animations 
ffl running time number iterations spring algorithm 
ffl gml widely file format graph layout specifications 
ffl signed applet allow file local machine 
outline thesis organization thesis follows chapter review background related area force directed graph embedding algorithms 
chapter describes approach improve existing spring algorithms 
chapter covers design implementation layoutshow 
chapter presents experimental results comparing running time quality algorithm existing spring algorithms 
lastly chapter presents thesis possible avenues 
chapter background chapter related thesis area methods graph layout java graph drawing software 
bibliography done field computer automated graph drawing 
start stating approach force directed method graph drawing describe types force directed methods spring electrical force barycenter methods 
continue introducing various force directed algorithms graph drawing 
results experimental comparison algorithms 
review existing java environments graph drawing 
force directed methods methods aim drawing general undirected graphs focus thesis 
furthermore variations method developed drawing directed hierarchical graphs 
generally force directed methods view graph system particles forces acting 
graph node considered particle goal position graph nodes node locally minimal energy 
words force directed methods seek equilibrium state force system sum forces acting particle zero 
defined force directed methods consist parts model algorithm 
model force system defined vertices edges equilibrium state system pleasing drawing 
hand algorithm technique finding equilibrium state nodes edges graph 
springs electrical forces simplest popular force directed methods uses spring electrical forces 
algorithms form forces called spring algorithms 
edges graph viewed springs connect nodes considered charged particles 
method force node defined follows uv gamma uv gamma uv gamma uv uv distance attractive factor repulsive factor hooke law electrical repulsion respectively defined follows uv uv uv gamma uv uv uv uv uv natural length spring uv stiffness spring uv indicates strength repulsive force spring force forces distance vertices equal uv normally equal constant value edges 
addition repulsive electrical forces prevent nodes graph placed close 
see section various spring algorithms attractive repulsive factors introduced section 
barycenter method earlier works area graph drawing introduced tutte 
method similar method described section electrical charge stiffness spring set length spring set zero 
force acting vertex gamma equation results undesirable equilibrium state nodes located origin 
solve set vertices fixed corners convex polygon 
rest vertices free originally located origin 
algorithm iterates iteration new location computed free vertex equation current positions remaining nodes converge free vertices 
various force directed algorithms eades algorithm eades introduced spring algorithm graph drawing electrical forces 
scheme logarithmic strength springs place hooke law inverse square law repulsive forces 
addition non adjacent vertices repel 
eades algorithm stated 
algorithm spring graph place vertices random locations repeat times calculate force vertex move vertex force vertex repeat draw graph spring 
eades algorithm basis subsequent spring algorithms 
major drawbacks algorithm high cost computing attractive repulsive factors absence repulsive forces adjacent nodes result concentration number adjacent nodes small area 
addition algorithm uses simple methods stopping choosing amount displacement nodes non adaptable graph node qualities 
spring algorithms came aimed making improvements areas 
algorithms described 
note thesis iteration repeat loop eades algorithm referred global iteration 
outer loop exists improved algorithms 
fr fruchterman reingold extended eades introducing new attractive repulsive factors temperature cooling schedule algorithm known fr 
algorithm force acting vertex computed stated equation 
fr uses attractive repulsive factors show produce results similar eades layouts efficient compute uv uv uv gammak uv iteration fr forces nodes computed nodes moved 
algorithm limits maximum displacement temperature computed cooling function nodes iteration 
suggest temperature starts initial value decreases inverse linear fashion 
note better cooling schedule dramatically change resulting layouts reduce number iterations required find layout 
speed algorithm call grid variant algorithm 
variant drawing area divided grids 
attractive forces computed usual vertex repulsive force computed vertex nodes close cells grid 
method popular mainly due dependency distribution nodes grid overhead placing nodes grid cells iteration compromised layout quality produces cases 
fr terminates maximum number iterations exhausted 
different types graphs require different number iterations layouts converge method stopping may terminate early late depending graph 
graphlet version fr terminates maximum force magnitude nodes falls maximum number iterations reached 
experiment section shows method stopping works small graphs nodes 
addition fr drawing frame limits nodes displacements 
algorithms including graphlet version fr add extra restriction displacement nodes rescaling draw final layout frame fixed size 
gem gem short form graph embedder spring algorithm eades algorithm uses history node movement choose temperature current displacement node 
fr algorithm moves nodes time iteration 
outline algorithm algorithm gem graph tmin round rmax find random permutation vertices vertex random permutation impulse attraction center gravity random disturbance repulsive forces attractive forces update position limited individual temperature update temperature gem tmin rmax constants indicate minimum global temperature maximum number rounds respectively 
defined average local temperatures vertices 
local temperature vertex computed old local temperature likelihood vertex oscillating rotating 
gem determines node oscillating rotating moving final destination directions movements previous displacements node 
case oscillation rotation local temperature node decreased raised 
experiments section show test graphs gem fails rmax reached 
addition starting random graph layouts gem finds drawings edge crossings large planar graphs 
note gem introduces initial layout algorithm named insert inserts vertices initial round 
layouts types graphs binary trees grids generated gem may benefit initial layout produced insert algorithm 
modeling graph theoretic distances kk kamada kawai introduced algorithm graph euclidean graph theoretic distances pairs vertices referred kk algorithm 
algorithm graph nodes considered particles connected springs ideal lengths equal graph theoretic distances point particles multiplied desirable length edge 
goal kk algorithm find balanced spring system 
energy kk spring system defined gamma gamma corresponds desirable distance strength spring vertices 
kk computes local minimum solves minimization problem newton raphson method 
graph theoretic distance nodes graph length shortest path nodes graph 
result define energy node partial derivatives equation outline algorithm algorithm kk graph max ei epsilon vm particle satisfying em max ei em epsilon compute displacement vm solving system partial differential equations displace vm kk number nodes 
major drawback method high computational cost due solving system partial differential equations inner loop algorithm 
graphlet version kk uses maximum theta iterations inner loop 
modification speeds algorithm generates quality layouts small graphs large graphs generates layout planar graphs edge crossings 
different algorithms graph drawing 
section outline approaches 
practical approach drawing undirected graphs algorithm introduced incremental algorithm referred tu 
algorithm stages 
stage permutation nodes graph constructed minimal height breadth spanning tree graph 
second stage node order computed stage area surrounding positioned neighbors node sampled examined approximate best position node placed position 
cost function determine best location dh explained section 
second stage local optimization procedure improves vertex position recursively performs process placed adjacent nodes vertex 
stage algorithm performs local optimization process node fine tuning 
algorithm generates layouts different fr kk gem 
specifically capture graph symmetries 
addition algorithm takes quality parameter large value results better quality graph layouts 
reported himsolt quality parameter estimated exponential effect running time algorithm 
efficient computation forces optimization process second graph drawing algorithm produced fr algorithm 
algorithm differs fr computation repulsive forces optimization process stopping algorithm 
similar grid variant fr algorithm approximates computation repulsive forces node 
done barnes hut tree code 
fr optimization process uses force laws effect compute negative gradient implicit objective function 
algorithm uses conjugate gradient method non quadratic objective function approximate line search see optimization techniques 
addition algorithm uses average square displacement distances nodes stopping algorithm 
terminates value 
note details particularly explaining optimization process algorithm source code available public java applet internet address article currently 
result difficult compare performance quality layouts algorithm algorithms 
time measurements square grids complete binary trees hypercubes show optimization process speeds algorithm comparison fr 
hand overhead barnes hut approximation repulsive forces slows algorithm graphs approximately nodes speeds algorithm graphs larger 
addition reports method stopping algorithm conservative cases algorithm stopped sooner 
simulated annealing dh davidson harel simulated annealing approach graph drawing 
algorithm referred dh 
context simulated annealing graph drawing configuration assignment unique grid points nodes graph 
algorithm tries find optimal configuration cost function 
dh rule generating new configuration moving node randomly picked point circle vertex radius new configuration better cost function described 
radius initially large decreases round algorithm 
decreasing radius decreasing neighborhood simulated annealing terms algorithm different simulated annealing process constant rule generating new configurations 
layout graph cost function dh defined weight uv uv distance prevent nodes close 
distances right left top bottom borders drawing respectively 
prevent nodes positioning close 
uv component avoid edges long 
number edge crossings minimal distance vertex edge penalizes node edges close 
weights components cost function equation adjusted obtain drawings different aesthetics 
instance high value results drawings crossings 
computational intensity simulated annealing approach graph drawing algorithm suitable interactive applications 
time complexity algorithms global iteration eades gem fr algorithms time complexity 
number global iterations algorithms theoretically known empirically estimated 
kk algorithm primarily required compute graph theoretic distances pairs nodes 
time needed terminate algorithm tn total number iterations inner loop theoretically known 
tu cost computing permutation nodes jv 
cost computing tu cost function node changes position number newly drawn edges 
cost computed node number sample positions proportional degree node initial placement local optimization phases 
note addition tu initial placement involves recursive optimization adjacent nodes node placement improves cost 
second algorithm introduced fr terms time complexity exception cost computing repulsive forces log iteration 
running time dh noted jv jej 
due fact algorithm jv configuration changes result node replacement cost jv 
previous experimental comparisons himsolt performed experiments gem fr kk tu dh compared execution time quality graph layouts 
section provide summary report 
note graphs experiments maximum nodes edges total 
addition modified version kk graphlet software explained section 
running time evaluation running time algorithms mentioned ffl gem kk competitive speed outperform fr tu dh 
ffl fr fast small graphs slows large graphs 
experiments show gem slower fr graphs larger 
see appendix details experiment 
quality himsolt ratio longest edge shortest edge normalized edge lengths deviation evaluation quality graph layouts generated algorithm 
summary evaluation ffl fr kk gem dh crossing optimization equation generate layouts similar appearances 
generated distorted layouts loosely connected graphs 
ffl tu layouts different 
particularly display symmetries 
performs grid graphs square triangular grids 
ffl high weights edge crossings close node edge distances dh destroy symmetries edge length uniformity node distribution layouts algorithm 
general difficult find right mix dh parameters obtain drawings 
criticism layout quality evaluation number edge crossings different graph layouts generated algorithms compared 
particularly significant layouts planar graphs 
java graph drawing tools visualizing graphs java graph drawing software available applet application 
supports algorithms kk spring algorithm walker tree algorithm algorithm drawing directed graphs 
addition supports graph editing 
applet version signed support local file addition software provides algorithms drawing variety graphs suitable experimentation different drawing algorithms 
provide running time algorithm include modules evaluating quality graph layouts different aesthetic criteria distinguish node iteration animations see remaining classes sub section section useful experimentation force directed algorithms 
addition applet loaded jar java archive file internet transaction 
slow execution applet anytime class time loaded server side 
due java security restrictions regular applet access files local disk 
reason applet allow load save operations 
restriction exists applets default java provided ways permitting applet access local disk privileges java application 
applet privileges signed applet 
brown university graph drawing server gds gds graph drawing server available applet application graph editing graph drawing format translation graph layout generation 
gds provides complete editing facilities 
software includes variety algorithms drawing general graphs orthogonal graphs directed hierarchical graphs spring algorithm 
graph drawing algorithms gds applet executed server machine 
slows running time algorithms specially large graphs 
addition gds applet signed users perform local file saving files applet returns url file contains graph layout produced server side user 
gds applet loaded jar file mentioned section slow execution applet 
furthermore gds aim providing facilities experimentation different graph drawing algorithms 
tom sawyer software tom sawyer software provides widely known commercial graph layout toolkit glt graph editor toolkit get 
released graph editor toolkit java version 
features software include ffl automatic drawing graphs 
ffl smart graph labeling 
ffl graph editing utilities 
chapter cost oriented spring layout algorithm pointed chapter existing force directed spring graph layout algorithms gem fr suffer inaccurate temperature scheduling stopping criteria 
chapter describe approach uses node layout graph layout qualities determine local temperature node detect convergence algorithm respectively 
start defining qualities explaining importance efficient functions measuring quality node graph layout different stages spring algorithm 
compare number different possible choices functions introduce call node layout cost function graph layout cost function respectively 
describe spring algorithm cost functions discuss running time algorithm 
node graph layout qualities spring algorithms section define node graph layout qualities discuss importance measuring desirability node position graph layout 
discussion spring algorithms refer algorithms family define negative gradient implicit cost function terms forces similar defined section 
gem fr examples algorithms 
node graph layout qualities 
graph drawing algorithm aims optimizing certain aesthetic criteria 
aesthetics may include minimization edge crossings preservation graph symmetries bend minimization 
result quality graph layout evaluation extent drawing meets certain aesthetic criteria 
explained chapter spring algorithms move nodes new positions minimize local energy force laws 
force laws bring adjacent nodes distance approximately equal predefined optimal edge length move non adjacent nodes distance equal optimal edge length formal definition section 
distances nodes neighbors non neighbors measuring node graph layout quality 
addition spring algorithms explicitly minimize energy magnitude force acting node implicitly increase symmetries decrease number edge crossings 
aesthetic criteria measuring graph layout quality family layout algorithms energy graph layout preservation symmetries drawing number edge crossings 
furthermore addition measuring quality graph layout evaluate layout quality node individually 
aesthetic criteria closeness neighbors non neighbors energy nodes allow evaluation individual node layout qualities 
matter fact case criteria quality graph may defined function individual node layout qualities 
instance energy graph defined average maximum energy individual nodes 
rest section explain node graph layout qualities spring algorithms discuss general form measuring 
applications measuring node graph layout quality execution spring algorithm criterion function measure quality node location kamada kawai different definition energy algorithm 
please refer section 
ffl stopping local movements node moves global iteration ffl stopping global iterations algorithm 
ffl choosing node temperature 
addition measuring quality graph layout allows automatic selection human interference layout best quality number different layouts graph 
especially useful graph layouts produced spring algorithm 
depending initial layout spring algorithm resulting layout may unwanted local minimum 
graph layout qualities compare early intermediate results executing spring algorithm number different initial layouts graph continue spring algorithm best layout selected 
approach may increase running time finding graph layout reduce chance arriving undesirable local minimum 
emphasize methods seeking evaluating single node quality entire drawing quality efficient 
due fact improving algorithms gem fr running time iteration 
spring algorithms node repositioned global iteration 
forces node computed node moved location stabilizes stopping criteria 
cost function measuring node graph layout qualities refer cost value represents quality node graph layout 
cost function computes cost value 
cost function evaluates quality value node layout graph general form corresponding function quality layout takes form holds adjacency information graph respectively vectors coordinates graph vertices layout numbers represent quality values node layout vertex graph layout respectively 
mentioned section may defined function node layout qualities 
graph values node graph layout generated spring algorithm known prior execution spring algorithm 
approach differences values equations obtained successive iterations words detect convergence applications measuring node graph layout quality mentioned section 
elaborate section 
different cost functions form equations defined davidson harel kamada kawai 
evaluate section 
choice cost function section evaluating number different choices cost functions 
goal find functions fulfill requirements mentioned section 
advantages disadvantages choice discussed functions find suited purpose introduced section 
terms introduced section choice evaluating 
choice function definition terms 
magnitude force cost section look possibility representing quality value vertex layout graph magnitude attractive repulsive forces acting vertex 
quality value layout function quality values graph vertices 
forces vertex defined uv gamma uv gamma uv gamma uv uv distance optimal edge length 
quality vertex jf quality layout vertices defined jf jf jf function mean maximum force magnitudes 
advantages magnitude force acting vertex natural choice measuring quality force computed node iteration force directed spring algorithm extra computation required 
starting initial random graph layout vertex layout initially large attractive repulsive forces balanced value decreases 
shows values function computes maximum force magnitudes vertices different graphs iterations implementation fr spring algorithm detecting convergence force magnitude vertex applications node quality measurement mentioned section 
see rest section magnitudes forces measurement quality number major drawbacks 
graph layouts generated matlab graphlet implementation fr spring algorithm translated matlab script 
default configurations graphlet version fr number iterations fixed 
binary tree nodes local minimum see maximum force magnitudes nodes converges small value near 
iteration grid wheel grid bt iterations fr 
maximum force magnitudes 
disadvantages observation force magnitudes vertices graph layout converge late spring algorithm 
words graph layout may improve significantly force magnitudes vertices decrease large amounts 
drawback introduced section stopping spring algorithm 
disadvantage cost function equation measuring quality graph layout argument function dependent scaling layout 
value vertex dependent scaling means layout graph scaled version layout graph force magnitudes corresponding vertices may different 
scale layout factor ff obtain second layout force vertex ff uv gamma uv gamma ff uv gamma uv uv distance drawback illustrated layouts 
obvious layout better layout 
drawback value scaled version graph layout may larger value graph layout 
case graph layout quality criterion number edge crossings automatically choose better graph layout layouts 
disadvantage cost function equation inability detect nodes graph undesirable local minimum graph layout 
presents value vertex graph layouts theta point operator grid note forces rounded nearest integer values 
graph layout left crossing free drawing grid right drawing graph undesirable local minimum 
shows small difference magnitude forces drawings 
table presents minimum maximum mean force magnitudes vertices graph layouts 
clearly differences negligible 
graph layout undesirable local minimum lower minimum maximum force magnitudes 
crossing free layout layout crossings graph layouts theta grid magnitude forces vertices displayed 
phenomena due fact optimization process force directed spring algorithms seeks low energy drawing minimum force magnitudes vertices 
cases required move worse drawing larger forces vertices finding better drawing 
process called hill climbing simulated annealing 
spring algorithm finds undesirable local minimum forces small drawing needs go hill climbing process 
forces vertices small vertices won ability large movements come unwanted local minimum 
second graph layout magnitudes layout layout maximum minimum mean table maximum minimum average force magnitude graph layouts 
result 
drawback cost function equation automatically choosing best layout number layouts graph 
applications measuring graph layout quality mentioned section 
kamada kawai energy cost choice measuring layout qualities node graph kamada kawai energy function 
consider nodes graph particles pair particles connected spring 
actual graph theoretic distances pairs nodes re position nodes spring system balanced see section 
energy system defined equation 
equation finding positions vertices goal kk algorithm 
intend kamada kawai energy formula defining cost functions seeking measure node graph layout qualities 
consider equation indicate quality layout graph equation define quality vertex uv uv gamma uv advantages advantage equation measuring quality node similar mentioned magnitude forces section 
iterations spring algorithm distances pairs nodes stabilize value vertex converge 
function suitable applications cost function node quality measurement mention section 
preprocessing phase finding uv uv computing sums equations change time complexity iteration spring algorithm 
see follows computations add substantial cost running time spring algorithm 
disadvantages disadvantage defined section case magnitude force cost equation dependent scaling graph layout drawback explained section 
second disadvantage functions equations measuring qualities node graph layout amount computation required 
computing new substantially adds running time spring algorithm empirically known jv see section 
elaborate 
start time complexity preprocessing stage compute uv uv pair nodes graph uv length shortest path multiplied constant value 
uv strength spring reverse square length shortest path multiplied constant value 
graph nodes time complexity finding shortest paths primarily 
large graphs possible reduce log log 
see additional cost computing uv uv efficient implementation log 
addition add arithmetic expression uv uv gamma uv times iteration spring algorithm times node 
saving case reusing uv originally computed obtaining attractive repulsive forces energy function kamada kawai measuring node graph layout qualities adds substantial amount computation spring algorithm change time complexity algorithm 
davidson harel cost function completeness briefly mention cost target function simulated annealing approach davidson harel graph drawing 
summarized presents general form cost function layout graph elements sum time complexities 
node distribution jv 

jv 

edge lengths jej edge lengths computed node distribution reused 

edge crossings jej 

node edge distances jv 
weight components set user 
advantage cost function equation variety graph layout elements takes consideration measuring quality 
specifically function includes different quality criteria 
see running times advantage comes high expense 
total running time finding cost graph layout cost function dh jv jv jej jv jej 
high cost computing function unattractive choice function seeking 
addition cost function equation measures graph layout quality node layout quality 
time complexities actual definitions components defined davidson harel see section 
components function computed individual node node edge distances 
important eliminated implementations cost function 
furthermore computation node edge distances costly considered function 
cost function section introduce node graph layout cost functions discuss properties 
goal find functions efficiently measure node layout cost iterations spring algorithm graph layout cost evaluate quality number layouts graph fulfill applications mentioned section 
general forces spring algorithm fr gem aim bringing adjacent vertices node close uniform distance node approximately equal predefined optimal distance move non adjacent nodes away node 
intuition spring algorithm motivation function computes defined 
furthermore define values vertices graph 
terminologies terms graph ffl set nodes adjacent ffl set nodes non adjacent terms graph layout ffl edist euclidean distance graph layout edist graph layout clear context ffl edist min edist ffl edist max edist definition vertex layout graph define edist ff edist gamma ff edist ff 
thesis chose ff give equal weight denominator components equation 
adjacent vertices graph empty reasonable define edist width layout frame edist edist choice equation implementation costspring algorithm 
graph layout obtain value gg properties regards components equation think vertex exist balls centered ffl radius edist smallest ball enclose adjacent vertices ffl second radius edist largest ball exclude non adjacent vertices ffl third radius edist largest ball exclude adjacent vertices spring algorithms aim finding graph layouts vertex edist edist edist edist layout graph generated spring algorithm results small values appendix shows graph layouts produced fr spring algorithm 
layout maximum minimum recorded 
iterations spring algorithm distances node neighbors non neighbors stabilize vertex converges 
furthermore scaling distances adjacent non adjacent nodes vertex changes factor value node remains 
convergence function introduced section layouts generated execution spring algorithm allows function applications mentioned section node quality measurement 
shows values equation graphs initial layouts algorithm environment configurations ones applied obtain data 
iteration grid wheel grid bt equation iterations fr 
binary tree nodes local minimum ql converges value greater 
pleasing drawing graph produced algorithm converges value near 
advantages convergence figures show introduced section converges earlier iterations spring algorithm introduced section 
observed quality graph layouts improve significantly converges 
advantage stopping spring algorithm 
insensitivity scaling result dependent scaling layout graph equation ratio distance sum distances layout graph dependability scaling drawback kamada kawai cost function magnitude forces cost function 
mentioned section gem algorithm explicitly tries detect nodes rotating brings temperatures indirectly algorithm 
values node rotating graph layouts 
algorithm rotating layout detect convergence cost function 
detection unwanted local minimum experiment shown equation useful distinguishing layout undesirable local minimum layouts graph see section 
shows graph layouts rounded values vertices graph layouts 
see magnitude forces values nodes surrounding twisted area graph layout layout maximum minimum mean table maximum minimum average values equation graph layouts 
layout higher rest nodes layout 
table shows maximum minimum average values vertices graph layouts 
fruchterman reingold note graph layout undesirable local minimum nodes barrier movements nodes need pass barrier achieve better layout 
adjacent nodes located opposite sides barrier 
observe usually causes maximum distance adjacent nodes located sides barrier large minimum distance non adjacent node vertices barrier vertices trying pass barrier small 
increase values nodes involved undesirable local minimum 
efficiency graph layout cost computing nodes jv 
includes cost ffl identifying neighbors non neighbors node jv 
crossing free layout layout crossings layouts theta grid equation displayed node 
ffl finding edist edist edist vertex jv 
ffl computing value vertex jv 
item mentioned computed preprocessing stage 
need value node iteration spring algorithm computation second third items repeated iteration algorithm 
cost iteration spring algorithm jv 
second item potentially costly operation 
reuse distances pairs nodes computed computation forces node second item 
adds maximum comparisons assignment attractive repulsive forces adjacent node computed adds maximum comparison assignment repulsive force non adjacent node computed 
negligible amount computation compared computation attractive repulsive force computationally acceptable 
iteration stopping algorithm need compare values nodes graph layout produced iteration corresponding values previous iteration detect convergence values graph vertices 
value computed iteration fashion explained approximation actual vertex graph layout hand iteration 
elaborate section 
approximate cost value previous subsections section suggested reuse distances computed force computations spring algorithm finding respective values vertices graph layout hand 
provides accurate value vertex time computed 
suggested values computed fashion iteration values vertices final graph layout produced iteration 
spring algorithms gem nodes moved time approximation actual graph layout depending falls order new positions nodes computed nodes jv moved includes 
spring algorithms fr nodes repositioned precisely computation forces nodes completed 
effect values obtained distances computation forces vertex iteration really accurate iteration gamma 
cost oriented spring algorithm described rest chapter move nodes time approximate reported section approximation provides acceptable result stopping spring algorithm 
costspring algorithm drawing undirected graphs section introduce cost spring algorithm call costspring 
algorithm node qualities choosing node temperatures stopping movements node repositioned iteration stopping global iterations algorithm 
recommend algorithm graphs nodes due computational intensity spring algorithms time complexity jv global iteration 
outline phases algorithm 
segment gorithm shown repeated phase 
parts code differ phases highlighted square boxes labeled accordingly phase 
functions important constants segment surrounded ellipses rectangles respectively 
default values configurable parameters algorithm appendix input algorithm adjacency information graph drawn output positions graph vertices 
attractive repulsive forces algorithm fr algorithm 
algorithm iteration compute forces nodes reposition time 
cost function node quality equation 
compute node distances pairs nodes computation attractive repulsive forces node 
random order nodes processing nodes loop 
initial layout algorithm takes input parameter indicates positions vertices initialized 
positions initialized algorithm initializes positions random locations 
algorithm uses pre assigned positions nodes 
algorithm shown produce quality graph layouts initial random layouts see section 
certain graphs grids large aspect ratio large sparse graphs binary trees circular graphs higher tendency phase cost reposition phase reposition factor diff factor diff maxdiff false cost diff abs cost cost phase phase temperature factor temperature factor compute forces cost compute forces cost node random order maxdiff max maxdiff maxdiff abs cost alpha outline costspring algorithm 
local minimum 
cases introduce new method finding initial graph layout spring algorithm values 
method execute part phase spring algorithm random initial layout graph drawn 
plus penalty edge crossing resulting layout find best graph layout continue algorithm layout 
approach finding initial graph layout costly decrease chance finding undesirable local minimum see section 
number initial graph layouts iterations obtain intermediate graph layouts crucial cost approach chance eliminating layouts 
higher numbers higher chance finding graph layout undesirable local minimum higher running time finding layout 
section conduct experiments different number initial graph layouts iterations number different graphs 
phases costspring algorithm phases 
phase allows large movements nodes move iteration needed 
second phase fine tuning resulting graph layout phase 
phase smaller movements permitted 
approach inspired observation behavior fr gem algorithms 
starting random layout graph large movements needed finding general shape choose initial random layouts iteration spring algorithm cost method theta iterations 
graph layout small movements sufficient fine tune final drawing 
fruchterman reingold acknowledged terms quenching phases respectively 
fr algorithm follow phase approach reported result experiments believed approach result better graph layouts fewer iterations 
temperature scheduling similar slightly different fruchterman reingold suggested phases 
subsection elaborate 
furthermore phase allow node repeatedly move cost difference previous position current position fall small value alpha 
motivation doing due observation starting initial random layouts vertices large energies early iterations algorithm 
resulted instance large repulsive forces pushing node far away rest adjacent vertices 
node temperatures allowing nodes take large steps node move far isolated position rest nodes 
observed early iterations allow node reposition balanced position respect nodes particularly neighbors 
experiment section shows average number iterations inner loop node global iteration phase costspring algorithm 
temperature fruchterman reingold suggested fast cooling high low phase constant low temperature phase 
temperature uniform global nodes iteration 
introduce combination global local temperature node moved 
see node temperature function variables factor function computes global temperature 
choose global temperature function maximum force magnitudes vertices iteration 
specifically body takes form return sqrt maxf maximum force magnitude vertices graph 
constant value adjustable parameters costspring algorithm 
parameter factor determined actor gamma phase possibly raise factor determined difference current cost node previous cost value 
larger difference larger factor selected 
factor value possible 
addition range factors selected phase larger ones second phase 
presents body functions diff diff diff beta diff gamma return return return return beta gamma constants adjusted different configurations algorithm 
constant parameters larger corresponding ones 
gradually decrease temperature node moving iteration phase 
stopping outer loop phase find maximum relative errors nodes previous costs current costs see 
iteration function takes maximum relative error values simply checks values fall tolerance value 
function returns true case loop terminates 
return false loop continues 
cases method terminating loop fails provide upper bounds prevent infinite loops 
originally relative error maximum node cost previous iteration maximum node cost current iteration relative error values maxdiff find current approach accurate stopping loops 
currently find largest relative difference differences current node costs ones previous iteration 
approach possible difference maximum node cost iteration previous represent maximum change cost values nodes iterations 
amount change indicates layouts graph improving algorithm 
tolerance values tol tol phases respectively maxdiff values compared affect number iterations phase execute 
smaller tolerance values larger number iterations phase 
tol tol respectively functions 
generally tol higher tol 
experiments indicate graphs different densities require different number iterations spent phase 
sparse graphs need iterations phase iterations second phase dense graphs require iterations phase iterations second phase 
algorithm preprocessing stage detects density graph chooses values tol tol density 
outline consider sparse intermediate dense graph ae density jej jv ffl sparse ae ffl intermediate ae ffl dense ae 
running time algorithm running times various parts algorithm jv running times discuss running time algorithm ffl 
ffl compute forces cost 
ffl 
time complexity 
ffl 
ffl 
time complexity 
normally small number case 
running times outer loops phase inner loop phase theoretically known 
experiment sections shows average number iterations inner loop phase node graphs experiment 
experiment time complexity components stated running time algorithm phases 
number iterations outer loop execute worst case determined 
implementation total value variables 
worst case running time algorithm 
value maximum number iterations outer loop normally reached 
experiment section shows average number iterations outer loop chapter design implementation layoutshow layoutshow signed applet application graph drawing experimentation layoutshow java multi threaded applet application experimentation different graph drawing algorithms 
supports variety spring graph drawing algorithms layouts eigenvectors 
implementation supports node iteration animations 
software provides algorithms producing non random initial layouts spring algorithms 
file gml implemented 
addition users layoutshow applet choose perform local file layoutshow signed applet 
knowledge layoutshow graph drawing software feature 
chapter discuss layoutshow features detail 
describe way different components system interact introduce individual package system elaborate functionalities classes 
list known bugs limitations 
layoutshow implemented jdk solaris sunos 
tested linux windows windows nt application applet 
source bytecode api layoutshow classes layoutshow applet currently www cs yorku ca html 
features outline layoutshow provides facilities ffl generate variety graphs complete rectangular hexagonal triangular complete binary tree random hypercube circular 
ffl draw graphs different force directed spring algorithms costspring see section gem fr kk combination eigenvectors layout costspring see section 
ffl generate initial layouts spring algorithms costchosen see section insert 
ffl randomize graph 
ffl obtain graph quality measurements number edge crossings longest edge shortest edge ratio edge length deviation cost value see section 
ffl perform iteration node animations see section 
ffl configure algorithms 
ffl label nodes 
ffl reading writing graph disk gml file format 
layoutshow applet mentioned layoutshow application applet 
running layoutshow applet classes layoutshow needs loaded internet transaction 
achieved jar java archive file 
jar file contain classes auxiliary resources applet uses 
need opening new connection new class loaded applet 
may slightly slow speed applet loaded certainly speed execution applet loaded running 
jar file compressed jar file layoutshow current size file megabytes 
due java security restrictions regular applet access files local disk reason graph drawing tool available applet allow load save operations 
restriction exists quality measurements mainly relevant layouts produced force directed spring algorithm layoutshow focuses 
discussion java security thesis refers java security model 
applets default java provided ways permitting applet access local disk privileges java application 
done signing verifying jar files 
signed jar file layoutshow providing option layoutshow applet privileges application including file particularly important traditionally graph drawing applets allow file important part graph visualization gds requires user send data files server return url file contains graph layout produced server side user 
approach slow especially graph large 
addition increasing speed processors average users currently need relying server computations computation done locally reasonably fast 
details concepts procedures signing verifying applet 
describe briefly 
electronically signing applet signing pen 
recognizes signature trust applet special privileges 
recognizing electronic signature applet called verification 
process signing applet involves signer sign jar file applet private key place corresponding public key certificate digitally signed statement trusted firms specializing digital security jar file 
done tool provided jdk 
user side public key data may produced tool saved file user needs visualize data 
certificate obtained user signer file normally called obj 
having file user indicates java enabled web browser trusts certain identity web browser loads applet jar file signed identity knows privileges application applet 
design system section elaborate way various components layoutshow software interact support computations finding new node positions drawing graph animation 
computation node positions graph computation module actual drawing screen display module main modules graph drawing software 
traditionally softwares graphlet new positions nodes computed graph re drawn 
actions happen sequential order 
multi threading capabilities java simultaneous location computations drawing 
best knowledge java graph drawing softwares see section new design way modules cooperate tools 
shows relationship computation display modules 
synchronized void super wait synchronized void status ready status synchronized boolean return ready super notifyall graph node positions layout information iterations synchronization object time cost crossings 
synch 
boolean ready compute node positions iteration graph synch true graph synch graph synch true write graph positions layout information back true synch synch false synch false cs cs synch directly synch graph synchronization scheme layoutshow 
threads tasks computation display managed threads share graph common data 
result segments code threads read modify graph considered critical sections executed simultaneously furthermore order sections executed crucial 
critical sections critical sections 
writing back new node positions 

reading new positions 
clear item executed item synchronization required manage 
synchronization synchronization critical sections managed wait notify mechanisms java synchronization object synch see 
see loops infinitely iteration synch object indicates graph ready drawn waits synch object hand writing node positions note simultaneous execution threads mean threads run multiple processors 
refer processor sharing multiple threads pre emption 
object waits object object calls wait function object call notify notifyall resume calls synch true effect calls notifyall function synch 
resumes start generating image 
point continue computing node positions iteration 
write new positions back graph called synch false 
called function wait synch 
call reads graph generates image actual drawing image occurs call function 
result code segments labeled cs critical section executed simultaneously threads 
node positions computed image drawn 
note methods synch object synchronized thread time may exist object 
animation option node positions written back algorithm 
case animation iteration node animations refer section node positions written back global iteration image redrawn 
case node animation position node moved written back image redrawn 
choice animation computation node position generation drawing graph occur concurrently resulting smoother animation 
note communication computation drawing modules way 
precisely computation module provides drawing modules new node positions information passed computation module drawing module 
remarks drawing canvas layoutshow running 
new generated time graph drawing algorithm instructed gui execute find node positions graph 
synch object unique unchanged layoutshow running 
due fact graph may null point drawn direct access synch object 
synch graph 
graph handle synch assigned generation 
layout algorithms directly communicate classes gui package 
algorithms receive graph boolean flag indicating animation required find node positions 
way communication drawing module gui writing back node positions information time graph synchronization 
type design allows module drawing module place gui 
example module write node positions algorithm disk drive 
packages section examine packages layoutshow 
list classes package visibility modifiers review important features package contributes tool 
shows relationship packages 
see package packages gui package 
edu yorku layoutshow gui edu yorku layoutshow util edu yorku layoutshow edu yorku layoutshow usage package packages layoutshow 
instance arrow gui package util package indicates gui classes util 
visibility modifiers keywords applied class indicate class visible 
public class visible class protected class visible subclasses classes package 
class modifier public public public public public public public public table classes package visibility modifiers 
graph structures edu yorku layoutshow package provides data structures required hold adjacency information graph layout information 
table shows classes package 
graph class main components graph drawing system 
class superclass graph class layoutshow system 
supports methods build graph obtain information graph including adding edges vertices returning enumeration edges vertices obtaining vertex number 
class chosen class support different implementations graph class layoutshow 
useful expanding system 
instance current implementation layoutshow efficient new drawing algorithm new suitable class may extend 
long functionality new class conforms specifications functions current classes fine new class 
case reflection java minimal code modification 
reflection allows creating instance class name known runtime 
current implementation string variable holds name class currently edu yorku layoutshow 
instance class created string reflection api java 
new class place value string change required 
object explained section variable name synch 
implements 
class classes 
shows structure relationship vertex edge classes small directed graph nodes 
vector holds vertices graph 
fast look vertex hash table map id vertex index vector 
attribute indicates graph directed 
graph directed edge considered directed 
data structure vertex 
includes layout adjacency information vertex 
layout information includes coordinates graph id id id source target target similar structure vertex similar structure vertex directed true directed true directed true directed false vertices edges type graph type internal structure object 
label shape width height color 
adjacency information includes list edges going node list edges entering node 
undirected edge appears lists 
experiment generic collection library java implemented dlist class doubly linked list class 
holds layout adjacency information edge 
currently color layout information contains 
addition source target attribute indicates edge directed information edge 
case undirected edge terms source target meaningful variables arbitrarily assigned point vertices edge 
layout algorithms edu yorku layoutshow section review package contains algorithms layout graphs 
table presents classes package 
class provides public interface package 
class consists static data members methods 
data members configurable attributes algorithms package maximum number iterations 
static methods run certain algorithm 
take general form class modifier public package package package kk package package package package package package package package package package public public table classes package visibility modifiers 
public static thread algorithm graph boolean animation boolean int initialization algorithm layout algorithm gem 
animation node animation initialization parameters applicable algorithm 
instance meaningful context fr algorithm nodes repositioned 
parameter static method runs fr algorithm 
body static methods instance appropriate algorithm created method called 
method starts thread carries execution algorithm 
thread returned user package case termination suspension resumption thread required 
exceptions 
methods return thread 
case thread calls method computes graph quality values 
acceptable computation quality values fast 
method spawns number threads creating instances responsible finding layout graph starting different initial random layout 
calling thread method waits threads join returns index resulting layout smallest cost value 
result calling thread method thread thread handles gui events blocked method returns 
kk superclass spring algorithms package 
class contains number common attributes methods spring algorithms 
classes implement various spring algorithms layoutshow ffl implements costspring spring algorithm introduced thesis see section 
ffl implements gem algorithm 
ffl kk implements kk algorithm 
ffl implements graphlet version fr algorithm java 
instance classes spawns thread carries computations 
classes create internal data structures graph vertices 
reasons implementing internal data structures described section 
addition algorithm iteration algorithm animation requested coordinates node information iteration count time written back global graph see section 
introduce alternative graph drawing approach spring algorithms implemented eigenvector layout algorithm 
details method graph layout 
class uses science mathematics api java find eigenvectors laplacian matrix graph 
cases method graph drawing finds layouts overlapping nodes 
class allows combination eigenvectors layout spring algorithm 
means user class may choose apply spring algorithm case costspring resulting layout eigenvectors algorithm layout overlapping nodes 
class provides methods find quality values graph ffl number edge crossings ffl longest edge shortest edge ratio ffl edge length deviation ffl cost value see section 
addition class provides method finds quality values writes back graph gui package 
quality values particularly meaningful layouts generated family spring algorithms 
package implemented local graph vertex structures different spring algorithms 
reasons implementing 
spring layout algorithms requires unique attributes vertex 
instance costspring stores current previous cost values node gem vertex information mass impulse temperature direction 
secondly importantly design implementation layoutshow tried keep efficiency algorithms independent implementation global graph structure 
means case changing implementation required new efficiently currently existing spring algorithms 
due fact global graph structure copied local efficient spring algorithms 
super classes local graph vertex classes respectively 
class data members global parent graph array objects 
method public void writeback layout boolean int node method writeback writes back node positions layout information global graph 
local vertex subclass holds indices adjacent non adjacent vertices node array objects object 
kk uses 
utility edu yorku layoutshow util util package small package consisting classes shown table 
classes support graph input output files graph generation 
class modifier gml public public table classes util package visibility modifiers 
note methods classes static 
briefly describe classes 
gml class reads writes graph file gml file format 
gml class provides static methods public static read fis string public static void write pw read inputs graph file associated fis graph type returns graph 
parameter indicates exact type global graph currently see section 
string reflection api java create instance class indicated 
similarly write method writes graph file associated pw 
currently read function input attributes node id label coordinates width height color type 
types supported oval rectangle 
edge method input source target color directed 
node id edge source target ids rest attributes optional 
default values attributes user specify values 
write method writes non optional attributes nodes edges mentioned file optional values default values 
class contains number static methods form public static string 
indicates type graph generated instance complete graph 
exact type global graph currently see section 
place argument may differ graph type 
instance number nodes complete graph number rows columns rectangular grid 
method returns graph generated 
note coordinates vertices graph generated method initialized 
list graph types generated methods class ffl complete graph 
ffl triangular grid 
ffl point operator grid 
class modifier layoutshow public package menus package package package package package package package package package table classes gui package visibility modifiers 
ffl hexagonal grid 
ffl complete binary tree 
ffl circular graph 
ffl random graph 
ffl hypercube 
graphical user interface edu yorku layoutshow gui section provide overview gui package layoutshow 
table lists classes package 
layoutshow layoutshow class starts layoutshow applet application 
class run application open main window layoutshow 
case applet class creates button pressed layoutshow window open 
extends awt frame major components menu object object awt panel added awt object 
shows snapshot instance middle panel single canvas 
class extends awt panel meant hold number buttons needed frequently 
currently panel holds button shuffle graph suspend resume buttons manipulate thread executing algorithm 
class extends awt panel awt objects show time algorithm takes find current layout number iterations 
middle panel manager allows multiple component objects overlap 
middle panel overlapping components default canvas see panel canvas objects laid columns rows support simultaneous execution spring algorithms different initial random layouts graph snapshot layoutshow main window 
costchosen initial layout see section 
user choose number initial layouts maximum number initial random layouts 
algorithms initial layouts terminate graph layout quality value resulting layouts appear top canvas lowest flashing red see section quality value formula 
delay resulting layout lowest quality value appear single canvas 
snapshot multiple canvas panel shown 
canvas middle panel draws image double buffering java awt 
results elimination partial screen updates 
menus menu class extends awt menubar see class menus file generate layout options 
list items menus ffl file new open save print close quit 
ffl generate complete graph rectangular grid hexagonal grid triangular grid tree random hypercube circle 
ffl layout randomize quality generate initial layout costspring fr gem kk 
generate initial layout insert costchosen 
ffl options animation configuration labeling 
configuration insert cost chosen costspring fr gem kk 
extends awt file 
instance class associated graph single canvas 
class manages clean snapshot layoutshow main window multiple canvas panel 
dirty state graph actions need taken new open save menu items invoked 
remaining classes remaining classes 
exception extends awt frame classes extend awt dialog 
brief description classes ffl inputs information needed graph generation 
example complete graph window input number nodes 
ffl inputs configurable attributes costspring algorithm 
ffl displays error message 
ffl allows user choose animation iteration animation node animation 
explain 
ffl displays quality values layout see section 
spring algorithms find forces acting node reposition node 
case possible update layout node repositioned node animation nodes repositioned iteration animation 
instance gives user opportunity choose animation types animation 
spring algorithms fr moves nodes iteration animation applicable 
bugs limitations number known bugs limitations current implementation layoutshow ffl configuration windows configuring insert fr gem kk implemented 
currently default configurations algorithms 
ffl simple approach labeling results overlapping labels cases 
ffl classes support directed graphs drawing directed edges implemented layoutshow 
ffl currently netscape internet explorer commonly internet browsers support java signed applets java plug installed 
layoutshow applet signed jdk tested java plug 
sun promised final version java plug support applets signed jdk tested signed applet java plug 
ffl animation layoutshow applet running default java virtual machine netscape browser hangs 
recommend java plug 
chapter experimental results outline experiments experiments divided categories measuring efficiency costspring algorithm evaluating quality resulting layouts 
compare running time layout qualities costspring gem fr algorithms 
himsolt studies reported family force directed algorithms fr fast small graphs nodes edges gem modified version kk competitive speed outperform small large graphs kk comparison original implementation kk inefficient due large amount computation requires relocating node modified version algorithm himsolt studies produces drawing planar graphs edge crossings 
confirm himsolt results gem generally faster fr graphs nodes edges 
largest graph himsolt total nodes edges 
experiments confirm results provided indicate gem faster fr graphs nodes 
see appendix details experiment shows discrepancy 
table shows test suite graphs experiments 
test suite test gem algorithm addition graphs 
avoid bias experiments average results runs algorithm reported common initial random layouts graph experimenting algorithms noted 
section evaluate running time number edge crossings combination eigenvector costspring algorithm implemented layoutshow 
section results experiment evaluates effectiveness cost chosen initial layout see reducing chance local minimum 
conclude chapter evaluation costspring gem fr terms running time layout quality experiments chapter 
configuration hardware configuration experiments noted performed sun ultrasparc iii workstation mhz processor megabytes ram 
name jv jej sparse binary tree path cycle star binary tree path cycle binary tree binary tree path binary tree cycle path binary tree normal wheel theta square grid hypercube dodecahedron triangular grid hypercube theta square grid triangular grid hexagonal grid theta square grid theta square grid triangular grid triangular grid hexagonal grid theta square grid dense hypercube hypercube table test suite different graphs 
software configuration operating system experiments solaris sunos 
application version layoutshow jdk 
gem fr implementations layoutshow graphlet ported java 
addition default configurations algorithms graphlet experiments 
refer appendix configurations default configuration costspring experiments 
efficiency costspring algorithm section start measuring fast costspring algorithm finds layout converges compared gem fr algorithms 
provide results experiment measures average number sub iterations node phase costspring algorithm 
continue presenting results experiment evaluates effectiveness method stopping costspring algorithm 
provide data show performance costspring gem fr test suite graphs 
convergence section run costspring gem fr test graphs animation graph record iteration count graph layout significantly improved 
graph algorithm figures show number iterations layout 
allowed gem fr run iterations higher default maximum iteration count gem 
emphasize graphs improving iterations 
cases report convergence iteration 
figures see costspring outperforms fr cases 
graphs nodes graphs costspring gem find layout approximately number iterations 
graphs nodes costspring finds layout earlier gem exception graph 
moving node iteration running time inner loop phase costspring algorithm see section theoretically known 
conducted experiment section find average number iterations loop node global iteration phase costspring algorithm 
find average ag node graph test suite formula ag inner iterations phase jv theta global iterations phase inner iterations phase total number iterations inner loop phase global iterations phase total number iterations outer phase 
table shows value ag graphs test suite 
see value ag graphs hypercubes 
observed hypercubes converge phase costspring number iterations costspring gem fr converge sparse graphs 
number iterations costspring gem fr converge normal graphs 
number iterations costspring gem fr converge dense graphs 
algorithm 
results larger number movements node iteration phase algorithm 
stopping challenges current spring algorithms find effective method terminate algorithm layout 
section conduct experiment show effectiveness method stopping costspring algorithm see section 
achieve run costspring algorithm test suite graphs graph comparison iteration count layout converges data section iteration count algorithm terminates 
naturally stopping method effective values close layout converge algorithm terminates 
figures demonstrate result experiment 
figures show acceptable results exception large graphs 
cases oscillation occurs 
detection oscillation improve stopping method 
table shows stopping method graphlet version gem algorithm see section graphs test suite 
note maximum number iterations implementation gem theta jv stopping method graphlet version fr algorithm see section worked cases cases graphs nodes 
note maximum number iterations implementation name ag binary tree path cycle star binary tree path cycle binary tree binary tree path binary tree cycle path binary tree wheel theta square grid hypercube dodecahedron triangular grid hypercube theta square grid triangular grid hexagonal grid theta square grid theta square grid triangular grid triangular grid hexagonal grid theta square grid hypercube hypercube table average number sub iterations node phase costspring 
fr 
performance table presents execution time costspring gem fr seconds number iterations algorithm set graphs test suite 
figures represents time measurements table 
note default configuration algorithm experiment see appendix 
costspring shows better running time performance gem fr test graphs exception graphs 
case graphs mentioned section stopping method shows weakness detecting oscillation execution time costspring graphs improve weakness resolved 
addition graph see iterations gem insufficient layout converge 
quality layouts costspring algorithm section examine quality layouts costspring algorithm compare layout qualities gem fr algorithms 
quality measurement criteria include conventional ones number edge crossings edge length deviations ratio longest edge shortest edge cost value graph layout see section 
appendix contains iteration counts costspring refer number global iterations see section 
number iterations costspring convergence stopping sparse graphs 
number iterations costspring convergence stopping normal graphs 
number iterations costspring convergence stopping dense graphs 
costspring gem fr name iter time iter time iter time binary tree path cycle star binary tree path cycle binary tree binary tree path binary tree cycle path binary tree wheel theta square grid hypercube dodecahedron triangular grid hypercube theta square grid triangular grid hexagonal grid theta square grid theta square grid triangular grid triangular grid hexagonal grid theta square grid hypercube hypercube table running times iteration counts costspring gem fr 
running times costspring gem fr sparse graphs 
running times costspring gem fr normal graphs 
running times costspring gem fr dense graphs 
sample resulting layouts costspring algorithm graphs test suite 
edge crossings table shows number edge crossings resulting layouts graphs test suite produced costspring gem fr algorithms 
asterisk side graph name indicates graph planar drawn edge crossings 
see larger graphs gem fr produce edge crossings layouts planar graphs 
uniformity edge lengths goals spring graph drawing algorithms produce layouts uniform edge lengths 
section compare uniformity edge lengths layouts costspring algorithm gem fr 
ratio longest edge shortest edge standard deviation edge lengths measure uniformity edge lengths layout 
avoid bias compute normalized deviation edge lengths 
figures show results measurements 
see figures algorithms produce layouts approximately degree uniformity edge lengths 
cases gem layouts smaller edge length differences 
due central gravity force randomized factor added node position displacement gem 
costspring gem fr name crossings crossings crossings binary tree path cycle star binary tree path cycle binary tree binary tree path binary tree cycle path binary tree wheel theta square grid hypercube dodecahedron triangular grid hypercube theta square grid triangular grid hexagonal grid theta square grid theta square grid triangular grid triangular grid hexagonal grid theta square grid hypercube hypercube table number crossings layouts costspring gem fr 
side graph name indicates graph planar 
longest edge shortest edge ratios sparse graphs 
longest edge shortest edge ratios normal graphs 
longest edge shortest edge ratios dense graphs 
comparison edge length deviations sparse graphs 
comparison edge length deviations normal graphs 
comparison edge length deviations dense graphs 
cost value section comparison layout cost values layouts graphs test suite produced costspring gem fr 
figures show result experiment 
result indicates costspring layouts approximately cost values gem fr nonplanar graphs planar graphs algorithms produce layouts approximately number edge crossings 
cost values layouts planar graphs produced gem fr edge crossings higher costspring fewer edge crossings 
graph drawing eigenvectors provide non spring option graph drawing implemented eigenvector graph drawing algorithm 
section illustrate algorithm number edge crossings resulting layouts test suite graphs 
noted cases algorithm produces graph layouts overlapping nodes 
cases run costspring algorithm graph layouts overlapping nodes 
table show number edge crossings resulting layout graph test suite 
table graphs eigenvector algorithm generates layouts overlapping node positions indicated asterisk names 
see table eigenvector algorithm generates layouts edge crossings running time generally lower spring algorithms comparison graph layout cost values sparse graphs 
comparison graph layout cost values normal graphs 
comparison graph layout cost values dense graphs 
name time crossings binary tree path cycle star binary tree path cycle binary tree binary tree path binary tree cycle path binary tree wheel theta square grid hypercube dodecahedron triangular grid hypercube theta square grid triangular grid hexagonal grid theta square grid theta square grid triangular grid triangular grid hexagonal grid theta square grid hypercube hypercube table running time number edge crossings algorithm 
asterisk graph name indicates eigenvector algorithm generated layout overlapping nodes graph 
demonstrated table 
major drawback approach overlapping nodes resulting graph layouts 
finding layout unwanted local minimum mentioned section layouts graphs narrow grids binary trees produced spring algorithms tendency local minima 
costchosen initial graph layout algorithm described section reduce chance finding graphs layouts unwanted local minima 
experiment costchosen algorithm test algorithm graphs layouts produced spring algorithms high tendency local minima theta square grid theta square grid complete binary tree nodes 
ran costspring algorithm different random initial graph layouts graphs 
ratio number resulting layouts theta grid local minima 
number theta grid binary tree nodes respectively 
show effectiveness costchosen algorithm tested algorithm graphs different number initial random graph layouts iteration counts 
case initial layout produced costchosen algorithm ran costspring algorithm initial layout recorded resulting layout unwanted local minimum 
combination initial theta grid number initial layouts iterations success sec success sec success sec jv table success ratio running time costchosen algorithm square grid 
theta grid number initial layouts iterations success sec success sec success sec success sec jv jv table success ratio running time costchosen algorithm square grid 
random layout count iteration count ran costchosen algorithm times reported ratio costchosen initial layouts local minima 
show running time costchosen algorithm test run 
tables show results experiment 
see tables right number iteration counts initial random layouts cases costchosen eliminated local complete binary ree number initial layouts iterations success sec success sec success sec jv jv table success ratio running time costchosen algorithm complete binary tree nodes 
minimum layouts graphs runs 
problem thesis automatic determination call right number iteration counts initial random layout costchosen algorithm graph 
adjacency information graph method determine costchosen initial layout needed graph suitable number iteration counts number initial layouts costchosen algorithm graph 
experiments discovered ffl dense graphs don require costchosen initial layout 
ffl sparse graphs binary trees local minima candidates costchosen initial layout 
ffl graphs normal densities tested narrow grids theta theta grids show benefit costchosen initial graph layout algorithm 
summary chapter results number experiments evaluated running time graph layout quality costspring algorithm performance eigenvector graph drawing algorithm effectiveness costchosen initial graph layout algorithm 
see section definition dense normal sparse graphs 
costspring showed converges faster gem fr stopping method effective exception graphs oscillation occurs 
starting initial random graph layouts costspring generates layouts edge crossings case planar graphs 
number edge crossings layouts planar graphs produced costspring noticeably smaller generated gem fr 
edge length uniformity layouts algorithm similar layouts fr algorithm 
graph layouts produced gem show slightly better edge length uniformity costspring fr due gem central gravity force randomized factor added node position displacement 
eigenvector graph drawing algorithm faster spring algorithms major drawback overlapping nodes occur layouts graphs generated algorithm 
experiments costchosen initial graph layout algorithm show method reduce eliminate chance finding graph layout local minimum 
costchosen degree success graph dependent number initial random layouts iteration counts 
method automatically finds right number initial random layouts iteration counts costchosen algorithm currently open problem 
chapter contributions thesis introduce node layout graph layout cost function functions improve running time quality layouts spring algorithms 
specifically differences cost values individual nodes successive iterations spring algorithm costspring determine local temperature individual nodes 
divide algorithm phases 
phase allow large node displacement second phase fine tune layout 
terminate algorithm graph layout cost values determine convergence algorithm 
furthermore graph layout cost values select layout best quality number layouts graph produced spring algorithm starting different initial random layouts 
layout method fed spring algorithm initial layout 
approach call costchosen initial layout aims reducing chance finding layouts undesirable local minima 
addition developed layoutshow software 
software implement improved spring algorithm cost chosen initial layout algorithm 
variety spring algorithms initial layout algorithms eigenvector algorithm implemented layoutshow 
recommend costspring algorithm embedding graphs nodes 
experiments show spring algorithm generates layouts considerably fewer edge crossings planar graphs shorter execution times gem fr spring algorithms 
addition costchosen initial layout effective method time primary factor 
method eliminate significantly reduce chance finding layouts local minima computationally intensive 
addition layoutshow flexible software environment generating graphs spring algorithms eigenvector algorithm experimentation algorithms 
applet version software allows local file user data generated application gml file format user layoutshow applet layout graph save result local disk 
eliminates need loading application version layoutshow 
list avenues thesis ffl detecting oscillation costspring algorithm 
improve accuracy stopping method algorithm graphs binary trees nodes 
ffl adding efficient computation repulsive forces costspring algorithm improve running time 
ffl computing accurate cost value graph layout efficiently iteration costspring algorithm 
may beneficial improving accuracy method stopping algorithm 
attempting modification justify accurate values graph layout costs fact result improvement 
ffl adding gem gravity force randomized factor costspring obtaining better edge length uniformity 
ffl finding algorithm automatically determine graph benefit costchosen initial layout algorithm finding number initial layouts iteration counts needed costchosen algorithm graph 
ffl extending layoutshow support graph editing better node labeling layout scaling 
extension 
appendix examples node layout cost values demonstrates examples maximum minimum node cost values values equation layouts different graphs 
layouts generated matlab graphlet implementation fr spring algorithm translated matlab script 
default configurations graphlet version fr number iterations fixed 
min max min max min max min max min max layouts titles indicating maximum minimum values equation graph vertices 
appendix performance gem compared fr large graphs experiments show fr algorithm outperform gem algorithm graph sizes grow larger 
result contradicts gem faster fr graphs nodes 
graphlet versions algorithms implementations configurations experiments see section configurations 
addition machine experiments sparcstation 
table shows result experiment 
graph numbers table correspond ones table 
graphs ones experiments 
iteration gem fr take time gem higher overhead larger multiplication constant factor 
experiment number iterations fr fixed number iterations gem times number nodes 
small graphs number iterations fr gem fr name time time binary tree path cycle star binary tree path cycle binary tree binary tree path path binary tree wheel theta square grid hypercube dodecahedron triangular grid hypercube theta square grid triangular grid hexagonal grid triangular grid triangular grid theta square grid hypercube table running times gem fr 
larger gem total running time slower gem 
graphs grow larger number iterations gem greater algorithm slower fr iterations graph 
appendix sample layouts generated costspring appendix resulting layouts costspring algorithm graphs test suite 
table lists graphs 
initial layouts algorithm random initial layouts experiments chapter 
software hardware configurations mentioned section 
binary tree jv jej path jv jej cycle jv jej star jv jej binary tree jv jej path jv jej cycle jv jej binary tree jv jej binary tree jv jej path jv jej binary tree jv jej cycle jv jej path jv jej binary tree jv jej wheel jv jej square grid jv jej hypercube jv jej dodecahedron jv jej triangular grid jv jej hypercube jv jej square grid jv jej jv jej hexagonal grid jv jej square grid jv jej square grid jv jej triangular grid jv jej triangular grid jv jej hexagonal grid jv jej square grid jv jej complete graph jv jej complete graph jv jej complete graph jv jej hypercube jv jej hypercube jv jej appendix default values configurable parameters costspring gem fr appendix default values configurable parameters costspring gem fr 
default values experiments chapter 
note adjusting parameters algorithms change running time resulting layout 
costspring beta gamma alpha tol sparse graphs tol normal graphs tol dense graphs tol sparse graphs tol normal dense graphs jv jv gem gamma gamma gamma gamma emp gamma emp gamma emp gamma gamma gamma gamma gamma gamma gamma gravity gamma oscillation gamma rotation gamma shake gamma gravity gamma oscillation gamma rotation gamma shake gamma gravity gamma oscillation gamma rotation gamma shake actor fr frv gamma iteration bibliography matlab guide 
mathworks massachusetts 
barnes hut 
log force calculation algorithm 
nature 
di battista eades tamassia tollis 
algorithms drawing graphs annotated bibliography 
computational geometry theory applications 
battista eades tamassia tollis 
graph drawing algorithms visualization graphs 
prentice hall new jersey 

layoutshow signed applet application graph drawing experimentation 
technical report york university 
submitted graph drawing 
liu 
improvements spring graph layout algorithm 
technical report york university 
submitted graph drawing 
brandenburg himsolt rohrer 
experimental comparison force directed randomized graph drawing algorithms 
proceedings graph drawing pages 
springer verlag 
garg tamassia 
graph drawing translation service www 
proceedings graph drawing pages 
springerverlag 

java tutorial object oriented programming internet 
addison wesley massachusetts march 

java tutorial continued rest jdk 
addison wesley massachusetts december 
cormen leiserson rivest 
algorithms 
mit press cambridge massachusetts 
davidson harel 
drawing graphs nicely simulated annealing 
acm transactions graphics 
feng frick madden sander 
toolkit development software diagramming applications 
proceedings international conference software engineering knowledge engineering 
knowledge systems institute 
eades 
heuristic graph drawing 
congr 

frick ludwig 
fast adaptive layout algorithm undirected graphs 
proceedings graph drawing pages 
springerverlag 
fruchterman reingold 
graph drawing force directed placement 
software practice experience 
gill murray wright 
practical optimization 
academic press london 
mark hale 
science api java 
university durham department mathematical sciences 
currently available fourier dur ac uk dma 
himsolt 
gml portable graph file format 
technical report university passau passau germany 
currently available www fmi uni passau de graphlet gml gml tr html 
himsolt 
graphlet system 
proceedings graph drawing pages 
springer verlag 
kamada kawai 
algorithm drawing general undirected graphs 
information processing letters 
kirkpatrick gelatt vecchi 
optimization simulate annealing 
science 
lea 
concurrent programming java 
addison wesley massachusetts 

visualizing graphs java 
proceedings graph drawing pages 
springer verlag 
chapman 
graph parsing automatic graph drawing 
ieee trans 
system man cybernetics september 
moffat takaoka 
pairs shortest path algorithm expected running time log 
proc 
conf 

comp 
sci pages 
object space 
user guide 
currently available www objectspace com developers white doc user 
html 
otten van 
annealing algorithm 
kluwer academic publishers boston 
shawe taylor 
characterizing graph drawing eigenvectors 
technical report royal holloway university london 
currently available www si papers papers htm 
purchase 
aesthetic greatest effect human understanding 
proceedings graph drawing pages 
springer verlag 

new algorithm finding shortest paths graph positive arcs average time log 
siam comput 
sugiyama misue 
simple unified method drawing graphs magnetic spring algorithm 
proceedings graph drawing pages 
springer verlag 
sun microsystems 
java plug documentation 
currently available java sun com products plugin docs index html 
sun microsystems 
jdk documentation 
currently available java sun com docs index html 
sun microsystems 
java plug documentation 
currently available java sun com products plugin docs index docs html 

practical approach drawing undirected graphs 
technical report carnegie mellon university school computer science 

java interactive graph layout environment 
proceedings graph drawing pages 
springer verlag 
tutte 
convex representations graphs 
proceedings london mathematical society volume pages 
tutte 
draw graph 
proceedings london mathematical society volume pages 
walker 
node positioning algorithm general trees 
software practice experience 
weiss 
data structures algorithm analysis 
benjamin cummings publishing california 

java awt 
reilly associates california 

