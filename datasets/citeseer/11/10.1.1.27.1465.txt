architectural support quality service corba objects john zinky david bakken richard schantz bbn systems technologies moulton street cambridge mass usa corba commercial standard distributed object computing shows great promise development distributed programs 
interface description language idl enables objects developed independently underlying programming language operating system computer architecture execute 
sufficient environments programs deployed wide area distributed system encounter conditions hostile varying operating single address space single local area network 
discuss major problems observed developing deploying wide area distributed object applications middleware 
programs developed ignoring variable wide area conditions 
second application programmers try handle conditions great difficulty harsh conditions different local objects dealing 
third idl hides information tradeoffs implementation object 
fourth presently way systematically reuse current technology components deal conditions code sharing impractical 
describe architecture quality service corba objects quo developed overcome limitations integrate solution providing qos abstractions corba objects 
conditions class entities integrates knowledge time space source 
second reduces variance masking 
third exposes key design decisions object implementation 
fourth supports reuse various architectural components automatically generates 

development deployment distributed programs increasingly commonplace 
possible judicious middleware layer software communication substrate offers consistent higher level research partially funded contract 
usaf rome laboratory 
fl john wiley sons abstraction network 
increasingly important category distributed applications multimedia applications including video demand 
applications demand high performance communication substrates 
simultaneously substrates offering new features quality service qos multicast applications exploit 
example qos allows reservations guaranteed system properties operational attributes throughput delay 
qos features offered communication substrate level new middleware needed translate features form appropriate application level 
important kinds distributed applications benefit qos support middleware 
example significant new kind distributed application collaborative planning 
applications typically feature widely dispersed people collaborating example map shared workspace video conference expert systems develop course action 
applications created subcomponents integrated corba commercial middleware standard distributed object computing 
interactions subcomponents feature wider spectrum usage patterns qos requirements operate hostile varying environment typical multimedia applications running local area network lan atm switches worstcase environment assumed current qos middleware exception socket level object level required application programmers 
process developing fielding wide area applications middleware past years observed systems great difficulty adapting volatile system conditions measured observed manifestations particular system property relatively scarce resources typical wide area network wan environment 
theory practice object systems vol 
difficulty evolving time deployed different environments developed lan migrate wan fixed site mobile 
root cause problems middleware lack support handling environmental variables system properties qos 
corba interface description language idl important base developing distributed applications 
idl describes functional interface object type signature operations object embodies independently underlying programming language operating system communication medium 
specifying functional interface allows distributed applications developed rapidly transparently regard underlying services 
corba uses traditional model interface hides implementation details 
distributed applications corba idl operate acceptably long resources plentiful 
example experience shown current corba implementations objects local client address space lan client system properties environments stable understood resources plentiful 
wide area distributed environments system properties dynamic hostile change configuration configuration 
order field distributed application wide area network usage patterns qos requirements underlying resources dealt 
unfortunately features precisely hidden functional interface described idl 
distributed application perform adequately adaptive need specify details design decisions embodied implementation object 
implementation opened give access system properties corba orb objects 
enables inexpensive easy way alter implementation sacrificing software engineering gains object oriented techniques 
aspect problem current application programmers normally trained deal system properties embodied qos system properties local objects ideal 
example local objects fail independently client created practical purposes delay negligible invoking method 
simple resource model programming languages mix functionality code optimization resources 
unfortunately system properties distributed objects far ideal fail unexpectedly delay method invocation return may long high variance 
result invocations remote objects typical distributed application bracketed extra code handle errors performance conditions 
coding difficult reasons describe difficult programs different environment originally hardcoded 
worse negates value transparent interface definitions 
describes key issues addressed support qos corba object layer especially wide area mobile environments 
issues include synthesizing information system properties reducing variance exposing key design decisions affect suitability object environment providing framework support reuse code dealing system conditions handling system properties feasible 
issues mind developed architecture quality service corba objects quo support qos corba layer 
quo extends corba functional interface description language idl qos description language 
specifies application expected usage patterns qos requirements connection object 
qos usage specifications object level methods second communication level bits second 
application connections object different system properties 
allows object designer specify qos regions represent status qos agreement object connection 
application adapt changing conditions changing behavior qos regions object connections 
quo provides mechanisms measuring enforcing qos agreements dispatching handlers agreements violated 
mechanisms help distributed applications predictable adaptive guarantees provided 
technical preview distributed applications developed current technologies fragile major reasons 
developed ignoring system properties best hand coding single set assumptions system properties environment 
second programmers difficulty handling wan system properties system properties local objects 
third presently large barrier entry creating minimally adaptive system information available intended usage object qos strive deliver structure implementation 
fourth programmers create strongly adaptive systems multiple implementations dif theory practice object systems ferent tradeoffs current technology support framework reuse development multiple implementations comprehensive handling system properties feasible 
quo solves problems 
making system properties class entities integrating knowledge time space source application feasible way aware handle changes environment 

reducing variance system properties programmer deal masking 

exposing key design decisions object implementation currently hidden object help application reconfigure adaptively 

supporting reuse various quo architectural components multiple points application lifecycle 
describe distributed collaborative planning applications discuss items detail 

observations distributed collaborative planning applications distributed collaborative planning applications increasingly important category distributed applications 
example deployed bbn wans support logistics operation desert storm persian gulf presently support activities bosnia 
dcpa style systems applied domains manufacturer suppliers devising delivery schedule virtual physician specialist jointly analyzing ray video customer support link electronic relocation bureau remote video teller 
collaborative planning applications complex featuring dozens people collectively performing different tasks 
example structure different kinds interactions just participants typical collaborative planning application simplified form 
users collaborating different levels involving video conference shared workspace scheduling algorithms 
video conference exchange verbal communication including synchronizing workspace 
domain independent shared workspace allows scheduling algorithms construct domain specific graphical objects permits collaborators view manipulate annotate objects 
domain specific application specific scheduling algorithms plan scenario display results shared workspace 
level example client usage patterns adaptivity requirements 
extreme usage patterns video conference priori little variance tolerated program satisfy users expectations 
extreme involves scheduling interactions usage patterns difficult impossible obtain ahead time delivery allows significant variance 
extremes usage patterns shared workspace 
levels different abilities adapt changing resources satisfying user expectations 
audio portion video conference tolerate lower bandwidth higher variance useful users generally tolerate video portion sent lower rate dropped resources scarce 
updates shared workspace suffer additional delays adverse conditions delay gets long users consider updates program perceived usefulness sharply curtailed 
scheduling algorithms endure longer delays worst case scenarios users waiting immediate feedback 
note interactions share computational communication resources radically different usage patterns system requirements 
problems developing deploying distributed applications illustrate problems inherent current technology develop deploy distributed applications wan complex interactions 
observed number problems developing deploying collaborative planning distributed applications developing cronus scheduling algorithms scheduling algorithms map map video conf 
video conf 
shared plans shared workspace video schedule map face schedule map face audio fig 

collaborative planning usage patterns theory practice object systems distributed object middleware developed wans field applications 
distributed applications tend fragile initially perform poorly unpredictably deployed hard move development environment field environment different field environment components reused tailored particular environment 
fragility largely distributed applications designed functional interfaces ones ignore system properties throughput delay availability 
functional interface represents significant progress old tedious way moving data network half solution 
necessary half way describe manage nonfunctional aspects client object interaction 
result limitation programmers ignore system properties altogether handle ad hoc manner code fragments scattered program 
try deal system properties programmers difficulty handling system properties distributed applications face programming assuming system properties local objects 
result generally ignore system properties program invocation remote object local object address space created new keyword 
interactions local objects typically programmed implicitly assuming offer infinite bandwidth delay variance 
systemic shortcoming facets 
base values system properties local objects better remote ones 
problem overcome special cases programmers priori knowledge poor system properties code operate properties remain relatively fixed 
satellite communications example environment difficult system properties low bandwidth high delay frequent failures code programmed great difficulty 
second programmers great difficulty writing code operate wide dynamic range system properties variance 
result distributed applications evolve new environments 
example applications developed lan usually perform poorly satellite environment designed handle poor system properties encountered 
conversely application developed satellite environment perform lan contain superfluous specialized code compensate poor system properties 
compounding factor programmers encounter try current technology deal system properties information system properties available different times different locations different sources 
programmers commitments assuming system properties various times ranging design time invocation time 
knowledge system properties available different locations distributed system client object communications substrate resources connecting 
knowledge system properties produced different participants including object designer client designer operations staff user distributed application 
implicit commitments match actual environment object application perform poorly 
example object designer commits algorithm implement method object design time assumed environment object operate 
application may deployed environment algorithm implementing object method better choice 
final problem today technology way reuse code dealing system conditions 
calls functional interface tend get bracketed code handle system properties 
code impossible reuse task trying handle system properties software development meeting deadlines difficult 
summary distributed applications today able adapt changing system properties resource availability deployed evolve nearly readily easily desirable 
needed middleware support just functional interface object system properties treated class entities managed accordingly 
overview quo solution quo architecture developed solve problems complementary ways 
integrates knowledge system properties time space source 
order provide clean way reasoning system properties interactions clients objects quo employs concept connection client object encapsulation including desired usage patterns qos requirements specified form contract 
help simplify combinatorial problem dealing dimensional qos space contract quo supports class qos regions designate regions operation client object connection 
scheme region may specified predicate involving multiple system properties client adapts terms simplified regions numerous combinations system theory practice object systems properties 
help application adapt different system conditions quo supports multiple behaviors functional interface bound qos region contract best suited 
quo supports different commitment epochs explicit times different information system properties available bound 
second way quo solves problems reduction variance system properties 
quo masks variance system properties layers delegate objects client address space 
delegate layer embodies knowledge system properties participant connection client object corba object request broker orb distributed systems plumbing delivers method invocation client remote object reply back client 
system properties encapsulated class objects call system condition objects 
quo system condition objects different levels granularity allows aggregation 
example single system condition object measures throughput bound single method invocation client method invocation group objects multiple clients inbetween 
third way quo solves problems making key design decisions object explicit allowing effort expended specification tailored desired level adaptivity 
design decisions exposed adaptive resulting applications 
support spectrum adaptivity really collection sublanguages concentrate different system properties 
includes contract description language cdl describe contract client object terms usage qos structure description language sdl describes internal structure objects implementation amount resources requires resource description language rdl describes available resources status 
quo evolves anticipate need additional sublanguages handling aspects connection structure configuration management optimization 
fourth way quo solves problems providing framework greatly reduce programming effort required deal system properties 
programmer deal highlevel abstractions involving system properties cases reused 
architectural components automatically generated high level descriptions programmer 
example running example illustrate problems handling system issues quo proposed solution 
example application collaborative map part distributed planning application running wan 
part example network capable reserving resources user charged reservations reflect cost providing capacity expense users 
challenge example adaptive application reservations wisely application expected usage patterns qos requirements user budget 
note example focuses performance issues quo architecture general handle system properties availability security aspects real time behavior metrics cost 
distributed planning application built help create execute logistics plans quickly moving relief equipment site earthquake 
wide variety domain locality information needed spectrum specialized needed person create plan 
plan represented corba objects distributed wan 
planner responsible content subset plan objects 
order resolve conflicts planners collaborate peers spread world 
tools planners support collaboration collaborative map subsystem 
collaborative map geographic map overlaid icons 
icon represents status domain objects managed plan location known ascertained 
example icon represent shipping container location moves time color represents full empty 
icon local view remote corba object represents shipping container icon graphical characteristics representations attributes remote domain object 
map view modify different types corba objects owned different planners 
planner change plan object icons updated maps displaying representation object 
map subscribes remote objects displaying order receive updates 
subscription implies going association remote object map 
desired system characteristics association dictate kind network resources required 
example objects changing quickly minimum bandwidth need service updates 
bandwidth available application change theory practice object systems behavior flow controlling updates discarding updates reserving resources 
common problem applications developed lans address basic form adaptability 
application fielded wan restricted bandwidth update queue overflows literally crash pause indefinitely 
utility programs zero bandwidth requirement met 
making application adaptive hard requirement 
suppose map needs minimum bandwidth path remote object server reserving resources met requirement 
key issue establish resource reservation tear 
simple policy reduce cost resource reservation cancel reservation application idle 
canceling network resources effect functional part application correct representation state remote map objects 
simple example user leaves workstation workstation detects idle turns screen 
user returns moves mouse screen quickly appears happened 
analogously network resource reservation canceled reestablished user starts working 
trivial scope implementing network policy illustrate dimensions quo show quo architecture supports adding adaptive capabilities application 
policy chosen running example illustrates problems associated handling system conditions easy understand isolation 
rest show quo architecture address pragmatic problems complexities reservations hidden application 
happens reservation fails available 
policies associated making reservation specified group objects associated reservation 
responsible making reservation code 
code dealing system conditions reused objects 

quo design part integrating knowledge system properties distributed program complex entity 
created multiple components design decisions construction combination behavior components 
information decisions provided different providers different times consumed number consumers 
consider simple example involving implementation plan object map client times various commitments ffl object definition time plan object designer commits idl interface specification attributes plan object geographic location 
ffl object implementation time plan object designer commits specific algorithm implement interface specification looks object location relational database 
ffl client implementation time map client designer commits specific behavior object expected perform convert geographic location pixel location client screen 
ffl installation time system administrators commit specific implementations plan object map client 
alternate implementation object client may installed knowing changed long object interface remains 
ffl run time user decides plan objects view map client 
previous example showed different times functional properties object bound 
system properties bound client expected usage pattern met client object able adapt changing system conditions 
helps distributed application adaptive defer binding decisions late possible 
example client specify expected usage patterns object indicate believes support proposed usage pattern 
client object informed environment changes change expectations behavior example resources lost congestion occurs 
client inform object expected usage patterns change 
similarly object inform client usage pattern support qos deliver changes 
connections traditional client server architecture system information independent places difficult reconcile client communications substrate object 
tripartite division driven functional layering communication layer convenient interface client server 
kind qos provided disparate system information reconciled issue best place 
theory practice object systems way communication network supply qos guarantees support external management information base mib assess guarantees met example package 
approach keeps system information separated external agent integrate 
second approach client take responsibility qos 
example current world wide web www architectures feature intelligent browsers managing system properties prefetching parallel image retrieval caching 
qos architecture employing smart clients put heavy burden client programmer expect inexperienced client programmers object programmers 
provide third alternative object responsible qos 
object knowledge system conditions extended part object implementation moved client address space 
accomplish layered stack delegate objects implement abstraction client object connection qos 
connections define boundary expected usage pattern qos requirements client objects agreed 
example connection place current throughput measured client idleness detected 
interaction client objects pass connection 
effectively boundary client remote object moved clients address space delegate object 
client create local delegate objects turn bind remote object 
delegate objects support functional interface remote object forward client invocations 
delegate objects provide api handling system properties affecting client object connection 
having connection boundary reside client address space beneficial major reasons 
essentially delay congestion client connection object 
major advantage example external mib essentially additional layer qos client mib mib job complicated account layer 
second advantage practical purposes delegate object fail independently client 
monitor availability remote object replicas 
advantages combined allow connection knowledge remote object implementation communication substrate connects exploited provide better support qos adaptivity 
employing connection heavyweight solution compared local procedure call costs negligible compared remote procedure call 
qos regions system conditions change time 
result usage client generates qos object provides may diverge expectations 
quo handles divergence allowing specification levels system conditions involving client object 
negotiated region named region defined terms client usage object qos system conditions try operate 
negotiated region defined terms expectations client object delegate connection object set 
typical quo object support number negotiated regions 
negotiated region may reality regions named regions defined terms actual client usage object qos measured quo runtime system 
quo allows specification handler routines invoked client object transitions occur negotiated reality regions 
handler reality region transition informs client connection object measured conditions change sufficiently observed behavior meeting expectations 
allows client connection object take compensatory action try operate expectations change expectations 
negotiated region handler informs client object negotiated region changed 
fairly heavyweight operation possibly involving reallocation lower level resources quo applications normally try adapt reality region handlers 
negotiated reality regions may overlap predicates involving expected measured usage qos overlap negotiated reality regions 
quo allows specification precedence regions select current region predicate true 
shows example negotiated reality regions 
contract supports negotiated regions allocated free 
allocated region normal mode operation free mode client inactive period time 
free region entered client explicitly set expected throughput zero indicate user going lunch quo runtime system observing traffic client reasonable length time 
free region state resources associated remote object connection object remain allocated resources previously allocated support delivery invocations remote object may recycled 
allocated negotiated region client expects generate practice object systems allocated expected throughput expected throughput expected capacity max normal measured throughput measured throughput measured capacity max measured idleness client asleep measured throughput client overlimit measured throughput max insufficient resources measured capacity free expected throughput expected capacity normal extra resources client asleep measured idleness max idle measured capacity measured capacity measured throughput fig 

contract regions put greater zero greater max methods second 
allocated region reality regions normal insufficient resources client overlimit client asleep 
normal reality region measured throughput capacity consistent client object expectations 
insufficient resources reality region measured throughput capacity inconsistent client object expectations 
case handler connection object invoked inform capacity insufficient 
client overlimit reality region client generating expected case client informed exceeding expected usage 
reality region client asleep denotes client observed generated throughput time measured idleness detector 
case client callback set expected throughput zero object callback set expected capacity zero 
change expectations triggers reevaluation negotiated region change free 
free similar allocated discussion parts omitted sake brevity 
adaptivity implies multiple behaviors distributed applications need adapt changing system properties 
ways adapt include 
finish expected simply tolerating invocation finishing originally expected rescheduling system conditions presumably better 
example required bandwidth allocated map client simply block bandwidth allocated perform update 

expected 
example map client discard updates tolerate lower fidelity representation plan 

alternate mechanism different system properties 
example throughput goes allocated bandwidth updates compressed sent network 
uses bandwidth cost processing cycles 
quo provides mechanisms support adaptivity schemes 
client object connection object may notified reply outstanding request return client expected qos expected delay 
cases client may warned history requests near serviced expected qos 
case client object need notified agree options choose 
case client object need agree runtime change behaviors 
allow distributed applications adapt changing system conditions object designer application programmer able deploy multiple implementations functional unit ones implement functional interface different runtime theory practice object systems behavior different design decisions trading communications bandwidth versus storage versus processing cycles 
needs way specify implementations best valid system conditions able dispatch best implementation runtime current conditions 
quo architecture provides mechanisms support options 
object client warned pending request expected qos met reality region callback 
aware qos negotiated region presently 
change behaviors different ways 
accomplished explicitly calling different internal functions different negotiated reality regions 
second object designer specifying alternate paths connection object remote object sdl transparently compress data connection object transparently uncompress remote object invocation reached target method body 
quo commitment epochs quo supports object oriented qos way allows application adapt changing system properties 
allows object designer client programmer defer binding decisions late possible 
quo supports number binding times call commitment epochs 
ffl definition define type connection 
define structure quo regions hooks bind handlers regions effect different behaviors 
define alternate paths object components including marshaling unmarshaling code object sdl 
example connection bound system behavior time 
ffl connection create instance connection object passing parameters bind shape structure defined definition time max 
bind remote object particular communication substrate 
ffl negotiation agree expectations client traffic object qos choose expected bounds client object attempt operate 
words decide agreed behavior 
example client explicitly free resources setting expected throughput zero 
alternately quo runtime detect client idle invoke map client callback turn change expected throughput 
ffl invocation measure actual client usage generated object qos delivered failures observe actual behavior 
example throughput measured client agreed throughput limit employ flow control shape usage 
quo integrates information assumed actual system properties provided times various parties provide object oriented qos provides 

quo design part reducing variance system properties programs written local objects ones client address space assume simpler model system behavior remote objects 
example delay delivering invocation method implementation reply back client negligible throughput invocations second high 
base values system properties better local objects remote ones 
variance system properties negligible local case 
possible client host get overloaded occurrences relatively rare proliferation inexpensive powerful workstations personal computers 
resources client side usually abundant server side remote object communications link 
base value system properties higher remote objects variance system properties higher local objects 
additionally local objects fail independently clients practical purposes remote ones 
extreme form variance system properties 
experience higher variance system properties remote objects generally harder programmers deal worse base values system properties 
example little variance programmers easily deal higher delays lower throughput fact programs structured local objects 
current technologies programmers remote objects forced include substantial error handling code deal great variance system properties 
goal quo improve base value remote object system properties observed client reduce variance 
accomplishes negotiated reality regions layering internal delegate system condition objects 
quo applications adapt variance reality regions bind different client behaviors implementations different system conditions 
allows client object adjust behavior keep connection negotiated region operation long theory practice object systems possible reducing variance 
quo employs multiple layered delegate objects client side layer able mask variance system conditions improve base values employing algorithms implementations appropriate current conditions 
masking variance layers delegates improving system conditions accomplished single time place systems knowledge required available different times different places 
knowledge best information distributed multiple partners 
layer delegate objects client address space mind example 
delegates knowledge system information possess improve system conditions seen layer masking 
layer exports negotiated region layer 
uses various techniques changing policies mask changing conditions maintain qos provides layer 
maintain qos corresponding current negotiated region propagates information upward handler indicating change reality region 
party tries adapt changing policies indicates change expectations 
triggers renegotiation negotiated region negotiated regions defined terms expectations client object 
changing conditions handled architecture include changes resource availability network host course affects qos object deliver changes client usage pattern failure object 
example assume client knows wait indefinite period time invocation object complete object fails restarted 
indicated cdl cdl code generator generates client delegate object application 
application invokes functional methods client delegate delegate passes invocation handles exceptional conditions resulting invocation 
example remote object network link fails client delegate indicate invocation interrupted attempt reestablish link create instance object 
completed pass invocation 
client delegate optional cases 
available clients wish simplify invocation semantics degraded normal degraded normal client delegate object delegate orb delegate masking masking compressed interrupted failed masking simple translation client orb functional interface system interface fig 

masking system properties particular way eliminate application level exception handling 
object delegate take advantage knowledge different implementations adapt changing conditions providing useful qos client 
example object delegate automatically compression bandwidth orb delivering insufficient meet client needs trade additional cpu cycles maintain desired bandwidth 
cases done transparently client 
bandwidth compressed region may normal system properties delay may different 
separate negotiated region compressed indicates longer expects able meet conditions normal region 
client delegate throughput guarantees remains normal region compression transparent client 
orb delegate translates corba system exceptions system information available orb quo negotiated regions 
doing take advantage knowledge orb implementation orb delegate class created different orb quo supports 
client object orb delegate objects automatically generated cdl code generator 
connection time client passes objects handle callbacks notified change current reality region specified cdl 
optionally pass system condition objects delegate objects specified cdl aggregation 
client passes condition object quo runtime system create connection time 
theory practice object systems integrating system knowledge different sources shows quo architecture integrates knowledge different parties cohesive framework 
example functional interface named inv extended include system properties 
stack set client connects remote object 
participants different systems knowledge ffl client designer knowledge adapt changing reality negotiated regions different usage patterns client may generate different implementations provide 
knowledge encapsulated client delegate object rest encapsulated client application handlers kept separate functional part code 
ffl object designer knowledge object different implementations encapsulated object delegate object 
ffl quo designer knowledge orb quo ported implemented encapsulated orb delegate object 
ffl orb designer simple model system conditions encapsulated corba system exceptions 
ffl operations staff knowledge resource availability resource access permissions administrative domains encapsulated environment delegate objects 
delegate objects support different standardized interfaces facilitate integration knowledge varied sources 
delegate object stack implements various interfaces 
includes functional interface client invocations passed remote object 
includes callback interface contract delegate object reality negotiated region callbacks expectations interface lower delegate object query expectations layer 
implements negotiated region interface delegate object interface indicates current negotiated region delegate object 
implements environment callback interface informed changing environmental conditions 
complex delegates system conditions class objects preceding discussion note delegate objects translators 
translate lower level system conditions higher variance worse base values desirable system conditions lower variance better base values sys client object delegate orb delegate inv orb client callback client expectations exceptions object env callback orb callback orb expectations inv object region inv env orb env exceptions inv inout params return value functional interface system interface exceptions orb region env object env client delegate client env callback inv client region exceptions env client env object callback object expectations orb env callback fig 

delegate object layers tem properties closer local objects 
scheme flows information functional system 
functional flow passes client functional invocation updates appropriate system condition concerning invocation ones measure client throughput 
system information propagates independently functional information example system condition objects detect client idleness capacity information network management system 
delegate object monolithic object attributes code implement functional system translators implied 
logically delegate object acts object physically system portion delegate really implemented web sub objects shown 
objects implement contract region objects objects represent system properties system condition objects 
having separate system objects provides main advantages 
system objects run independently asynchronous functional part 
example functional part blocked waiting response system condition object represents size response updated 
change system condition trigger action putting dialog box asking size response big send wan current conditions 
second aggregate behavior group connections represented sharing system condition 
example measured throughput group objects tallied system condition updated object group called 
measured throughput group flow control interactions objects share common resource server process 
theory practice object systems orb delegate expected throughput capacity measured throughput capacity idleness max max idle contract allocated free normal insufficient resources client limit client asleep normal extra resources client sleeping callback object ref idle timer rate detector value value value object delegate expanded client environment system condition region attribute key network object fig 

web system condition objects implementing system translators note functional part delegate shared 
functional delegate represents binding functional translator call remote object system translator connection object 
functional delegate contain binding state minimum functional delegates pointer lower delegate object pointer contract object 
structure web system objects defined cdl 
specifically cdl defines form regions predicates system conditions define regions 
form contract defines slots specific types system conditions 
binding types specific instances happens connection time 
setting connection defines web interconnected system objects 
connection setup fairly heavyweight operation done invocation object 
expect connection operation comprehensive version current bind operation trader lookup get local remote object 
notice interface layers delegates really collection system condition objects maintained contained layer read 
reads callbacks directed interface objects affect container object indirectly 
interface objects located container allowing interface spread devices 
interface system conditions described idl system condition instances local distributed 
example system condition represents failure status remote host implemented ways idl interface 
implementation actively poll remote status demand periodically 
alternatively status object interface remote status service detects disseminates device status 
system conditions updated asynchronously method invocation object flexibility tradeoff regarding done demand invocation time event driven system condition changes 
example predicate defines region updated 
method call 
system condition predicate changes 
system conditions define propagate changes cache 
example system conditions propagate change cause forward chain events changes active regions calls handler independent call functional part delegate 
alternatively delegate invoked system conditions backward chain cached value 
theory practice object systems aggregates grouped objects set methods invocation single method 
example methods modify object state grouped writers group 
system condition expected throughput writers group set zero usage object expected near considered read replication mechanisms optimizing case employed best service readers object 

quo part exposing key design decisions large distributed systems developed dod grown staggering levels complexity 
manage complexity large systems built layers abstraction 
layer provides services client layers 
abstraction provides interface provides service hides details underlying implementation 
new implementation abstraction replace old typically implementation abstraction operating time 
unfortunately layered abstraction exposing functional interface corba idl 
distributed systems fundamentally different self contained stand programs 
wide range resources usage patterns single implementation component provide needed possible clients 
fundamentally appropriate design implementation black box module determined knowledge client intends module available resources 
looking distributed application code clear handling system issues dominates development 
past moving data structures network providing graphical user interfaces guis dominated problems greatly reduced advances commercial software corba orbs gui builders 
inadequacy functional interface approach led ad hoc arounds programming lines simply rewriting large parts module tailor specific environment 
programmers acutely aware target hardware type network client usage pattern 
resulting application fragile perform adequately outside intended environment 
example programmers spent month experimenting different caching schemes accessing collaborative map objects 
implementations worked lans poorly wans worked wans unacceptably lans 
forced choose implementation worked lans wans 
restricted single implementation forced commit specific set tradeoffs may appropriate different environment application 
open implementation oi techniques help augment black box functional interface allowing designer object expose key design decisions affecting object performance reliability 
open implementation provides disciplined objectoriented access implementation functional abstraction 
allows application developer alter behavior application choosing implementation component best suited application 
metadata describe implementation specified separately functional aspects implementation changed easily 
meta level architecture allows system reason change behavior self knowledge current system properties 
object developed oi techniques general handle wider range system properties supporting multiple implementations 
monolithic encompassing meta level architecture overwhelm typical application programmer wishes system issues just go away 
practical meta level architecture needs low barrier entry programmer willing able provide metadata system adaptive 
programmer understand handling system properties completely automated simplified 
programmers aware tolerances application explicit supplying metadata 
tradeoff metadata supply 
quo architecture supports wide spectrum adaptive techniques 
quo focuses supplying metadata system properties needed adaptive systems 
quo offer mandate specific adaptive mechanisms offers framework exploit rich collections existing 
mechanisms exist quo runtime libraries expand change time 
quo uses open implementation techniques expose metadata needed basis 
quality description language really independent sub description languages allow structured specification metadata system properties 
application fully support comprehensive adaptive applications multiple implementations 
description languages need specified default policies assumptions 
allows granularity adaptability tailored level effort 
example corba allows market generalized business objects order effective theory practice object systems adapt different environments 
expect experienced object programmers expend lot effort describing metadata order spare client programmer burden business objects judged adapt 
uses description languages expose system conditions coming quo evolves 
describe paragraphs doing give examples level adaptivity achieved amount metadata description language provides 
quo contract description language cdl defines expected usage patterns qos requirements connection object 
described previous section contract defines regions system conditions allows actions take place region changes 
connection time cdl help bind appropriate object specified expected usage patterns qos requirement select policy find object 
augments current corba bind mechanisms envisioned trader services 
invocation time reality regions dispatch different behaviors implementations object delegate current measured conditions 
handlers specified cdl programmed called contract detects change current region 
handlers clean problems synchronously asynchronously calls object 
resource description language rdl abstracts physical resources object 
resources bound real devices run time 
quo runtime models resources application running current status 
connection time resource model helps choose appropriate resource binding object 
policies current status groups resources just general policies optimize low network traffic 
example policy bind server highest capacity cpu type load average network capacity 
invocation time status resources route message best active server 
structure description language sdl defines internal structure object consumes resources 
sdl data flow description internal processing communication object state 
method sdl description 
example methods may change objects state write 
placement method implementations relative object state accesses flexible allowing object state migrate object client address space inbetween 
quo supports large spectrum adaptive techniques 
quo opens distributed object implementation specify metadata system properties 
order create distributed applications fragile programmers address system issues 
quo offers low barrier entry allowing programmer specify metadata judged worth effort current round development 
metadata specified adaptive distributed application 
order handling system properties tractable quo depends reusing system knowledge topic section 

quo design part supporting code reuse generation quo architecture described previous sections supports development applications adaptive exhibit predictable behavior 
tangible benefits practice realized requires substantial additional coding 
software projects today budget late trying deliver just implementation component thought having worry system properties provide multiple implementations excessive 
programmers deal system properties programs wide area 
issues effort takes handle effort amortized multiple projects configurations reuse 
necessary objects adaptive critical ones experienced programmers tuning program performance observe pieces bottlenecks spend time reimplementing 
additional implementations added new uses identified value application proven 
knowledge evolve implementation necessary allows de emphasize initial implementation choice especially rapid prototyping disciplines 
issue system property definition implementation may hard programmers deal 
subfield networking community protracted debates algorithm define system property measurement translate metrics experienced programmer part community may seemingly endless debates 
corba standard instrumentation programmer find guidance 
quo helps dilemma providing collection implementations system properties 
quo extensible mandate particular algorithm system condition 
anticipate cases providing choice system property theory practice object systems albeit different characteristics measuring throughput leaky token recursive filter algorithms provided 
quo supports reuse automatic generation code involved application reduce burden handling system properties programmer 
conceptually similar idl functional interfaces 
section discuss different ways quo supports practical software engineering software management issues organized development cycle times programmer perspective 
show steps programmer goes quo highlighting step reused generated quo programmer write 
contract shown 
result steps creation objects contract shown client uses 
development process quo adds steps corba development process defines new role qos designer 
traditional corba development process object designer defines idl interface object uses code generator object stubs client side proxy code 
object designer adds object functionality object stubs compiles runtime server 
client designer writes code uses client side proxy code compiles runtime client 
quo allows new role qos designer designs custom quo connections system condition objects 
system conditions developed corba object capture qos designer measurement expertise 
connections specified code generator region code delegate stubs 
support adaptive code client designer add functionality callback stubs object designer add adaptive behavior delegate stubs 
generated stubs modification resulting application qos aware adapt throughput measured changes detected action taken change occurs 
system conditions connections independent functional parts code 
expect qos designers create libraries code available object client designers add applications 
developing contract qos designer writes idl objects client callback expectations objects client callback client expectations 
receive notifications transitions object maintain client current expectations 
client designer compile link region code client code proxy code server code corba libraries compile link measurement stubs edit callback stubs qos aware delegate stubs object stubs connection interface system conditions idl functional interface design object functionality adaptive behavior connection design system condition design measurement expertise client functionality server runtime client runtime edit edit edit edit edit edit edit delegate code gen cdl code gen client code gen object code gen sys cond code gen callback code gen callback code adaptive delegate code measurement code corba process quo process object designer qos designer object interface idl fig 

corba quo development process theory practice object systems qos designer writes cdl contract 
gives cdl negotiated regions contract gives cdl reality regions negotiated regions 
note cdl specific particular corba interface may reused objects functional types 
function interface defined object designer needed generate delegate 
generate delegate system objects qos designer runs cdl code generator generate objects 
delegate objects deal getting invocation object delegate remote delegate objects right delegates deal implementing contract governing client object connection 
object designer adds adaptive behavior delegate stubs 
implement client api contract client developer writes implementations client callback client expectations objects handle negotiation time issues 
cases existing contract reused multiple versions client callback implementations candidates reuse implementation implement different policy 
client expectations object simple little corba attribute read write method set read value condition client expectations clauses cdl 
write client client designer write code interfaces delegate object connection time invocation time 
note quo api client uses consists corba idl language mappings idl idl interfaces specified functional interface client callback client expectations 
client designer writes code call connection manager create instances delegate contract system condition objects shown 
orb delegate bind best implementation remote object knowledge hand 
policies choose best implementation setting connection reused cases provided quo 
policies decisions structural information provided programmer information status remote resources quo provides 
policy chooses best remote object connect chosen kind structural information provided programmer 
connection manager passed pointers binding arguments client arguments shape contract max contract client expectations client callback objects 
connection manager returns pointer top level delegate 
returns arguments pointer object expectations object client need query hook allow client force evaluation regions independent invocation object 
client designer pointer invoke method remote object 
exactly corba client uses pointer local proxy object returned orbix bind example program uses pointer local object returned new keyword 

related efforts begun bring qos concepts corba layer 
odp trader architecture provides means offer service discover service offered 
concept property specify non functional characteristics service offered 
properties defined general placeholders 
trader architecture intended direct implementation general architecture create detailed standards 
specialization tina effort 
tina ongoing effort telecommunications providers computer vendors enable rapid deployment telecommunication services focus real time multimedia applications 
involve contract specifying client usage object qos provided 
set system properties contract limited 
adaptive 
quo permits specification multiple regions operation contract negotiated reality regions 
quo provides long ago realized current foreseeable widearea distributed applications contracts inevitably broken important provide orderly way application handle 
tina provisions adapting breaking contract 
probably assumption proper optimization video server delivering movie miles atm poor assumption wide area mobile environments 
open implementation idea outgrowth research meta object protocols mops part common lisp object system clos 
theory practice object systems forward declarations classes connection parameters 
interface client callback interface negotiated region interface client expectations contract parameters required connection client callback cl call client callback client expectations cl exp client expectations object expectations ob exp object expectations parameters specific connection predicates negotiated reality regions 
double max double max idle sec client callback interface client callback object callback interface object callback client expectations interface client expectations object expectations interface object expectations negotiated regions allocated cl exp throughput cl exp throughput max ob exp capacity max free cl exp throughput ob exp capacity transition callbacks allocated 
free obj call client asleep free 
allocated obj call client awake cl allocated transition callbacks negotiated regions reality regions allocated separate reality regions free separate contract fig 

cdl negotiated regions clos object oriented language implemented terms meta objects protocols 
programmer extend behavior language providing meta classes 
mop approach applied general contexts 
application areas include fault tolerance distributed objects operating systems :10.1.1.15.7137
aspect oriented programming generation open implementation approach programmers describe system aspects concern akin call system properties way formally reasoned combined woven functional code compiler called tm 
adaptive programming splits object oriented program parts functional class graph describing structure containment relationships 
separation helps program evolvable greatly reduces effort involved reprogramming changes classes contained object example due refinement redesign 
viewed open implementation terms separate class graphs independent functional part program offers principled controlled view containment issues violating encapsulation 
adaptive programming techniques demeter toolkit 

research distributed applications adaptable cope system properties far desirable vary greatly time acceptable mission critical cost effectively evolve 
quo develops cohesive framework constructing adaptable applications introducing concepts quality service object access theory practice object systems separate reality regions allocated normal quo condition measured throughput quo condition measured throughput max quo condition measured capacity max quo condition measured idleness max idle secs insufficient resources quo condition measured capacity max client overlimit quo condition measured throughput max client asleep quo condition measured idleness max idle sec precedences tell reality regions chosen predicate true precedence normal client asleep client overlimit resources transitions callbacks normal 
insufficient resources warn client isn capacity re negotiated region allocated supposed capacity 
cl call warn resources tell object allocate capacity lower expectations obj call allocate capacity max insufficient resources 
normal client know proceed cl call warn resources 
client overlimit inform client exceeding negotiated promise cl call warn overlimit max 
client asleep object client know client gone asleep 
may reset expectations client throughput object capacity cause renegotiation 
cl call 
warn sleeping obj call 
client asleep transition callbacks separate reality regions allocated fig 

cdl negotiated regions providing mechanisms integrate concepts emerging applications 
initial focus adapting managing network communication resources 
approach taken lends broader definition quality service incorporates system properties fault tolerance security performance 
quo concept integrates currently dispersed knowledge system properties cohesive framework base value variance system properties improved 
accomplished techniques traditional operating systems concepts runtime software provide easier manageable resource provided existing infrastructure 
maximize utility widespread immediately applying results chosen leading commercially available standards distributed object computing environment context 
quo architecture progress 
prototyped components quo architecture currently middle developing full prototype implementation 
include code generator cdl fully implemented collection system condition objects tools tracing invocation patterns clients components 
believe important provide early widespread access intermediate results keeping best practices approach successful research development activities 
concepts prototyped number prior projects experienced dealt problems isolation confident approach 
main points prototyping activity assess fit ideas theory practice object systems evolving corba standards general particular corba orb language products particular obtain engineering estimates cost appropriate granularity mechanisms current modern computing environment 
information existing expected system properties distributed objects provides rich base information 
help distributed application configured run different system properties easily information absent worse dispersed code system 
just scratches surface different implementations deployed runtime help application cope changing resource availability partial failures 
goal put place plumbing concepts needed organize acquire utilize information various times various participants software life cycle pertinent 
quo today 
hope develop family languages different levels detail hidden programmer domain specific features 
hope broaden scope qos quo offers communications qos include security partial failures types system properties 
acknowledgments ken anderson allen doyle jerry david karr leblanc dave pitts ray rodrigo tom wilkes feedback quo 
comments anonymous referees helped improve greatly 

bernstein schantz 

interprocess communication facilities network operating systems 
ieee computer june 

anderson flynn 

cases system assessing naval capability 
proceedings symposium command control research saic report june 

anderson 

freeing essence computation 
acm lisp pointers 

anderson 

compiling 
unpublished manuscript 

bakken schantz zinky 

qos issues wide area corba object systems 
proceedings second international workshop object oriented real time dependable systems words ieee february 

bbn 
cronus system subsystem specification 
bbn systems technologies report june 

burstein schantz desjardins smith 

common prototyping environment 
ieee expert february 

chiba 

metaobject protocol 
proceedings conference object oriented programming systems languages applications oopsla acm 

chiba masuda 

designing extensible distributed language meta level architecture 
proceedings european conference object oriented programming ecoop 

johnson schantz sussman thomas walden 

operating system computer resource sharing 
proceedings fifth symposium operating systems principles acm operating systems review november 

fabre 

implementing fault tolerant applications reflective objectoriented programming 
proceedings international symposium fault tolerant computing ieee pasadena california june 

yemini 

management application quality service 
proceedings fifth ifip ieee international workshop distributed systems operations management october 

dean schantz 

programming support cronus distributed operating system 
proceedings sixth international conference distributed computing systems may 

kiczales des rivi eres bobrow 

art metaobject protocol 
mit press 

kiczales 

new model abstraction engineering software 
proceedings workshop reflection meta level architectures imsa 

proceedings workshop open implementation 
internet publication url www parc xerox com parc spl eca oi workshop gamma 

kiczales lamping 

operating systems object 
proceedings international workshop object orientation operating systems ieee 

kiczales 

black box open implementation 
ieee software january 

lee zachary 

reflections metaprogramming 
ieee transactions software engineering november 

leslie mcauley tennenhouse 

atm ieee networks march 

gay 

computational engineering view open distributed real time multimedia exchange 
proceedings fifth international workshop network operating system support digital audio video nossdav boston usa april 

shin 

combining contracts exemplar programming class hiding customization 
proceedings conference objectoriented programming systems languages applications oopsla acm 

lieberherr silva xiao 

adaptive object oriented programming graph customization 
communications acm may 

lieberherr 

adaptive object oriented software demeter method propagation patterns 
pws publishing boston 

lieberherr 

demeter 
internet publication url www ccs neu edu research demeter html 
theory practice object systems 
matsuoka asai yonezawa 

compiling away meta level object oriented concurrent reflective languages partial evaluation proceedings conference object oriented programming systems languages applications oopsla acm 

nicol wilkes manola 

object orientation heterogenous distributed computing systems 
ieee computer june 

object management group 
odp trading function 
omg document june 

object management group 
common object request broker architecture specification 
omg document july 

palsberg xiao lieberherr 

efficient implementation adaptive software 
acm transactions programming languages systems march 

partridge pink 

implementation revised internet stream st 
internetworking research experience march 

nicol 

atm desktop impacting modern business communications broadband technology 
telematics informatics special issue multimedia technologies systems applications appear pergamon 

nicol 
experiences developing distributed business multimedia applications 
proceedings international conference multimedia computing systems ieee may 

schantz 


operating system design network computer 
ph thesis state university new york stony brook may 

schantz thomas bono 

architecture cronus distributed operating system 
proceedings sixth international conference distributed computing systems may 



experimental internet stream protocol version st ii 
internet rfc october 

walker floyd 

asynchronous remote operation execution distributed systems 
proceedings tenth international conference distributed computing systems june 

walker 

decision aids crisis action planning 
proceedings mission planning symposium september 

walker dean 

migration cronus corba 
proceedings fifth ieee dual technologies applications conference may 

waldo wollrath kendall 

note distributed computing 
report tr sun microsystems laboratories november 

xerox 
aspect oriented programming 
internet publication url www parc xerox com aop 

zhang deering estrin shenker zappala 

rsvp new resource reservation protocol 
ieee network september 
theory practice object systems 
