distance browsing spatial databases sli hanan samet computer science department center automation research institute advanced computer studies university maryland college park maryland cs umd edu cs umd edu different techniques browsing collection spatial objects stored tree spatial data structure basis distances arbitrary spatial query object compared 
conventional approach nearest neighbor algorithm known prior invocation algorithm 
needed nearest neighbor algorithm needs neighbors possibly performing redundant computations 
second approach incremental sense having obtained nearest neighbors st neighbor obtained having calculate nearest neighbors scratch 
incremental approach finds processing complex queries conditions involves spatial proximity nearest city chicago population greater case query engine pipelined strategy 
general incremental nearest neighbor algorithm applicable large class hierarchical spatial data structures 
algorithm adapted tree performance compared existing nearest neighbor algorithm trees 
experiments show incremental nearest neighbor algorithm significantly outperforms nearest neighbor algorithm distance browsing queries spatial database uses tree spatial index 
incremental nearest neighbor algorithm usually outperforms nearest neighbor algorithm applied nearest neighbor problem tree improvement nearly large distance browsing queries 
fact prove informally step execution incremental nearest neighbor algorithm optimal respect spatial data structure employed 
furthermore simplifying assumptions prove dimensions distance computations leaf nodes accesses algorithm finding neighbors 
keywords distance browsing ranking nearest neighbors trees spatial databases hierarchical spatial data structures 
slightly modified version article appeared acm transactions database systems june pp 

journal version contains minor typographic errors 
particular errors pp symbol left second formulas log appearing line second paragraph section 
supported part national science iri department energy contract er 
acm transactions database systems june pp 
focus issue obtaining data objects order distance query object termed ranking 
issue primary interest spatial database finds database applications including multimedia indexing cad molecular biology :10.1.1.37.9993
desired ranking may full partial objects 
problem posed conventional database system 
example table individuals containing weight attribute ask weight closest lbs rank individuals weight differs lbs 
index exists weight attribute answer query scan tuples performed 
appropriate index structure efficient methods employed 
example tree query answered single descent leaf cost log tuples 
correct answer leaf adjacent 
rank individuals search proceed directions leaves tree constant cost tuple 
index query regardless weight multidimensional data things simple 
consider example set points dimensions representing cities 
queries analogous previous ones city closest point rank cities distances point 
database context wish know kind index structures aid processing queries 
fixed point distance metric build dimensional index distances cities point provide efficient execution time particular point point distance metric useless 
rebuild index costly process need query 
contrast dimensional case generally choice metric 
furthermore point point positions relation larger smaller 
possible define simple relationship multidimensional case 
example suppose want find nearest city chicago inhabitants 
ways proceed 
intuitive solution guess area range chicago check populations cities range 
find city requisite population sure cities closer meet population condition 
approach inefficient guess size area searched 
problem guessing may choose small region large region 
size small area may contain cities satisfying population criterion case need expand region searched 
size large may examining cities needlessly 
radical solution sort cities distances chicago 
practical need re sort time pose similar query respect city 
sorting requires considerable amount extra especially usually needed obtain desired result inspect nearest neighbors 
radical solution retrieve closest cities determine satisfy population criterion 
problem lies determining value area range solution may choose small large value small failure find city satisfying population criterion means restart search value larger 
drawback solution search forces expend finding nearest neighbors part cost finding neighbors 
hand large waste calculating neighbors populations check 
logical way overcome drawbacks second third solutions obtain neighbors incrementally needed 
essence doing browsing database basis distance shall term distance browsing describe operation 
acm transactions database systems june pp 
result incremental ranking cities distance cease search soon secondary population condition satisfied 
idea want small unknown number neighbors 
incremental solution finds application general setting specialized query example 
particular includes queries require application nearest predicate subset attributes relation object class class queries part restricted common class imposes additional condition usually involving attributes means nearest condition serves primary condition condition serves secondary condition 
incremental solution enables query processed pipelined fashion 
course worst case examine neighbors incremental approach 
may occur objects satisfy secondary condition cities requisite population 
case may better select basis secondary condition population criterion example considering spatially nearest condition especially index exists compute secondary condition 
nearest neighbor algorithm may preferable provided efficient incremental algorithm large values sense choose solution know advance neighbors needed value value estimated selectivity secondary condition 
issues demonstrate need query engine estimates selectivity factors involving numbers values expected satisfy various parts query computational costs applicable algorithms 
compare incremental nearest neighbor approaches browsing collection spatial objects stored tree spatial data structure basis distances arbitrary spatial query object 
process general incremental nearest neighbor algorithm applicable large class hierarchical spatial data structures show adapt algorithm tree 
performance compared existing nearest neighbor algorithm trees 
addition demonstrate nearest neighbor algorithm transformed special case tree adaptation general incremental nearest neighbor algorithm 
transformation process reveals tree incremental nearest neighbor algorithm achieves pruning tree nearest neighbor algorithm 
tree adaptation leads considerably efficient conceptually different algorithm 
presence object bounding rectangles tree enables pruning devices reduce disk accessing spatial descriptions objects stored external tree 
experiments show incremental nearest neighbor algorithm significantly outperforms nearest neighbor algorithm distance browsing queries spatial database uses tree spatial index 
incremental nearest neighbor algorithm usually outperforms nearest neighbor algorithm applied nearest neighbor problem tree improvement nearly large distance browsing queries 
rest organized follows 
section discusses algorithms related nearest neighbor queries 
section reviews structure trees 
section describes incremental nearest neighbor algorithm adaptation tree 
section introduces nearest neighbor algorithm 
section presents results empirical study comparing incremental nearest neighbor algorithm nearest neighbor algorithm 
section discusses issues arise high dimensional spaces drawn section 
related numerous algorithms exist answering nearest neighbor nearest neighbor queries 
motivated importance queries fields including geographical information systems gis pattern recog acm transactions database systems june pp 
nition document retrieval learning theory 
algorithms coming field computational geometry points dimensional vector space allow arbitrary spatial objects limited point query object 
applications rough answer suffices algorithms developed return approximate result saving time computing :10.1.1.15.3125
algorithms require specialized search structures employ commonly spatial data structures 
example algorithms exist tree quadtree related structures rtree lsd tree :10.1.1.49.7984
addition algorithms applied spatial data structures 
knowledge incremental solutions nearest neighbor problem exist literature 
algorithms employ priority queues see section 
algorithm developed tree 
considerably different algorithms algorithm stores data objects priority queue uses stack keep track subtrees spatial data structure completely processed 
necessary elaborate mechanism avoid processing contents node 
algorithm developed lsd tree 
similar method published time 
principal difference method lsd tree algorithm uses priority queues data objects nodes spatial data structure 
algorithm somewhat complicated priority queues offer performance benefits experiments 
algorithm initially developed pmr quadtree presentation general 
expand considerably initial solution showing adapted tree comparing solution existing nearest neighbor algorithm 
addition show nearest neighbor algorithm transformed special case tree adaptation general incremental nearest neighbor algorithm 
byproduct transformation process nearest neighbor algorithm simplified considerably 
term distance scan term distance browsing 
becker ting introduce concept distance scan motivate 
done similar lines section context finding closest object query point additional conditions may imposed object 
addition provides optimization rules mapping closest operator distance scan operation example gis query language 
algorithms mentioned far assume objects exist dimensional euclidean space distances defined objects data set object point space 
class nearest neighbor algorithms operates general objects commonly called metric space model 
restriction objects reside metric space distance metric defined objects 
general case possible produce new objects metric space aggregate divide objects euclidean space bounding rectangles purpose 
various methods exist indexing objects metric space model computing proximity queries :10.1.1.145.5268
methods properties distance metrics nonnegativity symmetry triangle inequality operate knowledge objects represented distances objects computed 
general approach usually slower methods spatial properties objects objects properties exist images chemical data time series 
approach advocated high dimensional vector spaces 
may possible map general objects geometric space benefit efficient search methods 
mapping approaches domain specific general approaches proposed 
acm transactions database systems june pp 
trees tree object hierarchy form balanced structure inspired tree 
tree node contains array key pointer entries key hyper rectangle minimally bounds data objects subtree pointed pointer 
tree leaf node pointer object identifier tuple id relational system nonleaf node pointer child node lower level 
maximum number entries node termed node capacity fan may different leaf nonleaf nodes 
node capacity usually chosen node fills disk page small number 
clear tree index space arbitrary dimension arbitrary spatial objects just points 
described tree leaf node contains minimal bounding rectangle object identifier object node geometric descriptions objects stored external tree 
possibility store actual object geometric description leaf bounding rectangle 
usually useful object representation relatively small similar size bounding rectangle fixed length 
data object relevant attributes stored leaf nodes object identifiers need stored 
disadvantage approach objects fixed addresses objects moved time tree node split 
abr cir ef tree index set line segments 
spatial rendering line segments bounding rectangles tree access structure 
bounding rectangles individual line segments omitted interest clarity 
variations trees devised differing way nodes split combined insertion deletion 
experiments variant called tree 
differs conventional tree employing sophisticated insertion node splitting algorithms attempt minimize combination overlap bounding rectangles total area 
addition rtree node overflows immediately splitting ther tree insertion algorithm tries see entries possibly fit better node 
achieved fixed fraction entries increases construction time index usually results node overlap improved query response time 
acm transactions database systems june pp 
incremental nearest neighbor algorithm algorithms traverse tree structures top manner form depth breadthfirst tree traversal 
finding leaf node containing query object spatial index done depthfirst manner recursively descending tree structure 
method recursion stack keeps track nodes visited 
having reached leaf need able extend technique find nearest object leaf may contain nearest neighbor 
problem unwind recursion find nearest object 
want find second nearest object solution tougher 
breadth traversal nodes tree visited level level queue keep track nodes visited 
technique lot done reaching leaf node containing resolve problems depth breadth traversal incremental nearest neighbor algorithm employs may termed best traversal 
deciding node traverse picks node distance set nodes visited 
means stack plain queue keep track nodes visited priority queue distance query object key 
key feature solution objects nodes stored priority queue 
section organized follows section specify conditions hold incremental nearest neighbor algorithm applicable conditions index spatial object types distance functions 
section general incremental nearest neighbor algorithm detail 
section discuss ways exploit particular nature tree spatial index section give example execution algorithm simple tree structure 
variants algorithm described section 
section analytical results algorithm section prove correctness 
section show deal large priority queue 
incremental nearest neighbor algorithm applied virtually hierarchical spatial data structure 
fact generally applicable data structure hierarchical containment partitioning see 
description assume tree structure method general structures tree node represents regions space objects pointers external table stored leaf nodes regions intersect objects 
remainder section distinction node region represents meaning clear context 
basic requirement method applicable region covered node completely contained region parent node examples structures satisfy requirement include quadtrees trees trees lsd trees 
examples node region rectangular requirement 
algorithm handles object represented leaf node pmr quadtree tree 
assume exposition node parent leaf nodes store objects algorithm easily adapted handle cases hb tree cell tree shelves 
observe data objects query objects arbitrary type points rectangles polygons 
requirement consistent distance functions dn calculating distance query object data objects nodes 
ensure object encountered node farther query object object structures node parent hb tree partition node region fully contained union regions parent nodes 
acm transactions database systems june pp 
strictly nondecreasing distances elements retrieved queue guaranteed 
consistency defined formally follows definition assumptions nature index hierarchy 
definition combination functions dn denote fact item contained exactly set nodes object set leaf nodes referencing object node set parent nodes 
functions dn consistent iff query object object node hierarchical data structure exists 
definition strictly tied hierarchy defined data structure 
hierarchy influenced properties node regions data objects usually recast definition terms properties 
example spatial data structures containment objects leaf nodes child nodes parent nodes spatial containment definition denotes spatial containment 
words union node regions nodes completely encloses region covered object node informally definition consistency means point accurately region corresponds closest contained region covered node note assume spatial indexes form tree hierarchy nonroot node exactly parent case nodes definition simplifies condition child node node dn 
easy way ensure consistency base functions metric dp points common choices metrics include euclidean manhattan chessboard metrics 
define minp dp spatial object node region 
important note way define consistent distance functions 
defined metric dp consistency guaranteed properties dp specifically nonnegativity triangle inequality 
nonnegativity property states things dp triangle inequality states dp dp dp spatially contained points common distance zero 
triangle inequality broad definition allow equals 
note distance functions defined way distance query object node intersects zero equal distance boundary node region 
incremental nearest neighbor algorithm works number dimensions examples give restricted dimensions 
query object need space dataset 
algorithm description consider regular recursive top traversal index locate leaf node containing query object 
note may node 
traversal initiated root node spatial index node spanning index space second argument 
queryobject node queryobject node node node leaf node report leaf node node spatial data structures node parent node hb tree exception 
acm transactions database systems june pp 
child node node queryobject child enddo endif endif task extend algorithm find object nearest query object 
particular leaf node containing queryobject line start examining objects contained node 
object closest query object reside node 
finding node may fact require unwinding recursion top descending deeper tree 
furthermore node aid finding nearest object 
resolve dilemma replace recursion stack regular top traversal priority queue 
addition priority queue nodes objects put queue leaf nodes processed 
key order elements queue distance query object 
order distinguish elements equal distances query object adopt convention nodes ordered objects objects ordered arbitrary unique rule 
secondary ordering possible avoid reporting object necessary disjoint decomposition pmr quadtree tree objects may associated node 
node examined reaches head queue 
time nodes objects closer query object examined 
initially node spanning index space sole element priority queue 
subsequent steps element head queue closest element examined retrieved repeated queue emptied 
informally visualize progress algorithm query object follows point see 
start locating leaf node containing imagine circle centered expanded starting radius call circle search region 
time circle hits boundary node region contents node put queue time circle hits object object nearest note circle hits node object guaranteed node object priority queue node contains hit guaranteed consistency condition 
presents algorithm 
lines initialize queue 
notice really necessary provide correct distance root node dequeued 
line closest object reported 
point routine query engine take control possibly resuming algorithm time get closest object alternately terminating objects desired 
recall types spatial indexes spatial object may span nodes 
case algorithm guard objects reported 
test statement line ensures objects reported put queue 
note test needed case element nonleaf node holds implicitly assumption child nodes fully contained parent nodes 
properly nodes retrieved queue spatial objects distance 
object may retrieved queue node containing distance query object means object contained node dequeued 
object encountered node way knowing reported 
loop lines eliminates duplicate instances object queue 
inducing ordering objects distance query object instances object clustered front queue instance reaches front 
explicitly check duplicates manner acm transactions database systems june pp 
circle query object depicts search region reporting nearest object 
simplicity leaf nodes represented grid spatial indexes shapes leaf nodes irregular grid 
shaded leaf nodes accessed incremental nearest neighbor algorithm 
region darker shading find objects priority queue 
queryobject queue enqueue queue isempty queue element dequeue queue element spatial object element queue queue enddo report element elseif element leaf node object leaf node element dist queryobject object dist queryobject element enqueue queue object dist queryobject object endif enddo element nonleaf node child node node element enqueue queue child dist queryobject child enddo endif enddo incremental nearest neighbor algorithm 
priority queue implementations binary heap efficient detect duplicates queue elements implementations maintain partial elements 
possible alternative priority queue implementation maintains total order queue elements balanced binary tree able detect duplicates efficiently 
acm transactions database systems june pp 
adapting trees section demonstrate adapt general incremental algorithm trees exploiting unique properties trees 
spatial objects stored external tree leaf nodes contain bounding rectangles objects adaptation leads considerably efficient conceptually different incremental algorithm 
enables bounding rectangles pruning devices reducing disk needed access spatial descriptions objects 
addition trees store object just making unnecessary worry reporting object 
removes need enforce secondary ordering priority queue general algorithm see section 
inputs tree incremental nearest neighbor algorithm query object containing set spatial data objects 
general incremental nearest neighbor algorithm data objects query object may dimension arbitrary type points rectangles polygons long consistent distance functions calculating distance data objects bounding rectangles 
case tree means data object rectangle completely contained rectangle 
general algorithm virtually unchanged object geometry stored tree leaf nodes changes ones described 
spatial objects stored external rtree primary difference general algorithm bounding rectangles stored leaf nodes 
exploit information third type queue element introduced object bounding rectangle 
distance object bounding rectangle greater distance object provided distance functions consistent 
informally modifications algorithm follows tree leaf processed main loop algorithm computing real distances objects distances bounding boxes computed inserted queue 
object bounding box retrieved queue actual distance computed 
object closer query object element priority queue reported nearest neighbor 
object inserted queue real distance 
shows algorithm 
lines queue initialized 
line closest object reported 
line object enqueued real distance key determined elements queue key real distance query object elements reported nearest object 
line enqueues object bounding rectangle brackets object signal object bounding rectangle pointer corresponding object 
general incremental nearest neighbor algorithm extra test point guard reporting duplicates needed 
tree variant spatial data structure method separates storage bounding rectangles actual geometric descriptions objects 
complex objects example polygons conceive levels refinement orthogonal polygons 
example example suppose want find nearest neighbors query tree spatial objects line segments stored external tree 
show steps algorithm contents priority queue 
algorithm compute distances line segments bounding rectangles 
distances table br means bounding rectangle 
arbitrary coordinate system approximate 
depicting acm transactions database systems june pp 
queryobject tree queue enqueue queue tree isempty queue element dequeue queue element object bounding rectangle element bounding rectangle object isempty queue dist queryobject object queue key enqueue queue object dist queryobject object report element bounding rectangle associated object nearest object endif elseif element leaf node entry object rect leaf node element enqueue queue object dist queryobject rect enddo element nonleaf node entry node rect node element enqueue queue node dist queryobject rect enddo endif enddo incremental nearest neighbor algorithm tree spatial objects stored external tree 
seg 
dist br dist br dist table distances line segments bounding rectangles query point tree 
contents priority queue line segments bounding rectangles listed distances increasing order distance ties broken alphabetical ordering 
bounding rectangles objects denoted corresponding object names embedded brackets 
algorithm starts executes steps 
andr 
queue acm transactions database systems june pp 

andr 
queue 
andr 
queue 
enqueue bounding rectangles 
queue 
dequeue 
distance larger distance ofr 
queue 
enqueue 
queue 
enqueue 
queue 
dequeue 
distance ofa larger distance reported nearest neighbor 
queue 
dequeue 
distance larger distance ofi reported second nearest neighbor 
queue 
report third nearest neighbor 
observe left priority queue execution 
corresponds nearest neighbor algorithm invoked node see section 
larger examples incremental algorithm generally achieve pruning nearest neighbor algorithm 
note second third nearest neighbors obtained little additional nearest neighbor 
case incremental nearest neighbor algorithm regardless underlying spatial index 
words nearest neighbor nearest neighbors retrieved virtually additional 
variants relatively minor modifications incremental nearest neighbor algorithm find farthest object query object 
case queue elements sorted decreasing order distances 
objects nodes contained node generally larger distances query object means elements enqueued larger keys node contained breaks condition elements dequeued decreasing order distance 
key node queue upper bound distance object subtree dmax maxp dp 
function implementing dmax satisfy consistency condition similar defined dn difference dmax replace condition extension algorithm allow minimum maximum imposed distances objects reported 
order effectively utilize minimum distance function dmax defined needed 
node put queue dmax greater equal minimum desired distance 
notice case algorithm performs spatial selection operation addition ranking 
acm transactions database systems june pp 
gives version algorithm extensions added 
arguments min max specify minimum maximum desired distance boolean variable true farthest object desired 
case negative distances keys priority queue elements get sorted decreasing order distance 
condition line encompasses conditions false true respectively 
line key leaf node assigned minimum maximum distance node depending value 
reason multiplying key line cancel effect multiplying value line negative looking farthest objects 
powerful way extending incremental nearest neighbor algorithm combine spatial queries restrictions objects nodes 
example algorithm combined range query checking object node range prior inserting priority queue rejecting fall range 
combined queries obtained manipulating distance functions return special values objects nodes rejected 
incremental nearest neighbor clearly solve traditional nearest neighbor problem query object find nearest neighbors done simply retrieving neighbors algorithm terminating determined 
analysis performing comprehensive theoretical analysis incremental nearest neighbor algorithm complicated especially high dimensional spaces 
prior area limited case data objects query object points 
number simplifying assumptions data objects uniformly distributed data space 
section discuss issues involved sketch rudimentary analysis dimensional points 
wish analyze situation finding nearest neighbors 
th nearest neighbor query object distance region distance called search region 
assume point search region circle hypersphere higher dimensions radius depicts scenario 
observe objects inside search region reported algorithm nearest object nodes intersecting search region examined contents put priority queue 
insight obtained contents priority queue noting node completely inside search region nodes objects subtree rooted taken queue 
elements priority queue contained nodes intersecting boundary search region dark shaded region 
proceeding point algorithm access nodes objects lie entirely outside search region farther 
follows directly queue order consistency conditions 
particular elements retrieved priority queue order distance consistency conditions guarantee insert elements queue smaller distances element dequeued 
conversely algorithm uses spatial index visit nodes intersect search region may objects closer query object established algorithm visits minimal number nodes necessary finding th nearest neighbor 
characterized saying algorithm optimal respect structure spatial index 
mean algorithm optimal respect nearest neighbor problem close algorithm comes optimal respect depends spatial index 
acm transactions database systems june pp 
queryobject min max queue enqueue queue endif isempty queue element dequeue queue element spatial object element queue queue enddo report element elseif element leaf node element key object leaf node element dist queryobject object min max enqueue queue object endif enddo element nonleaf node child node node element dmin mindist queryobject child dmax maxdist queryobject child dmax min dmin max dmax dmin endif enqueue queue child endif enddo endif enddo enhanced incremental nearest neighbor algorithm generally steps needed derive performance measures incremental nearest neighbor algorithm 
expected area search region determined 
expected area search region assumed distribution locations sizes leaf nodes derive measures expected number leaf nodes accessed algorithm intersected search region expected number objects priority queue 
describes approach uses number simplifying assumptions 
particular assumes uniformly distributed data points dimensional interval leaf nodes assumed form grid acm transactions database systems june pp 
lowest level spatial index average occupancy points search region assumed completely contained data space 
assume uniformly distributed points expected area search region expected area leaf node regions area circle radius search region means radius leaf node regions squares side length pc points number leaf node regions intersected boundary search region intersected boundary circumscribed square 
sides circumscribed square sc leaf node regions 
adjacent sides intersect leaf node region corner square expected number leaf node regions intersected search region bounded 
reasonable assume average half points leaf nodes inside search region half outside 
expected number points remaining priority queue points dark shaded region pp ck ck number points inside search region light shaded region expected number points leaf nodes intersected search region ck 
leaf node contains points expected number leaf nodes accessed get points bounded pk 
summarize expected number leaf node accesses expected number objects priority queue 
intuitively extra done algorithm comes boundary search region 
roughly speaking term expected number leaf node accesses accounts leaf nodes completely inside search region term accounts leaf nodes intersected boundary search region 
points priority queue lie search region taken queue inside leaf nodes intersected boundary search region 
average leaf node occupancy average node fan fairly high say number leaf node accesses dominates number nonleaf node accesses number objects priority queue greatly exceeds number nodes queue 
approximate total number node accesses total number priority queue elements number leaf node accesses number objects priority queue 
traversal root spatial index leaf node containing query object add log term measures 
spatial index disk cost disk accesses dominate cost priority queue operations 
spatial index memory priority queue operations single largest cost factor algorithm 
typical priority queue implementations binary heap cost insertion deletion operation logp size queue 
number objects inserted pinto priority queue pa cost log expected size bounded total cost log take nonleaf nodes account formulas somewhat complicated 
analysis outlined assumptions generally hold practice 
particular data rarely uniformly distributed search region extends data space 
analysis allows fairly close predictions actual behavior dimensional point data assumptions hold 
higher dimensions situation somewhat complicated 
detailed analysis context 
acm transactions database systems june pp 
correctness turn correctness algorithm 
ignore moment issue reporting object 
data object define ancestor set denoted include leaf nodes contain dn node guaranteed exist consistency distance functions ancestors applied recursively consistency property ensures dn 
elements interpreted representing object theorem guarantees object representative queue 
directly implies object eventually reported bounded numbers objects nodes put queue 
theorem set objects reported set elements queue 
invariant outer loop object element 
proof prove theorem arbitrary object induction 
choose arbitrarily proof holds objects 
induction number loop executions 
show invariant holds execution loop execution falsifies hold execution loop assuming held execution shown invariant holds 
clearly holds initially element queue root node root ancestor nodes assume invariant holds execution loop 
show holds 
reported invariant trivially holds affected loop execution 
assumption invariant holds exists 
invariant unaffected element dequeued assume dequeued 
subsequently reported moving invariant maintained 
node consider case leaf nonleaf node separately 
leaf node loop line enqueues objects distance dn dist queryobject element 
stored recall dn construction put queue 

nonleaf node child nodes enqueued 
ancestor leaf node contains child nodes maintaining invariant 
see leaf nonleaf nodes enqueued elements 
invariant maintained object chosen arbitrarily shown invariant holds objects 
mentioned theorem guarantees object representative queue 
elements retrieved queue order distance elements farther query point point put queue eventually reported 
reported closest object exists object closer representatives closer dequeued contradicting assumption dequeued 
acm transactions database systems june pp 
correctness duplicate removal lines follows directly ordering imposed priority queue 
way object reported inserted queue reported 
avoided test line fact nodes processed objects distance query object 
priority queue cost priority queue operations plays role performance incremental nearest neighbor algorithm 
larger queue size gets costly operation 
queue gets large fit memory contents stored disk structure memory making operation costly 
example worst case queue size tree incremental nearest neighbor algorithm arises leaf nodes distance query object data objects farther away shown query object data objects points 
case leaf nodes processed incremental algorithm data objects inserted priority queue nearest neighbor determined 
note nearest neighbor algorithm uses tree visit leaf nodes nearest neighbor farther away query object leaf nodes way sure seen nearest neighbor 
furthermore note worst case depicted highly arise practice depends particular configuration data objects query object 
example tree points node capacity showing worst case nearest neighbor search 
pointed section objects priority queue contained leaf nodes intersected boundary search region 
dimensional uniformly distributed data points mentioned expected number points priority queue finding nearest neighbors 
large course data set larger size priority queue manageable keeping memory 
complex objects points skewed data distributions may cause larger proportions objects inserted priority queue 
number dimensions grows size priority queue function tends get larger see section 
prepared deal large priority queue 
cases priority queue exceeds size available memory stored part disk resident structure 
possibility tree structure store entire contents acm transactions database systems june pp 
priority queue 
proper buffer management able arrange tree nodes store elements smaller distances get dequeued early kept memory 
believe priority queue fits memory trees considerably slower fast heap approaches tree expend maintaining queue elements fully sorted order 
contrast heap methods impose looser structure elements 
hybrid scheme storing priority queue portion priority queue kept memory portion kept disk appropriate 
simple way implement hybrid memory disk priority queue partition queue elements distance 
outline done 
contents priority queue split tiers 
tier kept memory heap structure second third tiers kept disk file difference little structure imposed contents second tier 
monotonically increasing sequence dm upper bound largest query object data object distance farthest corner data space 
sequence define ranges distances associate different ranges various tiers 
new element distance query object inserted priority queue element gets added tier associated distance range matches initially tier associated distance range queue elements range stored memorybased heap structure tier range dp tier range dp dm 
contents tier divided ranges dp dp 
value depends ranges cost effective maintain high tier exhausted move elements distance range tier tier associate tier distance range 
time tier exhausted move elements distance range tier 
happens eventually exhaust tier 
happens scan entire contents tier rebuild tiers new ranges 
note moving elements tier tier tier exhausted time tier exhausted reduces number scans tier may contain large number elements 
general distance elements head priority queue range di di neighbors distances di reported tier associated range di di tier range di di tier range di dm wheres mod 
keep elements tier set linked lists interval dj dj order save disk os associate buffer linked lists group elements pages fixed size 
alternative linked lists file separate file range 
associating range di di tier associate entire range di di newly inserted elements range get inserted tier tier 
want scan tier time exhaust tier tier contain elements range di di 
elements get moved tier tier gets scanned happens mod 
variation technique additional tier tier tier elements stored unsorted list memory 
idea limit size memory heap insertion deletion operations expensive 
keeping new tier memory outside heap inexpensive add elements require disk os 
small number neighbors requested elements tier need placed heap 
remaining question choose sequence dm 
naive way simply guess distance threshold dt dt 
alternatively assume data distribution derive appropriate sequence 
example recall section assumptions expected number leaf nodes intersected boundary search region radius bounded wheres expected side length leaf node region 
acm transactions database systems june pp 
assuming half points nodes outside search region expected number points priority queue 
assuming space memory priority queue elements means di satisfy equation di di course derivation assumptions generally hold practice 
fairly practice dimensional points 
gives indication obtain sequence ways analyzing size priority queue 
nearest neighbor search trees alternative approach nearest neighbor search trees proposed 
approach applicable finding nearest neighbors fixed advance 
contrast incremental nearest neighbor algorithm fixed advance 
key idea nearest neighbor algorithm maintain global list candidate nearest neighbors tree traversed depth manner 
see fact nearest neighbor algorithm employs pure depthfirst traversal means step algorithm local decisions node visit node visit child node current node incremental nearest neighbor algorithm global decisions contents priority queue choose child nodes nodes visited 
section describe somewhat simplified version nearest show example execution 
prove simplified version fact equivalent algorithm versions visit nodes tree 
show nearest neighbor algorithm transformed sequence steps incremental algorithm 
algorithm description nearest neighbor algorithm tree traversed depth manner 
complications mentioned section arise performing nearest neighbor search depth traversal overcome maintaining list candidate nearest neighbors 
particular reach leaf node containing query object insert contents node candidate list unwind recursive traversal tree 
candidate list contains members largest distance members query object prune search 
shows nearest neighbor algorithm 
nearestlist denotes list candidate nearest neighbors nearestlist maxdist denotes largest distance query object members nearestlist contains fewer members distance taken 
object inserted nearestlist line existing member replaced list contains members 
particular replace member farthest query object distance nearestlist maxdist 
inserting object nearestlist sure distance query object smaller nearestlist maxdist line kn 
note nearestlist maxdist decreases monotonically objects inserted list replace objects objects closer query object 
nonleaf node child nodes visited order distance query object 
done building list activebranchlist entries node sorting acm transactions database systems june pp 
distance query object see section different ways defining order 
iterate list sorted order recursively invoke child nodes 
distance child query object larger nearestlist maxdist ignore child rest entries activebranchlist 
means object subtree child remaining entries activebranchlist get inserted nearestlist 
queryobject nearestlist nearestlist queryobject return nearestlist nearestlist queryobject node node leaf node object node dist queryobject object nearestlist maxdist insert nearestlist dist queryobject object object endif enddo activebranchlist entries node queryobject activebranchlist child node activebranchlist dist queryobject child nearestlist maxdist nearestlist queryobject child exit loop endif enddo endif nearest neighbor algorithm 
difference nearest neighbor algorithm original presentation treatment activebranchlist 
pruning eliminate entries consideration comparing distances nearestlist maxdist identifies pruning strategies 
section show pruning strategies fact allow pruning 
objects stored outside tree tree leaf nodes contain bounding rectangles object minor optimization line 
compute distance query object bounding rectangle 
distance nearestlist maxdist compute real distance object query object 
object accessed potentially saving disk scenario objects stored outside tree 
recall bounding rectangle object distance distance suggested sorted buffer store nearestlist 
large values manipulation nearestlist started major factor execution time algorithm 
replaced sorted buffer simple priority queue structure sorted decreasing order distance making easy replace farthest object 
acm transactions database systems june pp 
example example algorithm describe finding nearest neighbors query tree 
show steps algorithm contents active nearestlist 
example distances line segments bounding rectangles table 
invocation node denoted nn 
start applying root tree 
describe subsequent invocations algorithm 
line segment elements nearestlist listed distance 
specification nearestlist list maximum distance pruning nearestlist maxdist 
initially nearestlist empty maximum distance 

nn activebranchlist forr 
nn activebranchlist forr 
nn hon nearestlist 
ii 
nn bin nearestlist 
nn activebranchlist forr 
nn distant 
ii 
nn invocation occur distance ofr 
final contents nearestlist isf returned list nearest neighbors ofq 
node ordering metrics ordering sort elements activebranchlist various metrics measuring distances queryobject elements bounding rectangles 
metrics considered mindist minmaxdist 
bounding rectangle node mindist minimum possible distance object subtree rooted minmaxdist maximum distance object subtree rooted guaranteed minimum maximum distances object 
mindist min maxdist calculated geometry position size bounding rectangle node require examining actual contents precise definition follows 
mindist distance closest point boundary necessarily corner minmaxdist distance closest corner adjacent corner farthest shows examples calculation mindist minmaxdist shown solid broken line respectively 
notice bounding rectangle distance distance accounting value minmaxdist equal opposite true 
sense orderings represent optimistic mindist pessimistic minmaxdist choice 
see observe minimum bounding rectangles order increasing value mindist mindist mindist best contains object distance close mindist value dist mindist need hold may contain object closer ifr order increasing minmaxdist value hand worst case object nearest distance minmaxdist larger minmaxdist 
experiments reported showed ordering activebranchlist mindist consistently performed better minmaxdist 
confirmed experiments include acm transactions database systems june pp 
example mindist solid line minmaxdist broken line bounding rectangle distance object bounded mindist minmaxdist 
notice point closer point case 
result section describes experimental findings 
suspect indicates optimism inherent mindist usually provides better estimate distance nearest object pessimism inherent minmaxdist order general lead nearest object earlier activebranchlist 
assume activebranchlist ordered mindist 
fact algorithm depends discuss section 
metrics uses regardless ordering activebranchlist 
represents minimum distance object bounding rectangle provides means pruning nodes search bound maximum distance available 
hand bounding rectangle minmaxdist upper bound distance object nearest clear minmaxdist help pruning search objects closer elements positions higher minmaxdist values 
bounds distance closest element property limited value useful seeking nearest neighbor 
pruning strategies mentioned algorithm employs set pruning strategies prune entries activebranchlist entries processed 
classes pruning strategies identified termed downward pruning upward pruning 
downward pruning entries activebranchlist eliminated prior processing nodes entering loop line 
upward pruning entries activebranchlist eliminated processing node returning recursive call line 
pruning strategies discussed said applicable downward pruning upward pruning 
discuss pruning strategies turn show sufficient combination upward downward pruning strategy downward pruning 
allows pruning entry activebranchlist bounding rectangle mindist minmaxdist bounding rectangle activebranchlist 
pointed minmaxdist pruning limited value useful 
may appear pruning strategy upward pruning line 
condition checked recursive call statement upward downward pruning 
acm transactions database systems june pp 
strategy prunes object dist minmaxdist bounding rectangle 
strategy applicable 
strategy claimed downward pruning inclusion somewhat puzzling help pruning nodes search 
possible authors intended strategy prune objects leaf nodes 
appear particularly fruitful requires objects accessed distances calculated 
possible explanation inclusion strategy discard nearest object subtree activebranchlist processed 
purpose clear better candidate replace object anyway 
strategy prunes node activebranchlist mindist nearestlist maxdist 
applicable value downward upward pruning 
note strategy explicitly labeled downward pruning strategy downward pruning noted 
particular entering loop line eliminate entries activebranchlist distances larger nearestlist maxdist pruning occur nearestlist contains entries 
recalling strategy applicable shown case applying strategy upward pruning eliminates bounding rectangles applying strategy downward pruning 
see bounding rectangle activebranchlist smallest min maxdist value 
strategy prune entry activebranchlist bounding rectangle mindist minmaxdist 
strategy prune entry activebranchlist preceding regardless ordering 
activebranchlist ordered min maxdist clearly holds mindist minmaxdist 
ordered nodes preceding mindist values smaller values smaller minmaxdist 
see entries pruned activebranchlist strategy processing node corresponding particular point dist minmaxdist candidate nearest object follows directly definition minmaxdist 
strategy dist applied active prune entries strategy minmaxdist 
fact eliminated strategies interested finding neighbors implies minmaxdist necessary pruning involved strategy 
assuming minmaxdist node ordering cpu cost algorithm reduced compute minmaxdist value bounding rectangle especially important minmaxdist expensive compute mindist 
observe really need distinguish downward upward pruning sense need explicitly remove items activebranchlist 
just test element activebranchlist turn comes 
activebranchlist ordered mindist prune element terminate computation level remaining elements larger mindist values 
exactly statement line 
transformation section show nearest neighbor algorithm transformed incremental algorithm result identical tree incremental algorithm 
discussion reveals main difference algorithms control structure nearest neighbor algorithm fragmented nodes path root current node specified list invocation algorithm incremental nearest neighbor algorithm employs unified control structure embodied priority queue 
acm transactions database systems june pp 
recall tree nearest neighbor algorithm traverses tree depth manner 
keeps track state traversal nodes bounding rectangles process activebranchlist level note node active level time 
addition original formulation assuming sorted buffer implementation keeps track distances query object data objects seen nearestlist sorted increasing order distance query object 
output nearest neighbors occurs traversal tree traversed entirety subject pruning nodes activebranchlist 
want transform tree nearest neighbor algorithm incremental algorithm need keep track nodes tree encountered inserted activebranchlist processed 
elements various instances activebranchlist letb denote union 
assume elements removed nearestlist processed 
aid itis possible tell element nearestlist reported nearest neighbor particular case closer closest node objects encountered subtrees nodes global knowledge embodies possible report nearest neighbor unwound recursive traversal algorithm root node tree know subtrees root 
nearest neighbor modified maintain global unprocessed node list enabling report nearest neighbors incrementally 
process efficient keeping sorted order distance leaves open question efficiently add remove nodes having modification go change control structure 
particular keeping strict depth traversal list guide traversal node closest taken node process 
node processed deleted nonleaf node processed entries added note described sorted mindist order 
ordered minmaxdist ordering disadvantage node nearest immediately accessible 
furthermore observe penalty choosing process wrong node far penalty doing nearest algorithm done inspect node entries traversing entire subtree subject pruning course 
note transformation possible allow unbounded element nearestlist farthest longer plays role 
course means nearestlist longer bounded total number objects tree 
entire process performed easily merging nearestlist list called 
increasing order distance able preserve role previous contents activebranchlist nodes pruned greater distances th nearest object 
subtrees traversed outputting nearest neighbors 
observe transformed algorithm mindist distance metric rendering moot issue min maxdist metric 
transformed algorithm general achieve pruning nodes original nearest neighbor algorithm 
conclude discussion nearest neighbor algorithm pointing transformation yields algorithm equivalent incremental algorithm earlier organized priority queue 
acm transactions database systems june pp 
experimental results order evaluate tree incremental nearest neighbor algorithm denoted inn compared result tree nearest neighbor algorithm denoted nn distance browsing section 
measured incremental cost inn cost obtaining st neighbor obtained th neighbor section 
varying number objects browsed able see true advantage method computing nearest neighbors incrementally committing predetermined number nearest neighbors case nearest neighbor algorithm 
remember know advance objects browsed finding desired object 
compare inn nn computing result nearest neighbor query section 
studies performed small numbers neighbors common situation distance browsing useful 
treat case large number neighbors section 
experiments mentioned measured execution time disk behavior number distance computations representative maps 
order discern size maps factor performed experiments size varied section 
addition extreme case experimented large data set section 
section report maximum size priority queue experiments sections 
data sets experiments consisted line segments real world data randomly generated data 
real world data consisted data sets tiger line file see 
howard county line segments 

water washington dc metro area line segments 

prince george county line segments 

roads washington dc metro area line segments 
randomly generated line segment maps constructed generating random infinite lines manner independent translation scaling coordinate system 
lines clipped map area obtain line segments subdivided intersection points line segments line segments meet endpoints 
note random maps necessarily model real world maps perfectly 
particular construction random maps cover entire square area case real maps tiger line file county maps 
furthermore random maps tend uniform real maps tend dense clusters small line segments mixed sparsely covered areas 
randomly generated maps capture important features real maps low probability line segments meeting point enabled run experiments wide range map sizes maps similar characteristics 
experiments differ hilbert packed tree tree 
hilbert packed tree static structure constructed applying peano hilbert space ordering spatial objects basis centroids 
leaf nodes tree built filling objects nonleaf nodes built top bounding rectangles computed nodes 
notice conventional tree node splitting rules applied construction hilbert packed tree node filled capacity hilbert packed tree construction algorithm 
interested dynamic environments chose tree tree experiments noted 
acm transactions database systems june pp 
real world data sets tiger line file howard water pg roads 
data sets small fit main memory modern computers experiments reported section 
disk tree structure employed buffers store limited number tree nodes 
believe results scale large data sets 
fact employ buffered added possibility requested disk block disk cache operating system buffers complicates comparison algorithms 
extremes requested disk block memory leads disk activity 
query fixed number neighbors incremental nearest neighbor inn algorithm shows improvement nearest neighbor algorithm nn case entire data sets resides memory may slower seen small random data sets 
mainly due overhead incurred priority queue operations 
extreme inn algorithm show advantage requests fewer tree nodes objects nn algorithm 
experiment ran multiple queries data set number neighbors 
done query point tested sure timing results meaningful timing granularity system 
tree implementation utilizes buffered means query may access disk blocks loaded buffer earlier queries sequence 
feel reasonable choice buffers acm transactions database systems june pp 
small compared data size clearing prior query affected timing results 
real world scenario user execute query map 
measures comparing algorithms execution time tree node frequently referred disk object distance calculations 
tree node reported number accesses may correspond actual disk nodes database system buffers 
number accesses predicts relative performance actual disk reasonably 
furthermore saving due buffering show reduced execution time 
disk characterization 
experiments conducted maps embedded grid capacity tree node 
order simplify analysis execution time results chose store actual line segments tree leaf nodes just bounding boxes 
organization external object storage large effect performance introduces extra variable comparison algorithms 
query points uniformly distributed space covered map data distance functions measure distances lines bounding rectangles query points squared euclidean metric order avoid computing square roots 
experiments run sufficiently obtain consistent results different query point time 
execution times reported milliseconds query include cpu time consumed algorithm system calls 
sparcstation model rated specint specfp gnu compiler set maximum optimization 
cumulative cost distance browsing section focus distance know advance neighbors needed query terminates 
case need reapply nearest neighbor algorithm value changes 
contrast case incremental nearest neighbor algorithm need algorithm obtain just neighbor nearest 
experiments map prince george county denoted pg figures randomly generated line map similar size containing lines denoted 
included random line map see performance affected unknown characteristics pg map 
figures show measure cumulative cost distance browsing database finding neighbors incrementally 
number ways nearest neighbor algorithm perform distance browsing 
tests shown figures methods execute nn time need new neighbor 
invoke nn neighbors 
example case cost computing th th neighbors cost computing th neighbor requires invoking nn algorithm 
figures clear incremental nearest neighbor inn algorithm distance browsing significantly outperforms simulating incremental access nn algorithm 
fact difference quickly order magnitude 
figures logarithmic scale axis order bring relative scale 
differences great order simplify presentation include results nn algorithm pg map results random data similar 
method choosing value performing distance browsing nn algorithm best larger values example better multiply time algorithm re invoked 
addition nn algorithm adapted suitable distance browsing 
particular finding nearest neighbors determining find neighbors distance th nearest acm transactions database systems june pp 
execution time ms log scale inn pg inn nn 
pg nn 
pg number nearest neighbors cumulative execution time distance browsing 
object distance calculations log inn pg inn nn 
pg nn 
pg number nearest neighbors cumulative object distance calculations distance browsing 
tree node disk os log scale inn pg inn nn 
pg nn 
pg number nearest neighbors cumulative tree node disk distance browsing 
execution time relative inn prune restart prune restart number nearest neighbors logscale execution time nn relative inn distance browsing nn approach possible 
neighbor minimum distance nn algorithm re invoked set nearest neighbors excluded search 
minimum distance prune search way described minimum distance inn algorithm section 
complications arise objects distance th nearest neighbor 
best way resolve return neighbors distance means obtain neighbors requested 
compare execution time adapted nn algorithm labelled prune distance browsing execution time inn algorithm 
show result unmodified algorithm restart search scratch nn algorithm re invoked labelled restart 
show results real world data set pg identical random data set 
different starting values shown parentheses 
time nn algorithm re invoked doubled 
shows nn algorithm re invoked usually takes twice nearly times long inn algorithm 
prune variant nn algorithm pay large number neighbors needed experiments 
reason variant takes longer smaller number neighbors nodes get pruned offset cost node distance acm transactions database systems june pp 
computations node compute distances minimum maximum just minimum 
observation nn approach highly sensitive initial value initial value better depends neighbors need know advance distance browsing 
spikes curves occur nn algorithm re invoked additional time higher values spike low point neighbors computed reason slope curve decreases spike range spike low point cost nn approach remains constant neighbors computed cost inn approach increases gradually compute additional neighbors 
note absolute low point curves corresponds case number neighbors needed happens equal initial value respectively 
values nn algorithm slower inn algorithm slower slower 
incremental cost distance browsing results experiments conducted section show total cost distance browsing retrieving th neighbor 
inn implement browsing step requires examine just neighbor regardless browsing steps executed 
contrast nn distance browsing requires examine neighbors browsing steps executed 
section compare algorithms terms cost browsing step incremental cost 
shown figures 
inn algorithm incremental cost seen fluctuate somewhat order magnitude cost nn algorithm neighbor obtained 
shown holds values logarithmic scale axis fluctuation cost incremental algorithm seen clearly 
evaluated incremental execution time neighbors pg map 
interestingly incremental execution time clusters average ms neighbors 
agreement results discuss section find average execution time neighbor ms retrieving neighbors pg maps 
see map incremental execution time remarkably close constant small fraction objects retrieved pg map neighbors map size 
tree node disk os incremental algorithm inn order magnitude better nn neighbor 
inn appears decreasing neighbors levels neighbors 
graph step function number node accesses averaged queries 
object distance calculations incremental algorithm inn order magnitude better nn neighbors 
improvement approaches orders magnitude neighbors continues manner larger values shown 
average number distance calculations performed incremental invocation seen decreasing 
continues neighbors retrieved neighbors 
inn quickly reaches stage accessing object reported neighbor 
spike prune occurs neighbors 
reason occasionally requesting nearest neighbors sixth nearest neighbor distance fifth nn algorithm need re invoked want obtain sixth neighbor true second spike neighbors 
acm transactions database systems june pp 
execution time ms log scale inn pg nn pg inn nn number nearest neighbors incremental execution times distance browsing 
object distance calculations log inn pg nn pg inn nn number nearest neighbors incremental object distance calculations distance browsing 
nearest neighbor queries tree node disk os log scale inn pg nn pg inn nn number nearest neighbors incremental tree node disk distance browsing 
execution time milliseconds inn pg nn pg inn nn number nearest neighbors execution time neighbor query 
consider cost incremental nearest neighbor algorithm solve 
words browsing database basis distance obtaining neighbor time address related problem finding neighbors knew advance neighbors need 
interesting see performance penalty incurred solving classical problem incremental algorithm approaches nn algorithm obtain neighbors 
ran sequence tests manner reported sections results shown figures 
figures observe inn algorithm leads sacrifice performance 
fact incremental algorithm outperforms nearest neighbor algorithm maps values addition experiments mentioned ran nearest neighbor queries values size data set 
results experiments reported figures cost measures divided number nearest neighbors reporting cost neighbor 
incremental nearest neighbor algorithm value close average incremental cost smallest values small cost retrieving neighbor dominates cost 
dividing cost measures possible distinguish cost measures large values difficult 
figures axis uses logarithmic scale 
acm transactions database systems june pp 
execution time see algorithms similar growth patterns nn somewhat slower inn pg 
improvement inn nn modest values reveals difference widens grows larger pg 
values small improvement inn nn 
note performance inn maps similar performance nn worse pg map map 
observation holds cost measures 
suggests inn sensitive nn distribution data objects 
large values may ask better simply calculate distances entire database sort distance 
objects ranked inn algorithm nn algorithm compute distances objects database 
question reduces overhead inn algorithm computing distances nodes priority queue exceeds cost sorting distance values computed 
interestingly pg map inn algorithm rank objects faster computing distances sorting nn algorithm little slower sorting approach 
course result generalized depends numerous factors size data set spatial index spatial objects stored directly leaf nodes tree external object table 
tree node disk os see inn better nn rate growth similar appears linear low values fact pattern held values see 
figures show value inn achieves pruning input tree nn 
partially explains better execution time performance 
values ranging inn accesses fewer nodes pg largest difference occurring maps 
tree node disk os inn pg nn pg inn nn number nearest neighbors tree node disk neighbor query 
object distance calculations inn pg nn pg inn nn number nearest neighbors object distance calculations nearest neighbor query 
object distance calculations see inn algorithm outperforms nn algorithm 
shows holds values ranking map objects case number distance calculations equals number map objects cases pruning objects nodes possible 
shapes curves seen similar 
surprising realize number distance calculations proportional number tree leaf nodes accessed leaf nodes tree greatly outnumber nonleaf nodes 
shows fraction total execution time attributed disk operations acm transactions database systems june pp 
execution time ms logscale inn pg nn pg inn nn log number nearest neighbors execution time neighbor nearest neighbor query 
tree node disk os logscale inn pg nn pg inn nn log number nearest neighbors tree node disk neighbor nearest neighbor query 
experiments 
compute recording node accesses performed execution algorithms measuring time needed access nodes 
shows fraction time spent inn algorithm doing relatively constant starts decrease large number neighbors 
contrast fraction time spent nn algorithm doing larger variation initially increasing rapidly decreasing significantly number neighbors needed increases 
fact eventually fraction time spent doing nn algorithm considerably spent inn algorithm number neighbors increases inn algorithm efficient cpu cost perspective 
may due part fact large number neighbors priority queue inn algorithm considerably smaller nearestlist maintained nn algorithm discussed section seen 
object distance calculations logscale inn pg nn pg inn nn log number nearest neighbors object distance calculations neighbor nearest neighbor query 
results varying data size cost relative total cost inn pg nn pg inn nn log number nearest neighbors fraction total execution time taken disk os computing neighbor query 
previous sections investigated performance algorithms varying number neighbors distance browsing computing nearest neighbors similarly sized data sets 
important performance algorithms remain reasonable size data set increased 
verify case tested performance inn nn random acm transactions database systems june pp 
real world map data 
experiments showed relationships algorithms cumulative incremental costs distance browsing computing nearest neighbors experiments reported sections provided maps nontrivial size 
particular confirmed superiority inn nn 
interest saving space show results 
rest section focus relative behavior algorithms finding nearest neighbor 
operation important step distance browsing saw section execution time dominates cost distance browsing small values figures show performance algorithms finding nearest neighbor 
axis log wheren number line segments 
real world maps appear order described left right howard county water prince george county roads 
random maps tested contained line segments 
execution time see inn algorithm faster maps nn took time real world maps time randomly generated maps 
exceptions smallest randomly generated maps 
explained partly fact maps small fit tree node buffer partly fact small sizes gave room improvement see figures 
larger values inn better nn data sets 
randomly generated maps similar characteristics rate growth execution time seen nearly identical algorithms 
fact rate growth appears nearly logarithmic number line segments recall axis uses log scale 
execution times real world maps correlate remarkably execution times random maps comparable size 
execution time milliseconds inn real nn real inn random nn random log number line segments execution time finding neighbor 
tree node disk os inn real nn real inn random nn random log number line segments tree node disk finding neighbor 
tree node disk os find relative behavior algorithms inn better nn rate growth similar 
rate growth appears logarithmic number line segments 
compares results reported nn observed number tree node accesses grew linearly height tree 
experiments exact agreement observation asymptotically observations equivalent trees height tree grows logarithmically number objects 
object distance calculations inn performs better nn 
acm transactions database systems june pp 
object distance calculations inn real nn real inn random nn random log number line segments object distance calculations finding neighbor 
results large data sets execution time ms logscale inn nn log number nearest neighbors execution time large data set 
admittedly data sets experiments reported moderate size 
largest data set spatial index occupies approximately mb disk space small fit main memory modern computers 
experiments small amount main memory buffers nodes size priority queue remained small compared data size kb worst case experiments section size map files 
believe results hold larger data sets data sets larger size main memory 
order verify claim conducted experiment randomly generated data set lines 
prohibitively slow build tree large data set built tree occupied mb 
level fan amount buffering nodes previous experiments better larger fan buffer sizes large data set 
incidentally algorithms performed poorly hilbert packed tree tree data set 
appears due greater amount node overlap hilbert packed tree 
incremental nearest neighbor algorithm proved sensitive level node overlap due superior pruning tree nodes 
figures show results experiments large map consisted nearest neighbor queries values size data set 
unfortunately able run nn algorithm memory hold neighbor list neighbors 
contrast inn algorithm priority queue contained elements number neighbors 
speedup execution time inn nn ranged 
nn accessed times nodes performed times distance calculations inn 
priority queue size section showed worst case data objects inserted priority queue incremental nearest neighbor algorithm 
experiments priority queue remained modest size 
size priority queue affects performance queue operations algorithm execution 
large queue requires disk implementation acm transactions database systems june pp 
tree node disk os logscale inn nn log number nearest neighbors node disk os large data set 
object distance calculations logscale inn nn log number nearest neighbors object distance calculations large data set 
slowing algorithm 
applications maximum queue size remains relatively modest permits memory data structure queue 
example consider shows maximum size queue computing nearest neighbor data sets section 
notice worst case situation described step distance browsing query object objects inserted queue determining nearest neighbor 
evident maximum queue size grows remarkably slowly number line segments increases 
results random maps suggest growth logarithmic number line segments 
shows maximum size priority queue incremental nearest neighbor algorithm distance browsing operations maps section ranged size map 
axis logarithmic 
see maximum queue size grows extremely slowly 
note relatively small worse case comparison sum number data objects tree nodes comparably sized maps theoretical maximum 
reaches value priority queue needed incremental nearest neighbor algorithm smaller priority queue needed store sorted buffer nn algorithm 
similar picture emerged large map section size priority queue smaller fraction map size worst case 
priority queue items real random log number line segments maximum queue size finding nearest neighbor 
priority queue items logscale inn pg inn nn log number nearest neighbors maximum queue size wide range acm transactions database systems june pp 
high dimensional space pointed incremental nearest neighbor algorithm independent dimensionality data objects equally applicable data embedded low dimensional high dimensional spaces 
unfortunately difficult effectively index high dimensional data nearest neighbor search costly 
section address issues arise 
hard reason arbitrary data distributions draw uniformly distributed data 
high dimensional data arises number current applications including multimedia databases data warehouses information retrieval 
usually data limited points general objects arise 
example application leads high dimensional data color histograms image databases allow searching images specific color combination colors similar query image 
colors image described dimensional vectors element encodes intensity particular range colors rgb values 
compare closeness sets colors images complex distance function involving matrix multiplication 
distance function nearest neighbor search image database find image closest color query image 
number dimensions color histograms typically 
applications number dimensions higher 
spatial indexing structures high dimensions 
tree example degenerate dimensions higher :10.1.1.102.7240
specifically happens range queries small query windows index pages read reading expensive sequential scan data 
indexing structures proposed address issue example tree lsd tree tree lsd tree respectively :10.1.1.102.7240
provide speedup compared sequential scan dimensions 
approach taken speed access point data high dimension map points space lower dimension case incremental nearest lower dimensional space 
order guarantee accuracy result output algorithm filtered distances corresponding higher dimensional points 
approach abandon goal indexing data points space occupancy properties distance metric employed see discussion metric space model section 
index method distance employed algorithm applicable :10.1.1.145.5268
fact nearest neighbor algorithm similar algorithm uses priority queue nodes guide traversal index 
euclidean distance metric nearest neighbor search region section spherical 
hand node regions types spatial index structures hyper rectangular shape 
effect making nearest neighbor search expensive points accessed necessary 
see true consider dimensions areas square circle radius respectively 
ratio area circle area square 
dimensions ratio volume sphere volume cube dimensions corresponding ratio hypersphere hypercube 
general ratio volume hypersphere circumscribed hypercube decreases exponentially number dimensions 
intuitively reason number corners hypercube grows exponentially dimension 
effect direct consequence nearest neighbor search euclidean distance metric 
see assume uniformly distributed data points inside hypercube radius search region radius centered inside hypercube hypercube represents smallest bounding box set hyper rectangular leaf node regions intersect search region 
proportion data points inside search region decreases exponentially number acm transactions database systems june pp 
dimensions dimensions inside search region 
large number data points inside hypercube outside search region represent wasted effort nearest neighbor search 
order alleviate effect spatial index structures hyperspheres node regions proposed nearest neighbor applications higher dimensions 
lead higher level overlap nodes hyperrectangles compromise shapes formed intersections hyperspheres hyperrectangles essentially smoothing corners hyperrectangles 
section pointed objects priority queue contained leaf nodes intersected boundary search region similarly nodes priority queue 
number dimensions grows ratio number leaf nodes intersected boundary search region number leaf nodes intersected interior search region tends grow 
size priority queue tends grow number dimensions 
uniformly distributed points spread evenly leaf nodes leaf node covers amount space shown ratio grows exponentially number dimensions 
true search region leaf node regions hypercubes chessboard metric 
course major significance number desired neighbors large volume search region depends number neighbors 
problems arising operating high dimensional spaces alleviated relaxing requirement nearest neighbors computed exactly 
goal report neighbors quickly possible 
incremental nearest neighbor algorithm object slightly farther query object node algorithm process reporting high dimensional space seen may cause lot extra 
report nearest neighbor distance larger particular suppose object priority queue closest andn node queue closest propose report approximate nearest neighbor dn nonnegative constant 
leads definition approximate nearest neighbor conforms distance th nearest neighbor distances objects returned approximate nearest neighbor search larger obviously get exact result larger exact result change required incremental nearest neighbor algorithm approximate sense key nodes priority queue :10.1.1.15.3125
specifically node dn key dn 
significant reduction node accesses results finding approximate nearest neighbors opposed exact nearest neighbors :10.1.1.15.3125
relatively high probability result exact approximate cases 
example approximate nearest neighbor search dimensions meaning relative error distance allowed speedup execution time order exact nearest neighbor search average relative error true nearest neighbor half time :10.1.1.15.3125
concluding remarks detailed comparison approaches browsing spatial objects tree basis distances arbitrary spatial query object 
shown incremental algorithm inn significantly outperforms terms execution time tree node disk object distance calculations solution nearest neighbor algorithm nn 
true nn approach optimized application carefully choosing increments previous search re algorithm described incremental accesses set nodes incremental nearest neighbor algorithm modified described acm transactions database systems june pp :10.1.1.15.3125:10.1.1.15.3125
sults pruning nn algorithm re invoked 
incremental approach superior performance applied problem computing nearest neighbors query object 
experiments confirm inn algorithm achieves higher level pruning nn algorithm 
important reduces amount tree node disk number distance calculations combined account major portion execution time 
data sets larger superiority inn algorithm pronounced 
experimental results reasonably close agreement rudimentary analysis inn algorithm predicts number node accesses log number neighbors size data set 
superior performance algorithm experimental study surprising prove informally step execution incremental nearest neighbor algorithm optimal respect spatial data structure employed 
practical standpoint means minimum number nodes visited order report object 
words reporting kth neighbor ok query object algorithm accessed nodes lie distance ok adaptation algorithm tree added benefit minimum number objects accessed objects minimum bounding rectangles lie distance ok experiments reported section tree variant spatial objects stored directly leaf nodes tree 
practical especially complex objects polygons 
alternative store objects external file case leaf nodes store bounding boxes spatial objects pointers objects 
performed additional experiments maps section stored tree inn variant experiments revealed larger advantage incremental nearest neighbor algorithm nearest neighbor algorithm typically 
primarily inn algorithm accessed fewer data objects purpose calculating distances query object nn algorithm 
nn algorithm typically accessed times objects inn algorithm low values twice values high map size 
reducing number object accesses object distance calculations incremental algorithm greater effect terms reducing execution time complex spatial objects polygons 
worst case scenario leaf nodes spatial data structure accessed see discussion section 
contrast incremental algorithm variant tree implementation spatial objects stored external tree alleviates worst case described making bounding rectangles leaf nodes enabling avoid accessing data objects disk particular original version algorithm spatial index assumed bounding rectangles meant worst case data objects accessed disk order measure distances query object 
bounding rectangles stored tree leads considerably efficient conceptually different incremental algorithm trees bounding boxes pruning devices reduce disk accessing spatial descriptions objects 
involves comparing behavior incremental nearest neighbor algorithm different spatial data structures pmr quadtrees trees trees adapting algorithm classes index structures distance indexes :10.1.1.145.5268
wish investigate decided report results experiments spatial objects stored leaf nodes external tree 
done part organization external object storage large effect performance introduces extra variable comparison algorithms 
recall footnote decided report experiments spatial objects stored leaf nodes external tree 
acm transactions database systems june pp 
algorithm large data sets high dimensional spaces priority queue may stored disk 
aoki 
generalizing search generalized search trees 
proceedings th international conference data engineering pages orlando fl feb 
aref samet 
uniquely reporting spatial objects operation comparing spatial data structures 
proceedings fifth international symposium spatial data handling pages charleston sc august 
aref samet 
estimating selectivity factors spatial operations 
optimization databases fifth international workshop foundations models languages data objects pages austria september 
technical report informatik bericht technische 
arya mount netanyahu silverman wu :10.1.1.15.3125
optimal algorithm approximate nearest neighbor searching 
proceedings fifth annual acm siam symposium discrete algorithms pages arlington va january 
revised version www cs umd edu mount 
becker ting 
rule optimization query processing extensible geometric database system 
acm transactions database systems june 
beckmann kriegel schneider seeger 
tree efficient robust access method points rectangles 
proceedings acm sigmod conference pages atlantic city nj june 
bentley 
multidimensional binary search trees associative searching 
communications acm september 
berchtold hm keim kriegel 
cost model nearest neighbor search high dimensional data space 
proceedings th acm sigact sigmod sigart symposium principles database systems pods pages tucson az may 
berchtold keim :10.1.1.102.7240
kriegel 
tree index structure high dimensional data 
proceedings nd international conference large data bases pages mumbai india september 
bern 
approximate closest point queries high dimensions 
information processing letters february 
brin 
near neighbor search large metric space 
dayal gray nishio editors proceedings st international conference large data bases pages zurich switzerland september 
broder 
strategies efficient incremental nearest neighbor search 
pattern recognition january 
burkhard keller 
approaches best match file searching 
communications acm april 
acm transactions database systems june pp 
ciaccia patella 
tree efficient access method similarity search metric spaces 
jarke carey dittrich lochovsky loucopoulos jeusfeld editors proceedings rd international conference large data bases pages athens greece august 
comer 
ubiquitous tree 
acm computing surveys june 
eastman 
partially specified nearest neighbor searches trees 
information processing letters september 
samet 
orthogonal polygons bounding structures filter refine query processing strategies 
scholl editors advances spatial databases fifth international symposium pages berlin germany july 
springer verlag lecture notes computer science 
faloutsos lin 
fastmap fast algorithm indexing data mining visualization traditional multimedia datasets 
proceedings acm sigmod conference pages san jose ca may 
frank barrera 
data structure geographic information systems 
buchmann nther smith wang editors design implementation large spatial databases symposium pages santa barbara ca july 
springer verlag lecture notes computer science 
fredman sedgewick sleator tarjan 
pairing heap new form heap 
algorithmica 
friedman bentley finkel 
algorithm finding best matches logarithmic expected time 
acm transactions mathematical software september 
fukunaga narendra 
branch bound algorithm computing nearest neighbors 
ieee transactions computers july 
nther 
spatial database indices large extended objects 
proceedings seventh international conference data engineering pages kobe japan april 
guttman 
trees dynamic index structure spatial searching 
proceedings acm sigmod conference pages boston ma june 
hafner sawhney equitz flickner niblack 
efficient color histogram indexing quadratic form distance functions 
ieee transactions pattern analysis machine intelligence july 

distance scan algorithm spatial access structures 
proceedings second acm workshop geographic information systems pages gaithersburg md december 

lsd tree access structure feature vectors 
proceedings th ieee international conference data engineering pages orlando fl february 
widmayer 
lsd tree spatial access multidimensional point non point data 
apers wiederhold editors proceedings th international conference large data bases pages amsterdam netherlands august 
acm transactions database systems june pp 
samet 
ranking spatial databases 
egenhofer herring editors advances spatial databases fourth international symposium pages portland august 
springer verlag lecture notes computer science 
hoel samet 
efficient processing spatial queries line segment databases 
nther schek editors advances spatial databases second symposium pages zurich switzerland august 
springer verlag lecture notes computer science 
kamel faloutsos 
packing trees 
proceedings second international conference information knowledge management pages washington dc november 
kamel faloutsos 
hilbert tree improved tree fractals 
jarke zaniolo editors proceedings th international conference large data bases pages santiago chile september 
kanal 
improved branch bound algorithm computing nearest neighbors 
pattern recognition letters january 
agrawal singh 
similarity searching dynamic databases 
proceedings acm sigmod conference pages seattle wa june 
katayama satoh 
sr tree index structure high dimensional nearest neighbor queries 
editor proceedings acm sigmod conference pages tucson az may 
korn sidiropoulos faloutsos siegel :10.1.1.37.9993
fast nearest neighbor search medical image databases 
proceedings nd international conference large data bases pages mumbai india september 

kriegel schmidt seidl 
similarity search shape approximation 
scholl editors advances spatial databases fifth international symposium pages berlin germany july 
springer verlag lecture notes computer science 
lindenbaum samet 
probabilistic analysis trie sorting large collections line segments 
computer science department tr university maryland college park md april 
lomet salzberg 
robust multi attribute search structure 
proceedings fifth ieee international conference data engineering pages los angeles ca february 
dewitt 
equi depth histograms estimating selectivity factors multidimensional queries 
proceedings acm sigmod conference pages chicago il june 
murphy selkow 
efficiency trees finding nearest neighbors discrete space 
information processing letters november 
nelson samet 
consistent hierarchical representation vector data 
computer graphics august 
proceedings siggraph conference dallas tx august 
bureau census 
tiger line files 
washington dc 
robinson 
tree search structure large multidimensional dynamic indexes 
proceedings acm sigmod conference pages ann arbor mi april 
acm transactions database systems june pp 
roussopoulos kelley vincent 
nearest neighbor queries 
proceedings acm sigmod conference pages san jose ca may 
roussopoulos 
direct spatial search pictorial databases packed trees 
proceedings acm sigmod conference pages austin tx may 
samet 
design analysis spatial data structures 
addison wesley reading ma 
seidl 
kriegel 
optimal multi step nearest neighbor search 
proceedings acm sigmod conference pages seattle wa june 
selinger astrahan chamberlin lorie price 
access path selection relational database management system 
proceedings acm sigmod conference pages boston ma june 
sellis roussopoulos faloutsos 
tree dynamic index multi dimensional objects 
kent editors proceedings th international conference large databases pages brighton england september 
computer science department university maryland college park md tr 
sproull 
refinements nearest neighbor searching dimensional trees 
algorithmica 
uhlmann 
satisfying general proximity similarity queries metric trees 
information processing letters november 
wang shasha 
query processing distance metrics 
mcleod sacks davis schek editors proceedings th international conference large databases pages brisbane australia august 
white jain 
algorithms strategies similarity retrieval 
technical report vcl visual computing laboratory university california san diego ca 
vision ucsd edu papers 
white jain 
similarity indexing ss tree 
proceedings th ieee international conference data engineering pages new orleans la february 
