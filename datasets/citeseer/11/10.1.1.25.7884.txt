un ver sced tool dynamic modelling object systems kai koskimies syst department computer science university tampere report university tampere department computer science series publications july sced tool dynamic modelling object systems kai koskimies syst university tampere department computer science box fin tampere finland isbn issn sced tool dynamic modelling object systems kai koskimies syst department computer science university tampere box fin tampere finland cs uta fi laboratory software engineering tampere university technology box fin tampere finland dynamic modeling object oriented software scenario diagrams descriptions particular uses system terms message flow objects belonging system 
diagrams help designer specify general behavior objects state machines collections methods 
techniques discussed building automated tool support dynamic modeling aspects object oriented software development 
discussed techniques include synthesis state machines method descriptions basis scenario diagrams constructing scenario diagrams support existing state machines visualizing run time behavior object system extracting state machines objects running systems consistency checking scenario diagrams state machines automated simplification state machines omt notation automated layout state machines 
basic problem software design derive executable software components requirements specification process supported computer 
object oriented approach provides common paradigm software development process analysis implementation 
allows smooth shift phase possible wide spectrum tools software development 
current object oriented case tools support drawing various graphical notations modeling application different perspectives consistency checking models storing models repository generating documents code models 
tools facilitate construction graphical models transformation models code level built automation relatively low far actual development process concerned 
object oriented analysis design dynamic modeling aims description dynamic behavior objects variant finite state machine 
example omt rum dynamic model models employed software development models object model describing static relations objects functional model describing data flow processes system 
study raising level automated support dynamic modeling part object oriented software development 
omt method guideline notational basis principle approach tied particular design methodology 
facilities discussed implemented working tool called sced mst mst 
system running ms windows implemented 
assume requirements concerning dynamic behavior system expressed scenarios describing system responds particular sequence external events user interactions 
scenario close concept case jacobson jac case specific way system accomplish identifiable task consisting possibly scenarios 
scenario diagram event trace diagram message sequence chart interaction diagram graphical formulation scenario specifying objects communicate external actors scenario 
object participating scenario represented vertical line event shown horizontal arc sender object receiver 
time flows top bottom 
sced demonstrates ideas discussed incorporated practical tool 
sced consists conventional case components scenario editor state machine editor intelligent component integrating scenarios state machines various mechanisms 
main principles component central topic 
scenario notation employed sced extended omt reasons discussed sequel state machine notation taken omt turn strongly influenced harel statecharts har 
logical structure sced depicted fig 

proceed follows 
section introduces graphical notation scenario diagrams 
sections discuss techniques transforming set scenarios state machine reversely existing state machines generate new scenarios 
section discusses implications useful reverse engineering 
section briefly study problem keeping scenario diagrams state machines consistent 
section discuss simplification algorithms state machines making special graphical notation omt 
section discuss automatic layout algorithms state machines 
concluding remarks section 
scenario diagram sced scenario diagram editor scenario diagram notation sced integrator designer fig 

general structure sced state machine sced state machine editor practical purposes extended rudimentary scenario diagram notation omt various ways see 
comment drawn rounded box stretching concerning selected 
necessary actions events object may perform arbitrary computations sending messages 
actions action box drawn vertical line object executing action 
techniques require designer express conditions known hold certain positions scenario particular object 
normally condition terms attribute values object 
kind condition drawn assertion box form ccitt scenario notation standard ccitt see symbols 
introduce third type box associated single participant state box 
state box gives name particular situation scenario point view certain participant name state object situation 
needed primarily technical reasons design aid convenient designer express assumption object identifiable state particular time position scenario 
technically state boxes necessary expanding conditional repetition constructs discussed 
note state box different assertion box condition may hold states 
fig 

elements sced scenario notation support presentation case single scenario diagram scenario notation extended algorithmic constructs repetition 
call scenario diagram having constructs algorithmic scenario diagram 
note certain object may involved cases algorithmic scenarios full specifications cases usually objects 
general algorithmic scenario diagrams full specifications multi object functions functions defined terms interacting objects 
restricted form conditional construct algorithmic scenario notation applied por jacobson jac associates textual pseudocode ordinary scenario diagrams achieve effect 
sced supports algorithmic scenario diagrams providing structured graphical notation repetition see arbitrary nesting 
algorithmic scenarios interpreted sets ordinary scenarios 
interpretation shown 
note case repetition number iterations number scenarios potentially infinite repetition construct represented scenarios making state box evaluating loop expression executing body object state entering loop object able re execute loop infinitely 
fig 

repeat constructs simple scenarios 
analogously subroutines scenario may consist parts aims characterizations 
instance scenario atm include event sequences checking valid card giving correct password give separate scenarios 
scenario diagrams easier read write adapted notion sced rectangle stretching participants denotes named diagram 
obtain complete scenario diagram boxes simply considered replaced corresponding scenario diagrams 
participants different host scenario 
especially useful requires objects needed rest scenario host scenario smaller vertical event sequence horizontal participants direction 
synthesizing state machines design example scenarios state machines describe dynamic aspects system necessarily share common information 
emphasized scenario instance state machine instance trace set collaborating state machines 
state machine gives complete behavior single object scenario gives single behavior trace complete set objects 
consequently scenario contains information included state machine vice versa 
scenarios state machines complementary notions constructed concert 
section show fact share information exploited developing design tools 
bik biermann krishnaswamy algorithm synthesizing programs example traces 
algorithm actual system able synthesize programs basis examples sequences primitive actions assignments assertions programmer partly graphical interface 
example programmer give examples sequences actions assertions sorting algorithm system generated complete code algorithm 
assertions employed algorithm conditions branching execution 
applied biermann krishnaswamy bk algorithm synthesizing state machines scenarios 
algorithm adaptation discussed detail earlier km summarize main ideas 
trace extracted scenario selecting object object state machine synthesized traversing vertical line object top bottom 
received event regarded assertion event occurred sent event regarded primitive action cause event terms bk algorithm 
lower bound number states resulting state machine required 
number different actions state action clearly lower bound 
algorithm maps actions states assertions transitions starting trace 
nondeterministic state results algorithm backtracks previous position freedom associating action state takes untried choice 
point states needed algorithm backtracks 
backtracking possible state machine states achieved 
process repeated allowed number states algorithm completed actions associated states 
bk algorithm works incrementally scenario fused existing state machine algorithm 
follows directly theorem bk algorithm produces minimal respect number states state machine capable acting role selected object scenarios 
due potential backtracking algorithm exponential time complexity worst case problem practice real life state machines seldom require heavy backtracking 
vast majority practical examples encountered synthesis time second 
fact automatic layout algorithm discussed section usually time consuming linear time complexity 
original bk algorithm assertions known hold primitive actions trace 
algorithm applied scenario diagrams aspect diagrams interpreted assertions 
viewed received events respect selected object assertions appropriate active objects incoming events basis control 
scenarios useful passive objects dynamic behavior characterized set operations state machine 
sequel show operation descriptions automatically synthesized scenarios 
note algorithm operation state machine transitions associated guards conditions events fact close conventional flow chart 
state guards associated leaving transitions nonoverlapping cover possible cases algorithm able continue deterministically cases 
passive objects event arcs scenario diagram correspond operation calls returns 
consider particular object scenario 
operation call object shown arriving call arc leaving arcs call arc corresponding leaving return arc internal calls operations objects arriving arcs returns calls simplicity ignore possibility object called execution operation 
trace operation call consists internal calls shown leaving arcs 
arriving return arcs call insignificant return arcs omitted scenario diagram variations gam 
received events act assertions synthesizing operations passive objects control information provided assertion boxes 
primitive statements operation calls action boxes 
assertion boxes action boxes incorporated synthesis algorithm described simple way assertion regarded event sender action regarded event receiver 
results natural representation assertion label transition action state activity 
extensions scenario diagram notation cause major problems synthesizing state machines 
state box taken account state identifier name corresponding state state machine 
algorithm refuses join states different names 
simply expanded synthesis 
condition repetition constructs likewise dissolved rules 
sced state machines synthesized active objects operations passive objects 
case designer selects participant open scenario diagram case selects call arc operation scenario diagram 
synthesis command system generates state machine object operation showing separate window 
designer determine traces extracted active scenario open scenarios scenarios current project selected scenarios containing object question 
fig 

scenario diagrams synthesized state machine sced synthesis algorithm cornerstone design example approach supported sced 
designer describe expected behavior application typical example cases scenario diagrams synthesize automatically state machines interesting objects 
state machines satisfying designer draw scenarios fuse automatically existing state machines tune state machines hand state machine editor 
technique operations passive objects single command designer see synthesis various executions particular operation appearing scenarios form state machine 
synthesis basis implementing operation checking purposes simply summary operation requirements expressed scenarios far 
illustrates synthesis state machine 
set scenarios describing automatic teller machine atm state machine control unit synthesized 
shown state machine exactly form generated sced including layout 
fig 

synthesizing operation descriptions scenarios 
generation description operation traces demonstrated simple case operation computes value postfix expression stack conventional way assuming operands operators provided object postfix operation get 
shown state machine right produced sced basis example call appearing scenario left 
layout state machine automatically produced 
scenario case smallest produce correct state machine readings operands operators added scenario affecting resulting state machine 
note special initial state generated name name operation 
type synthesizing information obtained scenarios event flow diagram rum nodes arcs represent classes events respectively 
fact instance class sends event instance class represented arc event flow diagram gives useful global view possible interactions classes referring particular executions system 
event flow diagram synthesis participants set scenarios state machine synthesis particular participant 
sced produces event flow diagram automatically request 
generating scenario diagrams design animation section show existing state machines support construction scenarios methods previous section construction new complete state machines 
call approach design animation animating partial specification system consisting set state machines employing scenarios runtime system representation 
scenario diagrams visualizing behavior running object systems idea proposed authors ln km 
assume set state machines describing complete system 
long provides required external stimuli system needed state machines simulate behavior system sending events changing states received events 
result execution shown scenario diagram 
suppose state machines objects system incomplete missing objective specify state machine 
call corresponding object unknown 
consequently point execution system stuck state machine waiting response state machine unknown 
designer act role unknown select object react response unknown indicate state transition applied object 
execution proceeds normally unknown needed 
result complete scenario diagram unknown generated designer ask system synthesize approximation state machine unknown augment incomplete state machine unknown new scenario 
design process continue making resulting state machine new behavior new path state machine required unknown designer intervene 
method generalized arbitrary number unknown objects designer specify object receiver unidentified message sent state machine 
designer start empty set state machines construct scenario diagram hand synthesize initial state machines basis scenario construct new scenario support state machines fuse scenario state machines satisfactory state machines obtained 
significant advantage approach designer need recall behavior existing state machines parts scenario concerning known behavior produced automatically 
furthermore guaranteed parts scenario consistent existing state machines 
approach works design existing components known behavior say gui library components design scratch 
complete designed system gets designer needs intervene 
note external interface user normally represented unknown participant scenario 
design animation approach particularly attractive interactions concerning participant simulated graphical interface drawing events scenario software designer explore possibilities actual interface observe response system form scenario extend behavior necessary 
sced design animation supported called tracing mode 
mode scenario diagrams constructed support existing state machines 
participating state machines opened designer 
activating tracing mode creates scenario participants bound state machines 
desired designer add new participants unknown behavior 
designer enter events normally state machine bound target object able respond event current state state transition takes place action part new state executed causing possibly new event sent object 
may turn cause state transition state machine bound new target object result cascade events created events immediately shown scenario diagram 
generation scenario gets stuck situations state machine sent event unique receiver event appears target object incomplete missing state machine unable recognize event 
case designer select receiver simply clicking receiver object scenario 
objects able recognize event shown hollow circle objects recognize event behavior extended defined frozen objects shown black spot see 
result selecting objects event drawn receiver may respond event causing new events appear scenario 
receiver unable respond case applies 
case designer see events object able receive current state clicking object bar scenario 
selecting events popup menu creates event arc currently active object selected object labeled event 
consequently receiver object respond event change state execute possible event sending actions new state continuing scenario 
execution may get stuck waiting external stimuli response user animated system 
case designer give user reaction normal event manually selected popup menus giving currently recognizable events simulated interface 
facilitate sced provides interface applications insert events windows clipboard buffer sced polls buffer regularly automatically appends events scenario 
user participant behavior known state machine applying tracing mode sced essentially means animating testing existing dynamic model system 
note intervention designer animated execution system implies new behavior exhibited current state machines 
participants state machine interesting sensible enduser system 
new behavior added existing state machines appropriate scenario diagram produced 
done sced simply selecting desired object diagram giving synthesis command 
result new scenario fused state machine object bk algorithm see section 
fig 

design animation specifying behavior atm support simulated atm interface existing state machines 
sced concert simulated graphical user interface atm 
simply emits user input events ascii form clipboard picked sced 
designer constructed state machines consortium bank frozen freezing shown coloring visible 
atm preliminary state machine exists designer strives specification complete behavior 
corresponds situation designer inserted card simulated interface far incomplete atm state machine responded requesting password designer password graphical interface atm responds sending verify account message 
accident consortium cons bank able recognize message receiver unique designer select desired receiver potential receivers indicated blinking circles spots 
case third event generated automatically principle generated event sequences arbitrarily long 
session continue follows designer selects consortium result event verify account drawn atm consortium consortium responds sending event 
designer selects time bank receiver event 
event drawn bank responds sending event invalid password consortium 
consortium responds sending event account ok 
event account ok far recognized object system asks receiver 
designer selects atm event drawn consortium atm 
atm unable respond designer inserts hand event invalid access atm user 
note steps represent extension behavior atm resulting scenario synthesized atm state machine extension part atm behavior 
reverse engineering sced interface externally generated events possible employ sced animator object oriented system 
system animated instrumented calls generating textual event descriptions site event sending 
events transmitted ascii text windows clipboard system animated written language 
run sced instrumented animated system simultaneously observe new events appear result animated system 
kind program visualization comes close scene km 
contrast scene tried solve scaling problem event compression techniques rely vertical horizontal scrolling scenario 
practice implies instrumentation select relatively small set objects give rise events resulting scenario large sensible examination 
call compression technique scene applicable sced events necessarily method calls 
combined state machine synthesis animation capability sced powerful reverse engineering tool 
recall sced able synthesize general behavior state machine scenarios independently scenarios produced 
synthesis algorithm applied scenarios produced running existing instrumented applications running application see general behavior objects belonging application form state machine 
additional test runs state machines describing general behavior complete 
long application instrumented sced possible extract state machines selected objects executions application property highly useful understanding complex legacy systems 
remarkable property essentially consequence features sced separate facility 
reverse engineering aspect sced demonstrated atm example follows 
assume simulator atm system implemented scratch 
addition atm interface simulator see system simulates behavior atm control unit central bank computer 
system instrumented message sending user interface control unit bank computer associated call operation inserts corresponding event descriptor sced event buffer windows clipboard 
sufficient sced program visualizer 
atm interface arbitrary ways resulting object interactions observed scenario displayed sced 
desired new scenario windows opened splitting generated event sequence meaningful parts 
user ask sced synthesize state machine control unit 
depending parts atm system complete state machine generated 
various tools developed supporting program comprehension traditionally tools rely static dynamic analysis source code 
result analysis graphical representations relations source entities produced 
typical systems kind program slicing data dependencies call graphs 
see 
essential difference tools sced reverse engineering sced produces description behavior object terms state machine description completely independent way behavior implemented source code 
drawback hard tell description complete possible ways system exercised 
accomplish target system instrumented dynamic statement execution counters 
consistency scenario diagrams state machines fact scenarios state machines edited independently possible create inconsistencies 
suppose state machine synthesized set scenarios scenarios changed 
clearly state machine may invalid sense able execute scenario 
holds reversely state machine changed may scenarios longer executable state machine 
system maintain consistency sense state machine object execute scenarios object participates 
note possible require stronger consistency state machine exactly result applying bk algorithm set scenarios object participates 
unnatural consequences state machine edited adding transition small artificial scenario causing transition generated 
eventually large set scenarios sensible context confuse designer help 
assume scenario edited synthesized state machine 
update state machine incrementally technique 
transition associated integer giving number scenarios transition call scenario counter transition 
scenario changed removed state machine scenario run state machine transition uses marked 
scenario counters marked transitions decremented 
scenario counter zero corresponding transition removed 
state way isolated states removed 
effect original scenario removed state machine way new version scenario added state machine incremental bk algorithm 
assume existing state machine edited set scenarios contributing state machine 
long adds new states transitions state machine inconsistencies may created changes prevent state machine executing scenarios 
state transition scenario removed modification viewed removing adding conflict arises scenario run state machine 
contrast transitions scenario counter zero added direct state machine editing removed problems states associated transitions 
call transitions states scenario sensitive 
editing scenario sensitive parts state machine gives rise problems hard solve general 
note reverse problem relatively easy solve incremental algorithm updating general description set state machines information contained new instance scenario 
revising scenarios automatically basis state machine editing questionable scenarios viewed requirements hold state machine modifications plain implications state machines 
sced supports consistency scenarios state machines principles 
designer ask system remove particular scenario state machine scenario edited resynthesized state machine 
updating state machine easily fully automatic preferred environment designer selection useful commands fixed working model imposed various implicit mechanisms 
time designer check validity current scenarios running state machines 
synthesizing omt state diagram notation result bk algorithm state machine consisting states associated action transitions usually associated label unlabelled transitions called automatic transitions omt fire automatically action state completed 
state machine called plain state machine 
omt provides auxiliary means state machine compact readable 
include entry actions exit actions internal actions transition actions entry actions executed arriving state exit actions executed leaving state internal actions executed response event changing state transition action executed transition associated fires 
extensions increase expressive power formalism serve state machine simpler readable cases reduce number states transitions extensions 
call state machines making features extended state machines 
state machines produced automatically omt context highly desirable generate directly extended state machines designer may edit resulting state machine hand just improve presentation 
sequel discuss automated techniques transform plain state machines extended ones fewer states transitions 
discussed techniques implemented sced 
usually plain state diagram transformed mutually different extended states machines depending chosen extensions order introduced 
ones minimal number states transitions called optimized state machines 
consider transformations aiming optimized state machines 
practice sensible apply transformations locally goal global optimization possible sced discussed 
require transformation plain state machine extended behavior preserving transformed state machine responds way particular sequence events original 
allow association action state states transitions addition omt allows nested states style har 
nested states currently fully supported sced ignore discussion 
state removed action may moved copied 
rule guarantees state machine optimized cost increased actions 
basic rules transformation rule external behavior state machine preserved 
rule action duplicated 
say state machine minimally deterministic states action joined making state machine non deterministic 
characteristic property bk algorithm resulting state machine minimally deterministic 
assume state machine minimally deterministic 
assume state state machine reachable initial state 
prevent automatic transitions causing nondeterminism require state automatic labeled leaving transitions 
exclude possibility state machine contains loop automatic transitions 
situations prevented adaptation bk algorithm 
way reduce number states special omt actions plain state machine remove automatic transition 
assume source state automatic transition state action target state state action assume transition entering state 
certain circumstances possible simplify state machine removing state making entry action state making exit action source state making internal action state associating new transition source state state merging state state action 
order transformations applied plain state machine affects result 
different transformations compete automatic transitions various action types applied order preference actions 
wish emphasize role states transitions attach information states possible 
state state regarded identifiers states state names 
actions states real state names moved similarly named states 
allow transformations introducing transition actions transformations possible 
hand prefer transformations type transformations specific internal action deals single event entry exit actions directly associated particular events 
shown order satisfies preferences results optimized state machine sys 
type transformation determine conditions hold transformation carried 
example consider internal actions 
assume state action state action automatic transition state state entering state 
state entering transitions leaving state state action couldn placed internal action state violating rule rule 
require source state state 
transitions state state internal actions formed corresponding transitions violating rule 
require transition entering state 
fact state leaving transitions automatic transition follows assumptions 
synthesis algorithm ensures transition labeled leaving transitions state labeled recall restrictions automatic transitions 
concluded leaving entering transitions state influence forming internal action state attached state assumptions 
generalize discussion infer smallest patterns respect number states transitions optimized adopting actions means determining choices source state concluded case internal actions source state state 
state restrictions automatic transitions 
third possibility state say state 
noticing state state different states loop automatic transitions conclude possible patterns plain state machines potential candidates simplification omt actions patterns shown 
type action may introduce additional restrictions 
fig 

plain state machine patterns special omt actions transformations discussed implemented sced 
designer ask system optimize plain state machine system produce equivalent state machine omt extended notation hopefully states transitions 
example command applied state machine states transitions removed 
example transformation shown 
upper window minimal plain state machine describing behavior vending machine 
lower window result optimization algorithm shown form roughly omt book rum algorithm removed state transition appearing rum 
automated layout state machines producing logical contents state machine result displayed satisfactory form 
state machine modest size arranging states transitions manually reasonable form laborious task large state machine task truly trying 
state machine visualized optimizing layout respect alignment symmetry balance crossing edges number bends transitions fig 

transforming state machine omt notation 
applied existing linear time layout algorithm directed graphs sced num state machine interpreted directed graph states vertices transitions edges graph 
advantage algorithm capability handle arbitrary sized vertices 
states state machine normally small size fixed limits width height state box actions written inside box take arbitrary amount space 
unfortunately basic layout algorithm far sufficient special features omt type state machines 
addition making general improvements concerning horizontal centering vertices vertical alignment vertices edges vertical packing vertices bend elimination details see mst solve problems specific state machines 
problems discussed 
designer adds manually parts state machine automatically produced layout constructs state machine scratch automatic layout applied carefully designer completely lost state machine rearranged editing actions 
designer able specify parts state machine satisfactory layout 
accomplish sced allows designer select rectangular area state machine freeze layout 
layout process internal states frozen rectangular area invisible frozen area treated single state 
layout created state diagram transitions internal states external states routed properly 
original layout algorithm accepts simple graphs graphs contain multiple edges nodes self loops 
perfectly valid constructs state machines layout algorithm modified accordingly 
multiple edges self loops effectively hidden layout algorithm added diagram making final completing operations 
practical state diagram cyclic character behavior object described cycle states transitions possibly augmented shortcuts auxiliary paths exceptional cases 
main cycle dominates object behavior clearly visible state machine layout 
current implementation try keep main cycle relatively free excessive bends 
doing basic layout optimization horizontal vertical alignment vertices choices preferred resulting better visibility main cycle 
concluding remarks sced extensive nokia industrial research partner years 
facilities sced extensions omt scenario diagram notation motivated needs emerging practical evaluation 
consequently sced fits nicely omt design methodology aj developed nokia methodology relies heavily scenarios basic instrument extracting design information requirements 
features discussed particularly design animation facility implemented far lack proper practical validation 
feel scenarios natural means expectations dynamic characteristics system early stages design exploited software development process 
demonstrated sced possible apply existing machine learning techniques inferring general dynamic specifications scenarios opens new directions tool support oo design methodologies 
tight coupling scenarios state diagrams apparent animated simulation dynamic model combined automatic state machine synthesis approach bridges gap easily obtainable example full specification 
automatic generation state machines gives rise new research problems 
highly desirable display generated state machine form reasonably close hand written 
improving representation state machine syntactic aesthetic sense necessary 
shown plain state machines systematically converted compact omt notation existing graph layout algorithms applied modifications state machine layout 
sced real life applications concerns relating scenario directed dynamic modeling technique supported sced broader context object oriented design 
includes methodological aspects tool support 
feel sced separate tool part integrated oo development environment 
currently building functionality sced commercial integrated oo case tool stone af 
sced available free anonymous ftp cs uta fi directory pub sced 
sced developed research project financed center technological development finland nokia research center automation 
professors ilkka erkki significantly supported 
parts sced implemented juha korhonen 
aj object oriented development interactive systems omt 
proc 
tools prentice hall 
bik biermann krishnaswamy constructing programs example computations ieee trans 
softw 
eng 
se 
ccitt ccitt document com new recommendation message sequence charts july 
eick ward interactive visualization message sequence charts 
proc 
th workshop program comprehension ieee computer society press march 
gam gamma helm johnson vlissides design patterns elements object oriented software architecture 
addison wesley 
har harel statecharts visual formalism complex systems 
science computer programming 
jac jacobson object oriented software engineering case drive approach addison wesley 
km koskimies automatic synthesis state machines trace diagrams 
software practice experience july 
km koskimies ck scene scenario diagrams active text illustrating object oriented programs 
proc 
international conference software engineering icse berlin march 
ln lange nakamura interactive visualization design patterns help framework understanding 
proc 
oopsla sigplan notices oct 
mst syst sced report user manual 
report department computer science university tampere february 
mst syst design state diagram facilities sced 
report department computer science university tampere december 
num constructing compact rectilinear planar layouts canonical representation planar graphs 
theoretical computer science 
oman maintenance tools 
ieee software may 
por flexible command interpreter pattern extensible language independent interpreter system 
coplien schmidt 
eds pattern languages program design addison wesley 
rum rumbaugh blaha premerlani eddy lorensen object oriented modelling design prentice hall 
sum sugiyama misue visualization structural information automatic drawing compound digraphs 
ieee transactions systems man cybernetics smc 
sys syst synthesis omt state diagrams 
internal report department computer science university tampere may 
