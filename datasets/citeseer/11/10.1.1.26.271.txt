software faults evolving large real time system case study perry carol bell laboratories mountain avenue murray hill nj usa bell laboratories blvd nj usa 
report results survey software faults encountered testing phases evolving large real time system 
survey done parts part surveyed faults reported characterized terms general categories second part depth faults design coding phases 
part describe describe report general faults characterize requirements design coding faults testing phases time testing interval 
second part describe survey design coding faults report faults occurred difficult find fix underlying causes corresponding errors means prevented occurring 
characterize results terms interface implementation faults 
surprising software fault studies appeared software engineering literature especially monitoring mistakes fundamental means improve process product 
particularly true development large systems 
preceding perry reported prevalence interface faults major factor development evolution large real time system faults 
main purposes software fault study indicate importance tools inscape environment manage interfaces dependencies interfaces 
prior endres hoffman glass reported various fault analyses software development delineate interface faults specific category 
thayer nelson bowen provide extensive categorization faults relatively narrow view interface faults 
basili offer comprehensive study problems encountered development phase medium scale system reporting data fault number components affected type fault effort required correct fault 
interface faults largest class faults faults 
important contributions case study 
software fault data evolutionary development initial development previous studies done 
second novel approach emphasize cost finding reproducing fixing faults means preventing 
section provide background study describing system general terms methodology employed evolving system 
section describe experimental strategy approach conducting survey 
section report modification request survey providing summary questionnaire summary results 
section design coding fault survey providing summary questionnaire discussion analysis summary relating results interface faults 
section recommendations 
background system discussed large scale distributed realtime system written programming language unix multiple machine multiple location environment 
organizational structure typical respect projects systems size number people organization 
surprisingly different organizations responsible various parts system development requirements specification architecture design coding capability testing system system stability testing alpha testing 
process development typical respect projects size 
systems engineers prepare informal structured documents defining requirements changes system 
designers prepare informal design documents subjected formal reviews fifteen peers depending size unit consideration 
design broken design units low level design coding 
products phase subjected formal code reviews reviewers low level unit testing 
components available integration system testing performed system completely integrated 
release considered non initial release viewed arbitrary point evolution class systems 
size system system evolution process consists multiple concurrent releases release dates sequential number releases proceed concurrently differing phases 
concurrency inter release dependencies associated problems 
magnitude changes approximately new code release general changes bug fixes improvements new functionality generally uniform releases 
facts large mean system ncsl 
wide variety large systems 
consider study provide representative sample life project 
relative uniformity releases contrasts lehman belady releases alternated adding new functionality fixing existing problems 
faults discovered testing phases reported monitored modification request tracking system example cms 
access source files modification possible tracking system 
source change activity automatically tracked system 
activity includes repairs enhancements new functionality 
kept mind fault tracking activity occurs testing released phases project architecture design coding phases 
problems encountered earlier phases resolved informally tracked system 
survey strategy goal study gain insight current process system evolution concentrating representative release particular system 
approach surveying means prepared questionnaires owned time closed 
conducted studies surveyed complete set faults second largest set faults design coding faults depth 
mandated management survey non intrusive anonymous strictly voluntary 
created authors working group developers involved study 
reviewed independent group developers part subject development 
able validate results assess accuracy resulting data 
returned parts study 
case sample size large sufficiently large justify precision remainder 
questions representativeness responses know factors skew results significantly 
survey specific purposes initial survey determine kinds general problems report kinds specific application problems report lack generality preparation release determine problem testing phase determine problem 
discussion follows summary questionnaire summarize results draw 
questionnaire survey questionnaire main components determination fault reported testing phase fault 
determining fault aspects importance development phase fault introduced second particular type fault 
particular type fault reported stage survey tended application methodology specific emphasized phase origin nature fault categorization 
general fault categories follows previous residual problems left previous releases requirements problems originating requirements specification phase development design problems originating architectural design phases development coding problems originating coding phases development testing environment problems originating construction provision testing environment example faults system configuration static data testing problems testing example pilot faults duplicates problems reported problems problems due misunderstandings interfaces functionality part user various problems fit neatly preceding categories hardware problems main component survey concerned phase testing uncovered fault 
different testing phases 
capability test ct testing isolated portions system ensure proper capabilities portion 
system test st testing entire system ensure proper execution system laboratory environment 
system stability test ss testing simulated load conditions laboratory environment extended periods time 
alpha test live release friendly user environment 
released re live 
study data refers release previous release 
expectation provides projection fault results release 
time interval faults initiated retrieved database tracking system 
ideally testing phases occur sequentially 
practice due size complexity system various phases overlap 
overlap due specific factors 
various parts system modified parallel 
means various parts system different states time 
second iterative nature evolution results recycling back previous phases various parts system 
third various testing phases begun early possible known component may incomplete 
looked way testing proceeds hierarchical manner testing begun various pieces subsystems integrating larger parts complete system 
judgment call different parts system move phase determined primarily percentage capabilities incorporated number tests executed 
looked slightly different way testing proceeds increasing system size complexity time increasing load stress 
results summary fault category discuss main issues stem results 
summarize requirements design coding faults testing phase time interval 
table 
summary responses categories proportion previous requirements design coding testing environment testing duplicates problems responses 
table summarizes frequency category 
previous problems existed precious releases surfaced current release 
indicate difficulty finding faults difficulty achieving comprehensive test coverage 
representing earlier part development evolution process representing requirements design coding significant accounting approximately significant subset concern testing testing environment testing categories surprising significant number problems encountered testing large complex real time system conditions simulated represent real world laboratory environment 
testing environment large complex system tested 
second real time system evolves laboratory test environment evolve 
duplicate problem significant subset data 
historically considered part overhead 
fig 

fault categories testing phase ct st ss re 
requirements faults design faults coding faults 
ct capability test st system test ss system stability alpha test re released duplicate large part due inherent concurrency activities large scale project difficult eliminate 
results testing phase time 
focus early part software process occur accordingly close attention yield results 
reason requirements design coding faults distributed testing phase 
requirements design coding fault categories shows percentage testing phase 
important observations 
system test st source category capability testing ct largest source 
second testing phases fault category 
note reasons design requirements faults continue entire testing process 
requirements change long development interval represented 
second informal requirement design documents lack precision completeness general problem current state practice project specific problem 
data represents displayed testing interval 
fig 

fault categories time 
requirements faults design faults coding faults 
time values fixed relatively long intervals 
shape data clear system testing overlaps interval 
requirements design coding fault categories time shows fault types peaked time held time coding faults decreased 
figures different non trivial mapping testing phase calendar time 
summary general observations may drawn general survey problems encountered evolving large real time system faults occurred testing phases majority faults late testing interval 
observations limited fact tracking primarily testing activity 
extremely useful observe kinds frequencies faults exists earlier phases project 
beneficial incorporate ways detecting requirements design faults existing development process 
design code fault survey result general survey decided design coding depth 
goals wanted achieve part study determine kinds faults occurred design coding determine difficulty finding reproducing faults fixing determine underlying causes faults determine faults prevented 
reasons choosing part general set exceedingly difficult separate kinds faults 
second catching kinds faults earlier process provide significant reduction fault cost cost finding faults system integration significantly finding laboratory testing environment 
internal cost data consistent boehm 
gaining insight problems yield significant cost beneficial results 
subsections follow summarize survey questionnaire results analysis summarize findings regard interface implementation faults 
questionnaire asked information actual fault difficulty finding fixing fault underlying cause best means preventing avoiding problem level confidence responses 
fault types 
fault consider possible types select closely applies cause 
language pitfalls 

protocol violated rules interprocess communication 

low level logic loop termination problems pointer initialization 
cms complexity due change management system complexity 

internal functionality inadequate functionality changes additions needed existing functionality module subsystem 

external functionality inadequate functionality changes additions needed existing functionality outside module subsystem 

primitives misused design code depended primitives correctly 

primitives unsupported design code depended primitives adequately developed primitives correctly 
change coordination know previous changes depended concurrent changes 

interface complexity interfaces badly structured incomprehensible 

design code complexity implementation badly structured incomprehensible 

error handling incorrect handling recovery exceptions 

race conditions incorrect coordination sharing data 

performance real time constraints resource access response time constraints 

resource allocation incorrect resource allocation deallocation 

dynamic data design incorrect design dynamic data resources structures 

dynamic data incorrect dynamic data structures example initialization maintaining constraints 

static data design incorrect design static data structures example location partitioning redundancy 

unknown interactions involved functionality parts system 

unexpected dependencies unexpected interactions dependencies parts system 

concurrent unexpected dependencies concurrent releases 

describe fault 
ease finding reproducing fault 
question ranked difficult reproduce failure locate fault 

easy produce 

moderate happened time intermittent 

difficult needed theories reproduce error 

difficult exceedingly hard reproduce 
ease fixing fault 
time needed design code fix document test 

easy day 
moderate days 
difficult days 
difficult greater days note easy fix single programmer system takes considerably time large multi person project complex laboratory test environment 
underlying causes 
fault may symptom provide regard underlying root cause problem 

underlying causes 

incomplete omitted requirements source fault stemmed incomplete unstated requirements 

ambiguous requirements requirements informally stated open interpretation 
interpretation selected evidently incorrect 

incomplete omitted design source fault stemmed incomplete unstated design specifications 

ambiguous design design informally open interpretation 
interpretation selected evidently incorrect 

earlier incorrect fix fault induced earlier incorrect fix fault result new development 

lack knowledge needed know know needed know 

incorrect modification suspected solution incorrect determine correctly solve problem 

submitted solution submitted knowing incorrect generally due schedule pressure 

describe underlying cause 
means prevention 
fault consider possible ways prevent avoid select useful appropriate choice preventing avoiding fault 

formal requirements precise unambiguous requirements design formal notation may graphical textual 

requirements design templates provide specific requirements design document templates 

formal interface specifications formal notation describing module interfaces 

training provide discussions training seminars formal courses 

application walk throughs determine informally interactions various application specific processes data objects 

expert person documentation provide expert person clear documentation needed 

design code currency keep design documents date code changes 

guideline enforcement enforce code inspections guidelines static analysis tools lint 

better test planning provide better test planning execution example automatic regression testing 

describe means prevention 
confidence levels 
confidence levels requested respondents high high moderate low low discarded small number responses confidence level low low 
analysis table 
chi square analysis summary variables degrees total freedom chi square find fix fault find fault fix cause find cause fix fault cause prevention find prevention fix fault prevention cause prevention understand relationships faults effort find fix underlying causes means prevention results survey cross tabulated subjected chi square analysis 
table provides summary chi square analysis 
identify relationships tested hypothesis member pairs independent 
establish relationship existed chi square test 
table provides results test 
numbers show relationships statistically significant level indicated value note cases relationships statistically significant 
relationship means prevention ease finding fault coming closest independent greater say independent 
relationship means prevention underlying causes significantly interdependent total chi square large 
earlier perry received comments cost faults specifically interface faults easy ones ones 
questions mind included questions effort find fix faults 
devised simple weighting measures finding fixing faults meant indicative definitive 
measures intended support relative absolute comparison faults 
estimate effort find fault determine weight multiplying proportion observed values fault effort category respectively sum results 
example fault easy find cases moderate difficult difficult weight 
higher weight effort required find fault 
estimate effort fix fault determine weight multiplying proportion observed values fault 
chose values reasonable approximation average length time fix set faults 
proportions corresponding fix weight 
compute effort adjusted frequencies fault multiply number occurrences fault weight divide total weighted number occurrences 
consider difficulty finding fixing faults 
discuss faults cost finding fixing 
consider underlying causes means prevention correlate faults effort measures underlying causes means prevention correlate underlying causes means prevention 
divide faults interface implementation categories compare terms difficulty find fix underlying causes means prevention 
finding fixing faults 
faults easy moderate find took days fix 
general easier find faults easier fix difficult find faults difficult fix 
faults easy find took day fix expected chi square analysis 
interestingly fewer expected easy find faults took days fix 
table 
summary find fix effort find fix effort days days easy moderate difficult difficult coordinates effort find fix faults comparable note relationship suggestive 
counter common wisdom says problem easy fix 
significant number easy moderate find faults require relatively long time fix 
faults 
table shows fault types ordered frequency survey independent factors 
show effort weights effort ranks weight adjusted frequencies finding fixing faults 
fault categories account observed faults 
internal functionality leading fault large margin somewhat surprising interface complexity significant problem surprising 
faults leading faults consistent nature evolution system 
adding significant amounts table 
faults ordered frequency fault description observed find find find fix fix fix weight rank weight rank internal functionality interface complexity unexpected dependencies low level logic design code complexity change coordination concurrent race conditions external functionality language pitfalls error handling primitive misuse dynamic data resource allocation static data design performance unknown interactions primitives unsupported protocol cms complexity dynamic data design new functionality system easily accounts problems internal functionality low level logic external functionality 
fact system large complicated real time system easily accounts fact problems interface complexity unexpected dependencies design code complexity change coordination concurrent 
known language pitfalls account rank fault middle set 
similarly race conditions reasonably significant problem lack suitable language facilities performance faults relatively insignificant probably due fact early release system 
ranking fix weight consistent intuition extremely difficult fix 
finding fixing faults 
find weighted ordering affirms intuition difficult faults find 
typically performance faults race conditions difficult isolate reproduce 
expect code complexity error handling faults difficult find reproduce 
inspect chi square test faults find effort notice internal functionality unexpected dependencies tended easier find expected 
code complexity performance tended harder find expected 
tended significant deviations sample population larger 
adjusting frequency effort find faults results slight shift ordering faults 
internal functionality code complexity race conditions change slightly rest faults 
adjusting frequency effort fix fault causes interesting shifts ordering faults 
language pitfalls low level logic internal functionality drop significantly relative importance 
coincides intuition kinds faults easy fix 
design code complexity resource allocation unexpected dependencies rise significantly relative importance interface complexity race conditions performance rise significantly 
top faults account effort expended fix faults effort find represent faults observed frequency 
collectively somewhat harder fix rest faults slightly easier find 
note scales strictly comparable comparison interesting 
inspect chi square test faults find effort notice language pitfalls low level logic took fewer days fix expected 
interface complexity internal functionality took days expected design code complexity unexpected dependencies took longer fix days expected 
deviations weighted assessment effort fix faults 
underlying causes 
table shows underlying causes ordered frequency survey independent factors effort weights effort ranks effort adjusted frequencies finding fixing faults underlying causes 
table 
underlying causes faults cause description observed find find find fix fix fix weight rank weight rank incomplete omitted design lack knowledge ambiguous design earlier incorrect fix submitted incomplete omitted req ambiguous requirements incorrect modification weighting underlying causes effort find reproduce faults underlying causes produces change ordering relative proportion underlying causes 
respect relative difficulty finding faults associated underlying causes resulting ordering particularly non intuitive underlying cause second difficult find submitted difficult find 
weighting underlying causes effort fix faults represented underlying causes yields shifts proportion effort incomplete omitted design increased significantly unclear requirements incomplete omitted requirements increased significantly decreased significantly unclear design decreased significantly 
relative ordering various underlying causes approximately 
relative weighting effort fix kinds underlying causes coincide intuition nicely 
inspect chi square test fix effort underlying causes notice faults caused tended take time fix expected faults caused incomplete omitted design submitted tended take time fix expected 
high proportion underlying cause requires explanation 
reasons faults language pitfalls low level logic race conditions change coordination tend fault underlying cause underlying cause category 
addition easily imagine faults interface complexity design code complexity considered fault underlying cause faults underlying cause category 
hand surprised cause substantial part internal functionality faults faults category 
expect underlying cause particular fault 
means prevention 
table shows suggested means prevention faults ordered occurrence independent factors effort weights effort ranks effort adjusted frequencies finding fixing faults means prevention applicable 
note various means prevention means independent non overlapping 
means selected may reflect particular approach responder selecting means example see discussion formal versus informal means prevention 
interesting note application specific means prevention application walk throughs considered effective means prevention 
selection application walk throughs useful means error prevention appears confirm observation curtis krasner thin spread application knowledge significant problem building large systems 
worth noting informal means prevention rank higher formal ones 
hand may reflect general bias united states formal methods 
hand informal means non technical solution providing information may supplied formal representations provide technical solution higher table 
means error prevention means description observed find find find fix fix fix weight rank weight rank appl walk throughs expert person doc guideline enforcement req design templates better test planning formal requirements formal interface spec training design code currency adoption costs 
level effort find faults means prevention change order table exception requirements design templates apply easier find faults better test planning apply somewhat harder find faults 
inspect chi square test find effort means prevention notice relationship finding faults preventing independent relationships discussed 
application walkthroughs applied faults marginally easier find expected guideline enforcement applied faults easy find expected 
inspect chi square test fix effort means prevention interesting note faults considered prevented training hardest fix 
formal methods apply classes faults take long time fix 
effort adjusting frequency fix effort yields shifts proportion application walk throughs guideline enforcement better test planning decreased proportion expert person documentation formal requirements increased proportion formal interface specifications 
result ordering changes slightly faults expert person documentation formal requirements weighted significantly higher requirements design templates formal interface specifications training significantly higher 
inspect chi square test faults means prevention notice faults prevented application walk throughs guideline enforcement tended take fewer days fix expected faults prevented formal requirements requirements design templates expert person documentation took longer fix expected 
underlying causes means prevention 
interesting note chi square test underlying causes means prevention significant number deviations wider variance actual values expected values correlating underlying causes means prevention appear statistical structure 
indicates strong dependencies underlying causes means prevention 
intuitively type relationship just expect 
interface faults versus implementation faults definition interface fault basili perry interface faults associated structures existing outside module local environment module 
definition roughly characterize language pitfalls low level logic internal functionality design code complexity performance implementation faults 
remainder considered interface faults 
say roughly cases implementation categories may contain interface problems design code complexity faults considered formal interface specifications 
table 
interface implementation fault comparison interface implementation frequency find weighted fix weighted interface faults occur slightly frequency implementation faults require effort find effort fix 
table compare interface implementation faults respect underlying causes 
underlying causes ambiguous requirements earlier incorrect fix ambiguous design tended underlying causes implementation faults interface faults 
underlying causes incomplete omitted requirements incorrect modification submitted tended causes interface faults implementation faults 
note underlying causes involved ambiguity tended result implementation faults interface faults underlying causes involving incompleteness omission information tended result interface faults implementation faults 
table compare interface implementation faults respect means prevention 
surprisingly formal requirements formal interface requirements applicable interface faults implementation faults 
training expert person documentation guideline enforcement considered applicable implementation faults interface faults 
table 
interface implementation faults underlying causes interface implementation incomplete omitted requirements ambiguous requirements incomplete omitted design ambiguous design earlier incorrect fix lack knowledge incorrect modification submitted table 
interface implementation faults means prevention interface implementation formal requirements requirements design templates formal interface specifications training application walk troughs expert person documentation design code currency guideline enforcement better test planning observed large number interesting facts faults cost finding fixing underlying causes means prevention 
offer general observations 
evolution large complex software systems involves large overhead approximately initial survey represented production faults represented overhead faults duplicate problem system test environment 
interface faults roughly entire set design coding faults harder fix implementation faults 
surprisingly formal requirements formal interface specifications suggested significant means preventing interface faults 
lack information tended dominate underlying causes knowledge intensive activities tended dominate means prevention 
clearly discovery rediscovery significant evolution large real time system 
relatively problems solved better programming languages language pitfalls race conditions account faults 
technology helps manage complexity dependencies useful internal functionality interface complexity unexpected dependencies low level logic design code complexity account faults 
system reported developed evolved current best practice techniques tools qualified practitioners 
fact feel development generalizable large scale real time systems 
mind offer recommendations improve current best practice 
obtain fault data entire development evolution cycle just testing cycle monitor progress evolution process 
incorporate non technological people intensive means prevention current process 
survey shown yield benefits majority faults reported 
introduce facilities increase precision completeness requirements architecture design documents manage complexity dependencies 
yield benefits faults generally harder fix help detect requirements architecture design problems earlier life cycle 
david contributed significantly general survey steve produced cross tabulated statistical analysis design code survey contributed carolyn larson julie federico wei tony analysis design code survey loader increased understanding chi square analysis larry votta helped refine improve presentation 
especially lew anderson support 
participated survey 

basili victor david empirical study syntactic complexity family ieee transactions software engineering se november 
basili victor barry software errors complexity empirical investigation 
communications acm january 
basili victor weiss david methodology collecting valid software engineering data 
ieee transactions software engineering se november 
boehm barry software engineering economics 
englewood cliffs prenticehall 
bowen john standard error classification support software reliability assessment 
afips conference proceedings national computer conference 
curtis bill krasner herb neil field study software design process large systems 
communications acm november 
endres albert analysis errors causes system programs 
ieee transactions software engineering se june 
glass robert persistent software errors 
ieee transactions software engineering se march 
humphrey watts managing software process 
reading mass addisonwesley 

kelly van uwe inferring formal software specifications episodic descriptions 
proceedings aaai 
sixth national conference artificial intelligence july seattle wa 
lehman belady program evolution 
processes software change 
london academic press 
ostrand thomas weyuker elaine collecting categorizing software error data industrial environment 
journal systems software 
perry michael empirical study software interface errors 
proceedings international symposium new directions computing ieee computer society august trondheim norway 
perry michael empirical study software interface faults update 
proceedings twentieth annual hawaii international conference systems sciences january volume ii 
perry inscape environment 
proceedings th international conference software engineering may pittsburgh pa 
perry industrial strength software development environments 
proceedings congress th world computer congress august september san francisco ca 
perry wolf alexander foundations study software architecture 
acm sigsoft software engineering notes october 
anderson mccabe processor operating system software development system 
bell system technical journal part january 

hoffman heinz michael experiment software error data collection analysis ieee transactions software engineering se may 
siegel sidney castellan jr john nonparametric statistics behavioral sciences 
second edition 
new york mcgraw hill 
thayer thomas myron nelson software reliability study large project reality 
trw series software technology volume 
north holland 

zave pamela jackson daniel practical specification techniques systems 
proceedings congress th world computer congress august september san francisco ca article processed macro package llncs style 
