query automata frank neven thomas schwentick main task document transformation information retrieval locating subtrees satisfying pattern 
unary queries queries map tree set nodes play important role context structured document databases 
want understand natural studied computation model tree automata compute queries 
de ne query automaton qa deterministic way nite automaton trees ability select nodes depending state label nodes 
study ranked unranked trees 
unranked trees di er ranked ones bound number children nodes 
characterize expressiveness di erent formalisms unary queries de nable monadic second order logic mso 
surprisingly contrast ranked case special stay transitions added unranked trees capture mso 
establish complexity non emptiness containment equivalence problem complete exptime 
popularity document speci cation language xml immensely increased amount research concerning structured document databases preliminary version th acm symposium principles database systems philadelphia pa 
research assistant fund scienti research flanders 
centrum 
mail frank neven luc ac 
johannes gutenberg universit mainz institut ur informatik 
mail tick informatik uni mainz de 
documents usually abstracted labeled ordered trees turn modeled context free cfg extended context free grammars 
particular context free grammars allow arbitrary regular expressions grammar symbols right hand side productions 
grammars form adequate abstractions xml document type de nitions dtds 
crucial di erence cfgs derivation trees ranked sense number children node bounded constant 
example depicted xml document corresponding dtd 
show corresponding abstractions 
main task document transformation information retrieval locating subtrees satisfying pattern 
unary queries queries map tree set nodes play important role context structured document databases 
goal understand natural studied computation model tree automata ranked unranked trees compute unary queries :10.1.1.38.8643
away grammar considering documents simply ranked unranked trees alphabet 
loss generality tree automata easily determine input tree derivation tree cfg 
de ne query automaton qa way deterministic nite automaton trees select nodes depending state label nodes 
qa compute queries natural way result qa tree consists nodes selected computation qa tree 
stress query automata consider quite di erent tree acceptors studied formal language theory 
thing way tree automata equivalent way ones dicult see query automata equivalent bottom ones 
bottom qa example compute query select leaves root labeled simply know label root starts leaves 
second di erence consider ranked unranked trees 
unranked trees received new attention context sgml xml 
pair takahashi murata de ned bottom automaton model unranked trees 
required describing transition functions arbitrary number children 
murata approach node abiteboul hull vianu foundations databases addison wesley codd relational model data large shared data banks communications acm example xml document describing bibliographic information 
author title journal year author title publisher year dtd xml document bibliography author title journal year codd comm 
relational author author title publisher year hull vianu author abiteboul book article addison wesley tree representation xml document 
bibliography 
book article article author 
title 
journal 
year book author 
title 
publisher 
year author 

title 

journal 

year 

publisher 

extended cfg representing dtd 
assigned state checking sequence states assigned children membership regular language 
way nite transition function represented nite way 
br klein murata wood initiated extensive study tree automata unranked trees 
showed results carry unranked case 
surprisingly context query automata discrepancy ranked unranked case 
show unranked case various qa formalisms accept class tree languages computing class queries 
indicates substantial di erence looking automata formal language point view de ning tree languages looking automata database point view computing queries ii automata ranked unranked trees 
section introducing necessary de nitions rst recall proof uchi theorem stating string language regular de nable mso generalize query automata strings section 
query automaton strings way deterministic automaton extended selection function 
approach allows recall important proof techniques easy setting generalized obtain main results 
techniques summarized follows de nition automaton mso essentially guessing states verifying consistency transition function ii capturing behavior way automata means behavior functions iii computing mso types automata 
conclude section recalling bottom tree automata compute mso tree language set trees 
say qa accepts tree underlying tree automaton accepts 
types 
section consider ranked trees trees xed bound number children vertex 
qa stands ranked way deterministic tree automaton de ned extended selection function 
show automata compute exactly unary queries de nable monadic second order logic mso 
section consider automata unranked trees 
rst approach de ne query automata unranked trees add selection function way deterministic tree automata unranked trees de ned br klein murata wood 
denote automata qa stands unranked 
automata accept recognizable tree languages compute unary queries de nable rst order logic 
intuitively automaton transition node assigns state child child knows state know general states assigned siblings 
means unranked case little information passed sibling 
resolve introduce stay transitions way string automaton reads string formed states children certain node outputs child new state 
automaton making stay transition equivalently constant number stay transitions children node strong qa sqa 
show automata compute exactly mso de nable queries 
qa sqa recognize tree languages compute queries 
restriction number stay transitions necessary 
restriction sqa simulate linear space turing machines 
testing non emptiness containment equivalence queries fundamental operations eld query optimization 
problems general usually undecidable language theoretic counter parts known decidable 
investigate section complexity problems qa tree node selected 
non emptiness ii query computed contained query computed 
containment iii compute automata di erent alternating tree walking automata 
query 
equivalence 
hope better exptime decision problems non emptiness way deterministic tree automata ranked trees selecting nodes complete exptime 
show non emptiness containment equivalence problem query automata studied exptime 
concluding remarks section 
basics logic automata strings trees section recall basic facts mso uchi theorem stating string language regular de nable mso 
approach allows introduce various techniques related mso automata easy setting generalize obtain expressiveness results query automata 
speci cally recall ehrenfeucht games facilitate reasoning mso equivalence types 
types constitute building blocks simulation mso formulas sections 
de ne bottom tree automata generalization uchi theorem trees obtained thatcher wright 
start conventions 
denote set positive natural numbers 
set denote jsj cardinality 
monadic second order logic vocabulary nite nonempty set constant symbols relation names associated arities 
usual structure consists nite set dom domain interpretation dom relation name arity interpretation dom constant symbol clear context important just say structure structure 
structure understood abuse notation write relation example vocabulary consisting binary relation symbol constants min max 
structure domain dom ng gg min max represents chain length min max interpreted rst element respectively 
monadic second order logic mso allows set variables ranging sets domain elements addition individual variables ranging domain elements provided rst order logic 
assume familiarity logic refer unfamiliar reader book ebbinghaus flum chapter thomas 
example give example mso formula 
usual denote set variables capital letters rst order variables small letters 
mso sentence vocabulary example min max formula de nes chains length 
chain set variable interpreted set elements occurring odd positions formula true element belong basic facts mso 
tuple elements write denote nite structure consists distinguished constants 
structures tuples elements respectively natural number 
write mso say mso equivalent mso sentence quanti er depth holds distinguished mso sentences quanti er depth readily follows de nition mso equivalence relation 
mso equivalence nicely characterized ehrenfeucht games 
round mso game structures denoted mso played players spoiler duplicator way 
rounds spoiler decides point move set move 
th move point move spoiler selects element dom dom duplicator answers selecting element structure 
th move set move spoiler chooses set dom dom duplicator chooses set structure 
rounds elements chosen point moves dom dom respectively sets chosen set moves dom dom respectively 
duplicator wins play mapping maps partial isomorphism 
atomic formula containing set variable 
say duplicator winning strategy mso shortly wins mso win play matter choices spoiler 
fundamental proposition known see proof 
proposition duplicator wins mso mso known relation mso nite number equivalence classes 
denote set classes refer elements mso types 
denote mso mso type structure elements distinguished constants mso equivalence class mso mso denote mso type structure distinguished elements 
useful think mso set mso sentences quanti er depth hold 
view mso set mso sentences quanti er depth mso nite logical equivalence nite number mso sentences quanti er depth equivalence types main tool simulate mso formulas automata 
illustrate usage recall employed prove uchi theorem 
regular string languages denotes nite alphabet 
string 
sequence symbols 
denote length jwj denote refer set positions de ne sets strings mso formulas associate string nite structure domain denoted dom binary relation symbol interpretation obvious set positions labeled fi distinction string relational structure corresponds 
type string mso nondeterministic nite automaton nfa tuple nite set states transition function set initial states set nal states 
denote canonical extension transition function strings string accepted language accepted denoted de ned set strings accepted size de ned jsj usual string language regular accepted nfa 
jij deterministic nite automaton dfa treat function additionally write de nition fs uchi theorem stating string language regular de ned mso sentence 
mso sentence de nes language fw 
simulation mso sentence dfa computation equivalence types 
proposition particular says mso 
depends mso 
mso 
observation proof theorem de ne transition function dfa computing mso type input strings 
ehrenfeucht games proposition easily show 
proposition strings 
mso mso 
mso 
proof 
proposition suces show duplicator wins mso 


know wins subgames mso mso 
duplicator plays mso 

winning strategies mso mso 
strategy precise consider moves spoiler string 
responses moves spoiler picks elements 
treated analogously 
spoiler chooses element duplicator answers winning strategy mso mso 
spoiler set move chooses 
contain elements respectively duplicator chooses sets winning strategy mso mso respectively 
winning strategy 
elements chosen point moves 

respectively sets elements chosen set moves 

respectively 
construction mapping 
restricted di erent components partial isomorphism corresponding components extended sets remains check relation preserved elements coming di erent components 
case elements precede duplicator chooses elements spoiler chooses elements duplicator chooses elements spoiler chooses elements 
ready prove uchi theorem theorem language regular de nable mso 
proof 
suppose de ned dfa ng 
nd mso sentence expressing string accepts sentence de nes run run encoded pairwise disjoint subsets intended meaning 
say labels position state clearly run accepting jwj labeled nal state 
sentence form fo formula de nes encoding run string consideration 
says rst position labeled state labelings consistent transition function 
local conditions readily expressed fo 
second part expresses element input string labeled nal state 
computational view input rst guesses state assignment veri es means fo formula guessed correctly 
guesses encode accepting run automaton 
direction types 
similar presentation ladner 
method referred composition method 
mso sentence quanti er depth clearly suces know mso determine 
show automaton input fact compute mso 
set states nite proposition says string symbol mso depends mso mso 
note mso depends 
mso computed left right initial state mso mso type empty string mso type string seen far symbol automaton moves state mso 
proposition matter representative mso equivalence class take 
automaton accepts state obtained reading input symbol 
formally automaton accepting language de ned de ned mso mso 
regular tree languages trees denoted boldface characters nodes trees denoted edges trees directed root leaves 
convention node tree vi denotes th child denote set nodes nodes root root 
arity node tree denoted arity number children say tree rank arity nodes 
node set children denoted children 
subtree rooted denoted envelope tree obtained deleting subtrees rooted children denoted tree consisting just node labeled denoted 
depth node number edges path root height number edges longest path leaf 
depth root height leaf zero 
denote label lab 
introducing notation 
symbol trees tree graphically represented note de nitions priori bound number children node may 
section restrict attention trees bounded rank simply referred ranked trees 
section consider trees bound rank 
clear distinction refer unranked trees 
remains specify logical structures corresponding trees 
tree naturally viewed nite structure binary relation symbols edge relation obvious 
relation speci es ordering children node set nodes labeled 
strings particular tree type mso note common 
rst de ne bottom deterministic tree automata indicate compute mso types trees 
allow generalization uchi theorem trees 
de nition superscript stress de ne automata ranked trees 
de nitions remaining section trees rank xed de nition deterministic bottom ranked tree automaton triple consisting nite set states nite alphabet set nal states transition function semantics tree denoted inductively de ned follows consists node labeled form 
tree accepted set trees accepted denoted 
set trees recognizable exists tree automaton 
prove theorem need suitable generalization proposition trees 
proof proposition similar proof bit subtle due presence edge relation proposition natural number trees 
mso mso proof 
just combine winning strategies subgames mso obtain winning strategy mso explained proof proposition 
shown assume duplicator picks root spoiler picks root vice versa 
show strategy winning 
suppose play mso elements chosen point moves respectively sets chosen set moves respectively 
clearly mapping 
restricted di erent components partial isomorphism corresponding components extended sets remains check relations preserved elements coming di erent components 
restrict attention elements 
denote roots respectively 
elements coming di erent components ng 
consequently children suces show roots respectively 
note 
spoiler picks root th move mso duplicator forced answer root picks node say round spoiler just picks parent duplicator answer 
come di erent components duplicator spoiler play rounds subgames mso mso 
subgames mso mso elements chosen th round 
argument means roots respectively 
required 
concerning consider case child similar argument follows child previous proposition mso type tree depends mso types subtrees rooted children root 
suggests mechanism compute mso types trees bottom way 
get bottom automaton purpose choose set states transition function follows mso mso 
proposition case strings matter representatives mso equivalence classes take 
tree automaton turn de ned mso guessing states verifying fo consistency transition function 
leads theorem obtained thatcher wright 
theorem tree language recognizable de nable mso 
show bottom tree automaton compute type mso root input tree need proposition 
need second item proposition items section 
proposition natural number trees node node arity 
mso mso mso 

lab lab vi vi mso wi wi mso 

ng 
mso lab vi lab wi vj vj mso wj wj ng fig vi vi mso wi wi 
proof 
proofs statements similar 
basic idea combine winning strategies duplicator respective subtrees winning strategy structures case strings proposition 
focus third case altogether subgames including trivial game structure consists vi wi 
winning strategy game vi vi wi wi just combines winning strategies subgames 
game selected vertices de ne partial isomorphisms pairs respective substructures 
ensure de ne partial isomorphism entire structures check relations chosen elements vi wi 
preservation chosen elements veri ed proof proposition 
additionally check corresponding pair chosen nodes vi wi vi wi vi wi 
follows immediately siblings parents vi wi distinguished constants elements corresponding substructures chosen 
lemma section 
lemma natural number 
exists mso root tree proof 
apply bottom technique proof theorem 
proposition proposition 
de ne take set mso types trees distinguished node 
de ne transition function follows mso root exists tree node arity mso mso vi vi proposition matter members vn mso equivalence classes take 
query automata strings warm start query automata strings 
simply twoway deterministic automata extended selection function 
approach allows introduce important proof techniques easy setting generalized obtain main results 
particular recall important notion behavior functions surprising lemma way automata hopcroft ullman 
rst de ne queries 
article query function maps structure unary relation domain 
mso de ne queries straightforward way mso formula de nes query fa de ne way automata strings 
prevent automata falling input string feed strings form 
new symbols appearing 
require automata move left right de nition way deterministic nite automaton dfa tuple nite set states initial state set nal states subset fcg subset fbg disjoint consists transition functions particular transition function left moves transition function right moves 
con guration member pair consisting state position 
string run sequence con gurations 

run run input initial state transition possible jm 
consider dfas halt 
decidable property 
show proof theorem behavior dfa de ned mso 
dicult write mso sentence satis able terminate input string 
known satis ability mso strings decidable 
clearly dfa modi ed halts endmarker 
convenience assume dfa 
query automaton just dfa extended selection function de nition query automaton strings qa string tuple dfa mapping 
say selects position run accepting mg selected selects need select time visits position 
particular run accepting position selected 
query expressed de ned fi selects ig 
dfas equivalent way dfas see shepherdson hopcroft ullman qa string equivalent qa string move direction 
consider example queries kind select rst symbol string contains letter 
query computable qa string moves direction 
started rst position oneway query automaton decide select having seen input 
holds started position move right left 
illustrate previous de nitions example 
example give example qa string computing query select position labeled occurring odd position counting right left starting right input string 
de ne fs fs fs bg fs cg 



automaton operates follows 
walks right endmarker state returns left endmarker alternating states position assigned state occurs odd position counting right endmarker endmarker included 
run input sequence position selected 
query automaton right endmarker 
easily modi ed 
generalizing uchi theorem query automata de ne twoway deterministic nite automata output position symbol xed alphabet just case query automata 
automata turn useful proof theorem essential capturing mso query automata unranked trees section 
de nition generalized string query automaton tuple dfa nite output alphabet function assume consider output position input string exactly symbol di erent halt 
position string denote unique symbol output position denote string 
jwj 
length preserving function say computed strings condition outputs exactly symbol di erent position essential results 
just taken symbol di erent output position automata just easier 
example modify qa string example generalized query automaton 
rede ne function follows automaton just copies input string replaces symbol occurs odd position counting right left endmarker 
generalize uchi theorem query automata 
proof introduce concept behavior function play major role sections 
additionally remarkable lemma due hopcroft ullman way automata turn crucial sections 
rst provide suitable generalization proposition 
proposition natural number strings 

mso 

jwj mso 
jvj mso 
proof 
just combine winning strategies subgames mso 

mso 
jwj 
jvj obtain winning strategy game mso proof proposition 
bit careful position 
jwj 
jvj respectively occur subgames mso 

mso 
jwj 
jvj combined strategy de ned positions duplicator picks position spoiler picks position subgames simply common positions occur distinguished constants subgames 
proposition obtain lemma lemma natural number 
exists dfa mso jwj string note shepherdson behavior functions simulate way automata way ones 
proof 
automaton just works automaton proof theorem 
di erence take distinguished constant account 
fs set states start state set mso types distinguished position 
proposition mso jwj depends mso jwj mso 
note depends 
transition function de ned follows mso mso jwj string mso jwj 
ready prove main result section 
theorem query computable qa string de nable mso 
proof 
qa string construct mso formula de nes query computed case way dfa state assumed position input string completely determined behavior accordingly simulated proof theorem simply guessing state assignment 
describe behavior way automaton know positions selects 
de ne partial functions string behavior function 
de ned 
starts computation position state rst state returns need notion 
jwj set states assumed de ned assumed fs mg ig run position input string formula guesses function 
set assumed rst state reaches denoted rst 
formally formula guesses sets partial functions sets intended meaning 
assumed rst 
note number sets bounded independently correctness guesses easily veri ed fo determined local consistency checks 
see introduce de nitions 
partial function state states smallest set containing states states 
reached position state states 
set states visits position making right move possibilities 
exists state states 

second case indicates starts cycle rst case means right move position state de ne right states exists 
right unde ned 
terminology show consistency checks depend local information 

rst 
jwj 
depends 
rst depends rst 
speci cally jwj 
right 
convention 
unde ned right 
unde ned 
rst right 
rst 
assumed jwj depends rst jwj 
jwj speci cally assumed jwj states 
jwj rst jwj 
jwj assumed depends 
rst assumed 
speci cally jwj assumed states 
rst 
assumed sg conditions uniquely determine rst 
assumed intuitively states rst functions xed left right sets assumed xed right left 
clearly conditions checked fo 
veri es halts accepting state depends assumed jwj selects positions selected depend sets assumed conversely mso formula quanti er depth describe automaton computing query de ned 
particular computes mso position input string proposition depends mso 
mso 
jwj 
start way dfa lemma compute mso 
right left variant compute mso 
jwj powerful surprising lemma hopcroft ullman allows combine automaton exactly want 
adapted setting lemma says lemma left right deterministic automaton strings right left 
exists generalized query automaton outputs position input string pair states take position respectively 
input outputs position pair 
jwj 

result readily follows rst simulate stated lemma select position output pair exists string position mso 
mso 
jvj 
sake completeness lemma sketch proof survey engelfriet 
automaton rst computes walking right simulating reaches endmarker goes step left outputs pair jwj starts walk back left endmarker simulating diculty maintain 
position describe general method doing 

assume output pair th position show computes 
suppose fp pg fp fp set states reached reading problem 
assume 
simulates backwards state fp simultaneously 
arrives position knows fp set states 
fp 
note sets pairwise disjoint 
computation continues conditions occurs 

position sets empty say 
state looking 

arrives required state set contains start state 
knows correct state position remaining problem position nd way back position construction step position di erent sets states reaches position reading 
key idea exactly position computations start position states sets ow state case state 
way left remembers states di erent sets position right starts way back position simulating behavior position states 
note lemma extensively engelfriet prove connections mso de nable string transductions deterministic way nite state transducers 
query automata ranked trees excursion strings turn trees 
speci cally de ne query automata trees simply way deterministic tree automata extended selection function 
show case ranked trees automata compute exactly queries de nable mso 
surprisingly unranked case add capture exactly mso 
borrow notation br klein murata wood de nitions 
de nitions section trees rank xed natural number way tree automata de nition way tree automaton 
de nition way deterministic ranked tree automaton dta tuple nite set states set nal states initial state 
disjoint subsets corresponds transitions transitions leaf transition function leaves root transition function root transition function transitions mg transition function transitions 
string length introduced disjoint sets avoid collision transitions 
come back having de ned computation dta introduce notions 
cut note leaves take part transitions 
subset nodes contains exactly node path root leaf 
con guration mapping cut set states node children denotes set children con guration 
children formally children subset overload notation children denotes sequence states arises order children children order de ne sequence lab 
lab 
automaton operating transition con gurations denoted transition transition leaf transition root transition 
transition node children ii children fvg iii iv identical 
transition node ii fvg children iii lab arity children iv identical 
leaf transition leaf node ii iii leaf lab iv identical fvg 

root transition froot ii iii root root lab root root con guration root froot start con guration 
con guration root accepting con guration 
means dta starts root returns accept tree 
run sequence con gurations 
start con guration 
run maximal exist run accepting maximal accepting con guration 
noted usually di erent runs tree nodes sequence states visited runs 
disjointness sure node labeled certain state transition run transition run 
justi ed consider behavior automata deterministic 
reason refer run tree correct run dta accepts tree run accepting accepts tree language accepts exactly tree note run forever input tree case run nite accepting 
consider automata terminate input 
decidable subclass 
show behavior de ned mso 
construct mso sentence satis able terminate tree 
satis ability mso sentences trees decidable follows deciding dta halts input decidable 
illustrate de nitions example 
example consider trees represent boolean circuits consisting gates having inputs output 
represented boolean function evaluated leaves root 
de ne dta accepting trees evaluate 
ease exposition consider full binary trees represent boolean circuits 
internal nodes labeled leaves labeled 
de ne dta fand fs ug fsg fu op op op fand org de ne 

leaf 

op op op op 
root op op de ne standard boolean functions 
automaton rst walks leaves leaves changes state state assigns state nodes height label rst child label second child assigns inner node pair result evaluation left right subtree node nally root assigned value tree 
obtain uniform way tree automaton transitions depend state label nodes transition originates 
transitions depend labels states children node automaton heads transition depends state label parent node 
transitions way tree automata de ned section di er depend states children label parent 
way tree automaton readily simulate way 
qb fb bottom deterministic tree automaton 
ease exposition assume transitions de ned 
de ne twoway automaton simulating follows 
runs leaves input tree thereon uses functions qb states intended meaning assigns node lab 
leaf assigns state transitions de ned follows 
furthermore accepts lab root fb state assigned root 
query automata ranked query automaton simply way deterministic tree automaton ranked trees extended selection function 
de nition ranked query automaton qa tuple dta function selection function 
de ne semantics qa tree node selects con guration lab 
selects run accepting ng selected query computed de ned fv nodes selects vg 
furthermore accepts tree language accepted underlying tree automaton 
example automaton selecting nodes evaluating boolean circuit obtained automaton example changing adding selection function de ned op fand org op op 
way deterministic tree automata equivalent deterministic bottom tree automata see query automata equivalent deterministic query automata top bottom 
consider example queries kind select root leaf labeled select leaves root labeled 
words way way query automata equivalent respect de ning tree languages respect computing queries 
preparation proof lemma extend notion behavior function proof theorem way tree automata 
de nition qa state set behavior function tree partial function de ned follows lab root lab root starts computation state rst state returns root 
noted assume automata enter nite cycles implies lab root call partial function admissible graph contains directed cycles length 
run set states assumes node de ned assumed fc ng belongs cut introduce notation 
admissible functions set states reachable functions denoted states smallest set states containing closed applications de ne unique state states state unde ned 
intuitively corresponds behavior function tv state transition started state expressiveness characterize expressiveness ranked query automata terms mso 
show query computed ranked query automaton de ned mso 
lemma query computed ranked query automaton de ned mso 
proof 
qa proof theorem construct mso formula guesses sets veri es consistency sets 
sets partial mapping input intended meaning node tv assumed 
proof theorem correctness guesses easily veri ed fo determined local conditions 

behavior function leaf node depends label 
behavior function non leaf node children depends tv lab lab vn lab 
specif ically node arity tv lab lab lab tv lab lab vn convention tv unde ned vi unde ned 
assumed root depends label root start state 
speci cally assumed root states root 
lab root 
non root node vi set assumed vi depends assumed label behavior function vi 
speci cally node children 
assumed vi vi assumed lab qg conditions uniquely determine behavior functions sets assumed 
particular behavior functions xed bottom sets assumed xed top 
furthermore conditions clearly expressed fo 
veri cation conditions formula veri es halts accepting state depends selects nodes visited selecting state depends 
proof direction construct automaton computing xed type mso node input tree 
theorem query computable ranked query automaton de nable mso 
root 
function mapping root 
denote lab th entry lab 
proof 
direction lemma 
notational simplicity describe proof direction trees rank 
proof general case straightforward generalization 
mso formula quanti er depth describe qa computes query de ned 
automaton nd vertex tree 
depends mso mso type structure 
proposition mso uniquely determined mso mso 
qa compute mso mso decide selected 
rst describe algorithm computes mso types node complete binary tree 
explain algorithm translated qa sketch qa modi ed deal possibly non complete trees 
underlying algorithm qa complete binary trees outlined 
ii objects computed algorithm bounded size depending size qa store state 
simulate outer loop algorithm qa proceed cuts consist vertices level follows proposition steps involve application xed nite functions 
steps performed parallel vertices depth step involves non local computation 
discuss step 
type mso computed bottom fashion subtree just automaton lemma 
discussed section automaton readily simulated way automaton starts problem detect root subtree starting point reached 
qa remembers starting point kind trick 
compute mso mso rst transition automaton assigns state keeps mso mind waits computation left subtree nished 
qa goes leaves computes mso bottom traversal described 
recognizes subtree noted describing special run automaton 
mentioned possible runs equivalent 
input compute mso root root mso root depth vertices level root level mso computed compute mso 
compute mso compute mso 
compute mso lab mso mso 
compute mso mso mso 
deduce mso holds select 
compute mso mso mso mso mso algorithm computing query de ned complete binary trees 
evaluation nished meeting state 
transition followed transition 
state contains mso mso waits termination evaluation right subtree done analogously case left subtree 
nishes description qa case complete binary trees 
iii explain qa deal non complete binary trees 
described trick node child 
remedy lemma 
node child parent node children view part tree rst descendant child child string play role endmarker respectively 
child leaf compute mso inductively 
consider deterministic string automata vertices computes mso starting mso computes mso starting mso 
string qa behaves way string automaton combines automata speci ed lemma 
automaton walks arriving state mso continues 
consider ary trees step just need compute mso mso vn arity xed compute 
steps consist application xed nite functions 
query automata unranked trees turn query automata unranked trees 
surprisingly equivalence mso obtained previous section generalize smoothly unranked trees 
obtain expressiveness mso add called stay transitions model 
tree automata unranked trees start recalling de nition bottom tree automata unranked trees 
de nition nondeterministic bottom unranked tree automaton denoted tuple nite set states set nal states function regular language semantics tree denoted de ned inductively follows consists node labeled fq form fq 
tree accepted automaton 
tree language de ned denoted consists trees accepted tree language recognizable exists 
note recognizable ranked unranked trees 
clear context considering ranked unranked trees 
represent string languages nfas 
size sum sizes nfas de ning transition function 
need lemma section 
proof straightforward generalization ranked case see survey vardi 
lemma deciding tree language accepted non empty ptime 
proof 
inductively compute set reachable states de ned follows exists tree 
obviously 
de ne fq fq note jqj jqj de ne jqj clearly computed time linear size testing non emptiness done time polynomial sum sizes see computed time polynomial size concludes proof lemma 
deterministic bottom unranked tree automaton abbreviated mention detailed study tree automata unranked trees initiated br klein murata wood 
generalize theorem unranked trees showing unranked tree language recognizable de nable mso 
de ned mso usual manner mso sentence de ning behavior just guesses states veri es consistency guesses transition function 
longer done fo case ranked trees transition functions determined regular languages 
theorem check readily done mso 
direction show mso type tree computed xed idea ranked case 
type children node tree plus label determine mso 
problem bound number children vertex correspondence children types type subtree longer nite function case ranked trees 
correspondence controlled regular language 
de ne set strings 
tree node labeled children vi 
show regular language 
state proposition 
proposition natural number trees 
mso mso mso 
proof 
proof identical proof proposition 
just combine winning strategies subgames mso mso obtain winning strategy mso game selected nodes de ne partial isomorphisms pairs respective substructures 
ensure de ne partial isomorphism entire structures check relations selected nodes coming di erent substructures 
technicality showing 
note 
spoiler picks root ng th move mso duplicator forced answer root mg 
picks node say round spoiler just picks parent duplicator answer 
holds spoiler picks root duplicator forced pick root suppose play elements chosen root root discussion implies root root simply picked th move subgames 
shown 
suppose play chosen root root 
similar argument shown root root 
proposition implies compute mso type tree incrementally reading mso types starting state mso 
de ne fm mso fm mso trees mso mso clearly 
theorem readily follows 
theorem unranked tree language recognizable de nable mso 
section needing tree automaton computing type mso root input tree 
automaton just slight extension automaton discussed 
show proposition 
precise need item items section 
abbreviate mso root mso root 
proposition natural number label trees node children node children wm 
mso mso mso 

vn root mso wm root vn mso wm wm mso 

label 
ng mg mso root mso root vn root mso wm root label equals label mso 
proof 
focus third case altogether subgames including trivial game structure consists vi wj 
winning strategy game vi vi wj wj just combines winning strategies subgames 
game selected vertices de ne partial isomorphisms pairs respective substructures 
ensure de ne partial isomorphism entire structures check relations chosen elements distinguished constants vi wi 
similarly proof proposition immediately follows observation 
distinguished constants subgames sure game vi vi wj wj child chosen duplicator reply child ii chosen duplicator reply 
need lemma section 
lemma natural number 
exists mso root unranked tree proof 
de ne set take set mso types trees distinguished node 
de ne regular language de ned automaton fm 
automaton de ned follows mso root fm mso root trees mso root mso root proposition matter members classes choose 
approach rst approach de ne query automata unranked trees add selection function way deterministic automata unranked trees de ned br klein murata wood 
turn automata compute rst order logic de nable queries 
de nition way deterministic unranked tree automaton dta tuple leaf root de nition 
transition function transitions form transition function transitions form ng regular string length language fw qg regular 
assure determinism require de nitions con guration leaf root transitions run accepting run carry qa note uniquely determined regular languages 
argue transition run automaton takes linear time 
elaborate structure regular languages 
language contains string length shown languages described nite unions regular expressions form xy strings 
assume languages represented languages 
suppose automaton transition state node label arity look string length exists 
clearly done time linear size input tree represented nite unions regular expressions simple form 
represent regular languages deterministic nite acceptors 
suppose con guration automaton transition children node just check cf 
section belongs 
done time linear size input tree 
way tree automaton readily simulate way 
qb fb bottom deterministic tree automaton unranked trees 
ease exposition assume transitions de ned 
exists qb 

de ne way automaton simulating follows 
runs leaves input tree thereon uses functions qb states intended meaning assigns node lab 
leaf assigns state 
transitions de ned follows 

clearly regular 
furthermore accepts lab root fb state assigned root 
de nition unranked query automaton qa tuple dta mapping 
query computed qa tree language de ned qa de ned analogously qa example consider boolean circuits consisting gates output arbitrary number inputs 
query automaton selects nodes input tree evaluate 
consider trees inputs represent boolean circuits 
de ne qa fand fs zero fsg fu zero de ne 
natural number 
times 
leaf 

ng mixed 


zero ng zero mixed zero 

mixed zero 
automaton rst walks leaves changes state state 
walks back assigning inner node state zero mixed depending evaluation subtrees node returns ones zeros ones zeros respectively 
consider example internal node assigned trees rooted children evaluate 
rst child leaf labeled 
child labeled assigned state children turn evaluate 
child labeled assigned state mixed node children evaluate 
selection function de ned follows op op op fand org mixed op 
qa accept recognizable tree languages compute rst order logic de nable queries illustrated 
proposition unranked query automata compute queries de nable rst order logic 
proof 
alphabet 
consider query select labeled leaves node left siblings labeled 
contradiction suppose exists qa computes query 
set states jqj 
crucial observation exist 
di erent sequences states take root tree 
set 
tree consisting root say labeled children rst children labeled labeled 
exist ng goes sequence root states state arity string states assigned children set states assumed th leaf set states assumed th leaf leaves carry selects select 
leads desired contradiction 
qa compute query proof proposition pass information sibling 
automaton transition node assigns state child child knows state know general states assigned siblings 
resolve introduce section query automata stay transitions 
transitions represented way string automata process string formed states labels children certain node output new state child 
strong query automata tree automata stay transitions de ned 
de nition generalized way deterministic unranked tree automaton dta tuple leaf root de ned de nition 
stay disjoint regular subsets function conditions apply de nition stay transition function stay transitions 
require function computed generalized string query automaton cf 
de nition 
de nitions remain qa stay transitions stay transition con guration con guration node children ii iii children iv identical de ned automata expressive mso 
instance simulate linear space turing machines trees depth 
restrict way de nition strong way deterministic unranked tree automaton dta dta stay transition children node 
lemma show behavior dta de ned mso 
dicult construct mso sentence asserting particular dta stay transitions children particular node 
satis ability mso sentences trees decidable conclude decidable dta dta strong query automaton dta extended selection function 
de nition strong query automaton sqa tuple dta function 
illustrate example 
example recall query proof proposition select labeled leaves node left siblings labeled 
query computed sqa sqa fs stay fsg stay stay natural number 
times leaf stay computed assigns rst labeled node automaton walks leaves stay transition walks back root 
selection function de ned follows 
expressiveness prove query computable sqa de nable mso 
rst emphasize remarkable di erence tree automata query automata unranked trees 
shown proposition stay transitions increase expressiveness respect de ning tree languages 
stay transitions difference respect computing queries shown proposition example 
proposition dta equivalent dta accepting tree language 
proof 
follows directly theorem lemma 
rst generalize lemma query automata unranked trees 
lemma query computed unranked query automaton de ned mso 
proof 
proof similar proof lemma 
notation introduced 
sqa guess sets check consistency 
input sets intended meaning node tv assumed 
opposed proof lemma consistency check longer speci ed rst order logic correctness guesses depends transition functions longer nite functions regular languages 
correctness easily veri ed mso theorem theorem regular languages de ned mso 
correctness behavior functions crucially depends assumption stay transition occur children node 
suppose node labeled transition function children labeled check states 
lab 
lab exist states 
ng case 
ng stay case exist 


unde ned unde ned case 
unde ned case 
ranked case states fn smallest set states containing closed applications de ne unique state states state unde ned 

unde ned 
assumption sqa stay transition children node follows case distinctions suce 
ready prove main result section 
theorem query computable sqa de nable mso 
proof 
direction lemma 
mso formula quanti er depth describe sqa computes query de ned 
automaton nd node tree 
depends mso turn proposition depends mso mso 
case trees nodes child treated proof theorem assume inner nodes child 
describe algorithm evaluates 
mso type subtree computed bottom manner automaton lemma 
automaton transformed equivalent way automaton discussed section 
note way automaton starts step done phases 
re idea proof theorem 
automaton transition 
children enter state remembers mso waits computation subtree nished 
mso type subtree computed bottom 
automaton recognizes subtree evaluation nished meeting states siblings 
transition followed transition 
state remembers mso mso waits termination evaluation subtrees computed parallel 
evaluation simultaneously computes mso vj vj 
step just special case step 
types subtrees children combined type making transition 
step involve information available vertex input compute mso root root mso root depth vertices level root level type computed compute type 
arity compute mso vj vj 
compute mso lab mso vj vj 
compute mso mso mso 
deduce mso holds select 
arity compute mso vj vj mso mso vj vj algorithm computing query de ned unranked trees 
remains show step done sqa noted transition step information types subtrees lost 
sqa rst recomputes mso types mso vj vj described keeping mso mind 
show computing sequence mso 
mso vn vn input mso mso 
mso mso vn vn tree node arity label proposition mso vi vi depends mso mso lab vi depends mso vi vi mso vn 
de ned automaton combining speci ed lemma automata computes mso computes mso vn 
position automaton information output mso vi vi 
step done recomputing mso types vj way step making stay transition 
allowing sqa constant number stay transitions children node increase expressiveness formalism 
proof theorem automaton simulated mso 
decision problems optimization queries studied subjects database theory 
involves instance rewriting queries equivalent ones evaluated eciently detection subqueries evaluate empty set 
checking equivalence nonemptiness queries fundamental operations 
general problem deciding queries equivalent result query empty usually undecidable language theoretic counter parts equivalence emptiness automata known decidable 
establish complexity decision problems automata express queries 
mentioned problems related de ned follows non emptiness query automaton tree 
containment query automata query computed contained query computed trees 
equivalence query automata compute query 
trees 
show problems exptime complete qa qa sqa exptime hardness problems follows exptime hardness non emptiness problem qa exptime membership follows exptime membership non emptiness problem sqa show containment equivalence reduced non emptiness polynomial time query automata ranked trees special cases query automata unranked trees 
size sqa sum sizes dfas representing transitions stay sizes automata stay transitions sizes regular expressions representing transitions size set states sqa point proof theorem need dfas opposed nfas representation transitions 
start observing deciding tree language de ned dta non empty exptime hard 
reduction person corridor tiling known hard exptime 
natural numbers view ng mg rectangle consisting rows width nite set tiles horizontal vertical constraints bottom top row 
corridor tiling mapping ng mg natural number rst row th row person corridor tiling game players turn place tiles row wise bottom top left right row 
rst player starts newly placed tile consistent tiles placed 
rst player tries corridor tiling second player tries prevent 
rst player achieve tiling matter second player plays say player wins corridor game 
player puts tile consistent tiles placed immediately looses 
person corridor tiling problem decide set tiles sequence tiles player wins corridor game 
proposition deciding deterministic way ranked tree automaton accepts tree hard exptime 
proof 
reduce person corridor tiling non emptiness dta strategy player represented tree nodes labeled tiles 
put rows tiling top branch sequence labels root leaf tree represents possible tiling 
forget start row moment odd depth nodes siblings represent moves player depth nodes siblings represent choices player 
strategy winning branch corridor tiling tiling player false move 
dta construct accept trees correspond winning strategies player 
automaton essentially check horizontal vertical constraints 
vertical constraints node input tree checked moving nodes width corridor horizontal constraints checked looking tile carried parent formally de ne tree represents winning strategy 
take ng node labeled means player places tile th position current row 
case just de ne rst nodes labeled say tree represents winning strategy rst player holds 
starts monadic tree labeled root carries label child root carries label 

exists node depth recall root depth exists node say additionally lab player places tile rst column second row second row form corridor tiling 

internal node lab parent lab mod mod means players place tiles turn 

siblings labeled label nodes corresponding moves player siblings 

alternative player node lab child labeled mod 

branch extended corresponds corridor tiling contain false move player 
dta works trees rank jt jhj jv clearly checked number states linear consider 
suppose arrives order check horizontal constraints remembered tile parent state moved 
check vertical constraints just move nodes get tile placed immediately square corresponding moving requires cooperation siblings 
moves tree level level level transitions get required tile 
number states linear needed 
computed logspace 
show non emptiness sqa exptime device 
way deterministic nite automaton pebble dfa pebble lay input string pick back 
refrain giving formal de nition automata informally describe algorithmic computations 
blum hewitt showed automata de ne regular languages 
need stronger result obtained harel proposition 
proposition way deterministic nite automaton pebble equivalent nfa size exponential size fact size uniformly bounded function 
jsj polynomials alphabet set states additionally constructed time exponential size ready prove theorem 
theorem non emptiness sqa exptime 
proof 
describe exptime algorithm decides sqa non empty 
proof consists parts 
de ne way deterministic unranked tree automaton nonempty accepts tree say non empty 
size linear size subsequently show testing non emptiness way deterministic unranked tree automata exptime 
implies non emptiness sqa exptime 
construction way deterministic automaton works alphabet 
input rst checks exactly node label 
done traversal tree root leaves 
node rejects 
walks back root starts simulating just behaves selecting nodes 
unique node label 
accepts additionally selects achieved keeping ag state moment selects clearly size linear size testing non emptiness way deterministic unranked tree automata exptime 
automaton 
construct nondeterministic bottom automaton qb fb cf 
section size exponential size additional property non empty non empty 
lemma know testing non emptiness ptime 
testing non emptiness way deterministic automata exptime 
set states qb consists tuples form partial function total functions describe intuition components states qb introduce notion 
state assignment tree mapping nodes state assignment semi valid node arity 
vn lab leaf node lab 
say state assignment tree valid semi valid root clearly tree accepted exists valid state assignment 
intuition states qb semi valid state assignment tree tv lab 
functions just facilitate de nition transition function de ne 
state qb 




de ned possibilities ng case 

stay case 


unde ned unde ned case 
unde ned case 

unde ned 
assumption sqa stay transition children node follows case distinctions suce 
de ne fb states root 
readily checked semi valid state assignment tree tv lab 
de nition fb accepts exists valid state assignment consequently non empty non empty 
remains show accepted nfa size exponential size de ne twoway deterministic automaton size polynomial accepts 
lemma equivalent nfa size exponential 
depend input root 
function mapping root 
depend input 
describe case de ned converse case similar 
test 
just simulate nite union regular expressions representing string 

done subsequently trying match regular expression union 
due simple form regular expressions xy needs number states linear size expressions 
tests 
stay stay ng 
test performed sweep input string depending test 
simply simulates dfa tests sweep 
needs number states linear size automaton 
second case veri es 


done simulating recall convention outputs symbol position 
done sweep input string simulating dfa 
linear number states size needed 
brie come back need dfas nfas case unde ned check transition unde ned certain sequence states 
transitions represented dfas easy just simulate automaton see gets stuck 
nfa harder check computations unde ned 
show reduce containment non emptiness 
sqa working trees 
de ne sqa working trees labeled symbols alphabet follows 
input rst checks exactly node label 
done traversal tree root leaves 
node rejects 
unique node label 
walks back root rst simulates remembers automaton selects recall convention consider automata terminate input 
selects selects select halts 
non empty contained size linear sizes non emptiness exptime follows containment exptime 
clearly equivalent automata contained theorem 
theorem equivalence containment qa qa sqa exptime 
discussion introduced query automata expressing unary queries structured documents 
investigated expressiveness established complexity decision problems relevant optimization 
considered ranked unranked trees 
received new attention context sgml xml 
theory automata unranked trees developed br klein murata wood applied neven murata neumann seidl neven 
particular pointed subtle di erence query automata ranked unranked trees 
extension way automata ranked trees selection function capture unary mso queries needed special stay transitions unranked case 
joost engelfriet wolfgang thomas jan van den bussche moshe vardi stimulating discussions 
initial idea query automata gratefully acknowledged jan van den bussche 
joost engelfriet pointed lemma 
abiteboul buneman suciu 
data web relations semistructured data xml 
morgan kaufmann 
abiteboul cluet milo 
logical view structured les 
vldb journal 
abiteboul hull vianu 
foundations databases 
addison wesley 
aho hopcroft ullman 
general theory translation 
mathematical systems theory 
baeza yates navarro 
integrating contents structure text retrieval 
acm sigmod record march 
baeza yates ribeiro neto 
modern information retrieval 
addison wesley 
beeri milo 
schemas integration translation structured semi structured data 
buneman beeri editor database theory icdt volume lecture notes computer science pages 
springer verlag 
blum hewitt 
automata dimensional tape 
conference record eighth annual symposium switching automata theory pages 
ieee 
br klein murata wood 
regular tree languages non ranked alphabets draft 
unpublished manuscript 
uchi 
weak second order arithmetic nite automata 
math 
logik 
math 

domino tiling games 
journal computer system sciences 
clark 
extensible stylesheet language xsl 
www org tr wd xsl 
world wide web consortium 
extensible markup language xml 
www org xml 
courcelle 
graph rewriting algebraic logic approach 
van leeuwen editor handbook theoretical computer science volume chapter 
elsevier 
deutsch fernandez florescu levy suciu 
query language xml 
www org 

tree acceptors applications 
journal computer system sciences 

ebbinghaus flum 
finite model theory 
springer 
engelfriet 
way automata checking automata 
mathematical centre tracts pages 
engelfriet 
way nite state transducers monadic second order logic 
van emde boas nielsen editors automata languages programming th international colloquium icalp volume lecture notes computer science pages 
springer 

tree languages 
rozenberg salomaa chapter 
harel 
complexity results way multi pebble automata logics 
theoretical computer science 
gonnet tompa 
mind grammar new approach modelling text 
proceedings th conference vldb pages 
gyssens paredaens van gucht 
grammar approach unifying hierarchical data models 
siam journal computing 
hopcroft ullman 
approach uni ed theory automata 
bell systems technical journal 
hopcroft ullman 
automata theory languages computation 
addison wesley 
lind en mannila 
structured text database system 
furuta editor proceedings international conference electronic publishing document manipulation typography cambridge series electronic publishing pages 
cambridge university press 
mannila 
retrieval hierarchical texts partial patterns 
proceedings sixteenth international conference research development information retrieval pages 
acm press 
mannila 
query primitives tree structured data 
crochemore gus eld editors proceedings fth symposium combinatorial pattern matching pages 
springer verlag 
ladner 
application model theoretic games discrete linear orders nite automata 
information control april 
neven 
formalization tree transformations xsl 
appear proceedings seventh international workshop database programming languages lecture notes computer science 

way tree automata 
information processing letters 
murata 
forest regular languages tree regular languages 
unpublished manuscript 
murata 
data model document transformation assembly 
proceedings workshop principles digital document processing 
appear lncs 
neumann seidl 
locating matches tree patterns forests 
arvind ramanujam editors foundations software technology theoretical computer science lecture notes computer science pages 
springer 
neven 
design analysis query languages structured documents formal logical approach 
doctor thesis centrum luc 
neven 
extensions attribute grammars structured document queries 
appear proceedings seventh international workshop database programming languages lecture notes computer science 
neven van den bussche 
expressiveness structured document query languages attribute grammars 
proceedings seventeenth acm symposium principles database systems pages 
acm press 
pair 
nition etude des 
information control 
rozenberg salomaa editors 
handbook formal languages volume 
springer 

systems linear recurrences regular sets extended 
kuich editor automata languages programming th international colloquium icalp volume lecture notes computer science pages 
springer 
shepherdson 
reduction way automata way automata 
ibm journal research development pages 
takahashi 
generalizations regular sets application study context free languages 
information control 
thatcher wright 
generalized nite automata theory application decision problem second order logic 
mathematical systems theory 
thomas 
ehrenfeucht games composition method monadic theory ordinal words 
volume lecture notes computer science pages 
springer verlag 
thomas 
languages automata logic 
rozenberg salomaa chapter 
vardi 
automata theory database theoreticians 
proceedings eighth acm symposium principles database systems pages 
acm press 

