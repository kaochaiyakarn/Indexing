lazy lexing fast manuel chakravarty institute information sciences electronics university tsukuba japan tsukuba ac jp www score tsukuba ac jp introduces set combinators building lexical analysers lazy functional language 
lexical analysis combinators generate deterministic table driven analyser fly 
consequently method combines efficiency line scanner generators flexibility combinator approach 
method essential lazy semantics implementation language haskell 
discusses benchmarks scanner programming language conceptually different approaches obtaining functional implementation scanner parser formal lexical syntactic specification specification written special purpose language translated functional program scanner parser generator specification composed set combinators provided scanner parser combinator library 
approaches advantages pursued past 
couple generators widely languages haskell sml number combinator libraries :10.1.1.34.1287
usually generators produce efficient scanners parsers implementing table driven analysers case parsers expense expressiveness generators usually confine specification restricted class languages lalr 
furthermore combinator libraries easier handle separate input language generator program necessary specify analysers statically unknown grammars grammar change program execution 
swierstra duponcheel introduced self optimising parser combinators parsing generate deterministic analyser ll grammars combining flexibility combinators efficiency generators 
introduces related technique lexical analysers lexers short 
application lexer deterministic table driven analyser generated fly combinator lexical specification 
tokens produced user defined actions standard principle longest match applied non regular features nested comments supported meta actions 
described technique fully implemented haskell library called lexers code available public 
efficiency technique evaluated download www score tsukuba ac jp benchmarking implementation lexer programming language despite relation mentioned swierstra duponcheel parser generators technique substantially different theirs 
interesting aside haskell lazy evaluation semantics 
state transition tables generated lexer combinators achieve deterministic behaviour represented cyclic tree structure requires non strict semantics impure mutable structures 
additional advantage laziness fragments table constructed needed accept input hand 
avoid overly high startup costs short inputs incurred non strict eager lenient languages ph 
summary central contributions new technique line generation state transition tables regular expressions lazy functional language 
combinator library specifying lexical analysers including required nonregular features 
experimental evaluation proposed table generation technique 
structured follows 
section introduces basic ideas combinator library table generation 
section defines interface combinator library section formalises dynamic table generation 
section presents benchmarks 
section discusses related section concludes 
combinators automata specifications lexers essentially consist pairs regular expressions actions program fragments executed soon associated regular expression matches current input 
actions usually generate tokens consumed parser lexer 
regular expressions typically structure matches empty word 
single character matches 
matches word part matched second part matches word matched matches word consists zero successive words matched matches word consists successive words matched 
matches word empty matched furthermore abbreviate 
example integer numbers matched optional minus sign followed non empty sequence digits 
regular expression expressed haskell follows define combinators detail section char quest alt plus epsilon improved typesetting char 
alt 
lexer specification regular expression paired action string lexeme recognised integer produces corresponding token 
known result automata theory states regular expression exists finite state automaton fa accepts exactly words matched regular expression precisely exists deterministic finite state automaton dfa state looking input symbol decide deterministically state automaton go 
correspondence exploited scanner generators produce deterministic table driven analyser lexical specification 
technique builds theory 
additional complication handling full lexical specification opposed single regular expression requirement match set regular expressions single pass 
implementing matching regular expression dfa get table driven lexer 
lexer represents state transition graph automaton twodimensional table 
lexical analysis traverses transition graph repeatedly indexing table current automaton state input symbol obtain state 
standard approach table constructed line scanner generator 
precisely regular expressions transformed nondeterministic finite automaton nfa nfa converted dfa dfa directly obtained regular expressions number states dfa minimised table stored compressed format tends sparse 
standard technology described detail compiler textbooks 
generate automaton incrementally lexing approach avoid expensive techniques subset construction 
essentially build state transition graph dfa directly regular expressions construct node graph reach lexing 
representing graph directly encoding table facilitates incremental construction reduces storage requirements comparison uncompressed table transition table usually sparse 
interface discuss details automata construction fix combinator set lexical specification 
consists regular expressions actions meta actions regular expressions describe structure lexemes actions specify transformation lexemes tokens meta actions keep track line numbers implement non regular features nested comments 
regular expressions sets lexemes trigger action usually generate sort token specified regular expressions freely constructed set combinators resemble operators regular expressions discussed previous section 
regular expression denoted haskell expression type regexp 
regular expression type arguments lexer maintains internal state type produces tokens type possible hide type variables add point non standard feature explicit universal quantification cost slightly complicating definitions 
combinators available constructing regular expressions regexp empty word char char regexp single character 
regexp regexp regexp concatenation regexp regexp regexp alternatives regexp regexp regexp zero rep 
regexp regexp regexp repetitions 
regexp regexp regexp zero occurences define 
terms combinators shall return details definitions 
furthermore definitions useful making regular expressions concise alt char regexp alt char 
char string string regexp string char 
char precedence declarations apply xl xl xl combinators straight forward define familiar token types identifiers ident regexp ident letter 
letter digit letter alt digit alt words identifier composed letter followed zero letters digits 
note regular expression infix operator requires second argument 
point view regular expressions natural choice unary postfix operators 
haskell postfix operators unary operator implementation difficult see section binary nature operators allows important optimization 
presentation takes freedom improve purely ascii typesetting haskell expressions 
ascii represented epsilon 
star plus 
quest 
actions lexer recognises lexeme matching regular expression applies action function lexeme position produce token 
type action string position action may choose produce token return example lexeme represents white space comment 
function regexp action lexer bundle regular expression action form lexer denoted types lexer user defined state tokens disjunctively combine collection lexers combinator xl lexer lexer lexer functions continue example lexing identifiers definition regular expression ident tokens defined data token string position 
define lexer recognises identifiers lexer token ident str pos just str pos compound lexer recognises sequences identifiers separated space characters defined follows lexer lexer token lexer char meta actions addition actions produce tokens meta actions alter internal behaviour produced lexer 
normal action meta action function type meta position 
position lexer current position user defined lexer state type meta action produces updated position updated user defined state 
furthermore may choose return lexer current analyse token 
user defined state example implement gensym routine maintain identifier table lexical analysis 
combination capability returning lexer implement non regular features nested comments 
realise follows user defined state keeps track current nesting level 
different lexers standard lexer recognises tokens outside comments comment lexer keeps track nesting level scanning comments 
lexing process encounters lexeme starting comment invokes meta action increases nesting count returns third component result comment lexer 
lexing process encounters lexeme comment triggers meta action decreases nesting count returns standard lexer nesting count reached zero returns comment lexer 
note technique kind cleaned side effect free variant userdefined start states parser generators lex 
standard actions combine meta actions regular expressions lexers regexp meta lexer library lexers discussed internally uses meta actions keep track positions presence control characters way position triple composed file name row column lexer char nn newline char nr newline char nf char nt tab newline fname row fname row fname row col fname row col tab fname row col fname row col col mod lexing performing lexical analysis lexer maintains lexer state type string position composed remaining input string current source position user defined component state transformed meta actions 
lexer lexer state function executes lexical analysis yields token string actual implementation lexers library function returns final lexer state list error messages 
lexer state case state state state just state state definition uses read single lexeme input stream 
token produced added resulting token stream 
case recurses process reminder input case just read token triggered meta action lexer recursion may differ signature defined detail lexer 
lexer table construction lexical analysis interface previous section difficult imagine standard combinator implementation similar 
disadvantage naive implementation low efficiency see section 
mentioned standard method making lexers efficient transform specification state transition table deterministic finite automaton 
main contribution purely functional algorithm fly constructs dfa compressed table representation regular expressions 
improve execution time short inputs big lexical specifications parts table needed lexing input hand constructed 
achieve implementing combinators building regular expressions smart constructors transition table regarding regular expression data structure processed table construction function 
precisely expression type lexer combination regular expressions actions evaluates state transition table dfa accepts exactly lexemes specified regular expressions actions automaton final states table construction algorithm encoded combinators forming regular expressions 
table representation imperative algorithms state transition table may represented dimensional array indexed current automaton state current input symbol 
representation problems table tends sparse incrementally refine table 
sparseness table course interesting point imperative lexers table stored compressed format line table construction completed 
approach attractive line approach table constructed lexing 
regarding second point incremental table construction requires frequent updates transition table eventually table lexical specification completed operation expensive big arrays purely functional programming style 
advanced data structures available functional language directly represent state transition graph dfa conventional table representation 
state transition graph directed cyclic graph direct representation requires non strict functional language impure operations mutable structures 
node graph represents state dfa edge represents state transition labelled input character triggering transition 
represent dfa nfa outgoing edge possible input character node 
final states dfa associated action initial state graph node root 
represent dfa lexer structure data lexer state char lexer data action action meta meta noaction state different noaction represents final state 
continuation association list admissible transitions acceptable character current state contains node graph reached associated character read 
example state ac graph node represents state outgoing edges 
reading states respectively reached 
action ac executed choice 
actual implementation library lexers uses different kinds nodes state represent states kind states outgoing edges states outgoing edges 
uses association list definition uses array associate input characters successor nodes 
increases efficiency lookup case outgoing edges alter essence actual table construction algorithm 
basic table construction discussing table construction operators fix type definition regular expressions 
type regexp lexer lexer essential point regular expression lexer extended lexer form new lexer 
words re word matching regular expression re accepted rest input handed lexer may final state associated action 
words match arbitrary prefix re automaton reaches remember expressions type lexer represent states automaton individual node state transition graph specifies consumption single character associated transition 
definition char straight forward 
regexp id char char regexp char state noaction 
regexp regexp regexp 
functions id identity function function composition respectively 
immediately follows left right neutral furthermore associative 
properties required formal language theory 
definition requires little care regexp action lexer re re state action adds final state containing action transitions regular expression 
interesting combinators alternatives introduce constructing nfa directly construct dfa immediately resolve potential 
avoid dealing problems combinators define terms regexp regexp regexp re re re re essentially means regular expression re re re continuation re re re words case alternative independent branch take reach suffix 
definition associative commutative define lexer lexer lexer state state state accum function combines transitions actions separately 
transition tables combined accum concatenates association lists applies auxiliary functions accum replace pairs conflicting occurrences new pair omit precise definition accum slightly tedious new insights 
function combines actions noaction noaction error lexers ambiguous action 
states action raises error implies lexeme associated actions execute 
indicates error lexical specification 
definition associativity commutativity easily deduce associativity commutativity example consider char ac char char ac regular expression common prefix initial state resulting lexer single transition character state contains action ac making final state contains transition third state contains action ac transition possible 
get lexer state noaction state ac state ac example illustrates action get middle complex lexer 
example may appear choice ac ac accepting ab principle longest match shall discuss section disambiguates choice requires lexer execute ac point reason design decision earlier definition lexer data type clear 
considering single regular expression action reasonable pair action root transition graph allowing action state putting initial action tips structure representing lexer 
just saw lexers disjunctively combined actions may may move middle transition graph exact location action graph important sufficient collect actions root graph 
cyclic graphs remaining combinators regular expressions build basic combinators just discussed 
definition straight forward 
regexp regexp regexp re re re re re recursive behaviour requires additional thought 
attempt define follows regexp regexp regexp re re self re self self re recursion realised local definition self empty word word matched re followed self self followed re 
words re zero times continuing re 
definition correct unfortunately operationally awkward 
create cyclic graph produces infinite path repeating re 
path constructed lazily definition works construction state transition graph consumes memory time proportional length accepted lexeme size regular expression 
fortunately turn inefficient definition equational reasoning efficient harder understand definition self re self self re self re self self re beta self re self self re 
beta self re self self re self re self self re inside self re self self re re self re self self self re self re self reason different behaviour initial derived definition original definition self type regexp st functional derived definition type lexer datatype want create cycle 
note subsection calculation depends binary operator unary postfix operator 
remains definition simple expressed terms regexp regexp regexp re re re 
re re lexing state transition graph implement lexing process traversal graphical dfa representation 
lazy evaluation graph ensures portions table necessary lexing input hand evaluated part graph evaluated 
subsection definition function reads single lexeme 
encode graph traversal tail recursive function input string 
main complication function implementation principle longest match take action encounter take possible action automaton gets stuck 
traversal keep track action passed lexeme recognised point 
transition possible execute action associated lexeme action encountered lexical error 
concrete definition recursive function collect collects characters current lexeme 
addition current lexer state maintains accumulator collecting lexeme third argument encountered action fourth argument 
initially error valid action encountered lexing 
type lexer lexer state collect state error lexical error value type comprises information associated lexeme possibly token lexer applied state reached reading lexeme 
implementation collect distinguishes cases dependent input symbol transition table cls collect lexer string collect state cls state cs pos lexeme action state lexeme case cs cs case lookup cls just collect cs pos lexeme auxiliary function action compute action result applies actions current lexer state recognised lexeme shall return definition 
decide react current input character perform lookup transition table cls character transition table valid transition dfa current input symbol result action automaton transition state associated current input symbol transition table furthermore current lexeme extended character just read 
function action deals possible cases data type follows action string function lookup eq haskell prelude 
action noaction action action cs pos lexeme lexeme cs pos lexeme action meta cs pos lexeme pos pos lexeme cs pos function adjust current position length lexeme definition fix concrete representation positions 
third equation action case meta action function meta action applied yield new position pos user defined state possibly new lexer function selects new lexer uses current lexer clear keeping track action fourth argument collect action realises principle longest match means lazy evaluation delays execution candidate actions known 
accumulating lexeme appending individual list elements definition collect inefficient 
lexers library difference lists similar shows haskell prelude allow constant time appends 
benchmarks performance technique measured coding lexer programming language lexers library implementing handcoded lexer set regular expressions 
comparison gives estimate overhead incurred convenient lexers library 
handcoded lexer implements dfa pattern matching character remaining input 
carries overhead lexers keeping track token positions scope optimisations expected big difference 
programs compiled glasgow haskell compiler ghc version optimisation level 
experiments conducted mhz celeron processor linux 
haskell source library specification lexer ghc specific optimisations language features input string naively represented cons list characters 
benchmark input lexer artificial code contains struct fields times header file gtk gui library expanded standard pre processor 
files kilobyte real stress tests toy examples 
results summarised table include time best results runs unloaded machine lexers handcoded input size byte time sec tokens sec time sec tokens sec gtk structs haskell standard library defines results show large input optimising lexer combinators ball park handcoded lexer needs execution time 
related comparison line scanner generators added flexibility ease approach comes increased startup costs graph build inability perform optimisations automaton computing minimal automaton 
lazy evaluation avoids startup costs partially input requires regular expressions lexical specification 
regarding related main part relation automata theory underlying scanner generators clear 
interesting establish formal correspondence dfa created lexer combinators produced various line automata construction algorithms 
formal result believe automata constructed algorithm constructs dfa directly set regular expression 
furthermore mentions technique called lazy transition evaluation 
constructs transition table runtime aim avoid state explosion occur generation dfa regular expressions worst case number states dfa grow exponentially size regular expression 
technique state transitions stored cache fixed size 
case cache transition computed standard algorithms stored cache may removed cache transitions needed 
technique essential mutable data structures substantially different aim working principle developed search routines text editors 
swierstra duponcheel parser combinators provided inspiration searching related technique works lexical analysis 
approach theory sll stack automata technique theory finite state automata 
technique significantly different 
discussed approach lexical analysis lazy functional language combines ease flexibility combinator libraries efficiency lexical analyser generators 
approach lexical analyser specified set pairs regular expressions actions functions combinator library 
combinators smart constructors building state transition graph deterministic finite state automaton implementing regular expressions 
graph lazily constructed lexing cycles represent recursive combinators 
worth noting discussed technique essential laziness regarded practical example usefulness lazy evaluation 
non strictness allows significantly optimise implementation recursive combinators exploiting cyclic structures 
furthermore lazy construction state transition graph minimises startup costs input regular expressions lexical specification 
cyclic structures definitely advanced feature haskell requires experience showed equational reasoning help compute efficient solution cyclic structures efficient easier understand implementation 
furthermore implementation principle longest match simplified lazy evaluation keep track action 
lazy list characters input lexer definitely efficient choice 
simplifies presentation function collect depends representation input 
hard adapt efficient form reading character stream 
furthermore attractive represent lexers monads presents technical challenges similar reported 
regarding interesting investigate algorithm formally derived underlying automata theory informally described 

am indebted simon peyton jones number suggestions helped improve lexers library considerably 
furthermore am grateful gabriele keller anonymous referees helpful comments suggestions 
roman feedback lexers library 

alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley publishing 

andrew appel james mattson david 
lexical analyzer generator standard ml 
cm bell labs com cm cs doc manual html 

graham hutton 
higher order functions parsing 
journal functional programming 

graham hutton erik meijer 
monadic parsing haskell 
journal functional programming 

simon marlow 
happy user guide 
www dcs gla ac uk fp software happy doc happy html 

nikhil arvind james hicks aditya lennart augustsson jan willem zhou 
ph language manual version 
technical report massachussets institute technology laboratory computer science 

swierstra duponcheel 
deterministic error correcting combinator parsers 
john launchbury erik meijer tim sheard editors advanced functional programming volume lecture notes computer science pages 
springer verlag 

david tarditi andrew appel 
ml yacc user manual 
cm 
com cm cs doc ml yacc manual html 

william waite gerhard goos 
compiler construction 
springer verlag second edition 
