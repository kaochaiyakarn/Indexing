chapter reasoning time higher level language software alan shaw methodology specifying proving assertions time higher level language programs described 
approach develops ideas distinction treatment real time computer times upper lower bounds execution times program elements simple extension hoare logic include effects passage real time 
schemas examples timing bounds assertions variety different statement types programs conventional sequential programs including loops time related statements delay concurrent programs synchronization software presence interrupts 
examples assertions proven include deadlines timing invariants periodic processes specification time events needed recognition single double clicks mouse button 
real time systems computer applications meet specifications perform tasks satisfy timing logical criteria correctness 
examples timing properties constraints include deadlines periodic execution processes external event recognition time occurrence 
scheme reasoning time specifying timing properties concurrent programs 
objectives predict tim chapter reasoning time higher level language software alan shaw appeared ieee transactions software engineering vol 
pp 
july fl ieee 
sec 
ing behavior higher level language programs prove meet timing constraints direct analysis program statements 
timing deterministic stochastic results applicable hard real time systems 
clear distinction recognized timing predictability hand speed efficiency 
important concerned primarily predictability 
higher level languages considered frequently constructing concurrent real time software standard reasons offer facilities structuring data control modularization programs easier design code results easier understand maintain software portable 
missing ability predict timing behavior programs methods reason time programs 
major ideas developed 
upper lower bounds execution times statements derived bounds primitive statements elements language underlying system 
schemas obtaining bounds conventional sequential statements including loops timing related statements refer imperfect computer clocks synchronization communications operations timeouts 
second idea extend hoare logic include effects updating real time defined ideal global clock statement execution 
examples illustrate techniques 
main contributions development synthesis ideas demonstrations program assertions invariants involving time 
works related influenced research 
methodology similarities proposed haase 
methods assume concurrent programming language guarded commands running non von neumann architecture deterministic execution time simple statement execution times conditional elements iterations need defined 
dijkstra weakest preconditions employed making proving assertions 
assume range conventional machine architectures develop time bounds reflect execution control conditional iteration data transforming operations 
haase distinguish computer time real time analyze timing behavior timing related statements communications operations 
haase introduces real time fictitious variable program space updated reflect exact execution times idea initially derive running bounds real time 
influenced jahanian mok argue notion real time clock variable realized correctly concurrency problems presentation pnueli argues clock variables feasible 
literature derive execution time statements higher level programming languages 
machine language level knuth techniques conventional sequential programs 
interesting attempt designing language deterministic timing predictability esterel project esterel instructions take zero time sec 
simple logic handling time deal explicitly time external events 
esterel appears predictability received attention 
fact part motivation research lack predictability languages systems proposed real time applications ada course outstanding example 
section presents basis elements techniques dealing time 
sections show timing bounds assertions produced variety different statement types programs 
section additional practical issues related interrupt handling processor sharing introduced 
concluding section discusses areas steps 
simple logic handling time real time computer time reasoning time refers ultimately idealization real time realized perfect global clock 
real time denoted rt may example greenwich mean time 
computer time discrete approximation real time implemented machines variety hardware software methods 
hardware level may fixed interval programmable interval timers produce tick interrupts absolute timers periodically update software accessible counter 
software clock typically tick interrupts value absolute time counter generate computer time 
versions computer time exist system 
assume version approximately synchronized perfect real time follows 
ct represents computer time ct rt ffi ffi determined accuracy hardware clock tick interval synchronization interval synchronization method 
relation include access time obtain compute ct assumed implicitly real time rt represented real number ct computer approximation real number 
ct normally complex data structure separate components designating example year month day hour minutes seconds 
updating clock computing time variable reading computer clock consume significant amount time 
effects considered section 
initial architectural assumptions broad spectrum hardware architectures possible 
may processors private shared memory communicate shared memory directly bus general communications network sec 
simple logic handling time combination 
programmed processes tasks considered static dynamic creation run time initialization period 
assume software process dedicated processor timesharing machines 
includes processes responsible input output 
similarly clock computes version time dedicated processor 
relax assumptions permit simple basis treatment time 
association processes processors feasible allocation scheme systems performance timing predictability critical especially era reduced hardware costs 
software interference operating system functions dispatching interrupt handling input output occur 
effects hardware sharing example due common memory bus contention factored execution times program statements 
execution times statements aim analyze directly higher level language programs 
assume modern algol language augmented functions handling computer time process synchronization communication input output real time external world standard input output 
program consists textually statements plus declarative text 
particular execution statement delimited events start event event 
events just points time consume time 
real time events 
ideally know execution time execution statement program 
unfortunately way determine priori general 
value depends context data program compiler run time system target machine possibly things 
possible obtain bounds 
min max min max executions program 
worst case better 
chapter concerned methods finding tight bounds various types statements emphasized general dependent particular language context compiler run time system target machine 
generally provided elementary statements expressions control structures derived computed elaborate constructs 
simple example sequential composition statements yielding bounds define 
assumes event occurs simultaneously start event conceivable sec 
simple logic handling time sequential control consume time particular realization programming language 
including sequencing overhead obtain time sequencing interpretation chapter 
similarly consider system concurrent processes associated programs respectively 
denote indicates concurrent control 
execution time bounds typically max max defined max max overhead corresponding running parallel 
lower level conventional conditional construct may performance theta control flow times time transfer assuming execution time transfer transfer testing may simply min max develop section schemas illustrated independent program context stronger bounds may derivable context known 
hoare logic time standard hoare logic uses assertions respectively statement notation interpretation true execution executed true assuming terminates 
perfect knowledge timing augment form fpg rt rt fqg sec 
simple logic handling time include relations involving real time rt execution start events respectively brackets 
indicate execution incrementing rt occur time 
assumed statement incrementing rt takes zero time 
axiom assignment assertions rt 
example rt assert fp rt fp rt gamma fp rt fp rt approximation unrealizable ideal rule fpg rt rt fqg rt pair rt min rt max time perfect real time rt interval defined rt min rt max may include assertions elements rt avoid naming conflicts rt statements composed introduce local real time variable rt statement fpg rt rt rt rt fqg trick employed 
brevity shorten standard hoare form henceforth appears assumed abbreviation 
bounded intervals exactly interval numbers defined analyzed kind arithmetic 
example oe operator symbols theta gamma oe fx oe bounded intervals rt treated sets numbers 
notation rt indicate range defined bounds 
bounded intervals denoted uppercase names 
examples extended logic express conveniently basic timing properties constraints 
examples sections provide detailed reasonings proofs particular program instances 

performance specifications starts executing timing interval rt start finish interval rt start 
frt rt start frt rt start simple variation frt start frt start sec 
simple logic handling time assertion abbreviated rt start start shortening start start 

deadlines rt dl deadlines program completed earlier general deadline problem expressed employing axiom assignment frt rt dl frt rt dl start event real time bounded gamma min rt gamma max impossible meet constraint gamma min gamma max letting gamma directly easy specify conventional deadline constraint frt gamma max frt similar expression produced earliest finish time constraint 
control periodic process consider program executed periodically starting time rt start appropriate invariant involving time rt execution rt start theta period rt delta eps computed start time cycle usually program variable gives number executions period time interval allocated cycle delta error bounded eps relative real time 
directly assumed delay introduced computer clock fill entire period 
implementation example developed analyzed section 
sec 
reasoning execution times sequential programs reasoning execution times sequential programs expressions simple statements consider straight line programs consisting assignment statements procedure calls form respectively exp name variable name exp expression name procedure identifier actual parameters procedure call 
assume exp syntax exp name exp exp denotes constant name function identifier basic binary operator 
separate analysis system example compiler target machine done produce execution times primitive entities follows retrieve value variable constant may just time load register 
obtain address variable cases addresses known compile time 
perform assignment 
typically value store time target machine 
execute basic operation call return call return procedure function 
par pass parameter procedure function 
may variations par type parameter example par call par call value 
times higher level constructs computed adding bounds obvious manner 
schema assignment statement exp exp procedure call time property name call return theta par body sec 
reasoning execution times sequential programs body program text procedure 
parameter general expression necessary add corresponding term 
schemes course take account various compiler optimizations occur 
example procedure call mod mod smart compiler choose evaluate common expression twice giving execution time bounds call return theta par body assuming parameters value parameters 
expression evaluation handled similarly example mod mod mod 
sequential composition statements yields execution times discussed earlier section 
target machine details resource allocation strategies fast registers possible compiler optimizations increase difficulty obtaining bounds manually 
anticipated machine assistance available analyzing actual compiler produced code especially straight line cases considered section 
example analyze simple assignment statement schema obtain execution time corresponds generous machine language program load load add load store indirect machine architecture permit tighter program load add store sec 
reasoning execution times sequential programs instance 
better may value previously loaded register reducing program instructions 
course extreme happen registers may contain valuable information saved executing assignment statement adding instructions 
simple cases straight line code may exact execution time predictable 
cases bounds predictable 
compiled code example may compute addresses variables run time 
hardware features memory contention instruction look ahead caching results account range possible execution times 
conditional looping constructs typical conditional constructs case statements bn sn 
case expr sn case conventional realizations statements transfer false transfer transfer false transfer delta delta delta bn transfer false sn means code construct 
case expr ng expr transfer transfer sec 
reasoning execution times sequential programs transfer delta delta delta sn primitive entities statements control flow objects realized transfer instructions 
time bounds objects case 
assume transfers time bounds conditional unconditional transfers take time case general may different values 
bounds execution times follows min theta sn min min theta max case expr theta case case expr sn case min max detail making calculations expected machine aids available assist analysis statements 
illustrate schemas method analysis loops consider common instances infinite loop usually implementing cyclic process loop loop classical statement sec 
reasoning execution times sequential programs primitive loop time designated loop just correspond time unconditionally branch back loop execution similarly statement basic object execution time corresponding unconditional branch back execution conditional test branch evaluating construct assumed conditional unconditional branches regardless branch taken consume amount time time bounds 
times course different values change methods analysis details 
analysis purposes auxiliary counting variable maintained loop follows loop loop counting variable gives number executions statements involving take zero time execute 
straightforward derive basic timing invariant kinds loops 
rt start denote real time bounds start event loop 
infinite loop invariant start event rt rt start theta loop theta defined theta theta statement slightly complex tested time loop control decision continue transfer 
account obtain invariant loop rt rt start theta theta simplifies rt rt start theta theta theta type analysis leads execution bounds statement 
number executions loop known just rt gamma rt start invariant giving theta theta theta propose obtain bounds hoare logic techniques similar developed proving termination loops 
min nmax timing bounds construct theta theta theta notation defined theta ac bd 
sec 
reasoning execution times sequential programs point worth noting order able predict timing behavior simply bounds loop executions 
real time programming language explicitly includes limits number iterations execution time loop 
examples 
ideas illustrated standard toy example program compute integer approximation square root integer 
conventional assertions appear comments braces 
fx fa dg fa xg fa loop invariant fa loop termination permits implication fa largest integer equal square root auxiliary counting variable identical values program variable termination xc 
termination proven trivially noting increases time loop bounded remain true forever 
input restricted range xmax xmax tightest possible bounds 
practical 
assuming program execution time bounds 
theta theta theta 
interesting example program computes max roundabout fashion 
including auxiliary loop count variable statement invariant fx gamma invariant provides upper lower bounds number times loop statement executed function 
note particular invariant permit proving max 
input restricted bmax loop executed max gamma times 
assuming sec 
time related statements execution times bounded max theta max gamma theta theta max gamma theta max time related statements higher level constructs dealing time systems provide clock abstraction form software functions read time possibly set time 
define functions follows get time returns current value ct computer time set time sets computer time ct basic timing facility useful programming real time applications delays process specific interval time time reaches absolute value 
defined int delay wait ct ct proceeding ct time delay statement invocation abs delay wait ct proceeding proceed immediately ct practical reasons delay statements usually defined loosely guarantee continued execution time ct ct ct respectively 
give tighter practical specification permits better timing predictability section 
third class timing facility commonly available concurrent systems timeout 
associated communications synchronization constructs permit specification timing limit waiting event occur 
timeouts treated section 
constructs permit implementation elaborate higherlevel statements abstractions 
example calendar package ada allows programmer perform arithmetic variables type time straightforward manner construct elements type time decompose time various components 
pearl language provides mechanisms directly scheduling processes time 
example tasks activated resumed time frequency particular time specified time interval 
third example realization different clocks system differing granularities tick time variable interval 
sec 
time related statements timing analysis get time delay execution times standard statements sequential programs straightforward analysis determine program satisfies performance constraints implicit timing constraints 
principal purpose timing related statements program constraints directly explicitly 
order obtain sort sensible predictability possible produce tight bounds statements 
languages called realtime languages ada provide timing bounds 
important reasonable question sequence int delay int delay produce result single statement int delay exactly result 
particular problem handled precisely interesting quite different esterel language 
consider possible realizations get time initial architectural assumptions section 
computer time maintained separate processor value ct returned message passing communication directly accessible shared memory 
may computation put ct suitable form 
function implemented different ways example procedure line macro 
factors included yield time bounds get time assume combination measurement analysis 
get time value ct returned related real time rt follows ct rt ct ct rt rt gamma defined section ct rt realistic cases ct value obtained start event get time event 
event get time able bound ct relation ct rt gammat max get time max get time upper bound get time 
alternatively ct expressed function real time start event get time ct rt max get time definitions analysis int delay version delay statement 
reasonable implementation separate processor assumption get time function busy wait loop int delay sec 
time related statements wakeup time get time statement get time wakeup time alternatively hardware interval timer hit employed directly 
assumed timer decrements value hardware tick interrupts applications processor reaches zero 
hit hit fs hit interrupt determine execution time bounds leads precise definition int delay examine overhead case 
ideal unrealizable semantics time bounds course int delay delay implemented type computer clock better int delay max gamma simpler relation obtained int delay convenience assume results general case evident 
consider effects various overheads implementations 
show case derive useful execution time bounds overhead oh independent parameter final result int delay oh code lower bound oh sum lower bounds wakeup time simple variable constant 
corresponds case ct changed ct wakeup time just prior retrieval ct get time 
analogously ct changed ct wakeup time just ct retrieved get time call test trace worst case scenario obtain upper bound oh equal twice sum upper bounds get time wakeup time plus upper bound 
competitor upper bound may case small get time fail test execution terminated upper bound oh sum upper bounds get time wakeup time 
final upper bound oh larger possibilities 
code admits simpler analysis 
entire loop realistically coded single instruction branch self 
sec 
time related statements loop optimized eliminate unconditional transfer loop 
overhead bounds oh min inter max inter max tmax max min inter max inter execution bounds handling timer interrupt 
handling may simple transfer instruction 
branch self assumed realizing loop 
upper bound considers cases similar treated 
results section compare sequence int delay int delay int delay 
sequence delays execution times meaning oh oh oh int delay oh identical timing semantics 
esterel produces identical results model assume overhead instantaneous computations distinction computer time real time 
program proof including time programming periodic process apparently simple delay loop illustrated 
executed approximately period units time 
get time loop fthe execution starts period gamma get time int delay loop variation code example appears ada manual 
code inserted directly comment start message sent separate process implementing schema build higher level software clock ticks period example compute time day 
informally wish show code compute correct time cycle provided greater zero variable contains start time current cycle 
indicated earlier example section requirement formalized loop invariant true just loop refers auxiliary counting variable section rt start theta period rt eps sec 
time related statements rt start approximately program start time eps eps min eps max min max eps constant eps 
problem bound rt start respect real time program say rt rt time start event statement 
second difficult interesting problem find eps 
program supposedly written timing errors don accumulate time loop reason int delay gamma get time simply int delay period 
proving invariant confirms intent realized correctly 
consider statement program including initialization fictitious loop count variable 
logic add provable assertions auxiliary counting time assumed equal rt get time rt max get time section rt rt get time postcondition rt max get time rt start theta period rt start rt similarly rt rt get time obtain rt rt start gamma get time gamma get time eps 
eps derived get time similar derivation described section 
postcondition statement implies rt start theta period rt eps invariant bounded rt start respect rt bound eps produced proving invariant loop part program assuming appropriately greater zero see discussion 
alternate equivalent notation rt eps rt eps show canceled time loop time residual error picked canceled time 
minimum maximum residual error due statement times timing errors initial eps bounds desired bounds 
loop fig period statement rt start theta period rt gamma period gamma get time fs rt start theta period rt gamma period sec 
time related statements gamma get fx rt start theta period gamma gamma period period gamma gamma gamma auxiliary counting variable fx period gamma gamma gamma rt start rt gamma period int delay fs rt start theta period period gamma gamma gamma rt gamma period oh fit assumed frt gamma period period gamma gamma gamma gamma hg loop frt gamma loop rt start theta details assertion derived primarily results get time analysis section 
assumed start event corresponds real time rt start event get time computer time returned get time equal rt 
alternative realization result addition bounded error term 
rest expression obtained substituting rt 
real time updated results previous analysis int gamma delay substituting assuming time loop arrive assertion just loop 
final assertion adds effects transferring back loop 
time loop new error term del gammae time initialization gives error del gammaffi fl ffi fl get time 
expression real time form rt gamma 
little analysis yields rt eps eps gamma gamma eps gamma define gamma gamma gamma pairs eps manner eps eps eps del eps eps eps del final eps eps min eps eps max eps eps sec 
synchronization communications analysis change substantially execution time process communication time included 
time say receive value equal period gamma gamma gamma gamma 
provided invariant continue hold 
system may correctly timing errors accumulate bound 
course happens overhead large period period del del shown intent common code fragment controlling periodic process real time formalized verified 
example illustrates desirability machine assistance keep track assertions verify details proof checker compute time bounds 
synchronization communications objective predict execution times synchronization communications software concurrent systems 
statements mechanisms need analyzed include semaphores locks monitors events message passing input output remote procedure call rendezvous 
process waiting time interval process logically blocked explicitly statements int delay treated section 
statements considered explicit waiting times making difficult obtain useful time bounds 
method study specific context statements account usual overhead times details processes interact question 
example consider standard producer consumer system consisting processes communicate bounded buffer semaphores synchronization producer process loop record empty ill buffer full loop consumer process loop full empty buffer empty consume record loop initially semaphore empty number buffers full 
find empty emin emax 
assuming successful operation pre determined bounds success tp min tp max emin tp min emax derived noting worst case producer wait empty entire cycle consumer starting consume record sec 
synchronization communications empty occurs wake 
yields upper bound emax equal upper bound expression fail consume record tp max empty buffer wakeup fail predetermined bounds operation fails time blocking process tp max corresponds successful full time operation wakes blocked process 
similar analysis full 
course cases interest approach practical 
timeouts second method guaranteed principle yield bounds employs timeouts 
associated invocation synchronization communication operation time say process unblocked timeout occurs operation completed appropriate indication process continues 
alternatively timeout parameter interval absolute time 
timeouts indicators various kinds system failures hardware error software mistake deadlock 
convenient programming timing constraints illustrated 
commercial example toolkit provides timeouts waiting input output devices semaphores events message ports 
timeouts operations may implemented basic clock mechanisms int delay 
hardware interval timer absolute timer directly employed get time function invoked busy wait loop 
case implementation details complex timeout coordinated primary object resource requested message semaphore event 
examples define semaphore operation timeout follows wait time whichever happens 
gamma return true 
return false 
fthe operation assumed atomic function parameter time start event particular call statement 
lower bound component certainly tp min 
possible exception mentioned 
upper bound represents worst case time timeout occurs 
cases possible immediate timeout small timeout 
case computer time compared execution bounds times entering making tests returning 
lower bound smaller tp min lower bound 
sec 
synchronization communications failure second case occurs computer time ct rt ffi ffi ct accounts missed ticks ct due overhead 
timeout occurs real time ct gamma ffi gamma ffi adding term time clean return timeout obtain final event time rt gamma ffi upper bound maximum rt time start event 
maximum rt max max sum purpose working details example note bounds derivable element timing expressions communications timeouts time stamps consider synchronous communications mechanism handling simple form events 
event posted sent send primitive obtained received receive operation 
sender receiver blocked respective primitives rendezvous timeout occurs 
events time stamped loose sense rendezvous time returned completion operations 
receive function defined manner ev receive event name event name input identifying type event absolute time timeout returned value ev pair ev name ev time 
timeout occurs ev name timeout ev time nominally equal ev name event name ev time gives time stamp value ts say ts ts computer time computed start events receive 
specify sender process port channel part input receive necessary timing analysis purposes 
aside section definition permitted true return timeout time variety assume ts event 
section analyze receive non trivial example uses timeouts time stamps 
send operation examined defined detail need peripheral way 
consider timeout case receive ev time ts ts rendezvous time obtained invoking say get time receive 
real time corresponding ts ts ffi ffi bounds software overheads receive 
event ev receive event name real time rt ts ffi timeout event occurs computer time ct possibilities arise similar treated analysis section 
timeout value small initially example computer time start event receive real time event receive rt start rt start real time start event receive 
timeout occurs computer time ct accounts missed ticks ct due overhead 
real time timeout ffi ffi sec 
synchronization communications real time event receive expressed ffi included overheads 
examples analyzed programs recognize single double clicks button mouse input device 
user clicks button depressing button letting go button 
time events interval sc single click event defined 
double click event single clicks separated interval dc specifically gamma dc time second click event time click event 
recognizer single clicks program single click loop receive inf large number time tsc receive name send sc receive inf loop aim show send sc name name rt gamma rt tsc err rt real time event rt real time event err small error term bounded 
similarly wish assertions hold timeout name name timeout rt gamma rt tsc err rt rt real time timeout event receive err error term 
note formulation shows existence ambiguous window tsc single clicks may detected missed depending relative values particular instances err err timing logic results analysis receive annotate program provable assertions loop receive inf fs name rt time rt time time tsc fs ft time tsc rt time rt time receive fs fup name rt time rt time time name timeout rt rt time thetat rt name send sc receive inf loop sec 
synchronization communications rt time rt time ffi ffi similarly case name rt time ffi ffi assertions give time gamma tsc time gamma deltat deltat combining get rt gamma rt time ffi gamma time gamma ffi tsc gamma deltat ffi gamma ffi ffi ffi difference bounded rt gamma rt tsc err err name timeout situation slightly complex possibility interval tsc smaller execution time overhead clicks 
provided tsc large implication timeout assertion holds rt ffi ffi expressions rt get rt gamma rt ffi gamma gamma tsc ffi tsc ffi gamma ffi ffi ffi tsc err err tsc small program timeout indicating system fast recognize single click 
safe tsc certainly larger maximum 
recognizer double click employs similar ideas double click receive inf time tsc loop receive name single time tdc receive name nd single click time tsc receive name send dc sec 
interrupt handling processor sharing receive inf receive inf receive inf time tsc loop program logic sufficiently complex warrant arguments favor correctness 
assuming computer time real time identical overhead time zero assertions hold double click send dc irst single click name name time gamma time tsc second single click name name time gamma time tsc double click ff irst single click second single click time gamma time similarly assertions correctness proven timeout points single click event 
add overhead timing error terms obtain real time properties approach single 
interrupt handling processor sharing assumption dedicated processors section applies contemporary systems expected hold applications timing predictability simplicity important potential cost savings resource sharing 
continue systems deal processor sharing problems 
typically processor may shared user process clock process user process input output processes user processes combinations 
operating system required order regulate multiplexing processes 
timer input output driver processes usually driven closely connected hardware interrupts code handling interrupt implements software part processes 
section show timing behavior sharing predicted 
worth noting techniques computing timing logic previous sections change parts system interruptible interrupts masked 
example methods employed analyze kernel higher level components operating system global critical sections 
similarly techniques apply segments applications processes run interrupt mode shared data possibilities need predictable performance 
sec 
interrupt handling processor sharing interrupts permitted interrupt handling times frequencies bounded effects processor sharing user process interrupt handlers included timing analysis 
interrupt handler clock interrupt tick just update variable representing time driver handler input output device update state variables transfer data buffer initiate operation 
suppose interrupt handler ih characterized parameters fmin fmax bounds frequency interrupts number times second ih execution time code interpretation interval interrupts smaller fmax seconds longer fmin seconds 
execution time bounds statement running dedicated processor time bounds including processor sharing interrupt handler 
upper bound max max max theta fmax theta max ih giving max max gamma fmax theta max ih similar result obtained min 
proof rule section changed straightforward way reflect new execution times fpg rt rt rt rt fqg note results adjusted upward max max theta max ih integer eliminate fractional handling interrupt similar downward adjustment min 
level granularity results applied depends clearly wishes avoid buildup rounding rounding errors final bounds meaningless 
assuming interrupt handlers non interruptible effects handler incorporated ideas 
interrupt handling results employed analysis elaborate instances processor sharing 
example class slice software architectures common hard real time systems 
processes broken non preemptible units called slices scheduled cycle executive driven timer consults scheduling table clock tick 
slice analyzed execution times priori frequency bounds information clock input output interrupt handlers 
slices interrupted preempted slice continues handler completes 
cyclic executive non preemptible process timing behavior obtained 
extreme practical example system cycle periodic process non preemptible constitutes slice 
sec 
discussion timing predictability impractical process preempted arbitrary points code 
processes sharing processor functions int delay execution times appear unpredictable general example processes waiting int delay scheduled wake time evident associate practical time bounds process delay 
study needed define particular useful cases analyzed 
discussion methodology specifying predicting proving assertions time new promising incomplete untested practice 
major outstanding issue useful best worst case execution time bounds statements contemporary higher level languages underlying systems 
obvious step perform experiments programs suitable implemented language system 
aim determine combination measurements analysis language compiler runtime system target architecture yield deterministic bounds confirm definitions basic timing elements 
order compute bounds structured statements general compute times statements particular programs desirable build automatic tools help analysis example tools realizations algorithms various statement schemas section 
software doing interval arithmetic available part tools 
structured timing schemas components higher level languages schemas proposed chapter correspond philosophy straightforward code generation modern compilers 
seek improve correctness understanding maintainability simple parsing predictable code generation 
difficult problem determination tight timing information instructions code sequences contemporary computers pipelining caching host performance enhancing features hinder timing predictability 
selecting appropriate granularities higher level language elements hope hardware issues exactly incorporate worst case effects memory bus contention handled practically 
may result clearer understanding definition machine architectures hardware features permit timing predictability manner similar reported microprocessor architectures evaluated suitability compiler code generation 
need analyze types statements including standard input output instructions forms synchronization communications operations guarded commands conditional iterative statements 
finding proving right kinds assertions somewhat difficult experiences reasoning time simplify problem 
tim acknowledgments ing assertions associated proofs relatively simple leading optimism viability approach 
main results contributions techniques principle permit prediction timing logical behavior programs 
believe novel idea methods computing time bounds ability deal directly real time computer times extension application hoare logic reasoning time illustration specific assertions involving time common problems 
acknowledgments chapter revised version published ieee trans 
software eng vol 
pp 
july 
principal part research accomplished laboratoire university paris academic year 
done month visit spring institut fur informatik eth zurich summer university washington 
research supported part institutions fulbright research franco american commission washington technology center 
am grateful philippe serge claude girault john zahorjan helpful discussions 
special go kevin jeffay critical detailed reading suggestions followed revision 
military standard ada programming language ansi mil std dept defense washington jan 
real time operating system nuclear power plant computer proc 
real time systems symp ieee computer society new york dec pp 

baker architecture real time software systems ieee software may pp 

berry esterel synchronous programming language mathematical semantics lecture notes computer science seminar concurrency brooks roscoe winskel eds springer verlag new york pp 

bic shaw logical design operating systems nd edn prentice hall englewood cliffs 
cardelli pike squeak language communicating mice proc 
siggraph acm siggraph vol 
july pp 

cheriton malcolm sager portable real time operating system commun 
acm vol 
feb pp 

clapp volz mudge real time performance benchmarks ada commun 
acm vol 
aug pp 

dasarathy timing constraints real time systems constructs expressing methods validating ieee trans 
software eng vol 
se jan pp 

haase real time behavior programs ieee trans 
software eng vol 
se sept pp 

haase modular design real time systems system description methodologies david eds elsevier amsterdam pp 

hoare axiomatic basis computer programming commun 
acm vol 
oct pp 

jahanian 
mok safety analysis timing properties real time systems ieee trans 
software eng vol 
se sept pp 

real time euclid language reliable real time systems ieee trans 
software eng vol 
se sept pp 

knuth art computer programming vol 
fundamental algorithms nd ed addison wesley reading mass 
miranker eds new approach scientific computation academic press new york 
lamport time clocks ordering events distributed system commun 
acm vol 
july pp 


mok fundamental design problems distributed systems hard real time environment ph dissertation may 
moore interval analysis prentice hall englewood cliffs 
pnueli presentation real time systems issues workshop univ texas austin dec 
shaw software clocks concurrent programming slice scheduling proc 
real time systems symp ieee computer society new york dec pp 

shaw reasoning time higher level language software research report laboratoire university paris apr 
technical summary digital equipment 
volz mudge instruction level mechanisms accurate realtime task scheduling proc 
real time systems symp ieee computer society new york dec pp 

pearl nd ed vieweg sohn germany 
wirth fast compact compiler modula tr institut fur informatik eth zurich july 
wirth microprocessor architectures comparison code generation compiler commun 
acm vol 
pp 
oct 
sec 
predicting program execution times predicting program execution times original published done developing testing similar ideas 
research concentrated refining extending schema approach predicting execution times validity predictions experiments 
research summarized part 
related execution time prediction include 
validation experiments software tools constructed variety experiments carried order determine practicality idea source program level schema basis deterministic timing prediction 
experiments done programs language gnu compiler running motorola sun 
tools accept program produce time bound best worst case execution times program 
validation accomplished comparing predictions measurements 
hardware interferences clock interrupts dynamic ram memory refresh explicitly taken account 
sets tools experiments static analysis program paths implied timing formulas obtained source language statement schema 
user input form best worst case iteration counts required loop 
granularities tried basic atomic unit block schema decomposition small atomic block corresponding terminal symbols source language variables constants operators proposed original large atomic block corresponding approximately expressions control constructs 
suite relatively small programs largest lines code analyzed measured results 
timing estimates safe actual best worst case run times bounds reasonably tight close realizable run times 
expected better results obtained larger atomic block 
bounds loose apparent cause interrelationship different program parts nested loops handled purely static analysis technique 
method specifying dynamic execution paths program statement schema prediction developed park restricted set execution paths eliminated infeasible paths contributed incorrectly best worst case predictions 
dynamic paths described user language underlying basis extension regular expressions including negation intersection 
correctness user specifications established assertional program proving techniques 
software tools built test method programs 
approach worked extremely producing safe tight bounds programs tested 
sec 
predicting program execution times parallel program prediction timing schema notion applied variety common parallel program constructs involving fork joins spawning synchronizing termination processes shared variable interactions critical sections general semaphores distributed message passing remote procedure calls 
hypothetical implementations demonstrate potential reasonableness applicability schema 
initial experiments shared memory multiprocessor processor sequent 
simplest process structures process interactions occur synchronize initiation termination processes 
predictions produced schema approach compared measured execution times 
predictions safe reasonably tight despite complexities underlying computer system 
demonstrated schema approach works relatively small sequential programs 
obvious need determine methodology scales larger software 
additional required deterministic timing prediction parallel systems input output commands underlying hardware complexities variations search generality particularly difficult 
applied extended prediction ideas schema area executable languages requirement design specifications 
kim shaw experiment predicting measuring deterministic execution times parallel programs multiprocessor tech 
report dept computer science engineering univ washington sept 
lin flex language real time systems programming foundations real time computing formal specifications methods van eds kluwer academic publishers dordrecht netherlands pp 

mok evaluating tight execution time bounds programs annotations proc 
th ieee workshop real time operating systems software may pp 

pugh partial evaluator hard real time system proc 
th ieee real time systems symp dec pp 

park shaw experiments program timing tool source level timing schema proc 
th ieee real time systems sec 
predicting program execution times symp dec pp 

revised version ieee computer vol 
may pp 

park predicting program execution times analyzing static dynamic program paths tech 
report dept computer science engineering univ washington dec 
published journal real time systems 
park predicting deterministic execution times real time programs ph dissertation tech 
report dept computer science engineering univ washington aug 
ch 
koza calculating time realtime programs journal real time systems vol 
sept pp 

shaw prototyping environment specifying executing checking real time state machines tech 
report dept computer science engineering univ washington oct 
publication software practice experience 
shaw deterministic timing schema parallel programs proc 
th international parallel processing symp apr pp 

shaw timing semantics programming languages foundations real time computing formal specifications methods van eds kluwer academic publishers pp 

shaw communicating real time state machines ieee trans 
software engineering vol 
sept pp 

real time language schedulability analyzer ph dissertation tech 
report csri computer systems research institute univ toronto dec 
