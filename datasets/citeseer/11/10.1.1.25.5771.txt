cost fault tolerant consensus faults tutorial keidar sergio rajsbaum may consider consensus problem asynchronous models enriched unreliable failure detectors partial synchrony processes crash links may fail losing messages 
study number communication steps performed deterministic consensus algorithms models failure free executions 
show tight lower bound communication steps 
process showing bound give simple uni ed proof number di erent impossibility lower bound results 
shed light relationship di erent lower bounds time illustrate general technique obtaining simple elegant lower bound impossibility proofs 
illustrate matching upper bound describing previously published algorithms achieve lower bound 
consensus fundamental problem distributed computing theory practice alike 
consensus service allows collection processes agree common value 
speci cally process input correct process decide output correct processes decide output furthermore output input processes 
consensus important building block fault tolerant distributed systems lam achieve fault tolerance data replicated consensus guarantee replica consistency state machine approach lam sch 
consensus solvable pure asynchronous models process crash flp real systems completely asynchronous 
partially synchronous models dls cf better model real systems 
consider particularly realistic kind model dls allows system asynchronous unbounded nite period time long eventually synchronous majority processes crash 
consensus solvable model 
similarly consensus solvable asynchronous model enriched certain oracle failure detectors ct including unreliable failure detectors provide arbitrary output arbitrary period time eventually provide useful semantics 
preliminary version appeared sigact news distributed computing column pages june 
mit lab computer science 
technology square ne cambridge ma mail theory lcs mit edu 
compaq cambridge research laboratory cambridge center cambridge ma mail sergio rajsbaum compaq com rajsbaum math unam mx 
leave instituto de matem unam 
consensus solved asynchronous model randomized algorithms shared memory models 
consider message passing deterministic algorithms 
study consensus algorithms partial synchrony model asynchronous models unreliable failure detectors 
call models non synchronous 
say running time consensus algorithms non synchronous models 
unfortunately absence failures consensus algorithms models bound unbounded running times 
flp asynchronous system consensus algorithm nite run failures occur non synchronous systems asynchronous unbounded period time 
practice extensive periods communication timely 
executions synchronous 
executions failure detectors time outs accurate 
study running time consensus algorithms non synchronous models benign circumstances 
focus executions network synchronous failure detector accurate 
call executions behaved failure free behaved executions common practice algorithm performance circumstances signi cant 
note algorithm know priori execution going behaved rely 
algorithms non synchronous models decide communication steps behaved executions sch hr kd 
distributed systems folklore suggests fault tolerant algorithm non synchronous models take communication steps processes decide behaved executions 
formalize folklore theorem 
speci cally show consensus algorithm models processes crash behaved execution takes communication steps processes decide 
start illustrating upper bound 
simple intuitive algorithm due raynal solves consensus asynchronous crash failure model unreliable failure detector 
failure detector implemented partial synchrony model way preserves behaved nature executions 
upper bound applies partial synchrony model 
deriving lower bound non synchronous models rst recall known running time consensus algorithms synchronous crash failure model model consensus algorithms failure free executions decide communication step 
generally early stopping algorithms processes decide communication steps execution involving crash failures lf 
optimal shown consensus algorithm synchronous crash failure model executions failures take communication steps processes decide lf dm lyn 
re prove lower bound section 
consensus algorithms non synchronous models require communication steps synchronous executions 
show need additional communication step needed synchronous model stems fact non synchronous models correct process mistaken faulty 
requires consensus algorithms models avoid disagreement processes faulty 
contrast consensus synchronous model requires correct processes agree value allows disagreement faulty ones 
uniform consensus problem strengthens consensus require processes correct faulty decide decide value 
interestingly uniform consensus requires communication steps absence failures synchronous model long processes crash prove section 
notion behaved behaved executions similar notion stable periods model cf self stabilizing systems 
communication step lower bound consensus non synchronous models stems fact algorithm solves consensus models solves uniform consensus gue prove section 
order prove general lower bound results study weaker version consensus called weak consensus 
recall consensus requires decision output value input processes validity property consensus 
de ne weak consensus replace validity weak validity property exist failure free executions processes decide di erent values 
flp observed weaker version validity sucient prove consensus impossibility asynchronous model flp requires exist executions necessarily failure free ones processes decide di erent values 
interestingly property weak imply step lower bound synchronous uniform consensus failure free executions show section 
addition crash failures consider message omission failures links fail losing messages including messages sent correct processes 
consensus solvable message omission model synchronous system restrictions placed possible message loss patterns 
particular consensus solvable model single mobile failure environment adversary choose single process communication step algorithm lose messages sent step process sw 
re prove impossibility result section technique showing lower bounds synchronous crash failure model 
impossibility result relies adversary ability choose process lose messages step 
section discuss certain restrictions placed adversary ability choose message loss patterns consensus solvable complicated algorithms tolerate crash failures lam 
non synchronous models synchronous message omission model number messages correct process may lost algorithm consensus solves uniform consensus 
processes fail communication step bound holds 
omission model say process fails point messages lost 
step bound synchronous omission model previously observed lamport lam 
primary goal provide intuition lower upper bounds 
especially strive lower bound proofs simple easy follow possible extract simplest arguments known techniques simple techniques derive new proofs uniform consensus lower bound 
give uni ed proof di erent results illustrating general technique obtaining simple elegant lower bound impossibility proofs 
rest organized follows section de ne models problems formal notion behaved executions non synchronous models state prove bounds 
section illustrate upper bound describing known algorithms decide communication steps behaved executions 
section prove lower bounds consensus uniform consensus synchronous crash failure model impossibility result consensus message omission model single mobile failure 
section derive lower bounds consensus non synchronous models 
section discusses optimistic alternatives consensus way circumvent lower bound 
section concludes 
de nitions models universe consists processes processes communicate message passing 
consider deterministic algorithms 
execution algorithm alternating sequence global states actions 
global states re ect local states processes communication channels messages transit 
actions steps taken distinct processes environment 
action process send messages number processes change local state environment decides subset messages transit deliver destinations 
deterministic algorithm single execution algorithm assignment initial values processes sequence environment actions 
consider distributed computing models 
de ned terms type failures occur timing assumptions 
proceed describe aspects model 
failure types consider types failures crash failures message omission 
consider byzantine failures 
crash failures crash failure model processes fail stopping execute actions point execution 
parameter bounds number processes crash 
process crashes execution faulty execution process crash correct 
process fails state execution failed model crash failures communication reliable process sends message correct process step fail step message eventually reaches process fail step subset messages sends step lost 
omission failures message omission model subset messages sent correct processes lost communication step 
process faulty model point execution messages process lost 
fact process faulty de ned examining nite execution state execution process failed 
mobile failure model sw restriction message omission model step messages process lost 
show consensus unsolvable restricted omission model 
timing assumptions focus models partial synchrony asynchronous models unreliable failure detectors 
order derive lower bounds models consider restricted synchronous model 
describe timing models 
synchronous synchronous model processes execute synchronous steps step processes send messages number processes 
failure occurs message reaches destination step 
partially synchronous partially synchronous models literature 
consider models de ned dls priori bound message latency 
time called global stabilization time gst bound message latency bound known processes 
simplicity assume local computation time zero processes measure time accurately addition assume exist pre de ned constant known processes re ects typical message latency system 
behaved execution partial synchrony model execution failures message reaches destination time 
behaved execution essentially synchronous 
asynchronous failure detectors asynchronous model unreliable failure detectors ct bound message latency process equipped failure detector oracle 
step algorithm execution query failure detector information 
focus failure detectors provide arbitrary outputs unbounded period time eventually provide meaningful semantics 
chandra toueg ct de ne classes failure detectors output list suspected processes 
say process suspects process certain point execution included failure detector output list point 
illustrate upper bound focus failure detector class shown weakest failure detector solving consensus cht 
failure detector class guarantees properties 
strong completeness time correct process permanently suspects crashed process 
eventually weak accuracy correct process time suspected correct process 
behaved execution model execution failures suspicions processes empty suspicion lists 
example failure detector class leader election service cht 
output failure detector class identi er process presumed leader 
initially failure detector class unreliable name faulty process leader name di erent leaders di erent processes 
eventually elect single correct leader give processes output correct process 
cht shown equivalent 
behaved execution failure detector announces correct leader processes execution 
communication steps called rounds 
consensus solved assumptions weakened timed asynchronous model cf clock skew possible bounded di erent processing times possible ratio bounded 
problem de nitions de ne variants consensus problem 
problems process participating algorithm gets input value algorithm output decision value dec simplicity consider binary consensus input values 
algorithm solves consensus satis es properties agreement correct process decides dec correct process decides dec dec dec correct processes decide di erent values 
validity correct process decides dec process dec decision value input value process 
termination correct process eventually decides value agreement property requires correct processes agree value require agreement faulty processes 
uniform consensus strengthens consensus requiring agreement faulty processes case decide fail 
algorithm solves uniform consensus satis es validity termination de ned property uniform agreement process decides dec process decides dec dec dec processes decide di erent values 
sake lower bound look weaker version consensus called weak consensus 
algorithm solves weak consensus weak uniform consensus satis es agreement uniform agreement termination property weak validity value failure free execution process decides weak validity may useful property consensus algorithm satisfy useful proving lower bounds results general applicable problems 
example instance weak uniform consensus non blocking atomic commit ske bhg 
atomic commit gra distributed database systems multiple database sites agree commit transaction abort 
decision represents commit decision abort 
likewise input value represents vote favor committing transaction input value represents vote aborting 
commit decision reached processes vote favor committing transaction 
non blocking atomic commit problem ske bhg special case weak uniform consensus 
algorithm solves non blocking atomic commit satis es uniform agreement termination properties commit validity decision value processes voted 
non triviality failures processes vote decision 
interested processes decide 
circumstances time needed halt larger 
upper bound exist various consensus algorithms non synchronous models processes decide communication steps behaved executions sch hr kd 
illustrate section simple elegant consensus algorithm due raynal 
algorithm works crash failure model behaved executions processes decide communication steps 
omission failures harder overcome show section consensus solvable synchronous model single mobile omission failure 
consensus solved certain restrictions placed message loss patterns 
discuss section 
failure detector class implemented partial synchrony model timeouts increasing time value time false suspicion occurs see ct 
implementation time value initially chosen maximum latency wellbehaved executions partial synchrony model behaved execution partial synchrony model failure detector generates suspicions 
behaved execution partial synchrony model simulate behaved execution failure detector model 
upper bound applies partial synchrony model 
consensus crash failures algorithms decide communication steps suggested sch hr 
algorithms tolerate crash failures long majority processes correct 
rotating coordinator approach cm dls 
approach algorithm iterates sequence rounds round di erent coordinator leads consensus algorithm order try reach decision 
round coordinator process mod 
iteration multiple rounds needed order account possible coordinator failures 
round coordinator correct suspected process processes decide 
illustration algorithm 
algorithm process keeps track round number variable initially zero estimated consensus value variable est initially process input value 
round algorithm conducted follows coordinator sends estimate processes 
process waits receives estimate coordinator suspects current coordinator 
processes send messages process received estimate coordinator sends estimate sends null value 
process waits receive messages majority processes acts follows 
process receives null values proceeds directly round 

process receives non null value coordinator estimate majority broadcasts decide message value decides value 
process returns value 

process receives null non null values sets estimate est received non null value proceeds round 
addition process receives decide message forwards decide message processes account case coordinator sent failed sending decides value decide message 
function consensus cobegin task est true mod est round case est est wait est received pc suspected est received est endif endcase est send est est enddo wait est est received processes rec est est received line est rec fvg fv case rec skip rec fvg send decide enddo return rec fv est endcase enddo task reception decide send decide enddo return coend consensus algorithm 
informally argue algorithm correct 
rigorous proof see 
validity ensured rst coordinator suggests initial value coordinator suggests value value previously sent coordinator 
induction processes initial values possible decision values 
see agreement ensured notice process decides round majority processes sent round process waits hear majority proceeding round process receives message round process proceeds round sets estimate 
clearly round onward possible decision value 
decision round coordinator fail suspected process 
properties failure detector fact algorithm continuously iterates possible coordinators process decides ensure eventually round 
addition process decides process decides broadcasts decide message processes 
guarantees correct process stops participating iterations decided correct processes get decide message decide 
consider behaved execution 
rst coordinator fail suspected process correct process receives coordinator estimate sends processes process sends null value 
processes decide receiving messages majority rst round communication steps 
consensus messages omissions omission failures harder overcome 
see section consensus solvable message omission model 
discuss possible overcome certain restricted message omission patterns 
consider example case communication links correct processes fair act sense message sent link nite number times eventually reaches destination 
case reliable transport protocol similar tcp implemented atop fair lossy links repeatedly retransmitting message known message reached processes act 
simulate crash failure model fair lossy links algorithm solving consensus crash failures previous section works model long majority correct processes 
consider case communication correct processes eventually reliable network partitions substantial amount time 
case continuously sending messages nitely times described practical practical transport protocols tcp give terminate session long lasting partitions 
practical algorithms model need able reach decision communication re established retransmitting entire message history 
rst best known algorithm paxos lam similar algorithms appear kd kd 
algorithms quite subtle describe detail 
lamport paxos algorithm lam dpll solves consensus asynchronous message omission model restriction message loss patterns time process messages correct processes lost majority correct processes communicate reliably paxos uses leader election service essence failure detector class pc algorithm kd solves atomic commit similar assumptions 
consensus algorithm uses failure detector 
corel algorithm kd uses group communication service equivalent eventually perfect failure detector stronger examine running time paxos behaved executions executions failures leader election service elects single leader processes execution 
executions paxos lam requires communication steps processes decide 
rst steps needed recovery past failures involve sending actual consensus input values 
sequence paxos consensus algorithms ran steps occur leader changes 
instance consensus invoked steps communication steps executed 
steps manner similar round consensus algorithm 
rst steps leader sends initial value processes 
second processes receive value record send acknowledgments leader 
majority processes recorded value value locked decision value possible 
receiving acknowledgments majority leader decides 
third step leader sends decision value processes decide 
simple variation paxos merge steps having processes send acknowledgments 
case process receives acknowledgments majority decide directly 
approach taken kd 
requires strengthening restriction message loss patterns require majority processes communicate reliably just leader 
synchronous lower bounds section consider synchronous system processes fail denote actual number failures execution 
give uni ed proof di erent results show consensus impossibility mobile failure model model 
consider crash failure model 
show lower bounds communication steps consensus uniform consensus respectively 
results known section discuss related 
prove results jointly section technique notation de nitions 
particular de ne notions similarity pair states similarity connectivity set states 
section show uniform consensus algorithm reach decision communication step states similarity connected set 
showing set initial states consensus uniform consensus similarity connected obtain lower bound uniform consensus failure free case 
section prove states longer executions connected results follow impossibility result consensus mobile failure model general bounds consensus uniform consensus crash failure model 
sake proving lower bounds impossibility result suces assume weak validity property prove bounds weak consensus weak uniform consensus 
result weak uniform consensus applies non blocking atomic commit discussed section 
section show result uniform consensus hold weaker validity property de ned flp 
related impossibility consensus mobile failure model rst shown santoro widmayer sw 
moses rajsbaum layering technique described 
previously shown steps necessary sucient consensus lf lyn 
charron bost schiper cbs show tight bound steps uniform consensus steps lower bound proof cover case 
dwork skeen ds give related result non blocking atomic commit problem instance weak uniform consensus 
consider failure free case 
complexity analysis uses di erent measure model sending messages single communication step costing time 
clearly time bounds obtained way higher 
bound communication steps failure free executions implicitly appears 
lamport lam shows communication steps bound uniform consensus message omission model processes crash assuming adversary restricted consensus solvable 
dolev drs show consensus algorithm tolerate crash failures executions failures involving sequence min communication steps processes halt 
contrast analyze time processes decide may earlier time processes halt 
traditional proofs lower bound consensus lf dm lyn lower bound uniform consensus cbs involved backward induction argument 
simpler proofs lower bound consensus forward induction moses rajsbaum aguilera toueg 
bar joseph ben similar technique show lower bound randomized synchronous consensus 
moses rajsbaum technique show lower bounds impossibility results di erent asynchronous message passing shared memory models 
similar forward arguments apply higher dimensional notions connectivity problems consensus appear hrt hrt 
proofs sw notion state algorithm bivalent lead di erent decision values di erent executions 
proofs show forward induction construct executions algorithm remains bivalent state sequence steps precluding decision 
notion strong prove lower bound uniform consensus 
show section merely having initial bivalent state preclude decision communication step failure free executions 
basing proof existence bivalent state base proof existence states lead di erent decision values failure free executions 
new notion give rst time proof forward induction uniform consensus lower bound rst proof covering case 
show forward induction argument layering approach moses rajsbaum prove lower bounds consensus uniform consensus impossibility consensus mobile failure model 
technique layering connectivity coloring proving lower bound impossibility results thought showing algorithm adversary strategy guarantee desired bad behavior 
case synchronous model adversary choose processes fail step subsets messages delivered 
say decision action environment 
assume deterministic consensus algorithm 
initial state system environment actions completely de ne execution environment de nes messages process receives step algorithm process de nes new local state messages sends 
describe execution specifying initial state sequence environment actions 
execution consisting states denote 
nal state execution results extending having environment perform action 
execution state represented form 


initial state algorithm environment action integer 
layering obtain impossibility result sucient consider subset possible executions model 
consider set executions generated set initial states layering layering set environment actions performed state system 
layering chosen appropriately executions structural properties simplify analysis sake proving results process fails step 
denote set fp denoting empty set 
layering consists nondeterministically choosing process fp set performing action meaning messages sent members lost messages lost 
action models step asynchronous models signi cant various layering structures de ned show consensus impossible executions little asynchrony 
failure occurs 
precisely layering mobile failure model lm ng crash failure model action causes process permanently crash 
assume processes crash care taken crash processes execution 
action layer applicable state fewer processes failed process failed denote layering consisting actions types notice number processes fail execution system processes failed state subsequent layers 
layering denote fx 
lg 
generalize de nition set states follows 
de ne application times 
formally de ned recursively follows layering consider mobile failure model property state failed processes 
words state system contains execution extending process fails 
connectivity coloring lower bound impossibility proofs distributed algorithms typically notion similarity captures case di erent executions look processes 
de ne similarity follows de nition states similar denoted process states states identical local state exists non failed 
mobile failure model holds 
set states similarity connected sequence states 
signi cance similarity states similar correct process distinguish 
particular process act way states example decide states 
obtain lower bounds rst show set initial states consensus algorithm similarity connected 
construct additional layers corresponding states longer executions similarity connected 
connectivity characteristic model particular algorithm problem 
prove lower bounds consensus observe similarity connected set states decision 
uniform consensus observe similarity connected set states decision step 
derive results view similarity connected set connected graph coloring function assign decision values nodes graph 
speci cally new coloring function 
state consider execution extending failures occur state layer repeatedly executed steps note algorithm solves weak consensus correct processes decide value execution 
denote decision value val coloring function 
uniform consensus failure free lower bound denote con set initial states process failed 
initial state determined inputs processes combination initial state con known lemma shows con similarity connected 
lemma con similarity connected 
proof state denote local state process state states con de ne setting get note di er exactly local state process processes non failed state con states similar coloring function val show uniform consensus algorithm reach decision communication step states similarity connected set 
lemma similarity connected set states uniform consensus algorithm crash failure model 
assume states val val 
assume state correct processes fail 
state failure free extension takes additional communication steps processes decide 
proof similarity connected similar states val val 
assume loss generality val 
states identical local state process non failed processes non failed process highest identi er failed 
assume way contradiction correct process decides step failure free extension consider state 
fails step 
state processes decide 
processes fail states add layers 
extend crashing processes consider state 

process exactly local state 


decides 

uniform agreement property extension 
correct processes decide 
symmetric argument decides 
extension 
correct processes decide 
particular extension 

correct processes decide extension 

correct processes decide 
correct process hears 



correct processes state 
contradiction 
plugging con lemma get theorem theorem resilient weak uniform consensus algorithm perform communication steps failure free execution processes decide 
proof lemma con similarity connected 
weak validity property states con val val 
state con correct processes fail 
lemma failure free execution takes communication steps processes decide 
seen lower bound case follows fact con similarity connected 
order prove general case prove con similarity connected general bounds connectivity uni ed proof lemma applies algorithms solving problem synchronous crash mobile failure models just consensus uniform consensus 
lemma shows models set similarity connected states process fail apply possible layers lm state get similarity connected set 
set states crash failure model add layers long number failures exceed mobile failure model add layers inde nitely 
lemma similarity connected set states lm assume state number processes failed smaller 
mobile failure model assumption holds process failed 
similarity connected 
proof rst show similarity connected 
recall pair processes non failed states 

failures extension addition states similar di er state identical case faulty case send message step 
left show states lemma follow 
see recall states identical local state process exists process non failed states 
number processes failed smaller possible crash 
consider states 


non failed processes local states process 
order apply topological result consensus replace con lemma allow base impossibility results con lemma 
con similarity connected con similarity connected 
exist con val val lm proof 
proof induction base lemma con similarity connected 
state con processes failed 
inductive step assume con similarity connected lm 
construction state con processes failed 
lemma con similarity connected 

weak validity exist states con val val 
states obtained applying layer times respectively 
failure free extensions get val val con 
coloring function val show similarity connected set states process decides 
lemma similarity connected set states consensus algorithm crash mobile failure model 
assume states val val state correct process decided 
proof similarity connected similar states val val 
states identical local state process exists correct process local state decided value decided value fail val val get decided value contradiction 
ready prove impossibility general lower bound results 
theorem resilient weak consensus algorithm mobile failures model 
proof lemma exist con val val con similarity connected lemma correct process decided execution steps correct process decide 
lemma fact layering nite exists nite execution correct process decide violating termination requirement 
theorem consider algorithm weak consensus synchronous crash model failures exists execution algorithm failures step correct process decide 
decision requires steps 
proof fix lemma exist con val val con similarity connected lemma correct process decided execution steps failures correct process decide 
showed steps lower bound consensus crash failure model executions failures 
mentioned bound tight lf 
uniform consensus case extra step needed theorem consider algorithm weak uniform consensus synchronous crash model failures exists execution algorithm failures step correct process decide 
decision requires steps 
proof fix 
lemma exist con val val con similarity connected 
state con correct processes fail 
lemma state con failure free extension takes additional communication steps processes decide 
execution failures takes communication steps processes decide 
weak validity property mentioned section weak validity property stronger weak validity property de ned flp 
weak validity property requires failure free executions lead di erent decision values property flp requires merely exist executions necessarily failure free lead di erent decision values 
stronger property really needed 
turns weaker property de ned flp sucient lower bound consensus impossibility consensus mobile failure model 
proof results works weaker weak validity property 
weaker weak validity property flp suce lower bound weak uniform consensus lower bound halting consensus due drs show 
give counter example algorithm satis es uniform agreement termination weak validity de ned flp 
decides halts communication step failure free execution 
counter example algorithm uses uniform consensus algorithm satis es strong validity 
know algorithm uniform consensus model exists cbs 
uniform consensus algorithm invoked calling uniform consensus 
function counter example step send message processes including 
step set processes step messages received 
js return send message processes endif step set processes step messages received 
js js init init endif return uniform consensus init 
counter example algorithm weaker weak validity 
easy see counter example algorithm decides halts step failure free executions 
argue algorithm solves weak uniform consensus weakened validity property 
show uniform agreement rst observe process decides step processes run uniform consensus input value uniform consensus 
send step message process execute step js js strong validity property uniform consensus possible decision value case 
process decides step uniform consensus algorithm ensures uniform agreement 
termination implied termination uniform consensus algorithm correct processes decide step run uniform consensus algorithm 
algorithm satis es weakened weak validity property flp possible decision values failure failures initial failures process fails send messages decision 
failures decision 
deriving lower bounds non synchronous models results previous section derive lower bounds consensus partial synchrony model asynchronous model unreliable failure detectors 
steps rst section derive lower bound uniform consensus models section show algorithm solves consensus models solves uniform consensus 
lower bound consensus follows 
synchronous asynchronous bounds previous section considered synchronous model processes may fail 
model shown corollary uniform consensus algorithm synchronous model processes fail perform communication steps execution processes decide 
lower bound applies behaved executions partial synchrony model asynchronous model failure detectors show lemmas 
lemma algorithm solves uniform consensus partial synchrony model processes crash behaved execution algorithm performs communication steps processes decide 
proof assume proposition false exists uniform consensus algorithm tolerates crashes decides communication step behaved execution failure free synchronous execution 
clearly algorithm solves uniform consensus synchronous model decides communication step execution 
contradiction corollary 
lemma algorithm solves uniform consensus asynchronous model enriched failure detector processes crash behaved execution algorithm performs communication steps processes decide 
proof suces show implement failure detectors synchronous model execution behaved failure free executions synchronous model 
construct failure detector algorithm algorithm conducted synchronous communication steps 
step process sends message process waits time step 
initially process empty suspect list 
subsequent communication step suspects processes get messages step 
clearly synchronous model failure detector suspects process process crashed perfect failure detector de ned ct 
particular failure detector class 
failure free executions failure detector suspect process 
failure free execution synchronous model simulates behaved execution asynchronous model failure detector 
implement failure detector modify algorithm process output process lowest identi er processes suspect 
failure detector suspects process process crashed failure detector process outputs rst non crashed process lexicographical order 
failure occurs processes elect correct leader 
failure free executions leader process execution 
behaved execution note lower bound uniform consensus holds failure detector implemented partial synchrony model manner preserves behaved nature executions 
consensus uniform consensus guerraoui gue proves algorithm solves consensus asynchronous model enriched certain classes failure detectors including solves uniform consensus 
adapt guerraoui proof models consider partial synchrony model asynchronous model enriched failure detector give arbitrary output arbitrary pre execution 
lemma partial synchrony model asynchronous model failure detector give arbitrary output arbitrary pre execution algorithm solves consensus solves uniform consensus 
proof assume algorithm solves consensus uniform consensus aforementioned models 
algorithm execution processes decide di erent values fails deciding 
assume loss generality decides point execution decides point decides 
note point fails fail 
construct execution correct point identical may send messages send may crashed part time 
delay receipt messages process point execution addition failure detector oracles processes give outputs pre pre time failure detector satisfy required semantics 
failure detector give arbitrary output arbitrary pre execution delay pre time observe pre point indistinguishable process pre point identical point 
decides time value observe process indistinguishable time decides time value decide di erent values correct 
contradiction 
conclude theorem recall asynchronous partial synchrony models environment delay messages arbitrarily long arbitrary pre execution global stabilization time gst occur theorem consider model partial synchrony asynchronous model enriched failure detector processes crash 
algorithm solves consensus models behaved execution algorithm performs communication steps processes decide 
note generally theorem holds asynchronous model enriched failure detector satis es conditions 
failure detector implemented partial synchrony model manner preserves behaved nature executions required lemma 
failure detector provide arbitrary output arbitrary pre execution required lemma 
optimistic note seen practical models messages may occasionally lost delayed faulttolerant consensus algorithms require communication steps behaved executions synchronous communication failures false failure suspicions 
contrast algorithms consensus synchronous crash failure model decide communication step failure free executions 
additional communication step required models due fact models correct processes may mistaken faulty ones 
observe additional communication step needed order avoid disagreement processes incorrectly suspected failed 
observation give insight possible gains optimistic approach lieu consensus explain 
agreement property consensus conservative requires correct processes decide di erent values 
state machine replication lam sch consensus introduces inconsistencies correct replica 
words consensus guarantees serializability execution replica exhibit sequence states 
contrast optimistic approach allows replica temporarily diverge long con icts detected reconciled 
optimistic approaches application live temporary con icts 
approaches generally cost ective con icts rare 
group communication systems acm isis bss take optimistic approach state machine replication implement algorithms totally ordered multicast operate single communication step 
example algorithms isis bss amoeba kt leader election follows leader sends proposed value processes immediately decides value 
recipients leader message immediately decide suggested value 
long leader suspected processes consistency preserved 
leader suspected new leader elected new leader attempts learn decision value processes communicate 
long false suspicions consistency ensured 
leader correct suspected crashed processes decide di erent value leader 
isis resolves inconsistencies forcing suspected leader fail re new process adopts state replica 
general con icts inevitable single communication step algorithm models implied lower bound proven 
hand con icts detected immediately processes point suspected re establish communication 
con icts reconciled quickly 
coste ectiveness optimism depends rate con icts 
recall observation role extra communication step practical models avoid potential con icts processes incorrectly suspected failed 
suggests frequency con icts optimistic approach depends frequency false suspicions 
rate false suspicions system guideline deciding optimism conservative approach consensus preferable 
network environments exhibit complex combinations timing behaviors failure patterns worst case useful successfully completed 
practice usually communication timely failures rare 
useful practice algorithms able tolerate asynchrony failures perform common benign circumstances 
motivated observation 
considered consensus algorithms tolerate bounded asynchrony failures studied algorithms performance benign circumstances 
de ned notion behaved executions capturing benign circumstances 
studied number communication steps performed consensus algorithms behaved executions 
showed tight lower bound communication steps systems processes crash 
contrast algorithms tolerate asynchrony decide communication step failure free executions lf lyn 
shown additional communication step required due fact models correct processes may mistaken faulty ones 
additional communication step needed order avoid disagreement processes incorrectly suspected failed 
suggests optimistic approach consensus single communication step algorithm inconsistencies arise case false suspicions explained section 
important goal provide intuition lower upper bounds 
illustrated upper bound discussing known algorithms achieve lower bound 
aimed give formal lower bound proofs simple easy follow possible 
order derive communication step lower bound non synchronous models rst looked synchronous crash failure model 
showed model uniform consensus algorithms need communication steps executions failures processes decide number processes crash 
bound previously shown charron bost schiper cbs lower bound proof cover case interested 
gave rst time proof forward induction lower bound rst proof covering case 
furthermore gave uni ed proof showing lower bound known results lower bounds consensus impossibility results consensus mobile failure model 
illustrated fact di erent lower bounds stem similar principles illustrated general technique obtaining simple elegant lower bound impossibility proofs 
acm acm 
communications acm special issue group communications systems april 
act aguilera chen toueg 
heartbeat failure detector quiescent reliable communication consensus partitionable networks 
theoretical computer science june 
aguilera toueg 
simple proof resilient consensus requires rounds 
information processing letters 
bhg bernstein hadzilacos goodman 
concurrency control recovery database systems 
addison wesley reading ma 
bar joseph ben 
tight lower bound randomized synchronous consensus 
th acm symposium principles distributed computing podc pages 
bss birman schiper stephenson 
lightweight causal atomic group multicast 
acm transactions computer systems 
cbs charron bost schiper 
uniform consensus harder consensus extended 
technical report dsc swiss federal institute technology lausanne switzerland may 
cf cristian fetzer 
timed asynchronous distributed system model 
ieee transactions parallel distributed systems pages june 
cht chandra hadzilacos toueg 
weakest failure detector solving consensus 
acm symposium principles distributed computing podc pages 
chockler keidar 
group communication speci cations comprehensive study 
acm computing surveys 
appear 
previous version mit technical report mit lcs tr september 
cm chang 
reliable broadcast protocols 
acm transactions computer systems 
ct chandra toueg 
unreliable failure detectors reliable distributed systems 
journal acm march 
dolev friedman keidar malki 
failure detectors omission failure environments 
tr institute computer science hebrew university jerusalem israel september 
technical report department computer science cornell university 
dls dwork lynch stockmeyer 
consensus presence partial synchrony 
journal acm april 
dm dwork moses 
knowledge common knowledge byzantine environment crash failures 
inform 
comput october 
dpll de lampson lynch 
revisiting paxos algorithm 
editors th international workshop distributed algorithms pages saarbrucken germany september 
springer verlag 
lncs 
drs dolev reischuk strong 
early stopping byzantine agreement 
journal acm october 
ds dwork skeen 
inherent cost nonblocking atomic commitment 
acm symposium principles distributed computing podc pages 
flp fischer lynch paterson 
impossibility distributed consensus faulty process 
journal acm april 
gra gray 
notes database operating systems 
operating systems advanced course lecture notes computer science volume pages 
springer verlag berlin 
gue guerraoui 
revisiting relationship non blocking atomic commitment consensus 
jean michel michel raynal editors th international workshop distributed algorithms pages 
springer verlag september 
lncs 
hr raynal 
simple fast asynchronous consensus protocol weak failure detector 
distributed computing 
hrt herlihy rajsbaum tuttle 
unifying synchronous asynchronous message passing models 
th acm symposium principles distributed computing podc pages 
acm june 
hrt herlihy rajsbaum tuttle 
new synchronous lower bound set agreement 
submitted publication april 
kd keidar dolev 
ecient message ordering dynamic networks 
th acm symposium principles distributed computing podc pages may 
kd keidar dolev 
increasing resilience distributed replicated database systems 
journal computer system sciences special issue selected papers acm sigact sigmod symposium principles database systems pods december 

theorie der und 

reprinted chelsea 
kt kaashoek tanenbaum 
group communication amoeba distributed operating system 
th international conference distributed computing systems icdcs pages may 
lam lampson 
build highly available system consensus 
babao glu marzullo editors distributed algorithms lncs 
springer verlag 
lam lamport 
part time parliament 
acm transactions computer systems may 
research report digital equipment systems research center palo alto ca september 
lam lamport 
lower bounds consensus 
unpublished manuscript march 
lam lamport 
time clocks ordering events distributed system 
communications acm july 
lf lamport fischer 
byzantine generals transaction commit protocols 
technical report sri international april 
lyn lynch 
distributed algorithms 
morgan kaufmann publishers 
moses rajsbaum 
uni ed structure consensus layered analysis approach 
th acm symposium principles distributed computing podc pages 
acm june 
submitted journal publication 
raynal 
solving consensus chandra toueg unreliable failure detectors general approach 
th international symposium distributed computing disc bratislava republic 
sch schneider 
implementing fault tolerant services state machine approach tutorial 
acm computing surveys december 
sch schiper 
early consensus asynchronous system weak failure detector 
distributed computing 
ske skeen 
nonblocking commit protocols 
acm sigmod international symposium management data pages 
sw santoro widmayer 
time 
th annual symp 
theor 
aspects computer science volume lncs pages paderborn germany february 
springer verlag 

