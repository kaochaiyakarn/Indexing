combinators functional programming languages cousineau curien robinet editors lecture notes computer science springer verlag amber machine luca cardelli bell laboratories murray hill nj amber machine stack machine designed intermediate language compiling higher order languages 
current version specialized amber language 
machine supports set basic structured data types functional closures signals bitmap graphics persistent objects meta level execution 
needed amber compiler entirely written amber amber machine level needs switch level executing program just compiled 
set implementation strategies admissible machine including bytecode interpretation threaded code interpretation compilation native code 
current implementation byte code interpreter space compacting collector runs macintosh 
amber machine stack machine designed intermediate language compiling higher order languages tradition secd machines landin combinator machines turner curien 
revision functional machine described cardelli cardelli specialized amber language cardelli 
amount specialization required particular language general class higher order algorithmic languages marginal involves set primitive data types affect basic organization machine 
machine supports set basic data types functional closures signals persistent objects meta level execution 
needed amber compiler entirely written amber amber machine level needs switch level executing program just compiled 
current dec src lytton ave palo alto ca 
set implementation strategies admissible machine including bytecode interpretation threaded code interpretation compilation native code 
current implementation byte code interpreter space compacting collector similar functional machine ml language compiled vax code space compacting collector 
format level format level lowest level amber machine 
level language independent considered general purpose heap manager 
supports garbage collection data persistence knowledge language data structures supported higher levels 
data boxed unboxed 
unboxed data exists stack inside data structures require memory allocation 
distinguish kinds unboxed characters normally byte words normally bytes 
unboxed char pointer integer value marks word unboxed words structured 
contain mark bits garbage collector persistence mechanism flag indicating integer pointer needed garbage collector integer pointer value 
boxed values allocated heap 
header data section format size marks header data boxed header contains mark bits unboxed words code indicating format data section size number items data section 
corresponding kind unboxed data format boxed data 
scalar sequence unboxed characters vector sequence unboxed words 
scalar vector routines supported manipulation data formats mkint int word convert ordinary integer unboxed integer ptr word convert address unboxed pointer isint word bool test unboxed word unboxed integer word bool test unboxed word unboxed pointer word int convert unboxed integer ordinary integer word ptr convert unboxed pointer address int boxed allocate boxed scalar size int boxed allocate boxed vector size boxed bool test boxed scalar boxed bool test boxed vector boxed int get size boxed scalar boxed int get size boxed vector boxed int char get th item boxed scalar boxed int word get th item boxed vector boxed int char set th item boxed scalar boxed int word set th item boxed vector hold stack provided store boxed data temporarily permanently 
garbage collector traces data starting hold stack structures accessible hold stack 
hold stack stack indirections heap indirections called holds 
necessary manipulate holds directly manipulating data garbage collector may unexpectedly start invalidate direct pointers data 
boxed hold push boxed hold stack obtaining hold boxed pop hold stack obtaining boxed top hold boxed extract boxed hold collect garbage collection normally called 
garbage collection implemented variety ways 
current amber implementation uses space compacting collector 
technique requires mark bits boxed unboxed data extra relocation word boxed datum prefixed header field invisible operations 
routines provide basic persistence mechanism 
extern takes arbitrary boxed unboxed datum writes file careful preserve sharing circularities 
intern inverse reads object exactly modulo relocation 
executions extern object duplicate persistent storage invocations intern file copies object memory 
extern filename string data save datum persistent storage intern filename string data fetch datum persistent storage extern intern implemented purely iteratively pointer reversal techniques restriction size persistent objects memory size 
encoding extern objects 
called dex data exchange format 
dex file describes data object loops shared subobjects 
dex file starts ends 
brackets data segments 
data segment refer data segment see order number segment segment file number zero 
data segment object described dex file 
data dex file encoded kinds descriptors 
followed non negative see number representing number data segment 
numbers 
followed representation number 
scalars 
followed non negative number 
followed chars 
vectors 
followed non negative number 
followed descriptors 
characters appear dex file 
variable size hex representation number 
hex digits represented negative starts followed representation 
zero represented 
positive represented hex encoding leading zeros 
terminated character different 
ex 
data structure level data structures needed particular language built top data formats 
data structures amber described 
level supports operations allocating accessing modifying data structures operations described previous section 
bool booleans represented unboxed integer words false true 
int integers represented unboxed integer words 
string strings characters represented scalars 
bitmap bitmaps graphics represented scalars 
region regions compressed bitmaps represented scalars 
record records represented vectors length 
positions point string representing field name odd positions contain field value 
variant variants represented vectors length 
item points string representing variant tag second item content variant 
array arrays represented vectors 
ref assignable variables extra indirection called ref object represented vector length 
function functions represented combination scalar vectors 
compiled code function contained scalar called code 
code section directly contain pointers literals strings embedded program code 
literals collected object called text vector element code remaining elements literals code 
literals normally strings text objects arising nested function definitions 
text objects built compile time change execution 
global variables function collected vector called closure element text remaining elements values global variables 
closures built run time different closures share text object 
closure text code globals literals opcodes sequel shall closures extensively drawn compact way closure text code globals literals opcodes stack instructions having meta level execution directly manipulate execution stacks 
reason stacks legal amber machine objects allocated heap data structures represented vectors 
stack pointer just index vector 
stack items top stacks frequently shown space efficient way top operation level amber machine stack machine 
state determined stack pointer sp indicating top evaluation stack trap pointer tp pointing trap frame trapping signals frame pointer fp pointing current closure program counter pc pointing instruction executed 
pc points code segment belonging current closure tp points stack sp 
pc fp sp tp machine computes performing state transitions 
state transition involves subset state show parts change exception pc moving instruction assumed shown 
transitions determined instruction pc pointing 
transition pc changes point instruction indicated notation pc value pc instruction 
exact meaning pc depends particular implementation strategy 
data operations simple data operations affect stack possibly heap take arguments stack produce results greater equal zero 
argument stack deepest similarly results 
data operations state transitions kind op sp sp rm simple data operations 
parameters taken instruction stream 
takes arguments returns true unboxed value equal unboxed integers unboxed pointer false 
takes argument value returns 
low level printing routine shows format structure value 
takes arguments returns boolean takes boolean argument returns negation 
takes boolean arguments returns boolean 
takes boolean arguments returns boolean 
takes arguments returns integer takes integer arguments returns sum 
signals overflow 
takes integer arguments returns difference 
signals overflow 
takes integer arguments returns product 
signals overflow 
takes integer arguments returns quotient 
signals divide zero 
takes integer arguments returns module 
signals mod zero 
takes integer arguments returns true second false 
takes integer arguments returns true equal second false 
takes integer arguments returns true greater second false 
takes integer arguments returns true greater equal second false 
takes arguments integers returns string length argument initialized character ascii representation second argument 
signals string argument negative second argument 
takes argument string returns length 
takes arguments string integer returns nth character string integer 
signals range 
takes arguments string integer integer returns 
replaces th element string integer converted character 
signals range 
takes arguments string index size allocates returns string initialized substring starting length signals sub bounds 
takes arguments destination string index source string returns 
side effects destination string replacing source string substring destination string starting index having length source string 
signals index index length source bounds 
takes arguments source string source index sx integer destination string ds destination index dx copies substring length starting sx starting dx 
string order copy chosen appropriately substring sx dx substring 
signal bounds 
takes arguments string string index boolean searches occurrence characters inside starting position search forward true backwards 
returns index occurrence signals search 
takes string arguments returns true equal string false 
takes arguments integers hor ver allocates returns bitmap bounding tile hor ver 
takes argument bitmap returns integers hor ver forming bounding tile 
takes arguments bitmap integers returns bool 
result true pixel bitmap black false bounds 
takes arguments source bitmap integer hor ver destination bitmap integer dx dy integer code region returns 
transfers tile hor ver source destination position dx dy code copy xor clear 
destination clipped region 
takes arguments source bitmap destination bitmap integers hor ver integer code region returns 
replicates source bitmap tile hor ver destination bitmap clipped region code copy xor clear 
replicated pattern aligned origin destination bitmap 
takes arguments bitmap integers integer code region returns 
draws line code copy xor clear clipping region 
takes arguments returns screen bitmap 
takes arguments returns integers current position mouse cursor 
takes arguments integers returns 
moves mouse cursor position 
takes arguments returns boolean true mouse button pressed false 
button assumed 
takes arguments returns bitmap current cursor icon 
changes change cursor image 
takes integers nx ny returns integers ox oy 
changes tip cursor coordinates cursor pixel cursor position nx ny 
returns old value tip ox oy 
takes arguments returns null region region points arbitrary coordinate system 
takes arguments integers hor ver returns rectangular region size hor ver 
takes bitmap returns region compressed version bitmap 
region coordinate system bitmap 
blank regions equivalent called null regions 
takes arguments region integers dx dy returns region 
moves argument region dx dy respect coordinate system returns new region argument region affected 
takes arguments region integers dx dy returns region 
shrinks expands negative dx dy region moving points inward outward dx dy 
takes regions returns region 
result region set union points argument regions 
takes regions returns region 
result region set intersection points argument regions 
takes regions returns region 
result region set difference points argument regions 
takes regions returns region 
result region set symmetric difference points argument regions 
takes region returns integers hor ver forming maximal tile entirely contained region signals region empty 
affect region 
takes arguments integers region returns boolean 
result true point belongs region 
takes arguments integers hor ver region returns 
true hor ver intersects points region 
takes arguments regions returns boolean 
result true regions coordinate system set points 
empty regions equal matter coordinate system takes argument value returns variant object tag th literal current closure contents argument 
takes arguments variant value 
variant tag equal th literal current closure contents variant set second argument signals 
takes arguments returns record th label th literal current closure th field th argument 
takes argument record returns value field label equal th literal current closure string 
parameter initial guess index label record 
guess wrong record searched label index field stored back code stream guess time 
takes arguments record value returns 
assigns value new contents record field label equal th literal current closure string 
parameter 
takes arguments integer value allocates returns array size items initialized signals array argument negative 
takes argument array returns size 
takes arguments array index returns th item array 
signals index range 
takes arguments array index value returns results 
updates th element array value takes argument value allocates returns ref data structure containing 
takes argument ref data structure returns contents 
takes arguments ref value returns results 
assigns value new contents ref 
takes arguments argument string value returns 
writes value file name string extern routine 
signals extern disk errors 
takes argument string returns value 
reads value file name string intern routine 
signals intern disk errors 
takes argument string returns 
redirects input stream initially bound screen 
old input streams saved input stream stack 
redirects input stream file name string argument signals infile errors 
string empty redirects input stream previous stream signals infile input stream stack empty 
takes argument string returns 
redirects output stream initially bound screen 
old output streams saved output stream stack 
redirects output stream file name string argument signals outfile errors 
string empty redirects output stream previous stream signals outfile output stream stack empty 
takes arguments returns integer 
reads character input stream 
input stream currently bound file input stream redirected previous stream input stream stack ascii blank character returned 
input stream bound screen characters read waits 
signals input errors 
takes arguments returns boolean 
tests currently characters read input stream 
returns true input stream currently bound file 
signals errors 
takes argument integer returns 
writes integer output stream character 
signals output argument errors 
takes argument string returns 
writes string output stream 
signals output errors 
stack operations general purpose stack shuffling operations 
copies th element stack top 
element stack displacement 
sp sp copies th global variable top stack fetches global variable closure note structure closures element index closure vector 
sp fp sp fp copies th literal top stack 
fetches literal text structure text objects element index text vector 
sp fp sp fp removes values top stack 
sp sp removes stack elements starting depth equivalent sp sp control operations control operations affect order execution instructions modify pc ways simply moving instruction 
function application achieved instruction number arguments application 
current calling closure saved place called closure installed current 
value pc saved stack pc set called closure 
pc fp fp pc sp sp pc operation takes care function returns number arguments current call number results 
old calling closure restored current saved value pc current 
calling closure arguments saved pc squeezed stack 
pc fp sp rm sp rm pc fp pc unconditional jumps obtained instruction relative displacement current pc 
exact meaning depends implementations 
sp fp pc sp fp pc conditional jumps obtained instruction relative displacement current pc 
exact meaning depends implementations 
jumps top stack value true proceeds instruction 
cases top value popped away 
picture shows transitions symmetric 
sp fp pc sp fp pc true sp fp pc sp fp pc false case operation variant objects 
top stack variant tag string contents string equal literal index current closure pc incremented corresponding relative displacement 
pc incremented literals index different 
case variant top stack replaced contents 
sp sp fp fp pc pc fp fp pc pc sp sp closure operations closure operations really belong data operations section listed separately importance general workings machine 
builds closure global variables text object obtained values stack 
values stack inverse order globals closure 
sp sp recursive mutually recursive functions need recursively defined closures 
built steps allocating empty closures filling 
builds dummy closures globals text object stack 
sp sp mn fills existing dummy closure depth stack values top stack pops values away 
values stack inverse order globals closure 
sp sp signal operations machine operations may signal exceptional conditions example signals string divide zero 
signals global jump outs unwind stack 
traps set intercept signals recover 
sets trap record intercept class signals 
string top stack name signal intercepted trap 
top saved pc current closure current trap pointer tp 
tp set top stack 
pc incremented relative displacement code immediately recover signals 
sp fp pc tp tp sp pc fp pc sig sig eliminates trap record case signal issued evaluation results evaluation sitting top stack 
tp set previous tp trap record squeezed stack 
pc sp tp sp tp sig signals generated primitive operations operation 
primitive operations push name signal string top stack assumes name signal 
signal issued process takes place 
trap frames scanned starting current tp looking trap signal 
adequate trap effect operation see message printed reporting occurrence signal 
appropriate trap record stack current closure pc replaced closure pc trap frame sp set trap frame tp set trap frame stack 
sp tp pc sp tp pc fp fp sig pc sig meta operations meta operations amber amber compiler bootstrap switch level compilation execution 
introduce new component machine state shown state stack 
complete machine state consisting execution stack closure saved state stack fresh machine started 
complete machine state resumed 
saves machine state state stack starts new machine 
operation expects stack text object execution stack initial setting tp sp new machine 
text object converted empty closure current pc set 
new stack tp sp current 
old pc closure stack tp sp saved state stack level pointer raised 
sp sp fp tp pc fp pc tp pc restores previously saved machine state stops amber machine state stack empty 
situation non empty state stack 
saved closure pc stack tp sp restored current stack tp sp pushed restored stack 
sp fp pc tp pc sp fp tp pc takes argument stack returns 
argument closure saved special place 
closure coerce construct amber language involves run time call amber typechecker 
takes arguments returns closure set apart signals executed 
operations takes arguments aborts execution machine 
emergencies 
takes argument string returns 
string interpreted set system flags meaning implementation dependent 
takes arguments returns 
inserted possibly infinite computation loops loops recursive functions able cleanly 
precise effect implementation dependent 
bytecode implementation section describe current implementation detail 
code object sequence bytecodes encoding machine operation parameters bytecodes 
code followed unsigned byte parameter 
codes 
meaning 

code 
code 
code 
code 
code 
code 
code 
code 
code 
code followed unsigned byte followed pairs byte bytes followed bytes 
displacements relative value pc immediately 
code followed unsigned byte 
code 
code 
code 
code 
code followed byte 
code 
code 
code 
code followed bytes constituting signed integer 
displacement relative value pc immediately code 
code 
code followed byte 
codes 
meaning 

code followed unsigned byte 
code followed bytes constituting unsigned integer 
code followed unsigned byte 
codes 
meaning 

code 
code 
code 
code 
code followed bytes constituting signed integer 
code followed signed byte 
codes 
meaning 

codes 
meaning 

code 
code followed bytes constituting signed integer 
displacement relative value pc immediately code 
code 
code 
code 
code 
code 
code 
code 
code 
code 
code 
code 
code 
code 
code 
code 
code followed unsigned byte 
code 
code 
code followed unsigned byte followed unsigned byte 
code followed unsigned byte followed bytes 
code 
code followed unsigned byte followed unsigned byte 
code followed unsigned nibble followed unsigned nibble 
codes 
meaning 

codes 
meaning 

codes 
meaning 

codes 
meaning 

code 
code 
code 
code followed byte followed byte 
code 
code followed byte followed byte 
code 
code followed unsigned byte 
code 
code followed unsigned byte followed unsigned byte 
code 
code 
code 
code 
code 
code 
code 
code 
code followed bytes constituting signed integer 
displacement relative value pc immediately code followed bytes constituting signed integer 
displacement relative value pc immediately code 
code 
code 
code followed unsigned byte 
code 
code 
apple apple computer inside macintosh addison wesley 
cardelli cardelli functional machine bell labs technical report tr 
polymorphism jan 
cardelli cardelli compiling functional language conference record acm symposium lisp functional programming austin texas august 
cardelli cardelli amber combinators functional programming languages proc 
th summer school le val france may 
lecture notes computer science springer verlag 
curien curien categorical combinators sequential algorithms functional programming wiley new york landin landin mechanical evaluation expressions computer journal vol 
pp 

pike guibas ingalls pike guibas ingalls bitmap graphics siggraph course notes 
turner turner new implementation technique applicative languages software practice experience vol 
