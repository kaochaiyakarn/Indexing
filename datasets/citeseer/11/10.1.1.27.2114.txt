efficient distributed backup delta compression randal burns darrell long department computer science department computer science ibm almaden research center university california santa cruz randal almaden ibm com darrell cs ucsc edu inexpensive storage powerful processors resulted proliferation data needs reliably backed 
network resource limitations increasingly difficult backup distributed file system nightly weekly basis 
delta compression algorithms minimally encode version file bytes changed backup system compress data sent server 
delta backup technique achieve significant savings network transmission time previous techniques 
measurements indicate file system data may average compressed original size method approximately changed files backed previous week 
measurements conclude small file store client contains copies previously backed files retain versions order generate delta files 
reduce load backup server implement modified version storage architecture version jumping allows restore delta encoded file versions accesses tertiary storage 
minimizes server workload network transmission time file restore 
currently file system backup takes long prohibitive storage cost 
resource constraints impede reliable frequent backup increasing amounts data spinning disks today 
time required perform backup direct proportion amount data transmitted author performed visiting scientist ibm almaden research center 
network backup clients backup server 
delta compression compactly encoding file version set changes previous version backup system architecture reduces size data transmitted reducing time perform backup storage required backup server 
backup restore limited network bandwidth mb poor throughput tertiary storage devices slow kb tape storage 
resource limitations frequently backing changed files infeasible single night weekend delta file compression great potential alleviate bandwidth problems available client processor cycles disk storage reduce amount data transferred 
technology enables perform file backup lower bandwidth channels previously possible example subscription backup service internet 
early efforts reduce amount data backed produced simple optimization incremental backup backs files modified epoch period backups 
incremental backup detects changes granularity file delta backup refines concept transmitting altered bytes files incrementally backed 
consequently bytes modified large file backup system saves expense transmitting large file favor transmitting changed bytes 
advances differencing algorithms allow nearly optimally compressed encodings binary inputs linear time 
algorithm generate delta encodings versions 
differencing algorithm finds outputs changes versions file locating common strings copied unique strings added explicitly 
delta file delta encoding output differencing algorithm 
algorithm creates delta file takes input versions file file version file encoded outputs delta file representing modifications versions version delta version reconstruction inverse operation requires file delta file rebuild version delta version version backup system leverage delta files generate minimal file representations see 
enhanced client server architecture distributed storage manager adsm backup system transmit delta files backup client retained versions file 
furthermore uncompressed files delta encoded files realize benefits standard file compression methods adsm utilizes 
integrate delta backup adsm compatible system optimizations transmit store reduced amount data server 
server storage network transmission benefits paid client processor cycles generate delta files additional disk storage backup client retain second copies files generate delta files 
architecture optimizes network storage bottleneck server favor distributed resources server multiple clients 
describe previous delta compression version storage 
modifications adsm system architecture 
describe delta storage problem presence large number versions 
analyze performance version jumping storage method compare optimally compact storage method linear delta chains 
potential discussed 
origins delta backup delta backup emerged applications instance appearing database technology 
database pages written backup epochs marked dirty single bit 
epoch dirty pages need backed 
concept parallels delta backup operates page granularity 
file systems guarantees modifications page alignment 
dirty bits effective databases may apply file system backup 
improve granularity backup logging methods record changes database file system 
logging system records write epoch log file 
recover version existed start epoch current state 
semantically similar delta compression logging provide compressibility guarantees differencing algorithms 
database example log journal changes grows proportion number writes 
bytes modified adjacent bytes modified different times minimal representation 
extremely active page log exceed page size 
differential compression guarantee log modifications file smaller corresponding delta 
commercial systems appeared marketplace claim perform delta backup 
exact methods systems disclosed product literature implies perform logging difference granularity file block 
perform delta backup granularity byte 
running differential compression algorithms changed versions granularity generate backup minimal delta files 
previous version management despite file restoration infrequent operation backup restore optimizing process great utility 
restore performed file system components lost damaged 
unavailable data nonfunctional systems cost businesses universities home users lost time revenue 
contrasts backup operation generally performed night low usage periods 
restoring files stored delta backup generates additional concerns delta file management 
traditional methods storing deltas require decompression agent examine versions file versions version version restored 
case time reconstruct file grows linearly see respect number versions involved 
backup system additional limitation delta file may reside physically distinct media device device access slow generally seconds load tape tape robot 
consequently having distinct deltas participate restoration single file costly device latency 
important goal system minimize number deltas participating restore operation 
previous efforts efficient restoration file versions provided restoration execution times independent number intermediate versions 
include methods avl dags linked data structures string libraries 
require delta versions file restore time consequently infeasible backup system 
backup system require prior versions file recalled long term storage file reconstructed 
previous methods efficient restoration fail ap file store magnetic storage tape storage file store restore manager delta compression algorithm file system adsm delta client adsm delta server delta compression agent server hierachical storage manager deletion expiration policy manager backup client server schematic delta backup system 
ply backup restore application describe new technique called version jumping associated system architecture 
version jumping takes delta versions version consequently requires files perform restore operation version 
restoration time independent total number stored versions 
system architecture modified architecture design distributed storage manager adsm ibm add delta compression capabilities 
modified adsm client delta compresses file data granularity byte transmits delta files server 
modified adsm server enhanced file deletion capabilities ensure delta file stored server corresponding file 
adsm client server backup restore system currently available client platforms 
adsm server available operating systems including windows nt various unix mainframe operating systems 
key features adsm scheduled policy management file backup client request server polling hierarchical storage management server media devices including tape disk drive optical drives 
delta compression client modified standard adsm client perform delta backup restore operations 
modifications include differencing reconstruction algorithms see addition file store 
order compute deltas current version file compared version 
choice storing version client fetching server 
obtaining file server increase network traffic server load adversely affecting time perform backup 
storing file client incur small local storage cost exchange large benefit decreased backup time 
considered options maintaining files including copy write shadowing file system logging 
options rejected violated design criterion file system modifications 
adsm supports client operating systems file system modification presents significant portability maintenance concerns 
chose keep copies backed files file store 
file store reserved area disk versions files kept see 
sending uncompressed file server backup client copies file file store 
point file system holds copies file active version file system space static version file store 
file store fills client selects file ejected 
choose victim file simple weighted lru technique 
backup system files equally old backed epoch 
order discern multiple potential victims backup client uses additional metric weight files equal lru value 
select victim file achieved worst relative compression previous usage file highest delta file size uncompressed file size ratio backup 
allows discern potential victims increase utility file store 
time weighting violate tried true lru principle consequently expected realize benefits locality 
percentage hits days day window day window day window fraction files modified today modified days ago 
backup client sends file prior version file store client delta compresses file transmits delta version 
old version file retained file store common file version jumping system 
expect storage requirements file store excessive 
order evaluate effectiveness file store collected data months file servers school engineering university california santa cruz 
night search files modified newly created past hours 
measurements indicate approximately files newly created modified average day day 
modified files contain approximately file system data 
estimate effectiveness file store sliding window 
considered windows days 
axis indicates day trace axis denotes fraction files modified day created modified window 
files window newly created modified 
average maximum files modified day modified days 
locality file system access verifies usefulness file store expect small fraction approximately local file system space adequate maintain copies modified file versions 
delta versions server addition client modifications delta version storage requires enhanced file retention file garbage collection policies backup server 
example nave server discard files delta files recalled 
files deltas encode lost backup storage pool 
file retention policies describe require additional metadata resolve dependencies delta file corresponding file 
backup server accepts retains files backup clients see 
files available restoration clients backed duration residence server 
files available restoration active files 
typical file retention policy hold versions file 
file retention policies may far complex turns bearing analysis consequent requirements backup servers 
concern existence deletion policies adsm server files server active finite number backup epochs 
reconstruct version file client backup server server delta encoding file client restore delta encoding corresponding file 
constraint modified retention policy dictates backup server retain files active files delta encoded 
words file deleted backup server active files file deleted 
relationship easily translates dependency digraph dependencies represented directed edges files nodes 
digraph encode dependent files need retained garbage collect files referring delta versions deleted 
version chain storage scheme may store delta file delta depends file backup server may store stores delta file representation 
event delta depend delta encoding delta see 
dependency digraphs delta chains branch cycles 
furthermore node digraph inbound edge outbound edge 
example restore file backup server needs keep delta encoding delta needs able construct file depends delta encoding retain encoding delta files requires reconstruct obvious dependency digraph reconstruct file node backup server retain files nodes reachable node reconstructed 
version jumping version chains version digraphs branch 
node version digraph may multiple incoming edges file may common file deltas see 
dependency digraphs version jumping simple delta chain 
jumping version chain 
dependency graphs garbage collection server deletion policies 
delta chains acyclic 
results directly delta files generated strict temporal order file delta file previous backup epoch 
digraphs acyclic implicitly solve dependency problem local information 
decide node available deletion traversing dependency digraph 
method works acyclic digraphs 
node dependency digraph file maintain pointer file counter 
pointer file indicates dependency delta encoded version points file uncompressed file value pointer 
counter stores number inbound edges node garbage collection 
node knowledge files depend dependent files exist 
backing delta file require client transmit file identifier identifier file 
store new delta file adsm server store name file dependent initialize counter zero 
update metadata referenced file incrementing counter 
metadata fields modified backup server information retain dependent files guarantee files active files available 
phase deletion storing delta files backup server needs retain files longer active 
modify deletion system place files states active files inactive dependent files inactive independent files 
inactive dependent files files longer restored policy criterion deletion met need retained active delta versions depend 
inactive independent files files suitable removal storage restored active delta files depend 
add piece metadata activity bit file backed server 
file received server stored usual activity bit set 
file marked active 
backup server implements deletion policies usual 
file retention policy indicates file longer restored clear file activity bit deleting 
state inactive 
clearing activity bit phase deletion 
files depend newly inactive file may removed storage second phase 
marking file inactive may result files independent 
newly independent file garbage collected pointer delta file 
rules govern file deletion ffl file referring deltas counter equals zero delete file 
ffl deleting delta file decrement counter file garbage collect file appropriate 
counting file pointers activity bits correctly implement reachability dependence relationship 
phase deletion technique operates locally traversing implicit dependency digraph consequently incurs little execution time overhead 
backup server traverses digraph restoring files 
follows dependency pointers determine set files required restore delta version question 
delta storage transmission time transmit files server directly proportional amount data sent 
delta backup restore system amount data related manner delta files generated 
develop analysis compare version jumping storage method storing delta files version version incremental changes 
show version jumping pays small compression penalty file system backup compared optimal linear delta chains 
exchange lost compression version jumping allows delta file rebuilt accesses tertiary storage 
version storage problem backup restore differs due special storage requirements distributed nature application 
adsm stores files multiple potentially slow media devices versions file readily available 
unavailability design considerations shape methods storing delta versions 
backup system stores files tape robot reconstructing file server may load separate tape delta access 
access tape may require seconds 
consequently multiple tape motions intolerable 
version jumping design guarantees accesses backing store needed rebuild delta file 
minimize server load performing differencing tasks client 
server processes requests clients system attempted run compression algorithms location quickly processor bound achieve poor data throughput 
client side differencing generate delta files client transmit server stored unaltered 
client differencing server incurs additional processor overhead 
linear delta chains serializability lack concurrency file systems result file having single preceeding single version 
linear sequence versions forms history modifications file call version chain 
develop notation delta storage analyze linear version chain stored traditional methods 
linear delta chains compact version storage scheme inter version modification smallest differencing consecutive versions 
optimality linear delta chains basis compare compression version jumping scheme 
denote uncompressed th version file difference versions indicated delta file delta considered differentially compressed encoding respect restored inverse differencing operation applied delta indicate differencing operation ffi delta inverse differencing reconstruction operation ffi gamma delta convention created modification gamma versions linear version chain versions adjacent obey property gamma intermediate version obeys property analysis consider linear sequence versions file continues indefinitely gamma traditional way store version chain series deltas adjacent versions store difference files delta 
produces delta chain delta delta gamma delta system reconstruct arbitrary version algorithm apply inverse differencing algorithm recursively intermediate versions relation compactly expressed recurrence 
represents contents th version file recurrent file version 
rebuilding ffi gamma delta gamma gamma time required restore version depends time restore intermediate versions 
general restoration time grows linearly number intermediate versions 
system retains multiple versions cost restoring remote version quickly 
reverse delta chains version control systems solve problem long delta chains reverse delta chain storage 
reverse delta chain keeps version file uncompressed 
version chain stored set backward deltas 
applications versions accessed far frequently older versions cost restoring old version intermediate versions offset low probability version requested 
seen linear delta chains fail provide acceptable performance delta storage see 
design constraints client side differencing tape accesses delta restore eliminate reverse delta chains 
show examining steps taken reverse delta system transmit version backup server 
point server stores reverse delta chain form delta delta delta vn vn gamma vn order backup new version file vn client generates difference file delta vn vn transmits difference server 
delta file server needs store 
needs generate store delta vn vn receiving delta vn vn server apply difference vn create vn run differencing algorithm create delta vn vn update single version reverse delta chain server store new files recall old file perform differencing reconstruction operations 
reverse delta chains fail meet design criteria implement minimal server processor load reconstruction minimum number participating files 
version jumping delta chains solution version storage implements call jumping deltas 
design uses minimum number files reconstruction performs differencing backup client 
version jumping system server stores versions modified forward delta chain occasional file delta 
chain looks delta delta delta gamma delta storing sequence files allows version reconstructed accessing files version chain 
performing delta compression backup client files transmitted server may stored directly additional manipulation 
immediate storage server limits processor overhead associated client session optimizes backup server 
obvious concern methods expects compression degrade difference non adjacent versions versions delta increases gamma increases 
compression degrade version distance gamma increases require occasional file limit maximum version distance 
raises question optimal number versions files 
performance analysis analyze storage transmission cost backing files version jumping policy 
know version jumping far outperforms version storage methods restore requires files accessed tertiary storage restore delta file 
showing compression loss version jumping small compared linear delta chains optimal storage method delta compression conclude version jumping superior policy 
analysis transmission time server storage identical backup server immediately stores files file jv denote size file 
files dimensional streams bytes synonymous length including deltas receives transmission time direct proportion amount data sent 
choose examine storage ease understanding contents backup server time analysis draw transmission times 
version jumping chains consider set versions adjacent versions modified symbols 
parameter ff represents compressibility adjacent versions 
ideal differencing algorithm create delta file delta maximum size symbols encoded delta file replace existing symbols add data file reasonable encodings mark deleted symbols 
compression achieved version gamma delta jv considering relative compressibility new versions size deltas delta file large size new version ranges size jv ff jv consequently worst case compression occurs modified symbols replace existing symbols jv jv worst case occurs file stays size 
versions maximum modified symbols versions modified symbols 
invoking union bound number modified symbols versions modified symbols assuming worst case compression 
occurs changed symbols versions disjoint versions size 
generalizing argument intermediate versions express worst case size jumping delta vn having defined size arbitrary delta determine storage required store linear set versions jumping delta technique jv delta jv ff interested determining optimal number jumping deltas taken files 
minimizing average cost storing version function number versions files 
average cost storing arbitrary version jv gamma ffn ffn gamma ff delta function minimum respect ff gamma ff ff storage cost number intermediate versions alpha alpha alpha average storage cost units jv number intermediate versions compressibility alpha number intermediate versions minimum 
version transmission storage cost worst case parameterized compression ff 
equation expresses worst case version storage cost consequently version transmission cost keeping delta files version jumping 
value ff optimal number jumping deltas uncompressed versions minimum equation 
give closed form solution minimum equation 
displays version storage cost parameterized ff minimum family curves function ff 
see large values version jumping provides poor compression version distance increases compression degrades expected 
optimal number versions depending compressibility version jumping performs reasonably 
number transmitted versions exceeds number storage cost minimum see equation system best decision transmit file delta encoding start new version jumping sequence 
analysis worst case compression bound 
practice expect achieve better compression version version changes completely disjoint files grow shrink size 
expect detect minimum storage transmission curve analytically ff constant 
backup client implements version jumping monitors size delta files compared corresponding uncompressed files 
average compression total bytes transmitted files total bytes uncompressed files stops decreasing compression degraded past minimum similar curve equation 
point client transmits new uncompressed file start new jumping version chain 
minimum local policy heuristic detecting minimum 
general files differ version distance increases heuristic detect global minimum 
linear delta chains having developed expression worst case version storage cost version jumping see linear delta chains 
recall linear delta chains suitable backup restore see provide bound best possible compression performance version storage architecture 
version jumping provides constant time reconstruction version 
realize efficient file restore trade small fraction potential compression 
quantify loss compression respect optimally compressing linear delta chains 
bound compression degradation deriving expression version storage cost linear delta chain comparing equation 
limited loss compression version jumping offset decreased restore time conclude version jumping superior policy backup restore 
facts nature delta storage backup restore apply analysis 
backup restore storage system retain file order able reconstruct versions 
additionally backing store holds bounded number file system backups 
number backup versions retained parameter say file backing store retain uncompressed version file gamma deltas uncompressed version 
storage cost number intermediate versions version jumping linear delta chain ff storage cost number intermediate versions version jumping linear delta chain ff relative version storage transmission cost units jv version jumping equation compared delta chaining equation 
derive expression amount storage linear delta chain 
minimal delta chain files contains file size jv gamma delta files size gamma 
assumptions version version modifications section total storage required version linear delta chain jv delta gamma jv gamma ff average storage required version jv gamma ff compare relative file cost storing versions linear delta chain version storage cost version jumping 
experimental results chose ff ff low high value compressibility file system data 
note version jumping delta chain storage curves nearly identical small values large values compression version jumping degrades curves diverge 
larger values restore time delta chains grows linearly larger number versions see 
addition asymptotic growth restore function linear chains require multiple accesses slow media devices compounds restore problem 
number intermediate versions stored grows restore cost quickly renders linear version chain storage intolerable 
delta chains version jumping number intermediate versions need kept small 
version jumping desirable pick largest value equal minimum value storage function see equation 
linear delta chains kept small file restore times reasonable restore time grows size versions retrieving files generally requires access slow tape devices 
small values version jumping superior policy compresses nearly requires tape accesses restore file 
fortunately backup restore applications generally require versions file stored time 
organization retains daily backups week weekly backups month considered aggressive backup policy 
configuration valued 
majority configurations take value 
applications may exist require versions expense storage storage management combined data older consequently pertinent tends limit number versions kept backup system 
operational jumping delta backup system perform better worst case analysis worst case factors realized file system data 
particular modifications version version completely disjoint versions file change size 
consequently conclude system maintain deltas files analysis specifies 
worst case analysis allow assert viability version jumping system 
worst case bounds plausible application delta backup system improves bounds providing viable backup architecture 
maintaining file store allows version modifications stored small fraction file system space large files presents concern may consume significant storage space file store 
believe merit considering block file storage schemes combined block file storing digital signatures compactly copy representation large files files ejected file store 
store choose copy blocks files 
allow modified blocks changed file duplicated store 
may mitigate large file problem prevents differencing algorithm detecting changes multi block files block aligned 
store choose save files files store blocks large files 
combined scheme heuristically address large file block alignment issues 
save storage large files file blocks uniquely identified digital signatures 
greatly reduces storage cost permits delta files calculated block granularity 
version jumping technique allows delta files restored accesses backup server storage pool 
generally means tapes loaded requiring seconds 
backup server collocate delta files files tape access files loading single tape 
collocation delta files provide significant performance gain file restore require extra tape motions files backed migrated different storage location 
delta file compression modified adsm send compact encodings versioned data reducing network transmission time server storage cost 
architecture version jumping method storing delta files backup server delta files generated common file 
shown version jumping far outperforms previous methods file system restore requires accesses server store rebuild delta files 
time version jumping pays small compression penalties generating delta files file system backup 
previous methods efficient restore examined determined fit problems requirements require delta files available simultaneously 
methods delta chains may require accesses backing store versions backup server 
file may reside physically distinct media access devices may slow previous methods failed meet special needs delta backup 
conclude version jumping practical efficient way limit restore time making small sacrifices compression 
modifications backup client server help support delta backup 
described system client maintains store files delta files may generated transmission storage 
described enhanced file deletion garbage collection policies backup server 
server determines files dependent inactive files retained order reconstruct active delta files 
acknowledgments indebted gray microsoft research review aid shepherding final form 
stockmeyer ajtai ibm almaden research center input helped shape architecture 
extend helped design implementation system pass menon golding support guidance instrumental continuing success research 
ajtai randal burns ronald fagin larry stockmeyer 
efficient differential compression binary sources 
ibm research preparation 
albert 
space efficient technique recording versions data 
software engineering journal june 
andrew black charles jr compact representation file versions preliminary report 
proceedings th international conference data engineering pages 
ieee 
randal burns darrell long 
linear time constant space differencing algorithm 
proceedings international performance computing communications conference feb tempe phoenix arizona usa february 
luis felipe cabrera robert rees stefan steiner michael wayne 
adsm multi platform scalable backup archive mass storage system 
ieee compcon san francisco ca march pages 
ieee 
connected importance backup small business 
www connected com html 
christopher fraser eugene myers 
editor revision control 
acm transactions programming languages systems april 
international business machines 
publication 
magnetic tape subsystem family 
jr generalized audit trail requirements concepts database applications 
ibm systems journal 
raymond lorie 
physical integrity large segmented database 
ibm transactions database systems march 
peter malcolm 
united states patent method operating data processing system 
intelligence quotient international february 
robert morris 
united states patent system method reducing storage requirements backup subsystems utilizing segmented compression differencing 
international business machines 
marc 
source code control system 
ieee transactions software engineering se december 
dennis guy lohman 
differential files application maintenance large databases 
acm transactions database systems september 
walter tichy 
rcs system version control 
software practice experience july 
jr sequential data processing design 
ibm systems journal march 
joost 
recovery techniques database systems 
acm computing surveys june 
product information 
www com product htm 
lin yu daniel rosenkrantz 
linear time scheme version reconstruction 
acm transactions programming languages systems may 
