conjunctive query containment constraint satisfaction kolaitis computer science department university california santa cruz santa cruz ca kolaitis cse ucsc edu moshe vardi department computer science rice university houston tx vardi cs rice edu conjunctive query containment recognized fundamental problem database query evaluation optimization 
time constraint satisfaction recognized fundamental problem arti cial intelligence 
conjunctive query containment constraint satisfaction common 
main conceptual contribution point despite di erent formulation conjunctive query containment constraint satisfaction essentially problem 
reason recast fundamental algebraic problem nite relational structures homomorphism formulated homomorphism problem uniform sense relational structures part input 
xing structure obtains non uniform problem nite relational structure homomorphism general non uniform tractability results 
natural ask tractable cases non uniform tractability results constraint satisfaction conjunctive query containment 
main technical contribution show cases tractable non uniform constraint satisfaction problems 
exhibit non uniform tractability results give rise polynomial time solvable cases constraint satisfaction conjunctive query containment 
examining tractable cases boolean constraint satisfaction problems show 
applied conjunctive query containment particular yields known tractable cases conjunctive query containment 
show tractability results constraint satisfaction problems expressed datalog programs preliminary version appeared proc 
th acm symp 
principles database systems june pp 

partially supported nsf ccr 
partially supported nsf ccr ccr 
url www cs rice edu vardi bounded number distinct variables 
provide new proof fact tractability results queries bounded treewidth connection rst order logic bounded number distinct variables 
conjunctive queries conspicuous presence theory practice database systems 
conjunctive queries constitute broad class frequently queries expressive power equivalent select join project queries relational algebra ahv ull 
reason algorithmic problems concerning conjunctive queries investigated depth 
particular containment recognized fairly early fundamental problem database query evaluation optimization 
conjunctive query containment essentially problem conjunctive query evaluation conjunctive query containment tool query optimization query equivalence reducible query containment 
chandra merlin cm studied computational complexity conjunctive query containment showed np complete problem 
years renewed interest study conjunctive query containment close relationship problem answering queries materialized views lmss 
emerged central problem integrating information heterogeneous sources area lately focus concentrated research orts see ull survey :10.1.1.127.3070
conjunctive query containment intractable full generality researchers embarked search tractable cases 
obtained imposing syntactic structural restrictions conjunctive queries serve input problem 
particular sar showed conjunctive query containment solved linear time database predicate occurs twice body chekuri rajaraman cr cr showed conjunctive query containment solved polynomial time query decomposition width available 
concept closely related studied concept treewidth graph see vl bod 
noted queries width precisely acyclic queries chekuri rajaraman results extend earlier yannakakis yan qian qia query evaluation containment acyclic queries 
starting pioneering montanari mon researchers arti cial intelligence investigated class combinatorial problems known problems csp 
input problem consists set variables set possible values variables set constraints variables question determine assignment values variables satis es constraints 
study constraint satisfaction occupies prominent place arti cial intelligence problems arise di erent areas modeled constraint satisfaction problems natural way areas include boolean satis ability temporal reasoning belief maintenance machine vision scheduling see dec kum mes tsa 
full generality constraint satisfaction np complete problem 
reason researchers arti cial intelligence pursued heuristics constraint satisfaction problems tractable cases obtained imposing restrictions constraints see mf dec pj 
conjunctive query constraint satisfaction common 
despite di erent formulation turns conjunctive query containment constraint satisfaction essentially problem 
reason recast fundamental algebraic problem nite relational structures homomorphism side conjunctive query containment known homomorphism canonical database associated query cm 
side constraint satisfaction perusal literature reveals problems studied viewed special cases homomorphism problem fv fv see 
noted researchers including bib dec pj observed tight connections constraint satisfaction problems certain problems relational databases 
particular gyssens jeavons cohen pointed set solutions constraint satisfaction problem coincides join certain relations extracted constraint satisfaction problem 
solving constraint satisfaction problems evaluating joins 
turn conjunctive query evaluation join valuation reducible ull 
chandra merlin cm showed conjunctive query evaluation conjunctive query containment equivalent problems provides di erent direct way establish tight connection conjunctive query containment constraint satisfaction 
fair say little interaction community pursues tractable cases conjunctive query containment community pursues tractable cases constraint satisfaction 
main goals connection conjunctive query containment constraint satisfaction explicit bring front stage enhance interaction database theory arti cial intelligence 
formulated homomorphism problem uniform sense relational structures part input 
xing structure obtains non uniform problem csp nite relational structure homomorphism past years researchers computational complexity studied non uniform problems attempt determine structures associated csp problem tractable intractable 
rst remarkable success front obtained schaefer sch computational complexity boolean csp problems structure boolean set universe 
schaefer established dichotomy theorem boolean csp problems 
speci cally identi ed classes boolean structures showed csp solvable polynomial time classes csp np complete cases 
note boolean csp problem viewed generalized satis ability problem 
particular schaefer sch dichotomy theorem provides coherent explanation computational complexity horn satis ability satis ability satis ability boolean satis ability problems 
hell ne set ril hn established dichotomy theorem csp problems undirected graph colorable csp solvable polynomial time csp np complete 
observe clique nodes csp colorability problem 
hell ne set ril dichotomy theorem generalizes results concerning computational complexity colorability problem 
motivated dichotomy results feder vardi fv raised question csp problem solvable polynomial time np complete 
settle question feder vardi fv able isolate conditions imply polynomial time solvability csp problems argued known polynomially solvable csp problems satisfy conditions 
rst condition asserts complement csp problem hand expressible datalog csp expressible datalog monotone problem condition covers known tractable cases horn satis ability satis ability colorability 
second condition group theoretic covers schaefer sch tractable class ane satis ability problems 
general non uniform tractability results 
tractability results problem collection non uniform csp problems necessarily yield tractable case uniform constraint satisfaction problem conjunctive query containment problem 
reason structures part input constraint satisfaction problem running times polynomial time algorithms csp may exponential size natural ask tractable cases non uniform csp problems give rise uniform tractable cases constraint satisfaction equivalently conjunctive query containment 
main technical contribution show cases tractable non uniform csp problems 
examining main tractable cases boolean csp problems considered schaefer sch 
cases csp corresponds satis ability problem horn satis ability problem dual horn satis ability problem ane satis ability problem 
cases uniform polynomial time algorithms obtained combining polynomial time algorithms detect membership cases build corresponding boolean formula apply polynomial time algorithm satis ability formulas 
pointed formula building algorithms satis ability horn satis ability dual horn satis ability worst case quadratic size turn yields cubic time algorithms corresponding uniform constraint satisfaction problems 
show better bound achieved designing algorithms skip formula building phase 
results boolean constraint satisfaction problems turn applications conjunctive query containment 
show conjunctive query containment problems binarized reduced boolean constraint satisfaction problems 
concrete application show sar tractable case conjunctive query containment derived technique 
focus connections datalog constraint satisfaction 
mentioned earlier feder vardi fv fv realized tractability nonuniform csp problems globally explained fact complement problems expressible datalog 
pebble game techniques introduced kv show non uniform tractability results long datalog programs bounded number distinct variables considered 
speci cally establish polynomial time algorithm testing homomorphism relational structures complement csp expressible datalog program distinct variables rule 
point obtained tractable cases constraint satisfaction problem homomorphism imposing restrictions structure result concerns known tractable case constraint satisfaction obtained imposing restrictions structure case structure bounded treewidth see section discussion earlier 
speci cally provide new proof fact polynomial time algorithm testing structure treewidth arbitrary structure homomorphism ect establish correspondence structures treewidth conjunctive queries expressible fo fragment rst order logic distinct variables apply polynomial time algorithm evaluating fo queries 
preliminaries formally ary conjunctive query query de nable positive existential rstorder formula having conjunction boolean connective formula form zm zm zm conjunction extensional database predicates 
free variables de formula called distinguished variables conjunctive query usually written rule head body zm 
example formula de nes conjunctive query rule database ary relation obtained evaluating query collection tuples satisfy query 
note need choose order free variables 
example chose order order acceptable 
example write query rule ary queries having tuple distinguished variables 
database say contained write conjunctive query containment problem asks conjunctive queries known conjunctive query containment reformulated evaluation problem homomorphism problem 
link problems canonical database associated database de ned follows 
variable occurring considered distinct element predicate body predicate distinguished variable distinct unary predicate occurring 
regards facts subgoal body gives rise tuple corresponding predicate distinguished variable fact example canonical database consists facts 
recall homomorphism relational structures vocabulary mapping predicate symbol vocabulary interpretations relationship conjunctive query containment conjunctive query evaluation homomorphisms provided theorem 
theorem cm ary conjunctive queries having tuple distinguished variables 
statements equivalent 
tuple distinguished variables homomorphism note database gives rise boolean conjunctive query body consists conjunction facts view elements databases existentially quanti ed variables 
turn possible show conjunctive query evaluation existence homomorphism nite relational structures reducible conjunctive query containment 
particular homomorphism focus constraint satisfaction problem 
mentioned earlier problem usually formulated question exists assignment possible values variables certain constraints satis ed 
consider alternate elegant formulation terms homomorphisms 
classes nite relational structures 
uniform constraint satisfaction problem csp decision problem structure structure homomorphism note de nition csp problem np 
write csp special uniform case csp class nite relational structures vocabulary consists single structure write csp csp fbg 
refer problems non uniform constraint satisfaction problems inputs just structures write csp special non uniform case csp class nite relational structures vocabulary note boolean structure universe csp generalized satis ability problem sense schaefer sch see gj lo page 
example csp equivalent positive sat 
csp may np complete problem 
interested identifying classes csp solvable polynomial time 
classes give rise tractable cases constraint satisfaction problem conjunctive query containment problem 
past years researchers computational complexity investigated csp problems discovered polynomial time cases 
general rule non uniform tractable results 
hard construct classes nite relational structures csp np complete non uniform csp problem solvable polynomial time 
example class nite cliques class nite undirected graphs 
clear csp np complete equivalent clique problem 
xed nite undirected graph determine constant number steps clique size example isolated np complete problems viewed way 
particular class nite paths csp equivalent hamiltonian path problem nite graph linear time algorithm csp 
negative results notwithstanding sequel establish interesting non uniform tractable cases give rise tractable cases constraint satisfaction conjunctive query containment 
boolean constraint satisfaction tractable cases schaefer studied computational complexity boolean csp problems established dichotomy sch 
speci cally identi ed classes boolean structures showed csp solvable polynomial time classes csp np complete cases 
classi cation terms de ning formulas 
ary boolean relation viewed set truth assignments propositional variables ary boolean relation propositional formula variables models 
call de ning formula say de nable schaefer showed boolean structure csp ptime cases holds 
relation contains tuple 
relation contains tuple 
relation horn de nable cnf formula positive literal clause 
relation dual horn de nable cnf formula negative literal clause 
relation de nable cnf formula 
relation ane de nable conjunction linear equations 
furthermore schaefer established classes csp np complete 
say boolean structure schaefer structure classes case csp solvable polynomial time 
call class schaefer structures schaefer class denoted sc 
main result section csp sc solvable polynomial time means schaefer tractability results completely 
rst step need show structures sc recognized polynomial time 
follows results dp sch 
theorem class sc recognizable polynomial time 
proof rst cases trivially recognizable 
schaefer showed boolean relation condition holds boolean operations applied tuples componentwise 
addition schaefer showed boolean relation ane condition holds dechter pearl dp showed boolean relation horn resp dual horn condition holds resp 
clearly conditions checked polynomial time 
say relation trivial schaefer relation covered rst cases schaefer classi cation say nontrivial schaefer relation covered interesting cases schaefer classi cation horn dual horn ane 
cases relation de nable formula certain syntactical structure 
step show nontrivial schaefer relation construct de ning formula polynomial time 
theorem polynomial algorithm constructs nontrivial schaefer relation de ning formula proof cases consider 
dechter pearl dp showed construct polynomial time horn dual horn 
remains deal cases ane 
ary relation 
cnf formula propositional variables fp models 
clause say satis es denoted models 
consider formula rj conjunction ranges clauses fp linear equation formula form false true 
precursors result see mck riv 
claim models consequently de ning formula clearly models 
conjunct satis es conjunct models models implies models 
clearly constructed time 

ary ane relation 
note linear formula false resp true viewed equation resp boolean eld 
rg 
linear equation satis ed corresponds boolean vector set vectors nullspace nr vector space solutions homogeneous linear equation system boolean eld viewed boolean jrj matrix note jrj jr 
fundamental theorem linear algebra dimension space nr min jrj 
gaussian elimination convert row echelon matrix polynomial time obtain basis nr size min jrj kw 
vector basis corresponds linear formula false true satis ed claim conjunction formulas constitutes de ning formula clearly models 
observed linear equation satis ed corresponds vector nr obtained linear combination basic vectors words consequence models prove main result section 
theorem csp sc solvable polynomial time 
proof suppose pair relational structures sc 
determine homomorphism theorem determine polynomial time tractable cases schaefer classi cation describes trivial schaefer structure homomorphism assume nontrivial schaefer structure 
ary relation corresponding relation interpretations relation symbol 
apply theorem construct recall formula fp view element propositional variable 
tuple formula obtained substituting 
note length 
claim homomorphism precisely satis able 
suppose consider truth assignment de ned element tuple choose speci tuple truth assignment de ned satis es formula satis es 
follows satis es conversely suppose truth assignment satis es de ne homomorphism element tuple choose speci tuple satis es truth assignment de ned satis es follows note conjunction horn clauses dual horn clauses clauses linear formulas depending type satis ability checked time linear length rst cases bb dg pap cubic length fourth case sch 
ane relation length de ning formula constructed bounded size contrast horn dual horn length proportional arity quite larger size complexity algorithm cubic cases 
possible skip formula building stage algorithm design direct algorithm essentially tests satis ability explicitly constructing 
theorem class horn dual horn structures 
csp solvable quadratic time 
proof rst describe algorithm horn case analogous algorithm works dual horn case 
ary horn relation 
take kg 
say satis es models 
determine homomorphism structure horn structure algorithm maintains set elements mapped 
initially empty 
tuple relation de ne fi 
algorithm repeatedly selects tuple relation adds satis es relation corresponds enlarged anymore homomorphism tuple relation tuple corresponding relation 
prove claim note element clearly mapped 
condition necessary 
see sucient consider homomorphism 
claim consider collection tuples 
know empty 
conjunction tuples 
horn relation closed conjunction see proof theorem 
done 

satis es means algorithm added case contradiction 
claim algorithm implemented run time jjajj 

naive implementation take time jjajj 
extended jjajj times extension takes time jjajj 
nd tuple requiring external loop tuples add satis es requiring internal loop tuples ecient implementation focus elements added 
preprocessing stage build linked lists link occurrences element added traverse list process tuples occur 
update scanning check triggers addition element 
occurrence element visited resulting running time jjajj 

implementation inspired linear time algorithms horn satis ability bb dg 
consider case 
linear time algorithm cnf formulas proceeds phases lp 
phase choose unassigned variable assign arbitrary truth value 
binary clauses formula propagate assignment 
assigned clause assigned clause assigned 
similarly assigned clause assigned clause assigned 
results variable assigned undo assignments phase try assign truth value 
attempts fail formula unsatis able 
rst second attempt successful proceed phase 
variable assigned truth value twice algorithm linear 
pair structures emulate algorithm 
variables elements clauses implied structure see proofs theorems 
algorithm proceeds phases 
phase choose unassigned element assign value 
structure propagate assignment 
suppose tuple relation tq set tuples corresponding relation suppose tq case know element assigned value propagation results element assigned undo assignments phase try assign value attempts fail homomorphism rst second attempt successful proceed phase 
note element assigned value twice propagating value requires scanning pairs tuples listing components tuple listing tuple requires preprocessing structures construct appropriate linked lists 
complexity algorithm jjajj 
jbj 
note size encoding jbj number tuples 
applications implications theorem conjunctive query containment 
rst sight applicability limited boolean constraint satisfaction problems correspond testing uses variables corresponding boolean values restricted 
critical observation instance constraint satisfaction problem converted small blow boolean constraint satisfaction problem encoding elements binary notation 
speci cally number elements encode element bit vector length dlog ne 
ary relation km ary boolean relation note needs ne bits encode elements essentially blow conversion 
replace element vector ha am consisting distinct copies relation yields km ary relation conversion blows size instance factor dlog ne jbj 
lemma homomorphism homomorphism proof assume elements suppose rst homomorphism element de ne th bit easy see homomorphism suppose homomorphism element de ne number binary notation hh easy see homomorphism refer process converting constraint satisfaction problem boolean problem 
application technique 
atom conjunctive query database predicate occurs twice body 
proposition sar testing atom conjunctive query contained conjunctive query done polynomial time 
proof lemma problem reduce testing existence homomorphism structure boolean structure relation tuples 
recall elements conversion increases arity relations factor dlog ne 
criterion see proof theorem relation 
theorem theorem test done time jjq jj 
log jjq jj jjq jj 
worth noting proof sar yields slightly better upper bound shown testing atom conjunctive query contained conjunctive query done time jjq jj jjq jj 
conclude section presenting examples provide additional evidence power 
example colorability graph consisting nodes single undirected edge 
easy see csp class colorable graphs tractable constraint satisfaction problem 
show known tractability result derived 
gives rise boolean structure structure cardinality ane set solutions true 
provides di erent explanations colorability solvable polynomial time 
example csp directed cycle nodes fa dg labeling 



obtain boolean structure clearly valid valid 
criteria proof theorem easily veri ed horn dual horn ane boolean relation 
instance horn resp 
dual horn componentwise resp 
rst tuples resp 
similarly componentwise majority rst tuples ane closed componentwise arbitrary triples alternatively seen ane observing set solutions system false true follows csp solvable polynomial time 
naturally seen directly observing csp colorability disguise 
homomorphisms compose colorable easy see homomorphism directed graph colorable hn 
pointed way carried may give rise schaefer structure di erent type 
speci cally claim labeling results boolean structure ane 
see consider labeling 



resulting boolean structure leave exercise reader verify criteria proof theorem horn dual horn ane 
datalog constraint satisfaction datalog finite variable logics datalog program nite set rules form atomic formula 
relational predicates occur heads rules intensional database predicates extensional database predicates 
designated goal program 
note may occur bodies rules datalog program recursive speci cation semantics obtained xed points monotone operators see ull 
datalog program de nes query set edb predicates returns value goal predicate 
query computable polynomial time bottom evaluation xed point program terminates polynomial number steps size see ull 
expressibility datalog sucient condition tractability query 
nite relational structure class structures write csp complement csp class structures homomorphism feder vardi fv provided unifying explanation tractability non uniform csp problems showing complement problems expressible datalog 
aim section obtain stronger uniform tractability results collections constraint satisfaction problems complements expressible datalog bounded number distinct variables 
positive integer datalog collection datalog programs body rule distinct variables head rule variables variables body may di erent variables head 
example query non colorability expressible datalog de nable goal predicate datalog program asserts cycle odd length exists known datalog viewed fragment xed point logic lfp see ch ahv 
turn class nite structures lfp subsumed nite variable nitary logic 


nitary logic arbitrary disjunctions conjunctions distinct variables see kv 
interested fragments 

suitable study datalog 

existential positive fragment 
variables collection formulas distinct variables obtained atomic formulas nitary disjunction nitary conjunction existential quanti cation 
query class nite structures xed vocabulary 
kv shown expressible datalog de nable 
kv shown expressible lfp xed point logic variables expressible 
matter fact proof adapted yield result optimal regards number distinct variables 
theorem positive integer 
datalog query expressible 
datalog 
follows self contained proof preceding theorem 
rst give precise de nitions concepts involved establish number intermediate results 
xed relational vocabulary 
write fo collection rst order formulas distinct variables 
write fo existential positive fragment fo collection rst order formulas distinct variables obtained atomic formulas disjunction conjunction existential quanti cation 
system rst order formulas nite sequence rst order formulas relation symbol arity vocabulary 
structure system gives rise operator sequences relations arity universe sequences relations universe arities 
precisely stages structure de ned induction simultaneously formula system positive relation symbols associated operator monotone arguments result sequence stages increasing component 
nite structure sequence stages converges nitely iterations positive integer sequence xed point operator smallest sequence relations see ahv 
call sequence xed point system denote 
usually interested entire sequence components instance component xed point logic lfp extension rst order logic formulas components systems positive rst order formulas 
lfp fragment lfp obtained components xed points systems positive fo formulas 
similarly lfp fragment lfp obtained xed points systems positive fo formulas 
chandra harel ch showed datalog expressive power existential fragment lfp 
precisely query expressible datalog lfp de nable 
fact datalog program simulated system positive fo formulas vice versa 
intuitively idb predicate gives rise fo formula disjunction positive existential formulas de ne bodies rules having idb predicate head 
resulting system fo formulas simulates datalog program step step say stage system corresponds stage bottom evaluation 
consequently prove theorem suces establish lfp 
amounts establishing system positive fo formulas component xed point system 
de nable 
sequel assume variables distinct variables logics fo 
lemma positive integer kg 
kg function query 
fo de nable query fo de nable nite structure sequence elements universe 
de nable query 
de nable 
proof show function kg 
kg formula fo resp 
formula fo resp 
structure sequence elements universe proof induction construction fo formulas resp 
formulas simultaneously functions 
formula formula rg 
kg function relation symbol arity atomic formula formula 
form formula 
form formula 
case disjunction handled similar manner 
assume formula form cases consider 
suppose rst 
desired formula formula 
suppose hand 
range 
kg 
kg function applying induction hypothesis function formula obtain formula fo structures sequences elements universe desired formula formula 
ready show lfp 
imply datalog 
theorem positive integers relation symbols vocabulary having arities system positive fo formulas vocabulary fs statements true system operator associated 
component stage de nable fo formula structures nite nite 
component xed point system de nable 
formula structures nite nite 
proof assume rst means ary relation symbol formula fo vocabulary fs induction simultaneously show component stage de nable formula fo claim obvious component stage de nable fo formula assume fo formulas de ne components stage means structure sequence elements universe consider components stage de ned occurrence relation symbol formulas system subformula form function kg 
kg 
relation symbol positive occurrences formulas system induction hypothesis repeatedly applying lemma function obtain formula fo formula obtained substituting subformula corresponding formula 
note formulas formula substitutions carried renaming variables introducing new variables 
formula fo formula de nes component stage consider case ary relation symbol vocabulary fo formula vocabulary ft obtained follows replace subformula formula replace 
straightforward induction simultaneously shows structure sequence elements universe structure fo formula de nes component stage formula formula 
fo formula de nes component stage component xed system de nable structures 
formula 
explained earlier theorem follows immediately preceding theorem 
corollary positive integer 
lfp 
consequently datalog 
pointed class nite structures datalog properly contained 
express non computable queries 
datalog pebble games constraint satisfaction describe certain combinatorial games play important role sequel 
relational structures common relational vocabulary 
existential pebble game played players spoiler duplicator 
spoiler places pebbles time elements move spoiler duplicator responds placing pebble element pebbles placed spoiler wins conditions holds elements th move spoiler duplicator 
correspondence 
mapping say exists 
correspondence 
mapping homomorphism substructure universe fa substructure universe fb conditions holds spoiler removes pebbles game resumes 
say duplicator wins existential pebble game strategy allows continue playing forever spoiler win round game 
formal de nition concept families partial homomorphisms forth property see kv details 
tuple elements tuple elements say duplicator wins existential pebble game winning con guration duplicator duplicator win game th pebble spoiler placed th pebble duplicator placed result kv shows expressibility 
characterized terms existential pebble games 
theorem positive integer ary query class nite structures 
statements equivalent 
expressible 

structures tuples elements duplicator wins existential pebble game 
corollary positive integer boolean query class nite structures 
statements equivalent 
expressible 

structures duplicator wins existential pebble game disjoint copies vocabulary relation symbol vocabulary contains relation symbol arity write vocabulary fd new unary relation symbols 
vocabulary encode pair structures single structure de ned follows universe union universes interpretation respectively universe respectively interpretation relation symbol respectively interpretation relation symbol respectively 
encoding possible formally view queries pairs structures queries single structures 
result concerns computational descriptive complexity existential pebble games 
theorem relational vocabulary positive integer 

sentence xed point logic lfp vocabulary expresses query structures spoiler win existential pebble 
result polynomial time algorithm nite structures determines spoiler wins existential pebble game 
nite structure datalog program expresses query structure spoiler win existential pebble game 
proof quanti er free formula vocabulary asserting correspondence 
mapping mapping homomorphism substructure induced vocabulary substructure induced vocabulary speci cally disjunction formulas ary relation symbol ary tuple indices set kg 
ary relation symbol positive rst order formula vocabulary ftg easy verify structures tuples elements respectively statements equivalent 


spoiler wins existential pebble game 
sentence 

logic lfp 
consequently structure structure statements equivalent 

spoiler wins existential pebble game lfp expressible query computable polynomial time follows polynomial time algorithm nite structures tells spoiler wins existential pebble game note positive rst order formula involves existential quanti ers interpreted elements universal quanti ers interpreted elements consequently xed nite structure universal quanti ers replaced nitary conjunctions elements transformed datalog program expresses query nite structure spoiler win existential pebble game 
follows describe datalog program detail 
goal ary predicate tuple elements tuple introduce ary relation symbol rules rule ary relation symbol ary tuple rule rule new variable note body rule variables 
goal predicate rule necessary notation machinery establish main results section 
theorem establishes connection expressibility csp datalog existential pebble game 
closely related somewhat precise connection established fv 
theorem positive integer nite relational structure class nite relational structures statements equivalent 

csp expressible datalog 
csp expressible 

csp fa spoiler wins existential pebble game bg 
proof implication follows theorem 
show assume 
sentence de nes csp nite relational structure csp spoiler wins existential pebble game duplicator wins game theorem means homomorphism contradiction 
conversely spoiler wins existential pebble game csp 
homomorphism give duplicator winning strategy existential pebble game spoiler places pebble element duplicator responds placing corresponding pebble element implication follows theorem 
combining theorems obtain uniform tractability result classes constraint satisfaction problems expressible datalog 
theorem positive integer class nite relational structures fb csp expressible uniform constraint satisfaction problem csp solvable polynomial time 
running time algorithm maximum sizes input structures note open problem class fb csp expressible recursive 
contrast schaefer class sc basis tractability result theorem recursive theorem 
remarks concerning results section order 

feder vardi fv showed non uniform csp problem certain datalog program complement csp expressible datalog expresses 
preceding theorems give alternative proof result reveal take datalog program expresses query spoiler win existential pebble game 

illustrate application theorem consider ary horn boolean structure easy verify complement csp expressible datalog 
consequently theorem yields polynomial time algorithm csp class nite structures class ary horn boolean structures 
bounded treewidth constraint satisfaction point tractable cases uniform constraint satisfaction problem csp imposing restrictions class section exhibit tractable cases csp obtained imposing restrictions class consider concept treewidth relational structure concept introduced feder vardi fv generalizes concept treewidth graph see vl bod 
tree decomposition nite relational structure labeled tree conditions hold 
node labeled non empty subset universe 
relation tuple node label contains fa 
set nodes labels include forms subtree width tree decomposition maximum cardinality label node minus 
say structure treewidth smallest positive integer tree decomposition width alternative way de ne treewidth structure terms treewidth gaifman graph graph elements universe nodes edge nodes corresponding elements appear tuple relations call treewidth gaifman graph gaifman treewidth show concepts coincide 
lemma tree decomposition structure tree decomposition tree gaifman graph proof easy see tree decomposition tree decomposition gaifman graph suppose tree decomposition gaifman graph consider tuple relation elements fa form clique gaifman graph lemma df node fa contained label follows tree decomposition class nite relational structures treewidth bodlaender bod showed linear time algorithm tests graph treewidth follows polynomialtime algorithm tests nite relational structure treewidth words class recognizable polynomial time 
feder vardi fv showed nite relational structure polynomialtime algorithm non uniform constraint satisfaction problem csp 
consequence facts xed structure class csp known expressible existential monadic second order logic fv furthermore membership classes graphs de nable monadic second order logic decidable polynomial time graphs bounded tree width known courcelle theorem see df 
fact shown fre non uniform tractability results holds uniformly see dp 
provide new proof uniform tractability connection rst order logic bounded number distinct variables 
nite relational structure 
theorem accompanied remarks follows existence homomorphism equivalent true boolean conjunctive query body consist conjunction facts show nite relational structure treewidth conjunctive query expressible fo fo formula equivalent time polynomial size lemma structure treewidth expressible fo proof key idea underlying proof structures bounded treewidth parse trees df chapter constructed polynomial time tree decompositions 
parse trees constructed structures structures distinguished nodes labeled structured combined form larger structures 
example structures assume xed underlying vocabulary glued obtain structure disjoint union identifying nodes labeled general way combining graphs de ned follows 
consist structure domain injective mappings kg view ary operator cardinality jdj structures 
structures construct manner 
take disjoint union identify th distinguished node node distinguished nodes result distinguished nodes labels nodes erased 
note glue operator essence binary operator structure elements empty relations identity function set kg 
shown df polynomial time algorithm converts tree decomposition structure elements treewidth parse tree expression terms nite set unary binary operators cardinality starting constant structure 
conversely parse tree describes structure treewidth 
structure viewed ary conjunctive query body consists conjunction facts non distinguished variables existentially quanti ed distinguished elements viewed free variables 
show induction structure expressed parse tree operators cardinality starting expressed fo fact prove stronger claim expressed fo tuples free variables arbitrary tuple distinct variables fx claim clearly holds query variable conjunctive query empty body 
consider expression ary operator cardinality suppose constructed fo conjunctive queries queries respectively 
take domain fx fx recall injective mapping kg induction hypothesis assume tuple free 
assume form resp permutation resp 
observe implicit existential quanti er jdj elements 
express proof note homomorphism structure structure homomorphisms distinguished element labeled 
words get homomorphism need nd homomorphisms meet compatibility conditions required mappings fo queries give required homomorphisms compatibility di erent homomorphisms guaranteed labeling distinct elements mapped identically variable 
fragment fo general fragment conjunctive queries allows negations disjunctions 
consider fragment fo allows negative formulas disjunctions 
fragment expressive power conjunctive queries 
shown fragment fo express precisely queries structure treewidth direction note translation described proof lemma yields formula fo direction note conjunction connective corresponds glueing operation described proof lemma existential quanti cation corresponds operation adding new node connected nodes making ith distinguished node easily expressed unary operation cardinality 
formula fo construct parse tree structure induction syntax 
relationship treewidth number variables tight 
derive main result section 
theorem positive integer class nite relational structures treewidth class nite relational structures 
uniform constraint satisfaction problem csp solvable polynomial time 
proof showed lemma nite relational structure treewidth fo formula equivalent time polynomial size case checking existence homomorphism reduces evaluation fo query structure shown var fo polynomial time combined complexity implies csp solvable polynomial time 
precise complexity analysis csp provided gls shown problem complete logcfl class decision problems logspace reducible context free language 
note way de ne treewidth structure terms incidence graph cr 
incidence graph bipartite graph tuples relations nodes part elements universe nodes part edge node node tuple element occurs call treewidth incidence graph incidence treewidth tree decomposition convert tree decomposition incidence graph follows 
graph structure relation tuple node label contains fa simply add node incidence graph label easy see tree decomposition 
treewidth incidence treewidth 
direction convert tree decomposition incidence graph tree decomposition replacing tuple label node set elements fa incidence treewidth treewidth maximal arity relation example gap notions consider structure single tuple 
easy see treewidth gaifman graph clique treewidth incidence graph tree 
mentioned chekuri cr showed uniform constraint satisfaction problem csp solvable polynomial time class structures chekuri studied conjunctive query containment problem explains term 
cr vocabularies bounded arities considered result extended cr general vocabularies 
showed incidence treewidth structure provides strict upper bound query width showing tree decomposition incidence graph called query decomposition 
note property having treewidth tested linear time bod property having np complete gls 
polynomial tractability csp follows results cr 
gottlob leone scarcello gls de ne notion width called hypertree width 
showed structure provides strict upper bound hypertree width class structures hypertree width class csp eciently recognizable 
discussion shows treewidth structure arity widest relation precisely number distinct elements occuring tuple minus 
desirable decrease arity relations done encoding structures binary structures structures binary relations 
refer binary encoding structure binary 
reduction binary dual graph representation dp 
see bb experimental results concerning reduction reduction called hidden variable translation 
vocabulary binary contains binary relation symbol pair necessarily distinct relations symbols pair argument positions respectively 
domain binary set tuples occurring relations relation contains pair th element th element identical 
note statements true structure binary relation contains tuples relation relation relation relation relation refer re exive symmetric transitive closure relations 
lemma homomorphism homomorphism binary binary 
proof assume homomorphism tuple de ne componentwise 
easy see homomorphism binary binary suppose contain pair binary elements identical implies 
follows pair relation binary 
conversely suppose homomorphism binary binary 
th element tuple relation th element 
de ne easy see homomorphism provided de ned 
suppose th element tuple relation relation binary 
relation binary implies th element tuple 
worth noting binary necessary encode coincidence relations suces put tuples re exive symmetric transitive closure encodes coincidence relations 
example relation relation necessary store relation dicult prove lemma holds 
reason optimization minimize treewidth binary desirable minimize number tuples binary 
possible show optimized encoding acyclic join queries ahv ull encoded structures bounded treewidth 
optimization easily done acyclic instances dicult general 
interesting know complexity task 
formally consider problem opt xed constant 
relational structure decide exist suitable encoding binary encoding guarantees coincidence relations see treewidth 
opt decidable polynomial time 
class general class bounded treewidth graphs class bounded graphs 
shown graph treewidth bounded 
class graphs bounded treewidth bounded 
courcelle cmr showed class ectively bounded monadic second order property polynomial 
follows csp ptime bounded 
hand clique observed class csp np complete 
result constraint satisfaction bounded treewidth structures case bounded structures assuming di erent np 
follows connection bounded treewidth rst order logic bounded number distinct variables extend bounded 
concluding remarks brought center stage close connection conjunctive query containment constraint satisfaction 
showed tractable cases non uniform csp problems yield tractable cases uniform constraint satisfaction conjunctive query containment 
past years group researchers pursued tractable cases constraint satisfaction csp investigating class functions relations structures closed jc see pj survey 
fv fv preliminary investigation carried connection expressibility csp problems datalog closure relations certain functions 
forthcoming elaborate connection delineate relationship approaches 

georg gottlob leonid libkin janos werner nutt useful discussions 
particular georg gottlob helped clarify relationship treewidth incidence treewidth section 
grateful referees useful comments 
ahv abiteboul hull vianu 
foundations databases 
addison wesley 
bb beeri bernstein 
computational problems related design normal form relational schemas 
acm trans 
database systems 
bb bacchus beek 
conversion non binary binary constraint satisfaction problems 
bib bibel 
constraint satisfaction deductive viewpoint 
arti cial intelligence 
bod bodlaender 
linear time algorithm nding tree decompositions small treewidth 
proc 
th acm symp 
theory computing pages 
ch chandra harel 
horn clause queries generalizations 
journal logic programming 
cm chandra merlin 
optimal implementation conjunctive queries relational databases 
proc 
th acm symp 
theory computing pages 
cmr courcelle 
linear time solvable optimization problems certain structured graph families 
graph theoretic concepts computer science wg lecture notes computer science pages 
springer verlag 
courcelle 
upper bounds clique width graphs 
technical report university bordeaux 
cr chekuri rajaraman 
conjunctive query containment revisited 
ph kolaitis afrati editors database theory icdt volume lecture notes computer science pages 
springer verlag 
cr chekuri 
conjunctive query containment revisited 
technical report stanford university november 
dec dechter 
decomposing relation tree binary relations 
journal computer system sciences 
dec dechter 
constraint networks 
shapiro editor encyclopedia arti cial intelligence pages 
wiley new york 
df downey fellows 
parametrized complexity 
springer verlag 
dg dowling gallier 
linear time algorithms testing satis ability propositional horn formulae 
journal logic programming 
dp dechter pearl 
tree clustering constraint networks 
arti cial intelligence pages 
dp dechter pearl 
structure identi cation relational data 
arti cial intelligence 
fre freuder 
complexity tree structured constraint satisfaction problems 
proc 
aaai pages 
fv feder vardi 
monotone monadic snp constraint satisfaction 
proc 
th acm symp 
theory computing pages 
fv feder vardi 
computational structure monotone monadic snp constraint satisfaction study datalog group theory 
siam computing 
gaifman 
local nonlocal properties 
stern editor logic colloquium pages 
north holland 
gj garey johnson 
computers intractability guide theory np completeness 
freeman 
gyssens jeavons cohen 
decomposition constraint satisfaction problems database techniques 
arti cial intelligence 
gls gottlob leone scarcello 
complexity acyclic conjunctive queries 
proc 
th ieee symp 
foundation computer science pages 
gls gottlob leone scarcello 
hypertree decompositions tractable queries 
proc 
th acm symp 
principles database systems pages 
hn hell ne set ril 
complexity coloring 
journal combinatorial theory series 
jc jeavons cohen 
algebraic characterization tractable constraints 

du li editors proceedings annual international conference computing combinatorics cocoon pages 
springerverlag 
jeavons cohen gyssens 
unifying framework tractable constraints 
montanari rossi editors proceedings st international conference principles practice constraint programming cp pages 
springer verlag 
jeavons cohen gyssens 
test tractability 
freuder editor proceedings nd international conference principles practice constraint programming cp pages 
springer verlag 
jeavons 
algebraic structure combinatorial problems 
theoretical computer science 
appear 
kum kumar 
algorithms constraint satisfaction problems 
ai magazine 
kv ph 
kolaitis vardi 
nitary logic laws 
information computation 
special issue selections fifth annual ieee symposium logic computer science 
kv ph 
kolaitis vardi 
expressive power datalog tools case study 
journal computer system sciences august 
special issue selections ninth annual acm sigact symposium principles database systems pods nashville tn usa april 
kv ph kolaitis vardi 
expressive power variable con ned logics 
proceedings th annual ieee symposium logic computer science lics pages 
kw kaye wilson 
linear algebra 
oxford univ pr 
lmss levy mendelzon sagiv srivastava 
answering queries views 
proc 
th acm symp 
principles database systems pages 
lp lewis papadimitriou 
elements theory computation 
prentice hall 
mck mckinsey 
decision problem classes sentence quanti ers 
journal symbolic logic 
mes meseguer 
constraint satisfaction problems overview 

mf mackworth freuder 
complexity constraint satisfaction revisited 
arti cial intelligence 
mon montanari 
networks constraints fundamental properties application picture processing 
information science 
pap papadimitriou 
computational complexity 
addison wesley publishing 
pj pearson jeavons 
survey tractable constraint satisfaction problems 
technical report csd tr royal holloway university london 
qia qian 
query folding 
proc 
th int conf 
data engineering pages 
riv rival 
maximal sublattices nite distributive lattices 
proc 
ams 
sagiv ullman 
answering queries templates binding patterns 
proc 
th acm symp 
principles database systems pages 
sar 
subtree elimination algorithms deductive databases 
phd thesis department computer science stanford university 
sch schaefer 
complexity satis ability problems 
proc 
th acm symp 
theory computing pages 
tsa tsang 
foundations constraint satisfaction 
academic press 
ull ullman 
database knowledge base systems volumes ii 
computer science press 
ull ullman :10.1.1.127.3070
information integration logical views 
ph kolaitis afrati editors database theory icdt volume lecture notes computer science pages 
springer verlag 
var vardi 
complexity bounded variable queries 
proc 
th acm symp 
principles database systems pages 
vl van leeuwen 
graph algorithms 
van leeuwen editor handbook theoretical computer science algorithms complexity chapter pages 
elsevier amsterdam 
yan yannakakis 
node deletion problems bipartite graphs 
siam journal computing 

