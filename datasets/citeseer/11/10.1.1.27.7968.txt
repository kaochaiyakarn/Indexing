beckert menzel reif schmitt integrating automated interactive theorem proving 
automated interactive theorem proving main directions field deduction 
chapters book belong focusing theory methods systems 
reflects fact long time research computer aided reasoning divided directions driven forward different communities 
groups offer powerful tools different kinds tasks different solutions leading different performance application profiles 
important examples acl kaufmann moore hol gordon imps farmer isabelle paulson kiv reif see chapter nqthm boyer moore pvs owre interactive tactical theorem proving community komet bibel otter wos protein baumgartner furbach setheo ta beckert automated theorem proving community :10.1.1.49.8833
chapter project integrate interactive automated theorem proving 
aim combine advantages paradigms 
focus particular application domain deduction purpose software verification 
reported facts may valid domains 
report integration concepts experimental results prototype implementation 
automatic provers fast majority problems solve 
increasing complexity response time increases dramatically 
certain problem size automated theorem provers produce reasonable results exceptional cases 
interactive theorem provers hand large case studies 
small problems require user interactions particularly combinatorial exhaustive search performed 
concerning software verification typical proof tasks arising gap methods applied naively dramatic 
mod tex fl kluwer academic publishers 
printed netherlands 
essentially reasons phenomenon 
theories occurring verification projects large hundreds axioms 
second majority axioms equality 
theories handled automatic provers 
techniques relieve problems 
investigate conceptual integration interactive automated theorem proving software verification goes loose coupling proof systems 
concrete application domain turned enormous influence integration concepts 
implemented prototype system combining advantages paradigms 
large applications integrated system incorporates proof engineering capabilities interactive system time eliminates user interactions goals solved efficient combinatorial proof search embodied automated prover 
report integration concept encountered problems experimental results prototype implementation 
furthermore current directions ongoing research described 
technical basis integration systems kiv reif ta beckert developed research groups authors ulm karlsruhe 
kiv karlsruhe interactive verifier advanced verification system applied large realistic case studies academia industry years 
ta tableau automated theorem prover automated tableau prover full order logic equality 
require normal forms easily extensible 
experimented particular systems conceptual results carry provers 
statistics case studies kiv estimate application domain user interactions needed interactive prover saved principle order theorem prover 
current provers far goal general prepared deduction large software specifications large search spaces typical domain specific reasoning 
section describe problems sections solutions came far 
decisions experimental evidence 
put lot effort sophisticated verification case study correct compilation prolog programs warren machine code chapter iii 
benchmark 
parts repeated evaluate success integration concepts see section 
realistic applications software verification proof attempts fail go 
specifications programs mod tex integrated theorem proving user defined lemmas typically erroneous 
correct versions usually obtained number corrections failed proof attempts 
question produce powerful theorem provers integrate proving error correction 
current research related topics discussed section 
different approaches combining interactive methods automated ones 
relation approach subject section 
section draw 

identifying problems integration theorem proving interactive system typically proceeds simplifying goals backward reasoning proof rules tactics 
proof rules may applied automatically usually tactics corresponding main line argument proof supplied interactively 
allow proof engineer keep track details proof system response time application tactics short 
case software verification initial goals contain programs 
tactics reduce goals order lemmas ultimately reduce goal order formula 
usually order goals require interaction program goals 
ideal automated theorem prover relieve proof engineer lot interaction 
scenario considered ta tactic prove order goals exploiting capability fast combinatorial search 
suitable interface implemented ta called interactively kiv heuristics 
termination tactic guaranteed simply imposing time limit usually seconds minute 
loosely integrated version started experiment automatic theorem prover solve order theorems encountered software verification 
expected automatic theorem prover initially meet requirements software verification 
virtually relevant theorem proved 
analysis proof attempts identified number reasons expected unexpected 
important ones interface automated theorem provers usually support separate input axioms goal 
forced prove combined goal axioms imply theorem universally quantified axioms theorem 
theorem provers preprocessing formulas speed proof search 
ta links potentially unifiable terms mod tex computed theorem provers formulas converted clauses 
preprocessing axioms ta takes sec 
holds provers tested see chapter iii 
preprocessing axioms proof attempt obviously unacceptable interactive theorem proving 
correctness management automated provers record assumptions needed proof 
information necessary interactive theorem prover rely strict bottom proving 
kiv example correctness management prevents cycles dependencies lemmas invalidates minimal set previous goals specifications changed 
different logics automated theorem provers support formulas order logic sorts otter clauses setheo interactive theorem provers support expressive logics higher order logic hol isabelle pvs type theory nuprl constable see chapter 
inductive theorems theorems proved inductively axioms automated theorem provers including ta capable finding inductive proofs 
large theories automated provers tuned prove theorems small theories small signature 
axioms relevant prove goal 
contrast theories software verification usually contain hundreds axioms relevant finding particular proof 
axioms contribute search space 
domain characteristics application domain software verification specifications structured specific properties sorted theories equality reasoning important 
theorems lemmas operational meaning interactive theorem prover equations oriented rewrite rules 
automated theorem provers exploit properties 
items technical problems requiring mere changes interface 
preprocessing axioms done ta user integrated system selects specification 
separate command initiating proof attempts refers preprocessed axioms naming specification occur 
embedding automated prover mod tex integrated theorem proving correctness management done converting proofs ta proofs sequent calculus kiv 
handle problem different logics suitable subset formulas treated interactive system selected general translated order logic 
automatic provers support clauses order formulas transformed standard encoding techniques ones described plaisted greenbaum 
case solution simpler logic kiv extension sorted order logic program formulas dynamic logic ta supports full sorted order logic 
discussion issues solved higher order logic polymorphism currying problems arising identification boolean terms formulas see archer 
presence inductive theorems fundamental problem 
mitigated adding previously derived inductive theorems lemmas 
hand reduces number theorems require inductive proofs experiments theorems see chapter iii 
hand roughly potentially useful necessary lemmas axioms adds considerably problem large theories 
leaves problems handling large theories exploiting domain characteristics software verification 
tackled sections 
number potentially relevant axioms proving goal minimized exploiting specification structure section 
measures taken exploit characteristics software verification 
section deals conversion proofs ta kiv 

reduction axiom set specifications kiv built elementary order theories usual operations algebraic specification union enrichment parameterization 
semantics class models loose semantics 
reachability constraints nat generated succ define induction principles 
typical specifications formally describe software systems contain axioms 
structuring operations arbitrarily formal specifications software systems 
enrich spec hierarchy persistent 
property means model spec extended model enriched specification 
hierarchy persistency mod tex checked syntactically usually guaranteed modular implementation specification reif 
hierarchy persistency exploited define simple syntactic criteria eliminating irrelevant axioms longer passed automated theorem prover 
enables theorem proving large theories described chapter iii 
reduction technique identify axioms question described greater detail 
sufficient example merely axioms minimal specification signature contains theorem 

equality handling 
incremental equality reasoning kiv specifications real word problems heavy equality 
essential automated deduction system integrated interactive prover employ efficient equality reasoning techniques 
part ta special equality background reasoner uses completion method beckert solving unification problems extracted tableau branches 
equality reasoner efficient just including equality axioms 
addition mere efficiency tableau foreground reasoner equality reasoner interaction plays critical role combined efficiency 
difficult problem decide useful call equality reasoner time allow computations 
heuristics hand avoid calling equality reasoner early late 
problem aggravated framework integration fact equalities branch needed close computing completion available equalities expensive quite useless 
difficulties partially avoided incremental methods equality reasoning beckert pape 
algorithms futile try solve unification problem allow store results equality reasoner computations reuse call additional equalities 
case doubt equality reasoner called early running risk doing useless computations 
addition incremental reasoner reuse data different extensions set equalities 
fortunately due inherently incremental nature ta algorithm solving unification problems possible design implement mod tex integrated theorem proving incremental version rewrite rules unification problems extracted new literals branch simply added data background reasoner 
previously information computed equality reasoner ta reused background reasoner called exhausted tableau branches expansion rule applicable meant redundant equalities simple theorems proved called time branching rule applied usually lead early calls repeated computation information 
ta avoids problems 
incremental equality reasoner may called time disjunctive rule applied risking useless computations 

generating precedence orders simplifier rules interactive theorem provers kiv simplification key issue 
simplifier rules theorems data structure marked proof engineer simplifier 
way determined syntactic shape 
common simplifier rules conditional rewrite rules form intended rewriting instances instances provable 
fact simplifier rules operational meaning interactive prover ways guide proof search automated systems 
example automatic generation useful precedence orders function symbols order provided manually arbitrary default order 
orders refinements calculi theorem proving results general interest 
ta precedence order orient equations lexicographic path order 
equations occurring proof ordered smaller search space 
attempt generate order rewrite rules kiv define top function symbols occur left right side rewrite rule respectively provided attempt generate total order information topological sort typically fails due number conflicts cons car cdr append usual list operations append cons cons append nil cons car append cdr append rule suggests accordance intuition append cons second suggests contrary 
avoid conflicts excludes rewrite rules form embedded mod tex 
case second rule order generation 
tested resulting algorithm specifications existing case studies kiv having approximately rewrite rules 
result function symbols topologically sorted conflicting pair rewrite rules 
additional restrictions order extracted considering differing function symbols rewrite rules top ones additional conflicts arose 
maximal flexibility kiv passes partial order conflict information function symbol generated 
partial order total equality handling module ta see section 
considerations show rewrite rules interactive theorem proving simplify terms relative user intuition translated directly information automated theorem proving 
experiments showed suitable simplifier rules similar algorithm obtains analogous result predicate symbols provided equality symbol considered special 

restricting search space 
problem specific orders calculi incorporate search space restrictions atom literal orders relatively investigated domain resolution theory 
order employ restrictions ta build order refinements tableau calculi pape 
fact research partially motivated integration paradigms discussed article 
ordered tableaux constitute refinement free variable tableaux fitting 
number advantages particularly important context software verification defined unrestricted order formulas contrast mere clausal normal form compatible important refinement called regularity letz 
possible extend ordering restrictions theory reasoning pape 
ordered tableaux proof confluent partial tableau proof extended complete proof provided theorem proven valid 
property essential prerequisite automated search counter examples see section 
problem specific knowledge choose mod tex integrated theorem proving order restricts search space importantly rearranges favorably 
point difficult exploit general kiv ta integration take advantage information computed reduce number axioms section provide meaningful simplification orders equality handling section 
hierarchy specifications implicit hierarchy function symbols specification defines partial order function predicate symbols occurring problem 
order naturally extended order oe binary irreflexive transitive relation atoms stable substitutions 
ordered tableaux characterized restricting branch extension follows formula extend tableau branch iff oe maximal connection connection literal occurs oe maximally ii oe maximal connection input formula connection literals occur oe maximally 
particular order 
terms atoms iff ii variables subset variables automatically computed prevents literals unrelated hierarchies maximal consequence formula maximal connection branch literals hierarchy unreachable maximal literals perfectly reflect hierarchy problem completeness calculus guarantees proof proof search influenced favorably 

pragmatic connectives explained automated part integrated system prove sub tasks order nature 
context software verification order formulas appear different situations axioms specified theory rewrite lemmas subgoals proof theorem involving programs 
contexts carries pragmatics concerning way formulas proofs 
basic task enable automated prover pragmatic information possible 
solution add new logical connectives logic automated tableau prover 
expansion disjunctive formula causes splitting current branch resulting branches chosen new branch focus 
choice heavily affects search space 
consider example formula expansion generates sub branches mod tex say leaves respectively 
suppose different instantiations allow close instantiations allow close case search instantiation closes branches done searching instantiation allows close checking allows close obviously smaller search space spanned way 
general information allows decide branch closed disjunctive connectives treated standard way default left argument handled theorem provers take relative size account may may beneficial 
hand specific knowledge role proof allow rearrange optimize search space 
typical candidates implications intended exclude exceptions 
consider formula property 
states property holding natural numbers 
assume formula occurs branch focus property complex formula 
expanding implication standard treatment puts new branch leaf focus 
substitutions fn fn closes natural numbers enumerated backtracking 
better examine branch containing property check instantiation close equal 
added version implication ta logic called declarative semantics usual implication carries pragmatic information branch associated part closed 
integrated system control specific distinction logically equivalent connectives kiv ta hidden user protecting confused operational semantics 

converting proofs usually automated interactive theorem provers quite different calculi supporting machine oriented proof search respectively intuition human user 
deal gap chose dual approach switching necessary interactive part system sequent calculus automated part system free variable tableaux 
doing exploit full power methods 
resulting question kind information system parts exchange operate construct proof 
static information depending signature axioms lemmas mod tex integrated theorem proving specification structure depending formula prove 
dynamically exchanged information depending current proof task request prove formula responded timed 
short response extremely valuable save user time effort spent boring potentially long proof task 
reasons informative response providing proof assumptions 
important reason correctness management kiv automatically guarantees absence cycles lemma dependencies automatically invalidates proofs affected modification lemma 
integrate proofs ta management kiv needs just 
second reason requires complete proof response replay mechanism kiv able rebuild branches remaining valid invalidated proof tree 
proofs ta fully kiv proof trees 
embedding ta proofs kiv calculus possible visualize proof single framework enabling user understand going requiring deal different calculi 
ta proofs translated kiv proofs 
uses tableau calculus second sequent calculus main task translation tableaux sequent proofs 
difficult correspondence tableaux sequent proofs provided consider appropriate instances calculi consisting corresponding sets rules 
case correspond toone designed different purposes automated search interaction 
demand different features 
interactive proof construction rules great degree non determinism arbitrary term guessed time simple 
hand context automated search important reduction search space requires small degree freedom postponing decisions removing non determinism possible 
typical example difference cut rule interactive calculus enable case distinctions arbitrary formulas 
rule feasible automatic proof procedure 
ta tableau calculus offers kind restricted cut called lemma generation handles disjunctions adding negation extension extension 
transformation easy lemma generation simply simulated cuts 
interesting different handling instantiations 
kiv uses ground calculus system user guess term instance quantified variable applying rule 
mod tex handling quantified variables rule easy skolem constants suffice 
hand ta uses free variable calculus 
rules introduce free variables representing terms guessed 
consequence rules introduce new skolem terms containing free variables formula 
older versions rules fitting correspond rules simple ground calculus 
research field tableaux yielded improvements 
modified rule proven allow exponential shorter proofs extreme cases beckert 
decided provide ground rule corresponds rule simple description soundness proof turned difficult 
improvement free variable tableaux usage universal variables 
special free variables arbitrarily instances assigned see chapter 
counterpart simple ground calculus 
bridge gap proofs universal variables transformed ground proofs collecting instances assigned universal variable building ground copies affected subproof instance 
crucial point analysis handling dependencies free variable instances 

evaluation wam case study evaluate project results demonstrate improvements integrated system chose verify selected compilation steps prolog warren machine wam major case study 
algorithms mathematical analysis compiler provided allowing concentrate development formal specification theorem proving 
analysis schmitt associated correctness problems showed verification compilation step poses tasks challenging kiv ta lead synergy effects 
important challenge interactive prover fact due complexity correctness proof developed incremental process failed proof attempts error correction re proof evolutionary verification 
automated prover important aspect large number standard data types lists sets tuples required large number order theorems proved 
theorems benchmarks evaluate improvement integrated system 
content case study described chapter iii solution problem finding large invariants 
just mention mod tex integrated theorem proving verification revealed formal gaps analysis 
operational semantics wam code formalized non deterministic allowing nontermination programs terminate prolog semantics 
giving explanation just show example 
prolog program consisting clauses fail asked query behavior may terminate may run forever 
took man months verify correctness theorems including required lemmas 
final proofs main theorems dynamic logic required interactions user 
algebraic specifications contained axioms order lemmas 
relatively easy prove compared complexity main theorems usually attempt state lemmas correct 
additional interactions required 
interactions potentially saved ideal automated theorem prover remaining interactions involve induction 
reality tests theorems top level specification showed ta able prove giving ratio 
improvements integrated system implemented far integrated system able prove theorems fully automatic 
significant gain productivity ta achieved reduction set axioms left relevant axioms proof 

current directions research described far current research concentrates deepening integration automated interactive proving paradigm exploiting domain specifics software verification 
aspects described 
tableau rewriting form frequently kiv specifications 
typical examples definitions formula specify meaning predicate symbol 

carry pragmatic information 
proofs simplifier solely deduce instance instance definitions usually equivalences form replace implication general simplifier 
mod tex premise known part pragmatics simplifier contrapositive needed proofs 
note formulas formal implications concept simplifier complementary operator pragmatics completely different 
consequently search space organized differently 
strong relationship equality reduction rules improvement hope gain similar reduction rules rewriting terms compared equalities unrestricted way 
extending application domain considered automated theorem provers goals occurring lemmas explicit subgoals interactive correctness proofs software systems 
lot order theorems hidden goals containing programs proved automated systems 
typical subgoals kind gamma test applicability conditional rewrite rule gamma check disjunctive goals containing programs order validity gamma check program conditional logical complement validity current context allows omit branch gamma determine reachability recursive call expressed order formula 
proof tasks kiv uses general simplifier possibly involving user interaction 
tasks suitable trying ta require induction 
compared order theorems proved different characteristic goals theorems 
new characteristic lot axioms usable lemmas irrelevant proof goals contain lot subformulas irrelevant 
routine application ta new problems solved 
proof engineering high degree automation important criterion efficient verification large software systems existence powerful proof engineering tools 
allow incremental development proofs cope failures resulting corrections changes 
major components gamma methods analysis proofs gamma methods construct counter examples gamma methods reuse proofs proof attempts 
mod tex integrated theorem proving exists method kiv reuse proofs program changes reif 
necessary correct order formulas incremental development coupling invariant wam case study 
major efforts improve possibilities analyze reuse proofs changed firstorder formulas 
computing counter examples non valid problems order problems deriving program verification constitute provable formulas 
reasons range bugs object program specification erroneous tactical decisions supplied earlier user weak induction hypothesis 
extending application automated prover discussed involves non theorems 
extremely desirable feature automated theorem prover provide counter examples non valid formulas 
general course falsifying interpretations non valid order formulas computable limited context program verification additional observations far rarely named explicitly simplify situation considerably program contains bugs meet specification certain inputs 
critical inputs obtained finite counter examples 
practice counter examples tend small need search large instantiations 
exploit features specifically problems derived program verification 
counter examples correspond initial models finitely generated known set function symbols constants 
variables sorted restricts number models 
hand needs generate models relative equality theory 

approaches integration approaches described literature common aim strengthen interactive proving methods tools adding automatic methods tools able handle relevant amount subtasks 
apart order logic theorem proving important reasoning methods integrated interactive frameworks computer algebra harrison model checking joyce seger owre decision procedures boyer moore 
typically applied particular domain 
computer algebra incorporated proof systems solving problems mod tex physical origin 
applications different problems occurring software verification focused chapter 
model checking context hardware verification 
method applied verify software restricted sub systems adequately represented finite states 
amount potential applications growing due new techniques abstraction problems arising software verification infinite state 
domain decision procedures relevant listed methods 
meant flexible fixed theories 
crucial question datastructures decidable apart unchanging experience different case studies specifications modified 
course decidable theories regularly fragments natural numbers integers decision procedures help 
computer algebra model checking decision procedures differ approach incorporated algorithms handle decidable problems 
correctness management problem keeping consistent underlying theories changed corrected continually relevant approaches handle fixed standard theories linear arithmetic calculus boolean algebra 
contrast problem impairing correctness interactive prover believing results connected systems issue approaches mentioned particular computer algebra 
comparison issue significant joint provers 
relevant area automated theorem proving attempts aggregate automated provers common homogeneous user interface ilf conceptual issues see chapter ii experiments extend existing automated provers interactive component hutter 
aware attempts integrate automated theorem proving techniques interactive systems far homogeneous approach implements automated theorem prover implementation language interactive system hol system schneider 
automated theorem prover faust uses variant sequent calculus 
sequent calculus proofs resulting application converted back hol proofs 
approach resulted speed ups reduced necessary interactions 
prototypical implementation faust compete results efficient implementations automated theorem provers 
heterogeneous approach combines different existing mod tex integrated theorem proving vers previously combine hol system resolution prover 
described archer concentrates selection sub language higher order logic suitable resolution prover proof visualization 
direct comparison heterogeneous homogeneous approach 
combination higher order logic proof checker lambda automatic order logic prover 
second extension lambda rules suitable firstorder theorem proving heuristics quantifier instantiation 
mention integration interactive type theory prover see chapter equality prover discount strecker current progress combining kiv vse system hutter nuprl komet 
experiments vse system higher order logic languages algorithms denoted functional style 
contrast logical framework dynamic logic deals imperative programs combined order formulas 
difference main purpose system 
designed formalizing mathematics specialized verify modular programs structured algebraic specifications structured order theories 
differs heavily making application domain especially reducing search space automatic prover see reduction axiom set generating precedence orders issues 

began project integrating interactive automatic theorem provers strong feeling working strategic promising topic 
expected benefit linking theorem proving programs provided sufficient motivation set extra effort 

anticipated identify problems particular theorem proving systems arise attempt combine theorem proving paradigms 
fact name typical trouble spots difficulties automated provers cope large sets axioms mismatch order automated theorem proving higher order interactive provers pragmatic information guide proof search internal communication interactive automated prover 
substantial progress finding solutions significance special situation dealing 
mod tex experience observing literature focus conferences see new research area emerging called integrated theorem proving 
archer fink yang linking theorem provers hol pm proof manager 
gordon eds higher order logic theorem proving applications th international workshop hug 
theorems algorithms interface isabelle maple 
levelt ed international symposium symbolic algebraic computation 
pp 

baumgartner furbach protein prover theory extension interface 
bundy ed proc 
th cade nancy france vol 
lncs 
pp 

beckert completion method mixed universal rigid unification 
bundy ed proc 
th cade nancy france vol 
lncs 
pp 

beckert sulzmann tableau theorem prover version 
eds proc 
th cade new brunswick nj usa vol 
lncs 
pp 

beckert schmitt rule free variable semantic tableaux 
gottlob eds proc 
rd kurt colloquium brno czech republic 
pp 

beckert pape incremental theory reasoning methods semantic tableaux 
moscato eds proc 
th tableaux palermo italy vol 
lncs 
pp 

bibel komet 
bundy ed proc 
th cade nancy france vol 
lncs 
pp 

wam definition compiler correctness 
eds logic programming formal methods practical applications 
north holland pp 

boyer moore integrating decision procedures heuristic theorem provers case study linear arithmetic 
machine intelligence 
oxford university press 
boyer moore computational logic 
academic press 
order automation higher order logic theorem proving 
melham eds higher order logic theorem proving applications th international workshop vol 
lncs 
pp 

constable allen bromley cleaveland cremer harper howe knoblock mendler sasaki mod tex integrated theorem proving smith implementing mathematics nuprl proof development system 
prentice hall 
walther wolf integrating logical function ilf 
system description humboldt universitt zu berlin 
farmer guttman imps update description 
eds proc 
th cade new brunswick nj usa 
pp 

resolution methods decision problem vol 
lncs 
springer verlag 
fitting order logic automated theorem proving 
springer new york edition 
second edition appeared 
letz mayr schumann setheo developments system 
bundy ed proc 
th cade nancy france vol 
lncs 
pp 

gordon hol proof generating system higher order logic 
birtwistle subrahmanyam eds vlsi specification synthesis 
kluwer academic publishers 
ordered tableaux 
logic computation 
pape ordered tableaux extensions applications 
galmiche ed proc 
international conference automated reasoning analytic tableaux related methods pont france vol 
lncs 
pp 

harrison extending hol theorem prover computer algebra system reason reals 
joyce 
seger eds higher order logic theorem proving applications th international workshop hug vancouver canada vol 
lncs 
pp 

hutter reif stephan wolpers vse development method way engineer high assurance software systems 
ed gi itg formale fr verteilte systeme 
hutter generation 
ed proc 
th cade new brunswick nj usa vol 
lncs 
pp 

joyce seger hol voss system model checking inside general purpose theorem prover 
joyce 
seger eds higher order logic theorem proving applications th international workshop hug 
pp 

kaufmann moore design goals acl 
technical report computational logic letz schumann bibel setheo theorem prover 
automated reasoning 
owre rajan rushby shankar srivas pvs combining specification proof checking model checking 
alur mod tex henzinger eds computer aided verification cav vol 
lncs 
new brunswick nj pp 

owre rushby shankar pvs prototype verification system 
kapur ed proc 
th cade saratoga springs ny usa vol 
lncs 
saratoga ny pp 

paulson isabelle generic theorem prover 
springer lncs 
plaisted greenbaum structure preserving clause form translation 
journal symbolic computation 
reif kiv approach software verification 
broy eds methods languages tools construction correct software final report lncs 
springer verlag 
reif proving system correctness kiv 
proc 
th cade australia vol 
lncs 
pp 

reif reuse proofs software verification 
ed proc 
fst tcs bombay india vol 
lncs 
pp 

reasoning state machines wam case study 
journal universal computer science 
available url tu graz ac 
schmitt proving wam compiler correctness 
bericht universitt karlsruhe fr informatik 
schneider kumar integrating order automatic prover hol environment 
higher order logic theorem proving applications th international workshop hug 

diplomarbeit fr informatik universitt karlsruhe 
strecker integrating equality prover software development system type theory 
brewka habel nebel eds proc 
ki vol 
lncs 
pp 

gaede rock version 
eds proc 
th cade new brunswick nj usa vol 
lncs 
pp 

wos overbeek lusk boyle automated reasoning applications nd ed 
mcgraw hill 
mod tex 
