impact lambda calculus logic computer science henk barendregt computing science institute nijmegen university netherlands february important contributions church logic invention lambda calculus 
genesis theory major areas application representation computations resulting functional programming languages hand representation reasoning resulting systems computer mathematics hand 

persons provided help various ways 
erik barendsen jon barwise johan van benthem andreas blass olivier danvy wil dekkers marko van eekelen sol feferman andrzej filinski jan kuper pierre lescanne hans robert maron rinus plasmeijer randy pollack rose richard shore rick statman simon thompson 
partial support came european hcm project typed lambda calculus esprit working group types dutch nwo project 

written honor church great invention lambda calculus 
best way think give description genesis impact areas mathematical logic representation computations reasoning 
cases technological applications emerged 
notion computability formalized terms definability numerals represented lambda calculus 
church thesis stating correct formalization notion computability years seriously challenged 
advances lambda calculus computations data types trees syntactic structures parsing done representing data types directly lambda terms coding godel numbers represented numerals 
resulted efficient representation functions defined data types 
notion lambda definability conceptually basis discipline functional programming 
progress area construction efficient compilers functional languages capturing interactive programs text editors functional programming paradigm 
representation proofs church original goals construct formal system foundations mathematics having system functions set logical notions 
resulting system turned inconsistent program abandoned 
church separated consistent subsystem called lambda calculus concentrated computability turned consistent ways represent logical notions typed untyped lambda calculus foundation mathematics obtained 
resulting systems developed systems computer mathematics programs interactive development automated verification mathematical proofs 
restrict attention applications lambda calculus fields mathematical logic computer science 
applications forms grammars studied linguistics montague see gamut categorial grammars see benthem treated 
telling story letter chosen denote function abstraction 
russell whitehead principia mathematica notation function 
church originally intended notation 
position hat top placed front resulting 
changed 
preliminaries short subsection preliminaries readers familiar lambda calculus 
information see barendregt referred chapters barendregt sections untyped lambda calculus simply typed lambda calculus 
topics outside chapters sections needed explicitly mentioned 
untyped lambda calculus 
definition 
sets variables terms lambda calculus defined syntax 
means mention necessary order warrant unique readability thinks trees strings generated 
var var term var term term var term syntactic category var collection variables 
examples variables letters range arbitrary variables 
syntactic category term collection lambda terms notation notation 
mn stands mn 
ii dually stands 
examples lambda terms xy xy xy zy xy zy xy ww yx term form mn called application intended interpretation function applied argument term form church considerably helped students early development lambda calculus notably kleene see kleene rosser 
important influences came curry curry 
called abstraction intended interpretation function assigns value 
interpretation notion function taken intensional algorithm 
scott succeeded give lambda calculus extensional interpretation interpreting lambda terms continuous functions topological space having space continuous functions retract 
lambda term xy xz variable said occur bound variable occurs free variable 
variable occurs free occurrence bound second occurrence variable 
statement stands syntactic equality modulo renaming bound variables 
xy yy free occurrence lhs bound rhs 
lambda calculus study set modulo called fi convertibility congruence relation fi axiomatized fi stands result substituting free variables notation free variables allowed bound substitution example yy yy 
changing names bound variables may obtain yy yy yy notion fi convertibility equivalence relation compatible syntactic operations application abstraction 
fi holds arbitrary contexts 
notion fi reduction compatible reflexive transitive relation 
fi axiomatized 
fi difference fi conversion fi 
fi direction involved reduction conversion bidirectional 
reason notational convention introduced understood realizing 
xyz yz xy 
fi term called fi normal form fi nf part form part called fi redex term said fi normal form fi normal form fi 
theorem church rosser theorem 

fi 
fi 
fi follows church rosser theorem term fi normal form 
fi nf fi 
fi fi fi nf redexes contract 
simply typed lambda calculus simple types defined syntax tvar ff tvar type tvar type type ff fi fl type variables types 
set types denoted tt 
statement form tt called subject statement 
basis set statements variables subjects 
gamma delta range bases 
complicated versions typed lambda calculus basis needs ordered called context unfortunately different notion name notion context defined earlier 
definition 
say basis gamma prove notation gamma derived production system 
gamma gamma gamma gamma gamma mn gamma gamma 
example 
ii xy version simply typed lambda calculus implicit types abstraction studied curry 
church variant explicit types abstractions introduced 
theory rule introducing abstractions gamma gamma essential difference approaches explicit case unique type term easily 
implicit case types unique 
simply typed lambda calculus types reconstructed implicit case complicated systems case 
inductive types recursion inductive types convenient represent data theories programs type systems allow axiomatic called inductive types 
simple example 
nat zero succ nat definition axiomatically zero nat succ nat nat succ succ zero nat 
inductive types come natural primitive recursive operators 
example type assuming nat may define nat follows 
zero succ depends uniformly dependence explicit write postulate 
zero succ operator represent primitive recursive functions 
presence higher types represent ackermann function 
formalizing notion computable church introduced formal theory call notion function 
system intended foundation mathematics 
predicates represented characteristic functions 
axioms deal logical notions 
system turned inconsistent shown church students kleene rosser tour de force argument involving techniques needed prove godel incompleteness theorem church isolated untyped lambda calculus system deleting part dealing logic keeping essence part dealing functions 
system proved consistent church rosser showed confluence fi reduction 
curry wanted build foundation mathematics functions case form combinators mention free bound variables paradox system similar aim easy derive see appendix church introduced notion lambda definability functions order capture notion computability elementary functions addition multiplication proved lambda definable 
function simple predecessor pred pred lambda definability remained open problem 
knowledge tempting explain follows 
lambda calculus conceived untyped theory typeable terms intuitive 
functions addition multiplication definable typeable terms schwichtenberg statman characterized lambda definable functions simply typed lambda calculus predecessor 
may kleene find way lambda define predecessor function untyped lambda calculus appropriate data type pairs integers auxiliary device 
kleene described solution gas removal wisdom teeth 
kleene showed solution teacher church remarked intuitively computable functions lambda definable 
fact lambda definability coincide intuitive computability 
years occasion robin gandy th birthday believe heard kleene say able say moment discovering lambda define predecessor function got idea church thesis 
church 
kleene gave important evidence church thesis showing lambda definable functions coincide recursive ones 
independently church alternative formalization terms turing machines notion computable turing 
turing proved notions lambda definability turing computability equivalent enlarging credibility church thesis 
church thesis plausible proved stated classical mathematical terms refers undefined notion intuitive computability 
hand church thesis refuted 
function godel just series lectures princeton kleene rosser 
consistent theories functions foundations mathematics described von neumann simplified robinson 
similar aim theories kuper 
theories paradoxes avoided having partial application 
feferman beeson discuss formal theories partial application aim constructive foundations come close lambda calculus partial combinatory algebras 
remember story stating church started problem trying show sequence betti numbers algebraic variety computable 
succeed enterprise came proposal capture notion intuitive computability 
able verify story 
readers confirm refute kindly requested inform author 
intuitively computable demonstrably lambda definable church thesis false 
years happened 
failure find counterexample argument favor church thesis 
think fair say logicians believe church thesis 
may wonder church thesis completely academic question 
clear realizing skolem introduced class primitive recursive functions time thought coincide intuitively computable ones 
ackermann showed function intuitively computable primitive recursive 
see gandy arguments favor church thesis kreisel ones casting doubts 
church thesis negative computability results function shown lambda definable turing computable church thesis state intuitively computable 
church turing gave examples undecidable predicates ones non computable characteristic functions questions lambda term normal form normalization problem machine program input terminates halting problem respectively 
concluded provability arithmetic undecidable 
fact undecidability mathematical problems established translating halting problem problem 
famous example result hilbert tenth problem unsolvable 
worth mentioning intuitionistic mathematics say heyting arithmetic ha precisely formulate church thesis formal statement contrast situation classical theory 
statement called ct states th partial recursive function input terminates value kleene computation predicate value extracting function see kleene 
form ct states decidable predicate excluded middle holds recursive characteristic function 
see troelstra formal consequences models counter models extension ct 
computing lambda calculi prototype programming languages 
case imperative programming languages examples untyped machine code assembler basic typed algol pascal systems lambda calculi exist untyped typed versions 
differences various lambda calculi 
lambda calculus introduced church untyped calculus abstraction allowed occurs free variables nowadays lambda calculus refers calculus developed influence curry allowed occur typed versions lambda calculus 
elementary versions simply typed lambda calculus 
version due curry implicit types 
simply typed lambda calculus explicit types introduced church system inspired theory types russell whitehead simplified ramsey 
order distinction versions simply typed decidable diophantine equation solution integers 
lambda calculus version explicit types called church version implicit types curry version 
difference church version explicitly types variable bound lambda curry version 
example church version similarly curry system term see information typed lambda calculi 
particularly interesting second higher order calculi introduced girard names system system applications proof theory calculi dependent types introduced de bruijn proof verification 

computing data types subsection explain possible represent data types direct manner various lambda calculi 
lambda definability introduced functions set natural numbers 
resulting mathematical theory computation recursion theory domains input output treated second class citizens coding natural numbers 
practical computer science algorithms directly defined data types trees lists 
coding data types numbers treat class citizens coding directly lambda terms preserving structure 
lambda calculus strong emphasized bohm bohm gross 
result efficient representation algorithms data types types represented numbers 
methodology perfected different ways bohm berarducci bohm berarducci bohm 
representation way typed papers essentially stronger way typed 
methods papers treating labeled trees example 
inductive data type labeled trees defined syntax 
tree ffl leaf nat tree tree nat succ nat see label bud ffl leaf number written 
typical tree leaf leaf ffl 
tree mirror image look follows 
ffl ffl operation trees defined recursion 
example action mirroring defined mir ffl ffl mir leaf leaf mir mir mir example mir leaf leaf ffl ffl leaf leaf show different ways trees represented lambda terms operations mir objects lambda definable 
method bohm berarducci 
resulting data objects functions represented lambda terms typeable second order lambda calculus see girard 

definition 
variables mnemonics bud leaf plus 
define tree term term collection untyped lambda terms follows 
ffl leaf fx church numeral representing lambda term 
ii define tree term follows 
blp 
proposition 
define blp ln blp blp blp ffl 
ii leaf 
iii 
proof 
trivial 
ii leaf blp leaf blp ln iii similarly blp 
proposition states trees considered representable lambda terms way constructors ffl leaf lambda definable 
fact lambda terms involved typed 
nice connection terms proofs second order logic leivant 
show iterative functions trees mir lambda definable 

proposition iteration 
lambda terms exists lambda term variables fb proof 
take wa known primitive recursive functions obtained iterative functions 
way coding finite sequence lambda terms lambda term hm zm components recovered 
take hm iu 
corollary primitive recursion 
lambda terms exists lambda term hb ht ht proof 
define auxiliary function ht hti 
proposition defined iteration 
hp hp take tu trick kleene 
method bohm berarducci bohm represent data types 
consider example labeled trees 

definition 
define tree term follows 
ffl eu leaf eu ne eu basic constructors labeled trees definable eu ne eu ne eu 
proposition 
lambda terms exists term fb nf xy proof 
try hhx ii tuple triple 
fb hx hx hx hhx ii provided hxi 
similarly find second representation essentially typed lambda calculi typeable terms normalizing 
follows consequence result similar proposition 
xy xy represent true false respectively 
writing bool fi bool usual behavior conditional obtained 
represent natural numbers data type style second representation immediately get lambda definable functions closed 
suppose lambda defined exists lambda term zero 
hx succ fi write hx apply proposition formulated inductively defined type num 
hx represent succ represents successor function zero test zero lambda definable proposition 
define partial recursive functions terms involved typed normalizing system 
self interpretation lambda term represented internally lambda term representation example lambda terms satisfying kleene showed meta circular closed terms fact data types represented directly lambda calculus exploited mogensen find simpler representation difficulty representing lambda terms internally form order algebraic data type due binding effect lambda 
mogensen solved problem follows 
consider data type signature const app abs const abs unary constructors app binary constructor 
const app abs representation lambda calculus definition 

proposition mogensen 
define const pq app abs exists self interpreter lambda terms possibly containing variables proof 
proposition exists lambda term const app ep eq abs zx easy induction show terms construction proposition bohm term simple form cii xyz xz yz xyz zy 
improvement kleene 
see barendregt self interpreters 

functional programming subsection short history lambda calculi untyped typed inspired consciously unconsciously creation functional programming 
imperative versus functional programming church captured notion computability lambda calculus turing done model computation turing machines 
second world war computational power needed military purposes electronic devices built basically turing machines random access memory 
statements instruction set machines directly related instructions turing machine 
statements easily interpreted hardware act substitution fundamental lambda calculus 
hardware early computers modified time different computational job done 
von neumann known turing concept universal turing machine suggested building machine programmed possible computational jobs software 
resulting computer revolution machines called von neumann computer consisting programmable universal machine 
appropriate call turing computer 
model computability introduced church lambda definability equivalent turing harder interpret hardware 
emergence paradigm functional programming essentially church invited turing united states mid 
year von neumann invited turing stay second year 
see hodges 
lambda definability took time 
functional programs closer specification computational problems imperative ones paradigm convenient traditional imperative 
important feature functional programs parallelism naturally expressed imperative programs 
see turner hughes evidence elegance functional paradigm 
implementation difficulties functional programming memory usage compilation time actual run time functional programs 
contemporary state art implementing functional languages problems solved satisfactorily 
classes functional languages describe languages cases influential expansion functional programming 
languages come classes 
lambda calculus complete model computation expression may evaluated different called reduction strategies indicate sub term evaluated see ch 

theorem order evaluation important final result normal form lambda term unique exists 
order evaluation difference efficiency time space question normal form obtained 
called eager functional languages reduction strategy evaluates expression fa evaluating particular order say delta delta delta delta delta delta delta delta delta contracting evaluation strategy definite advantages efficiency implementation 
main reason large normal form small advantageous time space efficiency perform reduction order 
evaluating fa directly delta delta delta delta delta delta delta delta delta takes space evaluated twice takes time 
eager evaluation normalizing reduction strategy sense ch 

example normal form evaluating fa eagerly diverges fa evaluated leftmost outermost roughly left right 
kind reduction called lazy evaluation 
turns eager languages computationally complete soon see 
implementation languages milestone development functional programming 
second milestone consisted efficient implementation lazy languages 
addition distinction eager lazy functional languages equal importance 
difference untyped typed languages 
difference comes directly difference untyped lambda calculus various typed lambda calculi see 
typing useful programming bugs errors result typing error detected automatically prior running program 
hand typing logical programming languages mentioned advantages 
far pure logical languages industrial quality developed 
prolog pure prolog see nadathur miller pure presently prototype 
cumbersome cases types need explicitly 
reason type reconstruction algorithm curry hindley rediscovered milner automatically find type certain context untyped typeable expression 
typed versions functional programming languages implicitly typed lambda calculi la curry 
types play important role making implementations lazy languages efficient see 
functional languages treated languages apl fp important historically 
language apl introduced iverson relatively widespread 
language fp designed backus gave lecture backus occasion receiving turing award imperative languages strong influential functional languages 
apl fp programs consist set basic functions combined define operations data structures 
language apl example functions matrix operations 
languages composition way obtain new functions complete full functional language user defined functions created 
consequence languages essentially limited ease expressing algorithms 
eager functional languages give promised argument eager functional languages computationally complete 
computable recursive function lambda definable calculus see church theorem 
calculus term having normal form strongly normalizing see church rosser theorem 
eager evaluation strategy find required normal form 
functional language lisp designed implemented mccarthy 
evaluation expressions language eager 
lisp considerable impact art programming 
programming environment programmers attracted produced interesting programs called artificial intelligence 
lisp pure functional language reasons 
assignment possible confusion local global variables dynamic binding lisp users lisp uses quote quote versions lisp common lisp see steele jr scheme see clinger rees dynamic binding longer 
quote operator languages 
ia ia adding quote lambda calculus inconsistent 
may reduce lisp scope quote having quote lips inconsistent 
quote available function constructor 
formed expres means substitution expression free variable context variable bound 
originators lisp hilbert ackermann done noticed von neumann review book 
church may known von neumann review avoided confusing local global variables introducing ff conversion 
sion quote lisp primitive fixed point operator label implemented cycle functional languages 
landin developed machine secd machine implementation reduction 
implementations eager functional languages including versions lisp computational model 
secd machine modelled lazy functional languages see henderson 
way implementing functional languages called cps translation 
introduced reynolds compilers steele jr appel 
see plotkin reynolds 
important typed functional language eager evaluation strategy standard ml see milner 
language curry variant simply typed lambda calculus implicit typing see 
expressions type free legal type derived 
algorithm curry hindley cited decidable expression type general type computed 
milner added features 
addition new primitives 
fixed point combinator primitive essentially types form assigned 
yf type sides yf yf type primitives basic arithmetic operations added 
additions ml universal programming language terms normalizing 
second addition ml construction 
language construct intended interpretation may think construction necessary 
large translation space inefficient 
interpretation interpretation limitations fixed type various occurrences may different types 
expression way space reduction sharing expression implicit polymorphism type 
example expression id fx id id typeable second occurrence id gets type third 
quote function violate church rosser property 
example ia quote reduce quote ia ia xa quote quote common reduct expressions ia relatively efficient implementation possibility type checking compile time finding errors language ml evolved important industrial variants standard ml new jersey 
widely industry efficient implementation ml machine caml see cousineau 
caml inspired categorical foundations lambda calculus see smyth plotkin curien 
papers inspired denotational semantics scott see scott gunter scott 
lazy functional languages computable functions represented eager functional programming language reductions full calculus performed eager evaluation 
saw normal form eager evaluation fa terminate term normal form 
lazy functional programming languages reduction fa possible reduction strategy languages essentially leftmost outermost reduction normalizing 
advantages having lazy evaluation infinite objects 
example legal expression potentially infinite lists primes take th projection order get th prime 
see turner hughes interesting uses lazy programming style 
explained eager evaluation implemented efficiently lazy evaluation copying large expressions expensive space time costs 
wadsworth idea graph reduction introduced order lazy evaluation efficiently 
model computation expression delta delta delta delta delta delta delta delta delta reduce delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta occurrences pointers referring third occurrence 
way lambda expressions dags directed acyclic graphs 
idea graph reduction carefully chosen combinators primitives experimental language see turner implemented lazy functional languages 
notion graph reduction extended turner implementing fixed point combinator primitives cyclic graph 
cyclic graphs described wadsworth 
lisp language untyped 
fair say programs written eager languages lisp standard ml execution programs orders magnitude slower imperative programs spite graph reduction 
typed versions lazy functional languages emerge considerable speed performance 
lazy version ml called lazy ml lml implemented efficiently group chalmers university see johnsson 
underlying computational model called machine avoids building graphs efficient 
example expression purely arithmetical seen type information evaluation done efficiently graphs 
implementation feature robin gandy mentioned meeting birthday early turing told wanted evaluate lambda terms graphs 
turing description evaluation mechanism common oversight confusing free bound variables 
gandy pointed turing said ah worth pounds month 
lml compilation super combinators see hughes form fixed set created demand depending expression evaluated 
emerging fully developed typed lazy functional language called miranda tm developed turner 
special mention elegance functional interface see 
notably ideas machine lazy functional programming efficient 
late efficient implementations typed lazy functional languages appeared discuss clean see eekelen plasmeijer haskell see jones wadler hudak 
languages implementations execute functional programs way comparable speed contemporary imperative languages interactive functional languages versions functional programming considered far called autistic 
program consists expression execution reduction output normal form nf exists 
quite useful purposes interaction outside world 
just dealing input output requires interaction 
need concept process opposed function 
intuitively process general geared continuation function geared termination 
processes input channel input stream potentially infinite sequence tokens coming output channel output stream coming 
typical process control traffic light system geared continuation input stream coming pedestrians output stream regulating traffic lights 
text editing process 
fact simple form process 
primitive way deal functional language versions ml 
input stream output stream 
suppose wants perform process read numbers input stream put difference gamma output stream write ml program write read gamma read satisfactory relies fixed order evaluation expression read gamma read 
satisfactory way consists called continuations see gordon 
lambda calculus adds primitives read write 
operational semantics expression follows hnf hnf head normal form read taken input stream write put output stream 
process written read read write gamma head nf lambda calculus form ym mn mn possibly nf 
wants process continuously takes elements input stream put difference output stream write program extended lambda term read read write gamma fixed point combinator 
interactive program written way provided special commands written output stream interpreted 
example imagine writing echo print output channel put screen print respectively 
continuations equivalent monads programming languages haskell shown gordon 
version haskell refined consider issue 
effective sequence terms infinite list represented lambda term zmn defined fixed point combinator 
operations read write explicitly lambda definable representation potentially infinite input stream world user external operating system potentially infinite output stream machine running interactive functional language 
interactive program acting argument 
continuation language definition matches operational semantics 
read write way acts dynamic state 
operating system take care actions performed channels 
take care statements echo interpreted 
easy find pure lambda terms read write satisfying 
implementation continuations way deal interactive programs 
serious problem 
define write write consider evaluation write write happen actual output channel added dilemma caused duplication channels 
solution explicitly mention channels lambda calculus continuations 
essentially happens method monads interactive functional programming language haskell 
writes main ffi ffi fn intended interpretation ffi ffi fn 
solution put forward functional language clean typing system guarantees channels duplicated 
purpose called uniqueness typing system designed see barendsen smetsers related linear logic see girard 
done improve way parts world explicitly 
representation aspects world incorporated lambda calculus 
having just world extended include representation screen printer mouse keyboard gadgets add computer periphery computers form network 
interpreting print simply put printer advantage wants echo print order happens immaterial forced specification sending print echo output channel echo print representing inside lambda calculus uniqueness types gadgets world write mouse screen printer mouse put screen put printer happens depends operating system parameters know example long printing queue 
interested 
system satisfies church rosser theorem eventual result printed echoed unambiguous 
clean somewhat natural haskell version definitely appropriate implementation parallel hardware 
clean haskell state art functional programming languages producing efficient code compiling time clean belongs class fast compilers including imperative languages 
serious applications written languages 
interactive aspect languages possible lazy evaluation higher type functions themes functional programming community called higher order functions 
prefer logically correct expression higher type higher order refers quantification types system 
core lambda calculus 
expected significant impact production modern interactive window software 

reasoning computer mathematics modern systems computer algebra ca able represent mathematical notions machine compute 
objects integers real complex numbers polynomials integrals 
computations usually symbolic numerical virtually arbitrary degree precision 
fair say done system ca represent exactly 
spite fact number infinite decimal expansion 
number represented computer just symbol mind machine knows manipulate 
common feature kind notions represented systems ca sense computable 
systems ca reached high level sophistication efficiency commercially available 
scientists pure applied mathematicians research 
emerging new technology systems computer mathematics cm 
systems virtually mathematical notions represented exactly including computational nature 
possible 
suppose example want represent non computable object diophantine set fn represent special symbol 
computer general operate object may nature 
answering question previous paragraph analyze non computability comes 
case comes quantifiers exists 
quantifiers usually range infinite set loses decidability 
ages mathematicians able obtain interesting information non computable objects 
notion proof 
proofs state confidence aristotle remarked hard find proofs verification putative done relatively easy way 
contribution aristotle quest formalization logic 
years frege right formulation predicate logic godel proved complete quest fulfilled 
mathematical proofs completely formalized verified computers 
underlying basis systems cm 
day prototypes systems cm able help user develop primitive notions axioms theories consisting defined concepts theorems proofs 
systems cm inspired automath project de bruijn see de bruijn nederpelt automated verification mathematical proofs 
way doing mathematics axiomatic method described aristotle 
euclid method successfully elements 
representing proofs lambda terms mathematical proofs fully formalized question arises done best efficiency reasons concerning machine pragmatic reasons concerning human user 
hilbert represented proof statement set axioms gamma finite sequence gamma follows previous statements rules logic 
efficient way represent proofs employs typed lambda terms called propositions types interpretation discovered curry howard de bruijn 
interpretation maps propositions types proofs corresponding inhabitants 
method follows 
statement transformed type collection set proofs provable inhabited proof proof consists brouwer heyting interpretation implication function having argument proof value proof symbols similarly px pix pix cartesian product px proof px consists function assigns element proof px 
way proof objects isomorphic intuitionistic natural deduction proofs gentzen 
interpretation proof py py ax py denotes function assigns input output 
proof description typed lambda calculi types inhabitants formulated gives example large proof object 
verifying proof boils verifying context type equal convertible 
method extended representing connectives right type system 
translating propositions types default intuitionistic logic 
classical logic dealt adding excluded middle axiom 
complicated computer system claims certain mathematical statement correct may wonder case 
example may software errors system 
satisfactory methodological answer de bruijn 
proof objects public written formalism reasonably simple proof checker verify 
able verify program proof checker hand 
call de bruijn criterion proof development systems lego see luo pollack coq see coquand huet satisfy criterion 
way keep proof objects growing large employ called poincar principle 
poincar stated argument showing proof strict sense verification claimed arbitrary mathematician 
automath project de bruijn interpretation poincar principle 
proof proof 
notion reduction consisting ordinary fi reduction ffi reduction order deal unfolding definitions 
fi ffi reduction complicated programmed type systems enjoying interpretation poincar principle satisfy de bruijn criterion spite compact representation typed lambda calculi poincar principle proof objects large times length complete informal proof 
large proof objects tiresome generate hand 
necessary persistence jutting written lambda lambda obtain proof objects showing proofs landau correct 
modern system cm better 
user introduces context consisting primitive notions axioms 
necessary definitions formulate theorem proved goal 
proof developed interactive session machine 
user needs give certain tactics machine 
interpretation tactics machine mathematically sophisticated necessary bookkeeping 
sophistication comes giving right tactics 
final goal research necessary effort interactively generate formal proofs complicated producing text say goal reached 
see barendregt including approaches computer mathematics 
include systems nuprl hol otter mizar boyer moore theorem prover 
systems satisfy de bruijn criterion probably modified easily 
computations proofs taken barendregt barendsen 
computations needed proofs 
happens example want prove formal versions intuitive statements 
integer part real prime way handle poincar principle extended reduction relation 
primitive recursion natural numbers 
operations primitive recursive lambda definable 
fi term say lambda calculus extended operation primitive recursion satisfying rab zero rab succ rab writing zero succ zero formally derivable follows poincar principle true reductions may cause proof checking unacceptable time complexity 
proof iff type proof coming human necessary conversion path feasible find automatically may hard 
problem probably avoided enhancing proof objects hints reduction strategy 
proof object 
fi usually proof obligation arises adequately constructed 
example case 
proof obligation needs formally proved reductions 
fi freely times 
similar way statement formulated proved constructing lambda defining term prime characteristic function predicate prime 
term satisfy statement prime prime prime prime proof obligation 
statement corresponds symbolic computation 
computation takes place syntactic level formal terms 
function acting syntactic expressions satisfying want lambda define 
nat context nat expression syntactic level represented internally satisfies term nat suitably defined inductive type term nat 
introducing reduction relation 
primitive recursion data type techniques similar lambda define say 
fi order finish proof needs construct self interpreter expressions nat 
fi prove proof obligation term nat follows 
fi 
fi 
fi poincar principle inductive types nat term nat corresponding reduction relations primitive reduction suggested scott extension poincar principle corresponding reduction relations primitive recursion martin lof 
reductions hard program resulting proof checking satisfies de bruijn criterion 
program primitive recursive predicate constructs lambda term defining characteristic function proof adequacy kp resulting computations prime efficient straightforward non optimized translation primitive recursion numerals represented numbers unary ary representation method promising 
efficient ad hoc lambda definition characteristic function prime fermat small theorem primality 
required proof obligation 
choice formal systems possibilities choice formal system representation theories systems computer mathematics 
constructing proof objects cooperation researchers desirable choice care order reach international standard 
step may restrict attention systems typed lambda calculi provide compact representation meet de bruijn criterion having simple proof checker 
simplest form systems described uniform way pure type systems pts different strength see 
pts extended definition mechanism pts definitions see poll 
describing variants logic sorted predicate logic second higher order versions 
stated default logic intuitionistic classical assuming excluded middle 
step consists adding inductive types corresponding reduction relations order capture primitive recursion 
suggest right formal systems computer mathematics type systems ts consisting extended described paulin mohring 
ts come parameters 
specification underlying pts specifying logical strength see 
second collection inductive types respective notions reduction 
specifying mathematical computational strength 
opinion system able verify proof objects written systems ts reasonable choice spectrum parameters 
wants subclass choice parameters dictated person foundational views proof checker anyway 
believe generality expensive terms complexity checking 
illative lambda calculus curry students continued look way represent functions logic adequate formal system 
proposed systems turned inconsistent ones turned incomplete 
research ts representation logic resulted unexpected side effect 
making modification inspired ts possible give extension untyped lambda calculus called illative lambda calculi ilc illative may argued list features important deserve ts primitives implemented quotient types see hofmann subtypes see aspinall type inclusion see luo pollack 
interesting question experiments done determine case translated basic ts sufficiently efficient way possibly macros system cm 
latin word means infer order logic faithfully completely embedded 
method extended arbitrary pts higher order logic represented 
resulting ilc fact simpler ts 
doing computer mathematics ilc probably practical clear proof checking systems 
nice thing ilc old dream church curry came true system untyped lambda calculus combinators logic mathematics 
importantly combinatory transformation ordinary interpretation logic propositions types interpretation 
basically situation follows 
interpretation predicate logic ilc logic proof ilc ilc ilc ranges untyped lambda terms 
translation propositions types interpretation hand interpretation isomorphic version order logic denoted see barendregt dekkers results 
short ilc combinatory version appendix abramsky gabbay maibaum eds 
handbook logic computer science volume background computational structures oxford science publications 
ackermann zum der zahlen mathematische annalen 
appel andrew compiling continuations cambridge university press 
aspinall subtyping dependent types clarke ed proceedings th annual symposium logic computer science ieee computer society press new brunswick new jersey 
backus programming liberated von neuman style comm 
acm 
barendregt lambda calculus syntax semantics revised edition northholland amsterdam 
barendregt theoretical pearls self interpretation lambda calculus journal functional programming 
order logic embedding natural second order logic 
open question exists natural representation second higher order logic ilc 
barendregt lambda calculi types abramsky oxford university press 
barendregt discriminating coded lambda terms apt schrijver eds universal morphisms megabytes baayen cwi kruislaan sj amsterdam 
barendregt lambda terms reducing constructively annals pure applied logic 
barendregt quest correctness images smc research stichting mathematisch centrum box gb amsterdam 
barendregt barendsen efficient computations formal proofs 
appear 
barendregt bunder dekkers systems illative combinatory logic complete order propositional predicate calculus appear journal symbolic logic 
barendsen smetsers conventional uniqueness typing graph rewrite systems extended 
barendsen smetsers uniqueness typing functional languages graph rewriting semantics appear mathematical computer science 
beeson foundations constructive mathematics springer berlin 
benthem van language action categories lambdas dynamic logic studies logic foundations mathematics north holland amsterdam 
berarducci bohm self interpreter lambda calculus having normal form lecture notes computer science 
bezem groote eds 
typed lambda calculi applications tlca number lecture notes computer science springer verlag berlin 
bohm cuch formal description language richard goodman ed annual review automatic programming vol 
pergamon press oxford 
bohm berarducci automatic synthesis typed programs term algebras theoretical computer science 
bohm gross cuch ed automata theory academic press new york 
bohm lambda definition function normal forms ed esop vol 
springer berlin 
de bruijn mathematical language automath usage extensions eds symposium automatic demonstration springer verlag berlin versailles 
lecture notes mathematics nederpelt 
de bruijn reflections automath eindhoven university technology 
nederpelt 
church formulation simple theory types journal symbolic logic 
church calculi lambda conversion princeton university press 
church rosser properties conversion transactions american mathematical society 
church unsolvable problem elementary number theory american journal mathematics 
clinger rees revised report algorithmic language scheme lisp pointers iv 
coquand huet calculus constructions information computation 
cousineau 
curien mauny categorical machine science computer programming 
curien 
categorical combinators sequential algorithms functional programming research notes theoretical computer science pitman london 
curry grundlagen der logik american journal mathematics 
german 
curry functionality combinatory logic proceedings national academy science usa 
curry modified basic functionality combinatory logic dialectica 
dekkers bunder barendregt completeness propositions types interpretation intuitionistic logic illative combinatory logic appear journal symbolic logic 
eekelen van plasmeijer functional programming parallel graph rewriting addison wesley reading massachusetts 
personal communication 
euclid elements english translation heath 
feferman language axioms explicit mathematics muller eds proof theory symposium lecture notes mathematics springer berlin 
feferman definedness 
gamut logic meaning chicago university press chicago 
gandy church thesis principles mechanisms kleene symposium northholland publishing amsterdam 
gentzen gerhard investigations logical deduction szabo ed collected papers gerhard gentzen north holland 
girard 
interpr etation fonctionelle elimination des coupures de arithm etique ordre sup erieur th ese de doctorat etat universit paris vii 
girard 
linear logic syntax semantics 
girard lafont regnier eds advances linear logic london mathematical society lecture note series cambridge university press 
available anonymous ftp univ fr pub girard synsem ps girard lafont taylor proofs types cambridge tracts theoretical computer science cambridge university press 
gordon functional programming input output distinguished dissertations computer science cambridge university press 
map theory theoretical computer science 
gunter scott semantic domains leeuwen 
heath thirteen books euclid elements dover publications new york 
heijenoort van ed 
frege godel source book mathematical logic harvard university press cambridge massachusetts 
henderson functional programming application implementation prentice hall englewood cliffs new jersey 
hilbert ackermann der logik die der mathematischen wissenschaften band edition springer verlag berlin 
hindley principal type scheme object combinatory logic transactions american mathematical society 
hodges intelligence unwin london 
hofmann simple model quotient types typed lambda calculi applications lecture notes computer science springer berlin new york 
hudak peyton jones boutel fairbairn fasel guzman hammond hughes johnsson kieburtz nikhil partain peterson report programming language haskell non strict purely functional language version acm sigplan notices ri rx 
hughes design implementation programming languages dissertation university oxford 
hughes functional programming matters computer journal 
iverson programming language wiley new york 
mccarthy lisp programmer manual mit press cambridge massachusetts 
johnsson efficient compilation lazy evaluation sigplan notices 
jones peyton wadler imperative functional programming conference record twentieth annual acm sigplan sigact symposium principles programming languages charleston south carolina january acm press 
jutting van benthem checking landau grundlagen automath system dissertation eindhoven university technology 
kleene lambda definability recursiveness duke mathematical journal 
kleene metamathematics university series higher mathematics van nostrand comp new york toronto 
kleene logicians 
reported crossley 
contributions chang crossley keisler kleene mostowski nerode sacks hilton lucy crossley ed algebra logic fourteenth summer res 
inst austral 
math 
soc monash univ clayton lecture notes mathematics springer berlin 
kleene origins recursive function annals history computing 
kleene rosser inconsistency certain formal logics annals mathematics 
models lambda calculus information control 
kreisel church thesis kind reducibility axiom constructive mathematics myhill eds intuitionism proof theory north holland amsterdam 
kreisel positivist doctrine mathematical precision light experience age de la science 
kuper axiomatic theory partial functions information computation 
landau grundlagen der analysis rd edition edition chelsea publishing 
landin peter mechanical evaluation expressions computer journal 
leeuwen van ed 
handbook theoretical computer science vol 
north holland 
leivant daniel reasoning functional programs complexity classes associated type disciplines th annual symposium foundations computer science ieee 
luo pollack lego proof development system user manual technical report ecs lfcs university edinburgh 
martin lof intuitionistic type theory studies proof theory bibliopolis napoli 
yu 
recursive unsolvability hilbert tenth problem fourth international congress logic methodology philosophy science studies logic foundations mathematics north holland amsterdam milner theory type polymorphism programming journal computer system sciences 
mogensen ae 
theoretical pearls efficient self interpretation lambda calculus journal functional programming 
nadathur miller overview prolog robert kowalski kenneth bowen eds logic programming proceedings fifth international conference symposium volume mit press cambridge massachusetts 
nederpelt geuvers de eds 
selected papers automath studies logic foundations mathematics north holland amsterdam 
von neumann eine der mengenlehre reine angew 
math 

proof calculation master thesis universitaire school voor informatica catholic university nijmegen 
paulin mohring inductive definitions system coq rules properties bezem groote 
plotkin call name call value calculus theoretical computer science 
poincar la science hypoth ese paris 
ramsey foundations mathematics proceedings london mathematical society 
reynolds john definitional interpreters higher order programming languages proceedings th acm national conference boston massachusetts 
reynolds john discoveries continuations lisp symbolic computation 
robinson theory classes modification von neumann system symbolic logic 
rosser highlights history lambda calculus acm symposium lisp functional programming acm press 
russell whitehead principia mathematica cambridge university press 
schwichtenberg funktionen im mit typen fur mathematische logik 
scott dana continuous lattices lawvere ed toposes algebraic geometry logic number lecture notes mathematics springer verlag 
scott constructive validity eds symposium automated demonstration lecture notes mathematics springer berlin 
poll pure type systems definitions nerode yu eds proceedings lfcs lncs lfcs st petersburg russia springer verlag new york 

ed 
proceedings th conference foundations software technology theoretical computer science bombay india lecture notes computer science springer verlag berlin 
skolem der durch die ohne anwendung mit klasse 
english translation heijenoort 
smyth plotkin category theoretic solution recursive domain equations siam journal computing 
statman typed lambda calculus elementary recursive theoretical computer science 
steele jr guy rabbit compiler scheme technical report ai tr artificial intelligence laboratory massachusetts institute technology cambridge massachusetts 
steele jr common lisp language digital press 
troelstra 
ed 
metamathematical investigation intuitionistic arithmetic analysis lecture notes mathematics springer verlag berlin 
turing computable numbers application entscheidungsproblem proc 
london math 
soc 

turing computability lambda definability symbolic logic 
turner semantic elegance functional languages proceedings acm mit conference functional languages computer architecture acm press 
turner new implementation technique applicative languages software experience 
turner language manual 
turner miranda non strict functional language types jouannaud ed functional programming languages computer architec tures lecture notes computer science springer verlag 
wadsworth semantics pragmatics lambda calculus phil thesis university oxford programming research group oxford 
