
tsang foundations constraint satisfaction academic press 

reeve li parallel clp system proc 
conf 
parallel architectures languages europe 

vitter ph 
flajolet average case analysis algorithms data structures handbook theoretical computer science vol 
elsevier science publishers amsterdam 

constraint language semantics computations technical report complete logic systems 

types proc 
th international conference logic programming 

clp sigma constraint logic programming regular sets proc 
th international conference logic programming 

wallace computable semantics general logic programs journal logic programming 

wallace applying constraints scheduling constraint programming eds nato advanced science institute series springer verlag 

warren prolog instruction set technical note ai center sri international menlo park october 

warren andorra principle workshop 

wilson borning hierarchical constraint logic programming journal logic programming 

yap restriction site mapping clp proceedings th international conference logic programming mit press june 

yap constraint logic programming framework constructing dna restriction maps artificial intelligence medicine 

yap contributions clp ph thesis department computer science monash university january expected 

srivastava subsumption indexing constraint query languages linear arithmetic constraints annals mathematics artificial intelligence 

srivastava ramakrishnan pushing constraint selections journal logic programming 

stallman sussman forward reasoning dependency directed backtracking system computer aided circuit analysis artificial intelligence 

transformational approach configuration design master thesis engineering design research center carnegie mellon university 

steele sussman constraints language expressing hierarchical descriptions artificial intelligence 

steele implementation definition computer programming language constraints ph dissertation mit ai tr dept electrical engineering computer science 

stickel automated deduction theory resolution journal automated reasoning 

stuckey incremental linear constraint solving detection implicit equalities orsa journal computing 

stuckey constructive negation constraint logic programming proc 
logic computer science conference 
full version information computation appear 

subramanian 
wang kinematic synthesis configuration spaces proc 
qualitative reasoning weld ed 

sutherland man machine graphical communication system phd thesis massachusetts institute technology january 

tarski decision method elementary algebra geometry university california press 

taylor lips mips results prolog compiler risc proceedings th international conference logic programming 

hawley sawada satoh iwayama parallel constraint logic programming language parallel constraint solvers proc 
international conference fifth generation computer systems volume 

tick concurrent logic programming languages draft manuscript 

tobias ii knowledge representation harmony intelligent tutoring system master thesis department computer science university california los angeles 

tong leung concurrent constraint logic programming massively parallel simd computers proc 
international logic programming symposium 

satoh computing soft constraints hierarchical constraint logic programming journal information processing appear 

scott domains denotational semantics proc 
icalp 
lncs 

shapiro subset concurrent prolog interpreter technical report cs dept applied mathematics weizmann institute science 

shapiro logic programs uncertainties tool implementing expert systems proc 
th 
ijcai 

shoenfield mathematical logic addison wesley 

siekmann unification theory journal symbolic computation 

simonis dincbas propositional calculus problems chip constraint logic programming selected research benhamou colmerauer eds mit press 

simonis formal verification multipliers proceedings ifip tc wg wg workshop applied formal methods correct vlsi design leuven belgium november 

simonis test generation constraint logic programming language chip proc 
th international conference logic programming 

simonis dincbas extended prolog digital circuit design ieee international workshop ai applications cad systems electronics munich germany october 

simonis dincbas logic programming fault diagnosis digital circuits german workshop artificial intelligence germany september 

simonis graf technology mapping chip technical report tr lp ecrc munich 

simonis nguyen dincbas verification digital circuits chip proceedings ifip wg international working conference fusion hardware design verification glasgow scotland july 

simonis le provost circuit verification chip benchmark results 
proceedings ifip tc wg wg workshop applied formal methods correct vlsi design leuven belgium november 

clp spacecraft attitude control proc 
jicslp workshop constraint logic programming 

smolka residuation guarded rules constraint logic programming constraint logic programming selected research benhamou colmerauer eds mit press 

smolka records logic programming journal logic programming appear 
proceedings joint international conference symposium logic programming 

le provost wallace generalized constraint propagation clp scheme journal logic programming 

przymusinski declarative semantics deductive databases logic programs foundations deductive databases logic programming minker ed morgan kaufmann 

rajasekar string logic programs draft manuscript dept computer science univ kentucky 

ramachandran van hentenryck incremental algorithms constraint solving entailment rational trees proc 
th conf 
foundations software technology theoretical computer science lncs 

ramakrishnan magic templates approach logic programs journal logic programming 

ramalingam reps categorized bibliography incremental computation proc 
th acm symp 
principles programming languages 

van roy despain benefits global dataflow analysis optimizing prolog compiler proceedings north american conference logic programming 

exploration capabilities software practice experience 

sakai sato boolean bases appear 

sagiv vardi safety datalog queries infinite databases proc 
acm symp 
principles database systems 

saraswat cp general purpose constraint language proc 
aaai 

saraswat somewhat logical formulation clp synchronization primitives proc 
th international conference symposium logic programming 

saraswat concurrent constraint programming languages ph thesis carnegie mellon university 
revised version appears concurrent constraint programming mit press 

saraswat category constraint systems cartesian closed proc 
symp 
logic computer science 

saraswat kahn shapiro detecting stable properties networks concurrent logic programming languages proc 
th 
acm symp 
principles distributed computing 

saraswat rinard panangaden semantic foundation concurrent constraint programming proc 
th acm symp 
principles programming languages 

saraswat retrospective look concurrent logic programming preparation 

marriott sndergaard stuckey yap optimising compilation clp proc 
australian computer science conf 

martin nipkow boolean unification story far journal symbolic computation 

macsyma manual group laboratory computer science mit 

michaylov pfenning higher order logic programming constraint logic programming proc 
workshop principles practice constraint programming 

michaylov design implementation practical constraint logic programming systems ph thesis carnegie mellon university report august 

miller logic programming language lambda abstraction function variables simple unification extensions logic programming international workshop springer verlag lncs 

miller nadathur higher order logic programming proc 
rd international conference logic programming 

montanari rossi graph rewriting partial ordering semantics concurrent constraint programming theoretical computer science 

tuples prolog technical report tr icot tokyo 

mumick finkelstein pirahesh ramakrishnan magic conditions proc 
th acm symp 
principles database systems 

naish automating control logic programs journal logic programming 

naish negation control prolog lecture notes computer science springer verlag 

nelson constraint graphics system computer graphics 

nerode kohn hybrid systems constraint logic programming proc 
th international conference logic programming 

older benhamou programming clp proc 
workshop principles practice constraint programming 

paterson wegman linear unification journal computer system sciences 

pfenning logic programming lf logical framework logical frameworks huet plotkin eds cambridge university press 

podelski van roy beauty beast algorithm testing entailment incrementally draft manuscript 

leung distributed constraint logic programming vol 
world scientific series computer science world scientific 

li reeve clark rawlings shirazi applications parallel clp system proc 
th international conference logic programming 

lloyd foundations logic programming springer verlag second edition 

lloyd topor making prolog expressive journal logic programming 

mcaloon lp logic programming linear programming system brooklyn college computer science technical report 

mcdonald stuckey yap redundancy variables clp proc 
international logic programming symposium 

mckinsey decision problem classes sentences quantifiers journal symbolic logic 

maher logic semantics class committed choice programs proc 
th international conference logic programming 

maher complete axiomatizations algebras finite rational infinite trees proc 
rd 
symp 
logic computer science 
full version ibm research report watson research center 

maher clp view logic programming proc 
conf 
algebraic logic programming lncs 

maher transformation system deductive database modules perfect model semantics theoretical computer science 

maher logic programming view clp proc 
th international conference logic programming 
full version ibm research report watson research center 

maher stuckey expanding query power clp languages proc 
north american conference logic programming 

problem solvability equations free semigroup math 
ussr 
english translation ams 

mannila ukkonen complexity unification sequences proc 
rd international conference logic programming 

implementation proc 
symp 
programming language implementation logic programming lncs 

marriott stuckey optimizing constraint logic programs refinement removal reordering proc 
th acm symp 
principles programming languages 

marriott stuckey semantics clp programs optimization technical report university melbourne 

complexity unification free groups free semigroups proc 
st symp 
foundations computer science 

krishnamurthy ramakrishnan shmueli framework testing safety effective computability extended datalog proc 
acm symp 
management data 

algebraic languages mathematical programming european journal operations research 

kunen negation logic programming journal logic programming 

contribution logic programming support telecommunications protocol tests proc 
th international conference logic programming 

constraint logic programming analysis partial synthesis truss structures artificial intelligence engineering design analysis manufacturing 

lassez constraint logic programming tutorial byte magazine august 

lassez mcaloon yap constraint logic programming options trading ieee expert special issue financial software august 

lassez 
lassez quantifier elimination conjunctions linear constraints convex hull algorithm symbolic numeric computation artificial intelligence donald kapur mundy eds academic press appear 
ibm research report rc watson research center 


lassez huynh mcaloon elimination redundant linear arithmetic constraints proc 
north american conference logic programming cleveland 


lassez maher marriott unification revisited foundations deductive databases logic programming minker ed morgan kaufmann 


lassez marriott explicit representation terms defined counter examples journal automated reasoning 


lassez mcaloon canonical form generalized linear constraints journal symbolic computation 


lassez mcaloon constraint sequent calculus proc 
symp 
logic computer science 


language program stating solving combinatorial problems artificial intelligence 

constraint programming languages specification generation addison wesley 

jaffar michaylov stuckey yap clp language system acm transactions programming languages 

jaffar michaylov yap methodology managing hard constraints clp systems proc 
acm sigplan conference programming language design implementation 

jaffar michaylov stuckey yap machine clp proceedings acm sigplan conference programming language design implementation 

jaffar stuckey canonical logic programs journal logic programming 

janson haridi programming paradigms andorra kernel language proc 
international logic programming symposium 

jorgensen marriott michaylov global compile time optimizations clp proceedings international logic programming symposium 

jourdan vald es erez constraint logic programming applied hypothetical reasoning chemistry proceedings north american conference logic programming 
page follow page 

floor planning applications clp proc 
jicslp workshop constraint logic programming 

polynomial algorithm linear programming soviet math 
dokl 

de kleer sussman propagation constraints applied circuit synthesis circuit theory applications 

kanellakis 
lassez saraswat eds principles practice constraint programming mit press appear 

kanellakis kuper revesz constraint query languages journal computer system sciences appear 
preliminary version appeared proc 
th acm symp 
principles database systems 

kanellakis ramaswamy vitter indexing data models constraints classes proc 
acm symp 
principles database systems 

kemp propagating constraints recursive deductive databases proc 
north american conference logic programming 

kemp stuckey analysis constraint query optimization proc 
th international conference logic programming 

klee simplex algorithm inequalities iii ed academic press new york 
klug conjunctive queries containing inequalities journal acm 

van hentenryck saraswat deville constraint processing cc fd manuscript 

van hentenryck saraswat deville design implementations evaluation constraint language cc fd technical report cs brown university 

hickey functional constraints clp languages constraint logic programming selected research benhamou colmerauer eds mit press 

smolka definite relations constraint languages report ibm 

clp system solving partial differential equations applications options valuation masters project depaul university 

hong risc clp real logic programming non linear constraints reals constraint logic programming selected research benhamou colmerauer eds mit press 

horn sentences true direct unions algebras journal symbolic logic 

huynh lassez clp options trading analysis system proceedings th international conference logic programming 

huynh lassez 
lassez practical issues projection polyhedral sets annals mathematics artificial intelligence 


variable elimination disequations generalized linear constraint systems computer journal 


fourier elimination choose 
proc 
workshop principles practice constraint programming newport april 

jaffar efficient unification infinite terms new generation computing 

jaffar minimal complete word unification journal acm 

jaffar 
lassez constraint logic programming technical report department computer science monash university 

jaffar 
lassez constraint logic programming proc 
th acm symposium principles programming languages munich january 

jaffar 
lassez maher theory complete logic programs equality journal logic programming 

jaffar 
lassez maher logic programming language scheme logic programming relations functions equations degroot lindstrom eds prentice hall 

jaffar maher stuckey yap projecting clp 
constraints new generation computing 

garc ia de la banda hermenegildo practical approach global analysis constraint logic programs proc 
international logic programming symposium 

garc ia de la banda hermenegildo marriott independence constraint logic programs proc 
international logic programming symposium 

van gelder negation failure tight derivations general logic programs foundations deductive databases logic programming minker ed morgan kaufmann 

van gelder ross schlipf unfounded sets founded semantics general logic programs journal acm 

gelfond lifschitz stable model semantics logic programming proc 
th international conference logic programming 

jones echidna constraint logic programming shell proc 
pacific rim international conference artificial intelligence 

heintze michaylov stuckey clp electrical engineering problems journal automated reasoning 

helm marriott odersky building visual language parsers proc 
conf 
human factors computer systems chi 

helm marriott odersky constraint query optimization spatial databases proc 
th acm symp 
principles database systems 

van hentenryck constraint satisfaction logic programming mit press 

van hentenryck parallel constraint satisfaction logic programming preliminary results chip proc 
th international conference logic programming 

van hentenryck constraint logic programming knowledge engineering review 

van hentenryck constraint satisfaction constraint logic programming artificial intelligence 

van hentenryck ed special issue constraint logic programming journal logic programming 

van hentenryck deville cardinality operator new logical connective application constraint logic programming proc 
international conference logic programming 

van hentenryck deville operational semantics constraint logic programming finite domains proc 
symp 
programming language implementation logic programming lncs 

van hentenryck graf standard forms rational linear arithmetics constraint logic programming annals mathematics artificial intelligence 

logic programming language retrospective commentary journal logic programming 

van emden quantitative deduction fixpoint theory journal logic programming 

emerson temporal modal logic handbook theoretical computer science vol 
chapter 

evans factory scheduling finite domains logic programming action lncs springer verlag 

fages semantics optimization predicates clp languages proc 
th conf 
foundations software technology theoretical computer science lncs 

falaschi levi martelli palamidessi declarative modelling operational behavior logic languages theoretical computer science 

schmid tid en experiences large industrial circuit design application proc 
international logic programming symposium 

fikes ref arf system solving problems stated procedures artificial intelligence 

fitting kripke kleene semantics logic programs journal logic programming 

fourier 
reported analyse des de des sciences pendant de des sciences de institut de france vol 
lv 
partial english translation kohler 
translation report fourier linear inequalities 
vol 

freeman benson constraint imperative programming phd thesis department computer science engineering university washington 

fruhwirth hanschke terminological reasoning constraint handling rules proc 
workshop principles practice constraint programming 

fruhwirth le provost lim wallace constraint logic programming informal logic programming action lncs springer verlag 

levi modeling answer constraints constraint logic programs proc 
th international conference logic programming 

gaifman maher shapiro replay recovery replication snapshots nondeterministic concurrent programs proc 
th 
acm symposium principles distributed computation 


ere prince project applications logic programming action lncs springer verlag 

colmerauer naive solving non linear constraints constraint logic programming selected research benhamou colmerauer eds mit press 

colmerauer invited talk workshop principles practice constraint programming newport ri april 


safety analysis means fault trees application open boolean solvers proc 
th international conference logic programming 

courcelle fundamental properties infinite trees theoretical computer science march 

darlington 
guo new perspective integrating functions logic languages proceedings rd international conference fifth generation computer systems tokyo 

de backer intelligent backtracking clp languages application clp proc 
international logic programming symposium 

de backer clp language handling disjunctions linear constraints proc 
th international conference logic programming 

debray static inference modes data dependencies logic programs acm transactions programming languages systems 

debray warren functional computations logic programs acm transactions programming languages systems 

diaz minimal extension wam clp fd proc 
th international conference logic programming 

dincbas van hentenryck simonis constraint logic programming language chip proceedings nd 
international conference fifth generation computer systems 

dincbas simonis van hentenryck solving cutting stock problem clp proceedings th international conference logic programming mit press 

dincbas simonis van hentenryck solving large combinatorial problems logic programming journal logic programming 

rossi embedding extensional finite sets clp proc 
international logic programming symposium 

duisburg constraint animation temporal constraints system technical report cr tektronix laboratories august 

ege maier borning filter browser defining interfaces graphically proc 
european conf 
object oriented programming paris 

carlsson automatic frequency assignment cellular telephones constraint satisfaction techniques proc 
th international conference logic programming 

contraction finite systems linear inequalities russian doklady nauk sssr vol 

english translation soviet mathematics doklady vol 


interoperability analysis symbolic simulation proc 
jicslp workshop constraint logic programming 

dec es fischler applying chip complex scheduling problem draft manuscript aviation department artificial intelligence 

chan constructive negation completed database proc 
th international conference logic programming 

variable elimination linear constraints computer journal 

hooker extended horn sets propositional logic journal acm 

chv atal linear programming freeman new york 

clark negation failure logic databases gallaire minker eds plenum press new york 

diaz boolean constraint solving clp fd proc 
international logic programming symposium 

fages jourdan design meta applications air traffic control proc 
jicslp workshop constraint logic programming 

cohen constraint logic programming languages cacm july 

colmerauer prolog ii manuel de groupe intelligence aix marseille ii 

colmerauer prolog infinite trees logic programming clark 
eds academic press new york 

colmerauer prolog figures proc 
th international joint conference artificial intelligence 

colmerauer equations inequations finite infinite trees proc 
nd 
int 
conf 
fifth generation computer systems tokyo 

colmerauer opening prolog iii universe byte magazine august 

colmerauer prolog iii users manual version 

colmerauer prolog iii cacm july 

boizumault solving real life exams problem chip proc 
international logic programming symposium 

borning programming language aspects constraint oriented simulation laboratory acm transactions programming languages systems october 

borning maher wilson constraint hierarchies logic programming proc 
th international conference logic programming 
fuller version technical report computer science department university washington 

levi meo contributions semantics open logic programs proc 
int 
conf 
fifth generation computer systems 

brodsky sagiv inference inequality constraints logic programs proc 
acm symp 
principles database systems 

brodsky jaffar maher practical constraint databases proc 
th international conference large data bases 

daniels application clp asset liability management banks computer science economics management may 

bryant graph algorithms boolean function manipulation ieee transactions computers 

temporal logic programming relation constraint logic programming proc 
international logic programming symposium 

temporal logic programming bounded universal modality goals proc 
th international conference logic programming 

burg hughes lang constraint programming survey technical report ist tr dept computer science university central florida 

burg parallel execution models algorithms constraint logic programming real number domain ph thesis dept computer science university central florida 

burg hughes lang parallel execution clp 
programs technical report tr cs university central florida 


resolution principle clauses constraints proc 
cade lncs 

simonis embedding boolean expressions logic programming journal symbolic computation 

carlsson freeze indexing implementation issues wam proc 
th international conference logic programming 

parallelization constraint logic programming language lp ph thesis city university new york 

mcaloon lp highly parallel constraint logic programming language proc 
th 
siam conf 
parallel processing scientific computing 

codish giacobazzi maher oracle semantics prolog proc 
rd conference algebraic logic programming lncs 

proving termination properties prolog semantic approach proc 
rd 
symp 
logic computer science 

chomicki wolper temporal deductive databases temporal databases theory design implementation tansel clifford gadia jajodia segev snodgrass eds benjamin cummings 

benhamou colmerauer eds constraint logic programming selected research mit press 

benhamou boolean algorithms prolog iii constraint logic programming selected research benhamou colmerauer eds mit press 

benhamou 
boolean pseudo equations constraint logic programming proc 
th international conference logic programming 

berthier financial model qualitative quantitative knowledge proceeedings international symposium computational intelligence milano september 

berthier solving financial decision problems chip proceeedings nd conference economics artificial intelligence paris june 

laurent industrial problem solved chip proc 
th international conference logic programming 

logic programming pseudo boolean constraints constraint logic programming selected research benhamou colmerauer eds mit press 

de boer kok palamidessi rutten non monotonic concurrent constraint programming proc 
international logic programming symposium 

de boer palamidessi fully model concurrent constraint programming proc 
tapsoft caap lncs 

de boer palamidessi embedding tool language comparison information computation 

de boer palamidessi concurrent logic programming concurrent constraint programming advances logic programming theory oxford university press appear 
people comments drafts help ways bruynooghe heintze van hentenryck 
lassez michaylov palamidessi stuckey wallace yap 
anonymous referees careful reading helpful comments 

abadi manna temporal logic programming journal symbolic computation 

extending chip solve complex scheduling packing problems journ ees de programmation logique lille france 

overview chip compiler system constraint logic programming selected research benhamou colmerauer eds mit press 

sakai sato hawley hasegawa constraint logic programming language cal proc 
international conference fifth generation computer systems 

ait kaci algebraic semantics approach effective resolution type equations theoretical computer science 

ait kaci warren machine tutorial reconstruction mit press 

ait kaci nasr login logic programming language built inheritance journal logic programming 

ait kaci lincoln nasr le fun logic equations functions proc 
symposium logic programming 

ait kaci podelski meaning life journal logic programming 

ait kaci podelski entailment order sorted feature constraints manuscript 

ait kaci podelski general residuation framework manuscript 

ait kaci podelski smolka feature constraint system logic programming entailment theoretical computer science appear 
proc 
international conference fifth generation computer systems vol 


albert fages average case analysis unification algorithms theoretical computer science 

apt blair walker theory declarative knowledge foundations deductive databases logic programming minker ed morgan kaufmann 
val val 
conclude mentioning authors claim approach great efficiency 
particular times faster boolean solvers deployed chip special purpose stand solvers 

applications applications discussed previous sections sample clp applications 
briefly mention indicate breadth problems addressed clp languages techniques 
exemplified clp model analog circuits 
considerable amount done digital circuits particular verification diagnosis synthesis test pattern generation 
works chip system 
see description large application 
civil engineering clp analysis partial synthesis truss structures 
electrical circuits constraints implement physical modelling verify truss support components generate spatial configurations 
mechanical engineering clp design gear boxes combined techniques qualitative physics clp design mechanical systems behavior specifications 
general engineering applications clp specify hierarchical composition complex systems rule reasoning 
important application area clp finance 
mentioned 
deals option valuations deal financial planning 
financial applications tended take form expert systems involving sophisticated mathematical models 
various proposals including certainty measures probabilities logic programs provide built evidential reasoning useful writing expert systems 
original proposals intended prolog underlying language clear clp languages provide flexible execution expert systems 
mention applying clp languages music car sequencing aircraft traffic control building visual language parsers warehousing problem safety analysis frequency assignment cellular telephones timetabling floor planning spacecraft attitude control interoperability fiber optic communications equipment interest rate risk management banking failure mode effect analysis complex systems development digitally controlled analog systems testing telecommunication protocols causal graph management factory scheduling project developed applications system manufacturing planning tourist advice molecular biology environment monitoring control 
bool var bool var bool var bool var bool var bool var needed bool var bool var bool var bool var 

propositional solver mentioned discussion boolean constraint domain approach solving boolean equations clp fd representing input formulas straightforward way variables constrained 
see section example 
follows 
assuming losing generality input conjunction equations form basic algorithm simply represent equation fd constraints theta theta gamma theta gamma gamma theta theta gamma theta gamma gamma gamma clp fd program fragment realizes representations 
shown procedure takes input equation calls procedures appropriately enumeration procedure values variables 
program val delays execution fd constraint containing ground time val denotes value meanings min max respectively current lower upper bounds maintained constraint solver discussed section 
constraint expresses respectively lower upper bounds min min 
max max min 
max max min min 
max max min 
min min min min 
max max max max min max 
max min max 
max 
ffl ultimate output program pathways identical identical transformations permuting reactants products step switching reactants products step 
program representation molecular formula list numbers specifies number atoms certain chemical element 
shall assume chemical elements interest presentation molecular formula tuple 
species represented tuple arithmetic variable formulation arithmetic formula mentioned boolean variables expressing formation dependencies species formula 
step gamma 
represented tuple containing identifiers representations listing simplified translated version prolog iii program 
main procedure solve argument list fixed size say element species template 
templates represent initial final target similarly steps list fixed size say element step template 
parameters program 
undefined procedure formula obtains species formula species projects element tuple 
similarly arith var bool var bool var project second third arguments respectively 
procedure duplicates asserts constraints prevent duplicate species steps prevents symmetrical solutions omit details 
calls procedure formation dependencies generate formation dependencies 
procedure needed imposes constraints conjunction formation dependencies assert respectively produce enumerate species self explanatory 
solve species steps duplicates 
balanced step 
step steps pathway step consistency 
step steps formation dependencies 
step steps needed enumerate species 
balanced step formula formula formula formula pathway step consistency arith var arith var arith var arith var formation dependencies bool var bool var 
chemical hypothetical reasoning prolog iii application described detail uses arithmetic boolean constraints 
problem hand elucidating pathways quote instantiation reaction schema delta delta delta determine pathway set constituent reaction steps molecules species formed reaction 
reaction step considered contains molecules product molecules described form gamma 
possibly empty molecular formulas 
problem determine reaction collection basic steps pathway explain reaction 
example ch pathway explains reaction 
ch gamma 
gamma 
gamma 
previously unidentified species 
program imposes constraints express requirements chemical reaction exclude uninteresting reactions 
addition constraints number molecules constraints reaction steps chemical element number atoms equals number product atoms step chemically balanced molecular formula appears sides step 
constraints pathway 
reaction schema consideration delta delta delta ffl pathway species ffl sufficient form target product boolean variables express dependency relation formed 
pathway step gamma 
state boolean constraint boolean variables associated respectively 
constraint expresses formed formed 
denote boolean formulas constructed steps pathway 
expressing species produce species tantamount satisfiability boolean constraint ar ap ar ap boolean variables associated respectively 
original need sets boolean variables sets dependency constraints avoid interference conditions 
ffl notion pathway consistency defined satisfiability certain arithmetic formula constructed occurrences species pathway 
essentially formula conjunction formulas pathway step gamma 
delta delta delta arithmetic variables respectively 
simple way proceed fix ordering tasks performed machine 
corresponds choosing resources rules pair tasks assigned machine 
forms basis enumerate procedure 
ordering tasks fixed simple matter determine best start times task 
done manner indicated solve procedure 
important efficiency point choosing precedence tasks new constraints created resources conjunction precedence constraints reduce number possible choices remaining pairs 
assume procedure define cost defines cost way conjunction constraints provides conservative lower bound real cost schedule determined far 
precise definition omitted obtained similar way second program cutting stock example 
solve 
tn cost precedences 
job precedences 
define cost 
tn cost enumerate 
tn generate start times 
tn 
enumerate 
tn resources 
pair tasks assigned machine resources 
solve procedure repeatedly run branch bound framework special minimize predicate mechanism explained obtain best solution possible orderings 
presentation program chosen simply list calls precedences procedure solve focus important procedures program 
real program auxiliary predicate iterate jobs generate calls precedences 
similarly enumerate iterate generate calls resources 
program independent number jobs pattern tasks assigned machines 
similar comments apply programs section 
variations specializations clp approaches problem 
section section presentation discuss problem particular features chip useful 
chip approach time specific practical scheduling problem reported 
focus new feature chip obtain optimal solution particular jobs machine problem remained open 
real scheduling problems involve kinds constraints just mentioned 
example require certain time elapsed completion task commencement 
see complete discussion clp approach general scheduling problem 
rsm lena ai lend dk mapb 
rsm lena lend bj mapb dk lend lena dk lena bj dk choose dk choose bj rsm lena bj lend dk mapb 
application clp due yap important note program considerable simplification yap program 
major omission consideration errors fragment lengths lengths obtained experimentation 
major point yap approach gives robust uniform treatment experimental errors inherent data compared approaches literature 
furthermore shows simple enzyme problem extended number problem variations 
map solution just set answer constraints returned algorithm easy combine maps compare maps verify maps kind flexibility important computational problem just computing consistent map intractable dealing substantial amount data algorithm take account data varieties mapping experiments information specific molecule question 

scheduling class problems number tasks task task duration 
task requires resources performed constraints precedences task performance resource usage 
problem schedule tasks resources efficiently example perform tasks done soon possible 
consider basic job shop scheduling problem number machines sequences tasks task durations machine assigned task 
precedence constraints tasks sequence called job performed sequence order 
resource constraints machine performs task time 
program precedences sets precedence constraints job called equally long lists 
contains task variables values start times 
second list contains durations tasks 
precedences called job 
procedure resources called repeatedly pair tasks performed overlapping durations precedences tail tail precedences tail tail 
precedences 
resources resources problem deals lengths fragments fragments 
consider enzymes 
enzyme partition dna sequence delta delta delta second delta delta delta bm simultaneous enzymes produces partition delta delta delta dk corresponding combining previous partitions 
delta delta delta delta delta delta delta delta delta delta delta delta conversely delta delta delta delta delta delta delta delta delta delta delta delta denote length similarly denote subsequence delta delta delta similarly define problem hand stated multisets fa delta delta delta fb delta delta delta fd delta delta delta dk construct sequences delta delta delta delta delta delta dk delta delta delta dk 
basic algorithm generates delta delta delta order extends partitions invariant property obtained problem definition 
ffl aligned delta delta delta delta delta delta ffl aligned delta delta delta delta delta delta program main procedure solve takes input lists representing arguments outputs remaining arguments 
enumeration done choosing recursive step rsm procedure cases mentioned 
rules rsm 
note middle arguments rsm maintain length subsequences far calls lena lend lend lena holds procedure choose initial chooses fragment call rsm invariant holding 
procedure choose deletes element list returns resultant list 
note rule rsm needed case fragments align extreme ends omitted possibility simplicity 
solve mapb choose initial rsm mapb 
rsm lena lend mapb empty empty empty mapb 
rsm lena lend ai mapb dk lena lend lena dk lena ai dk choose dk choose ai simplicity assume partitions aligned 




cost 
enumerate 

second solution uses special chip constraint element described section 
recall element list expresses th element list second approach problem variables denote configurations chosen 

denote number shelves configuration cost denote wastage configuration required shelves obtained constraints delta delta delta total cost simply cost delta delta delta ost program constraints serve eliminate consideration symmetrical solutions 
group element constraints serve compute variables terms values computed values 
group element constraints computes cost variables terms variables 
enumerate procedure range delta delta delta 
solve run repeatedly search lowest cost 
solve 
cost element 
element 
element 
element 
element 
cost element 
cost element 
cost element 
cost cost cost cost cost cost enumerate 
second program advantages 
apart smaller search space approximately comparison able avoid encountering symmetrical solutions 
timings showed second program ran faster 
comparison exemplifies abovementioned fact way problem modelled greatly affect efficiency 

dna sequencing consider simplified version problem restriction site mapping rsm 
briefly dna sequence finite string letters fa tg restriction enzyme partitions dna sequence certain fragments 
problem reconstruct original dna sequence fragments information obtained experiments 
follows consider abstraction sense unsatisfiability reported tested constraints unsatisfiable 
general primary efficiency issues ffl complete constraint solver 
general tradeoff larger cost complete solver smaller search space solver give rise 
ffl constraints model problem 
special case issue concerns redundant constraints constraints change meaning constraint store 
general redundant constraints slow clp system complete solver 
partial solvers redundant constraints may useful solver case equivalent information constraint store active 
ffl order choose decision variables enumeration 
order dynamically determined 
ffl order enumerate values decision variable 
order dynamically determined 
section outline number clp applications specific combinatorial problem areas 
subsection specified shall assume underlying constraint system integers 

cutting stock describes dimensional cutting stock problem pertaining furniture manufacturing early application chip 
machine cuts board wood number different sized shelves 
machine able cut configurations determines number kind shelf amount wood wasted 
different kinds shelves different configurations 
denote number shelves cut configuration denote wastage configuration denote number shelves required 
problem stated finding configurations required number shelves obtained wastage minimized 
kinds shelves configurations number boards cut fixed 
solutions paraphrase 
denote number boards cut configuration delta delta delta 
requirements number shelves expressed constraints delta delta delta objective function minimized delta delta delta straightforward program representation 
enumerate procedure range 
note solve run repeatedly search solution lowest cost 
solve 
cost 
time 
applications scheduling discussed section 
simple constraint domains model time explored extensively context temporal databases 
situation item data incorporate time interval valid 
simple domains considered riding requirements quick terminating execution queries discussed section 
furthermore restriction arguments tuple time valued arguments constant values 
surveys area integer model time 

combinatorial search problems clp offers easy realization enumeration algorithms solving combinatorial problems 
decision variables delta delta delta xn uses clp program schema form solve 
xn constraints 
xn enumerate 
xn 
implement constrain generate enumeration strategy called implicit enumeration opposed naive enumerate test strategy curtail search space 
refer basic text chapter introductory material clp approach 
schema represent set solutions constraints 
desires optimal solution criterion say solution delta delta delta delta delta delta xn minimizes function cost delta delta delta xn 
simplest strategy obtain solution simply obtain check solution solve 
easy improvement obtained augmenting search branch bound strategy 
briefly cost best solution encountered far stored continuing search constrained find new solutions better cost 
concretely clp systems typically provide predicates minimize solve 
xn cost bestcost similarly maximize solve 
xn cost serves obtain solution explained cost cost bestcost number representing cost best solution far 
initially number sufficiently large number 
assumed procedure solve 
xn cost maintains lower bound variable cost computed values decision variables determined 
minimize procedure essentially behaves repeated invocation goal cost bestcost solve 
xn cost 
general choice suitable cost function difficult 
refer reader text section detailed explanation branch bound clp systems 
constraint domain hand discrete typically finite enumeration cover candidate values sequence delta delta delta xn constraint solving np hard 
turn restricts implementations partial solvers constraints considered active 
recall partial solvers required conservative combination calls puts payoff payoff payoff payoff payoff value put sell payoff value put buy payoff value call buy payoff value call sell payoff 
answer obtained illustrates combinations options tailored produce custom linear piecewise payoff function 
payoff payoff payoff payoff payoff just brief overview core ideas 
important aspects omitted consideration option pricing models details implementing decision support system 
circuit modelling application described advantages clp program concise query language expressive 

temporal reasoning natural common model time arithmetic domain everyday life 
depending application discrete representation integers continuous representation reals may appropriate varying amounts arithmetic signature needed example ordering successor function 
brief discussion assume time linearly ordered universally accepted choice 
temporal logic language expressing time related concepts 
temporal logic adds standard order logic constructs meaning roughly time instant meaning time instant meaning time instant 
language designed horn subset temporal logic meaning function symbols vary time meaning predicate symbols 
shown operational behavior mimicked clp language natural translation predicate receives argument representing time 
time represented represented powerful temporal logic language viewed implemented clp language 
wish manipulate time parameter directly possible conventional temporal logic 
example may wish express durations times 
include signature domain modelling assume time modelled integers 
interest rate 



value type buy sell payoff sign buy sell sign data type payoff sign 
parameters piecewise functions expressed symbolically tables implemented simply clp facts 
sign buy 
sign sell 
data stock 
data call 
data put 
data bond 
program forms basis evaluating option combinations 
direct query evaluates sale call option expires money call value call sell call payoff 
giving answer payoff 
general queries ability reason inequalities 
ask share price value exceed payoff value call sell payoff 
answer constraints returned illustrates piecewise nature model payoff payoff 
complex combinations constructed composing base financial instruments linking constraints 
example strike price share price 
separate different sets answer constraints output 
payoff payoff payoff stock price stock price stock price buy call sell call butterfly 
payoff diagrams presentation due yap clp 
material appeared subsequently implemented system described 
main reasons clp clp particular suitable reasoning option trading complex trading strategies usually formulated rules combinatorial aspect problem ways combining options combination symbolic numeric computation involved developed mathematical valuation models constraints relationships involved option pricing flexible type analysis required 
simple mathematical model valuing options financial instruments stocks bonds linear piecewise functions 
heaviside function ramp function defined follows ae ae gamma payoff function call put options described matrix product creates linear piecewise function payoff theta share price strike price multipliers heaviside ramp functions 
program variables respectively denote stock price exercise price obtained easily 
circuit resistor mult 
circuit mult 
circuit capacitor mult 
circuit series equal equal add circuit circuit 
circuit parallel equal equal add circuit circuit 
close example application mentioning contains explanation technique addresses problems synthesis networks digital signal flow 
clp approach provide concise framework modelling circuits previously done ad hoc manner provides additional functionality relationships opposed values reasoned 
evidence approach practical example modelling executed rate circuit components second rs workstation 

options trading analysis options contracts value contingent value underlying asset 
common type option shares 
call option gives holder right buy fixed number shares fixed exercise price certain maturity expiration date 
conversely put option gives holder right sell fixed price 
option may bought sold 
example consider call option costing gives right purchase shares share period time 
call option sold current market price exercised cost 
price share option may exercised obtain profit share price option account net gain 
specified period call option exercised worthless 
shows payoff diagrams simple model relationship value call option share price 
sell options similar diagrams 
note denotes cost option exercise price 
options combined arbitrary ways form artificial financial instruments 
allows tailor risk return flexible ways 
example butterfly strategy consists buying calls lower strike price higher price selling calls middle strike price profit share stays middle strike price limits loss movement large 
remaining rules combine relationships network resistors 
circuit resistor circuit series circuit circuit 
circuit parallel circuit circuit 
example query circuit series series resistor resistor resistor asks voltage value current value flowing network containing just identical resistors series 
answer additional rules added devices 
example piece wise linear model diode described voltage current relationship gamma gamma gamma captured rules circuit diode 
circuit diode 
circuit diode 
basic idea extended model ac networks 
example suppose wish reason rlc network steady state 
dispense complex numbers representing iy clp term equal re im re im 
add re im re im re re im im 
mult re im re im re im re re re im im im re im re im 
implement basic complex arithmetic operations equality addition multiplication 
consider procedure circuit voltage current values complex numbers new parameter real number angular frequency 
noteworthy significant extension previous program fragment circuit part iii programming applications final part discuss practical clp languages 
format essentially selected list successful applications variety problem domains 
application overview emphasis particular programming paradigm clp features 
useful classify clp applications broadly classes 
class essential clp technique constraints rules obtain transparent representation relationships underlying problem 
constraints provide powerful query language 
class caters problems solved enumeration algorithms combinatorial search problems 
lp aspect clp useful providing enumeration facility constraints serve keep search space manageable 

modelling complex problems consider clp specification language constraints allow declarative interpretation basic relationships rules combine complex relationships 

analysis synthesis analog circuits presentation adapted early application clp 
briefly general methodology representing properties circuits constraints base level describe relationship variables corresponding subsystem ohm law constraints higher level describe interaction subsystems kirchhoff law 
consider program fragment defining procedure circuit specifies electrical network potential difference current respectively 
network specified obvious way term containing functors resistor series parallel 
program rule states required voltage current relationship resistor example instruction clp 
process partially constructed constraint represented accumulator 
solve instructions passes constraint solver 
think linear form accumulator generalization accumulator classical computer architectures accumulating partially constructed constraint number 

parallel implementations briefly outline main works involving clp parallelism 
opportunities parallelism clp languages arise addressed logic programming context parallelism parallelism stream parallelism arise presence potentially computationally costly constraint solver 
area experimental implementation clp language domain fd 
approach pursued development system developed parallel implementations clp languages 
presents parallelization lp language computes linear inequalities reals integers rules local variables deals parallel implementation clp language fd massively parallel simd computers 
basis parallelism nondeterministic choice rules conventional lp parallelism nondeterministic choice values variable 
parallelism logic programming depends heavily notions independence atoms goal 
addresses notion clp context identify notions independence constraint solvers hold advantages parallelism lp fully realized clp languages 
knowledge attempt produce implementation clp language 
works address stream parallelism parallelism constraint solving 
committed choice language crudely characterized committed choice version cal uses constraints domains finite trees booleans real numbers integers 
mainly discusses parallelization basis algorithms core solvers real number boolean constraint domains parallel branch bound method integer solver 
leung addresses incorporation constraint solving committed choice language language andorra model computation 
presents distributed solvers finite domains boolean domain linear inequalities reals 
finite domain solver solver reals simplex algorithm boolean solver unification algorithm 
reports design initial implementation clp execution model inference engine constraint solver compute concurrently asynchronously 
issues addressed backtracking difficult engine solver loosely coupled 
say variable rule local appears body rule head 
constraints unfolded predicate definition imply constraint analyzed 
early describing kinds optimizations discussion 
described machine clam clp defined examined problem special case detecting exploiting existence redundant constraints clp 
reported new algorithms problem special case detecting redundant variables clp 
describes general setting collection techniques entitled refinement removal reordering optimization clp systems 
see overview status clp optimization detailed empirical results 
despite potential optimization reported works lack full implementations leaves open practicality sophisticated optimization techniques clp systems general 

runtime structure clp machine requires basic runtime support wam 
data structures needed routine extension wam usual register stack heap trail organization 
main new structures pertain solver 
variables involved constraints typically solver identifier refer variable location solver data structures 
modifications basic wam architecture typically ffl solver identifiers necessary way index variable constraints involved 
wam structure provides stack locations dynamically created variables remains just tag value structure respectively identify variable solver variable access constraint associated variable 
note basic unification algorithm assuming functors constraint system needs augmented deal new type 
ffl tagged trail mentioned section trail wam merely consists stack addresses reset backtracking 
clp systems general trail store changes constraints 
tagged value trail required 
tags specify operation reversed value component contains old data restored 
ffl time stamped data structures time stamps briefly discussed section 
basic idea data structure representing constraint may go changes new choice point encountered activity 
clearly state structure need choice point 
ffl constraint accumulator constraint typically built basic instruction repeatedly required added store checked consistency 
constraints special added store store recomputed new internal form variables appear parts store referred 
consider sum program 
sequence constraints arises executing goal sum gamma gamma gamma gamma gamma gamma delta delta delta delta delta delta encountering second equation gamma simplifying note variable referred 
equation deleted 
similarly encountering third equation gamma simplifying variable referred deleted 
short equation involving need stored point computation 
add class instructions form add delete informs solver considering constraint associated may delete structures associated clp corresponding instruction delete obvious variant previously described instruction compiling sum example gives init pf solve fail eq init pf delete solve fail eq init pf delete solve fail eq delta delta delta delta delta delta note different set instructions required equation required remaining equations 
iteration needs unrolled produce efficient code 
main challenge special case special case detection special constraints 
address issue 

techniques clp program analysis kinds program analysis required utilize specialized instructions include techniques developed prolog prominently detecting special cases unification deterministic predicates 
algorithms analysis familiar see example 
see example description extend general techniques interpretation applicable lp clp 
considerations require specific kinds analyses 
detecting redundant variables redundant constraints fact done dataflow analysis 
simple method involves unfolding predicate definition typically case detecting redundant variables simply inspecting variables occur unfolded definitions 
detecting redundant constraint essential step de new variable 
direct compilation results 
note rightmost column depicts current state accumulator 
accumulator accumulator accumulator gamma solve eq solve gamma better compilation obtained specialized instruction solve fail eq adds equation exp store exp expression accumulator 
main difference solve eq satisfiability check performed 
example accumulator gamma accumulator gamma solve fail eq add gamma summary special case clp systems general encounter constraints organized form consistency store obvious 
typically happens new variable appears equation example new variables created clp systems 
instructions form solve fail xxx justified 
consider special case example clp program 
sum 
sum sum 
concern constraints added store shown redundant result additions store 
notion redundancy described 
execute goal sum second rule obtain subgoal sum 
continuing execution choices choosing rule obtain new constraint choosing second rule obtain constraint 
case original constraint redundant 
main point example constraint second rule implemented simply test added constraint store 
define new class instructions solve add xxx 
example shows redundant constraints occur clp systems 
apparent difficulty special case problem detecting occurrence 
mention relevant program analysis 
experiments clp shown special case leads substantial efficiency gains compared kinds special cases discussed section 
consider special case 
concern constraints entailed store case eventually redundant case machine revolutionized execution prolog translating programs wam exposed opportunities optimization apparent source level 
benefit designing appropriate machine source language great executing instruction code interpretation lead surprisingly efficient implementations language 
commercial prolog systems compile wam code 
certainly efficiency obtained native code compilation step prolog usable compiling wam 
wam prolog practical global analysis shows potential making major leap 
example fairly efficient analyzers generate high quality native code 
certain examples showed code quality comparable obtained compiler 
case clp opportunities obtaining valuable information analysis greater prolog 
constraint solving step general far involved unification step 

instructions consider design machine instruction set addition basic instruction set wam 
examples clp discussions clp systems general 
details material obtained theses 
requirement basic instruction invoking constraint solver 
format form solve xxx 
xn xxx indicates kind constraint denotes arguments 
typically arguments wam stack locations registers 
example clp instructions form number solver variable 
initializes parametric form contain just number adds entry form pf parametric form stored accumulator pf parametric form store 
accumulator general stores expression exp form delta delta delta instruction solve eq tests consistency exp conjunction store 
consistent solver adds equation store backtracking occurs 
similar instructions inequalities 
important special kinds constraints justify making specialized versions basic instruction 
clearly kinds special cases specific certain constraint domains cases stand 
constraint added store satisfiability check needed 
constraint need added satisfiability conjunction store needs checked 
constraint needs added satisfiability needs checked constraint 
exemplify special case consider adding constraint gamma store 
suppose store pow pow pow pow 
index structure entailed undoing delay upgrade constraint bounded fixed size underlying wakeup system 
total cost operation delaying new constraint processing entailed constraint backtracking delayed constraints proportional number delayed constraints affected operation 

machine section discusses major issues design machine execution clp programs 
primary focus design instruction set emphasis interaction information obtained potential program analyzer 
elements runtime structure mentioned 
general essential features parts machine dealing constraints differ greatly clp languages different constraint domains 
exemplified literature clp chip clp fd 
presentation contains material relevant machines clp languages 
arguing machine right approach place 
machines implementing programming languages reasons 
portability implementation machine needs available platform 
simply convenience easier write native code compiler task reduced compiling machine semantically closer source language 
best machines sit just right point spectrum conceptual clarity high level source language details target machine 
doing express programs exactly right form tackling efficiency issues source language 
example warren pow pow 
index structure downward pointer construct new dw lists corresponding defined delay operation 
backtrack restoring stack backtracking easy requires series pops 
restoring list structure straightforward trailing saving changes performed 
detail operation backtracking pop stack denote constraint just popped 
delete occurrence nodes pointed pointer constraint newly delayed constraint deeper stack need done 
pointer constraint reduced form perform modifications access structure pushed stack 
modifications described involve computing guards pertinent inserting occurrence nodes setting reverse pointers 
note index structure obtained backtracking may structurally previous state 
important depicts logical structure previous state 
illustrates entire runtime structure constraints pow pow stored order 
illustrates structure new input constraint entailed 
summary stack store delayed constraints reduced forms 
access structure maps finite number guards lists delayed constraints 
constraint solver assumed identify conditions entailed 
cost primitive operation delayed constraints delaying constraint upgrading degree delayed constraint including constraint 
delayed goal delayed constraint result inputting new active constraint 
restoring entire runtime structure previous state restoring collection delayed goals delayed constraints earlier collection restoring auxiliary structures accordingly 
follows concentrate delayed constraints mentioned constraint solver operations handle delayed goals guarded clauses essentially 
major structures stack containing delayed constraints 
implementing operation simply requires push operation 
additionally stack contains constraints newer forms constraints deeper stack 
example constraint pow stack input constraint encountered new constraint pow pushed pointer 
general collection delayed constraints contained system described subcollection stacked constraints inbound pointers 
consider operation 
order implement efficiently necessary access structure mapping entailed constraint just delayed constraints affected 
general infinite number possible entailed constraints finite classification required 
guard constraint simply guard short instance wakeup condition obtained renaming distinguished argument variables runtime variables 
template describing collection entailed constraints instances affect sub collection delayed constraints 
example suppose delayed constraint pow degree pow wakeup conditions 
guards need considered 
specify index structure maps delayed constraint doubly linked list occurence nodes 
node contains pointer stack element containing delayed constraint corresponding occurrence node reverse pointer stack element occurrence node 
call list associated delayed constraint dw dw list call node list dw occurrence node 
initially access structure empty 
specifies done basic operations delay push constraint stack wakeup condition associated degree create corresponding guard dw list 
occurrence nodes pointed process entailment say entailed 
find guards implied 
done 
dw list corresponding conditions constraint pointed delete occurrence nodes pointing reverse pointers push new delayed constraint total number occurrence nodes generally larger number delayed constraints 
meta language specify wakeup conditions 
example wakeup condition 

attached bottommost degree represents transition constraint pow ground pow cc cc ground number different 
wakeup condition represents transition degree woken represents fact pow active constraint equivalent 
similarly represents transition active constraint note wakeup condition pow equivalent active 
general certain requirements structure automaton ensure fact define mapping constraints wakeup degrees mapping satisfies certain properties defines partition maps active constraints woken consistent wakeup conditions specifying transitions starting point formalization meta language 
formal aspects scope survey 
summary wakeup systems intuitive way specify organization guard constraints 
wakeup degrees represent various different cases delayed constraint treated differently efficiency reasons 
associated degree number wakeup conditions specify input constraint changes degree delayed constraint 
intended wakeup conditions represent situations constraint solver efficiently update knowledge constraints needed wake delayed constraint 
embarking runtime structure implement delayed constraints pow amplify abovementioned point similarities delayed constraints guarded clauses 
consider guarded clause program pow 
pow ground ground log log 
pow ground ground pow ground ground pow 
pow 
pow program compiled wakeup system intermediate nodes reflect subexpressions guards entailed entire guard entailed 
precisely woken nodes clause body 
wakeup systems express central part implementation flat guarded clauses 
guarded atom viewed clause guarded clause program anonymous predicate wakeup systems applicable implementing constructs 

runtime structure implementational framework context wakeup system 
major operations delayed goals delayed constraints correspond actions delaying backtracking 
adding goal delayed constraint current collection woken pow pow pow pow 
wakeup system pow input constraints encountered runtime structure relate delayed constraint disjunction just remaining kinds constraints awaken 
second require index structure allows immediate access just guard constraints affected result new input constraint 
main challenge maintain structure presence backtracking 
example changes structure adaptation prolog techniques cost proportional number entries incurred guard constraints affected 
material condensation 

wakeup systems purposes section describe instance constraint form delta delta delta ary constraint symbol hand delta delta delta distinguished variables templates arguments constraint determines values delta delta delta 
wakeup degree represents subset constraints wakeup system consists set wakeup degrees degrees organized automaton transitions degrees labelled constraints called wakeup conditions intuitively transition occurs wakeup condition entailed store 
distinguished degree called woken represents active constraints 
proceed example 
consider clp constraint pow see 
wakeup degree may specified means constraints containing delta delta delta describing arguments meta constants delta delta delta describing unspecified values 
example specifies second argument ground 
templates guard constraints 
straightforward tedious omitted see case clp system 
final reconstruction approach added advantage incurring cost backtracking takes place 
summary backtracking clp substantially complex prolog 
useful concepts added prolog machinery follows value trail practice tagged trail systems accommodate variables different types example functor arithmetic variables clp time stamps avoid repeated trailing variable lifetime choice point reconstruction cross trailing 

inference engine section deals extensions basic inference engine logic programming needed constraints 
follows contains main sections 
consider problem incremental algorithm manage collection delayed goals constraints 
problem discussed independently particular constraint domain hand reduces problem determining set guard constraints cf section affected result change constraint store 
section discusses extensions wam design instruction set main elements runtime structure 
give brief discussion parallel implementations 

delaying wakeup goals constraints problem hand determine delayed goal woken passive constraint active 
criterion event guard constraint awaken goal activate constraint guard constraint entailed store follows term delayed constraint synonymous passive constraint emphasize similarities delayed goals 
underlying implementation issue far constraint solver concerned efficiently process just guard constraints affected result new input constraint specifically achieve incrementality cost processing change current collection guard constraints related guard constraints affected change guard constraints 
items necessary achieve 
representation constraints needed guard constraint entailed 
example consider delayed clp constraint pow meaning general awaits grounding variables constrast constraint pow awaits grounding nonzero number 
general delayed constraint conjunction input constraints 
subset guarded clauses problem extended determining clause chosen 
significant changes inference engine needed handle delayed goals guarded clauses 
issues faced extending logic programming systems implement delayed goals guarded clauses see example 
projection large 

backtracking issue restore state constraint solver previous state equivalent state 
common technique prolog trailing constraints modified constraint solver restoration constraints backtracking 
prolog constraints equations terms represented internally bindings variables 
variables implemented pointers bound values backtracking facilitated simple mechanism untagged trail 
identifies set variables bound choice point 
backtracking variables simply reset unbound 
prolog information variables just bound simply variables 
clp general necessary record changes constraints 
prolog variable expression simply instantiated forward execution clp expression may completely changed original form 
example variable may original linear form subsequently 
assuming choice point encountered just change original linear form needs case backtracking 
kind requirement fact holds sample domains exception ft rt requirement trailing mechanism trail value trail variable associated expression 
strictly speaking need trail constraints expression variable associated 
constraints typically represented internally association variable expression 
trailing expressions general far costly trailing variables 
reason useful avoid trailing choice point time variable changes value expression 
standard technique facilitating involves time stamps variable time stamped time changed value choice point time stamped created 
just variable value changed time stamp compared time stamp choice point clearly trailing needed consider cross table solved forms discussed arithmetic domains parametric variables 
index structure maps parametric variable list occurrences solved form 
structure particularly useful crucial efficiency process substituting parametric variable step algorithm 
adds backtracking problem 
straightforward approach simply trail entries table time stamps 
entries general quite large cross table redundant semantic point view useful approach reconstruct table backtracking 
details reconstruction recall means eliminable variables explicitly dereferenced equations solved form 
prolog think stack position variable time stamp 
xn target variables parameter continue denote equation hand contains variable lower priority choose lowest priority rewrite equation form target variable mark equation final substitute equations mark equation final return final equations 
projection algorithm linear equations combination contain fourier step eliminates set constraints computing gamma easy show xc 
clearly repeated applications eliminating non target variables result equivalent set constraints variables target variables 
main problem algorithm worst case size number constraints 
fact precisely jc jc theta jc gamma gamma jc jc gamma 
principle number constraints needed describe inequalities variables var gamma fxg far larger number inequalities practice fourier step generates redundant constraints see discussion redundancy 
proposed tests generated constraints detect eliminate redundant constraints 
output module clp system ideas 
considered general problem disequations 
redundancy elimination methods correct sense fc sequence constraints generated elimination variables delta delta delta survey contains perspectives fourier variable elimination technique 
contains discussion essential technique fourier adapted perform projection domains linear integer constraints boolean domain 
finish mentioning non fourier algorithms 
circumstances especially matrix representing constraints dense algorithm far efficient 
believed typical clp programs produce sparse matrices 
algorithm advantageous property produce approximation projection size obtained example multiplying gamma coefficients respectively adding resulting equations 
constraint redundant gamma fcg 
projecting lin constraints single variable show bounded bound program 
projection provides logical basis eliminating variables accumulated set constraints known referred 
general principles guide design projection algorithms various constraint domains 
primary reason course algorithms intimately related domain hand 
simply resort briefly mentioning existing approaches sample domains 
projection problem particularly simple domain ft result projection substitution obtained solved form described solved form simply mgu equations contain variable example solved form 
equations efficiently stored internally done actual implementations 
solved form obtained needed unification example fully dereferencing term 
direct representation projection variable required printout example exponential size happens example form delta delta delta xn contain occurrences constant solution equations equivalent equations example 
explicit representation projection example obvious variable ground 
projection domain rt done simply presenting equations target variable recursively equations appears 
straightforward presentation general compact 
example equation best 
general problem finding compact representation roughly equivalent problem minimizing states finite state automaton 
problem slightly complicated 
recall equations maintained parametric form eliminable parametric variables 
relatively simple algorithm obtained form gaussian elimination informally described 
assumes ordering variables ensures lower priority variables represented terms higher priority variables 
ordering arbitrary fact target variables higher priority variables 
crucial point efficiency main loop iterates times number number target variables far smaller total number variables system 
details algorithm 
lin relatively simple projection algorithm 
assume inequalities written standard form 
gamma denote subset constraints positive negative coefficients 
denote inequalities containing 
describe algorithm due fourier eliminates variable constraints positive negative coefficient define elim linear variables new constraint 
added feature solved form directly accommodates strict inequalities disequations 
consider domain lin allow inequalities clear represent guard inequality say way entailment refutation detectable simple format representation 
simplex tableau format solved form discussed intuition discussion guard equations substitute case basic 
clear format limit resulting expression order avoid explicitly checking entailed incremental algorithm checking entailment inequalities 
bool similar problem detecting entailment boolean constraints 
case groundness entailment algorithms previously discussed potentially incremental 
prolog iii algorithm fact designed detection groundness criterion 
algorithm represents explicitly variables grounded constraints 
basis algorithm contain basis explicit representation grounded variables 
unification algorithms issue clearly form unifier 
unifier fully simplified form ground variable associated ground value 
summary subsection problem detecting entailment limited just cost determining particular constraint entailed 
incrementality crucial property defined roughly limiting cost depend number guard constraints affected change store 
particular dealing briefly entire collection guard constraints time store changes unacceptable 
section issue related entailment taken 
focussed adapt underlying satisfiability algorithm incremental determining entailment 
consider generic problem independent constraint domain managing delayed goals awake certain constraints entailed 

projection problem hand obtain useful representation projection constraints set variables 
formally problem target variables constraints involving variables express usable form 
define usability formally typically means conciseness readability 
important area output phase clp system desired output running goal projection answer constraints respect goal variables 
useful target variables output depending domain possible 
example output gamma rearrangement involve variable 
area meta programming description current store may wanted manipulation 
example course done efficiently crucial point afford time store changes 
algorithm similarities previous algorithm avoids necessity undoing operations 
operations affect delayed performed special data structure separate strong incrementality claimed replace average case complexity worst case complexity algorithm satisfies criterion perfect incrementality 
goes problem entailing equations give algorithm entailment equations disequations considered constraints 
algorithm different basis discussed involves memoization pairs terms entailments disequations reduction disequation entailment equation entailments 
contain arbitrary equations add algorithm constructs solved form representation equation eliminable variables substituted 
note equations stored equations constraint store considered distinct collection play direct role question satisfiability current store 
example constraint store containing cause guard equation represented 
easy show guard equation entailed iff representation reduces trivial form similarly equation refuted representation form nonzero number 
example guard equation entailed refuted just case ground 
order incrementality argue substitution operation applied guard constraints 
tantamount second assumption argue incrementality algorithm 
believe algorithm incremental 
move domain lin allow equations guard constraints proceed discussion obtain incremental algorithm requirement constraint store contains implicit equalities explicitly represented equations 
easy show entailment guard equation need checked representation trivial 
argument incrementality essentially holds provided cost computing implicit equalities sufficiently low 
main works detection implicit equalities clp systems lin existence implicit equalities detected appearance equation special kind simplex tableau satisfiability checking process 
equation indicates implicit equalities pivoting turn give rise special equations generally required find 
important characteristic algorithm extra cost incurred proportional number implicit equalities 
method clp prolog iii 
chip uses method 
method solved form restrictive usual simplex solved form 
equation form contribute implicit equality tableau solved form implies implicit equalities 
basic idea maintain constraints solved form new constraint encountered search implicit equalities limited equalities entailed store presence inequalities 
example constraint store entails implicit equality 
clashes sort 
solved forms fact solution forms 
implied equations congruence closure treating features partial functions analogously rule algorithm rt summary subsection important property algorithms decide satisfiability average case behavior 
important crucially algorithm incremental 
goal common technique solved form representation satisfiable constraints 

entailment satisfiable guard constraints constraint entailed new constraint problem hand determine subset constraints entailed consider problem detecting groundness strictly speaking entailment problem 
essentially problem detecting groundness specific value entailment problem 
follows distinction unimportant 
rule thumb determine entailment algorithm incremental sense discussed earlier 
important factor number constraints entailed change store number constraints entailed 
algorithm able ignore constraints costs incurred depend number entailed constraints opposed total number guard constraints 
case incremental satisfiability property incremental entailment crucial implementation practical clp systems 
briefly discuss modifications previously discussed algorithms satisfiability provide incremental entailment 
consider domain ft suppose contains guard constraints form ground term add standard implementation unification algorithm index structure mapping variables just guard constraints involve 
see detailed description 
add process constructing solved form check groundness variables bound easily detectable 
gives rise incremental algorithm guard constraints inspected just ground entire collection just satisfiability testing entailment essentially domains rt feat works addressed problem context clp system slightly differing constraint domains 
discuss terms rt modifications works apply ft theoretical foundation built 
proposes concrete algorithm roughly follows entailed constraint added constraint store satisfiability tester capability detecting entailed inconsistent detected essentially simplified form stored effect adding undone 
time constraint added affects entailment test repeated 
mentioned discussion essentially apply guard constraints form ground 
boolean domain boolean unification algorithms conform structure algorithm 
unification algorithm essentially due boole borrow presentation 
loss generality assume constraints form delta delta delta xn variables assuming rewrite form delta delta delta xn gamma xn phi delta delta delta xn gamma problem reduced delta delta delta xn gamma delta delta delta xn gamma contains variable 
equation satisfiable assignment xn delta delta delta xn gamma phi delta delta delta xn gamma yn new variable describes possible solutions xn reduction clearly repeatedly applied left straightforward problem deciding satisfiability equations form phi ground 
unifier desired simply collecting substituting assigned variables assignments xn 
key efficiency problem course variable elimination process gives rise larger expressions increase exponential number eliminated variables worst case 
algorithm satisfies structure algorithm satisfy assumption size expressions obtained substitution general argument incrementality apply 
despite fact boole dates far back method example chip 
unification algorithm due adapt presentation 
delta delta delta xn equation considered 
denote solution 
unifier simply new variables 
basic efficiency problem course determine obtained unifiers slightly larger contrast boole method 
method provides way extending constructive satisfiability test satisfiability test incremental form 
method knowledge clp languages 
algorithms testing satisfiability boolean constraints considerably different algorithm 
basis algorithm produces basis space boolean constraints implied constraint store 
solved form solution form 
remaining algorithms mentioned previous subsection solved form 
algorithm prolog iii retains set literals implied true constraints normal form guarantee solvability tested 
enumeration algorithms behavior exhibit solution may retain information compute solved form 
domain feature trees feat equations occur variables 
algorithm address problem 
existing algorithms employ solved form implied equations variables explicit ffl substitution expressions eliminable variables largely determine size size independent size ffl number occurrences new eliminable variable largely determines cost substituting small comparison size domain ft provides particularly example solved form basic algorithm incremental 
consider standard implementation location variable implemented pointers 
solved form new constraint really obtain eliminable case bound variables pointers substitution expressions 
satisfiable obtain new equations just pointer setting substitution expression required done 
words cost pointer algorithm focussed determining satisfiability extracting new equations contrast step global substitution new equations incurs cost 
size large obtained equations may 
example contained just gammav gammaw gammau big rearrangement obtained new equation simply 
substitution phase new equation enlarge equations temporarily rearrangement needed equation substituted 
general beliefs hold practice algorithm behaves incrementally 
consider domain rt universally solved form due ft important change constraints represented form delta delta delta xn arbitrary term structure 
solved form differs ft contain variables algorithm directly applicable 
easy show constraint satisfiable iff solved form solved form fairly explicit representation set solutions explicit solution forms ft 
straightforward satisfiability algorithm roughly follows 
stand variable stand non variable terms 
perform rewrite rules applicable 
discard replace replace replace delta delta delta delta delta delta equations replace false entire collection constraints unsatisfiable replace pair equations say bigger termination needs argued leave details 
discuss algorithms fit exactly algorithm employ solved form 
consider simplex algorithm domain lin basic step pivoting operation algorithm essentially algorithm 
arguments incrementality algorithm apply 
main difference algorithm general pivoting operations required produce final solved form 
empirical evidence clp systems shown number pivoting operations small 
ables numbers column vector nonnegative 
domains unitary equality theory standard representation mgu case ft corresponds elementary equality theory 
word equations associated infinitary theory unification algorithm equations may terminate 
solved form word equations closed form solution matter known 
kinds solved form examples solution forms format set solutions constraints evident 
instance variables determines values gives solution 
set instances gives set solutions 
simplex format solution form choice basis variables depicts just particular solution 
important property solution forms just solved forms define convenient representation projection solution space respect set variables 
specifically variable equated substitution expression containing parametric variables variables projections entire space 
property turn aids incrementality show sample domains 
examples satisfiable constraint solved form new constraint hand 
ft substitution expression variable simply eliminable expression equated solved form mapping generalized terms obvious way 
similarly define mapping linear expressions replacing eliminable variables substitution expressions collecting terms 
domain lin case simplex form substitution expression variable simply basic expression obtained writing unique equation containing subject 
mapping generalized linear expression obvious way 
summary solution form defines mapping map expression equivalent form free eliminable variables 
basic step satisfiability algorithm solution form essentially 
algorithm 
replace newly considered constraint substitution defined 
write equations form involves choosing rearranging terms 
unsatisfiability detected stage 
previous step succeeds new equations substitute occurrences 
simply add new equations obtain solution form note eliminable variables substitution expressions needed ensure new equations solved form ensure augmented new equations remains solution form 
belief methodology leads incremental algorithm believing cost dealing closely related size small average large average 
turn believing davis putnam variable elimination 
essential idea reduces normal form representation smaller problems variable 
binary decision diagrams provide efficient representation 
boolean solvers chip example uses variable elimination diagrams 
related technique enumeration propagation 
constraints expressed conjunction simple constraints local propagation simplifies conjunction enumeration step 
see example 
method prolog iii modification sl resolution main element elimination redundant expressions 
technique comes operations research 
boolean formula restated arithmetic form variables constrained 
standard techniques integer programming example cutting planes 
see discussion technique 
technique clp systems 
development adaptation buchberger basis algorithm boolean algebras cal class algorithms perform boolean unification see survey example 
satisfiability testing part problem addressed discuss algorithms section 
satisfiability problem feature trees essentially satisfiability problem rational trees provided number features may occur bounded known constant 
generally bounding constant determined compile time 
different sort constraints variable clash way different function symbols terms rt clash 
equation feature tree variables sort induces equations subtrees determined features variables way occurs rt main difference sorts features may undetermined roughly unbound feat 
satisfiability incremental alluded crucial algorithm determines satisfiability tentatively new constraint store incremental 
example linear time algorithm satisfiability problem get 
consider sequence constraints delta delta delta approximately equal size naive application linear time algorithm decide delta delta delta delta delta delta incur cost proportional nk average 
contrast perfectly incremental algorithm discussed section cost nk average 
practice algorithms represent constraints kind solved form format satisfiability constraints evident 
satisfiability problem essentially reducibility solved form 
example standard unification algorithms ft represent constraints variant mgu form delta delta delta xn denotes term structure containing variables variable appears similarly linear equations represented parametric form le delta delta delta xn le le denotes linear expression containing variables variable appears examples call eliminable variables parametric variables 
linear inequalities lin simplex algorithm represents constraints theta matrix form contains theta identity submatrix defining basis vari inequalities enjoying faster gaussian elimination algorithm equations enduring cost communication kinds algorithms 
elements chip solver described 
disequality constraints handled entailment corresponding equation discussed section independence negative constraints holds 
domain word equations algorithm known efficient algorithm known 
fact general problem easily provable np hard known np 
efficient algorithm known basic structure algorithm uses far better bound termination 
systems word equations prolog iii example resort partial constraint solving standard delay technique lengths word variables 
rajasekar string logic programs uses partial solution word equations 
solutions equations lengths word variables appearing constraint word equation solved 
word equations satisfiability problem finite domains fd np hard 
partial constraint solving required typical approach 
attach variable data structure representing dom current possible values clearly dom superset projection space define min max smallest largest numbers dom respectively 
assume constraint written inequality form disequality form equation form variables number 
clearly constraint fd rewritten conjunction constraints 
algorithm considers constraint time main phases 
performs action determined form constraint constraints ensure min max modifying dom dom appropriately ensure min max consider subcases dom dom fl constraint reduces true dom fng remove dom similarly case dom singleton need done simple dom fng dom dom dom dom ensure max min min min max max 
time steps domain variable empty unsatisfiability detected 
second phase algorithm dom changed action steps constraints current gave rise action contain re considered action 
termination course assured simply domains finite 
domain boolean algebra bool variety techniques testing satisfiability 
problem np complete expected perform efficiently constraints 
early technique pioneered choice data structure depend size finite domains 
example small domains characteristic vector appropriate 
case simply remove dom elements bigger max remove dom elements smaller min 
omit details similar operations discussion 
singletons clearly constraint reduces true false 
additional term extra cost denotes extra cost incurred line algorithm best batch algorithm 
possible definition incremental algorithm clp system simply extra cost factor negligible 
follows shall tacitly bear mind expression obtain rough definition incrementality defined incrementality collection operations review operations individually discuss incrementality isolation 
oversimplification example shown standard unification problem remain linear backtracking considered 
general simply complex survey article 

satisfiability non incremental consider basic problem determining satisfiability constraints independent requirement incrementality 
see brief tour sample domains dominant criterion system implementers worst case time complexity algorithm 
domain ft linear time algorithms known rt best known algorithms linear time 
prolog systems implement algorithm best case complexity unification ft linear case unification rt done inspecting parts terms unified 
practice prolog systems really implementations clp rt clp ft 
fact prolog systems choose straightforward algorithms slower worst case linear time algorithms 
reason choice algorithms quadratic time slower worst case belief algorithms faster average 
arithmetic domain straightforward algorithm gaussian elimination quadratic worst case complexity 
general domain lin polynomial time algorithms known algorithms practical clp systems 
simplex algorithm see 
despite exponential time worst case complexity basis algorithm 
simplex algorithm works non negative numbers non strict inequalities extended clp systems 
extension straightforward principle implementations carefully engineered avoid significant overhead 
main differences simplex solvers clp systems specific realization basic algorithm 
example clp system uses floating point representation numbers solvers chip prolog iii exact precision rational number arithmetic 
example clp system major design decision separately deal equations similar notions non clp literature see bibliography 
realized simply omitting occur check operation standard unification algorithm ft prolog systems perform omission naively obtain incomplete algorithm may terminate certain cases 
cases considered pathological ignored 
systems guarantee termination slightly higher cost enjoy new feature cyclic data structures 
ffl add new constraint ffl set backtrack point associate current state system ffl backtrack previous backtrack point return state system associated backtrack point ffl project fixed set variables 
operations produce response constraint solver 
consider application sequence operations state delta denote updated state delta sequence responses operations 
follows shall concerned average cost computing standard definitions cost parameterized distribution sequences operations see example 
average cost assuming true distribution distribution reflects occurs practice 
distribution known hypotheses 
example identify typical occurring operation sequences approximate true distribution accordingly 
informal definitions intended guide opposed formal tool cost analysis 
expression exp denoting function define av exp average value exp sequences operations note definition average dependent distribution example cost denote cost computing fl algorithm fixed sequence av cost denotes average cost computing fl delta shorthand fl gamma 
denote algorithm applies sequence operations initial state giving response constraint solver necessarily computing new state 
batch line version constraint solver 
follows discuss means algorithm incremental relative algorithm intuitively represents best available batch algorithm operations 
extreme consider algorithm non incremental relative average cost applying extra operation delta better cost straightforward approach express av cost delta av cost extreme consider algorithm perfectly incremental relative cost worse words cost incurred incremental nature algorithm 
express av cost fl gamma cost delta av cost general algorithm lies extremes 
example perfectly incremental indicated cost formula av cost fl gamma cost delta av cost extra cost part ii implementation issues main innovation required implement clp system clearly manipulation constraints 
main focus part survey constraint solver operations described section 
section considers problem extending lp inference engine deal constraints 
discussion tied particular constraint domain 
important note algorithms data structures part view top systems particular systems backtracking 
little experience implementing bottom clp systems discuss 
algorithms discuss modification bottom systems 

algorithms constraint solving view operational semantics part operations involving constraints implemented 
include satisfiability test implement consistent infer entailment test implement guarded goals projection constraint store set variables compute answer constraint final state 
constraint solver able undo effects adding constraints inference engine backtracks 
section discuss core efficiency issues implementation operations 

incrementality folklore clp algorithms clp implementations incremental order practical 
prescription totally satisfactory term incremental different senses 
hand incrementality refer nature algorithm 
algorithm incremental accumulates internal state new input processed combination internal state 
algorithms called line algorithms 
hand incrementality refer performance algorithm 
section serves clarify notion incrementality prelude discussion algorithms subsections 
offer formal definition incrementality 
abstracting away inference engine operational semantics leave simply constraint solver operations 
consider state constraint solver consist constraint store collection constraints entailed backtrack points 
initial state denoted fl constraints backtrack points 
constraint solver reacts sequence operations results new state response 
recall operations clp languages ffl augment obtain new store determine new store satisfiable determine constraints implied new store approach adapt approach mathematical programming operations research employ objective function 
optimization primitive added language compute optimal value objective function chip cc fd primitives non logical behavior 
papers discuss optimization primitives logical characterization minimum value holds iff optimization primitives implemented branch bound approach pruning computation tree current minimum 
similar behavior obtained constructive negation logical formulation special purpose implementation efficient 
gives completeness result implementation kunen semantics negation 
second approach admit constraints required satisfied solution express preference solutions satisfy 
constraints called soft constraints 
developed approach hierarchical constraint logic programming 
soft constraints different strengths constraints accumulated derivation form constraint hierarchy strengths 
possible ways compare solutions constraint hierarchies different methods suitable different problems 
hierarchy dictates number weak constraints ruled stronger constraint 
example default behavior expressed program weak constraints ruled stronger constraints non default behavior required 
restriction best solutions constraint hierarchy viewed form circumscription 
approaches programming advantages certain applications problems general purpose methods 
approach works natural choice objective function suggested problem general natural choice 
second approach provides higher level expression preference easily fine tuned produce exponential number best answers carefully 
approaches advantages disadvantages explicit respectively implicit representations preference 
approach difficult reflect intended preferences 
second approach easier reflect intended preferences harder detect inconsistency preferences 
possible weight soft constraints provides combination approaches 
discuss minimization maximization similar 
upper lower bounds value variable indexical terms dom max min respectively 
indexical constraints operational semantics constraint defines method propagation 
example constraint max continually enforces upper bound equal upper bound behavior obtained finite domain solver constraint advantage indexical constraints greater control propagation propagate changes lower bound avoid indexical constraints 
discussion implementation indexical constraints 
application constraint solver boolean constraints describe application section 
negation treatments negation logic programming lift readily constraint logic programming minor adjustments necessary 
semantics programs negation essentially propositional collection ground instances program rules 
perfect model founded model stable model fitting fixedpoint semantics name fall category 
grounding variables clp rules elements domain terms deletion grounded rules constraints evaluate false produces desired propositional rules see example 
declarative semantics clark completion program extend clp counterpart comp satisfaction complete 
interestingly necessary consider complete theory domain equivalence valued logical consequences consequences finite iterations fitting phi operator shown kunen continues hold clp programs 
sldnf resolution variants relatively untouched lifting clp programs course consistency test unification 
main modification groundness replaced concept variable determined current constraints see section 
example safe computation rule may select non ground negated atom provided variables atom determined current collection constraints 
similarly definition allowed rule clp program requires variable appear positive literal body determined constraints body 
modifications various soundness completeness results sldnf resolution comp extend easily ideal clp systems 
alternative implementation negation constructive negation expanded applied clp programs stuckey gave completeness result method 

preferred solutions desirable express ordering preference solutions goal 
provide basis computing best solutions query 
example extension allow arbitrary order formulas bodies rules 
convex hull regions defined constraints approximation 
note constructive disjunction behavior obtained clauses methods 
second category mention constructs finite domain solver chip 
element expresses th element list operationally allows constraints index element list reflected constraints 
example constrained element constrain similarly constrained constrained 
declaratively cumulative constraint expresses collection linear inequalities arguments 
problems expressed integer programming problems expressed cumulative 
operationally behaves somewhat differently way chip usually treat inequalities 

user defined constraints complex constraints generally built language 
proposals extend clp languages allow user define new constraints inference rules specifying new constraints react constraint store 
basic approach guarded clauses 
new constraint predicate defined guarded clauses guards specify cases constraint simplified body equivalent conjunction constraints 
ground similar construct guard constraint straightforward implement local propagation propagation ground values 
give example section examples 
general forms propagation expressed guarded clauses 
seen extension method 
new constraints occur predicates guarded rules called constraint handling rules simplify new constraints 
guarded rules may atoms head 
execution matches head collection constraint atoms goal reduces equivalent conjunction constraints 
method appears able express powerful solving methods guarded clauses 
example transitivity user defined constraint leq specified rule leq leq 
true leq 
clear express atom head guarded clause 
drawback having multiple atoms inefficiency 
particular clear constraint handling rules produce incremental sense defined section constraint solvers simple cases 
different approach proposes indexical terms refer aspects state constraint solver providing limited form reflection constraints containing terms called indexical constraints indexical constraints user defined constraints built 
specifically discusses language finite domains access current domain approach called glass box approach 
guarded atoms generally guarded goals take form constraint goal 
available execution implied current active constraints 
call guard constraint delayed goal 
underlying mechanisms similar guarded atoms guarded rules differ substantially linguistic features guarded atoms combined conjunctively guards guarded rules combined disjunctively 

complex constraints language constructs said simply complex constraints added clp languages 
classify follows implement boolean combinations generally simple constraints describe ad hoc application specific relation 
falling category implementations constraint disjunction called constructive disjunction cardinality operator 
second category fall element constraint cumulative constraint 
constraints accounted operational semantics section considered passive constraints useful view additions better known constraint domain arose 
cardinality operator express boolean combination constraints 
combinator form constraints variables 
expresses number constraints true lies value value lower upper bound respectively 
constraining combinator represents disjunction constraints constraining combinator represents conjunction negations constraints 
cardinality combinator implemented testing constraints entailed inconsistent constraint store comparing numbers entailed inconsistent constraints values ground cardinality constraint produce constraint variables 
example constraint inconsistent constrained gamma 
constraint languages disjunction intended disjunction represented pair clauses simple clp language representation forces choice disjuncts 
constructive disjunction refers direct disjunctive constraint immediately making choice 
active constraint computed safe approximation disjunction context current constraint store constraint domain fd suggests possible approximations approximating constraint cc domain variable accurately approximating constraint interval constraints variable 
disjunction approximations easily approximated active constraint 
linear arithmetic suggests permit meta level constraint ground 

linguistic extensions discuss section additional linguistic features top clp languages 

shrinking computation tree aim transitions extract information reasonable passive constraints branching transitions reduced 
techniques proposed achieving result 
suggested information extracted atoms state 
constraint extracted approximation answers atom 
operation expressed additional transition rule 
ha si ha ci extract extract function satisfying ac evaluation extract performed run time involves approximate execution ha example defines facts constraint extracted extract 
widespread technique modify order atoms selected 
clp systems employ prolog left right computation rule 
improves programmability providing predictable flow control 
appropriate flow control data dependent complex example combinatorial search problems greater flexibility required 
solution problem incorporate data dependent computation rule language 
andorra principle involves selecting determinate atoms possible 
determinate atom atom gives rise ris transition 
second approach allow programmer annotate parts program atoms predicates clauses 
provide flexible computation rule programmed 
approach pioneered prolog ii mu prolog 
automatic annotation programs brings approach closer 
third approach introduce constructs concurrent logic programming language 
basically varieties approach guarded rules guarded atoms 
introduces committed choice aspect language variant second approach 
approaches originated conventional logic programs ideas lift constraint logic programs proposals ideas 
potential problem guarded rules completeness operational semantics respect logical semantics program lost 
incompleteness shown avoided alps modulo infinitely delayed atoms heavily reliant determinacy 
smolka discusses language guarded rules extends alps methodology extending predicate definition new guarded rules completeness retained execution involve indeterminate committed choice 
andorra kernel language akl combines andorra principle guarded rules 
interest providing language subsumes expressive power languages clp languages 
system ha ci ha ask ask tell rule renamed new variables predicate symbol ca tell 
roughly speaking transition occur rule provided accumulated constraints imply ask constraint contradict tell constraint 
languages ask constraint synchronization 
shown languages strictly expressive ask tell languages 
operational semantics completely faithful real execution language possible atoms rewritten simultaneously execution environment concurrency 
semantics allows rewritings interleaved 
true concurrency semantics graph rewriting 
ask tell programs monotonicity stability property ha ci ha ha ha property provides simple solutions problems distributed computing related reliability 
looked general framework stability advantage languages languages programs conventional languages concurrency stable 
interesting note notion global failure represented section state fail destroys stability 
course pragmatic reasons wanting avoid notion concurrent language 
framework permits non monotonic languages discussed 
program determinate reachable state determinate state determinate selected atom gives rise transition 
consequently initial state fair derivation rewrites atoms rules derivation fails 
non failed derivations determinate programs initial state differ order rewriting renaming rules 
substantial parts programs determinate interest determinate programs arises elegant semantics programs closure operators 
collection atoms semantics function pa gamma ha ci ha free variables ha ci ha final state 
semantics extended compositional fully semantics arbitrary programs 
semantics traces 
determinate programs clean application classical logical semantics program 
ha ci ha gamma free variables ha ci 
cases execution guaranteed suspend atom indefinitely soundness completeness results success failure hold see section 
programs consider determinate programs characterized syntactically condition pair rules renamed apart identical heads ask tell ask tell program ask ask tell ask ask tell 
languages procedures hidden process algebra formulations restriction initial states class determinate programs larger easily characterized 
resulting program terminates ignored capability constraints answers 
comparatively little done nuts bolts implementing bottom execution clp programs addressing constraint domain lin suggested intervals computed projection collection constraints basis indexing constrained variables 
different data structures originally developed spatial databases computational geometry proposed appropriate indexing 
new data structure minimizes accesses secondary storage 
sort join algorithm joins constrained variables 
provides query optimization methodology conjunctive queries balance cost constraint manipulation cost traditional database operations 

concurrent constraint logic programming concurrent programming languages languages allow description collections processes may interact 
concurrent constraint logic programming languages communication synchronization performed asserting testing constraints 
operational semantics languages quite similar top execution described section 
different context results lesser importance corresponding logical semantics 
discussion consider flat ask tell languages defined ideas 
restrict attention languages committed choice nondeterminism called don care nondeterminism general languages discussed section 
details languages see 
just prolog viewed kind clp language obtained particular choice constraint domain concurrent logic languages viewed concurrent clp languages program rule takes form ask tell atom collection atoms ask tell constraints 
treatments concurrent constraint languages employ language process algebra involving ask tell primitives syntax emphasize similarities clp languages 
sake brevity simpler transition system describe operational semantics transition system section 
implemented languages pragmatic compromises testing consistency implication reflected transition system 
states transition system form ha ci collection atoms collection constraints 
state initial state 
transitions transition concurrent prolog ask tell language shows fit inside framework 
generated fair executions independent order transitions applied regarded result bottom execution 
initial set facts program result fair bottom execution ss hhp ii execution delta delta delta delta delta delta terminates xm say finitary finite initial set facts fair execution execution non terminating program finitary initial set finite 
example 
consider program constraint domain lin straightforward bottom computation gives fp fp terminate 
lfp fp necessary technique test new fact subsumed current set facts accumulate facts 
fact subsumed facts respect transitions modified bottom execution model reduce reduce eliminates elements subsumed execution model finitary program terminates finite initial set unfortunately checking subsumption computationally expensive general 
constraint domain satisfy independence negated constraints problem showing new fact subsumed np hard see proof constraint domain 
constraint domains independence negated constraints problem bad new fact needs checked fact time 
classical database optimizations difficult independence negated constraints 
pragmatic approach problem subsumption lin 
avoids problem subsumption allowing ground facts database intermediate computations 
subsumption problem execution terminate example finitary 
approach restrict constraint domains permit computation finitely representable relations finitely representable relations 
requirement slightly weaker requiring programs finitary clear practical difference 
regrettably constraint domains satisfy condition limited expressive power 
alternative take advantage specific query class queries 
transformation technique magic templates produces program mg equivalent specific query 
techniques attempt limit execution placing constraints appropriate points program 
analyses check execution results 
results theorem equivalent results listed require solution compactness 
fact properties shown equivalent sc second condition solution compactness mentioned earlier sc needed 
soundness results half replaced omit assumption order language constraints see section results soundness half replacing necessary continue hold 
strong form completeness successful derivations result provides interesting departure conventional logic programming theory 
shows clp necessary general consider combine successful derivations answers establish holds successful derivation necessary standard logic programming 
results theorem direct liftings results logic programming theory 
clp scheme provides framework lifting results lp clp trivial 
replacing herbrand universe arbitrary constraint domain constraint satisfaction clark equality theory corresponding satisfaction complete theory results proofs lift lp clp 
lifting discussed greater detail 
furthermore operational aspects lp prolog interpreted logical operations consequently operations implementations lift clp 
early example matching various lp systems ghc nu prolog basis affecting computation rule corresponding operation clp constraint entailment 
philosophy clp scheme gives primacy structure computation performed prominence theory followed approach 
possible start satisfaction complete theory see example structure 
arbitrarily choose model structure results apply 
variation considers collection structures defines consistent hold iff structure weaker forms soundness completeness successful derivations apply case 

bottom execution bottom execution main database applications 
set time processing limits number accesses secondary storage comparison tuple time processing top execution simple semantics gives great scope query optimization 
bottom execution formalized transition system 
rule form set facts transition fh elements brief set rule defined section 
execution sequence transitions 
fair rule applied infinitely 
limit ground instances sets exists unsatisfiable 
ground derivation derivation composed define sets aspects operational semantics 
success set ss collects answer constraints simple goals 
finite failure set ff collects set simple goals finitely failed 
ground finite failure set gff collects set grounded atoms fair ground derivations failed 
ss fp hp gamma ff fp fair derivation hp 
gff fp fair ground derivation hp 

soundness completeness results main relationships declarative semantics top operational semantics 
keep things simple consider ideal clp systems 
results hold generally 
soundness results hold clp system restrictions place consistent infer 
completeness results successful derivations require clp system progressive 
theorem 
consider program clp language determined tuple sigma correspond executing ideal clp system 

ss lfp ss lm 

goal successful derivation answer constraint 
suppose satisfaction complete wrt finite computation tree answer constraints delta delta delta 
derivations goal answer constraints addition independence negated constraints result holds disjunction 

suppose satisfaction complete wrt delta delta delta computation tree answer constraints possibly delta delta delta delta delta delta 
suppose satisfaction complete wrt goal finitely failed iff 
gm bd gamma gff 

suppose solution compact 
bd gamma 
suppose solution compact 
canonical iff fh collection atoms constraints part state execution 
major implemented clp systems quick checking progressive ideal 
derivation sequence transitions ha delta delta delta ha delta delta delta 
state rewritten called final state 
derivation successful finite final state form si 
goal free variables initiates derivation produces final state si 
gamma called answer constraint derivation 
derivation failed finite final state fail 
derivation fair failed rewritten transition 
computation rule fair gives rise fair derivations 
goal finitely failed fair computation rule derivation ideal clp system failed 
shown goal finitely failed fair derivation ideal clp system failed 
derivation finite final state form ha si 
computation tree goal program clp system tree nodes labelled states edges labelled root labelled hg node outgoing edges label node labelled state outgoing edge labelled node exactly child state labelling child obtained transition respectively node labelled state outgoing edge labelled node child rule state labelling child state obtained transition rule edge corresponding transition uses atom constraint selected computation rule 
branch computation tree derivation computation rule derivation rule branch corresponding computation tree 
different computation rules give rise computation trees radically different sizes 
existing clp languages computation rules prolog left right computation rule fair 
discuss linguistic features intended improve rule section 
problem finding answers query seen problem searching computation tree 
clp languages employ depth search chronological backtracking prolog suggestions dependency directed backtracking 
depth search incomplete infinite trees answers computed 
depth search incorporated semantics way done prolog see example go details 
section discuss class clp languages top execution similar outlined backtracking 
consider transition ha si ha set equations 
variable occurring contains equation constant grounds variables constraint solver 
transitions ha si fail language chip infer performs obvious inferences 
example infer 
note formulate finite domain constraint solving chip having passive constraints having incomplete test consistency 
formulation give reflect systems closely 
similarly languages employing interval arithmetic real numbers prolog intervals active constraints constraints passive 
case infer repeatedly computes smaller intervals variables constraints terminating smaller interval derived modulo precision arithmetic 
execution language constructs cardinality operator constructive disjunction special purpose constructs example understood transitions constructs viewed part language constraints 
generally active constraints determined syntactically 
examples prolog equations active clp linear constraints active finite domains chip unary constraints constraints just variable active interval arithmetic prolog intervals active 
stronger collection active constraints earlier failure detected searching necessary 
mind wish infer strong possible active constraint infer possible possible generally preferred computational cost powerful infer function greater savings achieved limiting search 
clp system determined constraint domain detailed operational semantics 
involves computation rule definitions consistent infer 
define significant properties clp systems 
distinguish class systems passive constraints play role global consistency test complete 
systems correspond systems treated 
definition 
ris 
cis 
say clp system quick checking operational semantics described ris cis clp system progressive state nonempty collection atoms derivation state fails contains transition contains transition 
clp system ideal quick checking progressive infer defined infer consistent holds iff quick checking system inference new active constraints performed test consistency time collection constraints constraint solver changed 
limits consistent infer finds inconsistency soon possible 
progressive system infinitely ignore example clp linear constraints active non linear constraints passive take gamma finite collection active constraints implies constraints stronger transitions transition system ha si ha selected computation rule atom rule renamed new variables predicate symbol 
expression abbreviation conjunction equations corresponding arguments say rewritten transition 
ha si fail selected computation rule atom rule different predicate symbols 
ha si ha ci selected computation rule constraint 
ha si ha infer 
ha si ha si consistent 
ha si fail consistent 
transitions arise resolution transitions introduce constraints constraint solver transitions test active constraints consistent transitions infer active constraints modify passive constraints current collection constraints 
write refer transition arbitrary type 
predicate consistent expresses test consistency usually defined consistent iff complete consistency test 
systems may employ conservative incomplete partial test consistent holds consistent holds example system cal computes domain real numbers tests consistency domain complex numbers 
function infer computes current sets constraints new set active constraints passive constraints generally understood abstracting relaxing presence obtain active constraints 
added form simplified require information lost guessed infer 
role infer plays varies widely system system 
prolog passive constraints define infer 
clp non linear constraints passive infer simply passes linearized version constraint constraint linear context deletes constraint example infer 
proposition 
clp programs set facts constraint domain corresponding theory ffl lfp lfp ffl lm fh fh ffl lm lm lfp ffl gm gfp ffl lm ffl hhp ii hhp ii lfp ffl iff need terminology 
said canonical iff gfp 
canonical logic programs constraint logic programs studied showed logic program equivalent wrt success finite failure sets canonical logic program 
proof constructive subsequently provided algorithm generate canonical logic program kinds results traditional logic programming results extend clp straightforward way 

top execution phrase top execution covers multitude operational models 
fairly general framework operational semantics describe operational semantics major clp systems 
operational semantics transition system states tuples ha si multiset atoms constraints multisets constraints 
constraints referred constraint store implementations acted constraint solver 
intuitively collection unseen atoms constraints collection constraints playing active role awake collection constraints playing passive role asleep 
state denoted fail 
express details operational semantics necessary represent collections atoms constraints precisely 
example express left right prolog execution order sequence atoms multiset 
concerned details 
assume computation rule selects transition type appropriate element necessary state transition system parameterized predicate consistent function infer discuss 
initial goal execution represented state hg proof performed general class logic programs negation 
computation rule convenient fiction abstracts behavior clp system 
realistic computation rule depend factors state example history computation 
ignore possibilities simplicity 
denote satisfaction complete theory 
usual logical semantics models models model formula subset ordering denoted lm greatest denoted gm 
solution query valuation lm 

fixedpoint semantics fixedpoint semantics step consequence functions closure operator generated functions map interpretations 
set interpretations forms complete lattice subset ordering functions continuous bd fp rule valuation ng closure operator generated represents deductive closure rules id identity function define 
fixedpoint id greater fixedpoint function defined sets facts form complete lattice subset ordering 
denote closure operator generated hhp ii 
functions continuous 
fp rule rule facts renamed apart gamma denote fixedpoint function lfp greatest fixedpoint gfp 
exist functions interest monotonic functions complete lattices 
function mapping interpretations interpretations define upward downward iteration follows 
ff ff fi ff fi ff fi limit ordinal bd ff ff fi ff fi ff fi limit ordinal take semantics lfp lfp 
functions involved related way 
consequently lfp lfp 
lfp corresponds semantics languages constraints 
fixedpoint semantics sets clauses extend easily clp languages 
largely facts models models connections logical fixedpoint semantics just standard logic programming 
structure relation delta delta delta constraints abstracted relation satisfiability relation delta delta delta constraints abstracted set con consistent finite sets constraints fc ng 
essential semantic details constraint domain corresponding constraint system properties solution compactness independence negated constraints expressed detail constraint system provides 

logical semantics common logical semantics clp programs constraint domain 
interprets rule logic formula delta delta delta bn set free variables rule 
collection formulas corresponding rules gives theory denoted second logical semantics associates logic formula predicate pi 
set rules head bn formula associated delta delta delta bn set variables variables occur head rule formula collection formulas called clark completion denoted valuation mapping variables natural extension maps terms formulas closed formulas 
set facts fv interpretation formula interpretation formula domain interpretation symbols sigma represented subset bd bd fp pi model closed formula interpretation model formula 
negative equational constraints inconsistent negative constraints inconsistent positive constraints 
independence negative constraints investigated greater generality 
property shown hold classes constraints including equations finite rational infinite trees linear real arithmetic constraints equations may negated sort feature constraints feature trees infinite boolean algebras positive constraints 
consider restricted form independence negative constraints 
definition 
constraint domain independence negated constraints property constraints delta delta delta cn iff fact assumed closed conjunction existential quantification important restriction definition 
example colmerauer applicable setting dealt primitive constraints 
results cited full generality 
useful constraint domains known property including algebras finite rational infinite trees equational constraints infinitely function symbols feature trees infinitely sorts features linear arithmetic equations rational real numbers infinite boolean algebras positive constraints 
example 
herbrand constraint domain ft function symbols constant unary function easily seen statements true ft ft ft 
example independence inequations ft consider full class constraints ft facts 
statement ft true finite tree constant form finite tree hand ft ft true 
function symbols easy see extend example finite set function symbols independence negated constraints hold 
clear constraint domains constraints closely related information systems elements scott domain theory 
information systems codify notions consistency entailment elements interpreted satisfiability implication constraints single variable 
saraswat extended notion information system constraint systems allow variables showed motivating properties information systems continue hold 
constraint systems give formal definition viewed abstractions constraint domains eliminate consideration particular treat consistency entailment 
sc fc sc fc roughly speaking sc satisfied iff element defined possibly infinite conjunction constraints sc satisfied iff complement constraint described possibly infinite disjunction constraints 
definition sc quite equivalent definition paraphrase see 
turns sc necessary results include historical accuracy 
known natural constraint domain sc hold 
artificial constraint domains fails 
example 
lin denote constraint domain obtained lin adding unary primitive constraint negation constraint represented disjunction constraints lin lin solution compact 
theory parameter clp scheme intended axiomatize properties place conditions ensure reflects sufficiently 
conditions ensure agree satisfiability constraints addition third condition guarantees unsatisfiability detected theory conditions mainly play role completeness results section 
definition 
signature sigma constraint domain signature sigma sigma theory 
say correspond ffl model ffl constraint iff say satisfaction complete respect constraint satisfaction completeness weakening notion complete theory 
example theory real closed fields corresponds satisfaction complete respect domain model theory theory complete 
clark axiomatization unification defines satisfaction complete theory respect ft complete finitely function symbols 
notion independence negative constraints plays significant role constraint logic programming colmerauer independence inequations simplify test satisfiability equations inequations rational trees 
independence inequations states conjunction positive closely related model theoretic properties led interest horn formulas 
fd 
domain 
constraint domains interest exemplify lack space 
include pseudo boolean constraints example intermediate boolean integer constraints order sorted feature algebras domains consisting regular sets strings domains finite sets domains clp fun employ function variable domains functions expressed expressions possible form constraint domain directly objects operations application general purpose domains 
possibility pursued limited form generalpurpose domain extended ad hoc addition primitive constraints 
example uses chip finite domain extended predicate symbol element 
relation element expresses th element list discuss extensions section constraint domains expected support weakened form tests operations constraints major importance clp languages 
operation important obligatory clp languages 
ffl test consistency satisfiability ffl second implication entailment constraint generally may ask disjunction constraints implied constraint ffl third projection constraint variables obtain constraint gamma possible take gamma aim compute simplest fewest quantifiers 
general possible eliminate uses existential quantifier 
ffl fourth detection constraint value variable take consistent equivalently say determined grounded section discuss problems techniques arise implementing operations clp system 
point implementations operators particular test satisfiability incomplete 
cases argued algorithm incomplete respect desired constraint domain complete respect artificially constructed constraint domain 
turn properties constraint domains 
solution compactness satisfaction completeness introduced part clp scheme 
definition 
range elements range constraints possibly infinite index set 
constraint domain solution compact satisfies conditions sugared syntax represent constraint wine region color red 
constraint domain takes strings basic objects 
prolog iii 
example 
sigma contain binary predicate symbol binary function symbol constant number constants 
set finite strings constants 
symbol interpreted string concatenation interpreted empty string 
set constraints generated equations terms 
constraint domain equations strings called domain word equations 
example constraint constraint domain boolean values functions prolog cal chip prolog iii 
cal chip employ general constraint domain includes symbolic boolean values 
example 
sigma contain constants unary function symbol binary function symbols phi binary predicate symbol 
set ftrue falseg interpret symbols sigma usual boolean functions interpreted conjunction phi exclusive 
constraints generated primitive constraints 
bool valued boolean constraint domain 
example constraint slight abuse notation allow constraint written simply example phiy denotes constraint phiy 
general constraint domain sigma sigma fa constants 
constraints generated sigma primitive constraints free boolean algebra generated fa bool boolean constraint domain infinitely symbolic values constraint satisfiable bool iff 
finite domains chip best viewed having integers underlying structure limitation language constraints 
example 
sigma ff mn pair integers interval constraint denotes symbols sigma usual meaning 
constraints generated primitive constraints restricted variable subject interval constraint 
fd constraint domain referred finite domains 
domain variable finite set values satisfy unary constraints involving 
typical constraint finitely constants program argued finite boolean algebra appropriate domain computation 
alternatives agree satisfiability constraint entailment expanded language constraints permitted preferable view constraint domain independent program 
currently clear alternatives agree constraint operations 
prolog standard logic programming viewed constraint logic programming constraint domain finite trees 
example 
sigma contain collection constant function symbols binary predicate symbol 
set finite trees node tree labelled constant function symbol number children node arity label node children ordered 
interpret function symbols sigma tree constructors sigma arity maps trees tree root labelled subtrees arguments mapping 
primitive constraints equations terms constraints generated primitive constraints 
ft herbrand constraint domain prolog 
typical constraints 
unnecessary write quantifier prolog programs variables appear constraints implicitly existentially quantified 
pointed complete terminating unification omits occurs check solves equations rational trees 
example 
take sigma previous example 
set rational trees see definition function symbols interpreted tree constructors 
rt constraint domain rational trees 
take set infinite trees rational trees obtain constraint domain essentially rt way lin lin essentially language constraints structures elementarily equivalent 
domain contains objects similar previous domains different signature constraint language results slightly different expressive power 
viewed restriction domains login life compute sorts disjoint 
close relationship constraints terms emphasized syntactic sugaring constraints 
example 
sigma set unary predicate symbols sorts set binary predicate symbols features 
set finite infinite trees node tree labelled sort edge tree labelled feature node outbound edges label 
trees called feature trees 
interpret sort set feature trees root labelled interpret feature set pairs feature trees subtree reached edge labelled 
edge labelled pair set 
features essentially partial functions 
domain feature trees feat 
typical constraint wine region color red variant domain slightly different signature 
ffl binary predicate symbol contained sigma interpreted identity ffl constraints respectively identically true identically false ffl class constraints closed variable renaming conjunction existential quantification 
denote smallest set constraints satisfies assumptions contains primitive constraints constraints generated primitive constraints sigma general may strictly larger sigma example universal quantifiers disjunction permitted may smaller example 
usually take sigma occasion consider extension sigma sigma respectively constant sigma element example constraint domains 
practice fully implemented leave discussion 
general purpose clp languages incorporate arithmetic domain including cal chip clp prolog iii risc clp real 
example 
sigma contain constants binary function symbols binary predicate symbols set real numbers interpret symbols sigma usual interpreted addition 
constraints generated primitive constraints 
constraint domain arithmetic real numbers 
omit sigma symbol corresponding constraint domain lin constraint domain linear arithmetic real numbers 
domain restricted rational numbers constraint domain lin constraints lin lin write terms abbreviations respectively gamma constraint lin lin constraint 
extend allow negated equations symbol resulting constraint domains lin lin permit constraints restrict sigma obtain constraint domain constraints linear equations 
lin lin lin lin essentially constraint domain language constraints structures elementarily equivalent 
particular constraint solver constraint solver 
reformulation definitions results 
assumption unnecessary terms general unifier occurs prolog 
needed express parameter passing 
syntactic sugar unary binary minus symbol gamma allowed 
rational number coefficients terms sugared constraint need multiplied appropriate number reduce coefficients integers 
called disequations 
atom 
involves loss generality rule replaced equivalent rule 
assume rules defining predicate head rules variables common simply matter renaming variables 
examples relax restrictions 
programs font generally follow edinburgh syntax 
particular program variables upper case letter ail denotes list head head tail ail denotes empty list 
variation standard allow subscripts program variables improve readability 
part semantics clp languages languages definite clauses quite similar semantics 
crucial insight clp scheme earlier scheme logic programming language operational semantics declarative semantics relationships semantics parameterized choice domain computation constraints 
resulting scheme defines class languages clp obtained instantiating parameter take view parameter stands tuple sigma 
sigma signature sigma structure class sigma formulas order 
intuitively sigma determines predefined predicate function symbols arities structure computation performed class constraints expressed axiomatization properties section define important relationships elements tuple give examples constraint domains 
give declarative operational semantics clp programs parameterized declarative semantics quite similar corresponding semantics logic programs cover quickly 
variations resolution operational semantics main ones 
main soundness completeness results relate styles semantics 
discuss linguistic features proposed extensions basic clp language 

constraint domains signature sigma sigma structure domain computation class sigma formulas constraints 
call pair constraint domain 
slight abuse notation denote constraint domain assumptions strictly necessary simplify exposition 
assume ffl terms constraints come order language assumption results cite applicable appropriate order theory remaining assumptions omitted expense 
notation terminology hopefully keep conventions 
upper case letters generally denote collections objects lower case letters generally denote individual objects 
denote variables denote terms denote predicate symbols denote function symbols denote constant denote atoms denote collection atoms denote substitutions denote constraint denote collections constraints denote rule denote programs denote goal denote structure denote set elements denote element symbols may subscripted tilde 
denotes sequence distinct variables xn appropriate denotes sequence necessarily distinct terms appropriate abbreviates delta delta delta gamma oe denotes existential closure formula oe variables remain unquantified 
oe denotes full existential closure formula oe 
signature defines set function predicate symbols associates arity symbol sigma signature sigma structure consists set assignment functions relations symbols sigma respects arities symbols 
order sigma formula built variables function predicate symbols sigma logical connectives quantifiers variables usual way 
formula closed variable occurrences formula scope quantifier variable 
sigma theory collection closed sigma formulas 
model sigma theory sigma structure formulas evaluate true interpretation provided model theory model extending requires signature contained signature 
write oe denote formula oe valid models set function predicate symbols defined constraint domain denoted sigma set predicate symbols definable program denoted pi 
primitive constraint form terms sigma predicate symbol 
constraint order formula built primitive constraints 
class constraints vary generally consider subset formulas constraints 
atom form terms pi 
clp program collection rules form atom atoms constraints 
called head rule called body 
represent rule conjunction constraints body collection atoms body represent rule collection atoms constraints body 
subsection consider programs negated atoms body 
goal query conjunction constraints atoms 
fact rule constraint 
identify conjunction multiset union 
simplify exposition assume rules standard form arguments atoms variables variable occurs sorted language include associating sort argument result symbol 
discuss details survey 
prolog trees essentially part domain built top domain 
cil computes domain similar feature trees 
prolog computes domains valued boolean algebra finite domains arithmetic real numbers 
contrast clp languages arithmetic domains computes solutions numerically symbolically 
computes strings integers real numbers 
syntax closer lp considered clp language permitting subset horn clauses 
computes linear constraints integers real numbers 
cal computes domains real numbers constraints equations polynomials boolean algebra symbolic values equality boolean formulas expresses equivalence algebra 
delaying non linear constraints cal partial constraints computation 
experimental system risc clp real non linear constraints fully involved computation 
elf derived prolog compute values closed typed lambda expressions 
languages horn clauses include universal quantifier originally described clp languages 
argued operational behavior best understood behavior clp language 
earlier language le fun computed domain viewed clp language weak constraint solver 

synopsis remainder organized main parts 
part provide formal framework clp 
particular attention paid operational semantics operational models 
seen examples operational interpretation constraints declarative interpretation distinguishes clp lp 
part ii algorithm data structure considerations discussed 
crucial property clp implementation constraint handling algorithms incremental 
light review important solvers algorithms satisfiability entailment delaying constraints 
discuss requirements inference engine clp 
part iii consider clp applications 
particular discuss different programming paradigms suited modelling complex problems solution combinatorial problems 
survey concentrate issues raised constraints lp 
consequently ignore pass quickly issues inherent lp 
assume reader somewhat familiar lp basic order logic 
appropriate background obtained lp logic 
introductory papers constraint logic programming clp languages refer reader 
reading clp suggest surveys collections papers books 
generally papers clp appear various journals conference proceedings devoted computational logic constraint processing symbolic computation 
output 
mean time constraint dealt representation entire set constraints accumulated manipulated new representation constructed 
tantamount meta level implementation clp lp 
furthermore approach raises new challenges efficient implementation 
lp instance clp constraints equations terms solver requires representation accumulated constraints 
happens need explicit representation extra arguments discussed 
accumulated constraints represented general unifier course globally available simple binding mechanism 

clp languages viewing subject broadly constraint logic programming said involve incorporation constraints constraint solving methods logicbased language 
characterization suggests possibility interesting languages different constraints different logics 
point clp exclusively devoted languages horn clauses briefly describe languages concentrating received substantial development effort 
prolog said clp language constraints equations algebra terms called algebra finite trees herbrand domain 
equations implicit unification language discuss incorporates prolog terms addition terms constraints discuss aspect 
prolog ii employs equations disequations rational trees extension finite trees prolog cyclic structures 
logic language explicitly described constraints 
clp linear arithmetic constraints computes real numbers 
nonlinear constraints ignored delayed effectively linear 
chip prolog iii compute domains 
compute boolean domains prolog iii known valued boolean algebra chip larger boolean algebra contains symbolic values 
chip prolog iii perform linear arithmetic rational numbers 
separately domains mixed chip performs linear arithmetic bounded subsets integers known finite domains 
prolog iii computes domain strings 
languages compute finite domains manner chip including clp fd echidna 
cc fd essentially second generation chip system 
login life compute order sorted domain feature trees 
domain provides limited notion object object oriented sense 
languages support term syntax order term interpreted order constraints 
clp languages domains note combining constraints resolution order automated theorem proving 
language similar prolog equations explicitly making obviously clp language 
constraint languages related clp languages 
development symbolic algebra systems macsyma concentrated solving difficult algebraic problems 
programming language aspects developed 
languages linear programming provide little primitive documentation facility array coefficients input linear programming module 
parallel development constraint languages done modelling combinatorial problems constraint satisfaction problems csps development techniques solving problems 
generally independent host language 
possible exception alice provided wide variety primitives implement different search techniques 
important development definition study notions consistency 
significant influence development clp language chip 
refer reader basic techniques results concerning csps 
mention survey deals just constraint programming languages constraint programming techniques 

logic programming consider conventional logic programming lp argue example power clp obtained making simple changes lp systems 
question hand predicates logic program meaningfully regarded constraints 
predicate declarative semantics constraint sufficient implementation constraint clp 
consider example logic program add 
add add 
natural numbers represented delta delta delta delta delta delta occurrences clearly meaning predicate add coincides relation query add add clearly unsatisfiable runs forever conventional lp system 
important point global test satisfiability add constraints done underlying lp machinery 
example problem add predicate invoked representation add constraints collected far return representation having dealt constraint 
concretely second subgoal query representation fact partial solution problem delay mechanism 
roughly idea invocation predicate delayed arguments sufficiently instantiated 
example invocation add systematically delayed argument instantiated add behaves clp argument ground 
query delta delta delta delta delta delta add add fails desired 
original query add add delayed forever 
total solution principle obtained simply adding extra arguments predicate 
input representation constraints static solved local propagation relaxation techniques 
see chapter related techniques 
subsequent related language took object oriented flavor 
local propagation relaxation deal essentially static constraints system considered constraint solving different phases 
graphical object manipulated plan generated quickly re solving appropriate constraints changed part object 
plan repeatedly executed manipulation continued 
works tradition included filters project 
graphical system focusing geometrical layout 
constraints constructed text graphical primitives geometric object manipulated 
difference abovementioned works constraint solving performed numerically newton raphson solver 
collection early works arose mit motivated applications electrical circuit analysis synthesis gave rise languages general problem solving 
constraints language variables constraints static constraint solving limited local propagation 
extension provided sophisticated environment constraint programming including explanation facilities 
related systems el ars syn constraint solver macsyma avoid restrictions local propagation 
noted period conceptual correspondence constraint techniques logic programming 
ref arf system designed problem solving 
component ref essentially procedural language nondeterminism constraints conditional statements 
constraints static 
fact linear integer constraints variables bounded 
constraint solver arf backtracking 
bertrand system designed meta language building constraint solvers 
constraint language term rewriting 
constraints dynamic control 
constructs language augmented rewrite rules programmer adds rules specific constraint solving algorithm implemented 
post clp number works able deal dynamic constraints 
language lp described clp language syntax representing solving combinatorial problems 
obtaining parallel execution main objectives 
commercial language procedural framework arose chip essentially omitting logic programming part chip 
ilog solver commercial library constraint algorithms designed programs 
procedural language basis introduced constraint imperative programming explicit constraints usual way new kind constraints obtained considering variable assignments time stamped 
assignments constraints form 
mention constraint functional programming goal amalgamation ideas functional programming hope language constraints 
languages systems generally regarded terminates 
computation sequence states third answer example sumto sumto gamma gamma gamma gamma sumto gamma gamma gamma gamma gamma gamma constraints final state imply answer 
termination reasoned follows 
infinite computation second program rule state transitions 
means states shown fourth state gamma gamma gamma gamma sumto note contains unsatisfiable set constraints clp reductions allowed 
example shows key features clp ffl constraints specify query answers 
ffl execution new variables constraints created 
ffl collection constraints state tested satisfiability execution proceeds 
summary constraints input output dynamically generated globally tested order control execution 

constraint languages considerable constraint programming languages preceded logic programming constraint logic programming 
briefly survey important works view features 
constraints input output 
new variables constraints dynamically generated 
constraints control 
constraint solving algorithm extent complete 
follows adapted survey 
sketchpad earliest classify constraint language 
fact interactive drawing system allowing user build geometric objects language primitives certain constraints 
logic programming appear constraint logic programming survey jaffar michael maher constraint logic programming clp merger declarative paradigms constraint solving logic programming 
relatively new field clp progressed quite different directions 
particular early fundamental concepts adapted better serve different areas applications 
survey clp primary goal give systematic description major trends terms common fundamental concepts 
main parts cover theory implementation issues programming applications 
delta 
constraint logic programming clp began natural merger declarative paradigms constraint solving logic programming 
combination helps clp programs expressive flexible cases efficient kinds programs 
relatively new field clp progressed quite different directions 
particular early fundamental concepts adapted better serve different areas applications 
survey clp primary goal give systematic description major trends terms common fundamental concepts 
consider example program order identify crucial clp concepts 
program defines relation sumto delta delta delta natural numbers sumto 
sumto sumto 
query sumto gives rise answers address correspondence jaffar michael maher ibm thomas watson research center po box yorktown heights ny usa 
email watson ibm com final draft comments especially errors solicited 
