directed explicit state model checking validation communication protocols stefan stefan alberto institut fur informatik albert universitat freiburg georges kohler geb 
freiburg germany email informatik uni freiburg de technical report report date october success model checking largely ability toe ciently locate errors software designs 
error model checker produces trail shows error state reached greatly facilitates debugging 
current nd error states ciently counterexamples unnecessarily lengthy hampers error explanation 
due naive search algorithms state space exploration 
approaches heuristic search algorithms explicit state model checking 
class directed search algorithms propose heuristics bitstate compression techniques search violations 
achieve great reductions length error trails instances render problems analyzable exploring smaller number states standard depth rst search 
suggest improvement nested depth rst search algorithm show improve search liveness property violations 
approach directed explicit state model checking implemented tool set called hsf spin 
provide experimental results protocol validation domain hsf spin 
keywords model checking directed search protocol validation model checking formal analysis technique developed automatically validate functional properties software hardware systems :10.1.1.111.7245
properties usually speci ed sort temporal logic automata 
primary approaches model checking 
symbolic model checking uses binary decision diagrams represent state set 
second formalization uses explicit representation system global state graph 
explicit state model checker evaluates validity ofthe temporal properties model interpreting global state transition graph kripke structure 
focus explicit state model checking application validation communication protocols 
protocol model consider collections extended communicating nite state machines described instance 
communication processes realized synchronous asynchronous message passing communication channels queues global variables 
sending receiving message event causes state transition 
system global state space generated asynchronous cross product individual communicating nite state machines 
follow promela computational model 
model checking system design great advantage deductive formal veri cation techniques 
requirements speci ed model programmed model checking validation implemented push button process yields positive result returns error trail 
primary strategies model checking system design process observed 
complete validation certify quality product design model establishing absolute correctness 
due large size search space realistic systems hardly possible explore full state space order decide correctness system 
cases takes long explore states order give answer useful time span size state space large stored bounds available main memory 
second strategy appears commonly employ model checker debugging aid nd residual design code faults 
setting uses model checker search tool nding violations desired properties 
complete validation intended su ces hashing partial exploration methods allow covering larger portion system state space complete exploration needed 
pursuing debugging objectives need scope word validation denote experimental approach establishing correctness piece software veri cation denote formal theorem proving techniques purpose 
addressed 
desirable sure length counterexample short error trails easy interpret 
second desirable guide search process quickly nd property violation number explored states small means larger systems debugged way 
support objectives approach model checking model checking combined heuristic search 
model checker hsf spin extends spin framework various heuristic search algorithms support directed model checking 
experimental results show cases number expanded nodes length counter examples signi cantly reduced 
hsf spin applied detection deadlocks invariant assertion violations validation ltl properties 
instances estimates search derived properties validated hsf spin allows designer intervention targets state space search speci ed explicitly promela code 
propose improvement nested depth rst search algorithm exploits structure claims 
cation patterns described absence proposed algorithm performs transitions state space search nds shorter counterexamples compared classical nested depth rst search 
promela claim algorithm automatically computes partitioning linear time respect number states obtained partitioning non fully partially accepting strongly connected components exploited state space exploration 

originally appeared conference papers aaai spring symposium model validation intelligence th spin workshop model checking software 
considers safety property analysis simple protocols 
extends providing approach ltl speci ed liveness properties experimenting larger set protocols 
papers merged edited re ned selfcontained document 
correctness result improved nested depth rst search added new experiments evaluated 
structure 
section review automata model checking 
section introduces directed search algorithms instance 
heuristic estimate functions safety property analysis communication protocols suggested section 
spin tool set section experimental results safety properties section 
section propose improvement nested depth rst search algorithm analysis liveness properties show algorithm combined heuristic search 
experimental results liveness property validation section 
discuss related section conclude section 
automata model checking section review automata theoretic framework explicit state model checking describe validation algorithms practical model checker spin tool set :10.1.1.111.7245
automata theoretic framework model reactive systems nite behaviors appropriate formalization words state sequences systems buchi automata 
inherit syntactic structure nite state automata di erent acceptance condition 
nite run buchi automaton alphabet state symbols accepting set elements appear run non empty intersection set accepting states extends nite runs assuming nal state repeated forever 
language consists accepting runs helpful specify requirements reactive systems form atemporal logic 
linear time temporal logic ltl de ned 
ltl operator represents modality globally operator represents modality eventually 
automata model checking interested determining system represented buchi automaton satis es property speci cation buchi automaton directly automatically derived ltl property speci cation 
derivation exponential size formula typical property specications result small ltl formulae complexity practical problem 
buchi automaton satis es 
equivalent tol denotes complement ofl 
note buchi automata closed complementation 
practice computed ciently deriving buchi automaton negation ltl formula 
spin validation tool ltl formulae representing desired property rst negated translated equivalent buchi automaton 
parlance spin model checker promela input language automaton called claim adopt terminology 
example consider commonly response property states certain request event occurred response event eventually follow 
assume state occurrence request represented state predicate state response denoted corresponding ltl formula negation buchi automaton corresponding promela claim negated response property illustrated 
emptiness determined algorithm synchronous product 
assume state state perform transition successor state label edge represents sa buchi automaton response property top left negation bottom right 
proposition satis ed run synchronous product accepting contains cycle accepting state empty synchronous product accepting run 
standard distinction safety liveness properties 
safety properties refer states liveness properties refer paths state transition diagram 
safety properties validated simple search system state space liveness properties require twofold nested depth rst search 
property violations detected model checker return witness counterexample consists trace events states encountered 
search algorithms validation safety properties simple complete state graph traversal algorithm su cient 
usually depth rst dfs bfs search algorithm 
property violating state encountered search stack contains witness available user 
bfs nds errors minimal witness length memory ine cient 
dfs memory cient tends produce witnesses non optimal length 
liveness properties refer execution paths di erent search approach needed 
detection liveness property violations entails searching accepting cycles state graph 
typically achieved nested search nested dfs implemented stacks shown 
safety properties search stacks construct witness 
case property violation discovered rst stack contain path accepting state second stack illustrate cycle accepting state 
model checker spin spin model checking tool implementing discussed approach automata model checking 
input language promela permits de nition concurrent processes called promela parlance synchronous asynchronous communication channels true na nested dfs hash successors hash table nested dfs accept detect cycle detect cycle flag successors nested dfs stack exit ltl property violated agged detect cycle nested depth search data structures 
concurrency spin evaluated interleaving approach 
properties speci ed various ways 
express safety properties promela code augmented assertions deadlock state characterizations 
order express liveness properties promela models extended claims express undesired properties model 
spin provides linear temporal logic ltl claim translator 
spin implements synchronous product construction approach determine emptiness intersection promela model claim 
spin uses state space exploration algorithms implements various optimizations instance partial order reduction 
promela models simulated randomly user guided error trail 
spin line oriented graphical user interface called 
detailed discussion spin refer literature spin web site error trails property violations error trails contain important debugging information 
succinctness trails essential easy comprehension discovered design faults 
lengthy trails impede proper error trail interpretation 
illustrate impact long error trails example 
refer preliminary design plain old telephony system pots rst 
model generated visual modeling tool vip 
rst cut implementation simple party call processing know full faults various kind 
show model capable connecting telephones 
netlib bell labs com netlib spin 
model consists user processes usera userb representing environment behaviour switch phone handler processes representing software instances control internal operation switch signals hook hook received environment 
due space constraints understanding call processing behaviour type signals detailed description refer 
objective spin order debug pots model 
rst interested knowing certain inconsistent global system states reachable 
instance inconsistent state reached user processes phone handler process conversation states indicating presume phones connected second phone handler conversation state 
denote state propositions true phone handlers conversation state respectively 
denote state propositions representing fact phones conversation state respectively 
absence requirement inconsistent global system state safety property ltl formula spin validate property 
turns valid spin produces error trail leading global system state violating property partially illustrated 
experienced analyzing call processing sequences clear undesired state reachable race conditions lack synchronization userb processes probably calls synchronous communication interface 
error trail spin produces length steps comprises message exchanges obvious analyzing trail length locate cause error arduous task 
length trail surprising backward analysis knowing underlying state machine model easy come shorter trail hand instance trail comprising just messages 
trail length phenomenon partly due high degree nondeterminism inside system attributed highly concurrent nature telephony switch 
contributing factor search strategy spin uses exploring system state space 
resolution nondeterminism promela random spin implements xed priority scheme lexical structure promela model spin rst explore execution sequences lead establishment phone call 
means instance phone calls decides hang phones try call concurrently call sequences converges successful establishment call 
depth rst search strategy spin employs rst try explore action variants rst process try process 
roughly speaking means lexically rst transition rst proctype instance preferred concurrently enabled transitions 
usera userb conversation hook hook hook hook hook hook dial tone 
messages hook hook hook hook conversation dial tone dial tone disconnect conversation wait pots example error trail produced spin 
names curly brackets denote local control states reached trail 
usera userb conversation hook dial tone hook hook hook hook conversation dial tone disconnect conversation wait pots example manually generated shorter error trail 
target state reached processes steps phone call established 
spin search strategy takes knowledge model knowledge property account deciding possible successor states explore rst 
state space processes explored away state transition brought nearer local conversation state avoided conversation state globally transitions preferred non approximating transitions shorter error trail property violating state expected 
objective guided search algorithms heuristic guidelines state exploration similar just described 
discussing experimental results see pots example automatically obtained shortest error trail orders magnitude shorter generated spin exploration 
heuristic search algorithms section introduce heuristic search algorithms alternatives complete state space exploration model checking 
restrict discussion safety property searches extend discussion liveness properties 
detection safety property violation equivalent nding state property violated 
algorithms nding property violating states typically depth rst breadth rst searches 
search dfs memory cient provide optimal solutions 
breadth rst search bfs hand complete optimal ine cient 
state space exploration model checking safety properties casted search fora path failure state underlying problem graph 
graph implicitly generated node expansions contrast ordinary graph algorithms search terminates target state 
bfs dfs explore state space additional knowledge search goal 
selection successor node algorithms xed deterministic selection scheme 
heuristic search algorithms take additional search information form estimation function account 
function returns number representing desirability expanding node 
nodes ordered best evaluation expanded rst evaluation function estimates cost cheapest path current state desired resulting greedy best rst search bf nds solutions fast 
may su er defects depth rst search optimal search dead ends local minima 
algorithm combines best rst breadth rst search new evaluation function summing generating path length andthe closed open expansion criterion open max 
closed open expansion criterion open min 
closed open expansion criterion open min 
closed open expansion criterion open min 
di erent search strategies dfs top left bfs top right bottom left bf bottom right estimated cost cheapest solution starting displays ect compared dfs bfs bf table depicts algorithm pseudo code 
node expansion indicated access successor set 
set closed denotes set expanded nodes list open contains generated expanded nodes 
similar dijkstra single source shortest path algorithm successively extracts node minimal merit set open terminates node represents failure state 
combined merit merely changes ordering nodes expanded nite problem graphs complete 
changing weights edges problem graph observed fact performs computation dijkstra single source shortest path algorithm re weighted graph 
edges wehave optimality ofa inherited optimality dijkstra algorithm 
shown path length expanded node optimal correctly terminate search rst target node 
negatively weighted edges ect correctness proof dijkstra algorithm 
case wehave nodes expanded shorter path 
contrary dijkstra algorithm deals possibly re inserting nodes set expanded nodes set open nodes re open closed fg open deletemin open insert closed failure exit safety property violated search open open search closed delete closed insert open insert open table algorithm searching violations safety properties 
opening 
path accumulated weights graph structures di er andh 
consequently re weighting introduce negatively weighted cycles problem remains optimally solvable 
show lower bound estimate admissible heuristic solution returned algorithm re opening shortest 
main argument correctly estimated node optimal path set open 
node considered expanding non optimal goal node 
depicts impact heuristic search grid graph 
trivial constant zero function reduces dijkstra algorithm case uniform graphs collapses bfs 
starting depicted nodes shown generated goal node expanded 
distance node nodes hatched region removed open set 
algorithm severe drawback 
space resources storing expanded generated nodes exhausted progress 
iterative deepening variant ida short time space 
traverses tree expansion problem graph problem graph 
guarantee completeness optimality ida expands nodes consecutive bounded depth rst increasing threshold value possible merit value 
average number successors larger tree expansion grows exponentially increasing depth 
iteration ida usually dominates search ort 
due depth rst structure ida duplicate state expansions may ect heuristic search grid graph 
detected resulting redundancy 
similar depth rst best rst search long memory available generated nodes kept transposition table 
allow dynamic updates node information node table shortest generating path length corresponding predecessor maintained 
improve duplicate detection ida combined bit state hashing hashes entire state vector single bit wide table 
bit position indicates state reached 
single bit state hashing hash function maps state position stored setting bit searched querying 
double bit state hashing improves state space coverage applying second hash function 
state stored setting andh detected duplicate bits set 
bit state hashing implies retrieved node unexpected synonym way distinguish real duplicate false 
re opening node inside ida dangerous information generating path length predecessor path length false 
subsequently avoid partial ida 
note advantage partial ida compared track solution path recursion stack means predecessor link needed 
ida encountered heuristic function consistent 
case priorities increase generating path edges tree expansion problem graph 
practical heuristics satisfy criterion 
negative impact partial state space coverage due bitstate search reduced repeating search restarts di erent hash functions 
search heuristics safety properties section introduce search heuristics tool hsf spin analysis safety properties promela models 
denote hf true false hg hh hg hh de nition hf boolean expressions global system state model 
fpi currently active processes 
sake assume xed number processes write 
process pi refer current local control state 
ti denotes set transitions proctype instance pi si denotes set local states pi 
violation invariants system invariants state predicates hold global system state searching invariant violations helpful estimate number system transitions state reached invariant violated 
logical global state predicate hf estimation number transitions necessary state reached holds starting state similarly hf denote number transitions necessary violated validating negations state predicates 
boolean variable logical predicates 
give recursive de nition hf function rst part de nition 
de nition hg suggests independent may true 
consequently estimate necessarily lower bound ecting optimality condition 
goal obtain short necessarily optimal paths tolerate inadequacies 
obtain lower bounds may replace plus max 
formulae describing system invariants may contain terms operators boolean functions queues 
extend de nition hf shown 
function refers expression true message head queue tagged message type functions self explaining 
symbol represents relational operators 
note estimate coarse ective practice 
possible re ne de nitions speci cases 
instance ha de ned case decremented incremented 
pursued re nements 
statement typically appears system invariants predicate expresses process process id pid proctype hf full capacity length empty length length minimal pre lacks message tagged full full empty empty head maximal pre de nition hf boolean queue expressions relational operators hf di pci pci de nition hf control state predicates pt local control state write si 
corresponding de nition 
pci express local state process pi current global state value di isthe minimal number transitions necessary nite state machine pi reach state starting state si 
matrix di ciently pre computed pairs shortest path algorithm floyd warshall time 
note small comparison search space 
violations assertions promela statement assert allows label model logical assertions 
assertion labels transition ti say violated formula satis ed 
deadlock detection concurrent systems deadlock occurs subset processes resources cyclic wait situation 
promela deadlock state possible transition successor state processes system valid process statement executable 
promela promela expressed pt pid promela local control state labeled indicate valid state system may terminate process state 
label executable asynchronous channel empty asynchronous channel asynchronous channel full synchronous channel false condition function executable variable tag 
statements executable assignments statements run statements start processes 
statements send receive operations statements involve guard executability depends current state system 
example send operation executable queue full 
enumeration describes executability conditions signi cant portion promela statements 
asynchronous untagged receive operations variable executable queue empty 
corresponding formula empty 

asynchronous tagged receive operations tag executable head queue message tagged di erent tag yielding formula 

asynchronous send operations executable full indicated predicate full 

synchronous operations queue rendezvous block process executing operation process blocked queue trying execute inverse operation 
simplicity consider synchronous operations block process executability de ned predicate false 

conditions boolean expressions executable value condition false corresponding term boolean function executable ranging tuples promela statements global system states summarized 
propose estimator functions number transitions necessary current state reach deadlock state 
active processes deadlock state processes blocked 
active process heuristics uses number active non blocked processes state hap pi active active de ned active pci ti executable range active jpj active processes heuristic may informative protocols involving small number processes 
formula characterization deadlock state process blocked deadlock pi blocked pci predicate blocked pci de ned system state process pi blocked local state pci formalized blocked ti executable know set states system go deadlock advance compute exploration time resort approximation 
step determine states process block 
approximation process pi blocked blocked ci ci set dangerous states pi 
state dangerous outgoing transitions potential enabled outgoing transition enabling executable condition equivalent predicate true 
note classify valid invalid states dangerous default 
de ne approximation blocked predicate process pi blocked system state blocked blocked ci approximate deadlock formula deadlock blocked pi obviously computed exploration time depending characterization control states dangerous 
de nition transitions corresponding read send operations conditional expressions considered dangerous 
additionally guide search designer characterize selected control states dangerous inserting labels promela model 
hsf spin tool set chose spin basis hsf spin 
inherits ciency functionality original source spin sophisticated search capabilities heuristic search framework hsf 
hsf spin uses large subset promela modeling language 
hsf spin possesses re ned state description spin incorporate solution length information transition labels predecessors solution extraction 
provides interface consisting node expansion function initial goal speci cation 
order direct search implemented di erent heuristic estimates 
hsf spin writes spin compatible trail information visualized interface 
working spin validation model hsf spin done phases rst generation analyzer model second validation run 
protocol analyzer generated program hsf spin modi cation spin analyzer generator 
executing hsf spin model les generated 
les part source model checker model 
compiled linked rest implementation incorporating example data structures search algorithms heuristic estimates statistics solution generation 
hsf spin supports bit state hashing implementing partial ida 
hsf spin invoked di erent parameters kind error detected property algorithm applied heuristic function weighting heuristic estimator 
hsf spin allows textual simulation interactively traverse state space greatly facilitates explaining witnesses 
hsf spin prototype 
performance terms time space compete spin 
example exhaustive exploration state space generated giop protocol parameterized clients servers performed spin partial order reduction seconds memory consumption mb tool requires seconds mb space 
experiments show spin achieves speedup factor comparison hsf spin 
safety property validation experiments experiments performed spin version hsf spin version executed sun workstation ultrasparc ii cpu mhz solaris 
stated depth bound set compression technique 
case deadlock detection hsf spin hap estimation function indicated 
cases formula heuristic hf 
comparing spin noted model checker invoked partial order reduction enabled 
shorter trails computational ort rst set experiments intended show thata nds shorter trails compared dfs requiring computational ort bfs cases performs better dfs 
computational ort giop bfs dfs bf spin philosophers bfs dfs bf spin optical bfs dfs bf spin bfs dfs bf spin table deadlock detection various protocols 
mean conjunction number states stored number states expanded number transition performed 
additional objective show bf require computational ort bf delivers sub optimal solutions 
kind safety error representative set protocol models 
deadlock detection performed corba giop protocol con guration clients server philosophers con guration dining philosophers problem model optical telegraph protocol stations model concurrent program solves stable marriage problem con guration 
assertion violation detection experiments carried lynch protocol model relay circuit faulty solution mutual exclusion problem mutex invariant violation evaluated pots telephony model elevator protocol pots model invariant described section 
elevator model invariant form opened stopped 
tables depict results error detection protocols available netlib bell labs com netlib spin promela sources information models obtained www informatik uni freiburg de models models html derived www inf ethz ch personal biere teaching html relay bfs dfs bf spin lynch bfs dfs bf spin mutex bfs dfs bf spin table detection assertion violations various protocols 
various search strategies 
protocol number stored states expanded states transitions performed length error trail shown 
similar spin count sequence atomic steps unique transition 
number expansion steps spin number stored states 
columns correspond di erent search strategies hsf spin breadth rst search bfs depth rst search dfs best rst search bf 
column corresponds exploration spin depth rst search spin 
examples bfs provide optimal counterexamples 
compared bfs algorithm requires computational ort 
reduction number expansions states transitions varies example pots bfs dfs bf spin elevator bfs dfs bf spin table detection invariant violations various protocols 
usera userb conversation hook dial digit dial tone conversation conversation idle pots example error trail generated hsf spin hf example 
mainly due quality heuristic estimate 
example case invariant violation detection elevator protocol savings trail length achieved weak 
attributed integer range heuristic estimation function small considering optimal solution steps 
hand detecting violation invariant pots protocol heuristic function returns estimates range 
range estimate function allows di erentiated successor selection results informed search leading strong reduction computational ort required detect error 
expected dfs nds error trails signi cantly larger optimal 
example trail provided spin dfs invariant violation pots protocol times larger optimal trail generated hsf spin visualized 
trail superior manually generated short trail 
hsf spin happens nd di erent target state spin target state corresponds di erent race condition spin 
race condition traced back lack synchronization userb processes 
cases dfs performs better terms computational ort philosophers problem pots protocol performance superior dfs 
reason lies particular structure problems 
problems necessary sequence actions process performs steps order get closer target state 
dfs try rst explore possibilities process includes behavior processes 
consequence dfs require computational ort reach target state 
explained hsf spin runs memory pots example dfs spin nds counterexample 
due fact implementation dfs spin cient employed partial order reduction 
experiments highlight bf requires computational ort established error trails optimal 
heuristic estimates previous section noted important uence heuristic estimate function performance 
analyze di erent heuristic functions proposed deadlock detection 
particular compare heuristic number active processes hap formula heuristic hf combined proposed method automatically inferring deadlock formula hf denote user explicitly de nes dangerous states 
example chose optimal labeling exactly states labeled dangerous resulting global control state deadlock state 
experiments solution philosophers problem optical telegraph protocol problem giop protocol 
models con gured previous set experiments 
table visualizes number expansions required nd deadlock state range values heuristic estimate function de ned 
cases optimal solution 
results show applying inferred deadlock heuristic hf user intervention improves results cases 
easy compare inferred heuristic hf hap 
hap perform worse hf optical telegraph protocol 
optical telegraph protocol estimate hap works number processes model quite high 
case giop protocol model number processes small hap produces poor reductions number expanded states 
emphasized quality highly depends quality designers labeling dangerous states 
summary experiments indicate uence quality ofthe heuristic estimate function 
finding errors dfs fails objective model checking approach detect errors models classical depth rst exploration fails due exhaustion memory resources 
philosophers hap hf hf optical hap hf hf hap hf hf giop hap hf hf table deadlock detection di erent heuristic functions 
perform set experiments scalable deadlock solution dining philosophers problem 
experiments run time limitations hard memory constraint mb 
contrary experiments allow spin apply bitstate hashing compression order emphasize bene ts directed search 
table shows results deadlock detection philosophers model growing number philosophers 
rst column depicts number philosophers model 
labeling columns obvious 
bf scale linearly respect increase bfs dfs 
hsf spin bfs dfs exploration able nd deadlock situation con gurations philosophers 
spin go little fails con gurations philosophers 
results show models able detect errors depth rst search combined reduction compression techniques fails 
ida bitstate hashing memory time constraints ida combination bitstate hashing able detect errors problems ida fail 
priority queue full run memory transposition table full duplicate states force ida run time 
giop protocol deadlock error con gured clients server experimental setup 
set space limit mb time limit minutes 
hash table sizes ida set memory bound 
table depicts number expansions performed ida ida combined double bitstate hashing 
obtain data table snapshot expansions time search depth increases methods number bfs dfs bf spin table deadlock detection dining philosophers problem 
depth ida ida bitstate goal table deadlock detection giop protocol memory constraints 
state expansions corresponds number nodes current iteration 
results show combination ida bitstate hashing able nd error protocol 
ida exceeds time exceeds space limit 
duplicate state di erent generating paths 
duplicates occur frequently typical protocols 
long visited lists ida full duplicate states detected 
memory bound reached aborts unable allocate states open closed lists 
ida bypasses problem exploring tree expansion underlying graph possibly re exploring state space subtree structures 
cases duplicates transposition table full ida fails complete iteration time limit 
ida bitstate hashing prunes duplicates optimistically storing nger print signature state 
reduces space requirements orders magnitudes example case duplicates detected large search depths 
loss states false positives marginal example state wrongly identi ed double bitstate hashing depth reached ida gives 
liveness property validation feature nested dfs algorithm described section state agged expanded cycle detection 
correctness algorithm post order traversal search crucial second depth rst traversal encounters nodes visited main search routine 
second search improved directed cycle detection search 
aiming states placed nested dfs stack rst traversal heuristics perform directed search cycle closing states 
unfortunately examples accepting cycle improve 
disadvantage pre ordered nested search approach search acceptance state claim encountered search cycle quadratic worst case time linear memory overhead second search invoked newly initialized list agged states 
address drawback developed improvement nested depth rst search algorithm exploits structure claim 
algorithm applicable large set practical property speci cations combined heuristic techniques cient search performance 
classi cation claims strongly connected components scc partition directed graph groups cycle combining components 
subset nodes directed graph strongly connected nodes path path sccs maximal sense computed linear time 
illustrate sccs help improve nested dfs algorithm consider claim 
nd strongly connected components rst formed second na 
furthermore path second scc rst 
accepting cycles synchronous product automaton composed states claim second scc 
conclude local claim state corresponding cycle closing synchronous product automaton state belongs second scc cycle accepting 
belongs rst scc accepting 
order generalize observation suppose pre computed sccs claim 
due synchronicity product model automaton claim cycle synchronous product generated cycle exactly scc 
cycle accepting corresponding cycle scc claim 
suppose scc composed non accepting states accepting states 
global accepting cycles contain accepting states non accepting cycles contain non accepting states 
single depth rst search detect accepting cycles state stack established cycle accepting accepting 
partitioning rules sccs relaxed classi cation sccs call scc accepting states accepting non accepting 
call accepting scc fully accepting cycles contain accepting state 
table scc classi cation ltl speci cation 
call accepting scc partially accepting cycle contain accepting state 
claim contains partially accepting scc accepting cycle detection global state space performed single depth rst search state stack accepting state belong accepting scc 
special case occurs claim 
state reached claim said violated bad sequence 
bad sequences tackled similarly safety properties standard heuristic search 
classi cation patterns property speci cations proposed reveals empirically collected database practically ltl properties partitions absence universality existence response precedence 
pattern scheme scope modi ers globally obtain partitioning table 
indicate presence letter speci cation patterns ltl formulae derive equivalent claims spin built ltl claim converter 
approach particularly useful claims contain components instance response pattern global scope 
prevalence response pattern conclude improvement nested dfs algorithm applicable large set practical problems 
improved nested depth search improved nested dfs algorithm ideas 
scc scc state scc determines scc state type fully accepting scc determines scc state type partially accepting denotes local state claim global state algorithm nds acceptance cycles nested search problems partition components 
sccs avoids post order traversal 
sccs guarantee second cycle detection traversal restricted strongly connected component seed 
search path cycle established st dfs cycle nd dfs search tree scc claim scc scc visualization di erent cases improved nested dfs 
algorithm considers successors node depth rst manner marks visited nodes label hash 
successor contained stack cycle 
corresponds cycle scc accepting 
cycles sccs parts claim nested dfs exception successors node pruned outside component 
claim reached algorithm terminates immediately 
detailed proof correctness section 
depicts di erent cases cycles detected search 
main idea correctness improved nested dfs fact cycles state transition graphs correspond cycles claim 
cycle combining components claim search space 
mentioned strongly connected components computed time linear size claim number isvery small practice 
partitioning sccs non accepting partially accepting fully accepting achieved linear time nested dfs claim 
improved nested dfs far considered heuristic search improved nested dfs 
consider example response properties validated 
rst phase states explored 
heuristic estimation function easily designed reach accepting cycles sccs faster states aiming accepting 
approach generalizes hybrid algorithm improved nested dfs short alternates heuristic search sccs single pass searches sccs nested search sccs 
component improved nested dfs invoked searches cycles 
heuristic estimate respects combination sccs sccs accepting cycles components 
nodes horizon improved nested dfs hash successors improved nested dfs stack scc property violated hash table nested dfs accept scc improved detect cycle improved detect cycle flag successors improved nested df stack exit ltl property violated agged scc scc improved detect cycle improved nested depth search 
component lead pruning sub searches inserted back open list contains horizon nodes corresponding sccs 
continues directed search cycle detection components fails 
cycle detection search accelerated estimation function heading back states started 
visualizes strategy response property 
claim sccs scc scc scc 
state space seen divided partitions composed states claim state belonging sccs 
rst phase directing search states partition corresponding 
goal state second phase begins search accepting cycles performed improved nested dfs 
correctness nested depth rst search algorithm model checking validates emptiness buchi automata 
searches accepting cycles problem graph represents state space buchi automaton reports non emptiness exists accepting cycle graph 
correctness proof algorithm :10.1.1.111.7245
improvement nested depth rst search algorithm depicted 
prove correctness algorithm start de nitions 
st phase 
goals 
search tree 
true claim nd phase improved nested dfs scc visualization improved nested dfs response property 
de nition automaton tuple fi nite alphabet nite set states transition relation set initial states set accepting states 
de nition run buchi automaton nite word mapping 
rst state initial state moving th state st state reading th input letter consistent transition relation de nition inf set states appear nitely run treating run nite path 
run automaton nite word accepting accepting state appears nitely inf 
language accepted automaton set nite words runs accepting 
nite state automaton representing model claim 
construction automaton automaton states accepting 
de nition qm fm buchi automaton states qm fm qn fn buchi automaton 
synchronous product de ned fi qm qn fm fn qm fn sm sn sm sn na buchi automata represented directed graphs set vertices edges labeled transition relation runs automaton nite word correspond nite paths graph accepting runs nite paths containing nite accepting cycles 
accepting cycle de ned cycle state accepting 
de nition strongly connected component scc directed graph maximal set vertices vertex set reachable vertex set 
di cult show pairwise reachability equivalence relation set nodes partitioned equivalence classes strongly connected components 
important consequence de nition sccs vertices cycle belong scc 
write scc denote scc state belongs 
set states de ne partition function kg manner states belong partition state component ofn belongs scc state transition graph precisely ifs sm sn scc sn sm sn obviously de nes partition equivalence classes pk pi fs ig kg 
de nition connected component called non accepting states accepting full accepting cycle formed states scc accepting partial accepting 
de nition equivalence class pi non accepting full accepting partial accepting corresponding strongly connected component non accepting full accepting partial accepting respectively 
lemma cycle partitions states manner states cycle belong equivalence class pi kg 
proof cycle state transition graph sn sn si si 
si ng cycle cn sn sn sn exists sn ng 
si sj sn scc sn scc sn 
implies si sj si sj states belong equivalence class 
lemma cycle accepting corresponding cycle accepting 
easy see de ned state sm sn accepting sn accepting state lemma cycles non accepting component non accepting cycles fully accepting component accepting 
partial accepting components accepting non accepting cycles 
lemma deduced de nitions lemma 
lemma known property rst search essential proving correctness algorithm 
lemma vertex appear cycle 
depth rst search algorithm backtrack nodes reachable explored backtracked 
easy see lemma holds rst search original improved nested depth rst search algorithm 
theorem improved nested depth rst search algorithm returns counterexample emptiness checked automaton exactly empty 
proof counterexample returned algorithm corresponds fact accepting run automaton ii accepting run missed algorithm 
rst thing show algorithm nds accepting cycle cycle fact accepting 
algorithm closes accepting cycles rst second search 
algorithm closes cycles second search acts original algorithm 
shown cycles closed second search accepting second search started accepting states :10.1.1.111.7245
hand cycles closed rst search correspond cycles accepting equivalence class shown lemma cycle full accepting component accepting 
ii di cult case prove algorithm nds accepting cycle 
shown accepting cycles exist full accepting component accepting component 
cases algorithm fails nd existing accepting cycle iia cycle exists full accepting component missed rst search iib cycle exists partial accepting component missed second search 
iia suppose accepting cycle exists full accepting component rst search fails nd 
rst state visited depth rst search reachable belongs component 
rst search misses cycle moment search started path contains visited state 
rst state 
visited depth rst search reachable cycle 

belong full accepting component lemma contradicts assumption 
iib suppose accepting cycle exists partial accepting component second search fails nd 
case similar reasoning done show happen :10.1.1.111.7245
rst accepting state belonging partial accepting component second search starts fails nd cycle exists 
moment second search starts agged state cycle rst state state second search agged started 
algorithm second search remains equivalence class search started 
belong component 
assumptions second search started second search cases ii state reachable cycle previously algorithm terminated 
lemma cycle belongs partial accepting component 
contradicts assumption second search missed cycle belonging partial accepting component 
ii state reachable appears cycle cycle missed starting second search ats cycle belongs partial accepting component belong component 
assumption reachable subsequently reachable occur cycle lemma discovered backtracked rst search backtracking algorithm started second search starting contradicts assumptions 
liveness property experiments section describe experimental results validation liveness properties 
experimental setup largely described section 
compare algorithms section 
algorithms spin wehave implemented inside spin tools thesame algorithmic capabilities 
results produced tools similar terms computational ort give values obtained hsf spin section 
validating correctness rst set experiments intended show ts validating liveness properties 
worst case performs transitions expansions best case situation halve values 
worst case occurs claim contains sccs best case occurs claim contains exclusively elected na true elected true claims top left elected 
elected table checking correctness liveness properties leader election algorithm 
sccs type 
note claims generated spin claim translation 
model leader election algorithm test case 
worst case check property corresponding claim formed unique scc 
best case situation property elected corresponding claim formed unique scc 
illustrates claims spin generates property 
table depicts results experiments 
number transitions expansions shown 
number stored states included table show algorithms explore exactly 
results show case situation perform 
hand best case situation requires half transitions expansions requires 
na elevator giop table detection violation liveness properties protocols 
error detection objective requires computational ort provides better error trails 
test performance hybrid algorithm combines 
rst version giop model con gured server clients seeded error causes model violates response property stating client sends request reply received 
second model elevator violates response property stating request elevator exists level elevator eventually level open door 
table shows experimental results detecting violation ltl formulae 
compared algorithm combines 
results show provides small improvements categories 
giop protocol reduction signi cant halves length error trail 
hybrid algorithm nds better solutions situations computational ort varies drastically 
elevator experiment requires times state expansions giop experiment performs times 
reason varying behavior directs search nearest full accepting component state space 
component may free cycles 
part state space entirely explored nested search returns control directs search full accepting part 
case giop protocol algorithm nds component cycle early search elevator example algorithm rst explores parts state space include accepting states accepting cycles 
related earlier directed search model checking authors apply best rst exploration protocol validation 
interested typical safety properties protocols unspeci ed reception absence deadlock absence channel ow 
heuristics estimate determined identifying send receive operations 
analysis protocol obtained savings number expansion steps factor comparison typical depth rst search strategy 
incorporated strategy hsf spin 
approach limited detection deadlocks channel ows unspeci ed reception protocols asynchronous communication 
contrary approach general handles larger range errors communication types 
measures merely stochastic yield optimal solutions heuristics propose cases lower bound estimators allow nd optimal solutions 
authors identify phases veri cation process 
exploratory mode system designer tries nd rst error fault nding mode aims meaningful counterexamples maintenance mode expect errors 
point view approach concentrates rst modes 
authors analyze algorithm best suited mode 
di erent variants search breadth rst search 
ideas heuristic estimates similar authors elaborate speci heuristic estimates 
contrary consider ida restrict safety properties 
slightly di erent 
agree shortest path algorithm suitable fault nding mode believe search useful rst exploratory mode phase guiding search error state computational ort blind search strategies 
authors bdd symbolic search mur validation tool 
best rst search procedure propose incorporates symbolic information hamming distance states 
approach improved bdd version algorithm cke model checker 
algorithm outperforms symbolic breadth rst search exploration scalable hardware circuits 
heuristic determined static analysis prior search actual circuit layout failure formula account 
approach guided search model checking documented applies hints avoid sections search space di cult represent bdds 
permits splitting point iteration process symbolic exploration parts yielding approximation transition relation respectively 
bene ts approach simpli cation transition relation avoidance bdd blowup reduced amount exploration complicated systems 
contrast hints requires user intervention 
approach directly applicable explicit state model checking focus 
exploiting structural properties buchi automaton explicit state mode checking considered literature context weak alternating automata 
invented reason temporal logics generalize transition function boolean expressions successor set partition automaton structure 
classi cation states di ers partitioning disjoint sets states accepting rejecting imply partitioning 
simpli cation buchi automata proposed inferred ltl property algorithm analysis structure buchi automata 
considers partitioning type weakness conditions di ers approach taken 
approach taken addresses explicit ctl model checking spin hesitant alternating automata haas 
shows performance proposed ltl nonemptiness game fact reformulation improvement nested depth rst search 
partitioning context haa model checking signi cantly di erent setting 
und outlook argued order facilitate debugging error trails witnesses model checker generates minimizing length highly desirable 
reduction number visited states state space search desirable renders larger models tractable 
standard depth rst search algorithms explicit state model checkers spin cient terms memory usage computing time tend produce lengthy counterexamples 
introduced heuristic search algorithms showed apply heuristic search safety property validation 
experimental results showed directed model checking returns shorter error trails dfs instances trail length optimal 
regarding computational ort results mixed instances superior spin dfs cases performing 
clear gain obtained directed model checking better di erentiation heuristic estimation function allows 
observed dining philosophers problem constrained memory availability directed model checking able solve problem solved dfs 
expect ect linked highly symmetric nature problem high degree coordination typical example 
proposed improvement nested depth rst search algorithm exploits structure claim validated 
algorithms applicable validation liveness properties 
showed directed model checking algorithm leads modest improvements terms error trail length compared 
ex periments showed combined usage lead signi cant reductions error trail length 
incorporation heuristic search strategies observation standard state space exploration algorithms perform search uninformed structure search problem 
raw heuristics surprising see problems 
primarily interested optimal solutions tolerate non admissible heuristic estimates better estimates available 
concurrent describe approach shorten existing error trails re ned state distance metrics heuristic estimates 
approach implemented hsf spin 
selected benchmark industrial communication protocols experimental evidence trail directed model checking ectively shortcuts existing witness paths 
interested improving quality heuristics approach applicable larger set problems 
approach assesses fact assumption independence combining sub formulae rarely ful lled practice 
main idea implemented approach stochastic model checking derive model search prediction takes correlations propositions consideration order direct search 
unpublished reconciles partial order reduction techniques directed model checking approach hsf spin 
theoretically empirically show thata combined partial order reduction methods 
bene application partial order reduction limited due similarity nicely partial order reduction 
armin biere 
cke cient calculus model checking 
computer aided veri cation pages 
ravi somenzi 
symbolic guided search ctl model checking 
conference design automation dac pages 
acm ieee 
brand za 
communicating nite state machines 
journal acm apr 
clarke grumberg peled :10.1.1.111.7245
model checking 
mit press 
clarke osterweil 
right algorithm right time comparing data ow analysis algorithms nite tate veri cation 
proceedings rd international conference software engineering icse pages 
ieee computer society 
cormen leiserson rivest 
algorithms 
mit press 
dijkstra 
problems connection graphs 
numerische mathematik 
dwyer avrunin corbett 
patterns property speci cations nite state veri cation 
international conference software engineering 

directed explicit model checking hsf spin 
proc 
th international spin workshop model checking software lecture notes computer science 
springer verlag may 

protocol veri cation heuristic search 
aaai symposium model validation intelligence 

trail directed model checking 
proc 
workshop software model checking electrical notes theoretical computer science 
elsevier july 
re el 
obdds heuristic search 
german conference onarti cial intelligence ki pages 

localizing 
national conference arti cial intelligence aaai pages 
stefan 
data structures learning algorithms state space search 
phd thesis university 
gouda 
protocol veri cation simple tutorial 
computer networks isdn systems 
hart nilsson raphael 
formal basis heuristic determination minimum path cost 
ieee transactions systems science cybernetics 
holzmann 
design validation computer protocols 
prentice hall 
holzmann 
model checker spin 
ieee trans 
software engineering may 
special issue formal methods software practice 
kamel 
formalization validation general inter orb protocol giop promela spin 
software tools technology transfer volume pages 
kamel stefan 
vip visual editor compiler promela 
th international conference tacas volume lecture notes computer science pages 
springer 
korf 
depth rst iterative deepening optimal admissible tree search 
arti cial intelligence 
lin chu liu 
protocol veri cation reachability analysis state space explosion problem relief strategies 
acm pages 
manna pnueli 
temporal logic reactive concurrent systems speci cation 
springer verlag 
mcmillan 
symbolic model checking 
kluwer academic press 
wilson 
stable marriage problem 
communications acm 
muller 
alternating automata 
weak monadic theory tree complexity 
laurent editor international colloquium automata languages programming pages 
springer 
re el 
error detection directed symbolic model checking 
world congress formal methods pages 
springer 
somenzi 
cient buchi automata ltl formulae 
computer aided veri cation 
visser barringer 
ctl model checking spin 
software tools technology transfer 
yang dill 
validation guided search state space 
dac pages 

