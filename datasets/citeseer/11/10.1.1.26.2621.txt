garbage collection model checking radu iosif riccardo dipartimento di automatica informatica politecnico di torino corso degli torino italy iosif athena www dai arc 
garbage collection techniques common place actual programming environments helping programmers avoid memory fragmentation invalid referencing problems 
order ciently model check programs garbage collection similar functionalities model checkers 
focuses implementation classic garbage collection algorithms dspin extension model checker spin supports dynamic memory management 
experiments carried show making large class programs tractable garbage collection mean reduce number states generated model checking tool 
applying nite state veri cation techniques model checking concurrent distributed software systems looks attractive capable detecting subtle defects logic design systems 
transition techniques research practice slow 
reasons current nite state veri cation tools adhere static representation systems programming environments dynamic 
necessary distinguish static dynamic program information referring information known compile time static analysis techniques data ow analysis refers information occurs run time 
fact optimizations performed compilers lately software veri cation tools attempt approximate run time information static analysis techniques 
static analysis proves useful reducing size nite state program models cases ective reductions achieved expense complex time consuming analysis 
cases involve pointer analysis produces conservative approximation pointer alias set set objects may point run time 
complex analysis results large nite state veri cation 
alternative approach software veri cation involves representation dynamic program information directly model checking engine 
order extended model checker spin number dynamic features memory pointers dynamic object creation deletion function declaration call function code function pointers 
extension called dspin dynamic spin reported 
dspin remains general purpose model checker intended especially software veri cation allowing easy translation high level objectoriented programming languages java input language dialect promela 
size transition system reduced rst light weight pointer analysis applying common nite state reduction techniques partial order reductions state compression symbolic representation step improving model checking software systems garbage collection techniques dspin 
motivated widespread garbage collection real life software systems especially ones written java default memory management policy 
unused memory reclaimed program state space may experience unbounded growth analysis impossible 
example assume represents name class declaration fragment code true new 
garbage collection performed model checking iteration possibly nite loop add new states program state space 
state space explored depth rst order leads fast growth state space exhausts system resources useful results 
program model checked garbage collection rst state second iteration probably match rst state rst loop need re explored 
garbage collection solution explicit memory deletion 
explicit deletion drawbacks 
hand source program explicit deletion statements inserting statements program model requires expensive pointer analysis 
hand explicit deletes may result useless changes memory con guration greatly increases program state space 
embedding garbage collection model checker proves quite easy advantage eliminating need complex pointer analysis dangerous memory fragmentation expense small run time overhead 
come attention group working implementing garbage collection java byte code model checker java pathfinder tool 
organized follows section recalls background concepts dspin garbage collection section describes implementation collection algorithms dspin section reports number experiments carried section concludes 
background section recall background concepts 
particular classic collection algorithms discuss data layout dspin 
detailed report dspin 
follows denote garbage heap allocated object reachable chain pointers program variables 
memory occupied garbage reclaimed allocating new objects 
process called garbage collection performed program run time system case model checking engine 
counting collection garbage collection algorithms identify garbage rst nding reachable 
done directly keeping track pointers point directly object 
count object needs recorded object 
precisely need keep count objects separate table called table 
shows general structure counting collection algorithms 
object stored pointer variable object procedure table table field object delete procedure table fig 

counting collection count incremented call count previously pointed decremented call 
ifthe decremented count object reaches zero object deleted counts objects pointed elds decremented recursive calls 
counting simple attractive major drawback cycles garbage reclaimed 
consider example cyclic list objects anymore reachable program variables 
cons list count prevents collected 
considering pass counting collector collected objects total reachable time spent evaluated stands average object dele tion time 
worst case time counting collection occurs reachable objects collected 
corresponds case reachable objects count equal collector reclaim 
despite previously mentioned problem regarding impossibility reclaiming cyclic structured data cost counting collection quite small algorithm suitable model checking 
mark sweep collection program pointers heap allocated objects form directed graph 
program variables roots graph denoted follows set roots 
graph reachable path directed edges leading starting root roots 
graph search algorithm depth rst search marks nodes reachable roots 
node marked garbage reclaimed 
done sweep heap area looking nodes marked 
said nodes garbage deleted 
sweep phase clear marking nodes preparation collection 
shows mark sweep collection algorithm 
marking objects kept global mark table procedures 
order evaluate cost mark sweep collection consider reachable objects 
denote nmax upper bound heap maximum number objects allocated 
time taken mark phase proportional number nodes marks amount reachable data 
time taken sweep phase proportional size heap 
consequently time garbage collection nmax object marking time object deletion time introduced previous section 
worst case estimation practice number unreachable existent objects needs deleted collector 
number depends tightly program structure approximate maximum number unreachable objects nmax 
overview dspin procedure 
mark table mark table true field object procedure object mark table mark table false delete fig 

mark sweep collection order self contained need recall extensions implemented dspin particular ones concerning dynamic memory management 
dspin memory dynamically allocated deleted means explicit new delete statements 
dynamically allocated areas denoted follows objects 
mechanism handle objects dspin called pointer programming languages 
semantically dspin pointers resemble java assigned objects point accessed dereferenced arithmetic operations case complete description syntax semantics language constructs 
dspin objects dynamically allocated reside contiguous memory zone called heap area 
newly created objects added heap area 
deleting existing object heap area compacted order avoid memory losses caused fragmentation 
object retrieval information kept tables called set table size table 
rst table holds set respect heap area second holds actual size object 
addition garbage collector able operate objects types 
particular able determine number elds object eld pointer 
type information kept object type table 
pointer object encodes integer value index tables 
depicts run time representation objects dspin 
explicit type information needed run time input language dspin allows free pointer conversion 
words conversion index offset table size table type table heap area fig 

data layout dspin pointer types allowed static type evaluation impossible 
point type information need stored state vector performing model checking 
set size type tables global data structures modi ed allocation deletion statements 
discussed information needs recorded state stack inorder allow model checker unwind allocation deletion forward moves 
memory overhead introduced garbage collection depends maximum stack depth 
implementation issues section issues related implementation previously collection algorithms dspin model checker 
particular address aspects related compatibility algorithms model checking run time environment 
di ers common runtime systems way particularities may interact garbage collection considered 
rst point needs attention possibility duplicating regions model checker state space garbage collection 
example consider situation veri er generates state objects garbage 
assume usual run time environments garbage collector necessarily run immediately state generated 
consequence direct successor states call bn maintain garbage 
point veri cation model checker generates state di ers absence garbage states match 
consequently direct successors call match states bn respectively 
results unwanted duplication states garbage collection 
solution run collection soon possible order avoid states containing garbage 
order distinguish kinds statements may produce garbage dspin 
pointer assignment object previously pointed pointer may garbage 

exit function local scope objects pointed local pointers may garbage 

explicit delete objects pointed deleted object elds may garbage 
garbage collection invoked atomically part transitions red statements 
model checker experience increase running time proportional number collection attempts 
di erence common run time system model checker regards possibility unwinding forward moves 
model checker spin encounters visited state performs backward move matches forward move trail stack 
result model checker restores current state previously visited states 
simple transitions example assignments small information kept directly trail stack 
cases state entirely copied stack order performing backward move 
model checker keeps separate stack states thoroughly modi ed forward moves denoted state stack 
garbage collector runs transition thoroughly modify heap area adjacent tables set size type table 
order able restore transition source state model checker needs save entire heap area additional tables state stack 
needed impossible predict behavior collector objects reclaimed 
discussed section garbage collection algorithm keeps additional information heap allocated objects table 
modi ed collector run need saved state stack 
results memory overhead proportional state stack depth 
discussion regards implementation details collection algorithm particular 
estimation time space overhead introduced algorithm reported 
counting counting collector keeps global table number object 
discussed section number pointers directly point object 
collector runs number zero objects 
objects deleted collector runs recursively objects pointed deleted objects elds 
collection stops reachable object deleted 
time taken collector run number objects reachable set program pointers denoted follows roots point collection attempted 
interesting property counting collection regards possibility performing partial static evaluation set roots depending nature statement trigger collection 
pointer assignment statements set roots contains left hand side pointer 
case garbage collection attempted assignment takes place 
statements exit functions local scopes set roots contains local pointers 
situation involves explicit delete statements 
case set roots contains pointer elds deleted object 
said type object statically evaluated information encoded run time type table 
depending object type collector identi es layout position pointer elds 
order estimate time overhead introduced counting collection denote crc total number collector runs 
total number successful collections total number garbage collector invocations counting collector stops soon object deleted 
notations worstcase time overhead introduced counting collection crc 
number depends way program data structured 
may di er collection 
order able evaluate time collection follows assume represents average value 
space overhead estimated considering collection requires saving type table state stack 
practice size type table entry bytes integer table entry represented bytes short 
consequently collection introduces space overhead nmax bytes nmax maximum number heap objects 
crc represents number counting collections performed model checking needing save tables state stack space overhead nmax log crc 
maximum depth state stack log crc 
practice time space overheads show quite small counting default garbage collection mode dspin 
mark sweep mark sweep collection performs thorough scan reachable data marks objects encounters scan 
mentioned section mark phase starts set live program pointers roots 
anymore statically evaluated process statically determined 
problem overcome giving description global pointers local pointers declared proctype function 
data structure called pointer map built veri er generator 
nd roots collector starts top process stack scans downward frame frame 
frame keys function proctype corresponds frame giving entry pointer map 
frame collector marks starting pointers frame marks starting global pointers 
mark phase recursive spanning done object types kept type table 
mark phase completes sweep phase deletes unreachable data 
order entire heap area scanned time collector runs 
denote cms total number collector runs 
total number collector invocations mark sweep collector performs complete scan reachable data time invoked 
notations worst case time overhead introduced mark sweep collection nmax cms 
space overhead introduced need save type table state stack 
previously explained mark table written mark phase cleared time sweep phase don need save state stack 
size type table entry bytes 
consequently space overhead introduced mark sweep collection nmax bytes nmax maximum number objects 
state saved stack time collection successful object deleted 
denote number del ms mark sweep space overhead nmax log del ms 
overhead comparison evaluations time space overheads previously introduced attempt nd circumstances counting collection better mark sweep vice versa 
remind reader evaluations related implementation algorithms dspin 
denote follows counting time overhead trc crc space overhead src nmax log crc 
mark sweep denote time overhead tms nmax cms space overhead sms nmax log del ms 
time overhead comparison tms trc cms crc nmax rst term cms crc greater mark sweep runs time invoked counting stops objects deleted 
second term expression give case evaluation 
precisely greater nmax 
gives su cient condition counting collection run faster mark sweep 
practice condition usually met common programs 
space overhead comparison src sms log crc log del ms second term expression depends program data layout 
program cyclic data structures collection algorithms reclaim number objects crc del ms consequently src sms 
reported follows practice space overhead introduced mark sweep smaller introduced counting 
experimental carried number experiments order asses practical value garbage collection combination model checking 
obviously immediate advantage tracking programs may create unbounded number objects 
garbage collection reduces number states veri cation consequently model checker time space requirements 
rst part section reports experiments performed dspin speci cation tree structure 
reduction number states compared time space overhead introduced collection algorithms 
remainder section concerned estimation best worst case complexity doubly linked list example 
analysis time reports obtained unix time command mb ram ultra sparc mhz workstation 
small times seconds tend inaccurate operating system overhead 
tree example revisited example considered revision test case reported 
system describes tree structure accessed concurrently updater processes 
mutual exclusion protocol order ensure data consistency allowing simultaneous updater accesses structure 
order avoid unbounded growth structure updater stops execution prede ned maximum depth reached 
speci cation tested absence deadlocks 
example parameterized respect variables denotes tree order denotes maximum tree depth rst case explicit delete statements inserted model 
table shows results obtained performing analysis presence explicit delete statements rst garbage collection applying collection algorithms counting rc mark sweep ms implemented dspin 
table 
explicit delete tree states memory mb gc runs time options rc ms collapse rc collapse ms collapse bs rc bs ms bs number collector runs table 
counting total number successful collections collections object reclaimed 
comes consequence fact counting collection stops reclaim objects 
mark sweep collection performs exactly sweep heap area time invoked 
case number collector invocations number collector runs 
noted garbage collection acts complexity reduction mechanism 
explicit delete statements inserted model tend increase number states 
intuition semantically equivalent states match di erent orderings objects heap area 
garbage collection constantly reduces number objects reduces number possible interleavings heap representation 
implementors java pathfinder tool considered possibility representing heap objects way disregarding creation order reduction number states 
rst case garbage collection ine cient 
allowing maximum tree depth implies object deleted update 
case garbage collection introduces overhead memory space improve veri cation performance 
second case shows clearly garbage collection reduces model checker state space conse quently time space requirements 
due fact model tree nodes doubly linked mark sweep collection cient counting 
case analyzed bitstate hashing bs 
table shows hash factor reported veri er bs 
noted case garbage collection reduces state space complexity improves hash factor 
second suite experiments performed replacing explicit deletes skip statements 
table shows results 
general number states experiences remarkable decrease lack explicit deletes semantically equivalent states match cases 
table 
explicit delete tree states memory mb gc runs time options rc ms rc ms rc ms collapse ma rc collapse ma ms collapse ma case garbage collection reduce state space tends slightly increase case veri ed mark sweep 
noticed memory requirements tend decrease consequence decrease current state size 
case memory overhead introduced garbage collection balances gains resulting greater memory requirement 
discussed space overhead introduced garbage collection tends increase logarithmically number collections total number states 
cases show actual decrease memory taken veri er garbage collection 
worst best case estimation performed number experiments order give upper lower bound ciency collection algorithms 
test case speci cation doubly linked list sequentially process 
process xed number list updates counted variable 
purpose counter variable ensure number states change garbage collection 
value counter incremented iteration states current iteration match states previous iterations 
number states point evaluation 
worst case xed number cons cells inserted list 
cells continuously referenced head list program runtime garbage collection impossible 
best case number cons cells inserted list insertion cell extracted resetting list 
explicit deletes performed cells reclaimed garbage collector 
table shows analysis results 
table 
worst best case garbage collection gc runs states memory mb time secs worst case rc ms ii 
best case rc ms noticed worst case space overhead introduced counting greater introduced mark sweep 
hand worst case time taken counting smaller taken mark sweep 
case collection algorithms ine cient reclaim object 
best case mark sweep yields better results space time counting making analysis cient 
comes consequence fact case rate successful mark sweep collections big occurs iteration 
providing model checkers dspin support garbage collection allows analysis wider class real life software systems 
occurs dspin source code distributed url www dai arc dai arc auto tools tool shtml consequence widespread garbage collection current programming environments 
particular programs rely strictly garbage collection ones written java tend create models unbounded growth working memory 
despite limited run time overhead introduced collection algorithms embedding model checking improve analysis results general acting state reduction mechanism 
implementing algorithms model checker attention paid particularities model checking environment possible backward moves 
evaluation time space overhead introduced garbage collection 
tightly related layout data structures program worst best case estimation 
experiments carried order assess practical value 

andrew appel modern compiler implementation java 
cambridge university press 
corbett constructing compact models concurrent java programs 
proc 
international symposium software testing analysis 
corbett dwyer bandera extracting finite state models java source code 
proc 
nd international conference software engineering 
iosif deadlock detection tool concurrent java programs 
software practice experience vol 
iosif dspin dynamic extension spin 
lecture notes computer science vol 
springer verlag berlin heidelberg new york 
brat havelund park visser java pathfinder second generation model checker 
workshop advances veri cation 
holzmann design validation computer protocols 
prentice hall 

iosif dspin user manual 
www dai arc auto tools tool shtml 
