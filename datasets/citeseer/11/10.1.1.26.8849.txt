global register allocation graph fusion yuan thomas gross ali reza adl tabatabai march cmu cs school computer science carnegie mellon university pittsburgh pa register allocator effectively deal issues live range splitting live range spilling register assignment 
presents new coloring global register allocation algorithm addresses issues integrated way algorithm starts interference graph region program region basic block loop nest superblock trace combination basic blocks 
region formation orthogonal register allocation framework 
interference graphs adjacent regions fused build complete interference graph 
algorithm delays decisions splitting spilling register assignment register allocation may better obtained style allocator 
algorithm uses execution probabilities derived profiles static estimates guide fusing interference graphs allowing easy integration register allocator region compiler 
research sponsored part advanced research projects agency ito monitored contract 
views contained document authors interpreted representing official policies expressed implied arpa government 
keywords register allocation graph coloring graph fusion compiler optimization code generation graph coloring established approach register allocation crucial component optimizing compilers 
developments compiler design processor technology warrant new look global register allocation 
modern compilers include aggressive transformations function inlining loop unrolling exploit instruction level parallelism single basic block 
transformations global instruction scheduling create challenges register pressure increases values may allocated register ii register allocator sensitive compiler optimizations compiler heavily optimizes region program register allocator consider information deciding insert spill code 
developed register allocation framework addresses concerns illustrates benefits obtained new approach alvinn program spec suite 
shows total number data movement operations executed due register allocation operations save restore register register copies 
functions called main loop program inlined 
left see number data movement operations enhanced chaitin style register allocator 
middle see results approach described removes data movement operations compared chaitin style register allocator 
simple enhancement observation caller saved callee saved registers implies different costs improves results reduces data movement overhead shown right 
framework region register allocator operates groups basic blocks formed profile information static analysis 
register allocator dictate regions formed provides general flexible approach register allocation form priorities regions parameters algorithm 
regions individual basic blocks traces superblocks grouping compiler loop structure :10.1.1.112.9778
framework fits nicely code generators take similar approach instruction scheduling register allocator uses units compilation execution probability estimates instruction scheduler 
framework allows model number different approaches register allocation including classical chaitin style register allocation region function 
key idea approach incrementally build interference graph 
consider task allocating registers compilation unit function 
building interference graph function cutting colorable start interference graphs smaller units build interference graph complete function 
approach allows register allocator delay decisions live range spill split parts program analyzed 
order parts program analyzed determines overhead operations placed 
register allocator takes priorities regions account making spilling splitting decisions live ranges split necessary boundaries lower priority regions minimizing cost additional data movement code 
spilling splitting integrated segments live range low spill cost span regions high priority high register pressure spilled 
base register allocator powerful fusion operator interference graphs regions fused build complete interference graph 
major benefit region approach register allocator custom tailor callee saved registers 
discussions register allocation pay attention common practice designating registers callee saved caller saved 
register allocator split live range manner isolates spills parts cross frequent function calls 
alvinn chaitin region region cro data movement operations impact different register allocation strategies 
terminology common approach model register allocation problem graph coloring problem assigning colors physical registers nodes live ranges virtual registers heuristic order 
process blocks vertices degree greater number registers legal color exists node 
coloring blocks compiler lower maximum degree vertices interference graph allow coloring proceed 
major techniques developed lower degree interference graph splitting live range splitting segments long live range lr smaller live ranges lr 
shuffle code needed move data value control passes segment lr segment lr splitting reduce register pressure reduces degree interference graph 
expectation lr lower degree lr new graph colored 
spilling live range assigned location memory done memory accesses loads stores referred spill code 
spilled live range removed interference graph longer register assignment candidate lowering register pressure 
spill cost split cost execution cost spill shuffle code 
basic techniques leave compiler wide range options compiler decisions influence quality code 
decision compiler ffl order live ranges considering coloring 
ffl spill split coloring fails live ranges spill split case splitting place shuffle code 
ffl assign callee save caller save register live range 
register allocator isolates aspects allows compiler pick heuristic strategy line rest compiler design 
background prior frequently employed technique allocate virtual register infinite pool registers register allocation candidate 
candidates user variables constants compiler generated temporaries depending strategy chosen 
liveness analysis reaching analysis determine live range virtual register 
live ranges constructed manner may comprised disjoint segments resulting unnecessarily high number conflicts live range 
renumbering web analysis techniques construct concise live ranges result interference graphs potentially lower degree 
virtual registers mapped physical registers register allocator spill shuffle code added program necessary 
chaitin style register allocation chaitin algorithm observation vertex degree trivially colored matter colors assigned neighbors legal color remain vertex degree called unconstrained 
interference graph chaitin algorithm proceeds successively removing unconstrained vertices graph 
time vertex removed edges incident removed degrees neighbors decremented 
process known simplification 
vertices removed colors assigned vertices reverse order removed 
simplification blocks remaining vertices degree time live range picked spilled heuristic cost function 
cost function spill cost live range benefit removing live range interference graph degree live range 
registers assigned spill code process building interference graph performing simplification repeated spilling necessary 
refinements basic algorithm implemented 
coloring register allocation algorithm rs compiler improves basic algorithm ways 
interference graph colored times time variation cost function coloring resulting total spill cost selected 
second live range selected spilling inserting load store definition attempt insert single load store inside basic block 
effect split segments span basic block 
simplification heuristic approach coloring may legal coloring opportunities 
optimistic coloring improves simplification attempting assign colors live ranges spilled basic algorithm 
optimistic coloring delays spill decisions register assignment phase 
basic algorithm spill candidate chosen simplification blocks deciding spill live range removed graph added set live ranges assigned colors 
spill decisions register assignment phase legal color exists live range colored live range spilled 
style approach simple fast produces results programs colorable interference graphs 
interference graph colored simplification approach spilling decisions definitions uses spilled live range go memory parts live range allocated register 
beneficial spill troublesome segments live range segments contain span regions high register pressure keeping registers segments regions high execution frequency 
despite attempts improve spill code practice situations splitting produces better results 
difficult adopt live range splitting chaitin approach 
interference graph encode information program control flow structure patterns live ranges graph guide partitioning live ranges 
difficult splitting decisions simplification blocks reasons 
difficult decide partition live range manner allows registers assigned critical regions code minimizes split cost allows simplification proceed 
second interference graph rebuilt time live ranges split 
contrast spilling simplification resume spilled live range removed interference graph 
third difficult decide spilling splitting difficult distinguish cases high register pressure spilling absolutely necessary cases interference graph high degree splitting reduce interference graph degree 
splitting live ranges coloring approaches tried fit live range splitting chaitin coloring framework splitting live ranges prior coloring 
motivation reduce degree interference graph allow spilling live range segments span program regions high register pressure 
aggressive live range splitting uses static single assignment ssa representation program determine split points 
live range split oe node incoming values oe node result distinct assignments 
approach splits live ranges span loop splitting live ranges immediately loop 
harrold partition live range finer granularity considering ranges instructions loads stores virtual register 
approaches splitting live ranges coloring drawbacks 
decisions regarding live ranges split split prematurely 
live ranges split unnecessarily resulting performance degradation due unnecessary shuffle code 
various heuristics developed eliminate shuffle code increasing chance color partner live ranges biased coloring conservative coalescing 
determining critical regions splitting spilling beneficial approaches split live ranges arbitrarily greedily hopes steps clean unnecessary splits 
second points program live ranges split approaches necessarily points low execution probability 
approaches may execution probabilities determine points split live ranges guarantee resulting live ranges fit registers spilling 
register allocator runs risk splitting leading unnecessary shuffle code consequence high frequency live ranges spilled 
priority coloring priority coloring approach alternative framework allows splitting decisions delayed coloring blocks 
contrast chaitin approach register allocator assigns physical registers virtual registers approach begins live range assigned home location memory 
effect algorithm begins live ranges spilled memory 
coloring greedily assigns colors live ranges heuristic order determined priority function 
priority function captures savings memory accesses assigning register live range keeping live range memory 
priority function profile information static estimates live ranges deeply nested loops high priority 
colors assigned unconstrained live ranges removed interference graph unconstrained live ranges assigned legal color colors assigned live ranges 
simplification degree nodes neighboring removed unconstrained nodes decremented 
color assignment blocks legal color exists live range colored colors taken neighbors 
point split 
facilitate splitting live range candidate defined collection live units live unit basic block live 
splitting forms new live range starting seed live unit incrementally adding live units new live range adding live unit renders 
live units added breadth traversal control flow graph preferably starting live unit definition 
live range spilled remains home location live units comprise live range register 
important consideration live range splitting selecting points shuffle code inserted 
reduce split cost shuffle code placed points low execution probability 
priority approach take execution frequency account inserting shuffle code guarantee split points frequently executed edges 
shuffle code induced split may loop back arc code motion techniques register assignment optimize placement shuffle code 
program structure approaches approaches register allocation attempt graph coloring sensitive program structure dividing program regions prioritizing regions execution probabilities 
register allocator colors regions order priorities shuffle code inserted boundaries regions 
representative program structure approaches include tera multiflow rag compilers 
tera compiler described constructs tile tree program tree corresponds control flow hierarchy program 
register allocation colors tiles phases 
phase traverses tile tree bottom allocates pseudo registers live ranges tile graph coloring 
pseudo registers capture constraint virtual registers allocated physical register 
variables tile assigned pseudo register parents tile adhere decision 
second phase walks tile tree top binds pseudo registers physical registers 
biased coloring avoid unnecessary shuffle code tile boundaries 
coloring performed hierarchically shuffle code tends outside innermost loops 
requirement observe lower level coloring imposes constraints coloring moves root tile tree 
illustrates unnecessary constraints imposed register allocation premature coloring decisions 
code consists tiles loop shaded region blocks loop region colored 
interference graph region depicted 
inside region live range lr live live ranges lr lr loop 
live range lr live lr live coloring graph registers lr placed pseudo register lr pseudo register lr 
information inside loop region choices reasonable 
lr lr pseudo register shuffle move inevitable hb hb lr lr merge lr lr pseudo register shuffle code required mapping beneficial determined dealing presents approach address deficiency delaying binding decisions 
contrast algorithm takes lazy approach color assignment avoid premature coloring decisions 
tile tree rag compiler colors region nodes function program dependence graph pdg proceeding hierarchical manner leaves root 
chaitin algorithm region node 
coloring decision region preserved parent nodes region 
may prevent graph coloring finding best solution affects live range splitting 
live range split live range spilled parent region live range split boundaries parent region subregions live range live 
live ranges determined register subregions considered node parent region interfere union live ranges individual live ranges interfere 
multiflow compiler employs trace scheduling framework register allocation schedul lr lr lr loop premature coloring decision 
ing 
trace scheduler picks trace passes code scheduler code scheduler performs register allocation scheduling 
code scheduler records register usage preferences scheduled trace information maintained exit entry trace 
information subsequently translating traces connect exit entry points shuffle code traces needed value kept register 
traces compiled freedom registers shuffle code ends boundaries traces compiled 
long trace presents traces order reflects execution frequency scheme favors frequently executed parts program 
drawback approach coloring register allocation 
approaches exist approaches register allocation live range splitting 
example probabilistic register allocation hybrid priority program structure approaches 
approach consists steps local register allocation global register allocation register assignment 
variables initially reside memory virtual registers load store definition 
estimate probability variable allocated register priority local global register allocation steps determining get registers 
real register assignment deferred till register assignment step 
global register allocation step partitions program regions loop hierarchy proceeds innermost loops outermost loops 
variable assigned register shuffle code placed pre header post exit loop load value variable register restore back memory value updated 
obvious outer loops deal shuffle code 
fischer perform live range splitting register allocation free registers improve code scheduling 
empty delay slots final schedule filled shuffle code split spill live ranges 
spilling frees registers additional registers remove false dependencies induced reuse registers 
overview register allocation graph fusion key idea build interference graph starting live ranges extend single region 
region initially interference graph 
region small single basic block large function case algorithm identical chaitin style register allocation 
regions connected control flow edges prioritized 
edges considered priority order interference graphs regions connected edge merged fusing interference graphs 
fusion operator coalesces live ranges span control flow edge maintains invariant resulting merged interference graph colorable necessary splitting suppressing coalescing live range 
fusion operator spilling splitting decisions clear impossible unprofitable keep live ranges registers 
control flow edges considered single colorable interference graph remains 
phases framework region formation graph simplification graph merging register assignment 
region formation phase regions formed number possible techniques 
example region single basic block trace superblock region defined blocks particular static loop nesting level blocks pdg region node :10.1.1.112.9778
control flow edges lie outside regions ordered priority function consistent region formation approach edges entering innermost loop regions ordered entering outermost loop regions 
particularly attractive priority function execution probabilities 
derived profile information static estimates loop nesting depth static branch estimates :10.1.1.112.9778
choice edge ordering orthogonal register allocation course impacts quality code register allocation framework edge order sensitive shuffle code edges ordered spilling decisions delayed edges processed 
region formation interference graph gr built region virtual register segment live range lr extends block denoted lr segment region live reaching 
objective graph simplification phase determine live ranges spilled region 
interference graph gr simplified spill code necessary region gr simplified perspective cheapest live ranges spill transparent live ranges lr span definition global perspective choice live ranges best ones spill determined point algorithm 
decision live range spill delayed global knowledge patterns available phase determines transparent live ranges need spilled region 
phase graph merging determines live ranges best ones spill 
technique referred delayed spilling discussed detail section 
describe compiler spill live ranges transparent ones 
graph merging phase takes sequence control flow edges determined region formation phase fuses interference graphs edge 
graph merging powerful fusion operator maintains invariant resulting interference graph simplified 
live range splitting decisions fusion operator fusing graphs edge results interference graph simplified live ranges span split 
live ranges span need considered worst case splitting live ranges partitions graph back original graphs 
graph merging phase left interference graph know live ranges spill region place shuffle code physical registers committed live range 
invariant lazy approach allows avoid making coloring decisions prematurely lr lr spilled transparent non transparent spilled spilled spill section split section transparent coalesced transparent coalesced non transparent non transparent coalesced non transparent different possibilities coalescing lr lr 
graph merging phase 
coloring assignment decision live range graphs loop region fused 
know interference graph loop region colorable 
actual coloring decision deferred till register assignment phase 
graphs fused delayed spilling mechanism gradually spills live ranges 
net effect combining splitting delayed spilling register allocator may spill segments virtual register live range contain span regions high register pressure 
register assignment phase physical registers assigned live ranges shuffle code generated 
invariant guarantees interference graphs fused resulting interference graph colorable spilling splitting decisions 
shuffle code inserted edge hb live ranges extend different storage locations shuffle code load store register register move shuffling memory locations necessary live ranges virtual register spilled location memory 
straight forward insertion shuffle code may result partial redundancies shuffle code 
general partial redundancy elimination algorithm optimize shuffle code simple technique effective practice details discussed section 
exist opportunities improving code phase biased coloring may eliminate shuffle code optimistic coloring may assign registers live ranges spilled simplification notice live range gets caller saved register region high call frequency register may decide spill live range 
fusing interference graphs consider basic blocks regions connected edge hb control flow graph 
virtual register live edge live range segments lr states spilled represented gr transparent represented gr non transparent 
fusion operation attempts coalesce live range segments lr lr range interference graph gr shuffle code needed segments spilled shuffle code needed 
spilled transparent spill combined live range reduce register pressure live range spilled region 
spilled non transparent split point 
segments coalesced new interference graph coalescing may suppressed split 
enumerates cases 
live range attributes propagated graph fusion caller save cost spill cost def 
caller save cost attribute estimated cost assigning caller saved register live range 
cost number saves restores executed function calls live range assigned caller saved register 
spill cost attribute estimated spill cost live range 
caller save cost spill cost properties register assignment decide live range assigned empty entries table symmetric cases 
callee save register caller save register profitable spill live range 
def property true live range lr definition lr 
information indicates value needs stored memory exits lr live range modify value virtual register stores required exits live range 
basic block data flow sets maintained liveout 
virtual register definition reaches entry liveout live exit liveout sets indicate live ranges span edge fusion operator ensures invariant holds performing simplification gr simplification gr blocks coalesced live range lr chosen splitting set remaining constrained nodes 
lr split back lr lr 
splitting live range degree interference graph may lowered allowing simplification proceed point blocked 
simplification blocks additional live ranges split 
original graphs gr gr worst live ranges span split 
graph merging proceeds interference graphs fused resulting denser interference graphs 
earlier edge considered fusion process live ranges split edge 
provides nice property don want shuffle code particular edge fuse interference graphs edge 
consequently decision split prioritized edge ordering shuffle code ends frequently executed edges 
example illustrate steps example 
consider assigning registers program fragment shown 
assume physical registers regions basic blocks 
virtual registers program initial live ranges indicated vertical bars 
interference graph basic block prior fusion depicted 
suppose edges form frequently executed path edges fused order 
fuse edges obtain interference graph interference graph nodes list live ranges fused 
fuse interference graphs edge lr lr combined live range spanning edge lr 
fusing edge graph clique size algorithm undoes combining lr lr 
lr effectively split frequently executed point control flow graph 
result values kept registers additional register move instruction block splitting reduce call cost dividing registers sets callee save caller save registers provides register allocation freedom minimizing call overhead 
cost associated kind register assigned live range 
live range lr ends caller save register pay cost saving restoring lr value function calls crossed lr 
similarly lr ends callee save register register may saved restored entry exit function 
allow register allocator choose right kind register live range model cost functions caller callee respectively 
functions defined live range lr 
lr caller lr resp 
callee lr defined weighted counts spill code minus weighted caller save resp 
callee save cost 
functions indicate estimated number loads stores eliminated caller save callee save register assigned lr 
register assignment phase selection kind register functions 
callee lr caller lr finding available callee save register lr attempted prior 



edge edge edge edge lr lr lr lr lr lr lr lr lr lr lr lr lr lr lr lr lr lr lr lr lr lr lr lr simple code fragment world 
finding available caller save register 
callee lr caller lr preferable put lr caller save callee save register 
register spilling live range better wrong kind register 
example spill cost may caller save cost 
case live range spilled reduce load store counts available register register wrong kind 
fusing interference graphs tends grow live ranges aggressively reduce shuffle cost long colorability invariant maintained 
improvement algorithm sketched limit growth live ranges cross function calls constraining coalescing 
manner smaller live range chance get best kind register spilled lower spill cost reducing load store counts 
graph colorable may better live range split infrequently executed edges pay lower shuffle cost edges higher caller save cost call sites 
applied alvinn program improvement results reduction data movement operations shown 
heuristic constrain coalescing functions threshold split threshold threshold function determines candidates splitting split function determines splitting result savings 
consider live ranges lr region lr joined edge threshold lr lr function edge execution frequency number registers available assignment weighted counts lr lr 
threshold lr lr decides edge place suppress coalescing lr lr split lr lr judges decision drive number data movement operations 
function tests live range caller save cost spill cost live range caller save cost greater spill cost plus shuffle cost case live ranges coalesced adding lr lr interference graph hurt performance lr lr ends caller save register 
depicts example caller save cost reduced splitting 
example live range live program 
assume lr split occupies register 
register caller save register lr pays high caller cost saving restoring function foo 
cheaper split live range lr lr edge hb illustrated 
lr reside memory callee save register determine callee save cost low 
foo foo lr lr lr shuffle code eliminating caller save cost splitting 
delayed spilling region needs physical registers colored gamma live ranges spilled 
considering local spill costs inside best spill choice transparent live range high degree interference graph cost spilling zero inside assume transparent live ranges region cases considered gamma case number transparent live ranges number live ranges spilled 
choosing transparent live ranges spilling delayed compiler obtains global information patterns transparent live ranges 
searching region immediate neighbors solve problem transparent live ranges may transparent basic blocks 
delayed spilling deals nicely case explained 
large number transparent live ranges common processing high priority edges 
gamma case spill needs satisfied spilling transparent live ranges 
gamma case transparent live ranges gamma gamma live ranges inside spilled 
note spill decisions may globally optimal 
spilling transparent live range attractive construe flow graphs decision optimal 
gamma spill non transparent live ranges selected heuristic spill cost area degrees interference graph 
describe detail delayed spilling technique handle case gamma transparent live ranges conflict live ranges form clique region interference graph 
transparent live ranges collected single clique summary node interference graph depicted 
node contains edge nodes graph transparent live ranges interfere live ranges region 
clique summary node annotated number transparent live ranges represents 
record gamma transparent live ranges spilled specifying ones 
actual size clique gamma 
clique dealt single unit eventually live ranges spilled 
keeping summary node graph keep live ranges interference graph registers delay decision range spill information available 
edge hb live ranges span merged 
live range lr merged lr transparent cases consider 
lr spilled live range lr clique transparent lr removed spilled 
decremented 
decision grows spilled live range allowing compiler avoid shuffle code contiguous range spilled non spilled live range segments incur shuffle code transition spill non spilled vice versa requires shuffle code 

lr non transparent live range lr clique lr removed spilled 
decremented 
decision enlarges non spilled live range live range register adjacent region compiler favors live ranges clique 

lr clique lr clique lr lr coalesced added new clique processing live ranges cliques gamma gamma establishes ranges spilled computed function 
clique time phase means live ranges spilled 
point removed interference graph 
clique size spilled clique summary node 
placement shuffle code register assignment coloring phase done shuffle code inserted necessary edges 
edge hb shuffle code inserted virtual register split lr lr assigned storage location 
shuffle code types register register lr lr assigned different registers move operation required register memory lr assigned register def set lr spilled memory register lr spilled lr assigned register 
need memory memory shuffle code live ranges belonging virtual register spilled single location memory lr lr spilled memory location 
insertion shuffle code simple straight forward step may result partial redundancies code 
instance def property live range lr determines shuffle stores needed exit edges lr 
definitions frequently executed blocks exit edges splitting points frequently executed definitions shuffle stores executed necessary 
estimated costs def cost estimated costs shuffle move register register store register memory load memory register operations simple technique optimize shuffle stores 
live range costs shuffle move store load easily obtained edge annotated estimated execution frequency static profile 
def cost live range estimated weighted number definition live range 
sum def cost plus cost shuffle moves move values live range cost shuffle store shuffle stores eliminated inserting new shuffle store right definition st spilled region spilled region st ld ld edge edge edge edge placement shuffle store 
shuffle moves 
words definition includes shuffle moves store writing new value back memory location live range keep value memory date 
technique quite effective practice 
reason code motion step global optimization phase moves loop invariant common subexpressions loops definitions common subexpressions frequently executed may spilled inside part loops due high register pressure 
depicts optimized placement shuffle code 
live range defined live program 
spilled loop indicated shaded region 
shuffle code highlighted bold face 
straight forward shuffle code insertion requires shuffle code depicted shuffle store edge spilled region shuffle load edge spilled region 
shuffle store executed loop iteration despite fact modified defined frequently executed edge traversed placement shuffle store optimized eliminating shuffle store edge inserting new shuffle store immediately definition depicted 
evaluation framework implemented compiler optimizing retargetable compiler developed cmu 
data code generator mips dynamic numbers obtained decstation 
runtime cost algorithm moderate 
version compiled debug support optimizations runs times slower native compiler measured impact register allocation strategy various spec programs li alvinn espresso compress eqntott ear sc matrix doduc spice nasa fpppp 
contrast baseline algorithm improvement section results known enhanced chaitin style approach 
registers mips adhering standard calling convention 
taken preliminary 
tuned 
compiler compile support debugging optimized code forced flag undergoing active development 
implemented assess choice language implies performance penalty relative native compiler 
start smallest region size basic block grow interference graph function 
functions main loop alvinn inlined 
approaches run experiments 
static information guide register allocation 
loop depth estimate execution frequency block 
region approach considering basic blocks inside loop breath order select edges fusing 
second experiment profile information prior execution 
alvinn chaitin chaitin prfl region region prfl data movement operations fpppp chaitin chaitin prfl region region prfl spill load spill store shuffle load shuffle store shuffle move callee ld st caller ld st chaitin chaitin prfl region region prfl data movement operations nasa chaitin chaitin prfl region region prfl tomcatv chaitin chaitin prfl region static region prfl doduc available registers int double 
available registers expected programs small functions chaitin algorithm works fairly approach produces identical results 
programs profile information improves result independent register allocation strategy 
turn attention programs significant register pressure 
alvinn nasa tomcatv doduc fpppp programs high register pressure see limitations approach spilling foundation chaitin style register allocation 
shows register allocation graph fusion able split live ranges properly cuts alvinn nearly overhead required chaitin style allocation 
chaitin style allocation finds best complete live ranges put registers result improved profile information 
approach breaks live ranges seen lower number spill loads 
profile information provides better cost function register assignment phase deciding live range go caller save register spilled resulting improvement 
looking results fpppp static information see story 
overhead fpppp reduced large contribution shuffle code indicates live ranges split 
profile information approaches find right live ranges give result 
tomcatv approach removes overhead operations 
estimated static information provides estimation profile information help case 
big functions doduc supp 
account majority data movement operations 
supp consist big block 
types functions register allocator produces amount data movement operations chaitin style allocator sole basic block complete compilation unit 
simple way deal blocks partition big block smaller blocks approach applied better spilling splitting decisions 
show result large portions spill loads stores replaced shuffle code reduction edge ordering static information reduction profile edge ordering 
chaitin chaitin prfl region region prfl data movement operations alvinn fpppp chaitin chaitin prfl region region prfl spill load spill store shuffle load shuffle store shuffle move callee ld st caller ld st chaitin chaitin prfl region region prfl data movement operations nasa chaitin chaitin prfl region region prfl tomcatv chaitin chaitin prfl region static region prfl doduc chaitin chaitin prfl region region prfl data movement operations spice espresso chaitin chaitin prfl region region prfl smaller number registers int double 
smaller number registers causes high register pressure function inlining small number registers 
explore second dimension run experiments reduced number registers integer double argument registers integer double return registers managed register allocator plus integer double caller save integer double callee save registers 
results depicted 
notice overhead chaitin style allocation includes fair number operations move values caller saved registers 
interestingly result obtained algorithm static information better smaller number registers 
indicates cost functions improved fewer registers live ranges grow 
easier register assignment phase give small live range kind register requires caller saved callee saved 
reason register allocation static information superior allocation profile information related issue 
live range spilled graph merging spill cost may lower spilling happens register assignment avoid high call overhead 
happens profile information 
espresso program approach able produce better register allocation 
notice significant number overhead operations shuffle load stores 
algorithm splits number live ranges part ends register memory 
see impact dealing spilling splitting register allocator eliminates spill load store cost introducing shuffle code frequently executed edges 
overhead nasa reduced equal total number loads stores 
region region cro region prfl region prfl cro data movement operations alvinn region region cro region prfl region prfl cro compress spill load spill store shuffle load shuffle store shuffle move callee ld st caller ld st region region cro region prfl region prfl cro data movement operations nasa region region cro region prfl region prfl cro eqntott impact call cost optimization cro 
call cost optimization importance getting right kind register experiment take positive action limit growth live ranges described section 
presents results alvinn compress eqntott call cost optimization 
profile information differences negligible 
surprising definition threshold cost functions 
recall live range assigned caller save register high caller save cost low spill cost spilled memory register assignment phase registers hold live range 
live range picked spilled stage splitting attempted 
words go memory 
effect decision increase amount spill code reduce loads stores caller saved registers 
spill code see alvinn eqntott due live ranges spilled register assignment 
call cost optimization section suppresses coalescing live range segments lr lr say lr high caller save cost coalesced live range high caller save cost 
coalescing lr low caller save cost gets desired caller save register lr ends memory callee saved register 
lr memory extra shuffle loads stores required 
lr callee save register shuffle loads stores needed shuffle moves inserted 
modern machines moves cheaper loads stores 
results shown illustrate benefits nicely 
optimization succeed isolating high caller save cost regions frequently executed edges 
consequently register assignment phase spills fewer live ranges memory 
case alvinn half overhead operations shuffle moves 
eqntott shuffle moves shuffle loads stores 
case alvinn approach dealing spilling splitting including call cost optimization reduces total data movement overhead compared chaitin style allocator 
new approach register allocation 
algorithm produces results situations conventional chaitin style allocator breaks 
measured reduction runtime cost register allocation 
course programs significant register pressure 
aggressive compiler transformations common simple programs turned challenges global register allocator 
algorithm especially attractive compilers look regions basic blocks optimization opportunities perform global scheduling 
compilers register allocator presents effective way deal programs exhibit high register pressure 
appreciate comments feedback bernstein ibm israel chow silicon graphics mips freudenberger hp laboratories silicon graphics mips 
bernstein goldin golumbic krawczyk mansour pinter 
spill code minimization techniques optimizing compilers 
proceedings acm sigplan conference programming language design implementation pages 
acm july 
briggs 
register allocation graph coloring 
phd thesis rice university april 
briggs cooper kennedy torczon 
coloring heuristics register allocation 
proc 
sigplan symp 
programming language design implementation pages 
acm july 
callahan koblenz 
register allocation hierarchical graph coloring 
proc 
sigplan programming language design implementation pages toronto june 
acm 
chaitin auslander chandra cocke hopkins markstein 
register allocation coloring 
research report ibm watson research center 
chang mahlke chen warter hwu 
impact architectural framework multiple instruction issue processors 
proc 
th intl 
symp 
computer architecture pages 
acm ieee may 
chow hennessy 
priority coloring approach register allocation 
acm trans 
programming languages systems oct 
fisher freudenberger 
predicting conditional branch direction previous runs program 
proc 
fifth intl 
conf 
architectural support programming languages operating systems asplos pages 
acm october 
freudenberger 
phase ordering register allocation instruction scheduling 
giegerich graham editors code generation concepts tools techniques pages 
springer verlag 
hank hwu rau 
region compilation motivation 
proc 
th annual acm ieee intl 
symposium microarchitecture page appear ann arbor nov 
acm ieee 
hwu mahlke chen chang warter hank holm 
superblock effective technique vliw superscalar compilation 
journal supercomputing march 
johnson miller 
effectiveness machine level global optimizer 
proceedings acm sigplan symposium construction pages 
acm july 
harrold 
load store range analysis global register allocation 
proceedings acm sigplan conference programming language design implementation pages 
acm june 
fischer 
zero cost range splitting 
proceedings acm sigplan conference programming language design implementation pages 
acm june 
lowney freudenberger lichtenstein nix donnell :10.1.1.112.9778
multiflow trace scheduling compiler 
journal supercomputing march 
norris pollock 
register allocation program dependence graph 
proceedings acm sigplan conference programming language design implementation pages 
acm june 
proebsting fischer 
probablistic register allocation 
proceedings acm sigplan conference programming language design implementation pages 
acm june 
wall 
predicting program behavior real estimated profiles 
proc 
acm sigplan symposium compiler construction pages 
acm june 
appendix detailed example appendix provide example show interaction edge ordering shuffle code placement 
code fragment taken function update weights alvinn 
consider edge ordering loop hierarchy hb hb hb hb hb hb hb requires registers tmp tmp tmp referenced block 
addition transparent live ranges induced tmp tmp 
live ranges spilled interference graph simplified fusion takes place 
fusing edge hb doesn splitting spilling decision invariant holds resulting graph 
needs registers transparent live range tmp spilled 
fusing edge hb spilled live range tmp grows cover 
fusing remaining edges final resulting graph requires shuffle code move values different locations 
shuffle code highlighted bold face 
tmp definition loop shuffle store doesn edge hb placed right definition outside loops 
change edge ordering hb hb switched register allocator ends different spill decision seen 
shuffle load tmp hb needed longer tmp spill region 
furthermore shuffle load tmp placed hb hb spill region tmp indicated dotted line contains 
loop loop back edge 
tmp tmp tmp tmp 
tmp 
tmp 
tmp 
tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp 
tmp 
tmp tmp tmp 
tmp 
tmp tmp tmp tmp 
tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp 
tmp 
tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp spill tmp tmp loop loop loop st tmp st tmp st tmp ld tmp ld tmp ld tmp ld tmp region spill region tmp tmp tmp 
tmp 
tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp tmp spill tmp spill st tmp st tmp st tmp ld tmp ld tmp region region ld tmp tmp spill region code fragment alvinn 

