alternating time temporal logic rajeev alur thomas henzinger orna kupferman 
temporal logic comes varieties linear time temporal logic assumes implicit universal quantification paths generated system moves branching time temporal logic allows explicit existential universal quantification paths 
introduce third general variety temporal logic alternating time temporal logic offers selective quantification paths possible outcomes games game system environment alternate moves 
linear time branching time logics natural specification languages closed systems alternating time logics natural specification languages open systems 
example preceding temporal operator eventually selective path quantifier specify game system environment system strategy reach certain state 
problems realizability controllability formulated model checking problems alternating time formulas 
depending admit arbitrary nesting selective path quantifiers temporal operators obtain alternating time temporal logics atl atl interpret formulas atl atl alternating transition systems 
ordinary transition systems transition corresponds possible step system alternating transition systems transition corresponds possible move game system environment 
fair alternating transition systems capture synchronous asynchronous compositions open systems 
synchronous systems expressive power atl ctl comes cost model checking complexity synchronous atl linear size system length formula 
symbolic model checking algorithm ctl extends modifications synchronous atl asynchronous atl model checking complexity quadratic 
atl obvious candidate automatic verification open systems 
case atl model checking problem closely related synthesis problem linear time formulas requires doubly exponential time synchronous asynchronous systems 
preliminary version appeared proceedings th ieee symposium foundations computer science focs pp 

supported part onr yip award nsf career award ccr nsf ccr afosr contract aro muri daah arpa nag src contract dc 
department computer information science university pennsylvania philadelphia pa computing science research center bell laboratories murray hill nj 
email alur cis upenn edu 
url www cis upenn edu alur 
department electrical engineering computer sciences university california berkeley ca 
email eecs berkeley edu 
url www eecs berkeley edu 
department electrical engineering computer sciences university california berkeley ca 
email orna eecs berkeley edu 
url www eecs berkeley edu orna 
contents alternating transition systems definition ats synchronous ats fair ats alternating time temporal logic atl syntax atl semantics fair atl atl symbolic model checking atl symbolic model checking fair atl symbolic model checking model checking complexity atl model checking complexity fair atl model checking complexity atl model checking complexity atl alternating time calculus game logic incomplete information ats incomplete information atl incomplete information single agent atl incomplete information pnueli proposed linear time temporal logic ltl specify requirements reactive systems pnu 
formula ltl interpreted computation infinite sequence states 
reactive system satisfies ltl formula computations 
due implicit universal quantification set computations ltl express existential possibility properties 
branching time temporal logics ctl ctl hand provide explicit quantification set computations ce eh 
instance state predicate ctl formula requires state satisfying visited computations ctl formula requires exists computation visits state satisfying 
problem model checking verify finite state abstraction reactive system satisfies temporal logic specification ce qs 
efficient model checkers exist ltl spin hol ctl smv mcm increasingly debugging aids industrial designs 
logics ltl ctl natural interpretation computations closed systems closed system system behavior completely determined state system 
compositional modeling design reactive systems requires component viewed open system open system system interacts environment behavior depends state system behavior environment 
models open systems csp hoa automata lyn reactive modules ah distinguish internal nondeterminism choices system external nondeterminism choices environment 
consequently universal computations satisfy property 
existential computation satisfy property 
questions third question arises naturally system resolve internal choices satisfaction property guaranteed matter environment resolves external choices 
alternating satisfaction viewed winning condition player game system environment 
alternation natural generalization existential universal branching studied extensively theoretical computer science cks 
different researchers argued game interpretations ltl ctl specifications open systems 
list instances 
dil reactive system specified set safe computations typically generated transition relation set live computations typically expressed ltl formula problem determine finite safe computation extended infinite live computation irrespective behavior environment 
sensible necessary compositionality require affirmative answer problem 
realizability program synthesis alw pr pr ltl formula sets input output signals synthesis problem requires construction reactive system assigns possible input sequence output sequence resulting computation satisfies 
supervisory control rw finite state machine transitions partitioned controllable uncontrollable set safe states control problem requires construction controller chooses controllable transitions machine stays safe set satisfies general ltl formula 
module checking kv open system ctl formula module checking problem determine matter environment restricts external choices system satisfies 
approaches temporal logic syntax developed specifying closed systems reformulate semantics open systems 
propose enrich temporal logic alternating properties specified explicitly logic introduce alternating time temporal logics specification verification open systems 
formulation open systems considers just system environment general setting set sigma agents correspond different components system environment 
model open systems alternating transition systems 
transitions alternating transition system correspond possible moves game agents 
move game agent chooses set successor states 
game proceeds single state intersection sets chosen agents 
special cases game turn synchronous state agent restricts set successor states agent determined state lock step synchronous state partitioned agents step agent updates component state turn asynchronous state agent restricts set successor states agent chosen fair scheduler 
subclasses alternating transition systems capture various notions synchronous asynchronous interaction open systems 
set sigma agents set computations state system consider game protagonist antagonist 
game starts state step determine state protagonist chooses choices controlled agents set antagonist chooses remaining choices 
resulting infinite computation belongs set protagonist wins 
protagonist winning strategy say alternating time formula hhaii satisfied state hhaii path quantifier parameterized set agents ranges computations agents force game irrespective agents sigma na proceed 
parameterized path quantifier hhaii generalization path quantifiers branching time temporal logics existential path quantifier corresponds hh universal path quantifier corresponds hh ii 
particular closed systems viewed systems single agent sys represents system 
possible parameterized path quantifiers hh ii match exactly path quantifiers required specifying systems 
depending syntax specify set computations obtain alternating time temporal logics logic atl set specified formula ltl restricted logic atl set specified single temporal operator applied state formula 
atl alternating generalization ctl atl alternating generalization ctl alternating time temporal logics conveniently express properties open systems illustrated examples 
multi process distributed system require subset processes attain goal irrespective behavior remaining processes 
consider example protocol verified smv mcm 
desired properties absence deadlocks deadlocked state processor say permanently blocked accessing memory cell 
requirement specified ctl formula read write atl formula hhaii read hhaii write captures informal requirement precisely 
ctl formula asserts possible processors cooperate eventually read write collaborative possibility atl formula stronger guarantees memory access processor matter processors system adversarial possibility 

ctl formula asserts state predicate invariant system component irrespective behavior components adversarial invariance atl formula stands hh sigma states weaker requirement possible invariant component violate system components may cooperate achieve collaborative invariance 
invariant complex system necessary sufficient check component satisfies atl formula 

system live computations ltl formula specified atl formula 

checking realizability program synthesis ltl formula corresponds model checking atl formula maximal model considers possible inputs outputs 

controllability system safe states state predicate specified atl formula 
controller synthesis corresponds model checking formula 
generally ltl formula atl requirement asserts controller strategy ensure satisfaction 
notice atl better suited compositional reasoning ctl 
instance component satisfies ctl formula conclude compound system satisfies 
hand satisfies atl formula hhaii 
model checking problem alternating time temporal logics requires computation winning strategies 
case synchronous atl games finite reachability games 
consequently model checking complexity linear size system length formula just case ctl 
checking existential reachability corresponds iterating existential time operator checking universal reachability corresponds iterating universal checking alternating reachability corresponds iterating appropriate mix governed parameterized path quantifier 
suggests simple symbolic model checking procedure synchronous atl shows existing symbolic model checkers ctl modified check atl specifications extra cost 
asynchronous model due presence fairness constraints atl model checking requires solution infinite games generalized buchi games vw 
consequently model checking complexity quadratic size system symbolic algorithm involves nested fixed point computation 
model checking problem atl harder show complete exptime synchronous asynchronous cases 
remaining organized follows 
section defines model alternating transition systems section defines alternating time temporal logics atl atl section presents symbolic model checking procedures section establishes complexity bounds model checking alternating time temporal logics 
section consider general ways introducing game quantifiers temporal logics 
specifically define alternating time calculus game logic study relationship atl atl section considers models agents partial information global states 
show case alternating transition systems incomplete information model checking problem generally undecidable describe special case decidable exponential time 
alternating transition systems model open systems alternating transition systems 
ordinary transition systems transition corresponds possible step system alternating transition systems transition corresponds possible step game agents constitute system 
definition ats alternating transition system ats short tuple pi sigma ffii components ffl pi set propositions 
ffl sigma set agents 
ffl set states 
ffl pi maps state set propositions true state 
ffl ffi theta sigma transition function maps state agent nonempty set choices choice set possible states 
system state agent chooses set ffi 
way agent ensures state system choice state depends choices agents successor lie intersection sigma choices agents 
transition function non blocking agents choose unique state state 
require intersection contains unique state assuming sigma fa state set choices ffi intersection singleton 
number transitions defined sigma jffi states agent say successor exists set ffi denote succ set successors states say successor agents sigma succ 
successor iff system state agents sigma cooperate state 
computation infinite sequence states positions state successor state refer computation starting state computation 
computation position denote th state finite prefix infinite suffix respectively 
example consider system processes process assigns values boolean variable false leave value unchanged change true true leaves value unchanged 
similar way process assigns values boolean variable false leave value unchanged change true true leaves value unchanged 
model composition processes ats xy pi sigma ffii ffl pi fx yg 
ffl sigma fa bg 
ffl fq xy state corresponds false state corresponds true false similarly xy ffl labeling function pi follows 
fxg 
fyg 
xy fx yg 
ffl transition function ffi theta sigma follows ffi ffq fq xy gg 
ffi ffq fq xy gg 
ffi ffq xy gg 
ffi ffq fq xy gg 
ffi ffq fq xy gg 
ffi ffq xy gg 
ffi xy ffq xy gg 
ffi xy ffq xy gg 
consider example transition ffi 
process controls value change value false true agent determine state system 
determine value ffi ffq fq xy gg letting choose fq fq xy leaving choice case xy second case process consider state state successor state successor state successor system state processes cooperate system move hand agents cooperate system stay state move xy similar considerations follows infinite sequences xy xy xy possible computations ats xy suppose process change false true true resulting ats xy pi sigma ffi differs xy transition function ffi ffq gg cases ffi agrees ffi 
xy possible computation ats xy sequences xy xy 
third suppose process change false true true simultaneously set true transition function resulting ats xy pi sigma ffi differs ffi ffi ffq fq xy gg 
state process decides leave unchanged chooses option fq hand process decides change value true provided simultaneously changed true process chooses second option fq xy gg 
xy xy possible computations ats xy xy 
suppose consider process 
case agents env env represents environment may state change value arbitrarily 
resulting ats xy pi sigma ffi set sigma fb agents transition relation ffl ffi ffi ffq fq xy gg 
ffl ffi ffi xy ffq xy gg 
ffl ffi env ffi env ffi env ffi xy env ffq fq xy fq xy fq gg 
ordinary labeled transition system kripke structure special case ats set sigma agents singleton set 
special case sole agent sys determine successor state states transition ffi sys contain nonempty set choices singleton set 
synchronous ats section special cases alternating transition systems 
cases correspond synchronous composition agents 
turn synchronous ats turn synchronous ats state single agent scheduled proceed agent determines state 
depends state agent scheduled 
accordingly ats turn synchronous state exists agent sigma ffi set singleton sets agents ffi fqg 
state agent constrains choice successor state 
equivalently turn synchronous ats viewed tuple pi sigma oe ri oe sigma maps state agent scheduled proceed theta total transition relation 
successor iff 
example consider ats pi sigma ffi shown ffl pi fout gate gate request 
ffl sigma 
ffl fq ffl fout 
fout gate 
fout gate 
fin 
ffl ffi train ffq fq gg 
train train ctr gate gate request gate gate ctr train controller turn synchronous ats ffi ctr ffq fq fq gg 
ffi train ffq fq gg 
ffi ctr ffq fq gg 
ffi ctr ffi train ffi ctr ffi train fqg 
turn synchronous ats transition function ffi induces assignment agents states oe oe train oe oe ctr 
ats describes protocol train entering gate railroad crossing 
moment train gate gate 
order enter gate train issues request serviced granted rejected controller step 
train may enter gate relinquish 
system agents train controller 
states system labeled ctr controlled computation states controller chooses state 
states controlled train chooses successor states 
lock step synchronous ats lock step synchronous ats state space product local state spaces agent 
state agents proceed simultaneously 
agent determines local state possibly dependent current local states agents independent choices taken agents 
accordingly ats lock step synchronous conditions satisfied 
state space form pi sigma global state agent sigma write component local assuming sigma fa state form hq 
state agent oe exists set fq states local ffi fq fq agent determine local state determine local states agents 
equivalently transition function ffi replaced set local transition functions ffi qa agent sigma total 
successor iff agents sigma ffi 
example ats xy example lock step synchronous 
see note state space fq xy viewed product fu fv hu vi hu vi hu xy hu local transition functions follows ffl ffi ffi fu ffl ffi ffi xy fu ffl ffi ffi fv ffl ffi ffi xy fv ats xy example lock step synchronous ats xy xy 
xy ability process change value depends process step 
fair ats systems modeled ordinary transition systems establish liveness properties necessary rule certain infinite computations ignore enabled choices forever 
instance asynchronous system consisting processes may restrict attention computations processes take infinitely steps 
assumptions incorporated model adding fairness conditions 
motivated similar concerns define fairness conditions ats 
fairness condition ats pi sigma ffii set fairness constraints defining subset transition function 
precisely fairness constraint function fl theta sigma fl ffi states agents sigma 
ordinary transition systems fairness condition partitions computations ats computations fair computations fair 
elaborate interpretations fairness constraints 
consider computation ats fairness constraint fl theta sigma agent sigma 
say fl enabled position fl 
say fl taken position exists set fl interpretations fairness constraints defined respect set sigma agents follows ffl computation weakly hfl ai fair agent infinitely positions fl enabled infinitely positions fl taken 
ffl computation strongly hfl ai fair agent finitely positions fl enabled infinitely positions fl taken 
standard definitions strong fairness implies weak fairness 
fairness condition gamma ats set sigma agents computation weakly strongly gamma ai fair weakly strongly hfl ai fair fairness constraints fl gamma 
note fairness condition gamma set agents prefix computation extended computation strongly gamma ai fair 
note computation weakly strongly gamma fair sigma iff weakly strongly gamma fair gamma fair example consider ats xy example fairness condition gamma fflg fairness constraint fl fl ffq xy gg specify nonempty values fairness constraint 
computations ats xy strongly gamma fair 
computations value variable eventually true weakly strongly gamma fair matter gamma fa fair 
long value false ats xy state state long value false fairness constraint fl enabled 
fair computation fl eventually taken changing value true ordinary transition systems fairness enables exclude computations ats 
particular fairness enables model asynchronous systems 
turn asynchronous ats turn asynchronous ats state single agent determines state 
turn synchronous ats state determine agent scheduled proceed 
turn asynchronous ats designated agent sch represents scheduler 
scheduler sch proceeds states determines agent proceed 
agent determines state 
fairness constraints guarantee scheduling policy fair 
accordingly ats turn asynchronous exists agent sch sigma state agent exists local transition function ffi conditions satisfied 
states agents sigma ffi ffi 
say agent enabled state ffi 

states ffi sch fffi agent sigma enabled qg 
scheduler sch chooses option ffi agent scheduled proceed state 
states agents sigma enabled ffi fqg 
agent enabled influence successor state 

states agents sigma enabled assuming ffi fq ffi qn ffi fq qn ffi fq gg 
agent enabled state chooses successor state ffi provided scheduled proceed 
scheduled proceed influence successor state lie ffi condition 
equivalently turn asynchronous ats viewed tuple pi oei theta total transition relation oe sigma fsg maps transition agent 
ffi fq oe ag 
note turn synchronous ats label states agents turn asynchronous ats label transitions agents 
order ensure fairness scheduler impose fairness condition gamma ffl sigma turn asynchronous ats 
fairness condition gamma contains fairness constraint fl agent different sch ensures scheduler neglect forever 
states fl sch fffi agents sigma possibly fl 
computation weakly hfl fair iff send wait wait sender send sender sender env sender sender env env sender env send protocol turn asynchronous ats infinitely positions agent enabled infinitely positions scheduled proceed 
similarly strongly hfl fair iff finitely positions agent enabled infinitely positions scheduled proceed 
example example turn asynchronous ats consider modeling sender process alternating bit protocol shown 
agents sender environment 
initial state sender enabled chooses stay move state transition corresponds sending message tagged bit 
state sender waiting receive acknowledgment 
agents enabled scheduler chooses 
sender scheduled proceed state continues wait 
environment transitions correspond reception acknowledgment sender 
acknowledgment bit sender proceeds toggle bit moving state acknowledgment bit sender attempts resend message moving back state phenomenon modeled letting environment scheduled state choose state similar state similar formally fq sigma env 
set pi contains propositions send true state wait true state send true state wait true state local transition functions follows ffl ffi sender fq ffl ffi env 
ffl ffi sender fq ffl ffi env fq ffl ffi sender fq ffl ffi env 
ffl ffi sender fq ffl ffi env fq local transition functions induce transition function ffl ffi sch ffq gg 
ffl ffi sender ffq fq gg 
ffl ffi env ffq gg 
ffl ffi sch ffq fq gg 
ffl ffi sender ffq gg 
ffl ffi env ffq fq gg 
ffl ffi sch ffq gg 
ffl ffi sender ffq fq gg 
ffl ffi env ffq gg 
ffl ffi sch ffq fq gg 
ffl ffi sender ffq gg 
ffl ffi env ffq fq gg 
weak fairness constraint fl env ensures sender waiting state eventually receive acknowledgment ffl fl env sch fl env sch ffq gg specify nonempty values fairness constraint 
assumption environment keep sending incorrect acknowledgments forever ensures progress protocol modeled strong fairness constraint fl ffl fl env ffq gg 
ffl fl env ffq gg 
alternating time temporal logic atl syntax temporal logic atl alternating time temporal logic defined respect finite set pi propositions finite set sigma agents 
atl formula propositions pi 
atl formulas 
hhaii hhaii hhaii sigma set agents atl formulas 
operator hh ii path quantifier temporal operators 
logic atl similar branching time temporal logic ctl path quantifiers parameterized sets agents 
write hha ii gii 
additional boolean connectives defined usual manner 
ctl write hhaii 
atl semantics interpret atl formulas states ats propositions agents 
labeling states propositions evaluate atomic formulas atl 
logical connectives standard interpretation 
evaluate formula form hhaii state consider player game 
game proceeds infinite sequence rounds round position game state initial position consider game position update position protagonist chooses agent set ffi 
antagonist chooses successor position game updated way game continues forever produces computation 
protagonist wins game resulting computation satisfies subformula read linear temporal formula outermost operator atl formula hhaii holds state protagonist winning strategy game 
order define semantics atl formally define notion strategies 
consider ats pi sigma ffii 
strategy agent sigma mapping delta ffi 
strategy maps finite prefix delta computation set ffi 
set contains possible extensions computation suggested agent strategy 
strategy induces set computations agent enforce 
state set agents set fa ff ag strategies agent define outcomes fa set fa computations agents enforce cooperate follow strategies fa computation fa positions state successor satisfying 
turn formal definition semantics atl 
write state satisfies formula structure indicate formula holds state clear context omit write 
relation defined states inductively follows ffl pi iff 
ffl iff 
ffl iff ffl hhaii iff exists set fa strategies agent computations fa 
ffl hhaii iff exists set fa strategies agent computations fa positions 
ffl hhaii iff exists set fa strategies agent computations fa exists position positions note operator local hhaii iff agent exists set ffi state successor 
useful express atl formula dual form 
path quantifier set agents 
atl formula hhaii intuitively means agents cooperate true enforce dual formula means agents cooperate false avoid 
path quantifier write set agents atl formula atl formula atl formula hhaii hhaii hhaii similar abbreviations defined dual operator 
precise 
state set computations say agents enforce set computations fa set fa strategies agents dually say agents avoid set computations fa set fa strategies agents agents enforce set computations agents sigma na avoid hhaii implies sigma 
converse statement necessarily true 
see consider sigma fa bg ffi ffq fq gg ffi ffq fq gg assuming state satisfies proposition propositions 
hhaii strategy enforce strategy avoid 
example recall turn synchronous ats example 
recall turn synchronous ats state labeled agent determines successor state 
simplified setting determine truth formula path quantifier hhaii consider simpler version atl game 
state agent scheduled proceed belongs protagonist updates position successor antagonist updates position successor state satisfies atl formulas 
train gate enter gate controller prevent entering gate 
hh ii gate gate 
train gate controller force enter gate 
hh ii gate ctr gate 
train gate train controller cooperate train enter gate 
hh ii gate gate 
train gate eventually request entering gate case controller decides 
hh ii gate request 
train gate controller force step 
hh ii gate gate natural requirements stated ctl ctl consider atl formulas 
provide information ctl formula gate gate ctl formula requires existence computation train gate atl formulas guarantee matter train behaves controller prevent entering gate matter controller behaves train decide stay gate 
contrast train controller agents example third atl formula equivalent ctl formula gate gate turn synchronous ats worth noting special case turn synchronous ats agents enforce set computations iff agents sigma avoid states turn synchronous ats hhaii iff sigma equivalently hh sigma aii 
due strong duality turn synchronous ats define temporal operator hhaii sigma hh sigma aii 
single agent ats recall labeled transition system ats single agent sys 
case special case turn synchronous path quantifiers hh ii sys 
set ff sys outcomes contains single computation set outcomes contains computations 
accordingly path quantifiers hh ii equal respectively existential universal path quantifiers logic ctl 
words labeled transition systems atl identical ctl 
write arbitrary ats path quantifier hh path quantifier sigma 
regarding agents cooperate enforce condition iff exists computation fulfills regarding agents cooperate avoid iff computations fulfill 
fair atl fairness constraints rule certain computations presence need refine interpretation formulas form hhaii 
particular fair atl game require antagonist satisfy fairness constraints 
leads definition 
logic fair atl syntax atl 
formulas fair atl interpreted ats fairness condition gamma state satisfaction relation gamma state fairly satisfies formula structure respect fairness condition gamma propositions boolean connectives defined case atl 
ffl hhaii iff exists set fa strategies agent gamma sigma ai fair computations fa 
ffl hhaii iff exists set fa strategies agent gamma sigma ai fair computations fa positions 
ffl hhaii iff exists set fa strategies agent gamma sigma ai fair computations fa exists position positions note path quantifier hhaii ranges computations fair respect agents sigma na 
see observe gamma contains fairness constraint fl exists agent fl nontrivial state ae fl ae ffi agents enforce computations gamma sigmai fair 
definition assures agents accomplish tasks vacuous way violating fairness 
example consider ats example 
controller cooperates train guarantee train eventually enters gate gate suppose add fairness condition gamma ffl ctr imposes fairness control decisions state fl ctr ctr ffq gg values fl ctr empty 
interpret fl ctr strong fairness constraint train strategy eventually enter gate gate see train move eventually due strong fairness constraint controller move train move hand interpret fl ctr weak fairness constraint cooperation train controller required enter gate fair atl formula satisfied see note train avoid weakly hfl ctr fair computation atl logic atl fragment expressive logic called atl types formulas atl state formulas satisfaction related specific state path formulas satisfaction related specific computation 
formally atl state formula propositions pi 
atl state formulas 
hhaii sigma set agents atl path formula 
atl path formula atl state formula 
atl path formulas 
atl path formulas 
logic atl consists set state formulas generated rules 
logic atl similar branching time temporal logic ctl path quantification parameterized agents 
additional boolean connectives temporal operators defined usual manner particular true 
atl dual path quantifier hhaii abbreviations hh sigma 
logic atl viewed fragment atl consists formulas temporal operator immediately preceded path quantifier 
semantics atl formulas defined respect ats write indicate path formula holds computation structure satisfaction relation defined states computations inductively follows ffl state formulas generated rules definition atl 
ffl hhaii iff exists set fa strategies agent computations fa 
ffl state formula iff 
ffl iff 
ffl iff ffl iff 
ffl iff exists position positions example atl formula hhaii req asserts agent strategy enforce computations finitely requests sent infinitely 
requirement expressed ctl atl 
weak strong fairness constraints expressed atl provided appropriate propositions available need fair atl definitions atl atl strategy agent may depend unbounded amount information full history game current state 
consider finite ats involved games regular 
existence winning strategy implies existence winning finite state strategy rab depends finite amount information history game 
semantics atl atl respect finite ats defined equivalently outcomes finite state strategies 
interesting strategy thought parallel composition system controller sure system follows strategy 
appropriate definition parallel composition finite state strategies implemented finite ats 
finite reachability games generalized buchi games atl suffices consider memory free strategies ej implemented control maps controllers state 
case atl formulas specify winning positions streett games tho 
symbolic model checking atl symbolic model checking model checking problem atl asks ats pi sigma ffi atl formula set states satisfy 
atl model checking similar ctl model checking ce qs bcm 
symbolic algorithm manipulates state sets algorithm shown uses primitive operations ffl function sub atl formula returns queue sub subformulas subformula subformula precedes queue sub 
foreach sub case reg case true case case hhaii pre case hhaii ae true ae ae ae pre ae od ae case hhaii ae false ae ae ae pre ae od ae case od return 
atl symbolic model checking ffl function reg proposition pi returns state set 
ffl function pre set sigma agents set states returns set containing states state agents cooperate force state lie formally pre contains state iff agent exists set ffi state successor ffl union intersection difference inclusion test state sets 
primitives implemented symbolic representations binary decision diagrams state sets transition relation 
symbolic model checker ctl smv mcm pre operation needs modified checking atl 
special case ats turn synchronous computation function pre symbolic model checking particularly simple 
recall case oe denotes agent scheduled proceed state set agents set states pre returns set containing states oe successor oe successors fair atl symbolic model checking turn attention model checking problem fair atl ats pi sigma ffi fairness condition gamma fair atl formula compute set states fairly satisfy respect gamma 
weak interpretation gamma case strong fairness constraints handled similarly 
recall evaluate formula form hhaii need restrict attention computations satisfy fairness constraints agents determine fairness constraints satisfied computation augment state space adding new propositions indicate agent sigma fairness constraint fl fl enabled fl taken 
purpose define ats pi sigma ffi ffl agent sigma fairness constraint fl gamma new proposition hfl new proposition hfl pi pi gamma theta sigma theta 
ffl states correspond transitions successor sg 
ffl state hq agent sigma transition ffi hq obtained ffi replacing state appearing ffi state hq example ffi ffq fq gg ffi hq hq ig igg ffl state hq hq fl exists fl intuitively state form hq corresponds ats state agents deciding successor correspondence computations strategies new propositions gamma theta sigma theta allow identify fair computations 
consequently evaluating formulas fair atl states reduced evaluating states atl formulas encode fairness constraints gamma 
proposition state ats fairly satisfies fair atl formula hhaii respect fairness condition gamma iff agent exists set ffi successor state hq ats satisfies atl formula hhaii fl gamma hfl hfl proposition reduces fair atl model checking special case atl model checking 
presenting model checking algorithm full fair atl consider sample formula hhaii proposition consider game structure state labeled visited protagonist wins 
game continues forever protagonist wins iff resulting computation weakly gamma sigma ai fair 
winning condition antagonist specified ltl formula fl gamma hfl hfl generalized buchi condition 
set winning states game computed nested fixed points 
obtain algorithm example note ctl formula ik computed symbolically greatest fixpoint consequently algorithm computes set ae winning states protagonist 
function pre pre operates structure proposition projection ae gives desired set hhaii states original structure ae true ae ae ae foreach fl gamma foreach sigma ae ae true reg hfl reg hfl ae false ae ae ae ae ae pre sigma ae od ae od od pre sigma ae od return ae true nested fixed point computation fair atl symbolic model checking model checking complexity measure complexity model checking problem different ways joint complexity model checking considers complexity terms structure formula structure complexity model checking called program complexity vw considers complexity terms structure assuming formula fixed 
structure typically larger formula size common computational bottle neck lp structure complexity measure particular practical interest 
atl model checking complexity theorem model checking problem atl ptime complete solved time ats transitions atl formula length 
structure complexity problem ptime complete special case turn synchronous ats 
proof 
consider ats transitions atl formula length 
claim algorithm implemented time 
see observe size sub bounded executing case statements algorithm involves calculation single fixed point done time linear see cle 
reachability graphs known ptime hard imm specified fixed atl formula hhaii interpreted turn synchronous ats hardness ptime joint structure complexity immediate 
interesting compare model checking complexities turn synchronous atl ctl 
problems solved time ces structure complexity ctl model checking nlogspace complete 
ctl model checking related graph reachability turn synchronous atl model checking related graph reachability 
fair atl model checking complexity section consider case fairness constraints 
theorem model checking problem fair atl ptime complete solved time fair ats transitions agents weak fairness constraints atl formula size 
structure complexity problem ptime complete 
proof 
consider ats transitions agents weak fairness constraints 
fair atl formula 
state labeled subformula starting innermost subformulas 
consider case corresponding subformula form hhaii cases corresponding similar 
described section construct ats truth hhaii evaluated solving generalized buchi game structure number transitions equals note winning condition antagonist corresponds visiting fairness constraint fl agent infinitely state satisfying hfl hfl 
cn buchi constraints 
complexity solving buchi games quadratic nested fixed point computation cost processing temporal connective 
concludes upper bound 
model checking problem atl special case model checking problem fair atl gamma hardness ptime follows theorem 
atl model checking complexity seen transition ctl atl involve substantial computational price 
section consider model checking complexity atl exponential price pay model checking complexity moving ctl ctl price significant doubly exponential consider alternating time versions logics 
discuss atl model checking briefly recall ctl model checking el 
computationally difficult case corresponds evaluating state formula form ltl formula 
solution construct buchi automaton accepts computations satisfy 
determine state satisfies formula need check computation accepted automaton done analyzing product structure 
complexity ctl model checking reflects cost translating ltl formulas automata 
case atl state formula hhaii solution similar requires tree automata satisfaction corresponds existence winning strategies 
model checking requires checking nonemptiness intersection tree automata accepting trees paths satisfy accepting trees correspond possible strategies protagonist 
order solve model checking problem atl define notion execution trees 
consider ats set agents set fa ff ag strategies agents state set fa computations fusion closed induces tree exec fa 
intuitively tree exec fa obtained unwinding starting successor relation pruning subtrees roots chosen strategies fa formally tree exec fa nodes elements ffl node root 
ffl node delta successor nodes children delta strings form delta delta successor delta 
tree hq ai execution tree exists set fa strategies agent exec fa 
theorem model checking problem atl exptime complete special case turn synchronous ats 
structure complexity problem ptime complete 
proof 
consider ats atl formula 
algorithm ctl model checking label state state subformulas satisfied bottom fashion starting innermost state subformulas 
subformulas generated rules labeling procedure straightforward 
subformulas generated employ algorithm ctl module checking kv follows 
hhaii satisfaction state subformulas determined assume ltl formula 
construct rabin tree automaton accepts precisely trees satisfying ctl formula state construct buchi tree automaton accepts precisely hq ai execution trees 
automaton states rabin pairs es 
automaton jqj states 
product automata rabin tree automaton accepts precisely hq ai execution trees satisfying 
hhaii iff product automaton nonempty 
nonemptiness problem rabin tree automaton states pairs solved time nr ej pr 
labeling single state requires time jqj delta jqj jqj states subformulas membership exptime follows 
lower bound reduction realizability problem ltl pr shown exptime hard ros 
problem ltl formula set pi propositions determine exists turn synchronous ats agents sys env 
transitions alternate sys states env states 
env state pi successors labeled different subset pi 
state satisfies 
intuitively state satisfies witnesses strategy system satisfy irrespective environment 
pi maximal agent turn synchronous ats pi alternates sys env states pi pi pi theta fs oe pi theta fsg theta pi theta feg pi theta feg theta pi theta fsg pi hw si hw ei oe hw si oe hw ei 
easy see realizable iff exists state pi satisfies 
exptime lower bound holds ltl formulas fixed number propositions size pi fixed done 
lower bound structure complexity problem follows theorem upper bound follows fixing complexity analysis joint complexity 
atl section suggest formalisms specification open systems 
compare formalisms atl atl consider expressiveness model checking complexity 
logics say logic expressive logic formula exists formula equivalent true states ats 
logic expressive expressive expressive alternating time calculus formulas logic amc alternating time calculus constructed propositions boolean connectives operator occurrence parameterized set agents fixed point operator formally set pi propositions set propositional variables set sigma agents amc formula ffl propositions pi 
ffl propositional variables ffl amc formulas 
ffl hhaii sigma set agents amc formula 
ffl amc formula free occurrences occur subformula starting fall number negations 
logic amc similar calculus koz operator parameterized sets agents universal existential path quantifier 
additional boolean connectives defined usual manner 
atl dual hhaii abbreviations hh sigma 
calculus write abbreviate 
greatest fixed point operator dual operator connective write amc formula positive normal form occurrences front propositions 
amc formula alternation free written positive normal form occurrences resp 
syntactic path occurrence resp 
occurrence example formula hhaii alternation free formula hhaii 
alternation free fragment amc contains alternation free formulas 
turn semantics amc 
need definitions notations 
ats pi sigma ffii valuation function propositional variables subsets valuation propositional variable set states denote valuation maps agrees variables 
amc formula interpreted mapping valuations state sets 
denotes set states satisfy amc formula valuation mapping defined inductively follows ffl proposition pi fq ffl propositional variable 
ffl 
ffl 
ffl hhaii fq agent exists set ffi state successor ffl fq consider amc formula form 
valuation subformula viewed function maps state set state set 
free occurrences fall number negations function monotonic 
consequently standard fixed point theory function fixed point fq furthermore state finitely successor states function continuous fixed point computed iterative approximation starting false false ats finitely states intersection finite iterative approximation converges finite number steps 
sentence amc formula contains free occurrences propositional variables 
sentences define mapping valuations 
state sentence write state satisfies formula structure iff example amc formula hhaii equivalent atl formula uq 
amc expressiveness temporal properties operators defined fixed points nexttime properties 
closed systems gives calculus generalization temporal logics 
known calculus expressive ctl alternation free calculus expressive ctl 
similarly reasons amc expressive atl alternation free fragment expressive atl 
theorem amc expressive atl alternation free fragment amc expressive atl 
proof 
translation alternating time temporal logics amc similar translation branching time temporal logics calculus el hhaii replacing describe translation atl formulas alternation free fragment amc 
function atl formulas alternation free amc formulas atl formula formulas equivalent 
function defined inductively follows ffl pi ffl 
ffl 
ffl hhaii hhaii 
ffl hhaii hhaii 
ffl hhaii hhaii 
establish amc expressive atl alternation free fragment expressive atl note single agent ats alternation free amc alternation free calculus ctl atl ctl atl 
alternating time calculus natural convenient specification language reasoning open systems 
writing understanding formulas calculus hard context closed systems practice designers avoid fixed points prefer simple temporal operators see bbg 
amc specification language open systems require complicated formulas extra nesting fixed points making calculus appealing 
just ctl ctl capture useful friendly subsets calculus specification closed system atl atl capture useful friendly subsets amc specification open systems 
atl atl primitives parameterized path quantifiers just parameterized time operators 
amc model checking algorithms tools calculus model checking easily modified handle amc 
difference calculus amc definition operator game interpretation amc 
section modification involves pre function 
complexity model checking problem calculus el implies 
theorem model checking problem alternation free fragment amc solved time ats transitions formula size 
model checking problem amc solved time ats transitions formula alternation depth 
amc propositional logic games par parikh defines propositional logic games 
parikh logic extends dynamic logics pdl fl way similar way amc extends calculus 
formulas parikh logic built respect set atomic games correspond choices agents ats 
cooperation agents fixed point expressions specified parikh logic usual pdl operations disjunction iteration games 
fragment amc embedded parikh logic 
example amc formula hha bii corresponds formula ip parikh logic 
par parikh logic shown decidable complete set axioms model checking problem studied 
game logic parameterized path quantifier hhaii stipulates existence strategies agents universally quantifies outcomes stipulated strategies 
may generalize atl atl separating concerns strategy quantifiers path quantifiers say writing hhaii read exist strategies agents 
example formula asserts agents strategies behavior remaining agents true possibly different behavior remaining agents true 
refer general logic strategy quantifiers path quantifiers temporal operators boolean connectives game logic gl short 
types formulas gl state formulas satisfaction related specific state ats tree formulas satisfaction related specific execution tree definition execution trees recall section path formulas satisfaction related specific computation formally gl state formula propositions pi 
gl state formulas 
sigma set agents gl tree formula 
gl tree formula gl state formula 
gl tree formulas 
gl path formula 
gl path formula gl tree formula 
gl path formulas 
gl path formulas 
logic gl consists set state formulas generated rules 
instance formula gl state formula subformula tree formula 
define semantics gl 
write indicate state formula holds state structure write indicate tree formula holds execution tree structure write indicate path formula holds infinite path execution tree structure note case computation 
execution tree node write subtree root satisfaction relation defined inductively follows ffl formulas generated rules definition atl 
formulas generated rules definition obvious 
ffl iff exists set fa strategies agent exec fa 
ffl state formula iff root execution tree ffl path formula iff exists rooted infinite path 
ffl tree formula iff 
ffl iff ffl iff exists position positions gl expressiveness logic atl syntactic fragment gl consists formulas strategy quantifier immediately followed path quantifier note equivalent 
formula equivalent atl formula gl expressive atl syntactic fragment gl studied module checking kv 
considers formulas form single outermost strategy quantifier followed ctl ctl formula 
gl formula hha ii hha ii equivalent formula single outermost strategy quantifier gl expressive module checking 
furthermore expressiveness viewpoint alternating time logics module checking identify incomparable fragments game logic 
kv shown module checking complexity exptime complete ctl exptime complete ctl structure complexity problems ptime complete 
computational viewpoint atl advantageous 
gl model checking model checking problem ctl solved repeatedly applying bottom fashion ltl model checking procedure subformulas el 
technique order solve model checking problem gl repeatedly applying ctl module checking algorithm kv 
complexity ctl module checking implies 
theorem model checking problem gl exptime complete 
structure complexity problem ptime complete 
game logic expensive atl feel state path formulas tree formulas natural specifications reactive systems 
incomplete information definition atl agent complete information state ats 
certain modeling situations may appropriate assume agent observe subset propositions 
strategy agent depend observable part history 
section study agents incomplete information 
known results multi player games incomplete information show setting complex setting complete information 
main result negative show atl model checking problem undecidable cooperating agents incomplete information 
state result weakest version ats turn synchronous ats 
ats incomplete information turn synchronous ats incomplete information pair hs consisting synchronous ats pi sigma oe ri vector pi sigmag contains sets pi pi propositions agent sigma 
observability vector defines agent set pi propositions observable consider agent sigma 
state term pi view write pi set possible views function maps state view 
function extended computations natural way states stable agree propositions observe 
require transition function influence propositions observe independent propositions observe 
formally require conditions hold agents sigma states 
oe stable 

oe oe state stable 
words transition function agent maps view state scheduled set views possible successor states 
accordingly define relation theta iff stable states oe 
atl incomplete information specify properties ats incomplete information atl formulas restrict syntactic fragment atl 
see consider atl formula hhaii pi formula requires agent strategy eventually reach state proposition observe true 
requirement sense 
consequently set agents supposed attain certain task require agent set observe propositions involved task includes propositions appear task propositions observable agents appearing task 
formally observability vector define atl formula set inv pi involved propositions 
definition proceeds induction structure formula ffl pi inv fpg 
ffl inv arg 
ffl inv inv inv 
ffl inv hhaii inv pi ffl inv hhaii inv pi ffl inv hhaii inv inv pi atl formula formed respect observability vector conditions hold 
subformula form hhaii hhaii agent inv pi 
subformula form hhaii agent inv inv pi note formula hhaii formed agent observe propositions observable agents appearing may able observe propositions observable agents interpret atl formula turn synchronous ats hs incomplete information require formed respect definition satisfaction relation case complete information see section definitions strategies outcomes 
strategy agent sigma mapping pi pi 
strategy maps view finite computation prefix view possible successor state 
state set sigma agents set fa ff ag strategies agent computation outcome fa positions oe oe 
example hhaii iff oe exists oe view pi oe states oe oe states 
theorem model checking problem atl incomplete information undecidable special case turn synchronous ats 
proof 
outcome problem multi player games incomplete information proved undecidable yan 
problem identical model checking problem atl formula hhaii turn synchronous ats incomplete information 
note fair atl proving undecidability easier follows undecidability results asynchronous multi player games incomplete information pr pr 
single agent atl incomplete information single agent atl fragment atl path quantifier parameterized singleton set agents 
case agents cooperate model checking problem decidable incomplete information 
exponential price paid setting complete information 
theorem model checking problem single agent atl incomplete information exptime complete 
structure complexity problem exptime complete special case turn synchronous ats 
proof 
start upper bound 
turn synchronous ats hs atl formula formed respect label states subformulas starting usual innermost subformulas 
formed respect subformula form hhaii agent observe labels correspond subformulas hhaii refer labels observable propositions 
subformulas generated rules labeling procedure straightforward 
subformulas generated proceed follows 
state formed atl formula form hhaii hhaii agent observable propositions define turn synchronous ats complete information state hs iff pi sigma oe ri pi set observable propositions pi pi 
order define need notations 
add pi special proposition indicates agent scheduled proceed states iff oe pi pi fp set agent sigma extended view ae pi define ae successor set fq ae exists state set states extended view ae successors state pi fa bg oe defined follows ffl smallest set satisfying fqg sets views ae pi ae successor note sets view agent scheduled proceed scheduled proceed state corresponds set states indistinguishable agent ffl sets ae ae 
ffl sets oe oe oe ffl sets iff 
easy prove types hs iff fqg size exponential size membership exptime follows theorem 
lower bound observe model checking problem atl formula hhaii turn synchronous ats agents incomplete information identical outcome problem player games incomplete information 
problem known exptime hard rei 
methods reasoning closed systems general applicable reasoning open systems 
verification problem open systems corresponds modelchecking problem temporal logics corresponds case linear time realizability problem alw pr pr case branching time module checking problem kv search winning strategies 
existing methods verification open systems circumvent computational price caused solving infinite games 
logic atl introduced identifies class verification problems open systems suffices solve iterated finite games 
ensuing linear model checking complexity atl shows despite pessimistic results achieved area area far great deal interesting reasoning open systems performed naturally efficiently 
closed systems naturally modeled labeled transition systems kripke structures model open systems alternating transition systems 
case closed systems atl degenerates ctl fair atl fair ctl ces atl ctl model checking complexity results summarized table 
complexities table denote tight bounds size system length formula 
acknowledgments 
amir pnueli moshe vardi yannakakis helpful discussions 
luca de alfaro mang comments draft manuscript 
ah alur henzinger 
reactive modules 
proc 
th ieee symposium logic computer science pages 
closed system open system atl joint complexity ptime ptime ces atl structure complexity nlogspace ptime fair atl joint complexity ptime ptime ces fair atl structure complexity nlogspace ptime kv atl joint complexity pspace exptime ces atl complexity nlogspace ptime table model checking complexity results abadi lamport 
composing specifications 
acm transactions programming languages systems 
alw abadi lamport wolper 
realizable unrealizable concurrent program specifications 
proc 
th int 
colloquium automata languages programming volume lecture notes computer science springer verlag pages 
bbg beer ben david geist 
methodology system practical formal verification reactive hardware 
proc 
th conference computer aided verification volume lecture notes computer science springer verlag pages 
bcm burch clarke mcmillan dill hwang 
symbolic model checking states 
proc 
th symposium logic computer science pages 
vardi wolper 
automata theoretic approach model checking 
proc 
th conference computer aided verification volume lecture notes computer science springer verlag pages 
ce clarke emerson 
design synthesis synchronization skeletons branching time temporal logic 
proc 
workshop logic programs volume lecture notes computer science springer verlag pages 
ces clarke emerson sistla 
automatic verification finite state concurrent systems temporal logic specifications 
acm transactions programming languages systems 
cks chandra kozen stockmeyer 
alternation 
journal acm 
cle cleaveland 
linear time model checking algorithm alternation free modal calculus 
formal methods system design 
dil dill 
trace theory automatic hierarchical verification speed independent circuits 
mit press 
eh emerson halpern 
revisited branching versus linear time 
journal acm 
ej emerson jutla 
complexity tree automata logics programs 
proc 
th ieee symposium foundations computer science pages 
el emerson 
lei 
modalities model checking branching time logic strikes back 
proc 
th acm symposium principles programming languages pages 
el emerson 
lei 
efficient model checking fragments propositional calculus 
proc 
st symposium logic computer science pages 
es emerson sistla 
deciding branching time logic 
proc 
th acm symposium theory computing 
fl fischer ladner 
propositional dynamic logic regular programs 
journal computer systems sciences 
gawlick segala andersen lynch 
liveness timed untimed systems 
proc 
rd int 
colloquium automata languages programming volume lecture notes computer science springer verlag pages 
hoa hoare 
communicating sequential processes 
prentice hall 
hol holzmann 
model checker spin 
ieee transactions software engineering 
imm immerman 
number quantifiers better number tape cells 
journal computer system sciences 
koz kozen 
results propositional calculus 
theoretical computer science 
kv kupferman vardi 
complexity branching modular model checking 
proc 
th concurrency theory volume lecture notes computer science springer verlag pages 
kv kupferman vardi 
module checking 
proc 
th conference computeraided verification volume lecture notes computer science springer verlag pages 
lp lichtenstein pnueli 
checking finite state concurrent programs satisfy linear specification 
proc 
th acm symposium principles programming languages pages 
lyn lynch 
distributed algorithms 
morgan kaufmann 
mcm mcmillan 
symbolic model checking 
kluwer academic publishers 
par parikh 
propositional game logic 
proc 
th ieee symposium foundation computer science pages 
pnu pnueli 
temporal logic programs 
proc 
th ieee symposium foundation computer science pages 
pr peterson reif 
multiple person alternation 
proc 
th ieee symposium foundation computer science pages 
pr pnueli rosner 
synthesis reactive module 
proc 
th acm symposium principles programming languages 
pr pnueli rosner 
synthesis asynchronous reactive module 
proc 
th int 
colloquium automata languages programming volume lecture notes computer science springer verlag pages 
pr pnueli rosner 
distributed reactive systems hard synthesize 
proc 
st ieee symposium foundation computer science pages 
qs sifakis 
specification verification concurrent systems cesar 
proc 
th international symposium programming volume lecture notes computer science springer verlag pages 
rab rabin 
weakly definable relations special automata 
proc 
symposium mathematical logic foundations set theory pages 
north holland 
rei reif 
complexity player games incomplete information 
journal computer system sciences 
ros rosner 
modular synthesis reactive systems 
phd thesis weizmann institute science rehovot israel 
rw ramadge wonham 
control event systems 
ieee transactions control theory 
tho thomas 
synthesis strategies infinite games 
proc 
th symposium theoretical aspects computer science volume lecture notes computer science springer verlag pages 
vw vardi wolper 
automata theoretic approach automatic program verification 
proc 
st ieee symposium logic computer science pages 
vw vardi wolper 
automata theoretic techniques modal logics programs 
journal computer system science 
yan yannakakis 
synchronous multi player games incomplete information undecidable 
personal communication 

