marmot optimizing compiler java robert fitzgerald todd knoblock erik ruf bjarne steensgaard david tarditi microsoft research june technical report msr tr microsoft research microsoft way redmond wa marmot optimizing compiler java robert fitzgerald todd knoblock erik ruf bjarne steensgaard david tarditi microsoft research june marmot system research platform studying implementation high level programming languages 
currently comprises optimizing native code compiler runtime system libraries large subset java 
marmot integrates known representation optimization code generation runtime techniques java specific features achieve competitive performance 
contains description marmot system design highlights experience applying adapting traditional implementation techniques java 
detailed performance evaluation assesses marmot performance relative java implementations relative costs various java language features marmot compiled code 
experience marmot demonstrated known compilation techniques produce performance static java applications comparable superior java systems approaching cases 
java tm programming language gjs integrates number features object orientation strong typing automatic storage management multithreading support exception handling programming easier error prone 
productivity safety features especially attractive development large programs enable modularity reuse eliminating classes errors 
unfortunately performance penalty associated features prohibitive 
existing interpreter just time compilation jit java implementations compete favorably web technologies scripting languages small internet applets far competitive static compilers traditionally development larger static programs servers stand applications 
seek bring benefits java high level features larger programs minimizing associated performance penalty 
approach adapt known implementation techniques existing language implementations java integrating new java specific technology necessary 
constructed system marmot includes static optimizing compiler runtime system libraries large subset java 
native code compiler implements standard scalar optimizations sort fortran compilers muc basic object oriented optimizations call binding class hierarchy analysis bs dgc 
uses modern representation techniques ssa form type compilation cfr tar improve optimization support precise garbage collection 
runtime system supports multithreading cient synchronization exception mechanisms garbage collectors including precise generational collector 
marmot implemented entirely java demanding test cases 
experience marmot demonstrates known compilation techniques produce performance static java applications comparable superior java systems ap conversion jir high level optimization assembly linking code generation user code libraries marmot java runtime marmot native runtime win native executable java bytecode high level ir jir high level ir jir object assembly executable java bytecode marmot compilation process 
cases 
marmot reduces costs safety checks programs modest execution time 
synchronization costs quite significant optimization techniques reduce costs worth pursuing 
recognizing single threaded programs optimizing accordingly important special case 
marmot includes quality generational collector reduces cost storage allocating objects appropriately bounded lifetimes statically known sizes stack storage management costs significant 
describing motivating subset java supported marmot 
sections describe design implementation native code compiler highlights experience applying adapting modern implementation techniques languages java 
runtime system library described sections 
section analyzes performance marmot compiled applications 
related described section section 
supported language features marmot presently implements significant subset java language runtime features 
subset chosen appropriate studying performance larger java applications 
contains complete core language including java precise exception handling multithreading semantics 
features represent important di erences java provide useful functionality application developer provide interesting significant semantic constraints optimizer runtime 
marmot includes quality generational garbage collector 
included properly account costs automatic storage management basis study 
marmot runtime implementation large subset java libraries including java lang java util java awt parts java net java applet java text 
missing library functionality implemented needed support additional test applications 
significant omission marmot support dynamic class loading 
omitted implementation burden significant constraints places static optimization 
judged feature secondary importance class applications studied 
java features presently supported marmot principle supported undue ort 
include object finalization jni reflection marmot support class forname new instance creation classes known compile time 
marmot implements static schedule class initialization eager java specification suggests 
conversion high level intermediate representation native code compiler translates collection java class files native machine code 
shows organization compiler 
divided parts conversion java class files high level intermediate representation called jir high level optimization code generation 
code generation phase converts jir intel assembly code 
sections describe part compiler 
java programs usually distributed class files containing java bytecode ly 
java front compilers javac translate java source class files 
class files semantic information original source program formatting comments variable names types 
class files employ instruction set stack oriented irregular redundant 
instruction set unattractive internal representation optimizing compiler 
part marmot compiler converts java class files jir conventional virtual intermediate form 
conversion proceeds steps initial conversion temporary variable intermediate representation conversion static single assignment form type elaboration 
type elaboration reconstructs static type information lost conversion java source files class files 
starting class files java source code advantages 
avoids construction front java lexical analysis parser constant folder typechecker 
especially significant java class file specification stable java language specification continued evolve 
accepting class files input allows marmot compile programs java source files available 
marmot restricts input language verifiable class files 
allows number simplifying assumptions processing rely code behaved 
java bytecode compilers expected generate verifiable class files significant restriction purposes 
high level intermediate representation jir usual characteristics modern intermediate representation temporary variable static single assignment address representation 
addition strongly typed 
method represented control flow graph distinguished root entry block 
graph node basic block consists sequence ect statements concludes control statement 
ect statement side ect statement assignment statement 
side ect consists expression represents statement record result evaluating expression 
basic block concludes control statement specifies succeeding basic block execute normal control flow 
order represent exception handlers basic blocks jir di er classic definition asu app muc single entry multiple exit 
addition basic blocks terminated function call boundaries 
statement causes exception directly uncaught exception function call execution basic block terminates 
jir models java exception handling labeling basic blocks distinguished exception edges 
edges indicate class exceptions handled bound variable handler basic block transfer control exception occurs execution guarded statements 
presence exception edge imply block throw exception execution path 
intuitive dynamic semantics basic block execution follows 
execution proceeds sequentially statements exception raised 
occurs ordered list exception edges current basic block searched determine handle exception 
exception edge label class matches class raised exception selected 
exception value bound variable control transferred destination exception edge 
matching exception edge exists current method exited process repeats recursively 
existing java interpreters jits vary slightly details java class initialization specification 
exception edges leaving basic block di er semantically normal edges 
normal edge indicates control destination execution reached basic block exception edge indicates control may leave basic block block statement completes middle executing statement 
distinction especially important traversing edges backwards 
normal edges may considered single source source block exception edges multiple sources statements source basic block throw instance edge designated exception class 
sense jir basic blocks similar superblocks :10.1.1.14.9668
initial conversion compiling java program begins class file containing main method 
class file converted statically referenced classes queued processing 
conversion continues queue transitive closure reachable classes converted 
initial conversion class files jir uses interpretation algorithm cc 
abstraction virtual machine stack built ects instruction execution stack modeled 
temporary variable associated stack depth temp bottom stack value temp depth forth 
virtual machine instructions manipulate stack converted ects stack model jir instructions manipulate temporary variables 
assumption source class file verifiable assures stack models control point compatible 
care exercised modeling multiword long double virtual machine instructions doubles represented multiple elements stack 
conversion split values multiword constants values 
verifiability class file ensures possible 
simplification regularization virtual machine instructions occurs initial conversion 
example various icmp ifnull operations translated jir control statements appropriate boolean test variable 
similarly various iload aload istore astore operations translated simple local variables 
reducing number primitives way simplifies subsequent processing jir 
initial conversion manifest computations implicit virtual machine instructions 
includes operations class initialization synchronized methods 
lowering explicitly represented operations done operations available analysis optimization 
problematic feature java bytecode subroutine encode try constructs 
marmot initially complex encoding normal control flow similar described freund fre additional mechanism ssa form 
proved complex ine cient normal case eventually adopted freund minimalist approach expanding try handlers line 
static single assignment conversion second step converting class files jir conversion static single assignment ssa form cfr 
conversion lengauer tarjan dominator tree algorithm lt sreedhar gao phi placement algorithm sg 
conversion complicated presence exception handling edges considered computation iterated dominance frontiers 
edges may require source blocks split preserve usual correspondence phi arguments cfg edges 
phi nodes eliminated high level optimization complete translation low level form 
phi elimination implemented straightforward copy strategy 
algorithm uses lazy edge splitting limit scopes copies attempt reuse temporaries optimization subsumed coalescing register allocator 
type elaboration third final step constructing jir class files type elaboration 
process infers type information left implicit instructions produces strongly typed intermediate representation variables typed coercions conversions explicit overloading operators resolved 
java source programs include complete static type information information included class files local variables type information 
stack cells untyped corresponding temporaries jir stage 
values represented small integers booleans bytes shorts chars integers mixed class file methods 
class files preserve type information class fields contain representations originally declared type 
function formals types 
verifiability implies certain internal consistencies types locals stack temporaries 
type elaboration operates method 
begins collecting constraints omitted types 
result set type constraints type variables 
system solved factoring constraints strongly connected components solving component depth order 
result type elaboration strongly typed intermediate representation variables typed coercions conversions explicit operators resolved 
type information lost initial translation java bytecode possible recover user type declarations 
type elaboration recover legal typing intermediate code 
addition usefulness analysis garbage collection representation decisions type information serves consistency check jir 
optimizations jir expected preserve correct typing allowing type checking pre post optimization semantic check 
proved useful debugging marmot 
gagnon hendren developed type inference algorithm java bytecode sable compiler gh 
experience marmot takes verified bytecode input lieu java source 
advantages outlined costs 
type elaboration potentially computationally expensive natural formulation problem np complete 

certain java language features encoded bytecode 
example inner classes finalization synchronization primitives expanded low level bytecode representation 
optimizations targeted high level features may require rediscover encoded simple unnecessary compiler started java source 

multiple translation steps java bytecode jir demand cleanup optimizations 
minor point optimizations desirable anyway 
quirks initial bytecode representation may degrade resulting jir 
example simple boolean control source expressions large chunks code employing multiple statements temporaries blocks 
standard optimizations array bounds check optimization common subexpression elimination constant copy propagation conditional branch elimination control optimizations branch correlation removal dead unreachable block elimination dead assignment dead variable elimination inter module inlining loop invariant code motion loop induction variable elimination strength reduction operator lowering reoptimization object oriented optimizations null check removal stack allocation objects static method binding type test array store cast instanceof elimination method elimination abstraction java specific optimizations bytecode idiom recognition redundancy elimination loop invariant code motion field array loads 
synchronization elimination optimizations performed high level optimizer 
basic blocks serve group statements related control 
marmot distinguished exception edges allows larger blocks possible 
alternative annotate possible exception point success failure successor done vortex ddg 
lead explosion edges control flow graph small blocks 
ssa form potentially worse edge may corresponding phi argument successor blocks 
high level optimization high level optimizer transforms intermediate representation jir preserving static single assignment type correctness properties 
lists transformations performed 
grouped categories standard optimizations imperative languages general objectoriented optimizations java specific optimizations 
standard optimizations standard scalar control flow optimizations performed method basis understood intraprocedural dataflow techniques 
analyses induction variable classification extensive ssa def relation availability analysis standard bit vector techniques 
optimizations straightforward complications due java exception model explicit ssa representation discussed section 
optimizations shown array bounds check optimization widely technique particularly face java exception semantics 
techniques array bounds check optimization developed fortran mcm gup asu gup cg kw contexts si xp 
marmot employs folklore optimization upper lower bounds checks zero origin array may combined single unsigned check upper bound app 
common subexpression elimination optimization removes fully redundant checks 
remaining bounds checks optimized phases 
available inequality facts relating locals constants method collected dataflow analysis 
sources facts include control flow branching array creation available array bounds checks 
facts added additional facts derived bounds monotonicity induction variables 
second inequality decision procedure fourier elimination de wil array bounds check determine check redundant relative available facts 
lower upper bound checks redundant bounds check removed 
upper bound check redundant check rewritten lower bound test eliminates array length 
object oriented optimizations marmot object oriented optimizations implemented combination inter module flow insensitive method flow sensitive techniques 
instantiation invocation analysis iia simultaneously computes conservative approximations sets instantiated classes invoked methods 
initial set classes methods known instantiated invoked explores methods reachable call sites invoked method set subject constraint method class instantiated adding methods constructor invocations discovered 
similar rapid type analysis algorithm bacon bac iia rely precomputed call graph eliminating need explicit class hierarchy analysis dgc pass 
marmot uses explicit annotation mechanism document invocation instantiation behavior native methods library code 
marmot uses results analysis ways 
transformation virtual calls having single invoked target removes abstracts methods 
removes indirection program significantly reduces compilation times library methods require compilation 
analyses iia bound runtime types values build call graphs 
example inliner may analysis inline methods having call site 
local type propagation computes flow sensitive estimates runtime types sets classes interfaces carried local variable method uses results bind virtual calls fold type predicates 
relies flow insensitive analysis bound values formals call results takes advantage local information derived object instantiation type casting operations produce precise program point specific result 
information allows optimizer fold operations cast checks instanceof statically binding method invocations flow insensitive analysis 
local type information constructing precise call graph drives traditional optimizations inlining 
type operations folded type propagator may eliminated passes 
type interprocedural analysis finds provably non null expressions 
results directly eliminate null checks fold conditionals optimizations load hoisting 
stack allocation optimization improves locality reduces garbage collection overhead allocating objects bounded lifetimes stack heap 
uses inter module escape method abstraction required method body selector continues appear virtual calls 
marmot prune class hierarchy uninstantiated classes may hold invoked methods runtime type tests 
loop invariant code motion optimization currently loads throw exception proven non null base addresses 
pre ssa cleanup ssa conversion type elaboration method optimizations phi elimination method pre global cleanup inter module optimizations operator lowering ssa restoration folding demand sparse propagation optimization phases 
boxes solid outlines optimization phases dashed outlines utilities invoked phases 
analysis associate object allocation sites method bodies lifetime bounds allocated object 
allocation moved call graph lifetime dominating method storage pointer passed downward object initialized original allocation site 
see gay steensgaard gs details optimization 
java specific optimizations date marmot concentrated orts implement fairly standard scalar objectoriented optimizations context java version optimizer contains relatively transformations specific java programming language 
java programs may execute multiple threads simultaneously methods standard library guard potential critical sections synchronization operations 
cost operations paid multithreaded single threaded programs alike 
marmot optimizes single threaded case iia detect thread objects started allowing remove synchronization operations program optimizations performed 
similar analyses appear bacon bac muller 
techniques removal redundant loads hoisting loop invariant loads exist literature cl lck applying java programs requires extra step 
language semantics require global memory read written operation executed ectively invalidating cached loads points 
marmot performs call graph interprocedural analysis determine method invocations may execute synchronization operations modifies kill sets load analyses appropriately 
marmot performs transformations eliminate artifacts java bytecode representation jir 
possible ternary result comparison operators lcmp translated simpler boolean comparisons 
bytecode idioms boolean operations implemented control equivalent false true recognized reduced corresponding boolean operations 
integer bitwise operations integral operands known represent booleans reduced boolean operations 
phase ordering shows optimizations organized 
briefly describe phases 
ssa conversion type elaboration relatively expensive profitable run optimization prior conversion remove unused methods representation 
similarly converting java bytecode lacks boolean primitive datatype encodes boolean operations bitwise integral operations 
converting underlying boolean operations enables additional operator folding 
control operations value operations described previous subsection significantly simplifies control flow 
time marmot recognizes single threaded code removes synchronization operations possible 
high level optimization passes operate untyped non ssa representation 
performing inter module optimizations marmot applies suite simple optimizations method 
optimizations remove significant numbers intermediate variables unconditional jumps redundant coercions introduced bytecode translation type elaboration phases 
doing reduces code size speeding optimizations improves accuracy inliner code size heuristics 
inter module optimization phase runs pass followed multiple passes inlining alternating various folding optimizations 
inliner includes advanced capabilities including ability profile information space time tradeo purposes conservative inline control strategy employed 
inlines result inlining estimated smaller original call sequence 
inter module operations variety optimizations applied method 
optimizations avoid need re folding entire methods performing demand value propagation folding ssa hypergraph 
momentarily transform representation violation ssa invariants rely ssa restoration utilities reestablish invariants 
operator lowering phase translates high level operations cast checks monitor operations corresponding jir code may include calls java native code runtime system 
marmot runs inter intra module optimizations appropriate simplify internals lowered operations 
example distinct type tests single object load metadata object class pointer optimizer may find loads redundant 
experience presence exceptions complicates dataflow analysis analysis model potential transfer control implicitly explicitly throwing operation appropriate exception handler 
jir representation models transfers coarsely outgoing exception edges extended basic block 
marmot bit vector analyses achieve greater precision modeling exception behavior operation basic block information build edge specific transfer functions relating block entry exception arc ssa analyses need perform explicit modeling value flow resulting exceptional exits block explicitly represented phi expressions relevant handler blocks 
java precise exception model complicates transformation requiring handlers access exact observable program state existed immediately prior throwing operation 
optimizer forbidden relocate operation outside scope applicable handlers languages unable move potentially throwing operation past changes local variable storage location live entry applicable handler building specialized handler appropriate code 
reason optimizer limits code motion provably ect free non throwing operations 
limits redundancy elimination including redundant load store optimizations full partial redundancies 
better redundancy elimination may require dynamic information justify extra analysis ort code expansion specific code paths 
notable exception synchronization driven kills cached loads described section potentially multithreaded nature java programs significantly ected implementation marmot optimizer reasons 
method optimizations model values high level operations lowered immediately conversion optimizations synchronization removal cast check elimination rely ability recognize rewrite remove operations 
lowered longer available atomic operations 
performing code motion requires sophisticated ect analysis may require significant code duplication throwing operation moved loop 
conversion mir low level optimization code layout register allocation peephole optimization jir mir mir mir mir assembly marmot code generation phase 
local variables locally allocated storage nature una ected threading synchronization 
second inter module analyses flow insensitive model possible statement interleavings additional cost 
explicit ssa representation benefits analysis flow sensitive modeling statement value tuples transformation transparent extension value lifetimes significantly increases implementation complexity transformations 
main di culty lies appropriately creating modifying phi operations preserve ssa invariants edge structure control flow graph changes 
transformation specific phi operator maintenance di cult implementation task largest compilation time cost marmot optimizations 
considering modifying jir view ssa graphs sparse definition annotations top conventional statement representation primary representation 
doing allow benefits ssa form minus transparent lifetime extension need keep ssa graph date times 
wolfe parallelizing fortran compiler wol uses similar approach 
briggs noted systems treating phi operations basic block parallel assignments may require scheduling pass properly serialize assignments phi elimination phase 
marmot optimizer avoids issue giving phi assignments normal sequential semantics statements including ability loop carried definition kill 
requires extra care copy propagation ect analyses benefit simplifying phi elimination phase 
local type propagation algorithm dependent iia estimates runtime types method formals call returns array contents storage locations 
presence polymorphic datatypes containers java lang objects estimates imprecise containers appear hold instantiated subclasses java lang object 
experimenting context sensitive inter module analyses provide better type estimates face polymorphism 
code generation marmot code generation phase converts jir programs assembly code 
shows steps conversion 
jir programs converted low level intermediate representation called mir machine intermediate representation 
mir described section conversion process described section 
performs optimizations clean converted code including copy propagation constant propagation dead code elimination 
addition redundant comparisons registers zero set condition code eliminated 
unnecessary comparisons arise translation jir conditional statements take boolean variables comparisons arguments 
cleanup register allocation performed 
jumps control instructions branches jumps eliminated 
optimization deferred register allocation register allocation amount flow sensitivity encoded ssa representation reducing precision loss due flow insensitive analysis 
ssa form sole representation denies standard option simply base representation ssa hypergraph 
initial conversion base longer exists 
converting back ssa form cfg edit prohibitively expensive forced write custom phi maintenance code cfg transformation 
choi css describe phi maintenance loop transformations give solution general cfg mutation 
eliminates moves creates basic blocks containing jumps 
peephole optimizations performed code layout chosen 
code layout phase arranges code loop control instructions placed bottom loops avoiding unconditional jumps 
assembly code emitted tables exception handling garbage collection 
complications caused java precise exception semantics marmot currently schedule instructions 
low level intermediate representation mir conventional low level intermediate representation 
shares control flow graph basic block representations jir enables reuse algorithms operate cfg 
instruction set mir address instruction set instruction set processor family current target architecture marmot 
instruction set mir includes high level instructions function call return throwing exceptions replaced actual machine instructions register allocation 
operand mir annotated representation information 
simplified version type information identify pointers tracked garbage collector 
conversion mir convert jir mir marmot determines explicit data representations constructs metadata 
converts method data representations chosen phase 
marmot implements metadata including virtual function tables java lang class instances ordinary java objects 
classes defined marmot libraries data layouts determined means classes 
metaclass layout determined mir conversion able statically construct required metadata instances class array types 
marmot converts methods mir procedures syntax directed translation asu 
jir statements map address mir instructions 
coalescing phase register allocator removes unnecessary moves temporaries created translation 
list describes interesting cases translation jir statements mir instructions 
runtime type operations jir provides operations runtime type information checkcast instanceof 
operations lowered high level optimization section 
remaining operations replaced calls java functions implement operations 
exception handlers jir exception handling blocks may kinds incoming edges normal exception 
normal edges represent transfer control exception edges bind variable 
conversion mir splits target exception edge blocks 
block contains code corresponding original block 
second block binds exception variable jumps exception block 
conversion redirects normal predecessors original jir block block exception predecessors second block 
switch statements marmot converts dense switches jump tables small sparse switches chain conditional branches 
field marmot maps field ective addresses operands instructions 
assume risc instruction set load store instructions memory accesses 
long integer operations architecture support bit integers natively 
marmot translates bit integer operations appropriate sequences bit integer operations 
places sequences inline bit multiplication division generates calls runtime functions 
marmot maps bit jir variables pairs bit pseudo registers 
uses pairs disappear course part translation pairs appear mir functions high level call return instructions formal argument lists 
register allocator eliminates occurrences 
long comparisons lcmp conversion jir eliminates occurrences operators replacing simpler boolean comparison operations 
marmot generates inline code remaining occurrences operation 
register allocation marmot uses graph coloring register allocation style chaitin cac cha incorporating improvements coloring process suggested briggs 
allocator phases 
phase eliminates high level procedure calls returns throws 
introducing appropriate low level control transfer instructions making parameter passing value return explicit moves physical locations pseudo registers 

second phase eliminates unnecessary register moves coalescing pseudo registers 
coalesces registers aggressively conservative heuristics suggested ga 
phase rewrites intermediate form pass coalescing iterates register coalesces occur 

third phase performed lazily estimates cost spilling pseudo register 
sums occurrences pseudo register weighting occurrence register loop nesting depth occurrence 

fourth phase attempts find coloring optimistic coloring 
point coloring stops colors available register spilled phase removes pseudo register lowest spilling cost interference graph continues coloring 
phase colors registers successfully applies mapping program register allocation finished 

fifth phase inserts spill code especially important target architecture registers 
phase creates new temporary pseudo register individual occurrence spilled register inserts load store instructions necessary 
attempts optimize reloads memory uses spilled register basic block temporary register times introduce load spilled register optimization apply phase attempts replace spilled register stack location 
doing avoids temporary register program compact eliminating explicit load store instructions 
fifth phase completes register allocation returns fourth phase tries color new intermediate program 
process iterates registers successfully colored 
register allocation particularly important architecture fewer general purpose registers available 
performance problems disproportionately attributable register spilling 
precise garbage collection requires runtime system accurately find memory locations outside heap contain pointers heap 
support function call annotated set stack locations contain pointers live call 
sets empty register allocation updated spill code 
pointer containing register live function call spilled corresponding stack location added set function call 
see bri detailed description done 
runtime support majority runtime system code written java convenience provide large complex test case marmot compiler 
operations including cast array store instanceof checks java lang system thread synchronization interface call lookup implemented java 
marmot emits code rivals hand coded assembly code 
data layout object vtable pointer monitor pointer fields 
remaining fields contain object instance variables arrays contain length field array contents 
vtable pointer points vtable object contains virtual function table class metadata 
include java lang class instance fields implementation interface calls see section size pointer tracking information describing instances associated class array types 
monitor pointer points lazily created extension object containing infrequently parts instance object state 
prominent synchronization state synchronized statements methods wait notify methods java lang object 
incorporates hash code java lang object hashcode 
bacon describes similar scheme reduce space overhead due synchronization 
runtime type operations cast checks array store checks instanceof operations need test type inclusion 
check class subclass class scheme similar dec src modula system page 
node class hierarchy tree numbered pre order traversal 
node marmot records index node largest index max child node 
node subclass node index index max 
implemented machine instructions unsigned comparison expressions index index max index width class 
marmot stores index width vtable class 
class involved runtime type operation known compile time marmot generates specialized version operation uses compile time constants fetching values runtime 
check class implements interface marmot stores list interfaces class implements vtable class 
runtime list scanned interface 
interfaces marmot implements interface dispatch class data structure called interface table itable 
vtable class contains itable interface class implements 
itable maps interface method identifiers corresponding method entry points 
vtable contains mapping class instance interface position corresponding itable vtable 
itables shared possible 
invoking interface method consists calling runtime lookup function class instance interface argument 
function uses interface itable mapping find set itable vtable 
jumps itable desired method 
marmot saves space sharing itables 
interface direct superinterfaces positions itable followed itable 
method declared declared slot 
new methods declared placed itables direct superinterfaces note direct may declare method itable may multiple slots exceptions marmot uses program counter exception handling mechanism 
memory containing marmot generated machine code divided ranges associated list exception handlers 
runtime cost expected case exception thrown 
exception occur runtime system finds range containing throwing program point finds appropriate handler list 
marmot implements stack unwinding creating special exception handler function body 
handler catches exceptions 
invoked pops stack frame function exception 
special case code needed runtime system unwind call stack exception occurs 
marmot add special checks null pointer dereferences integer divide zero 
catches corresponding operating system exception throws appropriate java exception 
threads synchronization marmot java thread implemented native win thread 
monitors semaphores implemented java objects updated native critical sections 
mapping native threads java lang thread objects uses win thread local storage 
bacon describe lightweight implementation monitors java fact contention locks java programs rare 
common cases thread locking object unlocked thread locking object locked times 
case implementations execute single machine level synchronization instruction pair 
second case implementations execute instructions synchronization instructions 
implementations di er allocation monitor objects 
bacon store information bit field header word object contains 
uncommon case occurs bit field overwritten index table monitor objects 
marmot allocates monitor object heap time object locked 
cost amortized number synchronizations object bacon shown usually 
garbage collection marmot ers choice garbage collection schemes conservative collector copying collector generational copying collector 
conservative collector uses mark sweep technique 
copying collector semi space collector cheney scan 
generational collector simple generation collector nursery older generation 
small objects allocated nursery large objects older generation 
nursery fills collected live objects copied older generation 
collector write barrier tracks pointers older generation nursery 
pointers treated roots nursery collected 
write barrier implementations available card marking write barrier sequential store bu er ssb 
ssb multithreaded programs bu er broken chunks allocated demand individual threads 
avoids need synchronization operation entry stored bu er 
heap allocated objects valid java objects contain vtable pointers field 
conservative collector uses information vtable object concerning size object 
object array uses type information determine array contains pointers 
copying generational collectors additional vtable fields locate pointers objects 
copying generational collectors marmot generates tables allow collectors find pointers call stack 
call site associated entry describes callee save registers stack frame locations contain pointers live call 
name loc description impact transcription spec compress benchmark compressing decompressing large arrays synthetic data 
impact benchmark des encoding large file impact transcription unix grep utility large file impact transcription spec li benchmark sample lisp program impact benchmark cmp large files impact benchmark computing digits impact transcription unix wc utility large file impact benchmark merge sort mb table impact benchmark prime finding sieve small medium benchmark programs implementations java 
marmot uses generational collector default collector system sequential store bu er write barrier 
generational collector generally smaller memory footprint shorter average pause time collectors 
native code marmot uses alignment calling conventions native compilers 
class declaration corresponding java class straightforward build manually marmot adds fields objects canonical order 
native code interact explicitly garbage collector 
executing blocking system call thread put heap safe state allow collector run call 
pointers heap saved duration heap safe state location visible collector state exited restored afterward 
marmot thread state includes fields native code purpose 
native code interacts high level optimization native methods invoke java methods read write java data structures 
marmot supports optimization code containing native calls explicit annotations external file 
libraries marmot uses set libraries written specifications java class libraries cl cl 
java lang core language classes java util utility classes java io input output java awt graphics packages complete 
majority classes java net network communications java text international date text formatting support java applet browser interface packages implemented 
java lang java io java net java awt packages provide interface underlying system 
logic classes packages implemented java native code call necessary system functions 
native code performance reasons 
methods interfaces graphics primitives 
assembly code implement math libraries trigonometric functions 
libraries comprised lines java code lines implementing java lang awt lines code lines garbage collectors lines header files lines assembly code 
performance measurements section examine performance marmot compiled code relative java implementations 
analyze costs safety checks benefits synchronization stack allocation optimizations 
compare di erent garbage collection algorithms marmot 
marmot compared compiler understand performance tuned applications written java compares tuned applications written examined performance set benchmarks described java variants 
benchmarks java impact net project 
better understand remaining performance di erences java versions modified reexamined java benchmarks remove transliteration artifacts limitations current marmot optimizations 
compiled benchmark programs marmot microsoft visual version 
benchmarked java systems representative di erent category just time compilers microsoft java vm ms jvm version currently considered state art jit compiler 
commercial static compilers java version upgrade edition 
research static compilers ibm research high performance compiler java ibm version 
static compilers including marmot implement dynamic class loading 
microsoft java vm supports dynamic class loading perform program optimizations iia invalidated class hierarchy extended runtime 
measure performance executed benchmarks environment measured execution time unloaded dual processor pentium ii mhz pc running windows nt sp mb memory 
running times utime averaged runs program loops short running programs minimize measurement noise due ms granularity clock 
standard deviations running times nominal 
shows speed unmodified java programs corresponding versions 
versions times speed marmot versions median 
shows speed programs array bounds checking disabled 
array bounds checking costs account majority speed advantage 
profiled programs version faster marmot version small changes java source code compares files contained virtual function calls inner loop marmot version macros version 
static fields declared assigned bu subclass inputstream 
flow insensitive iia strong rebind virtual calls 
static fields bu eliminated virtual calls 
contained register spills inner loop marmot version version 
reasons spills 
java code instance fields virtual functions version static fields 
changed java version static fields functions version eliminated need register hold pointer 
original version benchmark slower original java version compiled marmot marmot automatically inlines tiny methods compiler leaves line 
report timings faster variant methods inlined 
speed relative marmot visual marmot ibm ms jvm relative speed compiled code benchmarks having java variants normalized marmot 
speed relative marmot visual marmot array bounds checking marmot relative speed compiled code benchmarks having java variants array bounds checking enabled java normalized marmot 
speed relative marmot visual marmot tuned marmot untuned ibm ms jvm relative speed benchmarks tuning normalized marmot tuned 
second java auto increment operator caused additional register pressure array subscript expression form 
variable appear updated array subscript expression evaluated case exception occurs subscripting 
new value live old value live increasing register pressure register 
marmot currently lacks support automatic code motion needed obviate extra register pressure manually moved index increment array subscript expression 
third marmot currently lacks frame pointer omission compiler uses free register 
allocates element arrays inner loop java version 
original program contained allocation modified java source reuse single temporary array repeatedly allocating discarding new 
java version executes array bounds checks inner loop added conditional test loop allowed compiler eliminate 
innermost loop contains multiple di erent constant arrays 
compiler allocates initializes arrays statically base addresses 
marmot currently allocates arrays heap stores pointers static fields causing extra loads creating extra register pressure hold heap addresses 
lisp interpreter private garbage collector interacts badly marmot collector 
eliminated private garbage collector java version relied marmot garbage collector 
merge sort array bounds checks innermost loops 
added conditional tests loops allowed optimizer eliminate checks 
marmot currently lacks strength reduction pointer arithmetic compiler provides 
word counting program static fields better declared local variables allowing marmot eliminate array bounds checks improve register allocation 
compiler performs strength reduction pointer arithmetic 
name loc description marmot marmot compiling javac jlex jlex generating lexer sample lex run times 
javacup javacup generating java parser svd singular value decomposition matrices plasma constrained plasma field simulation visualization cn cn induction algorithm slice viewer slices radiology data small medium java benchmark programs 
name loc description compress compression program compressing decompressing files jess java expert shell system solving set puzzles db memory database program performing sequence operations javac unavailable java bytecode compiler mpegaudio unavailable mpeg audio program decompressing audio files mpeg layer format jack unavailable java parser generator generating parser spec jvm client benchmarks 
name lines description code numeric sort sorts array integers string sort sorts array strings bit field operations tests variety functions manipulate bit fields fp emulation implements floating point operations software fourier computes coe cients series approximations waveforms assignment assigns tasks operations research algorithm idea encryption encrypts decrypts memory data 
hu man compression compresses decompresses memory data neural net simulates back propagation neural net lu decomposition solves linear equations java transcription byte magazine benchmarks hal 
shows performance benchmarks tuning 
versions times speed marmot versions median 
performance benchmarks improved better compiler optimization 
analysis determined constant arrays allocated initialized statically reduce register pressure 
techniques strength reduction pointer arithmetic presence garbage collection diwan improve performance 
results section suggest production quality compilers java produce code competitive produced production quality compilers 
marmot compared java systems compared performance marmot java systems set java benchmarks described figures 
shows relative performance java systems benchmarks 
results indicate known compilation techniques marmot produce executables performance comparable superior produced java systems 
cn javacup jlex marmot plasma slice svd compress jess db javac mpegaudio jack numeric sort string sort operations fp emulation fourier assignment idea encryption huffman compression neural net lu decomposition speed relative marmot marmot ibm ms jvm relative speed benchmarks normalized marmot 
cn javacup jlex marmot plasma slice svd compress jess db javac mpegaudio jack numeric sort string sort operations fp emulation fourier assignment idea encryption huffman compression neural net lu decomposition percent program running time safety checks array bounds checks cost safety checks programs compiled marmot 
costs relative program execution times programs compiled safety checks enabled 
synchronization cost cycles marmot ibm ms jvm compare swap test store relative speed invoking empty synchronized method 
cost safety checks java programs execute kinds run time safety checks array bounds checks array store checks cast checks null pointer checks 
marmot allows selectively disable particular run time checks determine cost 
shows costs various safety checks percentages execution times programs checks enabled 
programs combined cost array store checks null pointer checks dynamic cast checks insignificant 
median combined cost checks maximum 
programs total cost safety checks small 
median cost safety checks programs having safety check cost 
array intensive programs array bounds check costs exceed 
synchronization elimination synchronization elimination optimization removes synchronization operations programs proved compile time single threaded 
magnitude benefit depends cost synchronization 
bacon shown common synchronization case unlocked object locked thread 
compares average cost virtual call empty synchronized method java systems measured includes lower bound cost core synchronization code sequence compare swap synchronizing instruction test lock acquired store release lock 
marmot primitive synchronization costs competitive java systems factor lower bound 
shows costs synchronization primitives reasonable marmot synchronization costs artifact poor implementation 
ect performance disabling synchronization elimination optimization shown 
ect varies widely dependent particular program 
extreme single threaded programs run times faster optimization 
programs spend time inner loops call synchronized library function read byte bu ered file 
extreme computation intensive programs mpegaudio svd execute synchronization optimization ect 
optimization ect plasma slice multithreaded 
general eliminating synchronization important larger programs spec jvm small medium sized benchmarks smaller programs impact benchmarks benchmarks 
larger programs disabling optimization reduces speed programs median value 
smaller programs disabling optimization reduces speed safety checks fail execution benchmarks eliminating checks change behavior programs benchmark input 
cn javacup jlex marmot plasma slice svd compress jess db javac mpegaudio jack numeric sort string sort operations fp emulation fourier assignment idea encryption huffman compression neural net lu decomposition speed relative marmot sync elim sync elim ect performance disabling synchronization elimination optimization normalized sync elim 
javacup marmot slice jess db jack speed relative marmot stack alloc stack alloc ect performance disabling stack allocation optimization selected benchmarks normalized stack alloc 
programs median value 
indicates larger programs extensive java libraries heavily synchronized 
little lock contention occurs larger programs spend substantially time synchronizing performing safety checks 
marmot implementation synchronization competitive systems may important reduce synchronization cost multithreaded programs 
ect stack allocation stack allocation optimization reduced program execution time non trivial benchmarks 
shows ect disabling optimization performance benchmarks include small medium sized benchmarks marmot java cup spec client jvm programs jess db jack 
ect remaining benchmarks negligible shown 
comparison garbage collectors benchmarks significant amounts allocation compare ect application speed marmot garbage collectors conservative collector semi space copying collector generational collector 
collectors configured manner 
copying conservative collectors collection occurs mbytes data allocation 
generational collector nursery mbytes size 
objects larger older generation 
older generation collected mbytes data copied nursery 
lists benchmarks allocate significant amounts memory amounts allocate 
excludes benchmarks allocate large data structures persist entire benchmark run 
program allocation mbytes cn javacup jlex marmot compress jess db javac jack benchmarks allocate significant amounts memory 
cn javacup jlex marmot compress jess db javac jack speed relative generational version generational copying conservative ect di erent garbage collectors performance selected benchmarks normalized generational 
compares performance di erent benchmarks various garbage collectors 
benchmarks run safety checks 
marmot allocates memory benchmarks version uses generational garbage collector fastest 
rest programs copying collector generally fastest followed generational collector conservative collector 
current settings cost generational write barrier exceeds possible reduction garbage collection time 
cost garbage collection copying collector low range 
javac program marmot cost copying collection high garbage collection times copying collector generational collector 
survival rate objects allocated nursery quite high sets reduction collections older generation 
additional cost write barrier generational collector version slower 
related java compiler projects statically compile java source code java bytecodes portable assembly language 
complete implementations known harissa toba ptb 
harissa toba runtime systems boehm demers weiser conservative garbage collector 
incorporates compiled code sun microsystems java runtime system jni 
java compiler projects statically compile java source java bytecodes existing back compile languages 
ibm high performance compiler java uses common back ibm xl compilers ucsb kh distinct university colorado mdg suif system 
impact net compiler uses impact optimizing compiler back 
java compiler cecil vortex project ddg uses vortex compiler back 
vortex runtime system includes precise garbage collector tuned cecil programs systems retrofit conservative garbage collectors runtime systems systems designed precise collection 
java compilers compiling directly native code part commercial development systems 
tower technology tow generates native code numerous platforms machine architectures operating systems sup symantec visual cafe sym generate native code systems 
systems include customized runtime systems 
sun microsystem hotspot compiler uses technology similar self compilers 
optimizations measured runtime behavior recompilation optimization performed program running 
instantiations compiler ins compiler nat employ static program analysis optimization include runtime systems 
described implementation marmot native code compiler runtime system library java evaluated performance set marmot compiled benchmarks 
marmot intended primarily high quality research platform initially chose concentrate extension known successful imperative object oriented language implementation techniques java 
similarly focused ease implementation modification compilation speed compiler storage usage debugging support library completeness requirements production systems 
remainder section summarizes learned implementing marmot system examining performance programs compiled marmot 
java bytecode inconvenient input language obscures information java source code type information structure high level operations try 
generate code marmot forced reconstruct missing types recognize optimize bytecode idioms 
able apply large number conventional scalar object oriented optimizations required extensions support new java language features 
features inducing significant changes precise exception model absence interprocedural ect analyses severely limited code motion optimizations multithreaded storage model required modifications storage analyses 
compact modeling precise exceptions ssa representation required additional ort 
current limitations code motion hinder instruction scheduling 
marmot techniques worked yielding application performance competitive java systems approaching 
suggests production quality compiler java produce code competitive produced production quality compilers 
marmot optimizations reduced cost safety checks quite modest level median benchmarks 
cient lock implementation simple synchronization elimination reduces execution time larger benchmarks median 
storage management added significant runtime costs inside outside garbage collector 
stack allocation reduced program execution time 
david gay implementing stack allocation marmot jacob rehof improving marmot type elaboration algorithms 
cheng hsieh wen mei hwu impact team graciously sharing benchmarks 
app andrew appel 
modern compiler java 
cambridge university press 
asu alfred aho ravi sethi je rey ullman 
compilers principles techniques tools 
addison wesley reading ma usa 
asu jonathan 
optimization array subscript range checks 
acm letters programming languages systems june 
bac david bacon 
fast ective optimization statically typed object oriented languages 
phd thesis berkeley october 
preston briggs keith cooper timothy harvey taylor simpson 
practical improvements construction destruction static single assignment form 
software practice experience january 
preston briggs keith cooper linda torczon 
improvements graph coloring register allocation 
acm transactions programming languages systems may 
david bacon ravi chet murthy mauricio serrano 
thin locks featherweight synchronization java 
proceedings sigplan conference programming language design implementation pages june 
bri preston briggs 
register allocation graph coloring 
phd thesis rice university april 
bs david bacon peter sweeney 
fast static analysis virtual function calls 
proceedings oopsla acm sigplan notices pages october 
published proceedings oopsla acm sigplan notices volume number 
cac gregory chaitin marc auslander ashok chandra john cocke martin hopkins peter markstein 
register allocation coloring 
computer languages january 
cc patrick cousot radhia cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
proceedings fourth annual acm symposium principles programming languages pages los angeles january 
cfr ron cytron jeanne ferrante berry rosen mark wegman kenneth zadeck 
cient method computing static single assignment form 
proceedings sixteenth annual acm symposium principles programming languages january 
ron cytron jeanne ferrante barry rosen mark wegman 
ciently computing static single assignment form control dependence graph 
acm transactions programming languages systems october 
cg wei ngan chin goh 
reexamination optimization array subscript range checks 
acm transactions programming languages systems march 
cha chaitin 
register allocation spilling graph coloring 
proceedings acm sigplan symposium compiler construction pages june 
cl keith cooper john lu 
register promotion programs 
proceedings sigplan conference programming language design implementation pages 
cl patrick chan lee 
java class libraries volume 
addison wesley second edition 
cl patrick chan lee 
java class libraries volume 
addison wesley second edition 
chang scott mahlke william chen wen mei hwu :10.1.1.14.9668
profile guided automatic inline expansion programs 
software practice experience may 
css jong deok choi vivek sarkar schonberg 
incremental computation static single assignment form 
cc sixth international conference compiler construction lncs pages april 
ddg je rey dean greg defouw david grove litvinov craig chambers 
vortex optimizing compiler object oriented languages 
proceedings oopsla acm sigplan notices pages october 
published proceedings oopsla acm sigplan notices volume number 
de george dantzig curtis 
fourier motzkin elimination dual 
journal combinatorial theory 
dgc je rey dean david grove craig chambers 
optimization object oriented programs static class hierarchy analysis 
editor proceedings ecoop lncs pages aarhus denmark august 
springer verlag 
amer diwan eliot moss richard hudson 
compiler support garbage collection statically typed language 
proceedings sigplan conference programming language design implementation pages san francisco california june 
sigplan acm press 
du fourier analysis linear inequality systems 
mathematical programming study pages 
north holland new york 
fre stephen freund 
costs benefits java bytecode subroutines 
formal underpinnings java workshop oopsla 
ga lal george andrew appel 
iterated register coalescing 
acm transactions programming languages systems may 
gh etienne gagnon laurie hendren 
intra procedural inference static types java bytecode 
technical report mcgill university 
gjs james gosling bill joy guy steele 
java language specification 
java series 
addison wesley reading ma usa june 
gs david gay bjarne steensgaard 
stack allocating objects java 
preparation 
gup rajiv gupta 
fresh look optimizing array bound checking 
proceedings sigplan conference programming language design implementation pages june 
gup rajiv gupta 
optimizing array bound checks flow analysis 
acm letters programming languages systems march december 
hal tom 
benchmarking java 
byte magazine may 
urs holzle lars bak ste en robert 
java sun highperformance java implementation 
presentation hot chips ix stanford california usa august 
cheng hsieh marie conte teresa johnson john gyllenhaal wen mei hwu 
optimizing net compilers improved java performance 
computer june 
cheng hsieh john gyllenhaal wen mei hwu 
java bytecode native code translation ca eine prototype preliminary results 
ieee proceedings th annual international symposium microarchitecture 
ins instantiations super optimizing deployment environment java 
www instantiations com htm july 
kh holger urs holzle 
suif java compiler 
proceedings second suif compiler workshop august 
kw michael wolfe 
elimination redundant array subscript range checks 
proceedings sigplan conference programming language design implementation pages 
lck raymond lo fred chow robert kennedy shin ming lu peng tu 
register promotion sparse partial redundancy elimination loads stores 
proceedings sigplan conference programming language design implementation pages june 
lt thomas lengauer robert endre tarjan 
fast algorithm finding dominators flowgraph 
acm transactions programming languages systems july 
ly tim lindholm frank yellin 
java virtual machine specification 
java series 
addison wesley reading ma usa 
mcm victoria markstein john cocke peter markstein 
optimization range checking 
proceedings acm sigplan symposium compiler construction pages june 
mdg eric sandeep gupta 
compiling java suif incorporating support objectoriented languages 
proceedings second suif compiler workshop august 
gilles muller barbara moura fabrice charles consel 
harissa flexible cient java environment mixing bytecode compiled code 
proceedings third conference object oriented technologies sytems coots 
muc steven muchnick 
advanced compiler design implementation 
morgan kaufmann san francisco 
nat llc 
java compiler technology 
www com 
john ne 
java vm scales best 
javaworld august 
open group 
high performance java compiler 
www camb com february 
ptb todd proebsting gregg townsend patrick bridges john harman tim scott 
toba java applications way ahead time wat compiler 
proceedings third conference object oriented technologies sytems coots 
sg sreedhar guang gao 
linear time algorithm placing nodes 
proceedings nd acm sigplan sigact symposium principles programming languages pages january 
si suzuki 
implementation array bound checker 
proceedings fourth annual acm symposium principles programming languages pages 
sup java version upgrade edition 
www com september 
sym symantec 
visual cafe pro 
www symantec com september 
tar david tarditi 
design implementation code optimizations type directed compiler standard ml 
phd thesis carnegie mellon university december 
tow tower technology 
release 
www twr com september 
jan vitek nigel horspool andreas krall 
cient type inclusion tests 
proceedings oopsla acm sigplan notices pages october 
published proceedings oopsla acm sigplan notices volume number 
wil williams 
fourier motzkin elimination extension integer programming problems 
journal theory 
wol michael wolfe 
high performance compilers parallel computing 
addison wesley 
xp hongwei xi frank pfenning 
eliminating array bound checking dependent types 
proceedings sigplan conference programming language design implementation page unknown pages 

