grammatically genetic programming department computer science university college university new south wales australian defence force academy canberra act australia genetic programming gp paradigm functional approach inductively forming programs 
natural selection fitness function reproduction program population allowed problems solved require non fixed representation 
attempts extend gp focussed typing language restrict crossover ensure legal programs created 
describe context free grammar define structure initial language direct crossover mutation operators 
grammar specify structure hypothesis language allows clear statement inductive bias control typing 
modifying grammar evolution proceeds example learnt bias 
technique leads declarative approaches evolutionary learning allows fields incremental learning incorporated paradigm 
genetic programming paradigm gp received attention lately form adaptive learning koza 
technique genetic algorithm ga holland exploits process natural selection fitness measure breed population trial solutions improves time 
ability ga efficiently search large conceptual spaces suitable discovery induction generalisations data set 
summary genetic programming paradigm may koza 
closure genetic programming requirement closure program structures difficult express 
closure defined koza koza indicate function set defined combination arguments 
allowed points program crossed swapping program structures points program tree 
problems require functions typed arguments 
generally handled constraining syntactic structure resultant programs koza 
particular crossover point selected second point crossover match syntactic type point 
ensures syntactically legal programs created programs swap components koza 
typing issues addressed montana montana sets type variable constant argument return value initial population created 
constrains initialisation process subsequent genetic operators legal programs created 
bias genetic programming explicit typing may considered language bias 
bias machine learning methods inductive logic programming cohen restrict hypothesis language 
syntactic typing restricts form resultant program allow higher level structure represented 
introduces context free grammars cfg overcome closure requirements gp 
particular grammar allows user bias initial gp structures automatically ensure typing syntax maintained manipulating explicit derivation tree grammar 
describe extensions form allow bias learnt evolution solution proceeds 
system referred context free grammar genetic programming cfg gp 
context free grammars grammars may barrett couch 
context free grammar tuple nonterminal alphabet terminal alphabet set productions designated start symbol 
productions form ng productions form may expressed disjunctive symbol derivation step derivation step represents application production nonterminal symbol represent derivation step 
example nonterminal represent derivation step applying production ff fi ff fi ff fi fn derivation rooted defined ff ff fn represents zero derivation steps 
series derivation steps may represented tree 
grammatically learning system multiplexer example initially describe differences traditional gp grammars traditionally definitions terminal nonterminal represent atomic tokens symbols replaced respectively 
gp terms distinguish functions arguments gamma arity functions atomic values 
ensure confusion discussing gp constructs words 
program multiplexer program created cfg cfg gp 
full description multiplexer may koza 
table multiplexor gp representation table shows gp definitions representing multiplexer problem 
possible tree created definitions shown 
grammar possibilities allows creation functional structures derivation tree grammar shown 
trees figures represent function 
creating initial population initial population gp programs created technique half 
typically programs created depth upwards forced full depth randomly generated current maximum depth 
cfg gp initial population defined series parameters depth depth numberof programs creates number programs parse tree depth exceeding depth 
steps done create initial program population cfg fn sg 

label production ff ff fn minimum number derivation steps create terminals 

minimum number derivation steps create ff ff fi fi define fi fi having depth 
range depths number depth select start symbol label current nonterminal randomly select production form ff minimum derivation steps nonterminal ff label current nonterminal repeat steps 
ensure measure diversity programs initial population required different parse derivation trees 
selection individual programs selection programs uses process gp programs selected probability related fitness measure 
proportional fitness selection problems described 
programs executed pre order traversal derivation trees 
reproduction programs copied generation ion operation proportional fitness similar manner gp 
derivation derivation tree derivation derivation tree derivation modified modified derivation terminal nonterminal crossover derivation trees crossover cfg examining shows executable programs constructed terminals grammar 
terminals nonterminal program tree loss generality may constrain crossover points located nonterminals 
crossover operation maintains legal programs language defined grammar ensuring non terminals selected crossover site 
parameter max tree depth indicate deepest parse tree may exist population 
crossover algorithm see 
select programs derivation trees ae ae population fitness 
randomly select non terminal ae 
non terminal matches ae goto step 
randomly select ae 
swap subtrees non terminals note parameter max tree depth may exclude crossover operations performed 
current system crossover new program exceeds max tree depth entire operation aborted crossover procedure step 
mutation mutation applies single program 
program selected mutation non terminal randomly selected site mutation 
tree non terminal deleted new tree randomly generated grammar nonterminal starting point 
tree limited total depth current maximum allowable program depth max tree depth operation similar creating initial population 
applying cfg gp multiplexer problem grammar productions define structures solving problem start symbol nonterminals fb tg terminals fif 
table cfg multiplexer setup generations population size depth depth depth depth depth crossover reproduction max tree depth fitness measure possible cases program selection proportionate grammar applied different runs table resulting probability success determined 
note traditional gp applied multiplexer similar population parameters probability success approximately koza 
discussion initial results difficulty directly comparing gp applied multiplexer technique just described 
applying gp crossover occurred internal points tree tips 
cfg merely selected random site non terminals 
normally bias sub trees close terminal number nodes generally increases level tree 
differing results cfg gp may partially accounted distinction 
factors differing tree structures initial population seeding may influence result 
indicated elucidate differences 
applying bias multiplexer grammar examine effect applying bias grammar created specific versions grammar previously 
new grammar specific solution higher probability success 
grammar biased solution functions function program 
probability success approximately 
extending bias knowledge address line partially selected resulting data line create initial function address line follows grammar achieved probability success approximately 
final bias allow programs initial se lection mechanisms created grammar achieved probability success approximately 
discussion bias multiplexer previous results show bias grammar supports probability finding solution 
leads argument problem space large language bias restrict possible program structures hopefully greater success finding solutions 
grammar allowed user impose search bias language bias forms program created structure programs evolution 
may augment gp specialised functions improve performance differences approaches 
cfg gp bias may declared changing underlying functions solution gp define new functions explicitly 
difficult express combinations functions bias gp 
cfg control typing example program requires typing examine grammar define index classification describe landscape moisture 
problem described author gp approach required spatial operations avoid typing conflicts boolean operators 
attempted solve boolean case values required spatial description 
typing constraints necessary spatial operators return boolean values may arguments boolean functions 
object object rel luv object slope rel rel luv luv resent luv stream luv major stream sand luv luv lower upper luv luv low luv gentle slopes luv dam quarry gamma gamma gamma gamma gamma 
current adjacent note luv ordered terminals allowing meaningful statements relations rel 
grammar program created partial solutions problem settings table index setup generations population size depth depth depth depth crossover reproduction max tree depth fitness measure values program selection proportionate discover complete solution settings program demonstrated typing constraints maintained crossover grammatical definition 
example program generated settings table shown upper adjacent current slope current slope current current low hill slopes current generating new productions interest gp community adapting representation language evolution solution proceeds rosca ballard 
approaches tend take group functions turn single function values turned variables new function interest creating higher level functions appear useful identifying encapsulating useful building blocks 
studied automatically defined functions adf increase descriptive power language initial constructs kinnear 
adf true functions sense having list arguments function body return value 
consider extended version changing language focus modifying grammar weak form changing representation 
language cfg suggest new productions may discovered analysis current fit individuals population 
productions representing individuals may modify original grammar 
grammar may introduce new programs parts programs population 
consider creating new functions demonstrate form encapsulation builds new terms initial language 
modifying cfg constrain search space goal create set operations modify cfg initially bias learning system 
system attempts modify grammar ffl recognize need change representation ffl identify program individuals direct changes grammar ffl identify program productions refined ffl incorporate changes grammar ffl incorporate grammar back population programs examine points detail 
need change representation assumption population generation contain useful productions 
variation fitness population true 
identifying individuals identifying programs parts programs identified useful studied rosca ballard rosca ballard criterion studied fit blocks frequent blocks 
concluded fit blocks useful measure determine building block 
assumption fit program contain relatively fit productions may exploited changes grammar 
chose candidate program fittest individual population 
program equally fit chose program depth parse tree 
identifying useful productions selected program extend grammar range options concerning productions parts productions 
goal allow refinement grammar proceed initial grammar may viewed general description program search space 
easily incorporated refinement propagate terminal program tree level non terminals 
shown selected terminal propagated parse tree production terminals non terminals level 
describe new production places terminal previous non terminal spot grammar 
problem determining terminal selected 
propagating terminal tree assumption deepest terminals parse tree influence structure program chose terminal general point location refine 
mean attempt initially refine arguments functions functions 
terminal deepest point derivation tree program left terminal selected refinement 
incorporating productions cfg grammar represents generalisation space solutions problem 
productions selected composing correct solution 
represent concept explicitly giving production merit value represents probability selection non terminal 
initial grammar may biased changing merit value production changing applied program generated grammar 
grammar begins production bias set productions merit 
probability production selected epoch replacement proportional merit 
example consider production derivation steps may true syntactically terminal may effect semantics program 
study focussed syntactic manipulation programs semantics revealed evaluation program complete unit 
encapsulating production extend productions include production exist merit 
production exist merit incremented increasing probability selection grammar create programs 
second situation propagating terminal symbols occurs siblings propagated terminal terminal symbols 
example production fittest program contain deepest terminals shown 
wish encapsulate terminals functional symbol 
performed creating new terminal binds terminal symbols 
example production covered creating new encapsulated terminal definition 
terminal included set possible terminals production initial merit new symbol grammar may involved refinements encapsulations allowing useful components combined propagated 
incorporating grammar population modifying grammar changed current population programs created 
epoch replacement rosca ballard approach introducing new programs evolution 
term replacement represent number new programs created generation 
merit selection wish demonstrate adapting merit values productions evolution solution effective mechanism improving refinement grammars 
settings cfg gp multiplexer problem shown table 
table cfg gp multiplexer parameters generations population size depth depth depth depth depth crossover reproduction replacement max tree depth fitness measure possible cases program selection proportionate system replacement population recreated generation 
initial cfg gp system refinement replacement operator merely initial static grammar replace individuals generation 
probability success arrangement runs system 
refinement operator introduced settings probability success increase 
refinement performed generation fittest program selecting deepest terminal inclusion grammar described earlier 
merit proportionate selection production selection increased success probability increases statistically significant 
grammar created successful initial system refinement change merit proportionate selection productions introduced grammar modified evolution system 
run cfg gp generations num 
indicates merit value production 























grammar clearly shows bias function address lines test values 
grammar reflect general sense form preferred solution 
effect encapsulation studied effect encapsulation replacement individuals generation 
setup table encapsulation performed detected 
encapsulation detected required previous grammatical changes forced refinement point tried refine production composed terminals 
encapsulation previous initial grammar may occur times generations 
performed runs genetic program encapsulation replacement 
probability success implied little benefit encapsulation problem 
partially negative result may reflection limited number generations performed 
typical failed run cfg gp encapsulations performed limiting possible benefits discovering incorporating new useful terms population 
certainly runs genetic program useful encapsulations discovered shows address line useful selection point determining data lines chosen 
investigate limited generations contributing factor lack effect encapsulation previous experiments redone maximum number generations increased 
refinement encapsulation improved encapsulation included probability success showing similar lack improvement generation results 
discussion previous results previous shown refining grammar productions selected fit programs programs population modified grammar measurable benefits terms finding solution multiplexer 
shown merit selection grammatical productions aids creating useful programs evolution 
lack positive results encapsulation operation may due small probability time propagate population number generations completed 
generation tests encapsulations created runs 
encapsulation current grammar easily created appear affect results 
incremental learning biased grammar completion cfg gp run previous grammatical operators expect evolved grammar represent bias solution 
case modified grammar initial grammar increase performance genetic program 
tested hypothesis grammar described section initial grammar cfg gp merit production loaded part initial grammar information productions formed complete grammar 
parameter settings table 
technique represents form incremental learning information previous run program passed subsequent run expected improvement performance 
probability success learnt grammar ignored encapsulation operator benefit minimal multiplexer 
confirmed grammar modified way bias search space program multiplexer 
described starting point new genetically system learning 
required areas ffl studying structure initial populations influence probability success 
ffl applying inductive bias techniques problems find operators generalise 
ffl examining learn grammar may applied similar different problem expected improvement 
example grammar learnt multiplexer useful multiplexer 
approaches problem defining classes problems suitable learning inductive bias 
ffl describing class problems amenable description context free language 
demonstrated context free grammar define structure language manipulated genetic program 
grammar generation mechanism allow crossover mutation occur violating requirements closure 
learning new productions represents attempt shape search space represented grammar evolution proceeds 
positive results achieved refinement operator gradually change underlying grammatical definition promise applying automatic bias genetic learning 
encapsulation operator appear significant influence probability success problems examined 
required determine due form problems operator represent significant information 
certainly new symbols created encompassed relevant constructions discoveries normally exploited back population frequency impact learnt productions 
shown changes grammar represent underlying form problem 
demonstrated modified grammar starting point learning led improved probability success 
form incremental learning 
author express bob mckay discussions seeding idea applying language grammars evolutionary context 
go rosca comments suggestions 
cohen william cohen 
grammatically biased learning learning logic programs explicit antecedent description language 
technical report bell laboratories murray hill nj 
holland john holland 
adaptation natural artificial systems 
mit press second edition 
kinnear jr kinnear editor 
advances genetic programming 
cambridge ma mit press 
koza john koza 
dynamic genetic chaotic programming chapter pages 
john wiley sons 
koza john koza 
genetic programming programming computers means natural selection 
bradford book mit press 
koza john koza 
genetic programming programming computers means natural selection chapter pages 
bradford book mit press 
montana david montana 
strongly typed genetic programming 
technical report bbn bolt beranek newman cambridge ma 
rosca ballard rosca dana ballard 
learning adapting representations genetic programming 
ieee conference evolutionary computation pages 
morgan kaufmann pub june 
barrett couch gustafson barrett bates couch 
compiler construction theory practice 
science research assoc 

empirical investigation genetic programming paradigm 
technical report cs university college university new south wales 

operations modify grammar direct search space genetic program 
technical report cs university college university new south wales 
