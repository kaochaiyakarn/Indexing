nora making deduction software component retrieval practical johann schumann automated reasoning institut fur informatik tu munchen munchen schumann informatik tu muenchen de bernd fischer abt 
tu braunschweig braunschweig ips cs tu bs de deduction software component retrieval uses preand postconditions indexes search keys automated theorem prover atp check component matches 
idea simple vast number arising proof tasks practical implementation hard 
pass components chain filters increasing deductive power 
chain rejection filters signature matching model checking techniques rule non matches early possible prevent subsequent atp 
intermediate results reasonable precision available time retrieval process 
final atp step works confirmation filter lift precision answer set 
implemented chain runs fully automatically uses mace model checking automated prover setheo confirmation filter 
evaluated system medium sized collection components 
results encourage approach 

reuse approved software components identified key factors successful software engineering projects 
reuse process covers non technical aspects retrieving appropriate software components reuse library central task 
best captured golden rule software supported dfg sn habilitation sfb paris parallelization inference systems 
part done visiting icsi berkeley 
reuse find reuse 
earlier software component retrieval scr methods grew classical information retrieval unstructured texts 
software components highly structured specialized approaches may lead better results 
concentrate deduction approach pre postconditions components indexes search keys 
component matches search key involved pre postconditions satisfy defined logical relation component weaker precondition stronger postcondition search key 
matching relation proof task constructed atp establish disprove match 
approach proposed convincing success essential user requirements neglected 
follow user oriented approach describe steps making deduction scr practical 
concentrate deduction scr key technique underlies ambitious logic software engineering approaches program synthesis component adaptation 
discussion benefits integration software engineering processes refer 
sections outline user requirements practical reuse tool system architecture featuring filter pipeline graphical user interface 
discuss construction proof tasks vdm sl specifications 
important step different approaches model quite different reuse aspects 
sections focus major components filter pipeline rejection non matches model checking techniques final confirmation filter setheo 
evaluated approach rule attributed tracz 
database list specifications 
assess results experiments section 
compare approach related conclude current nora 
user point view earlier focussed technical aspects deduction scr 
users write complete specifications atp input language supply useful lemmata 
provers run batch mode checking library results 
atp runtimes problems scaling ignored 
view led severe acceptance problems users software engineers atp experts 
main requirements tool easy fully fast customizable hides evidence automated theorem proving 
hiding atp consequences 
input language fully specification language pure order logic fol 
automatic construction actual proof tasks major task 
short response times essential fourth reuse demands find faster rebuild 

due computational complexity atp truly interactive sub second behavior far reach 
anytime behavior acceptable intermediate results sufficient precision available user time retrieval process 
retrieval may guided feedback user may example strengthen search key incrementally 
ideally tool doesn constrain user feedback queries allows customization complete retrieval process 
includes selection appropriate match relation list choices tuning deductive mechanism time limits model sizes 
important ensure tool runs fully automatically produces useful results customization 
exchange constraints deduction scr offers unique feature completeness soundness absolutely vital 
incomplete unsound deduction methods reduce recall get matching components precision get right components 
nora real acronym highly adaptive multimethod retrieval tool 
real life setting reuse administrator required knows applied deduction methods tune libraries giving atp settings domain specific lemmata 

graphical user interface 
system architecture order meet user requirements implemented nora filter pipeline candidates fed pipeline typically starts signature matching filters 
check candidate query compatible calling conventions types signatures 
notion compatibility specified equational theory filter applies matching unification signature terms 
typical theories include axioms handle associativity commutativity parameter lists records currying functional languages pointer types var parameters imperative languages coercion rules see detailed discussion rejection filters try eliminate non matches fast possible 
crucial step prevent atp non matching matching candidates 
currently apply model generation techniques check validity tasks suitable finite models 
precision recall may decrease approach sound complete 
confirmation filters check validity remaining proof tasks lift precision result 
apply setheo high performance prover model elimination calculus 
filter classes described detail 
graphical user interface cf 
reflects idea successive filtering 
pipeline may easily customized icon pad filter icon hides specialized filter control window allows filters 
additional inspectors display intermediate results easy access components 
allow save intermediate results file may easily libraries subsequent retrieval runs 
objective gui precisely hide evidence atp usage 
knowledge necessary nora tool restricted vdm sl input language target language required signature matching 

proof tasks reuse structure generated proof tasks depends definition match relation deduction scr tool 
ultimately depends kind reuse tool aims 
deduction scr configured ensure plug compatibility retrieved components matches weaker precondition stronger postcondition search key usually cf 
formalized pre pre post post adequate partial functions :10.1.1.29.5124
partial function tail total completion nil returns nil want match completed result fit original specification 
necessary restrict implication postconditions domain pre proof tasks form pre pre pre post post similar guarded plug match stronger implication precondition query :10.1.1.29.5124
plug compatibility supports safe reuse 
retrieved components may considered black boxes may reused proviso modification component 
plug compatibility applicable users don want specify precondition willing accept comes long postconditions met 
case simplifies pre post post conditional compatibility 
reuse potentially unsafe client satisfy open obligation pre strong retrieves components library contains matches partial functions 
additionally retrieve components partial compatibility may pre pre post post proof tasks universally closed wrt 
formal input output parameters component query contain equations relating parameters 
likewise pre postconditions course logical functions respective parameters 
improve readability traditionally abbreviated formulations 
component retrieved computes correct results common domain 
domains disjoint pre pre true time vacuously true 
usually different types rejected signature matching 
empty domain implementable post true vacuously true retrieved query 
happen library 
obviously reuse partial compatibility unsafe retrieved components guaranteed entire required domain 
starting points desired general implementations 
components considered white boxes code needs closer inspection 
example consider vdm sl specifications rotate list list shuffle pre true pre true post post item delta delta tl hd delta assume plug compatibility match relation rotate candidate shuffle query steps necessary construct sorted fol proof task 
formal parameters identified case vdm underlying valued logic lpf translated fol 
essentially requires explicit insertion additional preconditions proof task prevent reasoning undefined terms translation connectives takes care missing law excluded middle 
example results proof task list delta true true tl hd item delta delta delta simplification removes obviously true false parts formula 

rejecting non matches detecting rejecting non matching components fast early possible probably single important step making deduction scr practical means concatenation lists empty list singleton list item hd tl functions head tail respectively 
identification simple renaming substitution vdm sl allows pattern matching complex data types 
simply non matching matching components 
unfortunately suited task 
exhaustively search proof refutation conjecture practically unable conclude valid contradictory 
techniques implement rejection filters 
generally may reject component find counterexample associated proof task valid 
model generators fol finder mace try find counterexamples simply interpretations evaluates false systematically checking possible interpretations 
obviously terminates involved domains finite example finite group theory hardware verification problems 
hand highly efficient implementation model generators usually bdd davis putnam decision procedures ideal candidates fast rejection filters 
domains application finite unbounded numbers lists 
want model generation techniques purpose map infinite domains finite representations abstraction approximation 

mapping abstraction approach establish mapping uses techniques interpretation infinite domain small finite number sets called domains 
function counterpart constructed commute abstraction function ff original domains ff ff 
may partition domain integers domains fx fx called zero pos neg 
operations integers abstracted accordingly 
example multiplication theta get multiplication theta mirrors sign rule neg pos neg 
model checking represents domains single model elements tries find axiomatization functions predicates standard fol model generator 
problem 
interpretation may escape larger domain truth values order predicates commute abstraction function standard fol model generators require exact concrete domain true false consistent abstraction may impossible 
try ordering numbers zero pos valid assign single truth value pos pos arbitrary positive numbers may ordered way 
predicates allow exact abstractions approximate 
want model checking rejection filter choices filter produces false counterexamples possible spurious matches handled subsequent confirmation filter improperly rejected components lost forever 

mapping approximation second approach map infinite domain finite done approximation 
infinite domain select number values crucial module behavior 
lists usually picks empty list small lists elements 
search model counterexample 
approach manual checking matches find matching component checks empty list small lists 
succeed component selected 
additional checks applied 
approach sound complete 
exist invalid formulas model finitely approximated domain list delta item delta vice versa list delta model domains distinct elements 
second case harmful application performance filter just decreases proof tasks pass dangerous proof tasks describing valid matches lost 
experiments describe section approach 
prototype implementation model generator mace 

setheo confirmation filter final stage filter chain highperformance theorem prover setheo 
setheo complete sound prover unsorted order logic model elimination calculus 
accepts formulas clausal normal form tries refute formula constructing closed tableau tree clauses 
completeness accomplished limiting depth search space bound size depth tableau performing iterative deepening bound 
context setheo seen black box returns proof failed find proof time limit 
details setheo 
description system features see 
setheo soundness obtain confirmation filter guarantees proof tasks pass successfully select matching components 
due hard time constraints means taken decrease recall unacceptable way 
describe setheo adapted order integrated nora 
discuss important issues handling inductive problems sorts equality selection axioms parameter settings 

inductive problems recursive specifications recursively defined data structures lists proof tasks solved induction 
setheo handle induction severe time constraints don allow inductive theorem prover 
approximate induction splitting problem cases 
example query candidate signature list corresponding proof task form list delta obtain cases item delta item list delta 
rewriting formula accordingly get independent order proof tasks processed setheo 
approach implemented efficiently 
solve inductive problem 

equality proof tasks heavily rely equations 
due vdm sl specification style construction proof tasks 
equations just equate formal parameters query library module carry information modules behavior 
efficient means handling equalities provided 
currently provide variants nave approach adding corresponding axioms equality reflexivity symmetry transitivity substitution axioms compilation approach setheo 
symmetry transitivity substitution rules compiled terms formula axioms need added 
transformation optimised variant brand ste modification usually increases size formula cases length proof size search space substantially smaller 
sufficient cases generate case specifications valid non empty lists 
specifications case trivial proof task contribute filtering 

sorts proof tasks sorted 
sorts imposed vdm sl specifications modules structured hierarchical way 
sorts static limited overloading function symbols 
approach compile sort information terms formula 
determination sort term checking sorts terms compatible handled usual unification 
need modify setheo loss efficiency minimal 
current prototype uses tool developed protein :10.1.1.49.8833

selection axioms proof task contain theorem hypotheses features data type list nat set axioms 
automated theorem provers extremely sensitive number structure axioms added formula 
adding single unnecessary axiom increase run time prover magnitudes decreasing recall unacceptable way 
general selecting optimal subset axioms hard problem solved satisfactory way 
strong time constraints furthermore won allow time consuming selection techniques 
prototype simple strategy 
select theories data types list nat boolean occurring proof task 
theories select clauses function symbols common proof task 
leave particular clauses axioms known increase search space substantially long clauses non horn clauses 
approach complete aim solve obvious simple proof tasks don axioms complex proof short limits run time 

control started theorem prover seconds run time search proof 
requires parameters control influence search way iterative deepening subgoal reordering set optimal way proof task 
global setting exist application domain 
order obtain optimal efficiency combined short answer times parallel competition parameters 
basic ideas developed adapted easily available processors network workstations copy setheo started process entire proof task 
processor different setting parameters 
process finds proof wins aborts processes 

experimental results 
experimental data base experiments carried database list specifications modified type list list order please simple signature matching filter 
approximately specifications describe actual list processing functions tail rotate rest simulates queries 
included underdetermined specifications result arbitrary front segment argument list specifications don refer arguments result empty 
simplicity formulated specifications postconditions vdm sl built sequences 
order simulate realistic number queries cross matched specification entire library partial compatibility match relation 
yielded total proof tasks valid 

evaluation filters information retrieval methods evaluated criteria precision recall 
calculated set rel relevant components satisfy match relation wrt 
query ret set retrieved components pass filter 
precision defined relative number hits response recall measures system relative ability retrieve relevant components ideally numbers system retrieves matching components practice antagonistic higher precision usually paid lower recall 
need metrics evaluate filtering effect 
define fallout entire library fraction components pass filter reduction just relative number refuted components 
define relative defect ratio dr delta rel model recall oe precision oe precision increase fallout reduction defect ratio dr table 
results model checking relative number rejected matching components relation precision filter input 
relative defect ratio greater indicates filter ability reject irrelevant components worse purely random choice 

rejecting tasks model generation rejection filter mace currently different models elements data type case list item 
due large number variables proof tasks generally confined small models 
experiments mace revealed restrictions serious 
shown table model checking filter run time limit seconds able recover relevant components regardless particular model 
large standard deviation indicates filter behavior far uniform may perform poor queries 
unfortunately filter coarse 
model increases precision answer compared original precision library significantly lets non matches pass 
values fallout indicate results average contain original non matching components 
similarly reduction approx 
lower expectations 
relative defect ratios show model checking model twice blind guessing 

setheo confirmation filter experiments setheo parallel competition processes exploring different ways handling equality 
due technical reasons restrict number modules library 
resulted total proof tasks matches 
set experiments tried retrieve identical modules library 
resulting proof tasks relatively simple induction axioms needed prove 
expected setheo show time limit seconds cpu time sun ultra sparc 
mean runtime proof tasks needed seconds 
tried retrieve matching non identical components 
experimental basis contains cases 
proof tasks tried induction 
setheo able solve proof tasks standard set axioms 
rate recall increased drastically approximation induction 
set axioms total proof tasks solved 
due increased size formulas esp step case overflow errors occurred 
case splitting able retrieve matches case splitting 
due different structure search space tasks shown case splitting making simple mode interesting parallel competition 
order obtain recall setheo confirmation filter combine data sets experiments 
total possible matches setheo retrieve identical modules non identical case splitting case splitting modules 
yields recall 
standard deviation relatively high model checking experiments revealing quite different retrieval results various queries 
setheo proof procedure sound solved proof tasks correspond matches precision 

related early publications deduction scr mainly concerned general conceptual issues ignored usability scaling problems 
discuss related 
wing investigated specification matching slightly general framework main application area software reuse :10.1.1.29.5124
larch ml specification language component description associated interactive larch prover retrieval 
promises severe scaling problems experience small fraction tasks provable interaction 
unfortunately contain larger experimental evaluation 
mili describe system specifications binary relations legal input output pairs 
define subsumption relation pairs retrieval relying otter calculate subsumption 
system prototypical stage relevant statistical evaluation 
examples heavily auxiliary predicates axiomatized rely arbitrary choice predicate names represent domain knowledge 
cheng uses subsumption test unfortunately shares problematic confidence choice predicate names 
statistical evaluation 
scaling problems addressed differently 
inscape inquire system limits specification language retrieval efficient 
similarly uses gui foster uniform specification style turn allows appropriate prover 
additional speed achieved automatically compiling axioms decision theories 
techniques successfully applied assemble fortran programs scientific component library solar system kinematics 
penix alexander semantic features user defined predicates follow components specifications classify components perform case reasoning classification identify promising candidates 
classification process uses forward reasoning atp 
authors give evidence successful approach related model checking techniques infinite domains rarer 
jackson investigates model checking software specifications 
goal prove conjectures disprove 
requires sound approximations forced restrict logic severely negations exact abstractions 
soon approximate abstractions allowed approach unsound 
wing abstractions don discuss correctness aspects related 

nora deduction software component retrieval tool 
goal show tool theoretically possible practical state art theorem provers 
designed user configurable pipeline different filters 
rejection filters charge reducing number non matching query component pairs soon possible 
studied approach uses model generation techniques purpose 
experiments mace showed approach sound complete returns reasonable results 
final stage filter pipeline ways confirmation filter ensures selected components really match 
automated theorem prover setheo 
short time limit seconds recall obtained 
evaluated approach reasonable large number experiments 
results obtained far encouraging 
currently preparing experiments library commercial date time handling functions example stock trading software 
done cooperation german dg bank 
improvements nora really industry 
due hard time constraints results wait reduction proof tasks complexity number central importance 
powerful rejection filters ensure proof tasks remain processed automated theorem prover 
current model checking filter rejects valid matches due necessary approximate abstractions 
trying model exact predicate abstractions belnap logic extends valued lpf consistently 
translation fol reflects explicit falsehood conditions belnap logic yields sound rejection filter 
include experiments specialized decision procedures different theories disproving techniques 
additionally knowledge filters similar heuristics help reduce number tasks handled confirmation filter 
filters configurable allow inspection behavior filter pipeline stage retrieval 
current high performance automated theorem provers certainly usable confirmation filters 
necessary adapt kinds proof tasks 
particular requirement full automatization strong time limits obeyed carefully 
experiments showed parallel competition variants case splitting set axioms handling equality essential obtain short answer times 
important issues handling inductive proofs selection appropriate axioms 
powerful heuristics additional information placed data base components tactics lemmas induction schemes helpful 
reduction search space achieved axiom compilation techniques similar meta 
integration decision procedures setheo open research topic 
application automated theorem proving carries unique feature soundness completeness absolutely vital unsound incomplete methods reduce precision recall retrieval tool 
allows interesting promising deduction techniques approximating proofs filter chains iteration explored help automate software engineering little 
gregor snelting originally proposed filter chain 
christian lindig helped gui 
anonymous referees provided valuable comments 
ralf dg bank frankfurt contributed date experiments 
baumgartner furbach :10.1.1.49.8833
protein prover theory extension interface 
pp 

belnap 
useful valued logic 
modern uses multiple valued logic pp 

reidel netherlands 
brand 
proving theorems modification method 
siam journal computing 
bundy editor 
proc 
th cade vol 
lnai 
springer 
clarke grumberg long 
model checking abstraction 
acm toplas 
cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
proc 
th popl pp 

acm press 

vdm sl guide 
pitman london 
fischer 
systematic approach type software component retrieval 
phd thesis tu braunschweig 
preparation 
fischer snelting 
reuse contract 
proc 
esec fse workshop foundations componentbased software 
jackson 
model checking infinite specifications 
proc 
nd fme vol 
lncs pp 

springer 

cheng 
formal approach general components 
proc 
th pp 

ieee computer society press 
jones 
typed logic partial functions reconstructed classically 
acta informatica 
kaiser editor 
proc 
rd fse washington dc 
acm press 
katz richter 
paris system reusing partially interpreted schemas 
proc 
th icse pp 

ieee computer society press 
krueger 
software reuse 
acm computing surveys 
letz schumann bibel 
setheo high performance theorem prover 
journal automated reasoning 
lowry underwood 
automatic programming scientific subroutine libraries 
proc 
th intl 
symp 
methodologies intelligent systems vol 
lnai pp 

springer 
lowry van 
meta synthesis efficient domain specific program synthesis systems 
proc 
th pp 

ieee computer society press 
maarek smadja 
full text indexing lexical relations application software libraries 
proc 
th annual intl 
acm sigir conf 
research development information retrieval pp 


knowledge deduction software retrieval tool 
proc 
th intl 
symp 
artificial intelligence pp 

mccune 
davis putnam program application finite order model search quasigroup existence problems 
technical report argonne national laboratory argonne il usa 

logic specification extending advanced formal specification 
computer science research practice 
chapman hall 
mili mili 
storing retrieving software components refinement system 
editor proc 
th icse pp 

ieee computer society press 
moser letz steinbach schumann mayr 
model elimination provers setheo setheo 
journal automated reasoning 
penix alexander 
automated component adaptation 
proc 
th intl 
conf 
software engineering knowledge engineering 
penix alexander 
classification retrieval reusable components semantic features 
proc 
th pp 

ieee computer society press 
perry 
inquire predicate reuse 
proc 
th pp 

ieee computer society press 
rollins wing 
specifications search keys software libraries 
proc 
th intl 
conf 
symp 
logic programming pp 

mit press 
salton mcgill 
modern information retrieval 
mcgraw hill new york 
schumann 
simple competitive parallel theorem provers setheo 
parallel processing artificial intelligence machine intelligence pattern recognition 
elsevier 
slaney 
finder finite domain enumerator 
pp 

wing 
model checking software systems case study 
pp 


software reuse current status trends 
jss sept 
wing :10.1.1.29.5124
specification matching software components 
pp 

