submitted version thursday april document submitted oopsla available www iam unibe ch demeyer deme finding refactorings change metrics serge demeyer ducasse oscar nierstrasz software composition group university berne ch berne demeyer ducasse oscar iam unibe ch www iam unibe ch scg reverse engineering process uncovering design design rationale functioning software system 
reverse engineering integral part successful software system changing requirements lead implementations drift original design 
contrast traditional reverse engineering techniques analyse single snapshot system focus reverse engineering effort determining implementation changed 
changes object oriented software phrased terms refactorings propose set heuristics detecting refactorings applying lightweight objectoriented metrics successive versions software system 
validate approach separate case studies mature object oriented software systems multiple versions available 
case studies suggest heuristics support reverse engineering process focusing attention relevant parts software system 
keywords reverse engineering metrics refactoring software evolution object oriented frameworks 
reverse engineering ongoing process development successful software system evolves response changing requirements 
system developers may benefit lot reverse engineering techniques keep track design drifts earlier versions 
integrated development environments called round trip engineering tools help keep design views consistent actual software 
tools applicable small software systems ii require initial design model matched source code iii classes isolation interaction classes 
consequently tools really contribute understanding software system evolves 
claim really understand evolving software changes critical factor 
certainly object oriented development processes emphasis iterative development see gold jaco change essential ingredient system design 
consequently reverse engineering technique exploit information available concerning changes piece code 
change reverse engineering efficient focus reverse engineering efforts changing pieces code ii need initial design model changes dictate appears model iii give insight finding refactorings change metrics class collaborations redistribution functionality reveals classes interact 
object oriented development changes accomplished means called refactorings 
refactoring operations provided refactoring browser robe class hierarchy shifting responsibilities classes redistributing instance variables methods 
reverse engineer object oriented software identify refactorings applied help understanding certain extent system evolved 
clearly discovering refactorings textual comparisons versions source code imaginable extremely tedious nature refactorings revealed manual examination 
measure available versions software system compare results order identify presence nature refactorings 
algorithmic approach finding refactorings adopt set heuristics 
examine heuristics identifying refactorings investigate knowledge helps program understanding 
heuristic defined combination change metrics reveal refactorings certain kind 
heuristic may occasionally refactorings misclassify mistakes typically corrected heuristics 
experimentally validate applicability heuristics applying case studies 
case study representative sense successful software system undergone successive refactorings address changing requirements 
results indicate approach successfully applied discover parts system changed changed extent designers chose change 
structured empirical study 
starts formulating research hypothesis guide selection metrics case studies section continues specification heuristics section proceeds discussion experimental results section 
includes overview empirical data performance heuristics anecdotal evidence heuristics support reverse engineering 
overview plans section compares related refactorings metrics objectoriented reverse engineering techniques section summarise contribution section 

experimental set section introduces experimental validation heuristics identifying refactorings 
starts describing research assumptions lead selection metrics gqm paradigm follows brief description tools collect necessary measurements ends overview case studies 
finding refactorings change metrics 
goal question metric paradigm decision metrics apply goal question metric paradigm 
goal question underlying experiment defined table 
goal identify design object oriented software system evolving deduce corresponding design drifts 
question comparing version software system characteristics symptoms refactorings table goal question experiment 
regarding question particularly interested finding symptoms categories refactorings correspond generic design evolutions occur frequently object oriented software systems 

creation template methods 
category refactorings split methods smaller chunks separate common behaviour specialised parts subclasses override 
design intentions refactorings may improvement reusability removal duplicated functionality 

incorporation object composition relationships 
kind refactorings move functionality newly created sibling classes 
usually applied reduce coupling mark migration black box frameworks 

optimisation class hierarchies 
category refactorings insert remove classes class hierarchy redistribute functionality accordingly 
refactorings applied increase cohesion simplify interfaces remove duplicated functionality 
question find symptoms refactorings comparing version software system subsequent version leads research assumptions listed table 
research assumption corresponds characteristic may serve symptom refactoring 
method size decrease method size symptom split method 
class size change class size symptom redistribution instance variables methods hierarchy optimisation class hierarchy shift functionality sibling classes incorporate object composition 
inheritance change inheritance associations class symptom optimisation class hierarchy 
table overview research assumptions underlying experiment 
criteria taken account selecting actual metrics research assumptions 
metrics derivable object oriented source code source code main source information disposal 
second metrics cheap collect different versions software system quite lot data analyse 
finding refactorings change metrics actual metrics selected experiment listed table defined chidamber kemerer lorenz kidd lore 
table includes abbreviation definition short description metric 
abbreviation description method size computed method mthd msg lore number message sends method body 
lore metric abbreviated nom renamed msg avoid name collision nom metric number methods 
mthd nos lore number statements method body 
mthd loc lore lines code method body 
class size computed class nom number methods class 
weighted method count wmc metric weight method 
niv ncv lore number instance variables number class variables defined class 
inheritance computed class dit lore hierarchy nesting level lore depth inheritance tree 
count number classes superclass chain class 
case multiple inheritance count number classes longest chain 
noc number immediate children class 
nmi lore number inherited methods defined superclass inherited unmodified 
lore number overridden methods defined superclass redefined subclass 
distinguish plain overriding overriding methods extensions super methods 
table overview metrics selected 

data collection case studies gather necessary measurements case studies developed metrics tool named moose metrics 
moose re engineering environment developed part project project goal produce set reengineering techniques tools support development object oriented frameworks 
metrics examined important part framework reengineering explains motivation 
moose metrics tool extracts classes methods check www iam unibe ch learn project 
finding refactorings change metrics attributes visualworks smalltalk source code computes necessary measurements generates tab separated ascii files subsequently loaded microsoft access microsoft excel post processing 
validate applicability heuristics experiment involving case studies visualworks framework hotdraw framework beck john refactoring browser robe 
case studies selected satisfy criteria 
accessible 
source code different versions frameworks publicly accessible researchers reproduce falsify results 
representative 
case studies successful software system undergone successive refactorings address changing requirements 
independent 
frameworks developed independently implies experiment influenced development process 
documented 
features changed different versions documented making possible validate experimental findings 
case studies implemented smalltalk 
case studies represents different kind software system 
visualworks 
industrial system experiment 
visualworks framework visual composition user interfaces independent look feel deployment platform 
typical black box framework sense programmers framework supposed customise behaviour visually configuring objects 
framework quite large customer base framework designers consider backward compatibility issues releasing new versions 
versions measured experiment versions released time span 
hotdraw 
framework building dimensional graphical editors 
hotdraw better known framework experiments pattern style documentation 
typical white box framework users framework supposed subclass framework classes order reuse hotdraw design 
hotdraw framework implemented visualworks smalltalk 
numbered versions corresponding visualworks release 
refactoring browser 
case study software system framework 
interesting example iterative development process 
refactoring browser released quite small increments month 
measuring single increment compared stable version latest version available time experiment 
version corresponds release april second version release march 
table provides overview changes case studies involved experiment 
leftmost column lists different transitions versions disposal columns give impression size impact changes 
see visualworks largest software system starting classes methods version classes methods finding refactorings change metrics version 
see transition visualworks entailed changes classes methods removed classes methods added visualworks hotdraw second third 
important note compare versions names detect renaming count remove add 
due large number removals additions assumed large number changes hotdraw corresponds renaming classes checking source code confirmed assumption 
small decrease number methods hotdraw large decrease number classes methods hotdraw 
confirms reported documentation hotdraw system design expanded little moving drastically transition 
classes methods ini add ret ini add ret visualworks hotdraw refactoring browser table transitions versions case studies 
ini initial version removed add added ret retained name final version 
heuristics finding refactorings research assumptions table list metrics table position specify heuristics find refactorings 
subsections define heuristic combination change metrics identify category refactorings name heuristic category 
heuristic specify recipe explains assess result correspond refactoring description false negatives false positives 
false positive heuristic case heuristic answered erroneously reported presence refactoring 
finding refactorings change metrics conversely false negative case heuristic answered failed identify refactoring 
note expression compute change metric component mean subtract metric measurement component version metric measurement component subsequent version 
occurs denote shorthand delta 
example compute change class view corresponds function delta view view version view version 
split superclass merge superclass heuristic searches refactorings optimise class hierarchy splitting functionality class newly created superclass merge superclass subclasses 
look creation removal superclass number pull ups push downs methods attributes 
recipe summarised 
inspecting changes inheritance hierarchy change identify classes superclass added removed 

combine information changes number methods nom number instance class variables niv ncv see functionality pulled pushed 

include number inherited overridden methods nmi analysis see effect added removed class protocol subclass 

browse source code corresponding classes check refactoring occurred 
finding refactorings change metrics split delta delta nom delta niv delta ncv delta nmi delta effect creating merge delta delta nom delta niv delta ncv delta nmi delta effect removing heuristic split superclass merge superclass false negatives 
heuristic may fail detect split merge change countered inverse change higher hierarchy pull push countered equal addition removal new functionality 
cases show false positives move class section 
false positives 
heuristic may discover situations correspond split merge part class functionality rearranged superimposed unrelated addition removal superclass 
worthwhile analyse situation rearrangement class functionality may denote false negative move class section 
change superclass may represent interesting optimisation class hierarchy anyway reasons include nmi metrics heuristic 

split subclass merge subclass heuristic searches refactorings optimise class hierarchy 
takes viewpoint superclass changes number children main symptom provides perspective subclass triggering changes length inheritance chain 
refactorings looking split functionality class newly created subclass merge subclass subclasses 
look creation removal subclass number pull ups push downs methods attributes 
recipe summarised 
figures conventions 
components different versions distinguished quote character necessarily imply change 
components change refactoring coloured light grey new removed components coloured dark grey 
finding refactorings change metrics 
inspecting changes inheritance hierarchy change noc identify classes subclass added removed 

combine information changes number methods nom number instance class variables niv ncv see functionality pulled pushed 

browse source code corresponding classes check refactoring sequences occurred 
split delta noc delta nom delta niv delta ncv merge delta noc delta nom delta niv delta ncv heuristic split subclass merge subclass 
false negatives 
heuristic may fail detect split merge refactoring involve change noc pull push countered equal addition removal new functionality 
cases show false positives move class section 
false positives 
heuristic may discover classes split merged 
class functionality added moved removed unrelated addition removal subclasses 
false positive correspond false negative move class section 
false positive may denote rearrangement class hierarchy worthwhile analyse represents class hierarchy refactoring 

move class superclass subclass sibling class heuristic searches refactorings move functionality class 
class may subclass superclass sibling class look removal methods instance variables class variables browsing identify sibling class participate inheritance relationship target class usually common ancestor 
note languages smalltalk clos classes common ancestor named object 
oo implementation languages frameworks provide common ancestor classes framework 
finding refactorings change metrics functionality moved 
note split superclass section split subclass section special cases general move functionality 
recipe summarised 
inspecting decreases number instance variables niv class variables ncv methods class nom identify classes functionality removed 

combine noc measurements rule cases correspond splitting classes see sections 

browse source check method removed methods invoke see functionality moved assess functionality removed 

similarly attribute removed check methods access see attribute moved assess removed 
move delta nom delta niv delta ncv delta delta noc check invocations removed methods 
check accesses removed attributes heuristic move superclass subclass sibling class 
false negatives 
heuristic may fail detect move countered equal addition removal functionality 
case move accompanied addition removal superclass immediate subclass detected anyway false positive split superclass merge superclass section split subclass merge subclass section 
false positives 
heuristic may discover cases correspond move functionality detects symptoms refactorings 
functionality may removed moved functionality may replaced code requires methods attributes refactoring case 
especially case attributes factored sibling classes rarely ordinary move bit movement bit replacement functionality 

split method factor common functionality heuristic searches refactorings split methods methods defined class 
look decreases method size try identify code moved 
recipe summarised 
finding refactorings change metrics 
looking decreases number message sends mthd msg method identify methods functionality removed 
include threshold heuristic large amounts methods returned heuristic requires fine tune amount functionality decrease interested 
experiment applied threshold users free adapt number needs 

combination decreases number statements mthd nos lines code mthd loc provides insight kind removals took place 

sort resulting list class name identify methods defined class presenting similar decrease symptom common functionality factored 

browsing source code necessary see functionality moved 
removed message send checked new methods defined class perform message send 





split delta mthd msg check changes method size measurements delta mthd nos delta mthd loc check decreases methods defined class delta mthd msg heuristic split method factor common functionality 
false negatives 
heuristic may fail detect split countered equal addition new functionality decrease functionality smaller threshold value 
false positives 
heuristic may discover methods functionality simply removed split method 
functionality split may moved class difficult recover mere browsing 
case worthwhile analyse situation correspond interesting refactorings 

results section reports results obtained applying heuristics defined section case studies specified section 
start summary empirical data collected experiment analysis advantages drawbacks heuristics anecdotal evidence interesting design shifts identified heuristics 
finding refactorings change metrics 
advantages disadvantages table provides summary empirical data gathered case studies 
different transitions leftmost column heuristics show focus 
focus percentage 
equal focus see item divided total number classes methods retained columns ret table 
number allows compare focus heuristic independent case study 
focus 
number classes methods returned heuristic 
heuristics supposed complemented manual browsing number small 
fp false positives 
number false positives refactorings misclassified assessed manual browsing source code 
lower number noise contained results reliable heuristic 
interesting 
number misclassified refactorings corresponded category refactorings 
number number false positives sense reverse engineering afford misclassifications refactorings 
ideally number equal number false positives 
split merge superclass split merge subclass focus focus fp focus focus fp visualworks hotdraw ref 

note count number false negatives list refactorings applied 
documentation systems check covered documented design changes 
finding refactorings change metrics move class split method focus focus fp focus focus fp visualworks hotdraw ref 

table overview results maximum focus focus values marked double underlining empirical data experience case studies gave insight advantages disadvantages heuristics identifying design shifts 
advantages 
focus 
heuristics focus small part software system 
amount classes methods returned small allow manual examination 
instance split method heuristic selects methods threshold 
number classes selected lies 

reliable 
heuristics quite identifying refactorings occurred process 
number false positives low considerable amount false positives interesting anyway 
largely due partial overlap heuristics false negatives heuristic covered false positives 
due lack empirical data false negatives early definite statements reliability 
experience case studies showed identified symptoms documented design shifts undocumented ones 
safely assert heuristics may missed refactorings usually identified important design changes 

road map 
focus absolute number percentage varies considerably heuristics 
may negative effect experienced helps reverse engineering process guidance determining places browse 
applying heuristics manually browsing results best focus order rely better focus prior heuristic better assess items larger lists 
finding refactorings change metrics 
class interaction 
heuristics select places system design changing chance focus parts design expanding consolidating key factor understanding design adapted 
heuristics filter clusters classes methods highlighting way interact 
helps understand design precisely interaction various methods different classes determines reuse object oriented design 

unbiased 
heuristics require human knowledge select interesting pieces code 
system dictates worthwhile investigate 
consequently heuristics may prior reverse engineering techniques require reverse engineer formulate model expected reflexion models round trip engineering tools 
disadvantages 
vulnerable renaming 
measuring changes piece code requires capable identifying piece code different version 
obvious approach experiment names anchors pieces code 
anchoring rename operations disappear show removals additions 
phenomenon partly explains large focus large number false positives transition visualworks 
reverse engineering technique relies source code conscious names usually bear lot domain semantics 
heuristics exception rule 

imprecise changes 
focus reliability depend lot amount changes 
changes applied piece code picture gets blurred technique imprecise 
imprecision respect identification refactorings heuristics identify important design changes 
difficult deduce intentions changes 

requires experience 
interesting pieces code identified reverse engineer check versions source code deduce refactorings applied 
requires experiences refactorings implementation language sense reverse engineer aware refactorings interact coding idioms particular implementation language 

considerable resources 
metrics underlying heuristics selected require cheap parsing technology 
instance able collect measurements smalltalk system straightforward meta object protocol rudimentary text processing count number lines 
similar technology collect measurements java systems incomplete parsers collect class definitions method signatures 
reverse engineering heuristics requires quite lot resources full access different versions source code plus metrics tool able measure changes feed measurements tool performing additional computations plus browsing tool able navigate method invocation corresponding method definition 
amount resources comparable reverse engineering techniques 
instance round finding refactorings change metrics trip engineering tools require full parsing program visualisation tools require complex layout algorithms query languages require logic databases 
summarise conclude heuristics reliably cost effectively identify refactorings applied going version 
feasible deduce implementation drifts original design 
heuristics disadvantages inherent reverse engineering techniques 
consequently claim proposed heuristics form basis reliable reverse engineering technique experts iterative projects small increments 

anecdotal evidence empirical data section shows heuristics effective identifying refactorings applied going version imply deduce implementation drifted original design 
scope analyse intentions hundreds refactorings identified experiment 
section selection describing interesting refactorings including interpretation design intention 
reduce code duplication split superclass 
new operations added refactoring browser refactorings add remove parameter method 
looking implementation release included flat hierarchy root class refactoring list subclasses refactoring operation 
adding subclasses manipulating parameters developers noticed introduced duplicated behaviour refactoring consequently inserted new superclass subclasses refactorings concerning methods 
inspecting methods redistributed class new class easily infer obligations new subclasses 
inferring bridge protocol merge superclass 
visualworks extensive bridge pattern implement platform independent look feel 
frameworks superclasses widget concrete subclasses different ui platforms supported framework motif macintosh windows 
transition widget hierarchy removing widget classes 
diminish new look feel included concrete subclasses implemented 
way existing methods redistributed class hierarchy gave insight protocol classes bridge pattern 
introducing layers move sibling 
refactoring browser provides multiple windows depending selected view software system window consisting various panes 
class implements aggregation panes panes 
release complicated interaction classes depending various state changes 
release simplified way finding refactorings change metrics component ceases invoke methods directly aggregation 
way designers able introduce layer system design 

open questions empirical results section obvious question generalise 
especially case studies successful smalltalk systems interesting ask heuristics behave implementation languages ii behave systems trouble 
metrics measure changes different versions ones listed table relevant question iii results depend particular metrics applied experiment 
far implementation languages concerned quite confident heuristics prove valuable 
confirm feeling plan experiments java systems obtainable publicly available code industrial partners project 
far troublesome systems concerns expected behaviour depends largely implied trouble 
thing suspect change metrics may identify places design keeps changing improving 
plan experiments verify assumption 
far metrics concerns answer depends kind metrics 
method size class size metrics think best stick simple metrics reported code size metrics correlate 
inheritance metrics certain simple metrics sufficient purpose possible metrics better discriminators distinguishing interesting refactorings 
category metrics deliberately include experiment 
coupling cohesion metrics typically expensive collect top strong disagreement literature constitutes object oriented coupling cohesion metrics 
assume may serve indicators refactorings introduce object composition consequently mark transition white box black box reuse 
plan define set cheap coupling cohesion metrics see offer help 
continuing validation heuristics software systems experimenting metrics particular coupling cohesion want integrate heuristics reverse engineering techniques 
necessary agree viewpoint reverse engineer detective solves mystery scarce clues available 
heuristics proposed exception rule isolation complement reverse engineering techniques 
consequently better integration tools smalltalk programming environment 
path explore better integration finding refactorings change metrics refactoring browser maintains log file refactorings applied 
second list integration smalltalk configuration management tool envy exploit version management features provided 
plan integration duploc codecrawler visualisation tools development lab 
duploc provides visual representation duplicated source code suited detecting portions source code changed 
codecrawler predefined metrics combinations simple graph layouts deme 
longer run want investigate tool integration object oriented languages smalltalk information exchange model reengineering tools step direction 

related refactoring technique object oriented constructs investigated quite years 
ph opdyke resulted number papers describing incremental redesign performed humans supported refactoring tools john 
line resulted refactoring browser tool represents state art field robe 
contrast moore report tools optimise class hierarchies human intervention casa moor 
schulz report refactoring introduce design patterns systems summarises experience refactorings industrial projects 
refactoring literature find mention identifying refactorings applied 
quality metrics problem detection technique sense closely related 
overview object oriented metrics including quality metrics 
detect problems quality metrics combines metrics thresholds particular measurement exceeds certain threshold value corresponding item needs treatment 
lore mention thresholds identify design anomalies mari kohl report practical application thereof 
uses metrics problem detection tools exist 
instance metrics detecting patterns duplicated code 
metrics problem detection tools share idea metrics focus interest large amounts data differ elements interested design anomalies vs refactorings 
reverse reengineering object oriented systems gained considerable interest object oriented paradigm reached industrial maturity casa 
especially advent uml lots case tool vendors working socalled round trip engineering way iterate modelling generating code changing code map code back original model eri 
note reverse reengineering studied intensively branches software engineering community arno 
restricting object oriented literature see reverse engineering research concentrates combinations program visualisation run time analysis logic query languages finding refactorings change metrics design pattern extraction 
instance de pauw report design extraction visual representations run time information pauw 
lange nakamura describe prolog fact base containing static dynamic information linked visual representations help capture design framework lang 
brown shows possible detect structural patterns smalltalk source code brow 
reports tool support patterns reverse forward engineering flor 
wuyts advocates logic meta language express extract structural relationships object oriented systems 
de hondt reports advanced browsing technology way incrementally capture framework design form reuse contracts 
find exploitation iterative nature object oriented development reverse engineering purposes 

approach understand object oriented systems evolved discovering refactoring operations applied version software 
main features approach concentrates relevant parts refactorings point places design expanding consolidating 
provides unbiased view system reverse engineer formulate models expected software 
gives insight way classes interact refactorings reveal functionality redistributed classes 
features extremely useful reverse engineering process reveals implementation drifted intended design 
demonstrated case studies technique applicable practice effectively focus attention interesting aspects software system 
results preliminary sense case studies means statistically significant 
clear approach warrants study experimentation 
funded swiss government project 
nfs 
european union esprit programme project 
want people reviewed earlier drafts anonymous oopsla ecoop reviewers joachim radu simon moser robb franz encouraged kent beck don roberts john brant patrick steyaert finding refactorings change metrics provided fruitful partnership software composition group participants project programming technology lab brussels 

arno robert arnold software reengineering ieee computer society press los alamitos ca 
beck kent beck ralph johnson patterns generate architectures proceedings ecoop tokoro pareschi ed lncs springer verlag bologna italy july pp 

brow kyle brown design reverse engineering automated design pattern detection smalltalk ph thesis 
technical report 
tr north carolina state university 
www com htm 
casa eduardo incremental class reorganization approach proceedings ecoop lehrmann madsen ed lncs springer verlag utrecht netherlands june july pp 

casa taivalsaari object oriented software evolution reengineering special issue journal theory practice object systems vol 
pp 

chidamber chris kemerer metrics suite object oriented design ieee transactions software engineering vol 
june pp 

deme serge demeyer ducasse michele lanza hybrid reverse engineering platform combining metrics program visualization working february 
ducasse matthias rieger serge demeyer language independent approach detecting duplicated code working university bern march 
eri hans erik eriksson magnus uml toolkit john wiley sons 
norman fenton lawrence pfleeger software metrics rigorous practical approach second edition international thomson computer press london uk 
flor gert marco pieter van tool support object oriented patterns proceedings ecoop mehmet aksit satoshi matsuoka ed lncs springer verlag finland june pp 

martin fowler refactoring improving design existing programs addisonwesley appear 
gold adele goldberg kenneth rubin succeeding objects decision frameworks project management addison wesley reading mass 
jim technical overview visualworks smalltalk report january pp 

brian henderson sellers object oriented metrics complexity prenticehall 
koen de hondt novel approach architectural recovery evolving objectoriented systems vrije universiteit brussel departement computer science pleinlaan brussels belgium december ph thesis available prog world wide web site brussels vub ac 
tim howard smalltalk developer guide visualworks sigs books 
jaco ivar jacobson martin griss patrik jonsson software reuse addison wesley acm press 
finding refactorings change metrics john ralph johnson documenting frameworks patterns proceedings oopsla acm sigplan notices vol 
oct pp 

john ralph johnson william opdyke refactoring aggregation object technologies advanced software international symposium lecture notes computer science vol 
springer verlag nov pp 

kohl gerd kohler heinrich rust frank simon assessment large object oriented software systems metrics process object oriented technology ecoop workshop reader serge demeyer jan bosch ed lncs springer verlag pp 

kostas kontogiannis evaluation experiments detection programming patterns software metrics proceedings fourth working conference reverse engineering ira baxter alex quilici chris verhoef ed ieee computer society pp 

merlo assessing benefits incorporating function clone detection development process proceedings icsm springer verlag 
lang danny lange nakamura interactive visualization design patterns help framework understanding proceedings oopsla acm press pp 

lore mark lorenz jeff kidd object oriented software metrics practical approach prentice hall 
mari radu object oriented metrics automatic design flaws large scale systems object oriented technology ecoop workshop reader serge demeyer jan bosch ed lncs springer verlag pp 

moor ivan moore automatic inheritance hierarchy restructuring method refactoring proceedings oopsla conference acm press pp 

gail murphy david notkin reengineering reflexion models case study ieee computer vol 
pp 

william opdyke refactoring object oriented frameworks ph thesis university illinois 
william opdyke ralph johnson creating superclasses refactoring proceedings acm conference computer science acm press pp 

pauw wim de pauw richard helm doug john vlissides visualizing behavior object oriented systems proceedings oopsla acm sigplan notices vol 
oct pp 

working objects software engineering method manning publications 
matthias rieger ducasse visual detection duplicated code objectoriented technology ecoop workshop reader serge demeyer jan bosch ed lncs springer verlag july pp 

robe don roberts john brant ralph johnson refactoring tool smalltalk journal theory practice object systems vol 
pp 

benedikt schulz thomas berthold mohr walter zimmer computer aided design patterns object oriented systems proceedings tools conference asia ieee computer society press 
sander tichelaar serge demeyer exchange model reengineering tools object oriented technology ecoop workshop reader serge demeyer jan bosch ed lncs springer verlag july 
finding refactorings change metrics richard waters elliot chikofsky reverse engineering progress dimensions special issue communications acm vol 
may pp 

linda wills philip newcomb reverse engineering special issue automated software engineering vol 
june pp 

linda wills james cross trends open issues reverse engineering automated software engineering vol 
june pp 

wuyts class management logical queries application reflective user interface builder proceedings tools conference usa ieee computer society press 
