architectural overview alpha real time distributed kernel raymond clark douglas jensen franklin reynolds concurrent computer digital equipment open software foundation com jensen helix dec com fdr osf org alpha non proprietary experimental operating system kernel extends realtime domain encompass distributed applications telecommunications factory automation defense 
distributed real time systems inherently asynchronous dynamic non deterministic mission critical increasing complexity pace systems precludes historical reliance solely human operators assuring system dependability uncertainty 
traditional real time os technology attempting assert impose determinism just ends means centralized low level sampled data monitoring control insufficiency hardware resources 
conventional distributed os technology primarily party client server hierarchies explicit resource sharing networks autonomous users 
technological paradigms special cases combined scaled cost effectively accommodate distributed real time systems 
alpha new paradigm real time distributed computing founded best effort management resources directly computation completion time constraints expressed benefit functions multiparty peer structured trans node computations cooperative mission management 

alpha os kernel part multi institutional applied research advanced technology development project intended expand domain real time operating systems conventional centralized low level sampled data static subsystems encompass distributed dynamic mission level systems 
begins summary distinctive characteristics alpha application context integrating constituent lower level centralized real time subsystems system focused performance single real time mission managing system meet cases changing mission objectives current cases changing internal external circumstances 
real time distributed system integration mission management predominately asynchronous endeavor conflicts overloads inevitable activities hard soft real time constraints 
combined factors constitute requirement apparent distributed resource management dynamic nondeterministic real time 
help resolve conflict needing functional temporal dependability accommodating inherent uncertainty devised new paradigm real time computing founded concepts 
real time computations individual collective benefit positive negative system functions completion times maximizing accrued benefit basis highly cost effective real time acceptability criteria 
second especially mission level distributed real time computing systems may preferable os best defined user current resource application conditions os fail conditions violate re premises underlying structure resource management algorithms 
describes alpha kernel programming model distributed threads span physical nodes carrying real time attributes facilitate systemwide resource management 
transactional techniques employed maintain trans node application specific execution correctness data consistency 
intended system configurations alpha os system supports distributed applications interoperating extant centralized os applications unix low level sampled data subsystems 
architectural experiences date alpha context comparisons related kernel mach 
concludes brief overview project history status 

distributed computing implications real time resource management physically distributed computing arises computing system comprised multiplicity processing nodes ratio nodal computing performance communication performance primarily latency bandwidth significantly high far application concerned 
nodal performance ratio significance degree physical distribution usually different computations different levels system 
example system ratios relatively insignificant application highly significant middleware application framework dce insignificant nodal operating systems highly significant communication subsystem 
significance ratio may differ levels abstraction computations particular system level system level may object method invocations ratio relatively insignificant built layered remote procedure calls ratio significant turn built uniform location transparent message passing ratio quite insignificant 
significance nodal performance ratio computation degree physical distribution depends intrinsic characteristics computation essentially related autonomous node components programming model express computation 
application pull physically distributed computing real time contexts involuntary voluntary 
common involuntary motivation application assets telecommunications switching offices different processing stages manufacturing plant ships aircraft battle group inherently dispersed real time performance requirement permit latency requisite number communications needed assets centralized computing facility 
prominent voluntary reason physical dispersal survivability sense graceful degradation continued availability situation specific functionality 
example may cost effective distribute replicate partition telecommunications operation system air space defense command system attempt implement physically centralized 
powerful contemporary technology push physically distributed computing due rapid increases microprocessor performance decreases cost 
voluntary involuntary due current primary memory subsystems disproportionately slower processors making clustered multicomputers attractive regular topology ar ray style multicomputers exhibit physically distributed computing properties 
physical dispersal distributed real time computing systems loosely coupled communication employing links buses rings switching networks directly shared primary memory 
generally results variable communication latencies regardless high bandwidth long respect local primary memory access times 
nature locations availability applications physical assets limit system viability partitioned example network workstations internode communication paths frequently redundant physically separated reduce probability happening 
typical non real time distributed computing system fitting workstation model network nodes having autonomous user executing unrelated local applications statically hierarchical party client server inter relationships supported user explicit resource management primarily centralized node 
contrast real time distributed computer system mission oriented entire system dedicated accomplishing specific purpose cooperative execution applications distributed nodes 
incentive likelihood nodes dynamically peer structured multiparty inter relationships application os layers 
real time distributed computing applications usually supervisory level means primary functions generally distributed system wide resource management mission management 
function application specific portion distributed real time execution environment augments real time centralized distributed os compose constituent subsystems coherent cost effective program deploy intended mission 
function utilizes virtualized computing system conduct particular mission 
far probable non real time dedicated function system accounting mission approaches objectives highly dependent current external application environment internal system resource situation 
real time distributed computing applications subject great uncertainties mission system levels fog war extreme obvious example 
application characteristics combined laws physics involved distribution results predominant portion supervisory level computing system run time behavior unavoidably asynchronous dynamic non deterministic 
application results hard soft real time constraints possible optimally satisfied exactly know advance ones 
real time distributed computing applications systems usually mission critical meaning degree mission success strongly correlated extent system achieve maximal dependability regarding real time effectiveness survivability safety possible resources available general sense operational suitable uncommitted affordable 
dependability lower level subsystems may necessary mission critical functions digital avionics flight control keeping aircraft part uncertainty tolerated system mission levels communications weapons sufficient flying aircraft perform mission wasting resources creating risks 

logically distributed computing defined terms kinds degrees multilateral resource management 

non determinism includes stochastic activity subset petri nets non determinism distributed real time computing systems may usefully considered probability measure permit tractable resource management algorithms 
implies need best effort real time resource management accommodating dynamic non deterministic resource dependencies concurrency overloads complex partial bursty faults errors failures robust adaptable way undertake possible important results correct time value domains possible current mission resource conditions 
entails offering application user opportunities participate control requisite resource management negotiations compromises adjusting mission objectives expectations fit circumstances changing circumstances constraints resources alternative possible 
option best effort resource management possible choice firm priori assurances exact behavior limited number highly specific resource mission situations offered static highly predictable real time technology versus weaker assurances probable behavior wider range circumstances 
examples applications call naturally highly predictable best effort resource management come immediately mind decision obviously value judgement regarding risk cost management situation 
virtually real time reconciliation uncertainty dependability system mission levels historically depended solely talent expertise system human operators control rooms factories plants aircraft 
increasingly complexity pace systems missions number complexity distribution resources cause cognitive overload requires operators receive support respect computing system 
application software solely bear responsibility effectiveness resource management policy especially real time ones depends consistently applied resources lowest layer hardware software 
best effort policies place special demands os facilities 
role traditional real time computers os limited low level sampled data subsystems contention accommodating uncertainty ensuring dependability arise 
premise application system behavior highly predictable allowing extensive priori knowledge load communication timing exceptions dependencies conflicts 
standard real time theory practice attempt exploit information static techniques aspire provide guarantees application system behavior just ends achieved exact means achieved small number rigidly constrained unrealistic mission resource conditions anticipated accommodated advance 
classic real time static deterministic mindset methodology constitute simple special case usually adequate intended domain scale distributed realtime systems 
essential aspect research underlying alpha kernel improved understanding real time resource management 

instructive enlightening consider issue light conclusive demonstrations cognitive scientists ubiquitous human trait risks example tend probability blind near extremes judge annihilation risk differently mere reduction risk diminishes risk far greater degree 

analogous paradigm shifts nature larger complex systems physics newton view gravity force generalized einstein space time curvature biology higher animals complex larger conversely 

real time alpha classical hard soft real time dichotomy proven unnecessarily confusing limiting centralized context arose 
created benefit accrual model overcome limitations classical especially facilitate expansion real time computing distributed systems model generalizes jensen notion time value function resource scheduling high performance architectural support initially explored 
time value function best effort scheduling long research topic project subsequently studied os implementation alpha appeared mach 
regard computation real time prescribed completion time constraint representing urgency time criticality acceptability criteria 
os real time degree explicitly statically dynamically manages resources objective application consequently computations meeting time constraint acceptability criteria 
definition real time system physical time absolute relative part system logic analogous faults states fault tolerant system 
computing system may meet time constraint criteria explicitly managing resources endowed excess resources ms dos cray mp real fast real time fortune cases system may fairly considered operate real time interest 
classical soft real time perspective computation completion time constraints usually explicitly employed scheduling corresponding hard real time view activity completion time constraints defined deadlines 
benefit accrual model time constraints explicit richer delineate encompass continuum soft deadlines 
represented primary components expression benefit system results yield individually collectively function completion times application specific predicates acceptability optimization criteria accruing benefit results see 
benefit application completing computation best time computation completion time acceptable time benefit function acceptable benefit alpha principal real time strategy schedule resources physical processor cycles secondary storage communication paths logical virtual memory local synchronizers transactions real time constraints benefit accrual model described preceeding subsection 
uniform approach resource scheduling allows thread control resources utilizes system nodes user devices performing disk network sensor actuator accesses 
resulting continuity thread time importance attributes appropriate scheduling algorithms ensures coherent maintenance real time behavior 
alpha separates resource scheduling application specific policies defining optimality criteria overload management general mechanisms carrying policies 
mechanisms policy module interface part kernel 
restrictions kind number scheduling policies obviously parameters time constraints importance interpreted consistently domain execution may multiple domains 
policies may time directly deadline algorithms indirectly periodic fixed priority algorithms rate monotonic round robin 
alpha context notably characterized overloads distributed system conceived new class best effort real time scheduling policies 
policies non stochastically non deterministic taxonomy scheduling 
best effort scheduling policies utilize application supplied information usual place specific requirements kind scheduling mechanisms provided 
obviously resource scheduling employs application supplied information benefit functions higher price little information static priority information round robin 
price affordable respect correctness performance gained comparison simpler expensive scheduling techniques 
effectiveness cost representative best effort benefit accrual algorithm studied simulation measurement 
results demonstrate kind scheduling capable successfully accruing greater value widely algorithms round robin shortest processing time non real time algorithms static priority common real time algorithm closest deadline loads characteristic alpha intended environment 
scheduling cost thread scheduling decision depend specific algorithm implementation time value function representation evaluation 
initial studies feasible design implement benefit accrual algorithms provide greater return application resource investment resources available application scheduling 
experiments research analytical characterization performance best effort benefit function scheduling place 
desired large part price paid cheap currency hardware multiprocessor nodes processor statically dynamically assigned evaluating time value functions done alpha release release respectively special purpose hardware accelerator analogous floating point processor employed 

distribution alpha alpha distributed kernel provides coherent distributed programming application software os 
exports new programming model appears suited writing real time distributed programs 
consequently provides mechanisms having objective supporting full range client layer trans node resource management policies policies clients kernel discussed 
alpha provides new kernel programming model extant ones cf 
deemed inappropriate alpha objectives various ways 
example message passing direct read write distributed shared virtual memory rejected low level unstructured cost effectively writing real time distributed programs distributed shared memo ry suffers implementation difficulties cost synchronizing dirty pages 
conventional layered remote procedure call model client server oriented imposes disadvantageous server centric concurrency control contemporary implementations insufficient transparency physical distribution 
distributed data structures linda tuple space suffer access sequencing design decisions non determinism fairness render unsuitable time constraint ordered tasks 
language dependent models argus potentially offer significant advantages acceptable alpha user community 
virtually real time distributed os programming models intended strictly deterministic systems 
alpha native programming model provided kernel interface os applications employ real time distributed programming 
os layer augment kernel supplied programming model application specific ways substitute alternative posix full unix compatibility alpha goal may inefficient 
alpha kernel presents clients coherent computer system composed reliable network transparent fashion indeterminate number physical nodes 
principle abstractions objects operation invocations distributed threads augmented particularly exceptions concurrency control 
objects alpha objects passive data types code plus data may number concurrently executing activities alpha distributed threads semaphore lock primitives provided construction local synchronization desired 
instance alpha client level object private address space enforce encapsulation resulting safety improvement judged generally worth higher operation invocation cost alpha application environments performance dictates objects may placed kernel discussed invocation subsection 
instance object exists entirely single node 
alpha kernel supports dynamic object migration nodes 
kernel mechanisms allow objects transparently replicated different nodes accessed updated application specific policies 
alpha objects intended normally moderate number size lines code dictated implemented cost object operation invocation 
kernel defines suite standard operations inherited objects overloaded 
objects operations identified system protected capabilities provide network location independent space unique names 
capabilities passed invocation parameters 
object may declared permanent causes non volatile representation state placed local crash secondary storage subsystem mechanisms normally necessarily resident kernel 
mechanisms support application specific atomic transaction controlled updates object permanent representation performed real time scheduled real time constraints corresponding distributed threads 
necessitates alpha take integrated approach managing resources accordance time related particular logical dependency constraints define execution correctness data consistency os real time distributed deal kinds constraints separately 
permanent objects obviate need traditional file system applications desired file system organization semantics readily provided client system application layer policies 
interests generality alpha kernel views universe objects flat structure added higher software layers 
operation invocations invocation operation method object vehicle interactions system including os calls 
distributed threads see subsection computations processes threads confined address space extend object object invocations 
operation invocation synchronous request reply semantics similar rpc operations block structured 
straight forward augment subvert intent alpha synchronous programming model constructing alternative asynchronous computational semantics native mechanisms message sends don wait calls spawn concurrent activity return 
asynchronous ipc assembly language programming long history supporters real time computing 
effects accomplished better behaved manner proper alpha model 
kernel level invocations deliberately synchronous threads distributed employing asynchrony generally straightforward particularly handling kinds concurrency exception cases happen distributed real time system 
non real time centralized multiprocessing os native ipc mechanisms asynchronous seek improve intellectual manageability client programming providing layered synchronous facilities 
mach provides examples mig just rpc local ipc ipc facility provided fault tolerant system built mach approach transparent recovery mach asynchronous messages significantly complicated 
similarly asynchronous message passing communication hardware large multicomputers abstracted productive synchronous programming model software development tools 
asynchronous rpc removed amoeba having truly decision impossible program correctly 
asynchronous ipc highly problematic attaining level assurance multilevel security os trusted mach 
invocation parameters passed invoked object domain invocation invocation complete return parameters passed back invoking object domain 
invocation request reply parameters capabilities passed value current frame stack invocation distributed thread distributed thread stack access stack 
handling bulk data typical requirement system integration mission management applications implementation enhancement facilitates movement value large parameters node asynchronous bulk data movement performed kernel client layer service changing programming model 
consider procedural parameters contrary spirit object oriented systems 
alpha presently deal topic parameter representation conversion arises heterogeneous nodes problem receives wide attention currently focusing alpha require especially unique solution adapt necessary 
invocation simply message passing fundamental kernel facility alpha 
consequently objects may placed kernel address space performance improvements 
course seek speedup directly accessing kernel data structures desirable option moving back kernel client space 
think inter node invocation creating segment distributed thread 
invocation masks effects thread segmentation unusually strong semantics independence transparency physical distribution 
alpha kernel performs implicit binding time invocation utilizing protocol centralized name server ncs location broker locating target object 
kernel includes provisions optionally perform explicit binding optimizing performance relatively static cases due specially located resources purposes testing failure recovery 
communication errors handled message protocols may realized kernel client objects 
various motivations reliable messages entirely client level functionality microkernel arguments argument balanced acceptability constraints particular real time system 
alpha communication subsystem incorporates approach general framework mechanisms implementing communication protocols due requirement problem specificity imposed real time requirements versions may substitute corresponding concepts techniques kernel 
alpha provides orphan detection presently usual assumption fail nodes elimination time distributed thread undergoing orphan elimination decentralized manner 
technique employed requires active tracking progress distributed thread alpha instance node thread rooted 
orphaned activity successfully detected eliminated requiring significantly complex mechanisms transactions distributed clocks 
technique allows dynamic trade offs communication bandwidth processing orphan detection latency 
standard alpha configuration orphan detection elimination kernel functionality alternatively implemented client space desired 
invocations may fail various reasons protection violation bad parameters node failure machine exception time constraint expiration transaction abort 
failure semantics invocation instances real time distributed system application specific alpha kernel includes additional mechanisms defining default 
see subsection exceptions 
distributed threads alpha distributed thread thread locus control point movement objects operation invocation shown 
distributed computation transparently reliably spans physical nodes contrary conventional threads conceived lightweight processes confined single address space os mach chorus clouds employs thread model similar alpha thread object thread object object thread alpha distributed threads threads object thread carries parameters attributes related nature state service re computation represents 
thread attributes may modified accumulated nested fashion executes operations objects illustrated 
rpc message passing employed os attributes utilized alpha kernel clients basis performing real time system wide decentralized resource management 
threads unit schedulability fully pre executing kernel 
scheduling subsystem detects ready thread execution increase accrued benefit currently running executing thread pre empted waiting 
pre emption costs expected completion time lower benefit accrual thread taken account making decision 
addition alpha offers scheduling algorithms explicitly deal various kinds resource dependencies conflicts threads appropriate roll forward roll back lower benefit accrual thread blocking higher 
fully pre multithreaded design alpha kernel facilitates real time behavior allows symmetric multiprocessing kernel clients 
exceptions thread object thread object object object object time object thread attribute accumulation object object thread subject exceptions event interrupts thread normal execution flow 
respect thread execution exception may synchronous machine check asynchronous real time constraint expiration transaction abort thread break 
kernel exception handling mechanisms treat synchronous asynchronous exceptions uniformly 
alpha kernel provides exception handling mechanisms defined terms kernel provided abstractions language independent mechanisms os language run time systems construct appropriate exception handling policies clients may turn es application specific exception handlers example retry perform compensatory actions utilize results attained prior occurrence exception 
mechanisms permit applications define handlers core set exception types defined kernel define exception types handlers 
mechanism specifying exception handlers exception block block structured construct complements block oriented nature invocations 
operation exception blocks opens scope execution parameters define exception handlers specified exception types thread executing block 
operation closes inner open exception block 
thread attributes exception blocks may nested exception block scoping dynamic 
exception handling attributes protected kernel subsequent application errors corrupt 
exception particular type occurs control thread moved handler specified inner exception block defines handler exceptions type 
alpha kernel fully pre exception may force thread kernel arbitrary point blocked perform exception handling 
addition userdefined exception blocks kernel treats operation defined object implicit exception block 
kernel defined handlers implicit blocks perform simple clean operations necessary ensure kernel retain minimum degree internal consistency leak resources fail due inconsistent internal data structures 
existence implicit block ensures exception blocks opened object closed exception blocks nest correctly object 
thread handles exceptions preserving correspondence thread computation performing 
occurrence exception kernel adjusts attributes thread exception handler executed attributes appropriate thread exception block point things ensures proper scheduling parameters associated exception handling 
occurrence single exception may require multiple levels exception handling performed 
example real time constraint expiration exception discharged exception block level real time constraint established reached 
example elimination orphan thread segment exception discharged segment eliminated 
cases exception handlers executed order inner outer exception discharged 
exception processing spans multiple invocations invocation frames thread head waiting invocation complete 
system level interface libraries take advantage fact simplify application level exception processing cases 
transactions transactions useful wide variety integrity purposes including optional extension needed invocation semantics zero 
particular interest alpha promotes limited transactional approach trans node concurrency control collectively threads behave correctly defined application distributed replicated partitioned data remains mutually consistent defined application 
advantages include permitting remote invocations pass mutable parameters value constitute shared state avoiding limitations conventional 
distributed systems synchronization generally achieved maintaining ordering events mutual exclusion centralized systems 
consider sending messages centralized synchronization entity consonant objectives distribution 
server centric concurrency control network style distributed systems 
transactions database context simply os particularly true real time systems integrated physical nature application 
general problem traditional transactions bundle properties atomicity permanence serializability high performance price 
alpha kernel provides transaction mechanisms atomicity permanence application specific concurrency control individually selected combined higher os application layers wide range different transaction policies cost proportional power 
real time systems permanence universally desirable transactions update data relevant local node incarnation cases physical world maintains true state related system sensor subsystems cached approximated data manipulated transactions 
conventional transactions define correctness serializability limits concurrency performance 
alpha mechanistic technique encourages application specific information non serializable transactions 
allows optimized correctness customized commit abort handling transactions commit allow transactions observe results ill effect arbitrary period time abort processing deferred arbitrary period time mitigating circumstances 
traditional recovery techniques rollback redo requiring client applications deterministic idempotent stateless germane real time contexts 
furthermore performance improved cooperation non serializable transactions 
second major limitation conventional transactions information application result real time constraints 
scheduled different criteria serializability tasks threads alpha case employ locking mechanisms time stamps unrelated task thread scheduling time required acquire release resources time required commit abort transactions potentially unbounded 
overcome limitations alpha transactions real time importantly meaning scheduled application real time constraints policies resources 
alpha system architectures distributed os impose accommodate variety possible os configurations system architectures alpha primarily intended 
purest form distributed os os system native nodes case provide local os functionality cost effective local centralized distributed applications 
nodes interconnection sufficient resources support local distributed computations 
difficult os accommodate backward compatibility extant local os application software cleanest coherent approach freedom create entire system scratch case real time applications especially distributed ones 
second system architecture interest distributed os native interconnected hardware nodes forming global os gos subsystem necessitates provide full local os functionality necessarily manner costeffective low level sampled data real time applications 
gos subsystem nodes physically interface local nodes os constitute low level real time subsystems gos subsystem interconnect system level interconnection 
case offers superior performance due local global hardware node interconnect concurrency compatibility heterogeneous pre existing local subsystems os applications major logistical benefits relative independence local global os application changes 
third alternative system architecture alpha distributed local os separate resident local nodal hardware 
uniprocessor nodes residency require virtual machine monitor create illusion processors entails overhead may affordable performance contemporary microprocessors 
multiprocessor nodes residency relatively easy highly effective alpha exist interoperate unix system multiprocessor nodes shown making available alpha applications alpha interconnect fddi ethernet command interpreter alpha resident unix multiprocessor nodes non real time functionality unix gui iso protocols software development facilities 
configuration internode connection able support distributed local os separate interconnection structures type 

multilevel security alpha alpha user layer applications utilities libraries paging policies alpha initialization sched 
policies system 
transact 
pol 
layer abstractions objects threads invocation exceptions capabilities transactions alpha kernel layer start facilities time manage 
communication virtual memory sec 
storage devices scheduling kernel layer traps interrupts debug monitor shared memory local os unix user system layer processors los interconnect tcp ip construction multilevel secure higher distributed real time systems great interest large part alpha prospective user community area active research alpha project 
inherent conflicts requirements real time security including limited covert timing channels arising real time scheduling algorithms covert storage channels due resource sharing contention potential malicious denial service untrusted applications improperly asserting great urgency importance predictability security enforcement behavior 
conflicts require appropriately authorized situation specific dynamic trade offs various security real time characteristics 

architectural lessons learned alpha important lessons believe learned experiences alpha architecture comparison mach 
kernel support distributed threads common find rpc services implemented layer top asynchronous message passing facilities 
layering usually involves multiple scheduling events complex rpc stubs argument marshalling multiple context changes consequent loss client identity attributes 
mach os attempts overcome deficiencies providing subsets message passing service optimized rpc 
case mach simple messages optimized messages capabilities port rights line data benefit optimizations 
optimizations reduce number scheduling interactions system calls necessary implement rpc identity scheduling information priority attributes propagated 
contrast alpha distributed thread moves object object time constraints properties remain effect 
alpha kernel fully pre effort run important ready thread executing client space kernel space 
timely service interruption processing essential alpha strategy scheduling overload situations 
alpha exception model explicitly takes account orphans distributed exceptions 
need functionality unique real time systems unix posix compatible systems support interruptible system calls 
orphan detection elimination typically provided layered rpc facilities 
limitations layered rpc facilities building distributed real time rpc facility problematic inefficient 
published suggests high performance rpc best obtained rpc specific kernel assistance 
multi server operating systems characteristics distributed applications servers reside single node 
client process communicates os server ipc 
standard implementation unix application invokes system service client thread control moves user application context operating system 
request service completed thread returns user space 
variety attributes follow thread user space kernel including identity working directory quotas kernel uses attributes track manage resource consumption provide interruptible system calls insure security 
interaction user applications standard operating systems reminiscent distributed threads 
mimicking semantics legacy operating systems unix particular collection servers complicated microkernels provide sufficient support distributed programming 
auditing authentication forwarding significant problems secure distributed systems 
changing identity subjects request service difficult associate server actions resources client responsible request service 
association important authentication auditing 
distributed threads facilitate aspect security preserving identity distributed computation 
dynamic adaptive thread management kernels mach chorus provide threads abstraction associates thread single task 
default mach thread management static 
servers subscribed requests block regardless computation resources available 
server subscribed kernel resources process control blocks kernel data structures reserved utilized dynamic adaptive thread management responsibility application designer 
experience shown application level solutions thread management distributed systems tend complex inefficient prone error 
thread management global inter task resource usage requirements difficult possible compromising security 
alpha threads prevent applications controlling number extant threads default behavior create threads dynamically needed basis 
kernel knowledge available resources primary responsibility balancing computation demands available resources 
argued thread management rpc layers constructed user space provide advantages distributed threads may true examples authors familiar convincing 
protected capabilities alpha capabilities kernel protected context sensitive names similar mach port rights port names 
systems chorus amoeba provide unprotected capabilities 
cost invoking type capability roughly equal experience confirms assertion unprotected capabilities somewhat expensive pass parameters 
unprotected capabilities insufficient build high trust systems 
early versions alpha associated capabilities objects similar way mach associates ports port rights tasks awkward inconvenient 
subsequent versions alpha permit capabilities associated threads 
thread local capabilities simplify capability management 
enable construction secure subsystems leveraged ways building secure real time systems 
object invocation broadcast alpha uses broadcast protocols aggressively locate invoke remote objects 
node maintains list objects local node object dictionary 
object invocation broadcast node receives message examines dictionary determine object invoked resides locally 
results simple object location protocols relatively constant time useful property real time applications 
time required locate object small broadcast processing overhead imposed nodes significant 
dictionary objects large fit memory paged 
paging add significantly total overhead variance broadcasting object invocations 
os mach particular demonstrated kernel owns capabilities possible track cache current location capability object 
alpha currently broadcasts remote object invocation done preliminary investigation caching remote object location information means reduce number object invocation generated broadcasts 
separation policies mechanisms separation policies mechanisms code words layered design design mechanisms policies approach encapsulation layering results relatively simple mechanisms suitable implementation variety policies 
experience suggests kernel interface interesting mechanism policy boundary 
creation policy modules kernel scheduling secondary storage communications great value 
scheduling subsystem simply layered common set mechanisms implement number signifi cantly different real time non real time scheduling policies 
encapsulation policies facilitated development maintenance wholesale replacement 

project history status alpha arose systems effort jensen project new paradigms real time decentralized computer systems began carnegie mellon university computer science department 
design alpha os started initial prototype release operational cmu fall 
alpha native kernel bare hardware necessitates great deal effort low level resource management 
involves fundamental issues alpha design implementation usual research approach emulating os application level typically unix introduced excessive real time distortions due vast disparity programming model structure alpha kernel unix 
alpha hardware base multiprocessor nodes built modified sun microsystems boards nodes interconnected ethernet 
principle goal project general alpha component particular create new concepts techniques real time distributed os validate results industrial academic experimentation 
step validation process augment personal experience industrial real time distributed computing systems involving user early development initial alpha prototype 
alpha sponsored primarily dod leading edge realtime computing problems solutions arise defense applications looked dod contractor community initial industrial user partnership 
selected general dynamics ft worth division exchanging application os technology highest bandwidth way exchanging people 
group successfully wrote demonstrated real time distributed air defense application alpha avionics organization intended base mission management os planned new aircraft alpha technology 
proof concept prototype operational sought transition alpha technology practice establishing relationship computer manufacturer 
facilitate transition leadership staff alpha project moved industry 
intent alpha serve technology development vehicle applicationspecific real time distributed operating systems telecommunications simulators trainers combat systems extensive functionality fault tolerance high real time performance utmost importance shelf products exist standards foreseeable number years 
subsequently technology available migration os contexts 
second generation alpha prototype design implementation delivered government industry laboratories experimental installed june 
current version initially available mips multiprocessor nodes interconnected ethernet ports hardware planned 
alpha non proprietary 
alpha research ongoing cmu related research technology development conducted cooperatively academic industrial institutions 
alpha project engaged partnerships number european corporations organizations develop experimental alpha applications areas telecommunications defense systems 

anderson ferrari rangan 
dash project issues design large distributed systems report 
ucb csd ca berkeley eecs department january 
jensen decentralized control distributed systems advanced course springer verlag 
von war tr 
graham 
london 
jensen alpha real time decentralized operating system mission oriented system integration operation proceedings symposium computing environments large complex systems university houston research institute computer information sciences november 
jensen locke tokuda time value driven scheduling model real time operating systems proceedings symposium real time systems ieee november 
locke best effort decision making real time scheduling ph thesis cmu cs department computer science carnegie mellon university 
clark scheduling dependent real time activities ph thesis school computer science carnegie mellon university 
kahneman tversky ed judgement uncertainty heuristics biases cambridge university press 
stankovic tutorial hard real time systems ieee 
einstein relativity special general theory crown december 
right size possible worlds essays 
jensen benefit accrual model real time proceedings th ifac workshop distributed computer control systems september 
jensen benefit accrual model real time submitted publication 
stewart distributed data processing technology interim report honeywell systems research center march 
gouda han jensen johnson methodology distributed computer system design proceedings texas conference computer systems ieee november 
jensen project overview proceedings international symposium synchronization control communication academic press 
mechanisms reliable distributed real time operating systems alpha kernel academic press 
jensen alpha non proprietary operating system mission critical real time distributed systems technical report tr concurrent computer december 
chen study timeliness property real time systems real time systems september 
chen classes effective heuristics time value function scheduling proceedings th real time system symposium ieee 
tokuda wang implementation time driven scheduler real time operating systems proceedings real time systems symposium ieee december 
jensen taxonomy real time distributed scheduling course notes distributed real time systems principles solutions standards paris june 
maynard shipman clark zimmerman keleher example real time command control battle management application alpha technical report tr project computer science department carnegie mellon university december 
clark maynard decentralized real time scheduling final technical report contract school computer science carnegie mellon university february 
clark shipman lindsay alpha operating system system subsystem specification project technical report department computer science carnegie mellon university may 
reynolds jensen alpha release preliminary system subsystem description technical report concurrent computer december 
tannenbaum van renesse distributed operating systems computing surveys acm december 
cheriton boyle paradigm highly scalable shared memory multicomputer architecture computer ieee february 
kaashoek bal tannenbaum experience distributed data structure paradigm linda proceedings workshop distributed multiprocessor systems usenix association october 
liskov scheifler guardians actions linguistic support robust distributed programs transactions programming languages systems acm july 

ko tripathi platform hard real time applications proceedings workshop operating systems mission critical computing ios press 
kopetz damm koza distributed fault tolerant real time systems mars approach micro ieee february 
clark alpha operating system programming model project technical report tr carnegie mellon university february 
clark shipman maynard jensen reynolds dasarathy threads programming construct reliable real time distributed programming proceedings international conference parallel distributed computing systems international society mini micro computers october 
draves jones thompson mig mach interface generator internal working document computer science department carnegie mellon university november 
chen ng building fault tolerant system mach proceedings usenix mach workshop october 
goldberg gopal li strom bacon transparent recovery mach applications proceedings usenix mach workshop october 
wu 
gajski programming aid message passing systems transactions parallel distributed systems ieee july 
tannenbaum van renesse van staveren sharp mullender jansen guido van rossum experiences amoeba distributed operating system communications acm december 
mayer access mediation message passing kernel proceedings ieee symposium security privacy may 
gifford remote pipes procedures efficient distributed communication transactions computer systems acm august 
levy silberschatz distributed file systems concepts examples computing surveys acm december 
apollo computer network computing system manual 
saltzer reed clark arguments system design transactions computing systems acm november 
clark alpha operating system kernel internals project technical report department computer science carnegie mellon university may 
hutchinson peterson kernel architecture implementing network protocols transactions software engineering ieee january 
herlihy timestamp orphan elimination transactions software engineering ieee july 
rashid threads new system unix review august 
rozier armand herman kaiser leonard chorus distributed operating systems cs tr chorus systemes 
dasgupta chen menon pearson ramachandran ahamad leblanc khalidi design implementation clouds distributed operating system computing systems usenix june 
brown taft alpine file system transactions computer systems acm november 
jensen implications physical dispersal operating systems proceedings informatica yugoslavia march 
garcia molina semantic knowledge transaction processing distributed database transactions database systems acm june 
borg fault tolerance unix transactions computer systems acm january 
ravindran failure transparency remote procedure calls transactions computers ieee august 
sha jensen rashid distributed operating processes transactions proceedings acm symposium data communication protocols architectures mar synchronization control communication distributed computing systems academic press 
partitioned multiprocessors existence heterogeneous operating systems proceedings usenix winter conference january 
gasser building secure computer system van nostrand reinhold 
reynolds jensen lunt security real time systems proceedings th national computer security conference october 
draves revised ipc interface proceedings usenix mach workshop october 
karger improving security performance capability systems technical report computer laboratory university cambridge october 
bershad anderson lazowska levy lightweight remote procedure call transactions computer systems acm february 
schroeder burrows performance firefly rpc transactions computer systems acm february 
anderson pose wallace password capability system computer journal february 
karger herbert augmented capability architecture support lattice security traceability access proceedings symposium security privacy ieee april 

acknowledgments research alpha constituent technology concurrent computer sri international mellon university sponsored rome laboratories computer systems branch 
additional support alpha supplied digital equipment provided cmu naval ocean systems center general dynamics ibm sun microsystems corporations 
views contained authors interpreted representing sponsoring organizations 
authors grateful duane invaluable leadership alpha prototype design development ed burke dasarathy jim don lindsay dave maynard martin doug ray sam shipman george jack test jeff nick yong wang doug wells essential contributions alpha 
teresa lunt ira sri international ray clark concurrent computer doug wells open software foundation principals multilevel secure version alpha kernel 
alan downing mike davis sri international principals integrated resource management project alpha assisted jon cmu 
unix registered trademark unix system laboratories 
