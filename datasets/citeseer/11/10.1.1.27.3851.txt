setl internet data processing david bacon dissertation submitted partial fulfillment requirements degree doctor philosophy computer science new york university january jacob schwartz dissertation advisor bacon permission reproduce part non commercial purposes granted provided notice www cs nyu edu bacon phd thesis remain prominently attached copied text 
excerpts postscript page long may quoted requirement include notice attach bibliographic citation mentions author name title year dissertation new york university 
children ii acknowledgments advisor jack schwartz support encouragement 
am grateful ed schonberg robert interesting helpful discussions particularly early days nyu 
terry boult lehigh university richard wallace contributed materially setl nsf arpa 
am indebted parents gave strength bring labor love hope 
iii preface colin colleague edmonton canada aware setl saw heavy making associative tables data processing protein ray crystallography laboratory 
accordingly copy primer henry max goldstein 
spoken language colleague mark israel visited university british columbia years came tutorial entitled setl programming language entirety syntactic treatment maps setl places expressive balance closer algebraic mathematics customary programming languages immediately started finding setl helpful notation planning difficult parts programs destined coded algol fortran assembler 
took sc 
enthusiasm setl presentation advanced programming languages class 
invited stay ph university toronto reason declined specifically willing supervise setl part want get caught logic programming iv really systems programming tradition prevailing time 
having access setl implementation cims version crash garbage collection attempt mainframe decided dash 
learning exercise 
compiler correctly extent tested produced runnable code saw practical application hardware day 
december decided write production grade setl compiler began implementation day continue extend 
start maps useful combinatorial programming doing molecular modeling 
implementation packaged way common invocation mode compile go shell level command setl making setl programs easy fit unix filter pipelines just scripts pre compiled programs 
reasonably convenient able set arrangements communicating setl programs way languages bourne shell interconnecting various programs thin descendants job control languages 
setl competent handling data natural extend facilities process creation communication 
led shot filter unidirectional pipe bidirectional pump models communication described chapter dissertation 
fact writea reader reada easily transfer large map small integer combined fact unix command rsh launch tasks remote processors communicate comfortable programming environment distributed programming able express tcp ip tcp udp server client directly 
world wide web arrived clear tcp ip firmly established global standard mime conveying protocol rides tcp streams namespace structuring universal resource locator url convention uses host names map ip addresses auspices widely domain name service dns 
decided build support tcp ip directly setl system opening bidirectional tcp communications stream setl easy natural opening file 
done detailed chapter describes setl programmer friendly support udp datagrams 
ability code servers setl proven useful predicted 
servers act primary objects server hierarchies 
bear state control access state message passing protocols child processes turn deal clients 
server tends keep track children dynamically varying map 
server trusted proximal children communication safe quick minimizing risk server bottleneck 
webeye study chapter illustrates pattern 
liberal processes turns beneficial time 
real tends fall simple modules communicate primitive way standard input output channels modules easily written efficiency oriented languages setl necessary 
small components vi easy isolate special unusual testing rare inevitable episodes called debugging 
systems designed process intensive server hierarchies tend acquire satisfying dataflow feel 
spirit unix filters setl value semantics pointer copy doing avoid hazard distributed dangling 
vii contents dedication ii acknowledgments iii preface iv setl 
brief history setl 
summary 
environmentally friendly invocation environment 
filters pipes pumps 
filters 
pipes 
pumps 
buffering 
line pumps 
sequential direct access 
sequential reading writing 
string 
direct access files 
viii signals timers 
signals 
timers 
multiplexing select 
files links directories 
user group identities 
processes process groups 
open compatibility 
automatically opened files 
opening streams file descriptors 
passing file descriptors 
normal abnormal endings 
strings 
matching regular expression 
formatting extracting values 
printable strings 
case conversions character encodings 
concatenation note defaults 
field selection syntax maps 
time 
low level system interface 
file descriptors 
processes 
summary 
internet sockets clients servers 
client 
server 
choosing port number 
ix concurrent servers 
nave server 
shell aided server 
shell independent server 
pump aided server 
defensive servers 
time monitoring server 
identity sensitive server 
udp sockets 
summary 
webeye case study webeye 
video services 
camera control services 
administrative services 
software structure 
video services 
camera control services 
summary 
data processing field 
problems solutions 
guidelines 
checking 
limits 
unexpected 
clients 
aliases 
accessibility 
program size 
standards 
summary 
systems 
interoperability 
types 
string handling 
exceptions 
miscellaneous desiderata 
lexical nesting 
filename 
format directed 
high level internet protocols 
fringe 
pointers 
closures continuations 
threads fine grained concurrency 
setl implementations 
comparison languages 
perl 
icon 
functional languages 
python 
rexx 
java 
summary 
xi webeye source code vc admin setl 
vc allowed setl 
vc setl 
vc camera setl 
vc check setl 
vc clear setl 
vc setl 
vc setl 
vc cron setl 
vc decode setl 
vc setl 
vc event setl 
vc setl 
vc setl 
vc exit setl 
vc getname setl 
vc giver setl 
vc go setl 
vc httpd setl 
vc image setl 
vc init setl 
vc input setl 
vc setl 
vc cgi 
vc jumper setl 
vc master cgi 
vc model setl 
vc mouse setl 
vc mover setl 
xii vc msg setl 
vc obtain setl 
vc provide setl 
vc ptz setl 
vc push setl 
vc quit setl 
vc recv setl 
vc restart setl 
vc send setl 
vc seq setl 
vc simpler setl 
vc snap setl 
vc toplev setl 
vc setl 
setl 
bibliography xiii chapter public network services coherent reliable responsive face errors failures attacks intermittent resource scarcity 
setl turns convenient powerful tool dealing challenging environment 
dissertation describes extensions setl useful data processing especially internet numerous processes involved 
intended serve tutorial design moderately complex distributed systems setl accordingly provides examples 
setl 
setl strives put needs programmer ahead machine reflected automatic memory management fact flexible setl 
structures employed easily size constrained ones presence interface powerful built datatypes concise natural syntax 
high level nature setl pleasure long appreciated outside world distributed data processing 
flexibility ensure discipline highly desirable rapid prototyping 
fills important need experimentation crucial early phase evolution large software systems especially featuring novel designs 
second setl strong bias favor value semantics facilitates distribution responsibility multiple processes client server setting 
absence pointers eliminates major nuisance distributed systems design question copy data structures contain pointers 
setl realizes hoare ideal programming pointers 
third fact setl object atoms procedure values converted string back slight loss precision case floating point values converted sender writea call matched receiver reada means setl programs little process boundaries enjoy mutual protections attending private memories 
maps tuples represent kinds data structures immediate way syntactic extension section allows record style field selection suitably domain restricted maps familiar dot notation direct maps objects programs complementing ease transmitted programs 
similar setl 
freedom notation exists javascript associative arrays identified properties 
fourth strings class objects setl 
completely flexible assigning substring change length hosting string just tuple change length assignment 
strings rich set built operations searching manipulation algebraically formulated patterns 
extensions allow selections substitutions specified regular expressions slicing notations forms described section 
strings heart data processing vital support setl 
fifth setl skill general finite maps welcome consequences data processing practitioner 
level data processing system viewed dynamic graph arcs messages pass 
system view concrete visual programming language 
data messages undergoes transformation recombination processing nodes maps represent data relationships directly 
processes extraction tend gather data keys strings identify categories 
processes association discovery correspond set intersection merging closely related set union 
sets domains ranges maps projections sets general tuples 
maps heart setl style book setl programming language wrote setl 
general rule setl maps possible 
may take practice especially programming language remember simple principle find maps 
principle works practice 
example process multiplex input streams processes map corresponding handles track state knowledge processes domain set input handles passed select primitive see section waits nondeterministically events 
sixth absence restrictions unhelpful programmers brings substantial measure orthogonality robustness 
orthogonality promotes feature combinations sense conducive directness expression 
absence size restrictions similarly helps eliminate clutter 
example programmers write extra code deal fact messages embedded tcp stream arbitrary length general case handled gracefully effortlessly 
importance publicly exposed network servers 
thing attack bring subprocess due exhaustion resources allocated hostile client interface public service damage easily isolated 
need damage se naturally handled ordinary transaction aborts commit 
setl 
remarkable adaptability setl gift concise expression wide range programming problems stem close connection foundations mathematics 
set formers modeled set comprehensions case point 
highly accessible little pictures encourage programmer take dual view sets entities characterized predicates constructed parts 
tuple displays exemplify setl directness expression 
fetch contexts enumerative denotations written form lisp lists store positions show immediately pattern required structure 
setl freely borrowed best ideas programming languages algol family apl snobol adding 
main significance foregoing attributes setl data processing internet pave way small programs 
small setl program lot constrained usual obstacles communication complex pointer bearing objects processes isolated module 
shared variables plague concurrent programs simply language rarely missed sharing resources serious matter usually calls management mechanism best encapsulated module anyway 
namespace adequately structured file system url convention purposes access objects space best mediated appropriately synchronizing small process 
raises important issue data processing environment language may scream 
fortunate choosing adopt posix standards design benchmark setl interface brief history setl files commands users processes network communication 
operating system model gained wide acceptance vendors embodied open specification commonly known unix 
chapters largely devoted presentation features current definition setl employ build model 
brief history setl setl today essentially language jack schwartz introduced years ago set theory language program specification programming may remarked favor setl mathematical experience past half century especially gathered mathematical logicians pursuing foundational studies reveals theory sets incorporate powerful language terms structure mathematics rapidly built elementary foundations 
applying setl specification number fairly complex algorithms taken various parts compiler theory shall see inherits advantages general set theory modeled 
may noted partly classical familiarity mathematical set notion provides comfortable framework requiring imposition relatively artificial constructions basic skeleton analysis 
shall see setl inherits brief history setl advantage allow describe algorithms precisely relatively superimposed conventions programs artificial lengthy hard read 
contrast expressive efficiency mathematics parsimony machine oriented languages highlighted programming vii hand programming concerned specification algorithmic processes form ultimately 
mathematics describes processes cases merely results succinct form form precision admit 
comparing gets strong initially confused impression programming difficult 

large gap logically precise specification object constructed programming language account method construction core answer may single word efficiency 
shall see want take word different sense ordinarily programmers 
specifically implicit language mathematics give language power imply searches infinite rate large sets 
programming algo brief history setl rithms realizing constructions necessity equivalent procedures devised cut ranges searched find objects looking 
sense may say programming optimization mathematics programming forget optimization program manner appropriate infinitely fast machine infinite amounts memory 
fundamental level mass optimizations burdened programming cumbersome process process principal obstacle development computer art 
perspective hinted quotation strong perception late need set oriented language capable expressing concisely kind set intensive algorithm kept arising studies compiler optimization allen cocke kennedy schwartz 
programming languages compilers published early devoted pages optimization algorithms 
included familiar techniques redundant code elimination strength reduction dealt extensively graphs control flow partitioning intervals showed split nodes irreducible flow graph obtain reducible 
workers just mentioned identified setl directly indirectly language brief history setl implementation greatly need solutions difficult compiler optimization problems 
setl far celestial sphere pure mathematics seen occupying high orbit relative languages 
setl distance pure machines optimizing implementations important time difficult 
synergy study code optimization high level set language expressing optimization algorithms led setl compiler project abundant source optimization problems 
setl project produced things setl optimizer line prototype written setl 
unfortunately machines day large apply 
setl language benefit greatly optimizer semantic simplicity particularly amenable flow tracing techniques machine independent code optimization 
absence pointers circumvents issue aliasing huge advantage kind analysis 
sort data flow definition information obtainable analysis control flow graphs generally schwartz value flow tracing follow objects stored aggregates extracted useful sorts ways 
sustained copy optimization redundant copying object suppressed subsequent object modified incrementally 
value flow analysis provided brief history setl dependency framework types variables expressions deduced transitive closure process starting manifest types literals forms 
process turn enabled discovery relationships set membership inclusion prelude automatic data structure choice way object profound influence implemented 
weiss schonberg showed type inference presence infinite sets possible types arising actions fxg 
data structure representations sublanguage served annotate modify setl programs coded appropriately level 
designed permit smooth transition schwartz level programming regime programmers supplied representational details fully developed system sophisticated optimizer selections 
important concept base sets implicitly defined objects principle allow representational sharing objects conceived programmer 
value flow analysis type inference copy optimization deeper determinations relationships set membership inclusion variables preparatory automatic data structure selection embody approach program analysis described called interpretation cousot cousot symbolic execution muchnick jones xv 
essence model program defined semantics projected ab brief history setl program capturing salient properties objects manner susceptible analysis 
example sign product deduced signs knowing specific values 
similarly result types known operators usually gleaned compile time operand types regardless actual run time values operands 
interpretation program exercised compile time discover desired properties objects symbols combine recombine algebra appropriate purpose 
algebra designed feasible goals mind exercise converge 
typical ensure termination advantage fact set generated inductive definitions data flow equations defined lattice theoretic fixed point monotone function 
allows global properties inferred local ones straightforward process transitive closure 
power generality interpretation moved paige colleagues undertake ambitious study program transformations ultimately led apts project 
main transformations apts dominated convergence computing fixed points tarski sequences 
monotone reasonable efficiency 
second finite differencing set theoretic analogue strength reduction allows expensive set operations loops reduced incremental updates locating fixed points quickly construction maintenance program invariants 
third transformation brief history setl real time simulation associative memory ordinary random access memory slight additional restrictions mere pointer access memory effectively automates tedious programming activity choosing efficient sets :10.1.1.29.4481
chung yung finite differencing technique calls destructive effect analysis seeks copying aggregates purely functional programming language eas packaging typed calculus extended homogeneous sets 
transformational programming regarded formalization dijkstra stepwise refinement 
bloom paige point transformational methodology able merely optimize code translate language 
helping algorithm designer reason time space complexity syntactic terms means low level counting arguments technology played significant role invention new algorithms greatly reduced asymptotic complexity compared previous solutions rendered algorithms perspicuous inventors students 
phase development apts seek improve reliability performance 
currently program transformations apts proved correct meaning preserving hand slow error prone 
hope integrate meta level proof verifier lines outgrowth ferro fast decision procedures fragments finite set theory 
brief history setl alternatively model integrated verifier setl nap system implemented setl derivative cantor 
verification assertions say hoare logic increase confidence automatically applied transformations 
davis schwartz showed mechanical verification systems extend new proof methods violating soundness changing set statements proved 
main existing impediment speed apts fact database program property relationships dynamically deduced static database inference rules recomputed application program transformation 
sought incremental rule database system regenerate relationship records efficiently rewriting operation 
ultimately possible apply apts large gains speed take advantage technique partial evaluation realize production grade transformational system 
goyal paige revisited copy optimization problem setl high level languages exemplify hoare ideal pointer free style programming 
known technique dynamic counting achieve lazy copying combining static liveness determination schwartz value flow analysis able optimize placement copy operations om assignments serving decrement counts objects known subsequent uses 
prove correctness alias propagation analysis code transformations formal semantics brief history setl interpretation 
goyal obtained dramatic improvement algorithmic complexity computing intra procedural may alias relations dominated convergence finite differencing 
dissertation develops set theoretic languages express specifications low level implementations form uses data structure selection method novel type system preserve computational transparency necessary order statements program efficiency meaningful 
cornerstone general transformational methodology 
number implementations setl setl languages years 
called implemented extension harrison extensible lisp language 
succeeded implemented strict subset setl 
full setl language implemented little syntactically fortran language supplemented notation bit field extraction 
little built data types fixed length bit strings floating point numbers implement compiler run time system version setl maintained distributed courant institute mathematical sciences cims new york university mid late 
cims setl system quite slow cumbersome little widely ported late nigel chapman graduate student brief history setl university leeds designed implemented system called setl 
covers substantial subset setl leaving macros backtracking data representation sublanguage support separate compilation minor syntactic 
name stand small setl compact system celebrated indirect threaded code technique written minimal portable assembly language run time system macro implemented 
jay dropped hyphen setl worked called nyu sabbatical college 
maintains current version compiler documentation 
batch oriented character full cims setl implementation requirement considerable computing resources extent complexity slowness led ed early setl informally discrete mathematics algebra courses clarkson university collaborate gary levin mid creation new small interactive system close syntax spirit setl overhead 
called system stable version years freely publicly available comprises little lines portable code runs quite common desktop computers provides class functions feature long valued strong ongoing pedagogical support textbooks annual workshops enthusiasm sizeable community mathematics teachers 
brief history setl late nyu project aimed cims setl language implementation 
new version language tentatively named setl 
kirk snyder graduate student time dissatisfied appeared discussion supported little action covertly designed implemented system called setl year 
simplified modified various aspects setl syntax semantics removed usual macros backtracking data representation sublanguage setl modules introduced ada packages portable file format separate compilation dos macintosh unix platforms 
snyder subsequently added lambda expressions class functions closures support object oriented programming including multiple inheritance extensions entirely semantic problems context nominally value oriented language 
toto improvements interoperability setl native package declarations allow direct calls routines written previously possible 
famous setl programs date ada ed validated translator executable semantic model language known ada 
established convincingly setl suited rapid prototyping complex systems significant size care taken construction prototypes serve readable definitive specifications inform guide building production systems 
brief history setl setl success prototyping tool spawned esprit sed setl experimentation demonstration project late sweeping effort create setl prototyping environment complete highly sophisticated language manipulation tools syntactic semantic levels 
included setl ada translator editor debugger performance profiling monitor 
rendered particularly accommodating non invasive cooperating processes sharing messages tcp sockets 
interpretation operative model ambitious tenenbaum type inferencer paige general transformational system predecessor apts prototype meta setl ast traversing interpreter 
sed employed rich set language processing tools type checking semantic analysis pattern directed inference interpretation mentor interface syntax directed editing environment 
interoperability addressed setl ada translator performance monitor means isle interface specification language environment important sed project demonstration rapid prototyping setl cartography application containing package computational geometry algorithms 
jean pierre keller leader sed project went define setl descendant called cantor 
cantor closer syntax semantics setl implemented 
firstclass functions concurrency mechanisms set predefined objects brief history setl gui construction 
encouraged sed contributions art programming large project plans persistence setl disappointed sed failure arrive coherent product ernst erich proposed integrating persistent backing stores called files requisite namespace support setl revision setl extended process creation operator renamed signify role prototyping 
interest setl grew general interest software engineering set oriented languages having intrinsic persistence features sought spare programmer trouble coding data movement operations explicitly 
hasselbring showed translate subset setl snyder setl 
tuples natural candidates inter process communication linda tuple spaces hasselbring worked extensively methodology prototyping concurrent applications hybrid system called linda compared approach 
entirely different notion persistence pertaining backing store ability data structure retain update history way preserves time space efficiency access current past states liu create setl run time system graphical debugging interface allows users scroll backward forward program execution history 
liu tried bring convenience setl relatively low level brief history setl world header files run time library 
relative setl slim designer herman describes cousin setl child shares common heritage setl independently designed 
supports object oriented programming allows optional type declarations 
language implementation relatively small complete 
experimental language bears kinship setl data structure level functional language called 
data item sequence single elements viewed element sequences 
facilitates highly orthogonal treatment operations particularly distributivity spirit apl 
maps associative subscripting 
language provides syntactic offering little denotational forms prefix function application notation binary operators 
griffin language designed new york university early intended general purpose successor setl 
goals included surely comprehensive type type inference system proposed 
griffin supposed give programmer complete freedom choice code functional imperative style 
language constructs database style transactions namespaces persistence 
real time facilities ada interoperability exceptions broad support concurrency built language level 
griffin implemented compiler brief history setl major obstacle completion enormous task difficulty fixing fully self consistent language definition 
interest setl dissatisfaction cims implementation terms marketed led prototype compiler run time interpreter setl 
version reasonably complete realization core setl language described appeared function correctly limited tests put entirely unsatisfactory terms speed size limitations strings tuples sets imposed direct representation strings arrays tables respectively 
late newly deprived transition mainframe running mts michigan terminal system workstation running unix encouraged emergence unable adapt easily non interactive data processing purposes 
began part time effort implement compiler run time system setl version complete daily mid car part replaced main vehicle running setl programs 
supports language extensions code samples dissertation 
set greater store robustness correctness speed implementation efficiency satisfactory 
rare instances case easy setl program interoperate programs subroutines written brief history setl lower level languages case situations usually occur library functions involved 
elementary computation intensive image processing operations representative example 
shortly arriving new york university aware snyder setl just spring 
fall year talk unified language definition implementation prevented fact snyder want permit access system source code fact considered setl setl works progress 
differences languages differently packaged reflecting different goals 
starting emerge body setl code including revision ada ed elected extend setl grammar setl generally simpler syntax accommodate 
quickly apparent essentially needed left 
worst collision ambiguities syntax loop headers little awkward resolve led minor patchwork compiler scarcely setl programmer 
resulting augmented setl ideal splice language design point view perfectly comfortable standpoint writing code requires programmer occasional choices equivalent alternatives 
slight form appear negative impact readability setl programs fact programmer chooses simplest expression available arguably confers minor advantage 
example loops brief history setl comparatively simple setl headers times greater generality full setl loop construct preferable particularly exit test fall naturally loop 
continued setl 
deliberately conservative extending syntax language consider world finest hesitant run time system 
goals highly pragmatic am day day user setl 
set theoretic languages small active particularly logic functional programming communities 
example visual logic programming language sets essentially graphical shell version prolog augmented sets constraints partitioning sets give language expressive power 
escher hand descends functional language haskell extends general useful mechanism list pattern matching function signatures accommodate sets identified predicates 
evaluation escher pure rewriting unification built computational model pattern matching lazy evaluation haskell added ability reduce expressions containing variables combine support logic programming escher sacrificing advantages functional style 
web sites devoted various aspects programming sets twelve papers workshop paris declarative program summary ming sets 
declaring goals preference specifying operational steps subject close heart logic programming 
summary chapter general background motivation setl suggested remains language worthy study development 
data processing largely concerned interaction programs environments chapter examines rich repertoire input output related facilities added setl 
subsequent chapters deal network specific provisions illustrate design patterns effective new tools 
chapter environmentally friendly cims version setl described schwartz features characteristics useful data processing language general high level nature particular extensions snobol inspired string pattern matching routines 
implementation packaged convenient manner popular unix tools awk perl promote construction simple programs chained output input programs build pipelines cooperating processes 
language specification pre cims implementation provided sequential file printer oriented offered built way communicate spawn external processes 
unix functions commands individually cited dissertation indicated suggestive typeface 
convention common gnu utilities fmt perl 
environmentally friendly invocation environment setl added support direct access files system primitive able start external program wait complete offer way communicate external programs way files 
distributed data processing depends direct fundamental way facilities chapter describes various extensions setl relating inter process communication including matters string number formatting multiplexed timers signals unix interface 
chapter deals network specific extensions 
non unix systems expected particular setl feature easily mapped corresponding facility operating system setl implementation supply benign substitute appropriate 
invocation environment setl adopted identifiers conventionally ada refer external name arguments program command invoked command name predefined constant string represents environment defined way name program point view party launched command line predefined constant tuple strings representing list arguments program 
environmentally friendly invocation environment commonly unix shells caller command name command line correspond programs receive argv subsequent argc elements argv respectively 
setl command invoked directly command line tuple strings representing arguments command name name setl interpreter default configuration current setl implementation 
setl interpreter invoked escape common virtually varieties unix escape sequence unspecified effect unix standard placing 
path setl file contains setl program making file executable chmod see section filename available inside setl program command name arguments placed name strings show command line 
convenient way supplying environmental information programs environment variables 
widely operating systems support form 
setl value getenv name retrieve string value associated environment variable named name 
variable known environment getenv returns om 
environmentally friendly filters pipes pumps programmers aware names environment variables may may treated case sensitively depending system 
unix systems case significant dos systems 
strongly recommend strict adherence uppercase convention names portable practice entrenched unix community 
setl program set environment variables benefit programs spawns name value associate value name name value strings value defaults null string 
environment variables deleted name filters pipes pumps great contributions unix world data processing tendency encourage small modular processes connected pipelines known filter chains standard default output stream process feed standard input chain forming larger module standard input output available redirection file device process 
programs designed act pipeline elements naturally called filters 
filtering usually shot event sense filter environmentally friendly filters pipes pumps typically read input quit having produced output way 
unix shells popular basic syntax connecting filters pipelines vertical bar simple command program invocations indicates standard output passed standard input second 
example cat txt jjj fmt jjj wc concatenates files txt suffix current directory stream fed command fmt treats input text left justified paragraphs exceed characters width 
output fmt turn passes wc output simply report number lines words characters input 
pipeline typed interactive text command shell output left attached display output wc single line case simply displayed text looking possible programs engage programs child processes communication arrangements parent handle connected standard input standard output child 
unidirectional channels called pipes typically programs read write data filter situations convenient parent execute operations course reading writing data 
environmentally friendly filters pipes pumps bidirectional case pump stream program handle connected standard input standard output child process 
generally sort protocol involved case parent child interaction span considerable real time 
see examples chapter processes called servers deal clients child processes normally exists duration client connection 
pump streams useful outside context networks example program spawns local gui graphical user interface processes 
filters setl handling strings convenient processing strings passing programs 
setl statement output filter cmd input causes cmd submitted standard unix shell command language interpreter sh command argument 
command specified cmd may internally contain pipeline redirection indicators run child process 
string input defaults null string fed child standard input string output receives issues standard output stream 
pump term years 
unix really embraced notion bidirectional buffered stream 
environmentally friendly filters pipes pumps filter unable create child process due resource exhaustion returns om 
string input non null child processes may need created run command cmd feed input command 
parent setl process remains consumer builds string containing command output returned caller filter 
simple example filter format left justify text fits prescribed width imposed user text window 
program section uses technique 
subroutine runs external command fmt insert line characters appropriate places proc fill message text width wrap text return filter fmt str width text proc example str convert presumed positive integer parameter width decimal string appended fmt form command including command line parameter 
string text filtered fmt formatted result returned 
pipes unidirectional stream connected standard input standard output child process called pipe 
setl start external command child process open input pipe stream connected standard output environmentally friendly filters pipes pumps fd open cmd pipe pipe launch external process output pipe stream connected standard input fd open cmd pipe pipe cases cmd string sense environmental command interpreter shell just filter 
stream handle returned open prototypes assigned variable fd mnemonic file descriptor 
setl programmer treat opaque certainly arithmetic may wish aware especially setting communication programs written languages setl setl file descriptor exactly integer assigned kernel result open related calls called file descriptor unix literature 
setl implementations expected provide buffering handle detailed section 
open fails create child process due resource exhaustion returns om valid file descriptor 
example pipe input pipe stream connected standard output unix ls command obtain list files current working directory filename line 
filename read ls process setl program applies fsize operator discover size named file bytes prints resulting integer right justified character field left justified filename separated space environmentally friendly filters pipes pumps fd open ls pipe open file listing subprocess name getline fd om loop loop input name print fsize name name print file size name loop close fd close child process example pipe setl program opens stream print lpr log fd open lpr pipe printa log fd log begins date primitives named pipe child pipe child essentially degenerate forms pump primitive described section 
pumps external command started child process standard input output connected bidirectional stream parent setl program follows fd open cmd pump direct appearance sockets powerful tool distributed computing string cmd specify invocation rsh execute example command remote host local doesn installed wishes distribute load 
starting external command specification child process convenient create child clone currently executing setl environmentally friendly filters pipes pumps program 
new nullary primitive pump creates child inherits copy parent setl program data space manner fork see section 
successful returns gamma child returns bidirectional file descriptor parent connected standard input output child 
unsuccessful due resource exhaustion returns om pump mode open fd pump optional suggests mere fetch fragmentary code template shows pump fd pump spawn clone fd gamma child stdin stdout connected parent fd 
normal exit fd om parent fd eof tells child completed 
close fd clear child process table child process created handle ignore failure 
reason usually works best put child code program miniature exiting just block contains parent save new fd carry 
clumsy parent code section branch child code 
exception rule branch really return generic launcher environmentally friendly filters pipes pumps proc start helper helper launch helper return pump fd fd pump spawn clone fd om child created return om failure return elseif fd gamma parent process fd connected child return fd caller close fd child process stdin stdout connected parent call helper indirect call helper procedure guard helper neglecting exit proc program uses pump second version impatient setl section 
buffering output files print shot filters setl programmer may need aware buffering processes interconnected pipes pumps times necessary tell system explicitly move data currently accumulated stream buffer receiver 
done call flush fd get kernel caught feature pump stream created pump open specifying mode pump output side automatically flushed read input side attempted 
fact true bidirectional direct access environmentally friendly filters pipes pumps streams created setl ones listed section socket streams introduced chapter 
automatic flushing association input output sides bidirectional stream called tying requested independent pair streams open input output call tie fd fd fd fd input try common see statement tie stdin stdout stdout stdin input try near setl programs intended invoked pump mode open 
association automatically child process arising successful pump call 
program intended merely filter contrast tie stdin stdout wishes operate line line internally remain 
buffering part setl language specification implementations expected behavior file type stdio library possible 
default stderr flushed character output streams block buffered meaning automatically flushed buffer fills connected terminal device case line buffered flushed output line 
environmentally friendly filters pipes pumps line pumps variant versatile pump stream available mode line pump fd open cmd line pump tty pump difference line pump regular pump environment provided child process case line pump possible line line virtual terminal 
programs including usual unix shells govern behavior output model program user terminal 
significantly standard stdio library uses line buffering sense described section block buffering standard output stream connected line line terminal programs rarely change default 
possible shelf programs cooperating child processes intended filters cost assuming program implementation specifically output flushing policy 
line pump specialized feature probably best avoided code intended ported easily outside unix world handy setting automated interactions programs mail clients 
example easily able unwanted mail messages control robot sent simple expedient having small setl program invoke unix mail client program type deletion command response message environmentally friendly sequential direct access recognized robot 
sequential direct access apart modes create sockets detailed chapter pipe pump modes section signal timer modes described section choices second mode parameter open appeared previous versions setl follows 
synonyms largely sake backward compatibility 
distinction binary modes 
translation line sequences non unix systems expected done external filters necessary older meaning binary input output machine level representation setl values obsolete efficiency advantage modes negligible inconvenience significant 
setl strings accommodate bit pattern required foreign data format coverage needs regard complete mode synonyms meaning rb input text text coded stream input coded binary binary wb output print text stream output coded binary ab append output append stream output print append text append starting coded append binary append file environmentally friendly sequential direct access nb new text new new text stream output coded new new coded new file binary new new binary rw read write input output bidirectional twoway way bidirectional stream rb direct random direct access file wb empty file direct access ab direct access file write nb new new direct access new direct new new direct new file random new new random sequential reading writing names sequential routines current version setl appeared previous versions new ones semantics slightly different cims setl setl course differ get line line 
stdin fd line line 
line line 
wr args fd lhs lhs 
lhs lhs 
wr args getc fd retrieve character getchar getc stdin optional getfile fd characters eof getline fd input line fd characters environmentally friendly sequential direct access fd look ahead character stdin optional print rhs rhs 
printa stdout printa fd rhs rhs 
space separated values line rhs rhs 
print line terminator fd rhs rhs 
printa line terminator put line line 
stdout fd line line 
line line 
rd args fd rhs rhs 
rhs rhs 
rd args putc fd string putchar putc stdout fd line line 
fd similar putc read lhs lhs 
reada stdin reada fd lhs lhs 
read convert values write rhs rhs 
writea stdout writea fd rhs rhs 
print printa write writea take rd arguments type write strings single line spaces represented values 
just print printa respectively leave output line 
functionally identical writea converts values way str 
print printa treat strings special case leave 
put require strings just string argument put behaves print 
read reada read value written write writea atoms produced procedure values produced routine 
reada differs subtly absorbs characters line reading values directed presence wr arguments environmentally friendly sequential direct access pick previous left 
accords historical intent routines 
stood binary mode notion line boundary foreign 
tokens representing input values need separated commas runs whitespace 
identical putc automatically close automatically opened file see section 
puts line terminator newline character unix string writes 
putc terminate lines 
getline operator reads current line file line terminated return line terminator 
input functions operators file encountered characters read call return om 
procedural forms reada assign om unsatisfied wr arguments 
string setl possible read string reads lhs lhs 
lhs lhs 
wr args strictly compatible setl version consumes value denotations requires writable readable 
setl version reads lhs lhs 
roughly equivalent lhs lhs 
environmentally friendly sequential direct access reads read reada tolerate trailing junk characters delimiter terminates denotation needed satisfy writable argument 
see section information 
currently corresponding writes prints string formatting 
arguably completeness quite convenient simply concatenate strings produced conversion primitives section occasions necessary buffer intermediate string forms 
direct access files stream opened direct access modes listed section special operations available employ concept current position implicit file distinction input position output position 
current position explicitly set call seek fd offset offset represents file 
rewind fd equivalent seek fd 
positions offsets measured characters 
setl compatibility environmentally friendly signals timers gets fd start length lhs lhs wr arg puts fd start combine position manipulation note start obeys string indexing conventions corresponding file offset 
gets file reached length characters read lhs assigned string fewer length characters 
gets puts update current position doing reading writing respectively 
signals timers setl programs read high priority signals processes kernel periodic timers 
system specify signals ignored meaning cases relieved duty terminating process 
routing signals timer alarms system making associated streams candidates multiplexed event sensing select routine described section great value helping create small modular processes simultaneously responsive events signals passage time 
signals setl program arranges receive signals type opening stream signal name int term contained case string int term respectively sigterm 
environmentally friendly signals timers full list signal names supported posix compliant unix system obtained kill command list parameter lowercase kill descriptions signals usually unix systems customary way command man signal details available header files normally directory usr include 
section shows send signals section receive process 
start intercepting signals setl program executes fd open signal name signal signal example signal name contain case subsequent signals sent setl process caught setl program lines input fd signal line 
setl program detects signal type sent detection select routine discussed section explicitly receive signal reading line stream file descriptor line getline fd time writing resulting line specified contain null string signal types collateral information may eventually prove useful 
remain upwardly compatible setl programs read lines signal streams 
environmentally friendly signals timers signal type may number streams open line delivered signal type caught 
particular type signal caught streams open signals type may stripped default effect setl process terminate process explicitly ignored fd open signal name ignore ignore signal meaningful thing done fd returned case close 
ignoring stream signal type closed default behavior signal type restored signal receiving streams open type 
receiving ignoring streams open signal type receivers take precedence incoming signals delivered ignored 
timers setl program may open number recurring interval timer streams wall clock time user mode cpu time total cpu time fd open ms real ms wall clock time fd open ms virtual ms user mode cpu time fd open ms profile ms total cpu time ms argument timer cases string consisting decimal digits interpreted number milliseconds supposed elapse environmentally friendly multiplexing select time new line available stream 
timer modes implicit signals prof respectively 
file descriptors returned open signal timer streams pseudo fd existence unix level 
decision route signals timers setl system primarily select section sense timing signals simultaneously regular events 
multiplexing select event driven programs need able wait set events simultaneously identify channels read written blocking process 
setl routine called select select routine introduced bsd unix 
takes tuple sets file descriptors parameter optional timeout value 
sets identify streams may ready reading ready writing ready return error indication 
specific meaning setl environment may assign 
typical call set potentially readable file descriptors specified ready select timeout general case environmentally friendly files links directories ready ready ready select timeout result set ready ready subset lists streams read blocking 
note say characters read fact zero possible file immediate 
similar considerations apply output practice operating systems networks may buffer packets allow program flush output long receiver ready 
furthermore may include file descriptors accept section called blocking pseudo fd signal timer streams section lines deliver 
timeout parameter integer number milliseconds omitted specify indefinite wait low effect polling 
find chapters convenient structure virtually tcp ip server loop select call 
files links directories file descriptor possible recover filename originally passed open available current process string valued expression filename fd routines fd fact original filename case call merely checks file currently open returns filename 
environmentally friendly files links directories possible obtain file descriptor corresponding open file designated name file descriptor integer valued expression fileno fd just checking identity function open file descriptors idiom fd fileno open name 
way ensuring om return open immediately causes run time error 
facilitate setl shell programming role need resorting running external command boolean valued expression string indicates file named contents exists local environment 
similarly integer valued expression fsize number bytes file named string file exists 
ordinary files created automatically opened writing creation manipulation links requires certain special functions 
hard link created atomically routine existing string naming file exists call new names file exist call environmentally friendly files links directories link existing new existing new filenames call existing new equivalent file 
existing exist call new exists error set error see section 
local filesystem link implement test set mutex assuming existing exists new exists operation fail doesn exist created calling process mutex lock releases calling unlink see new 
similarly symbolic link created call symlink new arbitrary string requirement file named exist order call succeed fail new exists 
symlink implement mutex manner link added benefit new pointed arbitrary string 
may example embed information process currently holds lock technique vc toplev setl program listed section 
order find particular symbolic link currently exists filesystem name string boolean valued expression environmentally friendly files links directories 
note applied symbolic link existence file referred link applied symbolic link merely existence link 
name intended represent mutex lock occur code free race conditions 
race free operation sequence requisite test set atomicity clear error symlink id error error lock 
unlink release lock unlink defined process lock 
known name symbolic link associated text available string valued readlink names exists symbolic link exist readlink returns om sets error case applies 
contrast attempt read data fail names nonexistent symbolic link pointing nonexistent ultimately symbolic links point filesystem entries symbolic links limit number indirection levels 
environmentally friendly files links directories unlink destroy hard link symbolic link 
hard link file destroyed unix filesystems file destroyed soon process open closes 
creating file act creates hard link file 
unlink standard routine destroying file unix 
program desire scratch file need declining increase virtual memory sizes 
reside shared public area primary consideration simply choosing unique filename 
unix routine scratch filesystem analogue setl generator nullary setl primitive trailing optional usual uses yield string filename reserved calling program 
current working directory notion supported modern operating system available setl string valued trailing optional changed call chdir routine pertaining file access rights explained section 
environmentally friendly user group identities user group identities routines set useful systems support notion users groups thereof useful systems distinguish real effective users groups 
systems support implemented return act ops uid get real user id uid get effective user id gid get real group id gid get effective group id setuid uid set effective user id gid set effective group id setuid procedure sets real effective user group id effective caller superuser 
effective id set requested value matches real id matches id associated file exec applied prior starting setl run time file appropriate allow set user id allow set group id bit set order permit just change effective id requested identity change performed error see section show error 
call succeeds process acquires privileges effective id idea executable file public setl interpreter allow setting user group id user able execute arbitrary setl programs user group identity attached interpreter file simply inserting setuid call 
environmentally friendly user group identities example superuser process needs able change ordinary user process login daemon periodic process spawning daemon 
convenient user program run user available privileges setuid toggle effective user id back forth users necessary 
example students lehigh university submit programming assignments unwittingly run setl program assumes identity submitter real user id picks files private directories takes identity effective user id owner script setl program launched image submitter files away private area allotted superuser privileges required implement scheme course care exercised designing parts program execute avoid allowing student consume disk space preventing students submitting assignments 
flags attached file depend filesystem hosting file exact interpretation depends host operating system 
filesystem maintains file ordered sets labelled user group set consisting bits labelled read write execute posix routine controlling environmental mask value determines bits set files subsequently created setl program mask get file creation bit mask mask set file creation bit mask environmentally friendly user group identities bits represented octal ed inverse mask determine bits initially set new files 
example user wants new files created read write access user owner read access code user group fr fr environmental file creation mask inherited processes unix shell common built command calls corresponding unix function 
systems mechanism absent setl implementations expected treat op getter return 
octal natural customary choice programmers tend system command normally manipulates bits chmod 
example desired file foo universally executable created octal permissions suggested example done calls system chmod foo merge foo current bits system chmod foo set foo bits fr xg fr xg chmod command subroutine set bits cause effective user group id changed file owner opposed process owner file replace process image exec giving executing program rights file owner ability setuid switch rights process owner 
example environmentally friendly processes process groups want people able update database foo command execute system chmod foo foo allow setuid thee processes process groups open pump stream connected child process process id see section retrieved integer valued expression pid fd fd omitted pid just returns process id calling process unix getpid routine 
existence process expression id tests id process id process currently known host operating system 
true referred process exited status equivalent wait see section 
send signal existing process setl program execute built kill id signal name environmentally friendly processes process groups signal name omitted defaults term 
signal names passed open alphabetic case significant prefix sig optional 
kill allows integer valued signal number place signal name 
id positive taken process id absolute value taken process group id see description signal sent members process group 
id equivalent members caller process group 
id causes signal sent processes caller permission send signals 
user level non superuser processes stands processes owned user associated calling process see section 
signals cause process termination side effects creating file core image final virtual memory state process 
described section recipient may altered default signal handling behavior 
signal kill designed impossible trap way providing method resort arrest processes 
full discussion semantics signals outside scope dissertation unix documentation sigaction function header file gives details 
unix new process belongs initially process group parent 
value trailing optional usual environmentally friendly open compatibility process group id integer 
call sets process group id equal process id time process called establishes new process group calling process leader 
main significance process groups distribution signals 
argument kill routine described section absolute value taken process group id signal passed kill sent processes process group 
convenient trees processes practice orderly attempted 
open compatibility backward compatibility permitted setl ignore result open old cims setl returned true false simply refer open files name originally passed open subsequent calls provided name unambiguous case file open simultaneously child process identified command string wish open 
setl programs treat file handle returned setl open opaque entity immediately portable setl described environmentally friendly automatically opened files change differences observed way values corresponding versions procedures printa 
automatically opened files files automatically opened mode stream input output operation initiated previously name 
auto opened input file file condition sensed stream auto closed 
routine auto closes stream auto opened output making partner getfile environmental filesystem elementary persistent database 
order discover particular stream open result automatic opening successful open call boolean valued expression open applied filename file descriptor causing side effects setting error 
opening streams file descriptors definitions chapter far argument open string giving filename command signal type name number milliseconds integer file descriptor may example inherited produced low level routines listed section 
major environmentally friendly passing file descriptors rw mode section fact obtain setl stream inherited file descriptor knows cares stream bidirectional 
example program lengths setl section 
pseudo fd returned open signal timer stream argument open 
useful feature signal handlers survive exec calls implicit exec section system filter pipe pump stream open section calls 
passing file descriptors normal inheritance file descriptors child processes suffices purposes typical servers child processes deal clients illustrated examples section 
cases convenient able pass file descriptors existing processes 
example httpd daemon optimize performance maintaining pool child processes 
spawning new process new request daemon may pass file descriptor created corresponding connection existing process handling 
passing file descriptors tree processes useful child process appointed perform open related activities result crash 
child process completes extended open operation successfully safely pass new file descriptor parent process crashes harm done 
isolating delicate environmentally friendly passing file descriptors operations small processes limit damage running theme dissertation cf 
chapter sections order file descriptor passed sender receiver share pipe pump stream 
writable file descriptor pd open stream file descriptor fd passed sender executes send fd pd fd rendezvous receiver readable file descriptor pd stream executes fd recv fd pd note resulting fd allocated receiver process space may numerically different fd refers kernel structure 
alias chosen automatically way low level dup routine described section 
mechanism underlying generalized passing file descriptors defined unix time writing versions unix common 
versions alternative mechanism exists available superuser processes 
situation surely improve programs send fd recv fd currently considered fully practical terms 
solaris operating systems full support implemented 
environmentally friendly normal abnormal endings normal abnormal endings normally proceed time call close fd file descriptor fd 
common reason closing stream file condition encountered 
value eof fd true false depending attempt read past input available fd 
fd parameter optional eof call value eof trailing optional true false depending input attempt stream failed file condition 
responsibilities close include flushing output buffer necessary possibly waiting child process complete releasing buffer kernel resources associated system level file descriptor 
permitted apply close file descriptor open operating system level setl level mentioned section 
bidirectional streams direction may closed closing calling environmentally friendly normal abnormal endings shutdown fd predefined constants shut rd shut wr shut 
directions closed way file descriptor remains open setl level 
shutdown cause file condition signalled tcp peer see chapter indicate local process done sending data receive reply 
stevens mentions conjunction unix shutdown routine shutdown calls 
open fails returns om integer file descriptor 
programs need check possibility crash attempt om acceptable behavior 
programs run crashing harm environments case invoked pump streams system filter behavior may acceptable 
possibility notwithstanding reason open tries offer caller chance recovery errors just crashing process initiating access external resources logically expected fail system run file descriptors subprocesses available current process file clients want chance take specific recovery action 
reason caller open chooses check om find rich variety possibilities error environmentally friendly normal abnormal endings yield om return 
setl program wishes issue detailed diagnostic internally detected open failures include value error error message program obtains similar information 
calling clear error restore error default returning error latest value error depend latest setting unix global errno variable system routine 
example low level unix posix interface routines described section express failure setting error setl process 
idea execute clear error just calling routine interact external environment way intends inspect error compare error call 
hand particularly networks involved explicit sockets networked filesystems possible practically regular operation fail main reasons delegating responsibilities child processes software designs preferred dissertation limit damage caused unpredictable communications failures child running pump stream crashes parent simply sees file condition pump stream 
environmentally friendly strings strings ultimately input output reduces communication strings 
importance string handling data processing languages appreciated cims setl setl went powerful string slicing operations introduced set built procedures inspired intrinsic patternmatching functions snobol 
matching regular expression gone step extended string slicing operations integer required regular expression may 
regular expression just string certain characters called meant taken literally act patterns 
sublanguage similar accepted gnu egrep command 
predefined boolean variable magic may assigned false literal special 
magic global variable defaults true setl programmer normally set back way code sequence requires false convenience old magic set magic new magic environmentally friendly strings old magic new magic boolean 
example piece code subroutine set magic local needs restore saved magic set magic false need turned 
pattern matching activity 
set magic saved magic restore prevailing value magic string slicing extensions follows 
string regular expression pattern expression refers leftmost substring satisfies greedy matches kleene star unbounded subpattern occurs 
expression may store fetch positions usual replacing producing substring accordingly 
occurrences value om assigning effect 
regular expression patterns expression refers substring begins leftmost substring satisfying ends substring right satisfying example contains text program assignment 
environmentally friendly strings replaces comment blank 
see consequence fact backslash literal character indicator setl strings regular expression sublanguage 
match actual asterisk asterisk pattern interpreted occurrences suffix operator kleene star necessary double backslash 
produces single backslash string value corresponding raw denotation backslash turn protects asterisk regular expression 
alternatively course magic set false 
desired effect 
regular expressions string slicing useful provide easy way construct replacement strings expressions terms matched substrings 
virtue possessed snobol standard editing tools unix useful plan add capability setl see section 
mark sub gsub split built routines scanning modifying strings help cover need complete patternmatching facility mark integers 

occurrences sub side effects sub side effects environmentally friendly strings 
gsub replaced occurrences 
gsub deleted occurrences split tuple delimited substrings split split whitespace 
pattern argument denoted synopsis 
may regular expression string slicing extensions ordered pair regular expressions behave terms matching exactly slicing form just reviewed 
matter fact integers forms full orthogonality expressions mark 
gsub returns tuple substrings replaced rewrite returns tuple ordered pairs integer indices pair frames substring entirely matched pattern precisely 


information myriad intrinsic operations comprising setl library world wide web 
formatting extracting values routines formatting numbers decimal named functions algol 
string valued expression width environmentally friendly strings represents integer decimal possible leading minus sign 
absolute value integer width number characters converted number manner printf width positive number right justified field width characters negative left justified field width characters 
real integer nearest takes place 
string includes possible decimal point subsequent digits fixed width prec takes real integer width functions exactly non negative integer prec stating number digits follow decimal point 
prec zero fixed omits decimal point fact acts just 
scientific notation floating width prec differs fixed character followed sign decimal digits appended representing power part understood multiplied 
initial segment just digit decimal point 
width specification applies entire string 
integers rendered explicit radix form 
call radix integers radix value radix range produces string form radix digits radix part decimal digits part consists environmentally friendly strings digits radix 
convention letters digits representing values respectively 
examples gamma oz contents strings produced acceptable integer denotations compiled part setl program acceptable read reada reads routines mentioned sections val operators described 
cases sharp sign may optionally appended literal changing meaning 
programmer general purpose str operator system choose format number 
integers decimal string preceded minus sign appropriate 
str occurred cims setl setl 
introduced setl operator approximately inverse str 
produce atom procedure value routine operator 
guaranteed str guarantee digits str produce 
merely implementation advice number significant digits yielded close exceed precision machine representation setl real normally bits mantissa 
environmentally friendly strings programmer wishes determine string consists single valid numeric denotation possible leading trailing whitespace obtain corresponding value val real integer om yield appropriate value 
note identities hold integers width radix range val str val width val radix radix design important difference val val defined return om argument string consist numeric denotation behavior unspecified invalid arguments 
intent setl implementations raise kind exception recognize setl denotation argument 
time writing formally defined exception mechanism setl see section 
checking implementations expected handle kind error manner helpful programmers 
example setl implementation detects error run time highlights source line points relevant token displays subroutine traceback 
order determine string acceptable environmentally friendly strings defined type consists valid setl value denotation om 
exceptions 
printable strings str confronted string argument increases quoting level necessary surrounding string quote marks doubling internal ones leaves characters 
reason may necessary add quote marks string may form setl identifier alphabetic character followed alphanumeric underscore characters 
str identity operators strings content restricted exactly way 
expression pretty formats string characters represented printable characters 
quotes doubled control characters represented setl denotation form shown table characters rendered backslash followed octal digits remaining characters printable left form function audible alarm environmentally friendly strings backspace newline carriage return horizontal tab vertical tab pretty operator encloses result string quotes 
conversely takes pretty string performs inverse operation 
course liberal accept strings pretty produce insist enclosing quotes single double 
operator converts string string having characters printable hex inverse unhex unhex hex unhex returns om argument fails consist number hexadecimal characters decimal digits letters upper lower case 
hex particularly useful instrumenting low level code special string encodings serial line device predefined command protocol 
canon vc system control service described environmentally friendly strings section interfaces perfect example 
similarly unhex easy set low level diagnostic tool allow prober throw arbitrary strings device 
programs vc model setl listed section unhex seen serve trivial welcome purpose facilitating hexadecimal string denotations program text avoiding need escapes repeatedly embedded string literals low level aid readability 
case conversions character encodings expression upper lowercase characters converted corresponding uppercase forms lower obvious complement 
case conversion operators useful string occur input command program subsequent tests map lookups converted string effectively 
cims version setl asterisk overloaded allow string multiplied non negative integer produce concatenation copies arguments order 
example row dashes specified 
environmentally friendly strings likewise yield copies padded blanks necessary left right respectively characters 
cims setl char operator takes integer internal code character returns character string length 
abs operator overloaded act char inverse introduced setl equivalent abs string error string 
date reader note distinction bytes characters setl strings 
effect posix locale defined unix accommodated current design setl characters assumed occupy bits 
language strongly tied assumption expected evolve gracefully support wider characters contemporary localization standards 
areas language compatibility issues arise new definitions largely upwardly compatible existing ones include char operators section hex unhex escape sequences string denotations direct access operations 
characters considered printable collating order strings case conversions decimal point symbol format times dates ultimately locale dependent 
locale changed setl program execution unreasonable environmentally friendly strings dynamic convertibility concerns addressed 
concatenation note defaults string concatenation common operation particularly building output strings 
principle possible require setl programmer apply str value string building string practice convenient programmer str invoked implicitly 
means context type mistakes disastrous strings built sake producing error messages important diagnostic prepared setl programmer missed due gratuitous crash critical type error go unnoticed effects propagated far insistence explicit coding str front non string expression long concatenation 
example expressions evaluate om situation show concatenated string conveys useful information 
happens operator overloaded support om initial value writable left hand operand right hand operand integer real string set tuple case acts initialized appropriate identity element fg respectively 
helpful loops tallies recorded keys map tally map fg 
loop environmentally friendly field selection syntax maps tally map 
loop identity element default statement tally map preceded tally map practice nuisance hard justify need protection failure initialize errors 
expression om supposed equivalent str om value implicit str rule question arises uninitialized mean 
unusual want form string starting converted value om string building expression meant copied questionable unusual want automatic initialization string accumulated concatenation decision easily favor interpretation 
field selection syntax maps pending design implementation type system setl added convenience records setl alas security strong typing extending member selection dot notation address range elements maps domain elements strings having form setl identifiers 
single valued string map identity environmentally friendly time holds 
dot retains normal purpose explicitly resolving member names packages 
case insensitive regime equivalent 
small admittedly dubious extension meaning infix dot originally intended stand allow maps serve easily records proves useful program program communication 
preliminary declarations difficulties representing records various types transit system setl programs pass data maps field may serve discriminant tag indicate fields meaningful 
flexibility offers power discipline corresponds familiar practice javascript resembles model resources windowing system argued pitfalls strengths approach fairly known 
time cims setl setl current date time available date equivalently date 
similarly integer valued time versions variants setl gives term borrowed designers algol describe sequences characters input device correspond symbols tokens programming language 
setl implementation defaults regime similar res reserved word convention algol general support modes including algol upper 
environmentally friendly time number milliseconds cpu time far current process child processes finished waited equivalent wait see section 
new version setl integer valued clock trailing optional measures number milliseconds wall clock time elapsed calling process started tod trailing optional number milliseconds utc 
new ms fmt formats integer argument ms presumed represent number milliseconds moment time date format string fmt 
format optional defaults cent sign escapes defined unix function applied result applying function ms div plus extension expands low order digits fmt decimal 
example sat sep edt eastern time zone 
setl date primitive produced time date implementation dependent format standardized meaning tod 
environmentally friendly low level system interface low level system interface purposes high level setl model embodied filters pump streams automatic buffering process management direct convenient 
occasionally access certain unix mechanisms underlying model desired 
routines described section aim supporting cast utilities spirit names mnemonic programmers familiar unix 
file descriptors lowest level unix facilities creating pipes file descriptor aliases directly available setl 
seldom necessary primitives example section shows traditional tools fork exec wait implement piping child process manner setl pipe stream stream obtained mode 
unix level pipe created pipe trailing optional recommended leaves readable file descriptor writable file descriptor 
file descriptors open setl level open operating system level 
easy open setl stream file descriptor shown section appropriate setl operations available 
environmentally friendly low level system interface close called file descriptor close levels open 
see section information close 
create new file descriptor refers kernel object existing file descriptor calls may fd dup fd system picks fd dup fd fd demand fd case dup system chooses lowest numbered free file descriptor 
second case dup caller chooses desired file descriptor fd system executes close fd necessary alias fd example process wished redirect input inherited file descriptor fd stdin channel convenience execute dup fd stdin fact precise correspondence dup standard unix shell syntax file descriptor redirection 
example dup equivalent shell write 
occasionally contexts low level operations useful bypass setl stream buffering direct calls interfaces fundamental read write unix system primitives sys read fd sys write fd environmentally friendly low level system interface sys read procedure returns string characters 
sys write tries write fd returns integer indicating characters wrote 
call sys write normally wrapped procedure write fd loop sys write fd loop write processes fundamental process creation primitive setl fork returns new process id parent process child 
child essentially clone parent inherits open file descriptors signal timer dispositions process id fork trailing connotes action see vendor specific fork unix manual pages details 
feature fork implementations popular take advantage page modification flags supported virtual memory hardware order defer copying pages cloned data space process writes 
insufficient resources available spawning child process fork returns om 
direct fork rarely necessary system filter pump mode starts child process see sections provide environmentally friendly low level system interface convenient fit data processing needs 
helpful appreciation unix process model setl model built 
process calls fork active child completes clear system record child process id exit status calling wait id wait block block boolean flag block false wait return immediately process id child process exited 
block true default wait earns name waiting child process exit returns process id important side effect wait call succeeds process id way record child process cleared kernel process table 
high level setl operations invoke child processes effectively call wait appropriate time close called pipe pump stream normally setl programmer program exit stage system filter call 
successful wait implicit explicit exit status child process available integer valued status child exited 
note setl program exit particular status optional integer argument statement multiple ibm environmentally friendly low level system interface unix realm things child process working level fork usually file descriptor rearrangement dup replace entire memory image new program exec exec pathname argv envt envt parameter optional absent argv parameter optional 
pathname string optional parameters tuples strings supplied 
default argv taken pathname 
exec return constructs call unix routine execve envt supplied 
see manual pages routines information pathname find executable file argument lists argv envt setl mapped obvious way null terminated arrays nul terminated strings seen program newly launched 
sketch fork pipe dup exec wait close classical unix style provide near equivalent setl pipe input mode pipe create pipe process id fork process id child redirects stdout pipe close close readable side pipe stdout dup stdout redirect stdout close retire alias string name identifies executable file exec name args 
replace process image assert false exec return environmentally friendly summary parent process continues close close writable side pipe process id om 
read child eof wait clear child record kernel child spawned printa stderr fork failed close done readable side pipe see pid process id process existence kill send signal operations described section 
summary chapter covered main needs encounters typical data processing reviewed new features help setl participate meaningfully wide variety process arrangements 
turn attention specifically matters 
chapter internet sockets life internet revolves processes called servers 
accordingly chapter introduces facilities built setl creating communicating governing servers 
setl proves suited expressing servers corresponding clients main goal dissertation show convenient setl servers manage fluctuating sets clients data processing internet 
client server conceptual model huge success point pair processes communicating internet helpful label client server 
course speaking relationships server play client servers 
setl relative roles reflected names open modes create internet sockets 
usual job server wait client requests respond internet sockets clients servers way 
spirit processes fundamental modules data processing system server typically define interface consisting set commands methods object oriented terms independent host operating system hardware source programming language 
server ideal position synchronize access resource long lived process consumes cpu time little memory passively waiting clients 
order remain available responsive client requests times remain immune client induced crashes server usually deal client pump stream see section 
child process associated stream goes due network failure unhandled data exception server merely sees file condition stream 
clients servers clients identify servers host port internet naming convention host part dns recognized name ip address see section 
servers bind port part explicitly identity host providing service implicit 
server host multi homed ip address clients reach service address route 
modes specified open creation client server sockets distinct shown list internet sockets clients servers mode synonyms meaning socket client socket tcp client socket tcp client socket server socket tcp server socket tcp server socket udp client socket udp client socket udp server socket udp server socket list network oriented modes completes list begun sections 
mode parameter open case sensitive 
client open client socket connected tcp server internet host particular port specified string host port host name followed colon port number setl program executes fd open host port socket client socket example complete setl program open tcp client connection port daytime service host cs nyu edu read line resulting stream print print getline open cs nyu edu socket produce host impression current weekday date time internet sockets clients servers thu jul known port numbers generally listed familiar names file services unix hosts port number replaced service name daytime allowing program written print getline open cs nyu edu daytime socket running programs approximately equivalent issuing command unix system telnet command telnet cs nyu edu shall see telnet useful testing servers 
client little unusual file descriptor returned open saved getline 
typical illustrates error checking comparable done attempting open file fd open cs nyu edu client socket fd om print getline fd close fd redundant automatic exit print command name error program print response server connection refused internet sockets clients servers name setl run time interpreter name file containing setl script line executable described section 
server tcp client simply request bidirectional stream connection wait established tcp server able perform quite distinct steps providing service 
able listen connection requests second able accept requests establishing distinct bidirectional stream connection accepted client 
unix interface java api file descriptor listening client specific connection produced accept routine discussed 
listening file descriptor created open server socket mode selected 
argument string consisting decimal digits identifying port number listen server fd open port number server socket listen result call om listening tcp port created 
file descriptor associated listening port call wait new connection request client 
arrives routine unblock yield new bidirectional socket stream internet sockets clients servers fd accept server fd accept client connection connection request arrives interval server busy successful accept managed call accept request queued 
immediately satisfied accept eventually called 
connection requests queued refused 
servers structured spend little time dealing directly clients keeping queue short 
means spawning child process handle interaction 
example server consider sequential server trusts clients read sends immediately delaying blocking service potential clients 
appropriate authentication kind simple arrangement useful resource access serialization 
service just supposed mimic daytime service opening example section client listens port port server fd open server socket listen loop cycle indefinitely fd accept server fd accept client connection printa fd date send current date time client close fd close client connection loop file descriptors involved server fd accept waits client connections fd represents tcp stream created accept client connect 
possible send receive data server fd internet sockets clients servers purpose listen new client connections accept 
conversely accept create listening server socket open job purpose accept create new socket representing server side individual connection client requests return file descriptor bidirectional stream embodied socket 
tcp connection established client server relationship parties essentially symmetric standard terminology called peer 
setl programmer point view symmetry fact complete child process inherits server process socket file descriptor connected client open setl stream open mode socket nominally refers tcp client socket stream generic mode rw suggested section 
doing child process exchanges generality ability enquiries stream listed section 
choosing port number server behave similarly standard port unix vms systems 
port numbers range served processes superuser privileges unix internet assigned numbers authority iana calls known ports 
best known listed file services unix systems associated internet sockets clients servers names daytime port 
ports iana registered ports simply means iana registers maintains public list ftp ftp isi edu notes iana assignments port numbers 
ports maximum possible port number called dynamic private ports iana 
preassigned association conventionally called ephemeral port numbers 
historically unix systems particularly bsd heritage allocated port numbers dynamically range included ephemeral ports unix system 
solaris systems allocate ephemeral ports range 
guarantee general port number available time requested server process port may 
true iana registered port numbers 
new server software strive avoid depending specific port number especially user level software tied known port 
fortunately easily done requesting port instructs system choose ephemeral port number 
assigned number port operator 
example value port server fd immediately successful open server section integer argument open 
sequence internet sockets clients servers setl statements print number range berkeley derived tcp implementation range solaris server fd open server socket print port server fd client socket implicitly uses ephemeral port number connection 
port operator rarely reason 
contrast server may wish know ephemeral port number associated client client host peer port operator described section allows 
primordial question naturally arises client know port desired service currently offered port number arbitrarily chosen server program began execution 
way handling server port number known web server httpd daemon clients initially contact web server find port number desired service web servers listen known port configured fixed port number 
stage technique case study chapter web document template instantiated dynamically assigned server port numbers information response initial client requests 
chapter sake simplicity server examples intended illustrate points fixed port numbers 
internet sockets concurrent servers concurrent servers purpose server serialize access resource available clients times 
example public web server ought able manage connections simultaneously hand responsibility clients equivalent separate threads processes able accept new clients quickly 
section running example called line length server introduced 
actual function quite trivial order obscure issues confronting server involved extended interactions multiple clients 
line text reads client line length server simply replies number indicating characters long input line 
number formatted run decimal digit characters single line 
na server version line length server check errors line length server version nave server fd open server socket listen loop cycle indefinitely fd accept server fd accept client connection fork child process deal client fd line getline fd om loop printa fd line number chars line loop internet sockets concurrent servers normal exit child process parent continues close fd child copy fd stays open long necessary loop server serve number clients simultaneously subject system resource availability problems 
subtle consequence fact file descriptor ostensibly returned accept checked om 
rare occasions accept unblock incoming connection request due number network hazards fail establish tcp connection 
child process crash attempt om file descriptor unfortunate affect parent 
parent crash calls close om rendering service unavailable 
solve problem simply conditioning accept call fd om 
second problem version line length server unix systems child processes return status code parents operating system required keep record status code parent asks wait variants 
start server shown clients close connections ask ps tell processes list child processes finished interacting clients exited zombies technical term processes terminated status codes wait 
eventually system able allocate internet sockets concurrent servers child processes fork start consistently returning om clients dropped immediately accepted 
see section informed call wait setl reflection wait described section order clear zombies process table finite size 
problem underlying need compulsory housekeeping calling wait fork unnecessarily low level function 
fork listed posix interface routines section really intended system level application level 
better way starting child processes setl higher level facilities system filter pump stream previously described 
shell aided server example fix problems checking fd system start child processes background line length server version server fd open server socket listen loop cycle indefinitely fd accept server fd accept client connection fd om convert fd string form command run background system setl lengths setl str fd close fd inherited background task loop internet sockets concurrent servers program lengths setl run background client follows lengths setl convert command line parameter integer open stream fd open val command line rw line getline fd om loop printa fd line line length loop file descriptor inherited child program identified command line starts child 
child string token converted val resulting integer opened bidirectional setl stream rw mode 
trailing command invocation server standard shell syntax indicate shell run command background independent concurrent process automatically receive keyboard generated signals foreground parent 
system uses shell run commands executing instances child program example direct children server shell exits returns caller system immediately launching background process 
unix orphaned processes automatically children permanently resident init process takes responsibility status codes clearing operating system process table terminate 
internet sockets concurrent servers shell independent server wanted avoid shell grounds weak performance argument syntactic dependency happened familiar posix api code line length server way done perl high level approach 
version just adds logging stderr feature line length server version const server port server fd open server port server socket listen server fd om get server port printa stderr port server port error exit status code arrange receive child exit signals fd open signal loop cycle indefinitely wait listener signal input ready select fd fdg server fd ready client wants connect fd accept server fd accept connection fd om got child pid fork child pid child process deal client fd line getline fd om loop printa fd line line length internet sockets concurrent servers loop exit status code parent process continues close fd child uses fd printa stderr child pid started date fd ready child process exited line getline fd take signal child pid wait get child process id exit status printa stderr child pid rc status date loop checking server fd om 
necessary previous versions server server crashed immediate obvious way om value passed accept 
om enter silently set passed select event waiting routine introduced section program simply sleep indefinitely waiting signal remaining singleton set containing just fd 
pump aided server elaborate communication parent child desired reporting number lines characters served hardy posix api go far code appropriate pipe dup close calls 
easier pump primitive take care low level housekeeping 
internet sockets concurrent servers version line length server set keep track pump file descriptors 
need catch signals child termination reflected file condition child pump stream compulsory wait implicit close applied stream file descriptor line length server version const server port server fd open server port server socket listen server fd om get server port printa stderr port server port error exit status code pumps fg pump stream file descriptors loop cycle indefinitely wait listener pump stream input ready select fdg pumps server fd ready client wants connect fd accept server fd accept connection fd om got pump fd pump pump fd gamma child process deal client fd dup stdout stderr shell redirection lines chars line getline fd om loop printa fd line line length lines chars line internet sockets concurrent servers loop printa stderr lines lines chars chars exit status code parent process continues close fd child uses fd pump fd om child created printa stderr pid pump fd started date pumps pump fd include pump fd pumps child created printa stderr pump failed date pump fd ready pumps loop child output child pid pid pump fd process id child child output getfile pump fd child entire output close pump fd close pump stream clear zombie printa stderr child pid pretty child output rc status date pumps pump fd remove pump fd pumps loop loop purpose pretty ensure child output legible part final printa statement child 
normal output just report lines characters quoted string 
child crashes happen client closes connection reading reply line sends server pretty string contain diagnostic output appear stdout dup call creates aliases described section stderr 
internet sockets defensive servers defensive servers server section protects quite careless malicious clients handing child process immediately accepted guard buildup clients get closing connections 
example service time way minutes idle client time ftp 
popular ftp server soon swamp host idle tcp connections command port users naturally tend leave tedious housekeeping details closing connections software disconnecting explicitly 
time monitoring server concurrent line length server tcp connection child process consumes space server host 
want client activity say minutes drop client forcibly necessary 
version line length server shell aided server section parent process instantiate external program new client shell convenience line length server version impatient server fd open server socket listen loop cycle indefinitely fd accept server fd om new client form command fd converted string run background internet sockets defensive servers system setl impatient setl str fd close fd inherited child loop program impatient setl replaces program lengths setl section shall see prevents clients hanging indefinitely 
clients trusted send receive entire lines simple matter select timeout argument minutes impatient setl trusting version fd open val command line rw open inherited fd fd loop cycle eof fd timeout ready select fdg minute limit fd ready fd input eof line getline fd om printa fd line send length input line exit client eof timeout fd minutes exit client timeout loop client send part line getline call block indefinitely 
solution problem shown impatient setl fork worker process deals client monitor process kills process minutes continuous client inactivity occurs 
way works internet sockets defensive servers worker process sends monitor process empty line cycle interaction client 
monitor receive line minutes initially previous cycle sends worker termination signal impatient setl highly cautious version pump fd pump gamma child worker deals inherited client stream fd open val command line rw inherited stream line getline fd om loop printa fd line send line length client print flush stdout monitoring parent happy loop done elseif pump fd om parent monitor continues loop cycle eof pump fd timeout ready select fdg pump fd ready getline pump fd om child exited normally timeout pump fd minutes kill pid pump fd send term signal child presume child exited likewise loop child created printa stderr pump failed dropping client monitoring parent process responsibilities closing pump fd internet sockets defensive servers statements quit loop statements close called explicitly pump file descriptor 
avoid clutter closing left done automatically version logging information cf 
server section omitted 
identity sensitive server security reasons important know identity clients primitives introduced setl name peer name fd address peer address fd peer port fd name address returned strings difference address customary external representation ip address decimal fields range high order part address having fields separated dots name internet primary host name peer connected fd om 
integer valued port number peer connected fd 
argument cases shown fd suggest integer valued file descriptor usual argument originally passed open known current process 
functions primarily intended servers obtain information clients available client sockets return information servers 
case peer port course merely number originally internet sockets defensive servers colon original argument open peer port server inquire client ephemeral port number returns useful way distinguish multiple clients single host 
primary name ip address host current process running obtained string valued nullary primitives name hostname address single host name ip address primitives return sets strings names ip names name address addresses ip addresses name address name address argument optional understood local host omitted 
just single host name map multiple ip addresses host multiple network interfaces single ip address reached local name fully qualified name aliases 
example consider program print ip names birch print ip addresses birch print ip names print ip names genie print ip addresses genie internet sockets defensive servers produces output executed host birch birch eecs lehigh edu www robotics eecs lehigh edu birch eecs lehigh edu www robotics eecs lehigh edu genie eecs lehigh edu association internet host names ip addresses maintained domain name system dns 
setl currently supports familiar ip version ipv emerging ip version ipv forms host names addresses 
dns service typically provided combination information local host particular request knowledge maintained nameservers 
output program ip names applied birch extensive applied genie opposite true application ip addresses multiple network interfaces genie 
modifying impatient setl implement blacklist clients denied service line length server section 
sixth final version line length server shows signal conventionally interpreted servers command re read configuration data 
causes server re read file blacklist line length server version server fd open server socket listen internet sockets udp sockets assert server fd om crash fd open signal catch nasty get blacklist read set names database loop cycle indefinitely await connection requests signals ready select fd fdg server fd ready fd accept server fd om client spawn background command name fd peer address fdg nasty fg system setl impatient setl str fd close fd fd ready caught dummy getline fd receive signal nasty get blacklist re read set names loop proc get blacklist read names clients file return fid id getline blacklist omg proc udp sockets setl provides support udp user datagram protocol 
unreliable protocol include software mechanisms retrying internet sockets udp sockets transmission failures data corruption tcp restrictions message length little bytes needed applications broadcasting multicasting underlies important applications nfs network file system dns domain name system snmp simple network management protocol various noted stevens 
continue prominently modern performance intensive roles multimedia 
strictly speaking udp connectionless protocol program single udp socket communicate host port number convenient udp client programs maintain fiction connection keeping local record server host port number 
modeled setl distinguishing client server udp sockets way argument open specified operations subsequently available resulting file descriptor 
udp client program call similar uses asks tcp client fd open host port udp client socket host name port number string form argument separated colon just tcp 
udp port numbers entirely independent tcp port numbers iana tries register port number udp tcp service offered protocols 
integer representing open udp client file descriptor permitted alternative internet sockets udp sockets host port argument usual 
successful udp open available operations send fd datagram datagram simply string restricted length noted datagram recv fd receives string datagram 
send recv named posix send recv functions 
example program udp analogue tcp client began section fd open cs nyu edu udp client socket send fd send empty datagram print recv fd receive print datagram tcp case opening connection sufficed prompt server return desired information day week udp connection opened sent server 
null string wrapped udp packet sent send server action instance 
fact important practical differences tcp udp message boundaries tcp stream udp packet datagram effectively self contained message complete length implicit setl string representation 
applications reliability concern messages known fit limited size datagrams internet sockets udp sockets occasionally udp convenient tcp rarely case reliability far ignored acceptable program sleep indefinitely waiting reply arrives go confused state due message arrived twice 
situations perfectly possible udp apparent convenience udp illusion programmer write code deal 
udp server socket created way tcp server socket fd open port number udp server socket port number specified open string decimal digits 
operations available kind socket sendto fd host port datagram host port datagram recvfrom fd named corresponding posix functions 
notice host name port number specified afresh sendto call may returned differently recvfrom call udp server socket memory particular client passing datagram 
udp analogue sequential tcp server section 
remarkably simpler internet sockets udp sockets fd open udp server socket loop recvfrom fd ignore input datagram sendto fd date send date datagram loop udp server socket send receive data tcp server socket produce new connection sockets accept client role 
program functionally equivalent udp client example fd open udp server socket sendto fd cs nyu edu gamma datagram recvfrom fd print datagram notion client interesting illustration fundamental difference udp client server setl lack memory udp server 
client disguise obtains arbitrary ephemeral port local machine uses associated file descriptor send empty datagram udp server usual replies information bearing datagram 
worth emphasizing setl maintains distinction udp clients servers restricts file descriptors opened client sockets mode argument open send recv restricts opened server sockets sendto recvfrom 
internet sockets summary summary chapter introduced facilities added setl network communication 
liberal processes seen playing role design methodology handling various functional concerns arise small canonical example line length server 
select started emerge central event awaiting routine servers processes responsive times nondeterministically arriving inputs 
chapter themes explored larger server case study 
chapter webeye case study best way organize system especially distributed system try frame hierarchy command control 
computer systems comprising multitude processes services provided subroutines callers child processes parents servers clients network 
hardware level notion master slave common tendency active entities play role coordinator subordinate transitively aggregates tree global nature systems 
top level unique physically replicated survival reasons genealogical head process tree 
client server relationships induce dependencies processes cross linking skeletal tree 
kind system inside outside interface simply refer box 
phenotype box embodied webeye illustrate webeye case study webeye facilities described chapters harmony liberal processes produce system flexible robust efficient maintainable 
webeye purpose webeye allow browser users aim zoom simultaneously view continuous stream images captured 
user control camera clicking dragging pointer image small widgets adjacent 
zoom widget slider red bar follows user pointing actions blue bar shows amount zoom achieved camera 
blue bar tends follow red rate constrained speed zoom servo motor 
canon vc zoom factor ranges 
pan tilt widget dimensional analogue dimensional zoom slider vc hardware range gamma degrees azimuth pan gamma degrees elevation tilt depicted flat grid 
red rectangle shows requested position pan tilt space dragged moved quickly clicking blue rectangle shows progress hardware moving current goal 
additionally size current field view reflected size red blue rectangles 
size inverse function zoom factor 
precisely width height rectangles show directly grid webeye case study webeye degrees azimuth elevation respectively subtended camera current view user immediate indication part pan tilt space viewed 
widgets real time streaming image pan tilt control simple java applets receive events pointing device mouse equivalent webeye box 
applet maintains rudimentary real time graphical display sends events derived user actions back box 
image production camera control managed box server side webeye 
notifies clients changes hardware parameters accepts requests change parameters 
box supplies clients processed image stream camera independent camera control motion event streams 
box services provided tcp streams 
designed direct convenience java clients general intent 
service supply compressed image data embedded mime documents tested learned standard text telnet client 
example comprehensive camera control service supports commands includes help directive 
java clients box supports browsers netscape primitive way delivering jpeg images streaming server push snapshot mode 
accepts camera control commands implied clicks 
httpd service provided vc httpd setl program listed section re webeye case study webeye sponds requests generated browser instantiates template document port numbers parameters resulting document presents live video playing 
hyperlink associated back httpd service click map causes camera motion new document instantiation 
service box video camera motor control aspect 
video services client point view simplest video service snapshot service snap 
sends mime encapsulated jpeg image response protocol get post request 
browser translate url server host name port number request display resulting jpeg image received 
non browser client wget snap take pictures periodically archival java clients fetch images urls fashion browsers 
closely related snapshot service image stream service push 
intended browsers support netscape server push method playing continuous sequence jpeg gif images contained indefinitely long multipart mime document httpd service just mentioned generates service document instantiates 
sake clients slow network connections cause buildup images route server webeye case study webeye client url carrying supports optional rate parameter measured milliseconds sets minimum time image transmissions 
rate included url rate integer question mark manner parameters supplied browser forms web servers 
unfortunately industry wide standard image streaming browsers appears proposed version java api popular browsers time writing caught version terms built support bundled java classes 
third video service webeye box giver offered transitional workaround deal problem java applets major browsers 
natural interface java clients simple command response handshake sustained network connection 
time client requests image sending command jpeg server replies latest image soon different sent client 
server side implemented just protocol server box 
client side java easy implement api version practically infeasible earlier versions 
convenient possible adopt new api available provide working suboptimal service giver service accepts jpeg commands replies image url client api fetch jpeg image 
url trivial service generates snapshot service decorated sequence number help defeat webeye case study webeye browser caching fully turned internet explorer 
image service box snap httpd 
employs command reply handshaking protocol tcp connection client receives jpeg image response jpeg command response delayed latest image picked server different image sent client 
camera control services pan tilt zoom camera control hardware accepts commands delivers event notifications serial line 
box provides bridge device number internet clients 
comprehensive camera control services camera supports protocol designed convenient programs time mnemonic people best tradition internet servers 
programmers intending write code communicates camera service obtain information need standard telnet client connect appropriate host port number session server sending welcome canon vc pan tilt zoom camera control server 
type help help 
db bacon cs nyu edu 
displayed interactive telnet session window 
help entered suggested response webeye case study webeye commands help command name mode notify fon zoom factor factor outg speed move pan tilt pan ms speed fup left deg ms speed ramp ms show notify zoom move position clear reload setup reset quit null command empty line repeats previous command 
user types help help serious reply follows help gives compact synopsis commands optional words shown brackets grouping indicated braces alternatives separated bars command names arguments case insensitive clarity shown literal names starting uppercase letter 
substitute value possibly hyphenated name begins lowercase letter 
numbers may include signs decimal points 
help command show produces output webeye case study webeye back client asynchronous notification see notify command 
tell piece help ends lines leave final line occurs 
server usage errors protocol mistakes reported help format 
output show consists single line asynchronous notification event message ends easy recognize 
help command name tells specific command 
describes difference help diagnostic output show notify output 
results help notify help show notify turns asynchronous notification 
client get event message formatted command recognized server convenience playback change mode zoom pan tilt ramp zoom pan tilt limit reached 
messages corresponding command formatted similarly added 
catch message canon showing things hardware saying 
notify turns asynchronous notification 
get information synchronously show command 
show commands produce output form webeye case study webeye command fed back server re establish state reported show 
show mode yields mode host mode rc 
show notify yields notify notify 
asynchronous notification event message show result sent client single newline terminated line 
show zoom yields current zoom factor zoom command 
show yields current pan tilt angles move command 
show ramp yields ramp command current ramp period 
output help move move pan tilt ms speed points camera pan degrees azimuth tilt degrees elevation stores current values 
positive means right pan tilt 
range pan tilt 
resolution deg 
angular trajectory shaped parabola suggested ramp period 
angular distance move large maximum speed sustained interval acceleration deceleration ramps constrained optional webeye case study webeye specification 
ms specified server try plan camera motion trajectory takes ms milliseconds 
speed specified trajectory speed limited maximum constant speed interval acceleration deceleration ramps 
units speed speed deg sec resolution deg sec range deg sec 
move pan tilt ms speed adds pan degrees azimuth tilt degrees elevation current pan tilt values calls move 
suppose user enters command notify requesting event notification 
updates hardware settings resulting move zoom commands cause command messages sent clients interested events 
example telnet user client typed command zoom message zoom appear telnet user display 
clients easily record camera control activity playback 
current settings sensed show command example show move equivalently show position produce move camera service little command processing front notice services provided vc setl program listed section webeye case study webeye responsible maintaining high level state bearing model camera acceptor commands producer events 
principle clients general camera service issue commands receive notifications works better things simpler java clients tend multi threaded favor specialized services relating particular responsibilities 
accordingly jumper mover services accept client input consisting purely numbers line build appropriate command send service line 
category mouse service tailored needs java clients essentially just pass pointing device gestures raw mouse maps camera control commands transmission service 
effectively generalization handling performed httpd service previously mentioned 
similarly java friendly services provide interface notice service events delivered java threads simplest possible way 
called 
vc setl program event producing capacity notice service relies pair lower level services notify event linked event received notify broadcast clients event 
webeye case study webeye administrative services webeye designed round clock unattended service mind administrative interface easy people computer experts start check system manage log files 
webeye normally run continuously problems severe cause critical component failure 
example certain forms resource exhaustion heavy load conditions trigger failures 
system large complex appropriate expect unexpected hardware software see section 
unexpected happens webeye best bring cleanly completely hope clearing condition caused failure 
restarted best possible chance survival 
order run unattended webeye able restarted automatically 
means program external webeye observe crashed functioning correctly attempt restart 
vc cron setl program listed section intended run minute administrative user file steps series checks presence correct functioning box 
box appears running principal servers fail give satisfactory responses vc cron setl tries shut cleanly restart 
event recurring failures indications complete success frequency restart attempts decreased powers attempt minutes 
part webeye case study software structure effort avoid apprentice syndrome attempt problem leads problems part effort avoid sending webeye administrator mail failure report sent party time vc cron setl tries restart box 
restarting webeye involves shutting cleanly starting vc restart setl section calling vc quit setl section 
setl section 
program vc check setl section provided programs invoked trivial wrapper commands restart manual style administration 
software structure primary program webeye box vc toplev setl listed section 
responsible starting monitoring stopping programs provide tcp services 
programs descendants clients services box vc toplev setl careful start order respects client server dependencies 
snapshot process tree taken minutes initialization webeye box currently operation lehigh university 
line begins number minutes seconds cpu time consumed far corresponding process 
indentation structure indicates parent child relationships setl vc toplev setl webeye case study software structure setl vc event setl setl vc giver setl setl vc image setl image pump setl vc push setl setl vc snap setl setl vc setl setl vc model setl setl vc seq setl setl vc send setl setl vc recv setl setl vc input setl setl vc httpd setl setl vc mouse setl setl vc mover setl setl vc jumper setl setl vc setl setl vc camera setl setl vc ptz setl setl vc ptz setl setl vc ptz setl setl vc setl webeye case study software structure setl vc setl time snapshot taken clients connected push image streaming service section camera control service section just connected instance indicates caught vc camera setl moment just started instantiate vc ptz setl child process new client setl translator active disappears immediately passing result translation occasionally catch instance setl preprocessor displays 
negative number appearing process display command line parameter passed setl identifying file descriptor read translated form setl program 
user level command line arguments setl placed argument form mentioned section see instances process display vc camera setl passes file descriptor newly accepted client vc ptz setl 
fact number reflects fact vc camera setl closes copy file descriptor created child process vc ptz setl preserves underlying kernel data structure number available vc camera setl client seeks connection 
vc toplev setl started attempts sure run webeye case study software structure ning instances conflict 
mutual exclusion mechanism conservative 
existence lock file atomically created destroyed 
clean shutdown box ends removal lock 
happen due catastrophic failure loss system power uncaught error vc toplev setl lock exists running instance administrator box cautioned perform certain checks separately removing lock restarting box 
see commence procedure 
setl listed section dependencies servers clients services respectively provide including dependencies transitively created relationships major job vc toplev setl analyze source texts comprising box able start servers order ensures client started service depends available 
matter preprocessing setl source programs scanning recognizable patterns indicating relationships interest constructing appropriate maps 
provided consistent idioms create child processes request tcp services reliable trying maintain separate database dependency information hazard familiar makefile users 
dependencies services effectively disappear satisfied services available just starting spawn server processes top level program sets little registry service allow servers publish services corresponding service clients look information services webeye case study software structure particularly dynamically assigned tcp port numbers 
registry place vc toplev setl proceeds start servers outstanding dependencies waiting services box published shrinking dependency maps services appear 
issues warnings services unreasonably long publish 
services come vc toplev setl announces world box ready external clients 
instantiating template html document embedded url refers key port number box 
stores document file redirects certain link point 
link called symbolic link unix special kind file content merely refers file input output performed link file really happens referred file 
link manipulated vc toplev setl name known nearby web server 
known link stages life cycle 
box cleanly points html document says 

box initial process analyzing dependencies starting servers link point static document indicating box initializing transition state 

box fully operational link redirected html document instantiated main webeye port number mentioned previous paragraph 
webeye case study software structure 
box attempt clean shutdown link redirected static document identifying transition state called closing 
normal circumstances box spend long state link quickly redirected cleanly document 
deliberate oversimplification description 
principal interface webeye provided httpd service implemented vc httpd setl service instantiates template html document response click logical httpd implementation serve initial document 
redirection symbolic link atomic operation versions unix link destroyed re created slim possibility exist just moment web server attempts read 
reasons link read directly web server cgi common gateway interface script waits short link exist necessary 
script reads file referred link inspects special prefix character sequence 
sequence file presumed contain static document script serves verbatim 
special prefix assumed followed properly delimited host port designation lookup service 
script uses lookup find host port location httpd service opens client connection 
web servers supply cgi scripts parameters received original request typically arising information url webeye case study software structure script name transmit parameters cgi scripts path info query string environment variables 
cgi script generated system configuration time vc master cgi see section passes url originated parameters httpd service just browser serves httpd returns 
similarly cgi script generated vc cgi section uses lookup service obtain host port locations services needed java clients substitutes template html document serves primary page continuous motion browser interface featuring control applets described section 
template document instantiated httpd refers back httpd service serving initial document web server involved 
web server bypassed entirely user knew port number webeye httpd service listening previous contact having sufficient access webeye private files 
case java interface web server involved long invoke cgi script instantiates page referring applets serve byte code applets 
video services program vc snap setl listed section implements public snapshot service 
checks ignores details required get post request webeye case study software structure client replies mime wrapped jpeg image turn obtains core video server 
defensive public server deals client pump stream connected child process keeps map pump stream file descriptors client information records 
small multiplexing data processing module 
program implements server push service vc push setl listed section 
snapshot server details request 
support optional rate parameter described section 
small multiplexing data processing module deals clients child processes 
vc giver setl program listed section giver service gives urls sequence jpeg images temporary measure pending widespread availability java api supports direct image streaming 
url creates contains snap snapshot service 
image service provided vc image setl program listed section 
vc snap setl vc push setl 
interfaces external program image pump written active captures images converts jpeg format quickly telling parent setl server vc image setl image ready 
server vc image setl intended strictly box 
rudimentary check authenticate client see listing vc allowed setl section 
satisfied dispenses usual need intervening child webeye case study software structure process communicates directly client 
complex program keep little state associated client client start receiving image says ready receive jpeg image new client arrived image pump 
camera control services camera service provided setl program vc camera setl listed section 
program really front larger program vc ptz setl section implements protocol introduced section 
front performs important function making service available arbitrary number clients simultaneously instantiating vc ptz setl client child process connected pump stream 
front server logs information client session distributes term terminate signals receives term signal child processes close connections exit continuing camera service presumably gone 
vc camera setl accepts new client connection passes new file descriptor vc ptz setl command line 
child process deals client directly file descriptor 
interests modularity dijkstra called clear separation concerns vc ptz setl little parse check protocol commands pass local service see vc setl webeye case study software structure form setl maps 
client vc ptz setl requested continuous asynchronous notification events issuing command notify vc ptz setl maintains connection local notice service service provided vc setl 
structuring principles vc setl small program chief concern multiplexing client sessions hands real program vc model setl maintains stateful high level model pan tilt zoom camera controller 
normally vc setl instantiated just vc model setl serial port 
model maintainer strictly sequential completes command passed vc ptz setl vc setl begins 
vc setl minor arbitration requests multiple clients service satisfied 
busy meaning command sent vc model setl replied command received client enter request fifo queue 
client allowed pending request vc setl read command client queue 
clients level get explicit indication command completion service 
jumper mover services designed java clients programs vc jumper setl vc mover setl vc setl listed sections respectively service similar way implemented setl preprocessor define symbols textually webeye case study summary include vc simpler setl section 
gesture interpreting mouse service provided program vc mouse setl listed section uses 
java friendly services provided programs vc setl vc setl listed sections respectively notice service textually included vc setl listed section 
vc setl program logical place provide notice service service direct contact model maintainer low level event service event provided vc event setl 
vc model setl program turn implements high level commands sequences lower level commands hands actual timing handshaking retrying responsibilities pertaining command sequences program vc seq setl happens best position send low level event notifications service called notify 
notify service provided vc event setl program just mentioned works follows client notify event vc event setl distributes event clients event service 
summary complexity enemy flexibility robustness maintainability 
modularity best defense free processes modules illustrated chapter 
processes share memory communicate webeye case study summary passing messages pipes network 
design restriction burdensome practice fits setl value semantics orientation 
ease arbitrary numbers clients tracked setl program works hand hand attention modular design 
keeps programs webeye case study small readable supporting box flexibility robustness maintainability 
efficiency assured isolating cpu intensive image pump program written takes advantage existing jpeg conversion library 
division labor find unnecessary schedule programs destruction labelling prototypes setl programs consume resources compared image pump 
interfaces modules checked external party 
currently corba interface description language idl specifying maps pass setl programs certainly approaching power ada specifications pin interfaces 
wise setl programmer insert redundant checks received map 
minor bit housekeeping compared checking needs done data arriving external sources network language independent setting 
case form piece data usually ensure sense occurs 
subtle extensive checks semantic context dependent 
similarly exception handling mechanism helpful relieve webeye case study summary programmer considering exceptional cases 
extent processes reasonably expected raise exceptions kept small isolated safety net effect exception handling specified achieved modular setl designs 
chapter look things programmer design robust flexible maintainable interfaces programs data processing internet 
chapter data processing world externally motivated programs larger elegant algorithms semantic richness presents tremendous challenges language designer 
kind computing calling data processing 
field contexts diverse science business academic research data processing fundamental computers really computer science study 
involved data processing 
usually happens data gets processed gets copied place 
computation data processing algorithms 
arranging right data processing field data appear right place right time bit challenging difficult mathematical analysis 
fact problems tend open ended psychology users usually reduced cogent proofs 
data processing clear boundaries distinguish forms computing content intensional description embraces 
thesis seek primarily define data processing show setl conservatively augmented remarkably suited roles far described programming 
salient feature data processing tends concerned data interfaces spanning range low level input output formats highlevel user interfaces 
contemporary office information system typically comprise shelf software spreadsheet packages database packages word processors operating systems configured local 
additionally customized elements graphical user interfaces specialized programs relating specific activity organization 
course data components directly indirectly accommodate 
major task data processing programmer provide interfaces components decoding observing data access coordination requirements transforming data formatting presentation sinks 
great rise importance computer networks modern data processing programmer able deal issues surrounding distributed concurrency including latency need redundancy security 
data processing problems solutions come long way simple world card readers track tapes local disks line printers operated batch mode 
increase complexity data processing environments reason high level languages important 
fortunately affordable 
problems solutions intelligent modern programmer faced task designing data processing system try existing packages possible reduce job coordinating large chunks software means relatively small interconnection programs 
programs written interpretive shell language called scripts typically operate highest semantic level system dealing granularity files programs 
shell languages foundations early job control languages 
shell language unavoidable starting point serious computer right age gui programmers memory cheap abundant resource shell languages tended thin lacking amenities lexical structure control structure 
support concept algebraic expression provide little opportunity static checking 
historically goal system designer little possible high level merely data processing problems solutions shell launching pad programs coded efficiency 
surprisingly feel drag history today 
people tend unnecessarily weak shell languages systems programming languages high level languages appropriate show little regard shell scripts 
phenomena probably results fact shell languages discourage programming style 
successful tool starts point exactly situation find shell languages pressed perform designed 
pressure worn tools comes modern data processing scene 
obvious language write small interconnecting programs locally available shell language 
programs small initially conceived minds creators stayed way course simple program weak language grows unmanageable monster earns respect caused considerable frustration 
commonly said choice language controlling influence think programming 
equally true say profound influence think program written operative factor regard care taken programmer program readable place 
course languages writing readable programs easier 
setl particular contribution readability programs written style data processing problems solutions appropriate mathematical character fundamental reusable forms sense literally read loud phrases set universe holds fx jjj exists holds exists jjj 
may idle matters experience setl dual view sets predicates alluded section tremendously important helping programmer stand back look set predicate delineated constraints universe mathematical view move closer look inside see mechanism iterators produce candidate values tested turn accepted rejected algorithmic view 
strength fact set predicate viewed ways mental image created view provides helpful 
similar psychology obtains case iterators jjj readability springs focus expression characterizes members set 
singleton appears degenerate form set enumerated set expr 
expr natural generalization singleton lending readability setl programs uniformity notation 
interesting compare setl encourages high level ways thinking problem solving languages ada strong support defining implementing high level abstractions efficiently 
setl takes minimum fuss approach really offers little chosen abstractions data processing problems solutions foundations mathematics generally free inconvenient restrictions machine level concerns 
ada hand deliberately abstractions provides facilities skilled programmer create high level abstractions running gamut generic completely application specific 
world data processing large part involves small programs setl attractive combining readability conciseness person knowledge system conventions usually start understand setl program quickly getting lost details 
course written ada program quality program probably taken longer write equivalent setl program inevitably longer textually 
place quick dirty realm especially small programs writer need save time reader need get right idea quickly better served minimal high level script exemplar 
programs modules system software engineering teaches achieve clean interfaces comprehensible implementations keeping modules small comfortably 
modern data processing setting fact small program modified confidence large defense shifting user requirements 
furthermore substantial cost advantages pre existing large software components possible dictates strong anti policy favor small interconnecting programs 
rise network slowly main data processing guidelines frame distributed approach ada excellent example language allows coordination issues dealt sacrificing advantages static checking ada really systems applications programming language distinct regarded usually respectable scripting language setl 
large data processing system various languages quite specialized useful various points argues little programs big ones 
tools disposal data processing programmer flexible convenient reasonably efficient robust 
matter implementation language design 
people tend look data processing tools place rapidly impatient obviously high quality scope design language fixated implementation concerns balance foresight accommodate practice data processing context 
motivation setl extensions described dissertation 
guidelines shift attention responsibilities language designer implementer programmer 
data processing guidelines checking practically data processing system forced deal environment foreign input data 
happens programmers armed tools better suited systems programming high level applications face deadlines supervisors take shortcuts coding input routines allocate fixed size input buffers situations know shouldn 
kind bug remains dormant attacker innocent button awakens long input record bites memory isn supposed difficult track 
learn rule ffl unchecked restrictions 
refined little overflows occur forms quite innocent 
correct advice aware overflows possible sure effects understood disastrous 
rule particularly relevant distributed data processing programs tend greater exposure malicious clumsy adversaries subroutines relatively protected environments 
stevens famous introductory text network programming writes remarkable network break ins occurred hacker sending data cause server call sprintf overflow buffer 
data processing guidelines functions careful gets strcat strcpy normally calling 
distinction making ansi routines respectively provide way programmer limit amount data written memory area 
limits best way guard ill effects memory arithmetic overflow sure overflow happen 
restriction isn really necessary worth removing giving closely related rule ffl silly restrictions 
entirely germane input buffer example programmer put appropriate checks form dynamic allocation sure big buffer buffer 
truly wise programmer taken care automatically language setl convenient input size restriction impose 
example input organized kind lines defined local file system operating system conventions statement line getline fd data processing guidelines assigns single line om file line matter line contains characters 
alternative raise exception due insufficient virtual memory 
silent disasters overflowing buffer yielding part input line simply options definition getline 
rule sense highest semantic levels 
lower levels closer hardware restrictions unavoidable need properly checked 
setl level usually appropriate simply pretend restriction exists example 
really saying exceeding restriction rare resource exhaustion event probably treated lines running hard disk space crashing program diagnostic message may reasonable response especially program small module main purpose deal external clients parent setl program sees crash merely file condition file descriptor see section 
language designers obey rule pay principle orthogonality 
extensions setl spirit 
example expression may validly initialize const general loop headers may appear set tuple formers clauses appear single loop header 
restrictions things length identifiers place modern language design course 
language implementers avoid things fixed size tables integers risk unnecessarily restricting program size data processing guidelines number symbols procedures 
unexpected programmer mistakes networks computers crash file systems overflow resources description reach point exhaustion clients myriad surprises ffl expect unexpected 
safety critical systems require heavy investment equipment entirely different approach software design appropriate data processing essentially guarantee need covered working component resource exhaustion absolutely occur best way maximize reliability large distributed system layer module doing local checks fielding failures lower level components 
check fails module path resistance usually throw hands fail completely 
module higher level usually parent process program hierarchy prepared deal failure reason ways child process say fail 
design economy achieved routing various types failure common handling mechanism 
box pattern embodied webeye done having parent processes connected child processes pipe pump streams 
failure natural termination child process known parent data processing guidelines file condition 
parent generally knows doesn care termination expected 
serious errors kind crash subprocess evoke complaint language processor run time system logged 
note parent responsibility usually check file condition input operation take appropriate action may simply fail turn 
file check elided parent setl program content crash immediately trying om value ensuing failed read programming style 
far liberal assert statement recommended highly purpose abend program ostensibly impossible case assertion fails 
component failures obviously lead cascade failures moving chain responsibility 
child processes need aware parents fail path resistance usually child exit sees file condition communication channel parent 
process want cleanup housekeeping exiting 
exit gracefully routine vc exit setl file section textually included components webeye fairly extreme example propagates sigterm signals subprocesses effort give chance shut cleanly ends issuing respond sigterm 
conversely processes webeye children strive remain receptive sigterm times best illustrated routine data processing guidelines called select exit sigterm vc seq setl section 
level design cascade failures reach module attempts form recovery 
main advantage lower level modules recovery code relates variety possible failure causes real systems failure specific immediately recoverable cause best chance clean slate bring failed part system back engendered clearing failed incarnation completely possible 
especially true root cause failure resource exhaustion unpredictable problematic failure modes act removing large subtree processes circumstances may important part recovery frees large quantity vital resources 
clients sequence server examples sections implicitly suggested rule ffl trust clients 
case child process appointed server deal client numerous responsibilities protection denial service attacks resource exhaustion simply part child natural propensity crashing conditions handle 
data processing guidelines child process interposed purely protection communications level 
examine couple general purpose child processes server safe line line communication client 
model doesn matter child process crashes matters server crashes blocked operation main select 
server try read seemingly innocuous single line directly client client send part line pause indefinitely 
similarly server send line directly client client absorb part block 
handle input side connection newly accepted client having file descriptor fd server trivial program merely copies lines stdin stdout flushing stdout tie stdin stdout auto flush stdout read stdin line getline stdin om loop read line eof indication stdout line write line auto flush loop loop ends eof reached program named line pipe setl server start intermediary client follows fd open exec setl line pipe setl str fd pipe notice shell redirect input fd child process stdin 
child receives line client writes stdout connected pipe parent fd 
parent data processing guidelines server ready receive input child read line high speed pipe 
typically fd file descriptors set passed select child attempt write line parent cause select wake return fd set ready reading file descriptors 
output side matters simple 
reasonably expect little program started parent fd open exec setl line pipe setl str fd pipe parent waits fd ready writing sending line certain knowledge child accept line high speed matter long takes child send line slow indefinitely blocking client 
run annoying fact unix pipes fact usually quite welcome performance point view filled capacity sender advance receiver ready receive byte 
result point view senders receivers appear ready receive really 
case means line pipe setl may appear ready receive line data parent fact middle previous line arbitrarily slow client 
solution problem sending child process gives parent explicit indication truly ready receive line fd open val command line get fd command line data processing guidelines tie stdin stdout auto flush stdout read stdin line getline stdin om loop read line eof indication fd line write line remote client flush fd flush client output buffer stdout tell parent re ready loop loop ends eof reached program named line pump setl parent invoke fd open exec setl line pump setl str fd pump notice fd bidirectional file descriptor fd redirected shell identified child invocation command line inherited 
parent wait fd ready reading clear indication reading empty line fd sending line fd 
obvious slight variation parent child protocol child send parent empty line initially write parent including preceded absorption empty clear send line 
parent opened fd fd free close fd 
actual network connection closed child processes released cursory inspection line pipe setl line pump setl shows happen terminate 
process tries write pipe pump stream process terminated pipe signal sent writer 
signal generated attempted output tcp connection closed peer data processing guidelines semantics little complex error indication generated second low level write stream 
normally causes silent termination process behavior overridden usual way call open ignore process normally check errors output operations pipes pumps network connections clear error fd 
flush fd error error output error occurred 
clearly messy business best avoided 
advantage line pump setl addition endowing servers simple output flow control mechanism assists servers just avoidance eliminates need consider pipe signals explicitly 
child process goes parent merely receives file indication child 
situation parent server waits child declare readiness receive line 
child point trying write adversarial client cause sent parent 
data processing guidelines complete picture 
parent communicating client processes just reviewed check file condition fd ready reading 
true fd bidirectional despite name 
done usual way checking om return getline interrogating eof 
file fd usually mean client host network closed connection 
file fd normal behavior essentially means dropped connection led line pump setl child terminating 
cases parent finish executing code kill pid fd send sigterm input subprocess kill pid fd send sigterm output subprocess close fd close fd kill calls redundant harmless 
case kill redundant client left side connection input output open blocking 
kill sure child process trying complete input output operation parent left waiting exit close pipe pump stream involves low level wait indefinite child blocked 
data processing guidelines aliases memory management low level allocation hidden view issue decisions programmer repeatedly copy merely 
languages easier copy 
natural considering languages traditionally designed machine upwards usually takes cpu time copy pointer copy data points 
effect application level programmers tend code copying necessary 
result produce pointer spaghetti ultimately leads bugs aliases mistaken unique pointers blocks deallocated prematurely pointers fail get updated referents moved 
setl hand encourages copying called value semantics 
way create alias setl usual sense variable referring single object pointers se setl 
assignment including directions parameter passing defined full copy object regardless simple number vast complex map 
course implementations free optimize actual copying example change regime 
emphasize orientation usually speak setl objects setl values necessary distinguish value machine representation 
closest thing pointer setl value serves key domain element maps 
map data processing guidelines plays role memory map name mentioned fetch store 
value type key maps fully associative memories unbounded address key spaces 
key space naturally dense set small positive integers tuple serve map memory 
short setl pushes programmers gently firmly direction rule ffl unnecessary aliases 
aliases necessary setl insists referenced specific maps 
effect programs bias far reaching somewhat people lisp background 
major paradigm shift 
lisp focuses map element ordered pair cons cell setl treats map considerable regard human syntactic needs 
represents significant elevation semantic level surprising pure lisp machine language tiny recursive interpreter 
anti alias recommendation believe highly appropriate virtually data processing programs systems programming 
hard imagine tree manipulation package operating system kernel written pointers ada access types 
data processing guidelines accessibility avoiding bottlenecks providing helpful redundancy form assertions sound rules modularization abstraction style emerged young science software engineering just valid applications programming systems programming data processing rule particularly worth specific context data processing ffl data 
words data passes data processing programs represented form displayed basic tools text editors printers natural denotations compelling reason doing 
long time ago justification binary formats save cpu time disk space communication bandwidth trivial inconsequential benefits data processing level weighed inconvenience data viewed special filters 
course formats predefined rule necessarily followed insofar browsers basic tools displaying data rule necessarily mean constrained printable part ascii strictly speaking print class characters posix locale defined unix probably desirable image data images best choice 
data processing guidelines setl actively supports bias favor printable data 
repertoire facilities deciphering formatting arbitrary values strings section features pretty operator section produces printable strings exclusively general output routines render values interfere necessary contents strings 
routines getchar getfile putchar interfere ensuring bit pattern read written necessary 
case pure setl programs exchanging data writea reada perfect reciprocals making data stream ideal place probe testing instrumentation purposes 
similarly programs designed communicate line line protocol typically incorporating simple command language printa formatting sending messages corresponding receive message line parsing interpreting 
mode operation especially appropriate communication servers usually need able defend clients 
primitive tool general telnet tcp client perform basic tests command oriented server 
program size large complex data structures just values setl passed setl program ease primitive writea reada operations just mentioned 
facilitates division labor data processing guidelines small programs large ones hints rule ffl monster programs 
nature modern data processing extent involves done programmers flexible attitude languages configurable theshelf software pressures programs small 
conversely large populations processes modern hardware removes efficiency obstacle treating programs plentiful resource 
furthermore relatively high walls protection provided modern operating systems processes suggests programs may ideal modules objects 
practitioners object oriented programming speak method call originally defined literally message passing operation 
numerous advantages programs fundamental modules data processing systems 
program written language appropriate call conventions usually constrain choices severely single program case 
second independent threads control help avoid bottlenecks ward syndrome single program trying juggle multiple activities 
third shared resources tend guarded supervisory processes managed global variables course careful programmer things private package accessible indirectly subroutines 
regard motivation copy data clearly strong setting processes resources data processing guidelines shared need 
standards goes saying adherence recognized standards internet protocols mime compatibility prerequisite practically new piece software hopes deal global public network confining api shell utilities defined unix posix feasible lend high degree portability 
specific rules followed compelling reason 
rules established practice 
port number independence recommended section illustrated section servers strive independent specific tcp udp port number 
risk making impossible service offered happen port number program 
condition persist indefinitely program server 
server critically depends obtaining certain port number fundamental servers web servers port number registered iana guarantee availability 
server chances getting port number wants data processing guidelines improved having started soon host comes part system initialization sequence 
configuration installation little effort part software developer package easy configure install maintain save person responsible installing administering significant amount trouble vulnerability mistakes 
true software package especially large complex systems require configuration decisions 
regard important rule provide step step installation procedure offers reasonable defaults opportunity override clear documentation places software package target platform 
installation script quite helpful 
principle follow try minimize reason number dependencies specific files resources target systems 
example software package may comprise large number programs configuration files default grouped directory name serves common prefix practicable 
prefix particular system files need inserted modified entire extent package footprint apart space time ultimately consumes course 
convention deserves special mention servers concerned matter sensitive configuration changes requiring data processing guidelines stopped restarted 
fortunately unix tradition answer question server accept hang signal request re read configuration data 
example inetd called super server running virtually internet aware unix host re reads configuration file services signal sent 
server structured event loop section behavior easily implemented including signal stream file descriptors passed main select invocation 
event loop setl program waits nondeterministically inputs source calling select 
example simple server vc snap setl listed section discussed section typical maintaining map pump file descriptors client records 
pump stream connected child process deals particular client 
domain map set pump file descriptors passed select file descriptor socket listens new client connection requests 
entirely typical arrangement server delegates long term subprocesses gets back main job sleeping select call quickly possible 
server events concerned signals telling re read configuration data timers telling periodic checks file descriptors signal timer streams included set passed select 
data processing guidelines personally find comfortable select appearing naked overt main event loop prefer callback style programming easily accommodated 
suppose fd map global map pump file descriptors records contains handler field designating unary event handling routine fd ready global set valued variable 
setl main program programmer wishes consist initialization final call routine proc process events var fd local loop cycle event handling routine executes fd ready select domain fd map set fd ready iteration fd fd ready jjj fd fd ready loop call fd map fd handler fd indirect call loop loop proc incorporated verbatim programs include preceded desired define lines rename fd map fd ready 
registering event handling routine named say client input done register fd routine client input procedure register defined follows data processing guidelines proc register fd callback routine fd map fd fg establish new record necessary fd map fd handler callback routine proc de registering callback routine fd done procedure proc fd fd map fd handler om caller may remove record fd ready fd remove fd transient ready set proc usual manipulation global variables apply callback routines sensitive callbacks variables 
process events odd looking loop header fd fd ready jjj fd fd ready inspects global fd ready set modifies 
loop header sure fd produced fd fd ready iterates copy fd ready global variable fd ready corresponding loop iteration occurs 
time previous iteration de registered file descriptor associated event handler fd map inappropriate try call event handler 
may appear glance circumstance dealt gracefully simply guarding fd map fd fd map fd handler om data processing summary offer protection case file descriptor retired callback close executed callback subsequent callback open unix yield closed file descriptor system level open call 
file descriptor mistaken older incarnation inappropriate processing performed 
really new file descriptor entered set candidates supplied select appropriate processing point 
notice performing fd ready fd register appeal symmetry exactly equivalent making oversimplification 
webeye main server loop typically select call domain clients map listening server socket semantic subtleties kept bay adhering principle code return select operations may shrink clients map precede may expand 
example tests input existing clients cause shrinkage clients map clients terminate connections indicated file condition input file descriptor placed test newly connecting clients increase size clients map 
summary chapter tried case high level language internet data processing feel useful rules software design data processing summary kind environment indicating setl particular supports software engineering methodology obeys 
chapter strengths setl data processing language follow largely properties language high level algorithm description prototyping encourage adherence programming guidelines chapter particularly advocates employing plenty processes reflect typical data processing environments convenient predefined interface commonly parts unix allow setl serve highly competent glue language interconnecting programs written languages 
case study chapter shown general purpose setl facilities operating system interface miscellaneous extensions described chapter sockets network support described chapter modularity small high level programs produce system comprehensible robust maintainable 
systems concluding chapter review systems discuss needs apparent particularly area types 
systems written server systems setl date 
small trivial desirable server hierarchy box system 
necessarily larger 
example box intermediate size pwm toolkit 
business sends commands serial line program pc cum microcontroller generates effective voltage control signals subset pins parallel port direct pulse width modulation pwm carefully timed rapid toggling 
drive spherical pointing motor bridge switch 
pwm toolkit supports possible methods modes signal generation involve dependencies pins 
controlling various basic quantitative parameters pwm toolkit generate time varying envelopes including cyclical patterns parameters maximum minimum frequency phase 
pwm toolkit may telnet clients command line interface help command conveniently gui client uses interface server presents user master window zero de systems tail windows depend selections master window 
windows created governed wish shell process reads dynamically generated tcl tk command scripts 
widgets created scripts originally specified templates consisting nested tuples setl program horizontal vertical layout gui elements nesting level controlled level odd 
wish process attached setl program pump stream 
tcl tk commands issued setl program stream build destroy update widgets inputs user pwm toolkit server 
widget user manipulates control sends information setl program pump stream writing short message widget sees standard output stream wish process main way setl program receives user input keeps debugging stream open users enter arbitrary wish commands merely passes 
web clients interface known view foveated log map image implicitly communicate pwm toolkit server controlling effective pan tilt voltages supplied spherical pointing motor miniature mounted 
clients issued notify command server receive notice parameter changes 
gui clients automatically issue command startup interesting useful effect causing sliders controls associated clients change state automatically real time user point view clients modify parameters controls 
systems possible users get tug war dragging similar controls opposite directions 
keeps server busy changing parameter values causes real harm hardware device difficulty rapidly changing effective voltage levels 
system just mentioned web interfaced service wrote called respects similar webeye chapter 
really described simpler webeye 
example ability manage filter cache variety live stored image streams simultaneously features calibration procedure interpolating pwm values aiming purely convolving image samples corresponding various pwm settings 
allows user control view patterns oscilloscope bi color leds browser interface server indirectly commands basic stamp turn controls circuit construction 
systems acted proving grounds setl process intensive techniques outlined dissertation 
richard wallace box approach setl prototype alice artificial intelligence 
primary interface web browser communicated server written setl 
server spawned child process read client input send mime wrapped html code reply just httpd interface webeye 
best modular tradition boxes original alice filters pump streams invoked setl server main natural language processing 
user input systems strings interpreted commands move alice played client camera control server side embedded video server aspect html sent client browser order serve user picture usually live textual response prompt input 
idea embedding html sent client presumed browser back server generated html server turn client html generator webeye alice 
fact kind self original nyu 
similar spirit cgi script bypasses need full fledged web server involved step fairly longterm interaction 
general principle appropriate web page designed lead user similar page times 
setl processing web requests began cgi scripts feel useful role 
example rudimentary comp lang ada interface service wrote visiting alfredo ferro colleagues catania moderately useful speed limited network environment prevailed time earliest tests sockets setl termed tcp version current set setl library extensions network programming 
famous original setl server accessible home page years server tcp ip sense simply general cgi script allows user run setl program interoperability entering directly text sub window web page giving url program 
similarly run time inputs setl program supplied ways 
setl program runs web server host delegate thereof run restricted mode prevents abuses arbitrary files 
administrator setl server allow guest programs latitude opening client sockets configuring set host port combinations foreign programs allowed connect 
mediated support secure restricted mode built setl implementation 
interoperability far important kind interoperation code written different languages occurs pieces code fact entirely separate programs linked communication medium 
especially true processes abundant resource easy reach powerful general modus find tends remove need interoperability high level languages setl lower level languages largely differences data representation languages unequal level 
differences require data conversions introduce potential error inefficiency clutter 
conversions occur inter interoperability face call 
conversely interfaces kept narrow practicable fundamental design principle high walls processes welcome form protection memory corruption setl program running correct interpreter impossible guarantee arbitrary library linked 
furthermore language split sake access optimized low level code process split allows computation moved easily different processor faster user workstation 
occasions genuinely useful able predefined library fortran ada routines directly setl typically graphics 
usually really wish write new code foreign language case write implementation language setl interpreter integrate 
just wants interface library terms natural setl 
question arises effort worth build thick setl oriented binding library compared nearly mechanical generation thin binding may require considerable accommodation library needs setl programmer 
answer depend transient need particular library judged 
jack schwartz indefinitely transient need facilities macintosh toolbox contained routines 
setl ported mac multiple processes standard environment platform available years come 
jack help gener interoperability ating thin setl interface toolbox 
setl callout interface exceedingly primitive calls routed single routine kirk snyder refused allow access setl source code days 
partly reasons mainly due fact great parameter types needing conversions kind part interface quite bulky running lines mechanically generated code 
setl programs scripts wrote generate interface helpful redundancy pascal header files source files containing declarations meant incorporated user programs 
header files convey information distinguish value parameters result value result parameters asterisk indicating pointer appeared appearance var corresponding pascal declaration supplied needed discrimination special cases 
nowadays discipline headers calls const allow programmers distinction glance common practice authors macintosh toolbox 
setl setl interfaces generated years 
griffin group generate setl interface graphics library 
eventually generators led reasonably procedure customizing setl interpreter thin interfaces libraries described headers 
interfaces personally useful date graphics libraries glut mesa implements simple event windowing system essentially complete realization opengl 
interoperability customization procedure fully automatic information pertaining library interface contained header files 
decisions correspondence structures setl objects consciously 
goal customization principally extend setl library thin interface acceptable rare goal produce setl package containing wrapper routines definitions 
done production makefile associated scripts build files fit structure setl distribution package way inclusion customization selected configuration time preparatory compiling installing setl system 
similar vein fairly powerful package called simplified wrapper interface generator developed dave purpose generating interfaces number languages functions variables information kind declarations header files 
currently scripting languages tcl tk perl python fully supported partial support eiffel java 
course best customization procedure ad hoc interface generator ultimately properly formalized foreign language interface 
requisite sublanguage able describe external entities precisely specify translate setl entities 
low level languages deal directly representations low level scalar types memory layouts sub interoperability language accommodate observe restrictions attend 
languages currently systems programming ada stands able express specifications way simultaneously convenient comprehensive precise 
accordingly proposal 
setl badly need respectable implementation small semantically straightforward language 
believe ideal way write formal specification describe syntactic constructs expansions ada code describe run time objects ada specifications 
bodies description obviously dovetail meta rules developed discipline form basis describing setl extensions including foreign language interfaces 
interfacing sublanguage nominally fit style setl ada suited kind descriptive role setl forms ought translate directly ada 
fact reasonable contemplate line ada construct setl ada play central definitional role 
relevant experience regard system built years ago called setl successful entirely satisfactory implementation setl describe setl objects 
line feature worked perfectly somewhat hard eyes 
unsatisfactory relative weakness specification language ultimately able templates bidding 
types practical terms greatest obstacle having setl take coded interpreter setl implementation unreliability compilers problem continues day 
ada hand probably ideal interface specification language existence gnat robust compiler currently available time ada setl ada ed ada gnat specify implement world truly robust setl system 
types probably area advantage ada specification language setl clear area types 
general observation design types requires higher degree care professional experience virtually aspect program design 
evident time parade versions java api standard library ada packages appeared years especially generics 
types play pivotal role large system 
core depends ways foundation think centrality fair consider design realm systems programming applications programming 
setl hand belongs sphere applications types tried illustrate dissertation best suited small programs 
furthermore maps tuples serve informally main purpose types package data objects 
maps tuples support formalized abstraction fact values convenient packets pass routines embody abstraction 
foregoing helps explain absence type system setl uncomfortable language ada aims support programming large systems applications level 
see similar phenomenon textbooks algorithms focus mechanisms organizing large bodies code 
variables declared example seeing immediately tells map array presence indicates object attribute record 
genericity expressions extends scalars fact matter kind number number 
reader take appropriately view seen involved arithmetic expression requiring specificity 
unfortunate setl follows tradition textbooks point making difficult manage program significant size non intrusive type system setl welcome 
main aspects done 
type declarations available remain optional important compiler human reader program unit come types understanding right outset marked strong variable formal parameter declared marked weak default undeclared variable implicitly var just current setl 
programmers writing new code course gently encouraged declare program units strong gain advantages type checking possible run time efficiency improvements cases add clutter 
second aspect non intrusiveness setl type system rob language essential simplicity 
pains point design core types challenging systems programming activity began section asserting ada advantages specification language setl 
think extreme position introducing new types setl program slipping ada ada declarative forms defensible ideal approach far extreme 
feel setl acquire simple forms defining extending record types specifying subtypes ada constraints 
forms obvious ada 
difficult say stage strictly guided need order avoid inventing myriad declarative forms setl marginal utility 
starting point add setl ability state type named described piece ada code 
tagged types visible setl limited private types visible setl operations described ada routines types conceivably specified pure ada 
meets requirements setl type quite restrictive stereotyped doubtless including unstated semantic promises admitted visibility setl level 
operations apply setl types type operator undeclared setl variables able change types dynamically notwithstanding fact part purpose type system help programmer constrain group appropriately 
dynamic dispatching routines fully type constrained formals certainly available 
upshot need essential features setl variables derive base adt ada encapsulates descriptor stub operations setl variables inherit 
issues surrounding types touched syntax typed variable declarations setl type variable declarations need remain segregated statements integrated algol scopes interactions package structure child packages generics inheritance multiple types dynamic dispatching multiple argument types communication typed values programs possibility representational hints lines old setl repr clauses 
string handling string handling remarked section extensions setl string slicing subscripting forms allow selections basis patterns described regular expressions magic true functions sub gsub mark split likewise accept regular expression patterns proven useful right sub gsub assigning forms lack means refer matched substrings conveniently construction replacement strings 
way done standard unix editing tools effectively support pattern forms take backslash escaped zero replacement string mean entire matched substring take mean substrings framed pattern backslash escaped parentheses replacement string refers kth framed pattern 
backslash escaped parentheses matched characters subject string nested numbered left parenthesis begins pattern 
snobol subsequently mts editor allow variables assigned side effect pattern matching providing syntax associates variables directly subpatterns 
immediate value assignment form causes variables assigned course matching process conditional value assignment defers assignments matching complete assign string handling ment pattern fails match subject string 
generally practical reason preferring conditional value assignment efficiency originally probably wrongly cited 
case resulting values variables available constructing replacement string subsequent purpose 
snobol pattern matching general 
example fully backtracking deferred value expressions embedded function calls incorporated patterns 
suite predefined patterns pattern matching functions 
substring starting positions substrings assigned variables matching 
regular expressions introduced setl familiar unix users ideal pattern matching facility setl integrate snobol ability incorporate matched substrings expressions defining replacement strings 
immediate value assignment setl variables need arcane error prone backslash escape conventions replacement strings regular expression regime unix editors strings able constructed powerful means 
patterns logically form distinct type values produced certain functions operators 
example exclamation mark 
binary operator takes pattern argument left arbitrary assignment target right string handling yields pattern evaluated course matching assigns substring matched snobol immediate value assignment 
operators overloaded types serve primitive patterns string ordered pair strings consistent overloading sub routine pattern matching function 
sign unary operator takes arbitrary assignment target produces pattern matches null string assigns cursor position string index current location matching 
corresponds snobol primitive operator 
primitive functions worth borrowing snobol 
example take pattern argument string serve pattern return pattern matches zero occurrences functions pos rpos take integer argument match null string matching cursor currently characters string respectively 
unary break len span appear setl binary functions available pattern producing functions 
unevaluated expressions snobol useful sorts patternmatching situations approximated readily 
extra syntax tuple element routine serve pattern subsequent elements evaluated prior matching passed arguments routine pattern encountered matching 
asterisk similar sig string handling unary special form appears global function name followed parenthesized list arguments 
equivalent routine 
produce actual pattern just tuple serve pattern 
likewise pattern equivalent routine routine 
reason insisting arguments intended foregoing evaluated pattern expression constructed matching invite dynamic scope violations patterns certainly constructed yielded functions 
global function name function names current version setl 
asterisk notation easily extended apply global variables defer evaluation pattern matching time 
nesting course perfectly feasible 
pattern matching functions yield match pattern matcher point view 
advance cursor succeed 
ways user defined pattern matching functions stereotyped order map behavior 
example subject string cursor supplied parameters predefined variables system pushes pops necessary accommodate pattern matching nested function 
function indicate failure yielding om success yielding number characters matched yield matched substring success 
alternatively function predicate advancing cursor yielding true string handling success failure leaving yielding false 
shelf predicates patterns match null string allow matching continue success match cause pattern matcher back seek alternatives failure 
existing setl operator symbols operations pattern concatenation alternation 
alternation new symbol overload old concatenation surely done strings concatenated 
raises slight problem plus sign tuple concatenation tuples serve patterns concatenations sense patterns 
reason programmers encouraged write code free hint ambiguity pat operator converts argument pattern complains 
expressions string pattern equivalent may read proposal replacement string important specify setl semantics previously left open evaluated 
clearly immediate value assignments produce values constructing replacement string evaluated 
note specified part forms evaluated assigned 
value effectively copied temporary initially 
matching performed substring replacement performed result copied complex statement exceptions 
equivalent temp temp 
temp expression defined evaluated twice programmer beware unintended side effects 
best policy ensure side effects consist assignments occur twice equivalent effect 
runs semantic assumptions interferes optimizers 
exceptions common exceptions provide kind safety net deal errors major problems resulting propagation erroneous values wholesale crashes 
argue exceptions purposes despite temptation programmers variant goto 
hinted near chapter exceptions important setl languages 
certainly true various ways crashing setl program ranging systemic errors running memory errors trying read non numeric denotation number 
exceptions emergence setl type system introduce possibility constraint violations errors 
handled gracefully isolating vulnerable code kind code normally placed protection exception handler little process attached parent pump stream 
child crashes parent merely sees file condition crash parent 
subprocess offers level protection denial service attacks clients try hold connections open indefinitely see section 
observations order demonstrate superfluous merely suggest absence tremendous burden 
fact remains exception handling facility positive addition setl 
attempt lay detailed design note resumption semantics need seriously contemplated setl 
exactly exceptions identified probably specified satisfactory type system designed potentially delicate semantics initial transfer control equivalently met situation expr block contained expression tuple example expr block executes goto expression yielding value 
miscellaneous desiderata miscellaneous desiderata numerous minor features added setl sake enhancing excellent support internet data processing greatly increasing complexity language 
mention 
lexical nesting routines procedure operator definitions nested setl procedure nesting allowed setl 
little consequence small programs software engineering point view strictly speaking routine purely helper routine ought private convenient way arranging lexically contained notion extends variables constants routines setl improved allowing names declared locally control structures algol 
rarely keyword imported algol extension sake doing framing local scope 
feeling setl follow lead algol allowing declarations occur statements occur 
name bound declaration referenced remainder scope 
setl special proviso name binding applicable current scope occurs default declaration taken innermost enclosing routine main program unit miscellaneous desiderata considered routine purpose 
declared scope standard rule says referenced scope point declaration apply 
filename unix shells able create lists filenames patterns universally include asterisk wild card matches run characters 
standard unix shell unix shells support patterns question mark 
match single character bracket enclosed run characters match character run brace enclosed fg list strings giving set alternatives 
example files foo foo current working directory see chdir section patterns foo foo foo foo fc og stand pair filenames 
notice characters special significance called convention meaning different obtains regular expressions 
setl appropriate realization feature introduce glob operator accepts string containing pattern obeying conventions unix shell yields possibly null tuple strings representing filenames match pattern 
shells behave similarly identically pattern match filenames standard shell simply leave pattern unexpanded shell issue diagnostic abort process miscellaneous desiderata constructing list tokens form command 
shells quoting conventions allow special characters normally expanded filenames 
programs access filenames course achieved simply 
glob function appeared posix specification part unix function tests single filename see satisfies glob style pattern 
provision roughly equivalent setl primitive appropriate main vendors unix systems caught potentially helpful functions 
word expansion shell sense dovetail kind filename expansion abbreviations user home directory names simple expressions familiar shell users easily accessible need convolutions fred home split filter bash echo fred obtain home login directory name 
format directed convenience especially valuable lower level programming languages format directed fortran library standardized posix unix algol 
cobol pictures sophisticated formatting features popular programming language 
setl functions fixed floating section get names algol routines miscellaneous desiderata interesting property symbolic expressions format strings algol system 
need format directed high level languages lower level languages easy build strings manipulate values 
formats tend arcane little sublanguages cases separate expression output variable input description appearance quite widely making correspondence difficult discern 
formats quite useful concise encoding complex output layouts dealing highly structured inputs particularly tend reflect layouts pictorially 
experience algol language high level handling strings rich set primitives formats sine qua non tasks preferred long concatenations string forming expressions 
setl effort years remain compatible unix moving definitely slowing target decade natural choice format sublanguage strives remain close callable printf scanf series 
assessed serious detail 
related format conversion issue arises dates times 
primitive described section render number milliseconds utc date time current time zone utc currently corresponding primitive formatted date time apart miscellaneous desiderata constituents manner unix routine recombining parts single integer representing time manner 
high level internet protocols strengths java api support internet protocols level udp tcp ftp third party sources smtp nntp 
url connections opened associated mime header information fetched set method calls object representing connection 
setl communication accomplished package setl routines imported setl program wants 
urls probably going long time convenient natural communicate entities addressed urls modes url url url directly supported open 
modes participate handling data streams simply passing data fairly serious design needed 
example mime headers appear map manipulated mechanism getenv section 
non protocols ftp specified urls treated 
open problem fact suggests viable solution modular support protocols things distributed file sys fringe tems database systems transaction management systems mediated add modules 
fringe number features appear glance desirable setl really 
pointers obvious example pointers explicit pascal ada pointers tied machine memory model permit arithmetic implicit java snobol 
lisp family lost 
pointers useful construction data structures various languages programmers may wonder earth get 
obvious answer maps 
aliases useful remarked sections avoided compelling reason 
situations aliases genuinely appropriate maps ideal general structure allow keys selected basis semantic content forced opaque nodes integers maps virtue clearly identifying context map lookup occurs map separate address space 
fringe languages pointers include pointers variables 
scheme ease data converted code run time produces similar effect 
java pointers objects eliminates class alias 
add pointers variables setl completely destroy value semantics 
add pointers objects unwise maps best serve required purpose high level language lost gained burdening setl programmer need keep track distinction object object 
feasible insist userdefined objects kind status accesses 
unacceptably different setl fundamental aggregate objects sets tuples strictly values 
closures continuations addition setl closures generally continuations scheme sense 
consider creation procedure values routine pseudo operator provisional measure deprecated despite fact indispensable escaping event loop section callbacks 
interest cautionary note regarding manipulation global variable example 
closure preserve local variables destruction normal span fringe state variables inspected updated closure invoked 
closures similarity pointers holder closure effectively possession set variables 
worse number variables ordinary procedure values refer bounded number global identifiers program limit closures 
pair lambda expressions example number times produce new pairs closures pair referring variable different activation record 
closures case poor substitute way bundling data means access manipulate objects 
callbacks better treated java style implemented procedure values closures 
lightweight multiple inheritance available java object repeated implements allows register callbacks object recognizes appropriate interface simply defining methods names signatures required interface identifying object calling appropriate registration method 
threads fine grained concurrency dissertation argued liberal processes hope case study chapter begun demonstrate value 
processes enjoy high walls protection alluded section share resources share usually mediated third parties server fringe processes 
contrast languages encourage threads processes sharing variables local address space create synchronization concerns programmer remain constantly 
java ideal language introducing concurrency attendant problems courses far graduate course advanced operating systems senior undergraduate course network programming junior undergraduate course programming languages elements thread creation synchronization signalling packaged java allows students proceed rapidly stage learning difficult concurrent programming correctly 
rare find student program synchronized keyword completely appropriately race conditions entirely safe deadlock 
pointers closures issue resource sharing multiple parties 
case parties threads party time making access common resources parties interleaved literally concurrent manner 
apart disciplined programming best defense enormous challenges raised need deal possible interactions simultaneously executing threads minimize interactions 
model offers convenience shared access data naturally visible threads works minimization 
fringe reason considering problems defining implementing setl system correct reasonable job code optimization am opposed kind threads setl allow sharing global process local data 
currently objects setl processes share access external designs processes 

conversely threads particularly useful setl 
messagepassing processes worst heavier mechanism strictly necessary situation certainly sufficient base implement semaphores monitors 
example suggested doug lea bounded counter study pp 
monitor counter counter easily bounded buffer implemented process accepts increment requests producers decrement requests consumers server sockets 
requests serviced immediately possible requester blocked run unix setl dmin dmax var counter min min effectively defined command line var producers fg clients awaiting increment var consumers fg clients awaiting decrement sock open server socket listen producers dec sock open server socket listen consumers port str port sock advertise producer port dec port str port dec sock advertise consumer port fringe loop cycle indefinitely ready select sock dec sock ready producer increment request fd accept sock fd om counter max satisfy request immediately counter send counter value client fd notify waiting consumer counter max defer request producers fd dec sock ready consumer decrement request fd accept dec sock fd om counter min satisfy request immediately counter gamma send counter value client fd notify waiting producer counter min defer request consumers fd loop refinements notify waiting consumer fd consumers pull arbitrary fd consumers fd om fringe counter gamma send counter value client fd notify waiting producer fd producers pull arbitrary fd producers fd om counter send counter value client fd subprogram proc send counter value client fd printa fd counter tell client new counter value close fd proc program exercised conveniently running instances programs desired 
simplicity assume run local machine directory monitor communication uses full fledged tcp sockets easily run monitor actual host name port numbers substituted open calls producer program requests increment fd open localhost getfile port socket print getline fd consumer program requests decrement fd open localhost getfile dec port socket print getline fd setl implementations setl implementations remarked chapter really fully satisfactory setl implementation advantages actively maintained released gnu public license written portable fast translator packaged way heavy allow configured adapted easily wide variety unix operating systems 
interpreter reflects greater interest modularity speed 
new version language includes respectable type system sufficiently defined think worthwhile write entirely new setl compiler run time system ada 
language defined terms ada expansions compiler designed definition possible take advantage gnat system 
deeper code transformations performed apts presence serious type system permit kind thorough optimization usually seen implementations lower level languages 
advantage tying setl definition implementations ada ada run time semantics readily expressed term java virtual machine jvm 
pave way writing browser applets setl 
comparison languages comparison languages main thing distinguishes setl high level languages syntax 
roots mathematical notation developed refined people long computers arrived scene lend ability express wide variety computational processes naturally elegantly 
perl perl commonly high level language data processing 
larry wall frustration insufficiency awk purposes grown baroque endless patching 
syntax arcane practically variable start special symbol semantics just bad undeclared variables global system interface implementation dependent claims portability usually perl 
worse interface unix thin example select normal buffered streams raw file descriptors semantics signals depend strain unix hosting perl implementation 
means re establishing signal handler may suffer historical system race condition led bsd style eventually posix signal handling definitions 
unix routines re entrant potential causing disaster called signal handlers perl top signals fielded asynchronously regardless comparison languages state garbage collecting memory manager leaving documentation choice advise programmers little possible signal handlers minimize probability disaster guarantee regard matter simple handler kept 
setl course strictly shields high level programmer nonsense providing high level interface select permitting synchronous access signals general keeping issues portability internal run time system exposing inappropriate level 
setl perl provides bidirectional pipe streams called pumps setl powerful inter process communication facility usefulness amply demonstrated webeye case study chapter 
perl cited conciseness expression beat setl score 
opposite true 
example tcp client program derived directly book described simple client 
version modified functionally identical line setl program section similar perl sample program manual page unix systems port cs nyu edu socket comparison languages name aliases proto tcp name aliases type len localhost name aliases type len pack af inet pack af inet port socket pf inet sock stream proto jj die socket bind jj die bind connect jj die connect print kernighan pike code classic markov chain algorithm java awk perl compare typical small data processing task 
program sizes range lines source code version lines perl version reproduced markov pl markov chain algorithm word prefixes nonword nonword initial state read line input foreach split push gf gg multiple assignment push gf gg nonword add tail comparison languages nonword suf gf array int rand suf suf number elems exit suf eq nonword print advance chain authors comment perl awk programs short compared earlier versions harder adapt handle prefixes exactly words versions written lower level languages prefix size governed named integer constant 
perl home fact exactly sort program perl programmers love write 
setl version slightly shorter perl program modeled general number prefix words controlled constant direct example tuple words recorded entry built tuple concatenation mysterious push operator 
looks real program wild festival glyphs markov chain demo const const number prefix words const nonword fg words nonword initial state word split getfile stdin loop comparison languages words word words words 
word loop words nonword add tail words nonword 
loop word random words nonword print word words words 
word loop icon icon interesting high level language programming small 
type declarations variable declarations scope rules similar setl 
represents extreme programming language design expression evaluation mechanism fully backtracking generators suspend produce value encountered asked resume backed 
abandoned exhausted generator ultimately fail 
rules limit backtracking appropriate contexts provides convenient basis control flow assignment expression results variables typically occurs time successful evaluation eliminating need distinct boolean type 
icon pervasive backtracking generalization backtracking snobol string pattern matching 
icon snobol twin extensively tight control comparison languages flow expression evaluation icon produces welcome effects fact accomplishes languages written extra liveness ubiquitous generators turn useful require vigilance 
backtracking worked pattern matching snobol best limited domain 
stranger syntactic improvements pattern matching turned quite comfortable original snobol forms 
icon proven particularly suited graphics programming course strong string manipulation 
feeling icon close second setl data processing 
syntax fairly elegant close mathematics setl particular doesn set tuple formers heavy operator forms example equals spelled depending numbers strings general objects lists compared 
icon lacks setl value semantics evident fact outcome depends objects identical lists means operands refer list scalars simply means value 
icon allows record definitions procedures global 
typed may addressed name position 
records lumped lists sets tables aggregates values collectively called structures icon terminology 
pointer semantics copy primitive performs level copying 
tempting adopt record model setl simple comparison languages icon borrowing attitude field typing pointer semantics 
think wait ada type system suggested section investigated far ensure unfortunate incompatibilities introduced 
functional languages lisp derivatives scheme purely functional languages ml haskell theoretical practical interest data processing haskell list comprehensions similar setl tuple formers lazy evaluation admits concise expressions represent infinite lists directly functions 
haskell strong typing combined ability dispatch routine correct signature generalized pattern matching lend great potential clarity elegance 
haskell way world data processing significant extent 
know surmise lack assignment disconcerting 
case servers clear tail recursion natural way express infinite main loop state information map current client records best represented succession values map say constructed previous map passed parameter round recursion 
hand assumes optimizer garbage collector haskell implementation able recognize opportunity conversion tail recursion comparison languages iteration possibility suppressing copy proliferation approach offer significant advantage avoiding hazards associated updating variables place 
python python language close level setl deliberately oriented calling data processing dissertation 
descends abc language guido van rossum designer implementer python helped design 
python number odd cases counterintuitive aspects scoping rules 
interesting features inherits abc indentation syntactic mechanism control structure grouping 
python suffers simultaneously offering lists tuples pointer semantics tuples tuples value semantics 
tuple denotations marked parentheses problem denote singleton unfortunately solved writing 
typical assertions conciseness high level language behalf python approaching setl set tuple formers 
consequence subroutine van rossum written concisely setl def find path graph start path path path start start comparison languages return path graph key start return node graph start node path find path graph node path return return setl equivalent function may written existential predicate place loop proc find path graph return exists jjj path find path graph om return path return om find path assumes multi map graph modified accommodate adjacency list changing graph fg 
difference languages apparent example van rossum def find paths graph start path path path start start return path graph key start return comparison languages paths node graph start node path find paths graph node path paths append return paths setl proc find paths graph return return path path paths graph find paths structure result set paths tuples obvious time natural list lists returned python function 
course setl content paths represented subgraphs interested concise definition micro managing optimization process simply write proc find paths graph return fs pow graph jjj path proc path defined comparison languages proc path graph vertices domain graph range graph return graph vertices gamma domain graph vertices range graph vertices proc tests graph tree domain vertices range vertices 
find path easily implemented arb applied result find paths 
rexx rexx originally shell language began supersede primitive exec job control language cms component ibm vm operating system years general purpose high level language ported wide variety systems 
retains characteristics shell programming language 
example commands recognized designating built user defined operations passed environmental command interpreter cms editing environment operating system standard 
values manipulated rexx program strings arithmetic defined strings representing numbers rexx simple variable names compound ones serve general associative device number simple variable name symbol comparison languages number variable name 
name uninitialized variable default value name uppercase 
gives considerable power language fundamentally simple 
parser run time string treated expression evaluated 
scopes dynamic 
rexx glue language suitable high level control lacks mathematical syntax data structuring capabilities setl 
compound variable names allow directly data processing shortcomings usual pitfalls highly dynamic language felt acutely program size increases 
java languages compared setl high level data processing languages conclude reflecting really intermediate level gained currency years java 
language took advantage widespread popularity immediate appeal programmers 
backed huge financial resources documented widely implemented important apis great variety application domains defined 
java language really reductionism 
syntax thin doesn operator declarations algol setl certainly close setl set tuple formers 
object inheritance facilities comparison languages streamlined 
probably deserves praise criticism 
class derived class derived number interfaces purely descriptors data 
eliminates troublesome questions arise general multiple inheritance happens base class data occurs hierarchy ancestors java model allows object play multiple roles identifying party interested different kinds event 
object java built types scalar value 
welcome aspect reductionism encourages creation aliases independent values cf 
sections 
threads encourage asynchronous sharing variables worse outlined section 
java approach handling exceptions may little severe tendency force programmers consider errors interested certainly preferred approach doesn allow errors caught especially long running programs intended public 
best thing java probably follow lead adapting better language ada case java suite apis java language mid level symbolic form highly portable machine language java byte code 
maintainers rexx taken approach 
goes farther entirely new implementation python written java targeted java runtime environment 
systems takes advantage reflects java package summary structure way setl follow suit 
summary programming languages setl stands apart designed take advantage syntactic tradition mathematics 
schwartz desire free programmers preoccupation machine level concerns recognition people evolved notations served aid mathematical reasoning combined produce language day ability express essential programming constructions concisely naturally 
come surprise setl gracefully handles relatively mundane generalizations required typical data processing 
setl elegant language clean semantics refreshing degree orthogonality 
importance attributes deal daily programs profound 
easy take pride results tend reward revisiting cycle readability robustness maintainability ensues 
setl language deserves taken seriously 
tried show dissertation excels realm remote algorithmic really useful process intensive age internet general principles patterns best context 
done optimistic hope setl slow start day prove start 
appendix webeye source code source code listings webeye box described chapter 
appear alphabetical order filename cross referenced roles relationships 
script precursors vc master cgi vc cgi strictly part box call 
likewise programs vc go setl vc quit setl vc restart setl vc check setl vc cron setl outside box deal aspects administration 
typographic conventions text dissertation reflect result automated preprocessing uses fonts subscripts open quotes clarity 
setl sources listings derived encoded subset printable ascii characters 
obey character set restrictions setl textbook compiled default case insensitive convention current setl implementation 
webeye source code vc admin setl vc admin setl textually included vc cron setl section vc go setl section vc quit setl section vc restart setl section vc toplev setl section source code management services principally relating creation interpretation removal mutual exclusion mutex locks 
include define yhwh lock 
proc msg log directly stdout cf 
msg vc msg setl yhwh proc proc log timestamped message print tod flush stdout proc proc commence acquire mutex abend immediately var text rc symlink error error msg obtain lock file lock error text readlink lock om msg instance yhwh may running msg currently render lock text msg please check processes str rm lock necessary yhwh vc toplev setl msg vc quit sure box stopped msg vc check check old processes msg vc restart clear str lock webeye source code vc admin setl msg manage log files rc msg exiting status str rc rc proc proc symlink clear error symlink yhwh pid str pid started str tod lock proc op render lock text return render link lock text op proc render link name text var return name text extract timestamp text om proc extract field text timestamp possible op extract timestamp text var split text val tod return webeye source code vc admin setl return om op extract pid embedded text possible op extract pid text var text pid 
om gamma val current range unix pid numbers return return om op proc rc release mutex yield status code rc system unlink lock rc proc webeye source code vc allowed setl vc allowed setl textually included vc setl section vc event setl section vc image setl section vc toplev setl section source code test peer peer address fd set allowed hosts usually meaning allowed server called allowed proc allowed fd hosts rudimentary host security var ok ips afd ip ok ips hosts ok ips om afd open vc allowed conf afd om ok ips fg ip ip localhost hostname reada afd ok ips close afd ip peer address fd return ok ips aliases ip fg proc op aliases ip return ip names ip ip addresses ip op webeye source code vc setl vc setl called parent program vc send setl section calls child programs vc setl section vc setl section source code const yhwh vc setl try provoke canon auto initializing printa stderr yhwh begins com dev filter exec setl vc setl com port val filter exec setl vc setl msr modem status register msr cts bit clear send cts bit fd fileno open dev port direct obtain initial cts value seek fd com port msr msr val abs getc fd cts val sign msr val bit cts bit printa stderr cts entry yhwh cts val try provoke auto init sending bad length byte com dev xff start clock clock delay ms give plenty chance take effect select om seek fd com port msr webeye source code vc setl msr val abs getc fd cts val sign msr val bit cts bit printa stderr cts ms cts val watch cts come back 
loop doing delta clock gamma start clock delta select om delay ms seek fd com port msr msr val abs getc fd sign msr val bit cts bit printa stderr cts delta ms goto done loop printa stderr cts delta ms done printa stderr yhwh ends webeye source code vc camera setl vc camera setl service provided camera called parent program vc toplev setl section calls child program vc ptz setl section textually includes vc exit setl section vc getname setl section vc msg setl section vc provide setl section source code const yhwh vc camera setl multiplexing server front program vc ptz setl provides high level command interface designed convenience telnet clients programs canon vc pan tilt zoom camera controller 
const vc ptz exec setl vc ptz setl const sigterm fd open sigterm signal catch term signals const camera fd fileno provide service camera var clients fg loop ready select fd camera fdg domain clients sigterm fd ready msg yhwh str pid caught sigterm quit gracefully webeye source code vc camera setl client clients pump fd jjj pump fd ready loop msg clients pump fd name done close pump fd clients pump fd om loop camera fd ready fd accept camera fd fd om name getname fd msg name accepted pump fd open vc ptz str fd pump close fd pump fd om client fg client name name clients pump fd client msg failed start vc ptz name loop proc quit gracefully exit gracefully str filename pump fd client client name pump fd client clients pump fd proc include vc provide setl include vc getname setl include vc exit setl include vc msg setl webeye source code vc check setl vc check setl source code report box processes program part box const pid dir vc pid const ps filter bin ps const lines split ps const header split lines const split line line lines 
jjj line const pid index index pid const index index const command index index command const pid map tup index main parent child map tup pid index tup const finder tup pid index tup name split filter bin echo pid dir jjj name notin pid dir pid dir vc toplev loop root getfile name id val root integer id id id printa stderr process id file str name invalid name pid dir id root range pid map printa stderr process tree name format finder root root domain pid map doit root max line line 
loop prot false gamma 
loop webeye source code vc check setl jjj prot mark elseif prot true prot false line loop line fanatic printa stderr line line printa stderr process root name gone name name pid dir vc toplev root getfile name om id val root integer id id id printa stderr process id file str name invalid name pid dir id assert root range pid map line format finder root printa stderr primordial process name printa stderr line printa stderr process root name gone webeye source code vc check setl name pid dir printa stderr record process name filter uname linux om printa stderr try ps fxj check orphaned processes printa stderr try ps xl check orphaned processes proc index assert exists field header jjj field return proc proc doit parent return jjj format finder child doit child child pid proc op format tup return tup pid index field field tup command index 
op webeye source code vc clear setl vc clear setl called parent program vc send setl section calls child programs vc setl section vc setl section source code const yhwh vc clear setl clear canon printa stderr yhwh begins com dev filter exec setl vc setl com port val filter exec setl vc setl rts lo time val command line ms mcr modem control register rts bit fd fileno open dev port direct seek fd com port mcr mcr val abs getc fd mcr val bit bit rts bit seek fd com port mcr putc fd char mcr val put rts low select om rts lo time delay rts lo time ms seek fd com port mcr mcr val abs getc fd mcr val bit rts bit seek fd com port mcr putc fd char mcr val put rts hi select om give canon ms catch breath printa stderr yhwh ends webeye source code vc setl vc setl called parent programs vc setl section vc clear setl section vc init setl section vc input setl section vc send setl section source code echo contents file containing configured serial device name default name 
const conf file vc conf com dev split getfile conf file dev putchar com dev webeye source code vc setl vc setl called parent programs vc setl section vc clear setl section source code echo contents file containing configured serial port address default port address 
const conf file vc conf com port split getfile conf file putchar com port webeye source code vc cron setl vc cron setl calls child program vc restart setl section textually includes vc admin setl section source code const yhwh vc cron setl supposed run minute user entry cd fred setl vc cron setl program basically tries detect correct problems box supposed permanently running 
tries going crazy apprentice attempt 
decides box malfunctioning time try correct problem try clean removing apparently stale locks processes restart box 
const lock vc lock file mutex const vc vc log exited const vc lock vc lock box lock file const vc link vc link html link pseudo document const vc prefix pseudo document convention const vc health vc tcp health box health check host port const vc camera vc tcp camera box command host port const vc going vc going vc go lock file const vc quitting vc quitting vc quit lock file const vc restarting vc restarting vc restart lock file const vc vc restarts success const vc restart cmd exec setl vc restart setl restart command webeye source code vc cron setl var box try acquire lock named lock appropriate 
started instance program running exit quietly immediately 
try correct problem lock exit hope cleanup effort action administrator subsequently takes easy get program run soon minute symlink symlink result error error readlink lock om stamp extract timestamp stamp tod gamma lock minutes old bogus 
msg lock file render lock str tod gamma stamp div minutes old try find blow away old instantiation program remove lock exit 
extract pid om kill process msg process str appears longer active msg find pid str msg removing lock exiting status cron exit render lock old bogus active instance considered old 
extract pid om webeye source code vc cron setl bow gracefully 
cron log instance str active msg lock file render lock indicates young active process str appears longer active msg removing lock exiting status cron exit instance str disappeared msg find pid str msg removing lock exiting status cron exit pid render lock msg create lock file lock reason str symlink result read symlink reason str error msg attempting unlink lock clear error unlink lock error error msg unlink attempt failed reason str error elseif lock msg unlink appeared succeed lock exists msg unlink apparently successful msg exiting status cron exit problem access lock acquired mutex lock named lock 
webeye source code vc cron setl see box healthy 
box lock file supposed symbolic link string information real file 
try read information box readlink vc lock om failure read vc lock symbolic link look box process id embedded link extract pid box om failure find pid str box check process identified really exists failure process str indicated lock file render link vc lock box disappeared wait see pseudo document indicating box available magic constants file 
vc limits setl 
interval ms limit ms loop ms interval 
doing flag content getfile vc link om match content vc prefix vc prefix flag select om interval loop flag failure box failed reach running state try open box health check service fd open box service vc health health check exercise health check webeye source code vc cron setl line getline fd ok failure box failed health check reason str line close fd fd om try open box camera control command service fd open box service vc camera camera control command absorb opening split getline fd loop pass loop tell ensure consistency hardware software state printa fd check close fd fd om zero restart counter unlink lock exit successfully vc cron exit ok fancy box identifier proc box return box render link vc lock box proc proc open box service vc look designated service box hp getfile vc om failure box failed create file str vc try open hp host port designated service fd open hp socket om failure box listening port hp return fd proc webeye source code vc cron setl routine called box appears malfunctioning attempts restart conditions proc failure message update count restart attempts time properly functioning box detected raw split getfile vc raw raw raw msg vc file corrupted contains str raw number treating val raw vc str case recurring failures restart attempts back powers maximum interval units minutes program run minute cron mod exists 
jjj try restart box 
try sure aren active instances vc go vc quit vc restart run restart true loop vc going vc quitting vc restarting run restart readlink om stamp extract timestamp stamp tod gamma lock file minutes old bogus msg removing lock file render lock unlink stale pid extract pid om webeye source code vc cron setl stale pid kill process stale pid msg find pid str lock file quite young 
skip restart opportunity come presently run restart false loop run restart attempt restart world know exit msg message attempting restart box system vc restart cmd cron exit message performed str vc restart cmd log failure unlink lock exit spamming stderr attempting restart cron exit message proc proc kill process process id msg killing str process id kill process id send term signal select om give term chance kill process id kill send kill signal sure proc log file named vc webeye source code vc cron setl purpose spam stderr mailed user cron proc cron log rc message fd open vc printa fd tod pid pid exit rc message close fd proc proc cron exit rc message cron log rc message rc proc include vc admin setl webeye source code vc decode setl vc decode setl textually included vc setl section vc event setl section vc model setl section vc ptz setl section source code operator decode low level message canon op decode frame const camera head pan ccu fg string frame frame kind erroneous frame frame detail string frame zero length frame frame om frame om frame type type frame return frame kind special frame frame case frame detail inter character timeout detail ack timeout multiple command sequence webeye source code vc decode setl detail checksum error detail timeout waiting ack nak response case return frame hex frame fid abs frame frame id device fid bit case device camera head device camera head pan device pan ccu device ccu device unknown device hex char device case fid bit command frame cid abs frame command id cmd cid bit command type bits cmd unknown hex char cmd default cid bit host canon message kind request case device camera head case cmd cmd status cmd focus cmd zoom cmd exposure case pan case cmd cmd status webeye source code vc decode setl cmd set cmd home position cmd pan tilt cmd remote controller cmd led case ccu case cmd cmd software reset cmd status cmd white balance cmd fade cmd mute cmd control mode select cmd preset case case canon host message cid bit response cid bit kind positive response kind negative response case device camera head case cmd cmd status cmd focus cmd zoom cmd exposure case pan case cmd cmd status cmd set webeye source code vc decode setl cmd home position cmd pan tilt cmd remote controller cmd led case ccu case cmd cmd software reset cmd status cmd white balance cmd fade cmd mute cmd control mode select cmd preset case case notification kind notification case device camera head case cmd cmd error cmd focus limit cmd zoom limit cmd button operation case pan case cmd cmd error cmd limit cmd remote controller cmd power case ccu case cmd cmd error case webeye source code vc decode setl case cmd error frame error type abs frame frame error cause abs frame error cause om error type error cause decode error error type error cause cmd cid bit response vs notification cid bit command direction ack nak frame ack nak id abs frame ack nak id kind ack detail received kind nak detail decode nak cause ack nak id fid bit command vs ack nak return op decode proc decode error error type error cause error type decode error type error type error cause om error cause om webeye source code vc decode setl case error type camera communication error cause raw uart 
status byte error cause status register hex char error cause pan rs comm 
error error cause decode comm error cause error cause error cause frame nak error cause decode nak cause abs frame case return error type error cause proc proc decode error type error type return case error type camera cable disconnected camera communication error pan communication error rs communication error command unconnected device undefined command undefined parameter status error received command status error received parameter timeout white balance correction error pan tilt zoom focus limit unknown error type hex char error type case proc proc decode comm error cause cause return case cause nak received ack receive timeout checksum error pan busy webeye source code vc decode setl fatal error sequence error length error buffer busy unknown comm 
error cause code hex char cause case proc proc decode nak cause cause return case cause buffer busy length error sequence error communication error checksum error unknown nak cause code hex char cause case proc webeye source code vc setl vc setl services provided local clients vc httpd setl section vc jumper setl section vc mouse setl section vc mover setl section vc ptz setl section vc setl section notice local clients vc setl section vc setl section vc ptz setl section client service event vc event setl section called parent program vc toplev setl section calls child program vc model setl section textually includes vc allowed setl section vc decode setl section vc exit setl section vc getname setl section vc msg setl section vc obtain setl section vc provide setl section source code const yhwh vc setl program provides notice services 
service server interface model pumping process maintains high level model control state supports mid level commands requests reduced setl maps alter state 
routing webeye source code vc setl commands clients model subprocess implements queuing policy allows client satisfied immediately command pending prevents commands client queued pending performed 
notice service distributes mid level events interested clients 
originate low level events generated event service responses parameter changing commands issued model pump 
const model pump exec setl vc model setl const sigterm fd open sigterm signal catch term signals performer mid level commands const model fd fileno open model pump pump generator low level events const event fd fileno obtain service event const server fd fileno provide service const notice server fd fileno provide service notice var notice clients fg map client fd client record var clients fg map client fd client record var queue queue fd clients awaiting service var pending false true await reply model open ignore write closed observers loop domain clients gamma fdo fd fd pool pending fdg fg fd event fd server fd notice server fdg ready select pool webeye source code vc setl sigterm fd ready msg yhwh str pid caught sigterm quit gracefully fd ready loop new request client 
reada fd request eof clients fd om close fd client clients fd client request request clients fd client queue fd loop pending model fd ready reada model fd model response eof msg eof str model pump quitting quit gracefully notices created model pump alert observers parameter changes special events initialization message model response notices loop tell observers message tell notice clients loop fd queue client clients fd request client request request name get writea fd model response value printa fd blank line say command done webeye source code vc setl flush fd pending false event fd ready reada event fd frame eof msg eof filename event fd quitting quit gracefully message decode frame tell observers message tell notice clients server fd ready fd accept server fd fd om name getname fd allowed fd client fg client name name clients fd client close fd msg name denied access service notice server fd ready notice fd accept notice server fd notice fd om name getname notice fd allowed notice fd notice client fg notice client name name webeye source code vc setl notice clients notice fd notice client close notice fd msg name denied access notice service queue pending fd queue client clients fd request client request writea model fd request flush model fd pending true loop proc tell observers message notice client notice clients notice fd loop clear error writea notice fd message flush notice fd eventually causes client closed error error close notice fd notice clients notice fd om loop proc tell observers proc quit gracefully exit gracefully str model pump model fd proc include vc provide setl include vc obtain setl webeye source code vc setl include vc getname setl include vc allowed setl include vc decode setl include vc exit setl include vc msg setl webeye source code vc event setl vc event setl services provided event local client vc setl section notify local client vc seq setl section called parent program vc toplev setl section textually includes vc allowed setl section vc decode setl section vc exit setl section vc getname setl section vc msg setl section vc provide setl section source code const yhwh vc event setl low level event notification distributor var producers consumers const sigterm fd open sigterm signal catch term signals producers notify port supply events const server fd fileno provide service notify consumers receive events event port const server fd fileno provide service event open ignore write closed consumers producers fg consumers fg loop ready select fd server fd server fdg webeye source code vc event setl domain producers sigterm fd ready msg yhwh str pid caught sigterm quit gracefully producer producers fd jjj fd ready loop reada fd event eof close fd producers fd om tell consumers event loop server fd ready fd accept server fd fd om name getname fd allowed fd producer fg producer name name producers fd producer msg name allowed event producer close fd server fd ready fd accept server fd fd om name getname fd allowed fd consumer fg webeye source code vc event setl consumer name name consumers fd consumer msg name allowed event consumer close fd loop proc tell consumers event consumer consumers fd loop clear error writea fd event flush fd eventually cause client closed error error msg consumer consumer name done close fd consumers fd om loop proc proc quit gracefully degenerate currently pump pipe attached child exit gracefully proc include vc provide setl include vc getname setl include vc allowed setl include vc decode setl include vc exit setl include vc msg setl webeye source code vc setl vc setl service provided client service notice vc setl section called parent program vc toplev setl section textually includes vc setl section source code const yhwh vc setl serve motion events simple form designed java clients name service provide define event type initial tokens event type look const interest move numbers represent pan azimuth tilt elevation const include vc setl webeye source code vc setl vc setl service provided client service notice vc setl section called parent program vc toplev setl section textually includes vc setl section source code const yhwh vc setl serve zoom events simple form designed java clients name service provide define event type initial tokens event type look const interest zoom number represents zoom factor const include vc setl webeye source code vc exit setl vc exit setl textually included vc camera setl section vc setl section vc event setl section vc giver setl section vc httpd setl section vc image setl section vc setl section vc model setl section vc mouse setl section vc ptz setl section vc push setl section vc recv setl section vc seq setl section vc simpler setl section vc snap setl section source code send sigterm signals processes listed name fd pairs asking quit quit current process 
ask doesn force issue 
proc exit gracefully name fd pairs var fd name fd id wid ready line exited fd open signal catch signals exited fg name fd name fd pairs loop fd om id pid fd name pid str id msg terminating clear error kill id send sigterm error error subprocess existed zombie 
webeye source code vc exit setl try clear quickly 
process existed signal sent receive soon manages exit select unblock 
process zombie select hold show ms process exists exit quickly ready select fdg fd ready line getline fd process exited zombie waited cleared process table added exited set wid wait false loop exited wid loop id exited subprocess exited safely call close file descriptor blocking carry 
close fd continue name fd name fd pairs loop 
fd notin ready indication subprocess having exited 
give bit time 
didn want start way subprocess zombie waited full ms ready select fdg fd ready line getline fd wid wait false loop exited wid loop id exited close fd continue name fd name fd pairs loop 
webeye source code vc exit setl subprocess reluctant exit 
hit harder 
msg killing kill id kill send ready select fdg fd ready line getline fd wid wait false loop exited wid loop id exited close fd continue name fd name fd pairs loop 
probably indicates bug host os msg failed exit kill signal msg loop close fd msg yhwh str pid exiting proc webeye source code vc getname setl vc getname setl textually included vc camera setl section vc setl section vc event setl section vc giver setl section vc httpd setl section vc image setl section vc setl section vc mouse setl section vc ptz setl section vc push setl section vc simpler setl section vc snap setl section vc toplev setl section source code return best available identifier client including ip name possible just ip address followed colon remote usually ephemeral port number 
op getname fd return peer name fd peer address fd anonymous str peer port fd op webeye source code vc giver setl vc giver setl service provided giver called parent program vc toplev setl section textually includes vc exit setl section vc getname setl section vc msg setl section vc obtain setl section vc provide setl section source code const yhwh vc giver setl gives stream urls stream 
go away java api widely available 
const sigterm fd open sigterm signal catch term signals const giver fd fileno provide service giver var clients fg loop ready select fd giver fdg domain clients sigterm fd ready msg yhwh str pid caught sigterm quit gracefully client clients pump fd jjj pump fd ready loop done client pump fd loop webeye source code vc giver setl giver fd ready fd accept giver fd fd om name getname fd msg name accepted pump fd pump pump fd gamma child serv name serv port find service snap serv name localhost public consumption pfx serv name str serv port seq line getline fd om split line jpeg loop name str printa fd pfx name loop close fd child hangs client fg client name name clients pump fd client loop proc done client pump fd msg clients pump fd name done close pump fd clients pump fd om proc done client proc quit gracefully exit gracefully pump client client name pump fd client clients pump fd webeye source code vc giver setl proc include vc provide setl include vc obtain setl include vc getname setl include vc exit setl include vc msg setl webeye source code vc go setl vc go setl called parent program vc restart setl section calls child program vc toplev setl section textually includes vc admin setl section source code const yhwh vc go setl start box const lock vc going lock file mutex const vc lock vc lock box lock file const vc log vc log box log file const vc cmd exec setl vc toplev setl box top level program const vc link vc link html eventually points pseudo document const vc prefix pseudo document magic convention const vc health vc tcp health host port box health check var box commence acquire mutex exit abnormally right away interactive system tty box readlink vc lock om interactive printa stderr box lock file exists printa stderr render link vc lock box putc stderr shall forcibly remove 
clear error unlink vc lock webeye source code vc go setl error error printa stderr lock file vc lock removed printa stderr error error trying remove vc lock msg printa stderr lock file vc lock removed msg exiting msg error box lock file exists msg render link vc lock box msg starting box vc log interactive printa stderr log file vc log exists putc stderr go ahead 
printa stderr okay str vc cmd vc log printa stderr okay log file left intact printa stderr try vc restart order save printa stderr start box msg exiting msg warning str vc cmd vc log webeye source code vc go setl full cmd vc cmd vc log msg starting str full cmd background system full cmd wait box lock reappear loop ms vc lock select om ms 
ms sec loop box readlink vc lock om failure box failed create lock file vc lock interactive printa stderr box succeeded creating lock file printa stderr render link vc lock box wait see pseudo document indicating box available magic constants file 
vc limits setl 
interval ms limit ms interactive printa stderr box initializing please wait str limit sec loop ms interval 
doing flag content getfile vc link om match content vc prefix vc prefix flag select om interval interactive putc stderr fixed ms sec loop interactive printa stderr webeye source code vc go setl flag failure box failed reach running state try exercise health check hp getfile vc health om failure box failed create file str vc health hp host port designation health check service fd open hp socket om failure box failed open health check service hp line getline fd ok failure box failed health check reason str line close fd msg box appears running normally msg done interactive printa stderr may wish tail vc log release mutex exit normally proc default ans split getline stdin ans default return lower ans proc fancy box identifier proc box return box render link vc lock box proc webeye source code vc go setl proc failure message msg message msg proc include vc admin setl webeye source code vc httpd setl vc httpd setl service provided httpd client service vc setl section called parent program vc toplev setl section textually includes vc exit setl section vc getname setl section vc msg setl section vc obtain setl section vc provide setl section setl section source code const yhwh vc httpd setl program thinks little web server 
instantiates local file vc template html substituting parameters typically come mouse clicks url keywords presents result wrapped html 
turn contains server push jpeg image producer push service self browsers usually decorate pixel locations clicked 
sends camera control commands service click parameters current state 
const want nonsense false true canon hardware const width const height constants go file say vc limits setl included uses const gamma const webeye source code vc httpd setl const gamma const const min zoom const max zoom const pi asin const fmin gamma const fmax const gamma const gmax const segments circle flag determines camera controlled client inactivity const method move move speed const want false want inactivity timeout const tick method move ms const inactivity timeout round tick sec const fd fileno want nonsense open getfile nonsense tcp socket obtain service const timer fd want open str tick real ms om const sigterm fd open sigterm signal catch term signals const httpd fd fileno provide service httpd var clients fg webeye source code vc httpd setl cycling want ticker starting radius ramp zoom get zoom factor loop ready select fd httpd fd timer fdg domain clients sigterm fd ready msg yhwh str pid caught sigterm quit gracefully client clients pump fd jjj pump fd ready loop pump fd action action clicked cycling method speed move cycling false reada pump fd zoom scale pan tilt zoom scale zoom zoom scale move pan tilt move pan tilt zoom zoom scale action new want zoom random webeye source code vc httpd setl zoom zoom method speed move start cycling true action initial cycling method speed move cycling false reada pump fd old zoom zoom pan tilt zoom old zoom zoom scale zoom zoom move pan tilt move pan tilt zoom zoom done client pump fd loop httpd fd ready new client fd accept httpd fd fd om name getname fd msg name accepted old pan old tilt get position confusing variable names zoom old pan zoom get zoom factor pump fd pump pump fd gamma child pumping process uri protocol mime headers get request fd webeye source code vc httpd setl mu massage uri uri fg protocol mu cmd jpeg mu click om mu top try clicking image pwm equiv explicit initial pan tilt zoom specifications url override old settings initially old zoom zoom old see confusing zoom mu zoom old zoom pan mu pan old pan tilt mu tilt old tilt mu pwm initial pan fixed pan deg tilt fixed tilt deg initial zoom factor fixed zoom mu zoom mu pan mu tilt om print new print initial print old zoom zoom pan tilt canon abuse pwm equiv just quote pan tilt degrees 
mu top clicked str mu click pwm equiv mu click pan norm gamma width width tilt norm height gamma height dist norm sqrt pan norm tilt norm zoom scale gamma dist norm pan pan norm zoom tilt tilt norm zoom webeye source code vc httpd setl string replaces pwm equiv html template req pan old pan pan req tilt old tilt tilt req zoom zoom zoom scale pan tilt clamp req pan gamma req pan req tilt gamma req tilt clamped fixed req pan max gamma min fixed req tilt max gamma min zoom clamp req zoom min zoom req zoom max zoom clamped fixed req zoom max min zoom min max zoom mu pwm requested pan fixed req pan deg tilt fixed req tilt deg delta pan fixed pan deg tilt fixed tilt deg pan tilt clamp requested zoom factor fixed req zoom fixed zoom scaled fixed zoom scale zoom clamp print clicked print zoom scale pan tilt html instantiate getfile vc template html mu html fd html protocol parent continues close fd child deals client fd client fg webeye source code vc httpd setl client pump fd pump fd client name name clients pump fd client timer fd om timer fd ready ticker timer fd dummy cycling clock camera pattern client inactivity note cycling happens want true ticker mod random zoom random zoom zoom ticker mod real pan cycle gamma fmin fmax gamma fmin normalized gamma scaled output range pan tilt cycle gamma gmax gamma normalized gamma scaled output range tilt method move max zoom zoom zoom move pan random gamma tilt random gamma elseif method speed move speed pan random gamma tilt random gamma elseif want ticker inactivity timeout ticker random zoom random zoom zoom method speed webeye source code vc httpd setl move start cycling true loop proc html fd html protocol upper protocol om printa fd ok printa fd server webeye printa fd expires printa fd pragma cache printa fd content type text html printa fd content length str html printa fd putc fd html flush fd proc html proc instantiate template mu gsub template date tod gsub template top mu top gsub template pwm equiv mu pwm go top sub 
gsub template web home look port httpd fd looked httpd port consistency sort silly gsub template httpd home public service httpd gsub template video home public service push gsub template camera tcp public service camera gsub template max rate mu rate om rate str mu rate return template proc instantiate webeye source code vc httpd setl look service name host port public proc public service name serv name serv port find service name serv name localhost serv name return serv name str serv port proc proc pan cycle return sin pix proc tilt cycle return cos pix proc new cmd name cmd fg cmd name name return cmd proc proc cmd cmd writea fd cmd fd response line return response line proc proc ramp ms cmd new cmd ramp cmd ms ms cmd cmd proc proc move pan tilt move pan tilt proc webeye source code vc httpd setl proc move pan tilt move pan tilt proc proc move toby pan tilt cmd new cmd move cmd subcmd toby cmd pan pan cmd tilt tilt cmd cmd proc proc move start cmd new cmd move cmd subcmd start cmd cmd proc proc move cmd new cmd move cmd subcmd cmd cmd proc proc move speed pan speed tilt speed cmd new cmd move cmd subcmd speed cmd pan speed pan speed cmd tilt speed tilt speed cmd cmd proc proc zoom factor cmd new cmd zoom cmd subcmd cmd zoom factor factor cmd cmd webeye source code vc httpd setl proc proc zoom scale cmd new cmd zoom cmd subcmd cmd zoom scale scale cmd cmd proc proc get cmd new cmd get cmd return cmd cmd proc proc done client pump fd msg clients pump fd name done close pump fd clients pump fd om proc done client proc quit gracefully exit gracefully pump client client name pump fd client clients pump fd proc include vc provide setl include vc obtain setl include vc getname setl include vc exit setl include vc msg setl include setl webeye source code vc image setl vc image setl service provided image local clients vc push setl section vc snap setl section called parent program vc toplev setl section textually includes vc allowed setl section vc exit setl section vc getname setl section vc msg setl section vc provide setl section source code const yhwh vc image setl server clients connected keeps image pump maximally busy making images sends new image ready clients arrives 
sends image clients ready 
server intended local trusts clients probably children higher level server ready take image send command line 
currently command supported jpeg takes parameters 
checks sure clients local host trust 
image single line decimal digits stating number bytes image follows 
client read count reada fscanf case take option appending newline image currently don legally 
am having vc push setl example bash away thing temporarily start leaving image pump open permanently 
webeye source code vc image setl const sigterm fd open sigterm signal catch term signals const server fd fileno provide service image var image fd om image pump fd var clients fg image errors awaiting image false current image image num loop ready select fd server fd image fdg domain clients sigterm fd ready msg yhwh str pid caught sigterm quit gracefully client clients client fd jjj client fd ready loop line getline client fd om split line jpeg current image client image num image num send image client current image image num client waiting true clients client fd client close client fd name client name image count client image count restore message get jpeg streaming webeye source code vc image setl time spent clock gamma client start time msg name done fixed time spent fixed image count time spent fps clients client fd om loop image fd om image fd ready reada image fd om msg image error om check var log messages clues close image fd current image don want re old image image errors image fd open image pump awaiting image false msg str image errors image errors row bye image errors image image fd image image errors msg image error size str image str image errors current image image image num client clients client fd jjj client waiting loop send image clients client fd current image image num loop awaiting image false server fd ready webeye source code vc image setl client fd accept server fd client fd om name getname client fd allowed client fd restore message get jpeg streaming msg name accepted clients client fd new client client fd name msg untrusted client name refused close client fd image fd om clients image fd open image pump awaiting image false restore code get jpeg streaming elseif image fd om clients msg closing image pump image fd str image fd close image fd image fd om current image old soon image fd om awaiting image printa image fd jpeg awaiting image true loop proc open image pump image fd open image pump pump open busy pump pump image fd om msg open image pump bye quit gracefully webeye source code vc image setl return image fd proc proc new client client fd name client fg client client fd client fd client num client waiting false client start time clock client image count client name name return client proc proc send image rw client image image num client fd client client fd printa client fd image putc client fd image flush client fd client image num image num client image count client waiting false proc proc quit gracefully exit gracefully image fd om om str filename image fd image fd proc include vc provide setl include vc getname setl include vc allowed setl include vc exit setl include vc msg setl webeye source code vc init setl vc init setl called parent program vc send setl section calls child program vc setl section source code const yhwh vc init setl initialize serial device com dev command line filter exec setl vc setl printa stderr yhwh begins fd open com settings fd om getline fd close fd fd system com dev system com dev printa stderr yhwh ends webeye source code vc input setl vc input setl called parent program vc recv setl section calls child program vc setl section textually includes vc msg setl section source code const yhwh vc input setl existence program predicated idea bad ignore input serial line long parent ready read bytes collected system level read eager swallow bytes accumulated generous limit 
unix pipe fd goes ready accept output example typical kernel prepared accept bytes blocking 
depending kernel buffer lots input bytes get probably excessive retrospect 
probably program just vc recv setl read directly device 
nice know probably buffer seconds worth bytes sec spend long writing ignores input long 
program normally invoked vc input simply setuid wrapper compiled program containing main setl setl vc input setl setl substituted absolute pathname setl program setl driver makefile 
webeye source code vc input setl com dev command line filter exec setl vc setl com fd fileno open com dev ready output false loop input pool fdg output pool ready output fg ready ready select input pool output pool ready getc com fd om eof clear cause just close reopen close com fd select om wait ms com fd fileno open com dev ready ready output true ready output putchar flush stdout ready output false loop include vc msg setl webeye source code vc setl vc setl textually included vc setl section vc setl section textually includes vc exit setl section vc getname setl section vc msg setl section vc obtain setl section vc provide setl section source code file meant included define yhwh name program includes code event type name service provided interest command tokens look parameters command tokens expect const interest const notice fd fileno obtain service notice const sigterm fd open sigterm signal catch term signals const server fd fileno provide service event type var clients fg var current event om open ignore write closed observers loop ready select fd server fd notice fdg domain clients sigterm fd ready msg yhwh str pid caught sigterm webeye source code vc setl quit gracefully client clients pump fd jjj pump fd ready loop ack getline pump fd eof done client pump fd client event current event tell client pump fd current event clients pump fd hungry true loop server fd ready fd accept server fd fd om name getname fd msg name accepted pump fd pump pump fd gamma child event getline stdin om loop printa fd event ack getline fd om print loop parent continues close fd client fg client name name client hungry true webeye source code vc setl clients pump fd client send initial event current event om tell client pump fd current event notice fd ready reada notice fd raw event string raw event split raw event interest gamman tell observers 

loop proc tell observers event client clients pump fd loop client hungry tell client pump fd event loop current event event proc tell observers proc tell client pump fd event printa pump fd event flush pump fd error error done client pump fd client clients pump fd client hungry false client event event webeye source code vc setl clients pump fd client proc tell client proc done client pump fd msg clients pump fd name done close pump fd clients pump fd om proc done client proc quit gracefully exit gracefully pump client client name pump fd client clients pump fd proc include vc provide setl include vc obtain setl include vc getname setl include vc exit setl include vc msg setl webeye source code vc cgi vc cgi source code 
setl bin setl script placed web server cgi bin directory equivalent setl bin vc dir defined configuration 
const vc dir vc dir webeye home directory name const vc link vc dir vc link html const fresh vc dir vc fresh html const broken vc dir vc broken html const java vc dir vc java html const vc prefix pseudo document convention magic false try times read link 
link file exist time box started briefly major life cycle transitions box shut restarted loop content getfile vc link om select om wait ms try loop content om webeye box probably started put document getfile fresh elseif match content vc prefix vc prefix pseudo document lookup break content jjj location lookup service lookup fd open lookup socket lookup fd om lookup server accept connection webeye source code vc cgi put diagnostic lookup html getfile java service name giver mouse loop writea lookup fd service name reada lookup fd service host service port gsub html upper service name port str service port loop close lookup fd put document html link points static real document put document content proc put mime headers print content type text html print proc proc put document content put mime headers putchar content proc proc put diagnostic service name var content getfile broken gsub content service service name put document content proc webeye source code vc jumper setl vc jumper setl service provided jumper client service vc setl section called parent program vc toplev setl section textually includes vc simpler setl section source code const yhwh vc jumper setl simplified jump command interface 
client just sends pair numbers pan tilt line 
name service provide define service name jumper number parameters command define full details command send service define build cmd cmd fg cmd name jump cmd subcmd cmd pan val cmd tilt val include vc simpler setl webeye source code vc master cgi vc master cgi source code 
setl bin setl script placed web server cgi bin directory equivalent setl bin vc dir defined configuration 
const vc dir vc dir webeye home directory name const vc link vc dir vc link html const fresh vc dir vc fresh html const broken vc dir vc broken html const vc prefix pseudo document convention magic false try times read link 
link file exist time box started briefly major life cycle transitions box shut restarted loop content getfile vc link om select om wait ms try loop content om webeye box probably started put document getfile fresh elseif match content vc prefix vc prefix pseudo document lookup break content jjj location lookup service lookup fd open lookup socket lookup fd om lookup server accept connection put diagnostic lookup webeye source code vc master cgi writea lookup fd httpd reada lookup fd httpd host httpd port close lookup fd httpd httpd host str httpd port httpd fd open httpd socket httpd fd om webeye httpd server accept connection put diagnostic httpd construct request send webeye httpd query getenv path info 
getenv query string printa httpd fd get query printa httpd fd ok getline httpd fd success serve document returned webeye httpd putchar getfile httpd fd webeye httpd responding properly put diagnostic httpd close httpd fd link points static real document put document content proc put mime headers print content type text html print proc proc put document content put mime headers putchar content webeye source code vc master cgi proc proc put diagnostic service name var content getfile broken gsub content service service name put document content proc webeye source code vc model setl vc model setl called parent program vc setl section calls child program vc seq setl section textually includes vc decode setl section vc exit setl section vc msg setl section source code const yhwh vc model setl main pump server maintains high level model pan tilt zoom system 
takes requests checked encapsulated setl maps performs replies similarly encapsulated responses 
processes requests sequentially internally uses sequencer program vc seq setl take advantage possibility overlapped command response full duplex communications canon vc implement speed ramped motion trajectories pan tilting zooming performed simultaneously 
command sequencer const seq fd fileno open exec setl vc seq setl pump const sigterm fd open sigterm signal catch term signals var cur mode rc assumption init model changes var cur zoom factor var cur zoom speed var currently zooming false var cur pan cur tilt webeye source code vc model setl var cur pan speed cur tilt speed var currently moving false var ms tick const min move speed const max move speed const max speed max move speed ms tick deg tick const max zoom speed min zooms const max pan speed min pans left const max tilt speed min tilts const min zoom const max zoom var cur ramp ms var ramp ticks ms ticks cur ramp var accel max speed max ramp ticks speed change tick tie stdin stdout init model loop doing ready select fd sigterm fd ready msg yhwh str pid caught sigterm quit gracefully read cmd eof write perform cmd perform cmd give client response loop proc init model init mode host zoom webeye source code vc model setl move zoom speed medium high default speed zooms proc proc perform cmd response default case cmd name zoom case cmd subcmd start zoom start zoom speed zoom speed cmd zoom speed zoom cmd zoom factor cmd speed zoom cmd zoom scale cmd speed msg unrecognized zoom subcmd str cmd subcmd case move case cmd subcmd start move start move speed move speed cmd pan speed cmd tilt speed move cmd pan cmd tilt cmd ms cmd speed move cmd pan cmd tilt cmd ms cmd speed msg unrecognized move subcmd str cmd subcmd case jump case cmd subcmd jump cmd pan cmd tilt implement msg unrecognized jump subcmd str cmd subcmd case ramp ramp cmd ms mode case cmd mode cmd mode mode keyword host mode host rc mode rc msg unrecognized mode str cmd mode webeye source code vc model setl case clear clear reload reload setup setup reset reset check check hex hex cmd cmd get get cmd msg unrecognized cmd name str cmd name case return proc perform proc zoom start dev dir dev speed zoom speed cur zoom speed dev dir xff zero zoom speed zooming return zoom currently zooming cmd unhex device start tele wide dev dir currently zooming true return response zoom start proc zoom start proc zoom currently zooming cmd unhex device zoom currently zooming false webeye source code vc model setl return response zoom proc zoom proc zoom speed zoom speed zoom speed max zoom speed zoom speed min max zoom speed dev dir dev speed zoom speed zoom speed dev dir xff zero zoom speed zooming currently zooming zoom currently zooming dev dir zoom speed cur zoom speed sign change zoom speed cmd unhex device zoom cmd unhex device zoom speed char dev speed cmd unhex device zoom start dev dir cmd unhex device zoom speed char dev speed cur zoom speed zoom speed return response zoom speed fixed zoom speed proc zoom speed proc zoom zoom factor speed currently zooming zoom speed om zoom speed speed zoom factor max min zoom webeye source code vc model setl zoom factor min max zoom dev factor zoom factor zoom factor seconds depending time limit abs zoom factor gamma cur zoom factor max abs cur zoom speed cmd unhex device zoom bytes dev factor time limit cur zoom factor zoom factor return response zoom fixed zoom factor speed om cur zoom speed proc zoom proc zoom zoom scale speed return zoom zoom scale cur zoom factor speed proc zoom proc move start dev pan dir dev pan speed pan speed cur pan speed dev tilt dir dev tilt speed tilt speed cur tilt speed dev pan dir zero speeds panning dev tilt dir return move currently moving cmd unhex device pan tilt start dev pan dir dev tilt dir currently moving true return response move start proc move start proc move currently moving cmd unhex device pan tilt currently moving false webeye source code vc model setl return response move proc move proc move speed pan speed tilt speed pan speed max pan speed pan speed min max pan speed tilt speed max tilt speed tilt speed min max tilt speed dev pan dir dev pan speed pan speed pan speed dev tilt dir dev tilt speed tilt speed tilt speed dev pan dir zero speeds panning dev tilt dir currently moving move cur dev pan dir gamma pan speed cur pan speed cur dev tilt dir gamma tilt speed cur tilt speed currently moving dev pan dir cur dev pan dir dev tilt dir cur dev tilt dir sign change pan tilt speed cmd unhex device pan tilt cmd unhex device pan tilt speed char dev pan speed char dev tilt speed cmd unhex device pan tilt start dev pan dir dev tilt dir moving sign change simple speed change cmd unhex device pan tilt speed char dev pan speed char dev tilt speed cur pan speed pan speed webeye source code vc model setl cur tilt speed tilt speed return response move speed fixed pan speed fixed tilt speed proc move speed proc move pan tilt ms speed assert ms om speed om currently moving move planning trajectories places go clamp request case caller hasn bothered deal published limits pan max gamma pan min tilt max gamma tilt min pan gamma cur pan tilt gamma cur tilt deg sqrt deg time axis called indexed integer deg deg ramp ticks ms ticks cur ramp accel max speed max ramp ticks speed change tick max ceil ramp ticks point ramp obtain speed om speed max min move speed speed min max move speed speed speed ms tick deg sec deg tick assert speed assert exists gamma gamma 
jjj speed speed min accel traj speed ceil webeye source code vc model setl ms max min deg deg sec sec ceil ms ticks max traj get fast revise accordingly setting max speed trajectory see proc max traj reaches rounding nearest half tick assert exists gamma gamma 
jjj max traj speed accel min max speed traj speed ceil reach upwardly revised time okay min ceil gamma assert degenerate case slipped find point departure max traj assert exists gamma 
jjj traj mid trajectory speed slope going speed traj gammak trajectory function max traj traj speed take pick ramp cmds move speed cmd 
round integer theory cmds gamma ramp cmds 
move speed cmd speed gammax ramp cmds gamma 
move cmd cmds move start cmd speed cmds cmd 
time limit allow sec final responses cmds cmds ms tick time limit responses cmds webeye source code vc model setl msg str cmds commands sent str responses responses received response responses loop gamma cmd cmds response satisfies cmd report response cmd loop camera settle final position speed suitable current zoom factor pan tilt max zoom cur zoom factor return response move fixed pan fixed tilt speed om speed elseif ms om ms proc move proc move ms speed return move cur pan cur tilt ms speed proc move proc move speed cmd speed deg sec speed ms tick gamma dev pan speed pan speed deg sec gamma dev tilt speed tilt speed deg sec return unhex device pan tilt speed char dev pan speed char dev tilt speed proc proc move start cmd speed deg sec speed ms tick dev pan dir gamma pan speed deg sec webeye source code vc model setl dev tilt dir gamma tilt speed deg sec return unhex device pan tilt start dev pan dir dev tilt dir proc proc move cmd return unhex device pan tilt proc proc jump pan tilt pan tilt max move speed return response move fixed pan fixed tilt proc jump utility move jump move status reload cur pan cur tilt hardware pan gamma cur pan tilt gamma cur tilt deg sqrt deg deg deg base time limit reasonable assumption greater error longer trajectories move speed settle speed settle speed settle time deg settle speed dev pan pan pan dev tilt tilt tilt cmd unhex device pan tilt bytes dev pan bytes dev tilt settle time cur pan pan cur tilt tilt proc webeye source code vc model setl proc ramp ms ms max ms min second ramp pretty incredibly slow cur ramp ms return response ramp str ms proc ramp proc mode host clear toggle rts cmd unhex device mode select pc cur mode host setup auto detects home re reads pan tilt zoom info return response mode host setup notices proc mode host proc mode rc clear toggle rts cmd unhex device mode select remote controller cur mode rc return response mode rc proc mode rc proc init condition serial line cmd initialize return response proc init proc clear lower rts line ms raise cmd clear return response proc clear proc reload note model impression platform currently zooming updated reload webeye source code vc model setl don know read bits hardware 
directions bound zoom pan tilt start read update zoom pan tilt speeds just assumes sign think similarly update current control mode host rc 
return response zoom status notices move status notices proc reload proc zoom status cmd unhex device zoom status response cmd cmd string response response response dev zoom speed abs response dev zoom factor bytes response dev zoom dir gamma zoom speed cur zoom speed cur zoom speed zoom speed dev zoom dir dev zoom speed cur zoom factor zoom factor dev zoom factor return response zoom speed fixed cur zoom speed zoom fixed cur zoom factor msg unexpected response str decode response zoom status command str decode cmd return reset negative response response proc zoom status proc move status cmd unhex device pan tilt status response cmd cmd string response response response dev pan speed abs response dev tilt speed abs response dev pan bytes response webeye source code vc model setl dev tilt bytes response dev pan dir gamma pan speed cur pan speed cur pan speed pan speed dev pan dir dev pan speed dev tilt dir gamma tilt speed cur tilt speed cur tilt speed tilt speed dev tilt dir dev tilt speed cur pan pan dev pan cur tilt tilt dev tilt return response move speed fixed cur pan speed fixed cur tilt speed move fixed cur pan fixed cur tilt msg unexpected response str decode response pan tilt status command str decode cmd return reset negative response response proc move status proc reset negative response frame hack obviously 
turns canon starts responding status requests negative response continue 
db fault glitch canon firmware remains unknown 
fortunately happens rarely day early months testing 
remedy works pull hammer reset condition detected 
frame abs frame bit abs frame bit return reset return response proc proc setup cmd unhex device pan tilt setup response cmd cmd sec time limit string response response response webeye source code vc model setl pass response absolute position reload pick moment anyway msg unexpected response str decode response pan tilt setup command str decode cmd return reload refresh model state hardware state proc setup proc reset init cmd provoke vc auto init sec time limit return mode host proc reset proc check zoom factor cur zoom factor pan tilt cur pan cur tilt reload move fuzz constants respectable place abs cur pan gamma pan abs cur tilt gamma tilt fiction zoom factor 
certainly just position servo controlling zoom ring abs cur zoom factor gamma zoom factor return reset return response proc check proc hex cmd low level experimentation response cmd unhex cmd second time limit wow return response frame str decode response proc hex proc get response webeye source code vc model setl value case mode cur mode zoom factor cur zoom factor zooming currently zooming zoom speed cur zoom speed position cur pan cur tilt moving currently moving move speed cur pan speed cur tilt speed ramp cur ramp msg unrecognized get argument str case return proc get model replies client record including notices proc response notices fg notices notices return proc proc cmd cmd time limit command get lo lev response seq fg seq cmd cmd second response timeout default seq time limit time limit return step seq proc proc cmds cmds tick ms time limit cmds responses seq fg seq cmds cmds seq tick ms tick ms second response timeout default seq time limit time limit return step seq proc webeye source code vc model setl proc step seq send command sequence packet get response writea seq fd seq reada seq fd response eof msg yhwh got eof sequencer quitting quit gracefully return response proc op satisfies response cmd assert string cmd response cmd return true string response return false response cmd response char abs response bit response response min cmd cmd return true return false op proc report response cmd string response msg non string response str response command str decode cmd msg unexpected response str decode response command str decode cmd proc general note speed conversions conversions yield sign single character suitable plugging device level command magnitude positive integer range suitable passing bytes 
webeye source code vc model setl zoom rate conversions zoom hardware requires direction bit magnitude 
provide zero direction value xff valid values tele wide think zoom speed supply 
don know relationship available speeds direction actual change zoom factor second mapping just take zoom speed spec map nearest integer gamma 

get dev zoom dir xff dev zoom speed om get dev zoom dir positive negative dev zoom speed magnitude going way take direction indicators speed range map pair gamma 
gamma symbolized max zoom speed code 
proc zoom speed zoom speed round zoom speed max zoom speed min max zoom speed case sign gamma return gamman gamma abs gamma return xff om return gamma case proc proc zoom speed dev zoom dir dev zoom speed case dev zoom dir return zoom speed gamma xff return webeye source code vc model setl return dev zoom speed case proc zoom factor conversions know relationship zoom ring position zoom factor just scale linearly try logarithmically looks better 
define zoom lo min zoom define zoom hi max zoom define dev zoom lo define dev zoom hi proc zoom factor zoom factor zoom factor gamma zoom lo zoom hi gamma zoom lo max min rounding quite fair anyway return round dev zoom hi gamma dev zoom lo dev zoom lo proc proc zoom factor dev zoom factor dev zoom factor gamma dev zoom lo dev zoom hi gamma dev zoom lo max min return zoom hi gamma zoom lo zoom lo proc pan tilt rate conversions device units degrees second ideal 
conversions map signed pan speed tilt speed sign magnitude pair 
magnitude suitable device pan tilt speed command sign pan tilt start 
speed range gamma degrees second pan gamma tilt positive meaning webeye source code vc model setl respectively 
conversions obvious inverse range check rounding 
proc pan speed pan speed round pan speed max pan speed min max pan speed case sign gamma return gamman abs return return case proc proc pan speed dev pan dir dev pan speed case dev pan dir return pan speed return return dev pan speed case proc proc tilt speed tilt speed round tilt speed max tilt speed min max tilt speed case sign gamma return gamman abs return return case proc proc tilt speed dev tilt dir dev tilt speed case dev tilt dir return tilt speed return return dev tilt speed case proc webeye source code vc model setl pan tilt conversions natural units degrees 
canon takes units deg pan tilt 
hex midpoint home go hex pan tilt representing deg pan deg tilt 
device convention pan backwards 
proc pan pan return round max gamma min proc proc pan dev pan return gamma dev pan proc proc tilt tilt return round tilt max gamma min proc proc tilt dev tilt return dev tilt gamma proc trajectory functions proc max traj value ramp max speed extension assert max ceil ramp ticks point ramp ceil return gamma gamma kn means ramp covers 
follow ramp gamma travel max speed rest way webeye source code vc model setl return traj gamma max speed proc max traj proc traj speed follow ramp go assert integer assert assert don need strange caller 
return max traj speed gammak proc op ms ticks ms example ticks return ms ms tick op independent unpacker byte spam op bytes return char div char mod op op bytes return abs abs op proc quit gracefully exit gracefully str filename seq fd seq fd proc include vc decode setl include vc exit setl include vc msg setl webeye source code vc mouse setl vc mouse setl service provided mouse client service vc setl section called parent program vc toplev setl section textually includes vc exit setl section vc getname setl section vc msg setl section vc obtain setl section vc provide setl section source code const yhwh vc mouse setl strange little service java clients take unusual view mouse gestures doing local timing interpretation result mouse events agree call click linger jump zoom 
mapped combinations moving jumping just moving usual sigmoid speed motion trajectory zooming see vc setl 
const width const height const gamma const const gamma const const sigterm fd open sigterm signal catch term signals const server fd fileno provide service mouse var clients fg var fd om webeye source code vc mouse setl loop ready select fd server fdg domain clients sigterm fd ready msg yhwh str pid caught sigterm quit gracefully client clients pump fd jjj pump fd ready loop done client pump fd loop server fd ready fd accept server fd fd om name getname fd msg name accepted pump fd pump pump fd gamma child fd fileno obtain service loop line getline fd om split line case click num num val val pan norm gamma width width tilt norm height gamma height zoom get zoom factor dist norm sqrt pan norm tilt norm zoom scale gamma dist norm webeye source code vc mouse setl pan norm zoom tilt norm zoom zoom scale zoom zoom scale move move zoom zoom scale printa fd reply empty line linger num num val val pan norm gamma width width tilt norm height gamma height zoom get zoom factor pan rate sign pan norm pan norm zoom tilt rate sign tilt norm tilt norm zoom move speed pan rate tilt rate move start printa fd reply empty line jump num num command uses natural units pan val tilt val jump pan tilt printa fd reply empty line zoom num zoom val zoom zoom max min webeye source code vc mouse setl printa fd reply empty line move printa fd reply empty line case loop assert false parent continues close fd client fg client name name clients pump fd client loop proc new cmd name cmd fg cmd name name return cmd proc proc cmd cmd writea fd cmd fd response line return response line currently check proc proc jump pan tilt jump pan tilt webeye source code vc mouse setl proc proc jump pan tilt jump pan tilt proc proc jump toby pan tilt cmd new cmd jump cmd subcmd toby cmd pan pan cmd tilt tilt cmd cmd proc proc move pan tilt move pan tilt proc proc move pan tilt move pan tilt proc proc move toby pan tilt cmd new cmd move cmd subcmd toby cmd pan pan cmd tilt tilt cmd cmd proc proc move start cmd new cmd move cmd subcmd start cmd cmd proc proc move cmd new cmd move webeye source code vc mouse setl cmd subcmd cmd cmd proc proc move speed pan speed tilt speed cmd new cmd move cmd subcmd speed cmd pan speed pan speed cmd tilt speed tilt speed cmd cmd proc proc zoom factor cmd new cmd zoom cmd subcmd cmd zoom factor factor cmd cmd proc proc zoom scale cmd new cmd zoom cmd subcmd cmd zoom scale scale cmd cmd proc proc get cmd new cmd get cmd return cmd cmd proc op num return om op proc done client pump fd msg clients pump fd name done webeye source code vc mouse setl close pump fd clients pump fd om proc done client proc quit gracefully exit gracefully pump client client name pump fd client clients pump fd proc include vc provide setl include vc obtain setl include vc getname setl include vc exit setl include vc msg setl webeye source code vc mover setl vc mover setl service provided mover client service vc setl section called parent program vc toplev setl section textually includes vc simpler setl section source code const yhwh vc mover setl simplified move command interface 
client just sends pair numbers pan tilt line 
name service provide define service name mover number parameters command define full details command send service define build cmd cmd fg cmd name move cmd subcmd cmd pan val cmd tilt val include vc simpler setl webeye source code vc msg setl vc msg setl textually included vc camera setl section vc setl section vc event setl section vc giver setl section vc httpd setl section vc image setl section vc input setl section vc setl section vc model setl section vc mouse setl section vc ptz setl section vc push setl section vc recv setl section vc send setl section vc seq setl section vc simpler setl section vc snap setl section source code program includes file server started vc toplev setl subprocess thereof identifies string yhwh routine message log file vc toplev setl captures output sent stderr subprocesses feeds output routine vc admin setl prefixed timestamp yhwh 
proc msg printa stderr yhwh proc webeye source code vc obtain setl vc obtain setl textually included vc setl section vc giver setl section vc httpd setl section vc setl section vc mouse setl section vc ptz setl section vc push setl section vc seq setl section vc simpler setl section vc snap setl section source code open tcp client port named service proc obtain service serv name var serv host serv port serv host serv port find service serv name return open serv host str serv port socket proc find location service registered name proc find service serv name var fd serv info fd fileno open getenv vc lookup socket writea fd serv name reada fd serv info close fd return serv info proc webeye source code vc provide setl vc provide setl textually included vc camera setl section vc setl section vc event setl section vc giver setl section vc httpd setl section vc image setl section vc setl section vc mouse setl section vc push setl section vc simpler setl section vc snap setl section source code open tcp server port publish availability 
port number chosen arbitrarily proc provide service serv name const sock open str server socket sock om hostname place localhost distributed system publish service serv name localhost port sock pid om non zero client may wish wait retry return sock proc publish availability service registering name location proc publish service serv name serv host serv port serv pid const fd fileno open getenv vc publish socket writea fd serv name serv host serv port serv pid close fd redundant environment variable external parties vc tcp serv name serv host str serv port proc webeye source code vc ptz setl vc ptz setl client services vc setl section notice vc setl section called parent program vc camera setl section textually includes vc decode setl section vc exit setl section vc getname setl section vc msg setl section vc obtain setl section source code const yhwh vc ptz setl program instantiated pumping process child vc camera setl client high level command interface canon vc pan tilt zoom ptz camera controller 
file descriptor connected client socket program inherits identified program invocation command line 
const arg fd fileno open val command line socket const fd arg fd fd arg fd mnemonic inherited socket const sigterm fd open sigterm signal catch term signals const fd open server mid level command server var notice fd om mid level event notification service open ignore retain control output errors welcome canon vc pan tilt zoom camera control server webeye source code vc ptz setl type help help 
db bacon cs nyu edu help marker prev words help loop pool fd fd notice fdg notice fd may om ready select pool sigterm fd ready msg yhwh str pid caught sigterm quit gracefully fd ready line getline fd om quit gracefully words split line words words prev words prev words words cmd words case command language needs comment convention 

cmd ceq help help command name send lines prefixed followed line containing single words commands help command name webeye source code vc ptz setl mode jjj notify fon jjj zoom factor jjj factor jjj jjj outg speed move pan tilt jjj pan ms jjj speed fup jjj jjj left jjj deg ms jjj speed document jump ramp ms show jjj notify jjj zoom jjj move jjj position jjj clear reload setup reset check quit null command empty line repeats previous command cmd name words case cmd name ceq help help gives compact synopsis commands optional words shown brackets grouping indicated braces alternatives separated bars jjj command names arguments case insensitive clarity shown literal names starting uppercase letter 
substitute value possibly hyphenated name begins lowercase letter 
numbers may include signs decimal points help command show produces output back client asynchronous notification see notify command 
tell piece help ends lines leave final line occurs 
server usage errors protocol mistakes webeye source code vc ptz setl reported help format 
output show consists single line asynchronous notification event message ends easy recognize help command name tells specific command cmd name ceq notify notify turns asynchronous notification 
client get event message formatted command recognized server convenience playback change mode zoom pan tilt ramp zoom pan tilt limit reached 
messages corresponding command formatted similarly added 
catch message canon showing things hardware saying notify turns asynchronous notification 
get information synchronously show command cmd name ceq zoom note zoom speeds canon speeds going tele wide accordingly speed speed clauses zoom commands number range 
zooming way zoom factor zoom factor reverse take seconds maximum speed seconds minimum speed zoom factor speed sets current zoom factor floating point value webeye source code vc ptz setl zoom factor speed scales current zoom factor specified factor zoom speed equivalent zoom zoom speed equivalent zoom cmd name ceq move move pan tilt ms jjj speed points camera pan degrees azimuth tilt degrees elevation stores current values positive means right pan tilt range pan tilt resolution deg angular trajectory shaped parabola suggested ramp period 
angular distance move large maximum speed sustained interval acceleration deceleration ramps constrained optional specification ms specified server try plan camera motion trajectory takes ms milliseconds speed specified trajectory speed limited maximum constant speed interval acceleration deceleration ramps units speed speed deg sec resolution deg sec range deg sec move pan tilt ms jjj speed adds pan degrees azimuth tilt degrees elevation current pan tilt values calls move cmd name ceq deg ms jjj speed synonymous move deg plus options webeye source code vc ptz setl cmd name ceq deg ms jjj speed synonymous move deg plus options cmd name ceq left left deg ms jjj speed synonymous move deg plus options cmd name ceq right right deg ms jjj speed synonymous move deg plus options cmd name ceq ramp ramp ms sets number milliseconds pan tilt apparatus take get maximum speed move move requests long take slow destination approached default ms shouldn jerk platform 
look way smooth eh cmd name ceq show show commands produce output form command fed back server re establish state reported show show mode yields mode host mode rc show notify yields notify notify asynchronous notification event message show result sent client single webeye source code vc ptz setl newline terminated line show zoom yields current zoom factor zoom command show jjj yields current pan tilt angles move command show ramp yields ramp command current ramp period see reload check cmd name ceq mode mode host puts pan tilt zoom apparatus state receptive commands computer hand held remote control uses clear toggle rts line requests device mode change calls setup auto detection home position server state refreshment mode rc zoom move commands computer meaning client 
ignored switch mode host uses clear toggle rts line requests device mode change cmd name ceq clear clear toggles rts line rs communications link effort cancel wait state entered canon vc merely wastes little time hardware state called automatically mode command called webeye source code vc ptz setl reset cmd name ceq reload reload causes server refresh record hardware state reading current zoom pan tilt parameters canon vc asynchronous notification sends zoom move event messages reflecting newly read values try command think show lying 
see check reload called automatically setup called mode host called reset host mode reload detect control mode host rc 
parameter assumed unchanged best definiteness set mode command cmd name ceq setup setup causes canon vc hardware auto detect pan tilt home position calls reload refresh server record hardware state done automatically final stage mode host called reset host mode take long seconds camera swings wildly home position back cmd name ceq reset reset causes canon vc camera control unit ccu re initialize 
ccu lower cts line rs communications link seconds process 
cts raised server webeye source code vc ptz setl attempt establish control mode obtained reset calling mode command cmd name ceq check check perform sanity check canon vc camera control unit ccu reset appears malfunctioning 
reasons unknown ccu gets state responds normally serial line fact ignoring zoom motion commands check effectively show reload looks discrepancies 
primarily intended external automata find ccu responding see check action zooming say setting far show reporting doing check watching effects reset transient camera motion image notify event messages normally result reset cmd name ceq quit quit asks server drop network connection technical reasons mildly preferable client drop network connection usually simply closing 
server follow suit 
avoids compulsory msl wait retire half association tcp module server host server drops 
words reason don quit merely close socket done really big deal invalid argument help command try help help webeye source code vc ptz setl case help marker cmd ceq notify notify fon jjj words switch words case switch ceq notice fd open notice server switch ceq notice fd om close notice fd notice fd om help notify argument try help notify case help notify command requires argument try help notify cmd ceq zoom zoom jjj zoom speed zoom speed zoom factor jjj factor jjj jjj outg speed case words words ceq start zoom start words words ceq zoom words words ceq speed num words zoom speed val words zoom speed zoom speed words webeye source code vc ptz setl words words ceq words num words zoom val words words help zoom command parameter error try help zoom elseif num words zoom val words words elseif words ceq words num words zoom val words words help zoom command parameter error try help zoom elseif words ceq zoom words elseif words ceq zoom words help zoom command parameter error try help zoom help zoom command parameter error try help zoom case start speed deprecated de documented may disappear release software cmd ceq move move jjj move speed pan speed tilt speed move pan tilt jjj pan ms jjj speed case words words ceq start move start webeye source code vc ptz setl words words ceq move words words ceq speed num words num words pan speed val words tilt speed val words move speed pan speed tilt speed words words toby words ceq words elseif words ceq words toby num words num words pan val words tilt val words move toby pan tilt words help move command parameter error try help move help move command parameter error try help move case cmd ceq speed speed pan speed tilt speed words num words num words pan speed val words tilt speed val words move speed pan speed tilt speed webeye source code vc ptz setl help speed command parameter error cmd ceq deg ms jjj speed words num words tilt val words move tilt words help command parameter error try help cmd ceq deg ms jjj speed words num words tilt val words move words help command parameter error try help cmd ceq left left deg ms jjj speed words num words pan val words move words help left command parameter error try help left cmd ceq right right deg ms jjj speed words num words pan val words move pan words help right command parameter error try help right cmd ceq jump words num words num words webeye source code vc ptz setl pan val words tilt val words jump pan tilt help jump command parameter error try help jump implement jump cmd ceq ramp ramp ms words num words ms val words ramp ms help ramp command requires numeric argument try help ramp cmd ceq show show jjj notify jjj zoom jjj position jjj move jjj case words 
ceq mode mode get mode mode mode words 
ceq notify notify notice fd om words 
ceq zoom zoom factor get zoom factor zoom fixed zoom factor words 
ceq zooming zooming get zooming zoom zooming start words 
ceq zoom speed zoom speed get zoom speed zoom speed fixed zoom speed words 
ceq position words 
ceq move pan tilt get position webeye source code vc ptz setl move fixed pan fixed tilt words 
ceq moving moving get moving move moving start words 
ceq speed words 
ceq move speed pan speed tilt speed get move speed move speed fixed pan speed fixed tilt speed words 
ceq ramp ms get ramp ramp str ms help show command parameter error try help show case cmd ceq mode mode jjj words mode words case mode ceq host mode host canon computer control mode ceq rc mode rc canon control help unrecognized mode mode try help mode case help mode command requires argument try help mode cmd ceq clear clear words clear help clear command takes arguments try help clear webeye source code vc ptz setl cmd ceq reload reload words reload help reload command takes arguments try help reload cmd ceq setup setup words setup help setup command takes arguments try help setup cmd ceq reset reset words reset help reset command takes arguments try help reset cmd ceq check check words check help check command takes arguments try help check cmd ceq hex hex cmd command advertised help 
words hex words hex words help hex command requires hex argument cmd ceq quit quit words webeye source code vc ptz setl quit gracefully help quit command takes arguments try help quit help unrecognized command try help case fd notice fd om notice fd ready reada notice fd notice eof help mid level notice service crashed sorry msg eof filename notice fd closing close notice fd notice fd om string notice canon notice canon str notice notice fd loop case insensitive comparison strings aggregates thereof op ceq return string upper upper forall jjj ceq op op num return om op webeye source code vc ptz setl op hex return string mod fa op proc take trouble sure carriage return newline strictly speaking line oriented internet programs supposed communicate client program happens telnet running dos windows carriage return characters welcome 
conversely hurt clients running say unix 
check output errors fair assume client drops connection seen soon input side eof 
printa fd proc proc line help message proc proc fill point paragraph para filter fmt mash line split para para gamma loop mash line mash loop proc proc help diagnostic form help message help marker webeye source code vc ptz setl proc proc new cmd name cmd fg cmd name name return cmd proc proc zoom toby zoom words words words ceq num words speed val words zoom toby zoom speed elseif words zoom toby zoom help error speed option try help zoom proc proc zoom subcmd cmd new cmd zoom cmd subcmd subcmd case subcmd start pass pass speed cmd zoom speed gamma cmd zoom factor cmd speed cmd zoom scale cmd speed case cmd cmd proc proc move toby pan tilt words words num words words words ceq num words ms val words words webeye source code vc ptz setl move toby pan tilt ms elseif words words ceq num words speed val words words move toby pan tilt speed elseif words move toby pan tilt help error option try help move proc proc move subcmd cmd new cmd move cmd subcmd subcmd case subcmd start pass pass speed cmd pan speed cmd tilt speed cmd pan cmd tilt cmd ms elseif cmd speed case cmd cmd proc proc jump toby pan tilt cmd new cmd jump cmd subcmd toby cmd pan pan cmd tilt tilt cmd cmd proc webeye source code vc ptz setl proc ramp ms cmd new cmd ramp cmd ms ms cmd cmd proc proc mode mode cmd new cmd mode cmd mode mode cmd cmd proc proc clear cmd new cmd clear cmd cmd proc proc reload cmd new cmd reload cmd cmd proc proc setup cmd new cmd setup cmd cmd proc proc reset cmd new cmd reset cmd cmd proc proc check cmd new cmd check cmd cmd proc proc hex device cmd webeye source code vc ptz setl cmd new cmd hex cmd cmd device cmd cmd cmd proc proc get cmd new cmd get cmd value cmd cmd return value proc proc cmd cmd writea fd cmd fd response line eof help mid level command service crashed sorry msg eof filename fd closing quit gracefully service return response line proc proc open server fd obtain service fd om help mid level command service sorry msg open service quit gracefully service return fd proc proc open notice server fd obtain service notice fd om help mid level notice service sorry msg open notice service webeye source code vc ptz setl take non fatal error 
return fd proc proc quit gracefully degenerate currently pump pipe attached child exit gracefully proc include vc obtain setl include vc getname setl include vc decode setl include vc exit setl include vc msg setl webeye source code vc push setl vc push setl service provided push client service image vc image setl section called parent program vc toplev setl section textually includes vc exit setl section vc getname setl section vc msg setl section vc obtain setl section vc provide setl section setl section source code const yhwh vc push setl send infinite multi part mime document consisting stream images benefit browsers support server push model 
long netscape evil empire explorer 
const sigterm fd open sigterm signal catch term signals const server fd fileno provide service push var clients fg loop ready select fd server fdg domain clients sigterm fd ready msg yhwh str pid caught sigterm quit gracefully webeye source code vc push setl client clients pump fd jjj pump fd ready loop done client pump fd loop server fd ready fd accept server fd fd om name getname fd msg name accepted pump fd pump pump fd gamma child uri protocol mime headers get request fd mu massage uri uri fg mu cmd jpeg someday may dispatch content type image fd obtain service image image fd om printa fd sorry printa fd server webeye printa fd content type text plain printa fd printa fd jpeg source temporarily unavailable printa fd please try printa fd ok printa fd server webeye printa fd content type multipart mixed replace boundary eom printa fd printa fd eom loop doing printa image fd jpeg reada image fd eof image image fd assert image printa fd content type image jpeg printa fd content length str webeye source code vc push setl printa fd printa fd image printa fd eom flush fd integer mu rate select om mu rate delay mu rate ms loop parent continues close fd child hangs client fg client pump fd pump fd client name name clients pump fd client loop proc done client pump fd msg clients pump fd name done close pump fd clients pump fd om proc done client proc quit gracefully exit gracefully pump client client name pump fd client clients pump fd proc include vc provide setl include vc obtain setl include vc getname setl include vc exit setl include vc msg setl include setl webeye source code vc quit setl vc quit setl called parent program vc restart setl section textually includes vc admin setl section source code const yhwh vc quit setl box const lock vc quitting lock file mutex const pid dir vc pid const main pid file pid dir vc toplev const ps cmd ps ps solaris commence acquire mutex exit abnormally right away main pid file relieve main pid file true msg pid record main pid file reason abandon cleanup effort early relieve executed cleaned just extra sure pid dir pid file split filter echo pid dir jjj pid file notin pid dir loop relieve pid file false loop msg directory pid dir doesn exist msg seriously broken installation msg webeye source code vc quit setl msg calling str ps cmd system ps cmd msg done release mutex exit normally proc relieve pid file complain id val getfile pid file integer id id id msg file str pid file contain valid process id elseif id msg sending term signal pid str id kill id process supposed propagate signal wait seconds process go away loop id select om loop clear process process group case components orphaned children msg sending term process group str id kill give polite signal ms take effect select om blast away misguided msg sending kill process group str id kill kill elseif complain msg process id str id proc relieve include vc admin setl webeye source code vc recv setl vc recv setl called parent program vc seq setl section calls child program vc input setl section textually includes vc exit setl section vc msg setl section source code const yhwh vc recv setl low level serial input receiver program tries build frames canon vc messages characters received vc input 
frame received created result error detection encapsulated setl string written stdout new line 
const vc input cmd exec setl vc input setl needed const vc input vc input invoke vc input setl const sigterm fd open sigterm signal catch term signals var fd open input loop get char om input source keeps yielding oms 
quit 
msg obtain character vc input quit gracefully length abs length length loop webeye source code vc recv setl get char max ms chars om meaning inter char timeout goto tell parent loop remove char put abs gamma length abs mod meaning checksum error goto tell parent bad length byte means serious trouble 
drain input arrives soon report checksum error 
msg bad length byte hex draining input loop get char om pass char ms predecessor soon loop meaning checksum error goto tell parent tell parent write flush stdout loop get character ms milliseconds return om timeout proc get char ms max retries retries retry retries ms om ready select fin fd sigterm fdg ms ready select fin fd sigterm fdg webeye source code vc recv setl sigterm fd ready msg yhwh str pid caught sigterm quit gracefully fd ready getc fd om retries max retries really want 
msg vc input went 
restarting close fd select om wait sec fd open input msg vc input fd str fd goto retry return return om proc proc open input fd open vc input pipe fd om msg open vc input quit gracefully return fd proc proc quit gracefully exit gracefully vc input fd proc include vc exit setl include vc msg setl webeye source code vc restart setl vc restart setl called parent program vc cron setl section calls child programs vc go setl section vc quit setl section textually includes vc admin setl section source code const yhwh vc restart setl restart box meaning necessary preserve old log start const lock vc restarting lock file mutex const vc lock vc lock box lock file const vc log vc log box log file const vc num vc number contains seq log saved const vc go cmd exec setl vc go setl const vc quit cmd exec setl vc quit setl commence acquire mutex exit abnormally right away msg calling str vc quit cmd quit rc system vc quit cmd quit rc msg str vc quit cmd terminated abnormally msg vc lock msg str vc quit cmd completed normally lock file vc lock exists msg removing vc lock force unlink vc lock webeye source code vc restart setl vc log val getfile vc num saved log vc log str msg moving vc log saved log system mv vc log saved log vc num str msg calling str vc go cmd system vc go cmd msg done release mutex exit normally include vc admin setl webeye source code vc send setl vc send setl called parent program vc seq setl section calls child programs vc setl section vc clear setl section vc setl section vc init setl section textually includes vc msg setl section source code const yhwh vc send setl low level sender program normally invoked vc send simply setuid wrapper compiled program containing main setl setl vc send setl setl substituted absolute pathname setl program setl driver makefile 
com dev command line filter exec setl vc setl com fd fileno open com dev tie stdin stdout loop doing read frame eof frame case frame system exec setl vc init setl webeye source code vc send setl system exec setl vc clear setl system exec setl vc setl msg unrecognized special command pretty frame case operations cause putc device com fd fail close com fd select om wait ms device com fd fileno open com dev frame abs frame putc com fd char frame frame char mod flush com fd print loop include vc msg setl webeye source code vc seq setl vc seq setl client service notify vc event setl section called parent program vc model setl section calls child programs vc recv setl section vc send setl section textually includes vc exit setl section vc msg setl section vc obtain setl section source code const yhwh vc seq setl low level canon vc command sequencer pump takes commands sequences thereof clocked attached tick schedules 
remains receptive times event notices generated canon mixed command responses may delayed 
advantage taken fact canon doesn necessarily wait response command sending 
example commence panning zooming operation time order seconds receive confirmation newly accomplished settings 
send asynchronously received notices notify service events unexpected responses see calls local notify routine program 
const ack time limit ms low level receiver const fd fileno open exec setl vc recv setl pipe webeye source code vc seq setl interface low level sender vc send setl const vc send cmd exec setl vc send setl needed const fd fileno open vc send pump const note fd fileno obtain service notify event consumer const sigterm fd open sigterm signal open ignore see put frame tie stdin stdout loop ready select exit sigterm fdg fd ready state treat controller note frame get frame frame om notify frame stdin ready read seq command packet map eof quit gracefully time limit round seq time limit cmd seq cmd om response cmd cmd time limit write response elseif cmds seq cmds om responses cmds cmds seq tick ms time limit write responses msg unrecognized seq form str seq ignored webeye source code vc seq setl loop proc get frame reada fd frame eof msg eof str filename fd quit gracefully elseif frame inter char timeout return frame elseif frame checksum error put frame unhex checksum error nak return om elseif frame illegal byte frame return frame elseif ack nak frame return frame note response ack char bit abs frame bit put frame ack ack whichever note frame notify frame return om return frame proc get frame proc cmd cmd time limit put frame cmd cmd return cmd awaiting ack true response om deadline clock time limit webeye source code vc seq setl time left time limit time left loop ready select exit sigterm fin fdg time left fd ready frame get frame frame om frame inter char timeout bad frame return frame abandon command response frame elseif ack nak frame awaiting ack ack frame response om return response awaiting ack false abandon command response nak frame return frame ack nak unexpected notify frame treat note ignore response awaiting ack got ack return frame take frame response didn get ack strange supported response frame returned ack comes time left deadline gamma clock loop return way indicating kind timeout proc cmd proc cmds cmds tick ms time limit const cmds responses webeye source code vc seq setl timer fd open str tick ms real ms tick cmds loop cmd cmds tick loop ready select exit sigterm fd fdg timer fd ready timer fd dummy tick fd ready frame get frame frame om responses frame loop put frame cmd ack deadline clock ack time limit ack time left ack time limit ack time left loop awaiting ack ready select exit sigterm fin fdg ack time left fd ready frame get frame frame om ack frame ack time left got ack quit loop responses frame nak frame ack time left give waiting ack responses ack timeout ack time left give waiting ack webeye source code vc seq setl ack time left ack time left ack deadline gamma clock loop loop deadline clock time limit time left time limit enter final stage just waiting time limit number responses reach original number commands responses time left loop ready select exit sigterm fin fdg time left fd ready frame get frame frame om responses frame time left deadline gamma clock loop close timer fd return responses proc cmds op note frame return string frame frame abs frame bit abs frame bit op op ack nak frame return string frame frame abs frame bit frame id byte op op ack frame webeye source code vc seq setl return ack nak frame abs frame cmd id byte op op nak frame return ack nak frame abs frame cmd id byte op proc notify frame writea note fd frame flush note fd proc proc select exit sigterm fds max time max time ready select fdg fds ready select fdg fds max time sigterm fd ready msg yhwh str pid caught sigterm quit gracefully return ready proc proc put frame frame output operation provokes remain unaware explicitly requested open ignore signal 
detect disappearance sender checking eof getline fd om normally sender acks requests empty line writea fd frame getline fd om msg str filename fd appears crashed quit gracefully proc webeye source code vc seq setl proc quit gracefully exit gracefully str filename fd fd str filename fd fd proc include vc obtain setl include vc exit setl include vc msg setl webeye source code vc simpler setl vc simpler setl textually included vc jumper setl section vc mover setl section vc setl section textually includes vc exit setl section vc getname setl section vc msg setl section vc obtain setl section vc provide setl section source code file meant included define yhwh name program includes code service name mover build cmd statements build cmd send service const sigterm fd open sigterm signal catch term signals const server fd fileno provide service service name var clients fg loop ready select fd server fdg domain clients sigterm fd ready msg yhwh str pid caught sigterm quit gracefully client clients pump fd jjj pump fd ready loop done client pump fd loop webeye source code vc simpler setl server fd ready fd accept server fd fd om name getname fd msg name accepted pump fd pump pump fd gamma child fd fileno obtain service loop line getline fd om split line forall parm jjj num parm build cmd writea fd cmd fd response printa fd response normally empty line loop parent continues close fd client fg client name name clients pump fd client loop op num return om op proc done client pump fd webeye source code vc simpler setl msg clients pump fd name done close pump fd clients pump fd om proc done client proc quit gracefully exit gracefully pump client client name pump fd client clients pump fd proc include vc provide setl include vc obtain setl include vc getname setl include vc exit setl include vc msg setl webeye source code vc snap setl vc snap setl service provided snap client service image vc image setl section called parent program vc toplev setl section textually includes vc exit setl section vc getname setl section vc msg setl section vc obtain setl section vc provide setl section setl section source code const yhwh vc snap setl server sends single wrapped jpeg image closes 
const sigterm fd open sigterm signal catch term signals const snap fd fileno provide service snap var clients fg loop ready select fd snap fdg domain clients sigterm fd ready msg yhwh str pid caught sigterm quit gracefully client clients pump fd jjj pump fd ready loop done client pump fd loop webeye source code vc snap setl snap fd ready fd accept snap fd fd om name getname fd pump fd pump pump fd gamma child uri protocol mime headers get request fd mu massage uri uri fg ignore details get post request 
image fd fileno obtain service image printa image fd jpeg reada image fd image image fd assert image printa fd ok printa fd server webeye printa fd content type image jpeg printa fd content length str printa fd pragma cache printa fd expires printa fd putc fd image close fd child hangs client fg client name name clients pump fd client loop proc done client pump fd close pump fd clients pump fd om webeye source code vc snap setl proc done client proc quit gracefully exit gracefully pump client client name pump fd client clients pump fd proc include vc provide setl include vc obtain setl include vc getname setl include vc exit setl include vc msg setl include setl webeye source code vc toplev setl vc toplev setl services provided lookup publish called parent program vc go setl section calls child programs vc camera setl section vc setl section vc event setl section vc setl section vc setl section vc giver setl section vc httpd setl section vc image setl section vc jumper setl section vc mouse setl section vc mover setl section vc push setl section vc snap setl section vc setl section textually includes vc admin setl section vc allowed setl section vc getname setl section source code const yhwh vc toplev setl primordial program box known webeye 
starts servers box catches log output necessary shuts 
version tries bring server management high standard 
takes advantage consistent obtain service provide service idiom parents start pump pipe processes webeye source code vc toplev setl setl source texts servers process trees transitively depend services order start servers 
note server provide multiple services client obtain multiple services child program instantiated multiply 
goodness setl maps 
file named lock serves lock sure instance box running time local host 
file named vc link web server points static document saying process coming pseudo document created dynamically fully come know port number static document saying shutting static document saying 
external party probably cgi script simply try read link file gets report box started 
see example vc master cgi vc cgi instantiated 
const stub vc toplev base name logging purposes const lock vc lock lock file mutex const vc link vc link html link const starting name vc starting html const running name vc running html const stopping name vc stopping html const name vc html const master name vc html template running name file const pid dir vc pid directory recording server process ids var pub fd om miscellaneous file descriptors var lookup fd om 
var health fd om 
var waiter fd om miscellaneous pseudo fds webeye source code vc toplev setl var sigterm fd om 
var wait time var service db fg service name 
host port pid var fd map fg fd 
server name var src names var server map client map var started servers started commence acquire mutex exit abnormally right away stub point link just process coming document redirect link starting name process group leader see terminate external record pid likes vc quit vc check pid dir stub str pid sigterm fd open sigterm signal catch term signals global dependency analysis phase slow probably moved configuration time re done source file changes raw names program sources src names name split filter grep const yhwh vc setl jjj src name notin server map scan provide service service name 
server name client map scan obtain service service name 
client name exec front invocations setl driver idiomatic shell bin sh implicitly launch commands started open filter system webeye source code vc toplev setl depending shell implementation command tricky things redirections consists multiple process specifications hangs 
interferes desire send signals sigterm setl subprocesses shell propagate told 
easier solution simply shell move way soon parsed command set redirections ready launch setl subprocess see proc start program example parent child map parent child src name src names line split filter prep cmd src name jjj egrep 
exec setl setl jjj line doing src name setl parent src name line 
setl line setl 
child line start core services identify environment variables pub fd core service publish vc publish publication lookup fd core service lookup vc lookup information start warning timer report services fail come waiter fd open real ms wait time minutes melt server map client map removing entries services come 
record servers started order shut reverse order msg starting servers server map loop webeye source code vc toplev setl servers server map started 
prerequisite constituent programs server server name transitive closure parent child map client map meaning clients dependent services 
servers range server map jjj server notin started forall pgm transitive closure parent child map server jjj pgm notin range client start servers main loop new service publishes old service db service db service db old service db loop main loop step loop service names domain service db gamma old service db assert service names presume time main loop step service name arb service names msg service service name revise maps preparatory re evaluating dependencies server map service name om client fg loop close waiter fd finished egg timer waiter fd om close pub fd allow publication pub fd om health fd core service health vc health sanity check instantiate pseudo document running master getfile master name webeye source code vc toplev setl gsub master lookup getenv vc lookup lookup service locus running name master master instantiation getfile running name master msg fatal problem creating file running name terminate msg created running name point link running pseudo document 
real document give location lookup service cgi script pick 
redirect link running name stub loop terminate called main loop step loop try link file point appropriately life cycle phase proc redirect link target unlink vc link clear error link target vc link error error msg str vc link refers str target msg problem pointing str vc link str target error proc pre process setl source proc prep cmd src name check early terminate request ready select fdg sigterm fd ready msg yhwh str pid caught sigterm webeye source code vc toplev setl terminate return setl src name jjj awk source code jjj sed 
proc obtain service name 
program name sans setl suffix map proc scan return service name src name src name src names line split filter prep cmd src name jjj grep jjj grep proc jjj line doing service name line 
src name setl proc start core service location visible child processes environment variable proc core service serv name envt var var serv fd serv host serv port serv pid serv loc locals serv fd open server socket listen arbitrary port serv host localhost serv port port serv fd serv pid pid include service db entry core service service db serv name serv host serv port serv pid serv loc serv host str serv port core service visible envt var serv loc record parties external box vc tcp serv name serv loc return serv fd proc proc start servers webeye source code vc toplev setl server servers loop set command shell redirect server stderr stdout stream 
pipe mode start server ll able pick debugging diagnostic output children stderr child may stdout redirected communication parent cmd exec setl server setl fd open cmd pipe fd om fd map fd server server pid dir server str pid fd record process id started server insert server front list msg fatal open pump cmd terminate case terminate mistakenly returns loop proc proc main loop step ready select fd lookup fd health fd sigterm fd waiter fdg domain fd map pub fd om pub fd ready fd accept pub fd fd om allowed fd reada fd service name service info service db service name service info msg getname fd trying provide service close fd webeye source code vc toplev setl lookup fd ready fd accept lookup fd fd om allowed fd local clients expected rapid lookup requests immediately close connection 
loop doing reada fd service name eof printa fd service db service name loop msg refusing lookup service getname fd close fd health fd ready fd accept health fd fd om allowed fd placeholder global checks want program printa fd ok faith self health msg refusing health check service getname fd close fd waiter fd om waiter fd ready reada waiter fd wait time msg services str domain server map started webeye source code vc toplev setl str wait time minute waiting sigterm fd ready msg yhwh str pid caught sigterm terminate fd ready jjj server fd map fd om loop getline fd om server msg server exited 
shutting box terminate code executed terminate return happen comes valid reason individual servers terminate close fd server fd map fd om loop proc main loop step proc terminate rc stub point just process shutting document redirect link stopping name get rid dynamically created pseudo document 
processes happen reading won disappear close system rm running name msg removed running name webeye source code vc toplev setl health fd om close health fd health fd om lookup fd om close lookup fd lookup fd om pub fd om close pub fd pub fd om inv fd map server fd server fd map fd try polite signal give servers chance clean server started loop fd inv fd map server msg sending term signal server pid str pid fd kill pid fd loop wait servers go 
assume progress long seconds silence goes fd map loop ready select domain fd map ready timeout 
resort signal remaining servers msg str range fd map exit killing server fd map fd loop kill pid fd kill close fd server fd map fd om webeye source code vc toplev setl loop response server 
telling log goes eof say exited fd ready loop server fd map fd getline fd om server close fd server fd map fd om loop loop lest servers abandoned children sure processes box receive term signal kill 
predicated assumption processes box process group 
avoid killing ourself signalling special child puts process group fork special child process box escape box process group kill send term processes box group select om wait sec plenty kill kill kill point document redirect link name stub rc webeye source code vc toplev setl error parent reach error 
just depends special child gets race don care wins 
really quite comfortable 
better spawn child starts process group right near start tree 
parent wait child exit group signalling lock release 
rc proc terminate proc transitive closure adapted page process seen fxg return fy doing process process fyg gamma seen seen fyg process proc include vc getname setl include vc allowed setl include vc admin setl webeye source code vc setl vc setl service provided client service vc setl section called parent program vc toplev setl section textually includes vc simpler setl section source code const yhwh vc setl simplified zoom command interface 
client just sends number zoom factor line 
name service provide define service name number parameters command define full details command send service define build cmd cmd fg cmd name zoom cmd subcmd cmd zoom factor val include vc simpler setl webeye source code setl setl textually included vc httpd setl section vc push setl section vc snap setl section source code read parse get post command triple consisting uri string protocol string mime header map proc get request fd getline fd kill effects split return cmd uri protocol upper cmd notin get post return uri protocol mime headers fg upper protocol om read lines loop doing getline fd kill effects split break om mime headers lower content length om val loop webeye source code setl content fd content printa stderr expected bytes content got content uri 
content return uri protocol mime headers proc get request parse uri map taken delimiters map elements taken separate key associate map element 
delimited element treated specially key taken cmd element associate 
element consisting comma separated pair unsigned integers taken associate key click 
missing associate taken null string 
elements containing multiple separators recognized remains taken associate 
op massage uri uri uri om uri uri return fg null map command parameters string uri uri return om simply respect uri fg uri cmd sub uri pair split uri return webeye source code setl op op general pair return om om return click sub 

return op op om return val elseif om return val elseif return split return op op escape convert certain characters hh hex return fg jjj hex op op escape map escape setl map web transmission escape gsub return op op convert hh hex escapes normal chars webeye source code setl loop fa fa om unhex len loop return op op map convert web form type spam setl map gsub change blanks split decode op op pair break part 
return 
op bibliography ada core technologies 
www gnat com 
home page ada compilation system gnat 
nyu ada project 
ada ed interpreter executable semantic model ada 
technical report courant institute mathematical sciences new york university july 
self documenting listing nyu ada ed compiler version validated june 
alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley 
montanari 
meta interpreting setl 
sed setl prototyping environment october 
allen 
program optimization 
mark halpern christopher shaw editors annual review automatic programming volume pages 
pergamon press new york 
frances allen 
control flow analysis 
acm sigplan notices july 
frances allen 
basis program optimization 
proc 
ifip congress pages 
north holland 
frances allen 
interprocedural data flow analysis 
proc 
ifip congress pages 
north holland 
frances allen 
method determining program data relationships 
andrei ershov editors proc 
international symposium theoretical programming ussr august volume lecture notes computer science pages 
springer verlag 
frances allen john cocke 
catalogue optimizing transformations 
editor design optimization compilers pages 
prenticehall 
frances allen john cocke 
graph theoretic constructs program control flow analysis 
technical report ibm res 
rep rc ibm watson research center yorktown heights ny 
frances allen john cocke 
program data flow analysis procedure 
communications acm march 
david bacon 
dave famous original setl server 
birch eecs lehigh edu bacon setl server html 
allows security restricted setl programs edited fetched run server host browser environment 
david bacon 
online 
birch eecs lehigh edu cgi bin html online html 
interface comp lang ada newsgroup 
david bacon 
setl home page 
birch eecs lehigh edu bacon 
home page long claimed home setl touted setl world wonderful programming language 
david bacon 

birch eecs lehigh edu 
view oscilloscope pair leds controlled browser 
david bacon 

birch eecs lehigh edu imp 
image view mounted spherical pointing motor 
david bacon 
movable zoomable web camera 
cgi bin 
instantiation webeye see chapter dissertation 
david bacon 
setl library documentation 
birch eecs lehigh edu bacon setl doc html 
david bacon 
slim 
birch eecs lehigh edu slim 
starting point adaptation documentation distribution files comprising herman slim language system longer maintains 
bernard banner 
private communication 
nancy baxter ed gary levin 
learning discrete mathematics 
springer verlag 
nancy hood baxter 
understanding students acquire concepts underlying sets 
james ed editors research issues undergraduate mathematics learning number maa notes pages 
mathematical association america washington dc 
david 
simplified wrapper interface generator 
www org 
bederson wallace schwartz 
miniature pan tilt actuator spherical pointing motor 
ieee journal robotics automation june 
published courant institute mathematical sciences new york university computer science technical report april 
benjamin bederson richard wallace eric schwartz 
spherical pointing motor 
united states patent april 

setl language cartography applications computational geometry algorithms 
sed setl prototyping environment 
bard bloom robert paige 
transformational design implementation new efficient solution ready simulation problem 
science computer programming 

setl monitor performance evaluator 
sed setl prototyping environment 
cai ph 
henglein paige schonberg 
type analysis data structure selection 
moeller editor constructing programs specifications pages 
north holland 
cai paige tarjan 
efficient bottom multi pattern matching trees 
theoretical computer science november 
cai robert paige 
program derivation fixed point computation 
science computer programming 
cai robert paige 
increased productivity algorithm implementation 
david notkin editor proc 
acm sigsoft symposium foundations software engineering sigsoft volume number software engineering notes pages 
association computing machinery special interest group software engineering december 
cai robert paige 
multiset discrimination solve language processing problems hashing 
theoretical computer science july 
canon usa vc communication camera 
www usa 
canon com vcc html 
domenico alfredo ferro 
techniques computable set theory applications proof verification 
communications pure applied mathematics september 
domenico alfredo ferro eugenio 
computable set theory 
clarendon press oxford 
chia hsiang chang robert paige 
regular expressions dfa compressed nfa 
theoretical computer science may 
nigel paul chapman 
theory practice construction efficient interpreters 
phd thesis university leeds 
clocksin mellish 
programming prolog 
springer verlag fourth edition 
john cocke 
global common subexpression elimination 
acm sigplan notices july 
john cocke ken kennedy 
algorithm reduction operator strength 
communications acm november 
john cocke raymond miller 
analysis techniques optimizing computer programs 
proc 
nd hawaii international conference system sciences pages honolulu hi january 
john cocke jacob schwartz 
programming languages compilers 
courant institute mathematical sciences new york university april 
daniel cooke 
language experiment constructs processing 
software practice experience november 
daniel cooke 
provides different way view programming 
computer languages 
patrick cousot radhia cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
proc 
th acm symposium principles programming languages pages january 
patrick cousot radhia cousot 
constructive versions tarski fixed point theorems 
pacific journal mathematics 
mike 
rexx language 
www ibm com rexx 
davis schwartz 
metamathematical extensibility theorem verifiers proof checkers 
comp 
math 
appl 
thierry despeyroux 
executable specification static semantics 
kahn macqueen plotkin editors semantics data types proc 
international symposium sophia antipolis france june volume lecture notes computer science pages 
springer verlag 
thierry despeyroux 
formalism implement natural semantics 
technical report inria 

setl programming language 
courant institute mathematical sciences new york university 
birch eecs lehigh 
edu bacon ps gz 
mccann 
macro snobol compiler 
software practice experience 
robert 
indirect threaded code 
communications acm june 
robert arthur grand ssu cheng liu jacob schwartz edmond schonberg 
programming refinement exemplified setl representation sublanguage 
acm transactions programming languages systems july 
edsger dijkstra 
notes structured programming 
structured programming pages 
academic press 
dijkstra 
discipline programming 
prentice hall englewood cliffs nj 

schwartz 
reusability design complex programs experiment setl optimizer 
proc 
itt workshop reusability software pages providence ri 
itt 


prototyping reusing software 
hall editors software re utrecht pages 
springer verlag 

hasselbring 
setl prototyping system sets 
zorn editor proc 
tool pages 
university karlsruhe november 

hasselbring 
investigating strategies cooperative planning independent agents prototype evaluation 
paolo ciancarini chris hankin editors coordination languages models proc 
international conference coordination italy april volume lecture notes computer science pages 
springer verlag 
longer version published university dortmund software technik memo nr 
december available ftp ls www cs uni dortmund de pub technische berichte memo ps gz 


inline expansion setl procedures 
acm sigplan notices 



set oriented program description language ada 
prieto diaz schafer cramer wolf editors proc 
international workshop software reusability pages july 
ernst 
efficient translation setl programs 
proc 
th hawaii international conference system sciences volume ii pages january 
ernst erich 
proposal integrating persistence prototyping language setl technischer bericht technical report university essen computer science software engineering april 
ernst erich 
integrating persistence set oriented prototyping language 
structured programming 
ernst erich dietmar fox 
software prototyping mit setl 
teubner verlag stuttgart 
ernst erich dietmar fox ulrich 
translating setl ada creating libraries data structures 
sed setl prototyping environment 
ernst erich wolfgang franke ulrich wilhelm hasselbring ulrich claus 
prototyping sets language definition 
technischer bericht technical report university essen computer science software engineering april 
ftp ls www cs uni dortmund de pub technische berichte berichte 
ps gz 
ernst erich wolfgang franke ulrich wilhelm hasselbring ulrich claus 
language prototyping sets 
nick editor proc 
rd international workshop rapid system prototyping pages 
ieee computer society press research triangle park nc june 
ernst erich ulrich 
setl ada tree transformations applied 
information software technology december 
dubois jean 
development programming environment setl 
nichols simpson editors esec proc 
st european software engineering conference strasbourg france september volume lecture notes computer science pages 
springer verlag 
huet kahn lang 
programming environments structured editors mentor experience 
shrobe sandewall editors interactive programming environments pages 
mcgraw hill 
driscoll sleator tarjan 
making data structures persistent 
journal computer system sciences 

programming language learning mathematics 
communications pure applied mathematics september 
nyu occasion jack schwartz th birthday 
ed stefan freudenberger schonberg schwartz 
reusability design large software systems experiment setl optimizer 
ted biggerstaff alan perlis editors software reusability volume concepts models pages 
acm press new york 
ed harel 
nature process conception function 
harel pages 
ed uri 
learning algebra 
springerverlag 
earley 
high level iterators method data structure choice 
computer languages 
william fenton ed 
discrete mathematics 
springer verlag 
amelia fong 
generalized common subexpressions high level languages 
proc 
th acm symposium principles programming languages pages january 
amelia fong 
inductively computable constructs high level languages 
proc 
th acm symposium principles programming languages pages january 
amelia fong john kam jeffrey ullman 
application lattice algebra loop optimization 
proc 
nd acm symposium principles programming languages pages january 
amelia fong jeffrey ullman 
induction variables high level languages 
proc 
rd acm symposium principles programming languages pages january 
amelia fong jeffrey ullman 
finding depth flow graph 
comput 
syst 
sci 
free software foundation 
gnu unix gnu project free software foundation fsf 
www gnu org 
stefan freudenberger jacob schwartz micha sharir 
experience setl optimizer 
acm transactions programming languages systems january 
matthew fuchs 
escaping event loop alternative control structure multi threaded guis 
unger bass editors engineering hci 
chapman hall 
engineering human computer interface available www cs nyu edu phd students fuchs 
david gelernter 
generative communication linda 
acm transactions programming languages systems january 
deepak goyal 
improved intra procedural may alias analysis algorithm 
technical report courant institute mathematical sciences new york university february 
cs cs nyu edu phd students deepak publications improvement ps 
deepak goyal 
language theoretic approach algorithms 
phd thesis new york university january 
deepak goyal robert paige 
formal reconstruction improvement linear time fragment willard relational calculus subset 
bird meertens editors ifip tc working conference algorithmic languages calculi pages 
chapman hall 
deepak goyal robert paige 
new solution hidden copy problem 
giorgio levi editor static analysis proc 
th international symposium sas pisa italy september volume lecture notes computer science pages 
springer verlag 
nyu griffin project 
griffin programming language 
ftp cs nyu 
edu pub griffin 
ralph griswold griswold 
implementation icon programming language 
princeton university press 
ralph griswold griswold 
icon programming language 
peer peer communications third edition 
ralph griswold clinton jeffery gregg townsend 
graphics programming icon 
peer peer communications 
griswold 
snobol programming language 
prentice hall englewood cliffs nj second edition 
harel ed editors 
concept function aspects epistemology pedagogy 
number maa notes 
mathematical association america washington dc 
harrison 
setl simple implementation setl 
setl newsletters november 
hasselbring 
integrating generative communication prototyping language 
technischer bericht technical report university essen computer science software engineering december 
ftp ls www cs uni dortmund de pub technische berichte berichte 
ps gz 
hasselbring 
translating subset setl setl 
technischer bericht technical report university essen computer science software engineering january 
hasselbring 
formal specification linda 
technischer bericht technical report university essen computer science software engineering september 
ftp ls www cs uni dortmund de pub technische berichte berichte ps gz 
hasselbring 
animation object specifications set oriented prototyping language 
bowen hall editors user workshop proc 
th user meeting cambridge uk workshops computing pages 
springer verlag june 
published university dortmund software technology research report available ftp ls www cs uni dortmund de pub hasselbring ps gz 
hasselbring fisher 
investigating parallel interpretation tree model matching algorithms linda 
software technik memo university dortmund december 
ftp ls www cs uni dortmund de pub technische berichte hasselbring fisher swt memo ps gz 
hasselbring fisher 
linda prototyping language investigating mimd algorithms model matching computer vision 
ferreira jose editors parallel algorithms irregularly structured problems proc 
second international workshop irregular lyon france september volume lecture notes computer science pages 
springer verlag 
published university dortmund software technology research report available ftp ls www cs uni dortmund de pub hasselbring fisher irregular ps gz 
hasselbring kirsch 
implementing parallel algorithms prototype evaluation transformation 
software technik memo university dortmund january 
ftp ls www cs uni dortmund 
de pub technische berichte hasselbring kirsch swt memo ps gz 
wilhelm hasselbring 
prototyping parallel algorithms linda 
jens editor parallel computation proc 
second international conference austria october volume lecture notes computer science pages 
springer verlag 
published university essen computer science software engineering technischer bericht technical report available ftp ls www cs 
de pub technische berichte berichte ps gz 
wilhelm hasselbring 
approaches high level programming prototyping concurrent applications 
software technik memo university dortmund january 
ftp ls www cs uni dortmund de pub technische berichte hasselbring swt memo ps gz 
wilhelm hasselbring 
linda approach prototyping parallel systems 
journal systems software november 
published university dortmund software technology research report available ftp ls www cs uni dortmund 
de pub technische berichte hasselbring ps gz 
wilhelm hasselbring andreas 
combining omt prototyping approach 
journal systems software november 
published university dortmund software technology research report available ftp ls www 
cs uni dortmund de pub technische berichte hasselbring ps gz 
hoare 
axiomatic basis computer programming 
communications acm 
hoare 
data reliability 
proc 
international conference reliable software pages 
ieee cat 
ch csr 
jim hugunin 
home 
www org 
iana 
internet assigned numbers authority 
www iana org 
ieee 
ieee standard information technology portable operating system interface posix part shell utilities volumes 
institute electrical electronics engineers 
ieee ansi std iso iec 
ieee 
ieee standard information technology portable operating system interface posix part system application program interface api language 
institute electrical electronics engineers 
ieee ansi std iso iec 
ieee 
ieee standard information technology portable operating system interface posix protocol independent interfaces pii 
institute electrical electronics engineers march 
draft standard 
iverson 
programming language 
john wiley new york 
eric johnson kevin 
advanced window applications programming 
books new york second edition 
neil jones carsten gomard peter sestoft 
partial evaluation automatic program generation 
prentice hall international uk 
marc kaplan jeffrey ullman 
general scheme automatic inference variable types 
proc 
th acm symposium principles programming languages pages 
keller 
cantor tutorial user guide 
education report 
kepler paris 
keller 
sed setl prototyping environment 
final report sed project esprit february 
keller paige 
program derivation verified transformations case study 
communications pure applied mathematics september 
yo keller 
cantor version 
kepler paris february 
richard kelsey william clinger editors jonathan rees 
revised report algorithmic language scheme 
www swiss ai mit edu scheme html 
kempe software capital enterprises 
ada web java 
www com resources ada java html 
ken kennedy 
global flow analysis algorithm 
international journal computer mathematics december 
ken kennedy 
node listings applied data flow analysis 
proc 
nd acm symposium principles programming languages pages january 
ken kennedy 
comparison algorithms global data flow analysis 
siam comput march 
brian kernighan rob pike 
practice programming 
addisonwesley 
research 
www com 
philippe edmond schonberg jacob schwartz 
software prototyping setl programming language 
ieee software october 
doug lea 
concurrent programming java design principles patterns 
addison wesley 
lindsey van der meulen 
informal algol 
north holland 
liu 
lazy setl debugging persistent data structures 
phd thesis new york university november 
liu 
persistent runtime system persistent data structures 
acm symposium applied computing pages february 
liu 
system visualizing animating program runtime histories 
ieee symposium visual languages pages 
ieee computer society press september 
liu 
advanced library symbolic computing 
technical report tr cis purdue university indianapolis february 
lloyd 
programming integrated functional logic language 
journal functional logic programming march 
cs tu berlin de journal articles html 
james low paul 
techniques automatic selection data structures 
proc 
rd acm symposium principles programming languages pages january 
james low 
automatic coding choice data structures volume interdisciplinary systems research 
birkhauser verlag basel 
david mathews 
distribution page 
www math purdue edu ccc distribution html 
milner tofte harper 
definition standard ml 
mit press 
thomas minka 
ple lecture notes python 
vismod www media mit edu ple python python html 
morel renvoise 
global optimization suppression partial redundancies 
communications acm february 
steven muchnick neil jones 
program flow analysis theory applications 
prentice hall englewood cliffs nj 
donald 
interactive set language 
notices american mathematical society march 
review software package 
henry max goldstein 
primer 
courant institute mathematical sciences new york university 
netscape communications 
core javascript 
developer netscape com docs manuals js core index htm 
object management group 
corba 
www omg org 
open group 
single unix specification version 
open group february 
volume set document number 
freely searchable line www org publications catalog htm 
reilly associates 
www perl com 
home page perl 
john ousterhout 
scripting higher level programming st century 
ieee computer march 
www com people john ousterhout scripting html 
paige schwartz 
expression continuity formal differentiation algorithms 
proc 
th acm symposium principles programming languages pages january 
robert paige 
programming invariants 
ieee software january 
robert paige 
real time simulation set machine ram 
editors proc 
volume ii computing information pages 
canadian scholars press toronto may 
robert paige 
efficient translation external input dynamically typed language 
simon editors technology foundations th world computer congress ifip transactions volume pages 
north holland september 
robert paige 
viewing program transformation system 
manuel hermenegildo editors programming language implementation logic programming proc 
th international symposium plilp madrid spain september volume lecture notes computer science pages 
springer verlag 
plilp joint symposium th international conference algebraic logic programming alp 
robert paige 
directions program transformations 
computing surveys december 
robert paige fritz henglein 
mechanical translation set theoretic problem specifications efficient ram code case study 
journal symbolic computation august 
robert paige koenig 
finite differencing computable expressions 
acm transactions programming languages systems july 
robert paige robert tarjan robert 
linear time solution single function coarsest partition problem 
theoretical computer science september 
robert paige yang 
high level reading data structure compilation 
proc 
th acm symposium principles programming languages pages january 
parallax basic stamps 
www com 
toto 
string matching native package setl language march 
available electronic mail request cs nyu edu 
raymond sandra 
apl language usage 
prentice hall englewood cliffs nj 
enrico 
programming sets 
www cs nmsu edu sets 
rossi jayaraman editors 
workshop declarative programming sets number del dipartimento di matematica 
universita di parma september 
www math dps papers html 
rossi 
programming sets 
math sets index html 
schonberg shields 
prototype efficient implementation case study setl technical report courant institute mathematical sciences new york university july 
edmond schonberg jacob schwartz micha sharir 
automatic technique selection data representations setl programs 
acm transactions programming languages systems april 
schwartz 
set theory language program specification programming 
courant institute mathematical sciences new york university 
schwartz brown schonberg 
user manual 
programming interim report setl project pages 
originally appeared setl newsletter 
jacob schwartz 
programming interim report setl project 
courant institute mathematical sciences new york university revised 
schwartz 
automatic data structure choice language high level 
communications acm december 
schwartz 
optimization high level languages value transmission corollaries 
computer languages 
schwartz 
optimization high level languages ii deducing relationships inclusion membership 
computer languages 
schwartz schonberg 
programming sets setl 
springer verlag 
randal schwartz 
learning perl 
reilly associates 
keith julie hawks jennifer 
horizontal vertical growth student conception function 
harel pages 

solutions business integration 
www com 
home page tcl tk 
robert 
concepts programming languages 
addison wesley fourth edition 
nyu setl project 
setl newsletters 
numbers courant institute mathematical sciences new york university 
david shields 
user guide brief 
setl newsletters march 
josh simon 
michigan terminal system 
www clock org jss mts 

calculating properties programs valuations specific models 
acm sigplan notices 
kirk snyder 
setl programming language 
technical report courant institute mathematical sciences new york university january 
ftp cs nyu edu pub local hummel setl setl ps kirk snyder 
setl programming language update current developments 
technical report courant institute mathematical sciences new york university september 
ftp cs nyu edu pub local hummel setl update ps lindsey 
seeing logic programming sets 
phd thesis university kansas 
www edu papers phd dissertation dir visual logic sets html 
steven pemberton 
short abc language 
www cwi nl steven abc 
richard stevens 
unix network programming volume 
prentice hall upper saddle river nj second edition 
tarski 
lattice theoretical fixpoint theorem application 
pacific journal mathematics 
aaron tenenbaum 
type determination high level languages 
phd thesis new york university october 
thompson 
haskell craft functional programming 
addison wesley 
see haskell org 
united states department defense 
manual ada programming language ansi mil std 
springer verlag new york february 
guido van rossum 
python patterns implementing graphs 
www python org doc essays graphs html 
guido van rossum 
comparing python languages 
www python org doc essays comparisons html 
guido van rossum 
python language website 
www python org 
julius 
private communication 
julius 
programming language revised 
ftp cs nyu edu pub languages 
herman 
slim programming language 
birch eecs 
lehigh edu slim default htm 
larry wall tom christiansen randal schwartz 
programming perl 
reilly associates second edition 
richard wallace 
nexus 
www org 
warren jr setl implementation optimization look setl compilation target code style 
programming interim report setl project pages 
revision setl newsletter 
gerald weiss 
recursive data types setl automatic determination data language description efficient implementation 
technical report courant institute mathematical sciences new york university october 
gerald weiss edmond schonberg 
recursive structures dataflow analysis presence infinite type sets 
technical report courant institute mathematical sciences new york university august 
chung yung 
extending typed calculus sets 
proc 
april 
cs cs nyu edu phd students yung publications 
ps gz 
chung yung 
eas experimental applicative language sets 
proc 
march 
cs cs nyu edu phd students yung publications eas ps gz 
chung yung 
destructive effect analysis finite differencing strict functional languages 
phd thesis new york university august 

