computable isomorphisms degree spectra relations scott families khoussainov cornell university ithaca ny usa university auckland auckland new zealand richard shore cornell university ithaca ny usa studying effective structures investigate effective content typical notions constructions branches mathematics including universal algebra model theory 
particular interested possibilities model theoretic algebraic constructions limits possibilities 
instance try understand certain results model theory universal algebra carried effectively 
try discover sharp effective counterexamples 
systematic study effectiveness algebraic structures goes back pioneering papers fr shepherdson rabin early 
early nerode collaborators initiated combining algebraic constructions priority arguments computability theory new era development subject 
nowadays various approaches effectiveness structures 
example nerode remmel developing theory time partially supported aro msi cornell university daal 
partially supported nsf dms aro msi cornell university daal 
structures 
khoussainov nerode began development theory automatic structures 
interested structures basic computations performed turing machines 
definition structure language computable decidable domain computable computable enumeration ai atomic elementary diagram ai computable 
structure isomorphic computable decidable structure called computably presentable 
isomorphism structure computable decidable structure called computable decidable presentation examples computable computably presentable structures 
natural numbers addition multiplication computable structure 
ordered field rational numbers finitely algebras decidable word problem free groups vector spaces field rationals computable presentations 
give general notion effective structure 
definition structure language computably enumerable computable enumeration ai positive atomic diagram ai computably enumerable 
structure isomorphic computably enumerable structure called 
computably presentable 
isomorphism structure computably enumerable structure called computably enumerable presentation finitely algebras natural examples structures 
note computable structure computably enumerable 
model theory universal algebra identify isomorphic structures 
introducing effectiveness consideration area naturally want understand relationship classical isomorphism types effective isomorphism types 
model theory universal algebra identify isomorphic structures effective model theory concerned computable isomorphisms finding characterizations structures computable isomorphism type 
definition computable structures computable isomorphism type computable isomorphism dimension structure number computable isomorphism types 
dimension structure maximal number isomorphic computable presentations structure 
stress dimension structure class computable presentations differ dimension structure class presentations 
example dimension set rationals class computable presentation 
show dimension linear ordering class presentations 
deal mainly computable presentations 
dimensions considered respect class computable presentations structures specify 
similarly structures considered computable mentioned 
far computable isomorphism types classical ones seen result goncharov theorem computable structure computable dimension significant interest trying understand nature structures dimension 
basic model theoretic notion motivated consideration structures dimension notion countable categoricity 
theory countably categorical computable noncomputable countable models isomorphic 
arbitrary countable structure categorical theory countably categorical 
analogous concept effective model theory deals computable structures isomorphisms definition structure computably categorical computable structure isomorphic computably isomorphic result results nature computably categorical structures theorem structure conditions equivalent 
decidable presentations computably isomorphic 

exists finite number constants prime model theory set atoms theory computable 
late goncharov remmel independently gave algebraic characterization computably categorical boolean algebras linear orderings 
theorem 
boolean algebra computably categorical finitely atoms 

linear ordering computably categorical number adjacent pairs ordering finite 
goncharov proved structure presentations computable decidable decidable dimension structure 
conversation khoussainov goncharov asked analogous result obtained answer question question structure presentations computably enumerable computable computable dimension structure class presentations 
answer question theorem proof basic result theorem theorem exists structure exactly computably enumerable presentations properties hold 
computably enumerable computable structure 

computable structure 

computably enumerable presentation computably isomorphic 
interestingly structures shown computably categorical common property 
scott families 
definition scott family structure computable sequence 
xn 
xn 
formulas satisfiable finite tuple elements tuple elements satisfies formulas tuples satisfying formula sequence interchanged automorphism basic idea definition 
scott family computable structure isomorphic existence scott family allows effectively carry back forth argument construct computable isomorphism theorem structure scott family computably categorical 
tuple 
cn expanded structure 
cn scott family computably categorical 
proof 

xn 
xn 
scott family 
am 
computable presentations define mapping stages 
assume 
ai element ai corresponding constant aj classical isomorphism 
stages define images elements odd stages define preimages elements 
stage 
set 

stage 
suppose function defined 
assume 

bs ds extended isomorphism 
number domain 
consider tuple 
bs 
find 
bs holds 

ds holds 
find 
ds holds 
extend letting 
stage 
define similarly put element range 
fi 
computable isomorphism 
second part theorem slightly change original scott family 
set 

yn cj yj 
easily check sequence 
scott family expanded structure 
cn 
point observations effect expanding computably categorical structures finitely constants 
mentioned known examples computably categorical structures scott families 
natural ask exists computably categorical structure scott family 
theorem possible way build structure provide example computably categorical structure expansions finitely constants computably categorical 
second motivations computable categoricity comes model theoretic notion categoricity 
easy consequence theorem structure countably categorical structure expanded finitely constants 
analogous situation effective model theory wish consider 
goncharov proved computable structure theory decidable computably categorical scott family 
computably categorical structure decidable universal existential theory remains computably categorical expanded finitely constants 
millar proved decidability structures existential theory sufficient show categoricity preserved expansions theorem structure computably categorical existential theory decidable expansion finitely constants computably categorical 
informally theorem states effectively solve systems algebraic equation inequations computably categorical structure computable categoricity preserved expansions finite number constants 
partial decidability assumption problem known millar goncharov problem open time 
question expansion computably categorical structure finitely constants computably categorical 
negative solution problem 
theorem corollary extension main result gives new solution simpler proof theorem natural number exists computably categorical structure element expanded structure dimension immediate consequence theorem corollary exists computably categorical structure scott family 
proof 
consider structure existence claimed theorem 
structure computably categorical 
structure scott family contradiction theorem 
theorem suppose essential reason structure constructed theorem scott family expansion finite number constants computably categorical 
ask question question exist computably categorical structure scott family expansion finite number constants computably categorical 
application ideas proof basic result theorem provides positive answer question 
construction prove theorem simplified establish theorem exists computably categorical structure scott family expansion finite number constants computably categorical 
note proven similar result quite different methods 
slightly modifies family computable enumerations constructed codes family unary algebra way produce computably categorical structure decidable existential theory scott family 
combining result theorem gives theorem 
referee directing 
turn basic result theorem 
theorem degree spectra relations structures 
definition relation computable structure define partial ordering computable presentation turing reducibility sets natural numbers ub image call partially ordered set degree spectrum 
recall computable presentation includes isomorphism determines extensive study degree spectra relations computably structures related results 
refer readers papers ash nerode ash knight ash knight millar suggested investigating relations finite degree spectra 
motivations came fact ash nerode type decidability conditions relations see usually imply degree spectrum infinite singleton 
motivation goncharov examples structures finitely computable isomorphism types 
open question call degree spectra problem question finite partially ordered set isomorphic relation structure 
modifying goncharov construction provide examples relations finite degree spectra 
theorem exists relation structure exactly computable presentations computable noncomputable set 
theorem improves result theorem exists relation structure exactly computable presentations computable computable 
relation isomorphism extends map computable 
goncharov announced construction computable structure dimension relation degree spectrum consists noncomputable degree 
grew earlier khoussainov construction family sets certain properties 
construction supply goncharov poses called degree spectra problem question problem 
methods enable give positive solution problem theorem computable partially ordered set exists structure dimension cardinality relation guarantee computable presentation element element 
natural strengthenings result ruled observation relation computable structure set computable presentation countable partial orderings realized degrees degree spectrum relation computable structure 
just consider complicated 
similarly partial ordering element realized turing degrees degree spectrum computable relation computable structure true finite set degrees realized degree spectrum relation computable structure degree spectrum containing degree degree uncountable set member uncountable 
see example sacks iii natural question degree realized degree spectrum 
just answered question adapting extending methods show tuples degrees realized degree spectra 
goncharov asks problem pairs generally tuples degrees realized structure dimension precisely pairs tuples 
note structures considered directed graphs elementary notions graph theory example edge relation component path connectedness denote edge relation graph 
definitions notions basic text graph theory 
basic result construction goal section prove theorem exists relation structure exactly computable presentations image computable image computable 
relation isomorphism extends map computable 
proof 
order describe structure need notation 
natural number consider directed graph 
hold 

denote graph 
see cycle length tag 
call top coding location graph 
set containing 
consider sequence bn pairwise disjoint graphs bn isomorphic 
define graph disjoint union graphs bn identifying top elements graphs 
denote graph 
note isomorphic 
warning abuse notation confusing isomorphism type individual graphs isomorphic 
similarly leave details choosing computable representations graphs computable sets associated operations representations disjoint union reader 
graphs disjoint domains 
suppose set nonempty 
top elements respectively 
suppose domain empty intersection domain 
define new graph follows 
domain consists elements top element 

edge relation defined follows 
pair belongs 
example isomorphic isomorphic isomorphic 
note isomorphic 
set graphs consider operation applied graphs produces graph isomorphic disjoint union graphs 
operation extended follows 

gn 
sequence graphs disjoint domains 
gn definition graph domain gi edge relation gi 
note components graph form bn 
want produce computable presentations graph form bn bi bj fact guarantee property holds stage 
precisely stage presentations ak form bn bi bj note bi bj graph clearly rigid nontrivial automorphisms 
addition want produce unary relation properties 
element coding location 

image computably enumerable computable 

image computable 

computable copy computably isomorphic 
dimension degree spectrum consists exactly degrees computable 
computable structures computably isomorphic 
important aspect construction provide computable binary predicate holds belongs belongs exists isomorphism extending map need property construct computably categorical structures expansions constants computably categorical 

standard enumeration partial computable directed graphs 
consider standard enumeration 
computable partial functions 
order build structure unary relation properties need satisfy requirements de rj gj isomorphic gj computably isomorphic wish show computable graph isomorphic computably isomorphic know special form described ak limit computable graphs gj form gj bn bi bj require true stage gj bn bi bj loss generality require enumerations gj component yt gj xt ak yt xt 
enumerate components gj right form top cycles attached cycles added contained ak components partially enumerated allow extensions possible components distinct 
done add single desired element required form 
construction need computable 
achieved effectively listing elements strictly increasing order 
action meet requirement de operations graphs define 
definition operation applied bn produces graph denoted 
bn isomorphic bn bn bn 
adopt important convention elements component bi ones corresponding graph component bi bi 
bn elements new graph corresponding ones bi original graph new elements bi bi 
operation applied bn produces graph 
bn isomorphic bn 
bn bn 
apply operation construction apply corresponding convention elements component bi ones corresponding graph component bi bi 
bn elements new graph corresponding ones bi original graph new elements bi bi 
definition obtain lemma 
lemma graph bn graphs 
bn 
bn isomorphic extend bn 
operations applied components graph obtain extensions suppose graph form bn ck 
consider extensions 
bn ck 
bn ck 
lemma extensions isomorphic 
explain meet requirements de rj separately 
strategy meet just de 
constructing structures type soon equals number coding location construction acts extending structure structure extending structure structure construction puts puts image action meets requirement de 
note number put new convention applying operations 
construction puts strategy meet just rj follows 
constructing structures type stage partial isomorphism gj empty 
stage wait gj provides components isomorphic 
soon gj provides components say extend previous partial isomorphism adding partial isomorphisms respectively 
gj isomorphic structure construction building strategy constructs computable isomorphism gj structure 

problem arise case construction tries satisfy requirements de just rj simultaneously 
brief informal explanation problem 
suppose construction acted meet requirement rj components acted meet de 
words gj provided components say isomorphic respectively construction partial isomorphism say gj defined coding locations addition defined coding location 
suppose stage construction equals coding location 
construction acts meet de operations 
construction guarantee extended isomorphism gj 
suppose stage gj provides components isomorphic components containing coding location extended 
component previously isomorphic isomorphic new isomorphism type component previously isomorphic 
construction changes mind attempts constructing new isomorphism gj 
action meet requirement de stage force construction change mind constructing isomorphism gj see infinitely de potentially force construction change mind infinitely times satisfy rj 
define basic notions construction 
module satisfying requirements de just requirement rj gj th partial computable graph appropriate form 
gt approximation stage 
module construct isomorphic structures unary relations binary predicate isomorphic computably isomorphic 
construction proceeds stages 
stage module notions terminology 

finite structures approximations isomorphic structures construction building 
ak ak ak ak structure ak ak computable 
structures isomorphic 
ak form 

construction guarantee isomorphic 

ask 
requirement de construction assigns coding location ae goals construction put ae ae 
image go ae 
coding locations different component success attempt meets requirement de number put 
functions stage partial isomorphism gt ak construction designated isomorphism 
function may extend previous isomorphism 
extend previous isomorphism say construction changes 
designated isomorphism 
special component 
construction picks component st structure called special component 
exist infinitely stages construction changes isomorphism special component st infinite components embedded finite isomorphic 
say component embedded just case 
stage construction changes designated isomorphism isomorphic computably isomorphic ak 

special components 
construction ensures isomorphic special component components ak stage special component st structure embedded components 
recovers stage see definition recovery components satisfy properties 

construction change isomorphism rk substructure participated operation 

construction changes isomorphism rk rk substructure 

stage construction changes isomorphism recovers infinitely times isomorphic construction guarantees special component isomorphic 
marking recovery 
component ak exists unique component gt embedded component ak say covered equivalently covers construction components ak marked special symbol called waiting mark 
say recovers stage equivalently stage recovery stage stage component ak marked exists unique component covers notion recovery show isomorphic computably isomorphic 
idea 
suppose isomorphic construction component ak marked waits cover component soon recovers stage unique component gt covers construction defines isomorphic embedding attempts guarantee isomorphic recover stage say waiting state 
waiting state stage construction isomorphic ak 
general construction objects example coding locations ae functions waiting mark defined additional indices correspond nodes priority tree 
module satisfy requirements de 
stage 
isomorphic graph 
partial isomorphisms empty designated partial isomorphism 
put waiting state mark components recovery stage define st st isomorphic graph 
stage recovery stage go 
recovery stage proceed follows action 
define partial isomorphisms components marked partial isomorphism maps component gt component covered suppose construction previously designated isomorphism 
cases 
case 
suppose rk extends rk case set special component ak 
special component extends special component previous stage 
case participated operation case 
suppose rk extend rk case construction changes designated partial isomorphism set special component ak image special component st partial isomorphism case extend adding new component isomorphic graph new number 
extends coding location component isomorphic 
find ae acted de ae conditions satisfied 
go 

exist ae 

recovery stage ae 
action de 
suppose condition holds 
component containing coding location ae 
isomorphic image extend performing operations new components isomorphic respectively new numbers 
put ae image new number greater numbers stage put ae note successfully met requirement de 
structures extended new isomorphic structures respectively 
go 
suppose second condition holds 
consider special components st gt respectively 
subcases 
subcase 
sequence components isomorphic images conditions hold 
coding location ae 
components participated operation 

image nonempty intersection component corresponding sequence 

participated operation respectively number times possibly construction changed isomorphism just changed components participated operations 

participated operation odd number times construction changed isomorphism designated isomorphism component played role time special component participated operation participated operations 
component isomorphic time operation applied 

participated operation odd number times construction changed isomorphism designated isomorphism component played role time special component participated operation participated operations 
component isomorphic time operation applied 
case extend applying operation sequence extend applying operation sequence 
note image coding location ae new number 
put pair ae number ae number note successfully met requirement de extended structures ak ak 
go 
subcase 
suppose previous subcase hold 
case add new components isomorphic new numbers 
go 
recovery stage go stage 
put mark component participated operation new components isomorphic bi ci added component image number component marked go stage 
concludes description construction 
state claims construction sketch proofs 
may helpful construction proofs refer diagrams results applying operations special sets immediate neighbors sequences supplied proof lemma 
claim 
construction meets requirements de 
stage enumeration enters waiting state recovers isomorphic 
proof claim 
suppose stage enters waiting state recovers 
clearly ae stage stages construction satisfies condition action stage course ae de met automatically 
note case components ak finite construction 
follows definition recovery description stages isomorphic 
course satisfying de implies de satisfied 
suppose recovers infinitely stages 
smallest number de met 
action requirements de finished stage 
clearly act de 
exists stage ae condition subcase holds 
follows stage construction meet requirement de 
contradiction 
claim gives fundamental properties recovery 
claim 
consider sequence st gt sequences corresponding maps suppose stage operation applied operation applied 
stage recovers 
gt satisfies mutually exclusive properties 
components st covered respectively corresponding isomorphic components 
designated isomorphism stage covering corresponds fact stage construction change isomorphism designated isomorphism stage covering corresponds fact stage construction changed isomorphism 
components st covered respectively corresponding isomorphic components 
designated isomorphism stage covering corresponds fact stage construction changed isomorphism designated isomorphism stage covering corresponds fact stage construction change isomorphism proof claim 
note changes component ak elements range happen recovery stages construction 
claim follows directly fact participated operations form distinct numbers definitions recovery operation operation 
yi grow components ak determined requirements uniqueness definition recovery 
claim 
ak form stage ak form 
proof claim 
second version claim stage follows immediately induction construction 
way components infinite infinitely recovery stages construction change isomorphism stage 
case isomorphism remains infinite component ak 
disjointness condition final components follows stage 
claim 
suppose recovers infinitely stages 
stage construction changes isomorphism hold 
special component extends 
infinite component 


sequence stages stage ti partial isomorphism rk ti properly extends function rk ti extends extends components isomorphic 

component ak distinct kt finite 

isomorphic computably isomorphic ak 
proof claim 
part claim follows definition stage assumption 
second part follows claim properties operations description construction stage 
third part noted claim component distinct exists stage stage component finite 
prove part claim consider function construction component ak eventually marked exists stage rk component construction changes isomorphism 
component ak contained isomorphic ak restrict isomorphism component domain assumed isomorphic ak isomorphic component ak isomorphic isomorphic components isomorphic ak claim 
claim 
construction changes isomorphism infinitely stages special component infinite components finite 
isomorphic 
proof claim 
component distinct finite 
prove components contain finite 

sequence stages construction changes isomorphism 
suppose stage construction changes isomorphism consider 

construction 
stage construction changes partial isomorphism 
extends stage component 
component containing finite 
continuing procedure see contains infinite component 
claim 
isomorphic 
proof claim 
immediate construction isomorphic finitely recovery stages component ak finite claim follows 
exactly infinite component isomorphic item claim 
course finite components isomorphic existence isomorphisms stage 
claim 
relation computable 
proof claim 
time pair put new number 
construction enumerates increasing order 
claims prove correctness construction respect de 
general construction 
describe construction priority tree satisfies requirements 
nodes length fixed set possible outcomes left right ordering 
induced lexicographical ordering tree coincides usual priority ordering length define strategy meet requirement dj 
stage construction guarantees coding location attached accessible node length 
goals construction satisfy dj coding locations 
strategy meet requirement dj employs operations 
strategies nodes possible outcomes stage outcome construction acts acted previous stage initialized satisfy requirement dj 
left right ordering outcomes length define strategy meet requirement rj 
structure building form limit computable graphs gj form 
loss generality require enumerations gj stage distinct components gj component gj 
enumerate components gj right form top cycles attached cycles added contained components partially enumerated allow extensions possible components distinct 
done add single desired element required form 
strategy meet requirement rj stagewise definition potential partial isomorphisms try define isomorphisms structure gj ak 
strategies possible outcomes stage outcome waiting state outcome recovers stage construction change isomorphism outcome recovers stage construction changes isomorphism rk 
notions analogous ones construction defined precisely general construction 
outcomes ordered follows nodes length devoted guessing components gj isomorphic infinite special components constructed nodes length 
information needed nodes length successfully define required isomorphism rk 
possible outcomes node length order 


intention corresponds different guess required components gj correspondence desired components ak outcome eligible guess guess eventually proven false 
define accessible nodes priority tree stage induction length 
empty sequence length root priority tree accessible stage accessible stage outcome accessible deal instructed go stage 
go stage 
cancel component means guarantee operation 
construction component ak isomorphic image ak cancelled stage stages construction 
component containing ak equal 
finite 
initialize node length stage means cancel components associated 
initialize node length stage means cancel previous isomorphism rk special components ak choice gj components associated participated operation 
special component cancelled changed component stage construction keeps extension convention changing explicit mention parameters 
describe general construction 
remarks enclosed double brackets explanatory part formal construction 
stage 
initialize requirements 
take distinct numbers sets form uniformly computable collection disjoint sets infinitely numbers 
say numbers associated 
stage 
proceed act accessible node turn stage terminated 
stage initialized stage accessible stage 
node declared accessible initialize nodes right 
case 
outcome outcome outcome code sequence components gj eligible isomorphic corresponding special components ak 
length guessing needed outcome code empty correspondence 
say component gj stage yt eligible isomorphic stage yt stage defined necessarily yt xt yt xt zt isomorphic component participated operation time participated 
option included set may grow desired special component outcome 
outcome see irrefutable evidence element sequence components gj coded isomorphic corresponding special components ak 
outcome say irrefutable evidence stage component gj stage yt isomorphic yt associated 
case 
think gj isomorphic need rj 
case outcome suppose 
say recovers stage equivalently stage recovery stage conditions hold 
ignoring components gj picked outcome associated special components definition covering exists component ak marked unique component covers 
recovery stage require component zt sequence coded supposed correspond zt recovery stage say waiting state 
case outcome special component add components isomorphic say associated 
note perform components maintain association node way maintain original elements component originally associated contains various numbers added graph component containing numbers associated stage 
declare components isomorphic special components 
empty designate construction isomorphism 
case outcome recovery stage special component define partial isomorphisms rk components gj components ak marked making rk correspondence coded matches correspondence mention rk covered ignore components mentioned code corresponding components 
defined set component gj mapped define outcome follows subcase 
suppose rk extends previous designated isomorphism rk rk component extends 
case outcome subcase 
suppose rk extend previous designated isomorphism rk case construction changes designated isomorphism rk rk outcome 
note case component extends case 
outcome 
coding location attached add components isomorphic associate attach coding location copy 
coding location attached node 
component containing coding location isomorphic image 
components associated stage attached 

kn sequence numbers denote ki 
numbers corresponding conditions description vacuous 
case outcome stage accessible add new components isomorphic associated case outcome subcases 
subcase 
exists sequence 
components corresponding isomorphic image 
sequence associated properties 

image nonempty intersection component sequence bk xk ck bk ck 
bk ck bk designated isomorphism ck designated isomorphism 
participated operation respectively number times possibly construction changed isomorphism just changed components bk ck participated operations isomorphic respectively 
participated operation odd number times construction changed isomorphism designated isomorphism component played role time special component necessarily participated operation participated operations isomorphic 
component isomorphic applied time operation 
participated operation odd number times construction changed isomorphism designated isomorphism component played role time special component necessarily participated operation participated operations isomorphic 
component isomorphic applied time operation action dj subcase extend applying operation transform sequence 
extend applying operation transform sequence 

define transform sequence 
ck sequence ck bk 
bk im im ck im bk ck bk ck 
jr jr ck jr 
im list order designated isomorphism 
jr list order designated isomorphism note image coding location new number 
put pair number number subcase outcome go stage 
subcase 
outcome stage cancelation addition initializations nodes right accessible ones marking 
suppose recovery stage accessible 
components isomorphic necessarily participated operation cancel appoint new ones respectively 
eventually get marked necessary accessible components available needed act describe marking procedure recovery stage 
marked mark 
cancelled component 

component associated node left 

component form 

components form 

components form 

components form designated isomorphism form designated isomorphism 
performed operation transform sequence 
mark previously participated operation mark designated isomorphism mark ck designated isomorphism mark bk 
marking components marked operation position left concludes description construction 
constructed structures lemmas state basic obvious facts construction 
lemma properties hold construction 
component cancelled stage construction uses component operation stage finite isomorphic components 

component infinite set stage set participated operation infinite 
lemma suppose stage operation operation applied transform sequence 
consider node exists stage node left accessible components ck 
participate operation components ak containing finite 
ck 
order prove correctness construction need consider true path tree leftmost path nodes accessible infinitely 
true path infinitely stages accessible exists stage left accessible 
clear unique true path lemma relation computably enumerable computable 
relation computable 
particular structures computably isomorphic 
proof 
note stage put element new greater elements appearing stage construction effectively lists elements strictly increasing order 
computable 
suppose computable characteristic function consider requirement dj node 
true path corresponding dj 
stage accessible left accessible stage coding location attached node stage components associated attached 
requirement clearly satisfied suppose stage accessible 
add new components isomorphic stage construction operation act satisfy dj 
cancelation appointment procedures stage recovery unused components form marked available needed definition acting stage 
stage subcase case construction hold satisfied dj acting 
new components needed operations construction 
follows construction meet requirement dj stage characteristic function lemma 
suppose stage operation applied transform sequence 

sequence accessible 
consider node suppose designated partial isomorphism recovery stage particular accessible stage stage nodes left accessible hold construction changes isomorphism stage special component em component corresponding empty intersection component 
construction change isomorphism stage special component embedded component corresponding extends component component 
suppose stage operation applied transform sequence 

sequence accessible 
consider node suppose designated partial isomorphism recovery stage particular accessible nodes left accessible stage stage hold stage special component em construction changes isomorphism component corresponding empty intersection component 
construction change isomorphism stage special component embedded component corresponding extends component component proof 
lemma follows directly definitions recovery operation operation construction 
crucial point say designated isomorphism components left transform operation applied associated nodes lower priority marked 
apply operation marked components change place isomorphism change place 
situation analogous claim construction rj 
easier see points schematically display results applying operations various circumstances 
sake simplicity omit subscripts node stages duplications product notation results applying operations 
omit superscripts designating component just display results 
result sequence operations designated isomorphism remains note bi new components time 
results applying operations designated isomorphism remains conventions 
note ci new components time 
results construction starts changes isomorphism stage bi ci new 
prove lemma note component form am 
denote component am 
lemma component component isomorphic 
similarly component component isomorphic 
proof 
suppose finite 
exists stage component participate operation stage image say am participate operation 
component isomorphic am 
components participate operations ones operations 
suppose component infinite 
set stage set participates operation infinite 

tn 
list elements set 
consider stage tj stage tj participates operation 
tj 
tj components participating operation including tj components participate operation tj belongs set tj associated accessible remains associated 
stage stages tj tj node left accessible lemma cancelled finite 
construction changes isomorphism infinitely component associated participate operation infinitely ones playing roles bk ck new time isomorphism changes change time lemma changed 
see 
construction changes isomorphism tj 
cases consider case 
suppose designated isomorphism tk case component participates infinitely special component tk increasing 
see 
components tj isomorphic tj form increasing sequence 
limits tj tj am isomorphic required 
case 
suppose designated isomorphism tk case component participates infinitely alternates tj playing role operations stages tj 
see 
case increasing limits tj tj am isomorphic required 
proof going am similar 
lemma addition infinite special component numbers associated set proof 
stage stage distinctions follow immediately construction induction 
additional concern infinite components 
clearly differentiated having cycles length distinct different 
lemma structures isomorphic 
proof 
back forth argument constructs desired isomorphism previous lemmas wish prove requirements rj satisfied 
analyze outcomes appropriate nodes true path assumption gj isomorphic lemma gj isomorphic node length code sequence components gj isomorphic infinite special sets higher priority correct correspondence isomorphic components proof 
stage initialized 
clear eventually eligible outcome gj isomorphic represents correct isomorphism relevant components eligible fail eligible 
components numbers associated set irrefutable evidence correct outcome 
need show get irrefutable evidence code correct 
correspondence component gj eligible correct 
eligible contain number stage correctly defined 
component gj isomorphic isomorphic ones play role bi ci operation applied 
obvious definition sequence operations displayed component eventually gets addition includes number associated desired contradiction 
lemma gj isomorphic node length 
proof 
stage initialized 
suppose consider components 

sequence stages accessible construction changes isomorphism stage stage construction stage extension participate 
see 
construction components extending ti finite 
consider corresponding special gj component structure gj 
note special component infinite just argued components embedded finite 
components associated embedded construction 
contradicted assumption gj isomorphic 
suppose stage accessible node left accessible 
waiting state 
correct correspondence infinite special sets higher priority appropriate components gj enumeration gj eventually put components members ones waiting part desired recovery 
need consider finitely components ak marked coded 
new marks put waiting state 
component set finite eventually constant 
components associated node right canceled accessible choice finite 
introduced stage get mark assigned recovery stages 
components associated nodes extending left participate operation finite 
leaves components associated 
ones possibly infinite special components isomorphic images ak excluded consideration coded previous lemma 
gj isomorphic eventually stage gj isomorphic copy finite marked component way get recovery stage desired contradiction additional component gj embeddable explicitly prohibited situation occurring enumeration gj 
lemma gj isomorphic node length gj computably isomorphic ak 
proof 
consider effective sequence 
left accessible accessible stage ti 
outcome node stages follows sequence rk rk 
sequence partial isomorphisms rk ti rk 
ti argument case rj additional remarks components associated nodes right cancelled undergo changes 
associated nodes left participate operation change choice 
associated node extending participate operation accessible 
ones associated nodes special components participate operations marked domain rk longer participate operations change 
assignment procedure marks component finitely eventually gets mark 
possible exceptions special components ones initially form 
consider function rk rk ti component dom rk 
clear rk embedding component ak 
gj isomorphic ak components ak embedded lemma proper embedding component construction rk restrict isomorphism 
component ak eventually gets rk maps ak finitely components 
component gj domain rk isomorphic ak 
isomorphic components gj ak lemma finitely components left rk match 
rk extended unique possible matching finitely components omitted desired computable isomorphism 
lemma relation computable 
proof time pair put new number 
construction enumerates increasing order 
lemmas prove correctness construction 
proved theorem degree spectra problem section gives positive solution degree spectra problem question 
proof ideas proof theorem previous section 
give basic ideas proof 
intend give full proof result simply want repeat arguments construction similar ones theorem 
theorem computable partially ordered set exists structure dimension cardinality relation degree spectrum isomorphic guarantee computably enumerable computable presentation contains element element 
choose representatives ai degree spectrum relation di dj ai aj isomorphism ai aj extends map computable isomorphism takes di ai sketch proof 

effective list repetitions elements partially ordered set goal construct computable sequence 
computable structures digraphs isomorphic single rigid structure relation properties hold 
computable presentation computably isomorphic 

isomorphic images 
relation respectively di dj ai aj 
predicate pair di dj ai aj mapping extended isomorphism ai aj computable 

standard enumeration computably enumerable digraphs 
order build structure unary relations properties need satisfy requirements dn dm dn am rj gj isomorphic gj computably isomorphic 

effective enumeration computable partial functions oracle order satisfy requirement dn construction needs divide requirement infinitely sub requirements 
dm dn de am 
dm dn de am 
construction satisfy requirements rj de construction sequence 
unary predicates 
carried priority construction tree defined follows 
requirement rj level rj tree node level devoted satisfying rj exactly immediate successors requirement de dm dn level de tree node level devoted satisfy de exactly immediate successors assume de rn de rm 
notions ideas construction 
stage accessible node length rj special component node potential finite partial isomorphisms gj aj designated construction 
partial isomorphisms guess correct correspondence infinite special components higher priority appropriate components gj 
idea gj going isomorphic graph construction building construction attempts force graph gj computably isomorphic aj follows 
suppose true path 
outcomes 
outcome corresponds fact construction changes mind potential isomorphism infinitely 
special component infinite components embedded finite gj isomorphic outcome node gj waiting state isomorphic outcome gj computably isomorphic ai 
stage node length de construction picks coding location attempts meet requirement de form am location 
idea 
action meet requirement type de performing operations structures construction building 
suppose true path 
stage left accessible assume coding location attached node stage 
exists stage construction puts am stage 
construction puts images ai images coding location new numbers dm di number put am dm di 
accomplished performing operation ai dm di operation ai dm di 
clearly am ai dm di 
basically predicate computable pair put elements pair larger note requirement de met lower priority requirements initialized put number computation higher priority requirement act put numbers choice characteristic function am course ai construction 
di element diagonalization requirements form de new numbers put ai computable desired 
argument requirements rj satisfied node true path associated rj construction previous section possible outcomes 

corresponding claim map computable isomorphism gj ai true path stage accessible node left accessible 
true path gj isomorphic 
applications section provide applications techniques developed previous sections 
application answers question posed goncharov 
second application answers question giving new solution ash goncharov problem 
third application answers question connections scott families categoricity 
answering question theorem exists structure exactly computably enumerable presentations properties hold 
computably enumerable computable structure 

computable structure 

computably enumerable presentation computably isomorphic 
proof 
consider structure constructed proof theorem 
unary relation computably enumerable computable computable 
expand structure adding language predicate symbols set interpretation unary predicate constructed theorem 
set interpretation binary predicate define expanded structure 
obviously structure defined computably enumerable computable presentation structure defined computable presentation structures isomorphic computably enumerable presentations presentations computably isomorphic 
computably enumerable presentation relation computably enumerable relation equality relation computably enumerable 
equality relation structure computable 
omit predicate symbols language structure predicates omitted computably isomorphic 
computably isomorphic 
result provides new solution ash goncharov problem originally solved theorem natural number exists computably categorical structure expansion finitely constants exactly computable isomorphism types 
proof 
theorem computable structure unary relation properties hold 
structure exactly computable presentations ak domains pairwise disjoint 

distinct 
ai aj turing incomparable 

binary predicate distinct ai aj mapping extended isomorphism ai aj computable 
see simply set pairwise incomparable elements 
di dj di dj 
define desired structure graph 
ak expanded predicate equivalence relation equivalence classes ak 
clearly computable structure 
computable presentation equivalence classes substructures considered graphs isomorphic computably isomorphic ak 
lost generality suppose computably isomorphic computable function 
computably isomorphic computable function able decide follows belongs pairwise isomorphic 
computably isomorphic computably categorical 
designated element 
consider expanded structure new constant ai aj image ai aj respectively 
follows structures 
ai ai 
ak 
aj aj 
ak expanded predicate equivalence relation isomorphic computably isomorphic 
exactly computable isomorphism types 
immediate consequence corollary exists computably categorical structure scott family 
goal strengthen corollary answer question 
theorem exists structure scott family expansion structure finite number constants computably categorical 
proof 
structure required establish theorem constructed coding certain uniformly computably enumerable families sets natural numbers 
definition family sets natural numbers computable enumeration bijection computably enumerable 
call computable enumeration wish consider standard computable enumerations naturally induces equivalence relation corresponding computable isomorphism definition computable enumeration reducible computable 
say equivalent 
note enumeration permutation equivalence classes oneto enumerations minimal elements induced partial ordering 
enumerations need consider define family supplies structure required theorem 
informally computable categoricity corresponds single equivalence class dimension structure corresponds number classes 
definition computable structures computable isomorphism type computable isomorphism dimension computable structure number computable isomorphism types 
definition computable sequence 
canonical indices finite sets scott sequence family properties hold 
di exists exactly denoted mi di 
set 
finite 
definition lemma follows easily lemma scott sequence computable enumerations equivalent 
family want construct structure scott family scott sequence 
family sets computable enumeration assume set elements contain 
consider structure af 
assume af computable structure constructed uniformly note set top elements af computable computable presentation af elements outdegree ones part cycle 
lemma describes relationship af 
lemma structure af satisfies conditions 

computable enumeration af isomorphic ag 

structure af rigid nontrivial automorphisms 

computable enumeration af computably isomorphic ag equivalent 

dimension structure af equal maximal number computable enumerations 
structure af scott family scott sequence 
proof 
prove note pair graphs af ag isomorphic 
enumerations conclude af isomorphic ag 
automorphism af identity construction af fact mapping 
proves 
suppose equivalent 
exists computable function 
af ag computably isomorphic 
computable presentation af 
consider effective sequence 
repetition top elements define toone computable enumeration fb follows fb ei connected cycle length 
follows computably isomorphic ag equivalent fb part follows proof 
left prove part lemma 
suppose scott sequence 
lost generality suppose di 
case 
derived easily considerations simply fact 
finite 
prove af scott family 
take af 
find top element di connected suppose length path connects di define formula exists path length connects top element di element connected cycle length 
tuple 
xs xs 
xs 
hard check sequence xs scott family af 
suppose simplicity af scott family 
xn 
xn 
parameters 
proof show lose generality making assumption 

effective sequence top elements af 

effective subsequence original sequence ik dk holds 
formulas existential structure computable effectively find finite substructure bi af di bi ik dk holds bi 
define di di connected length substructure bi 
scott family af structure af rigid see sequence 
scott sequence family corollary computable enumerations equivalent af computably categorical 
prove theorem suffices lemma build computably enumerable family sets scott sequence computable enumerations equivalent 
lemma computably enumerable family sets scott sequence computable enumerations equivalent 
proof 
order build family enumeration need satisfy requirements de fe scott sequence rj gj gj enumeration gj computable sequence potential enumerations family sets fe computable sequence potential scott sequences see requirements similar requirements constructing computable structure theorem 
briefly explain meet rj de 
verifications modifications needed prove full theorem similar theorem left reader 
set gi 
gt appears fewer steps fixed computation procedure 
construction proceeds stages 
stage notions terminology similar proof theorem 
enumeration ft approximation enumeration construction building 
ft 

family st function ft enumerates family denoted st 
fe assign set ce number pe called witnesses ce pe computable set set ce pe 
goals construction meet de numbers 

potential reduction function rt 
map rt function potentially reduces gt ft stage function rt extend previous potential reduction rt 
rt extend previous potential reduction say construction changes potential reduction 

dom ft 
construction guarantee ft ft dom ft 
stage ft possesses element belong ft purpose property ensure oneto enumeration 
guarantee 
special set 
construction needs pick set sg enumeration called special set 
exist infinitely stages construction changes reduction set sg infinite sets contained sg finite enumeration hand stage construction changes reduction enumeration family equivalent 
special numbers construction uses numbers rt sg ft set ft stage corresponds sg 
recovers stage defined numbers satisfy properties 

construction change previous reduction stage 
construction changes reduction stage 
stage construction changes reduction recovers infinitely enumeration family construction guarantees set limn infinite 

marking recovery 
ft index exists gt ft pair gt contained ft say gt covered ft equivalently ft covers gt 
construction ft indices marked special symbol called mark 
say enumeration recovers stage equivalently stage recovery stage ft index marked exists unique ft covers gt 
notion recovery show enumeration family equivalent idea 
suppose enumeration construction ft marked waits cover set soon recovers stage unique gt index ft covers gt construction defines rt attempts guarantee 
enumeration recover stage say waiting state 
waiting state construction enumeration need definition operation corresponds operation proof theorem 
operation needed meet requirements de 
definition xk 
sequence sets 
operation applied sequence gives definition sequence xk xk 
xk 
say sets xk 
participated operation 
describe construction satisfying de stage 
dom new number new number 
set 
put mark reduction empty function 
put waiting state 
recovery stage define sg stage recovery stage go 
recovery stage proceed follows action 
define reductions indices marked follows put gt covered ft 
cases 
case 
suppose extends previous reduction case set case 
suppose extend previous reduction 
case construction changes reduction 
note compute fe 
ft new numbers 
find fe qe ft ce acted de cases satisfied go stage 

exist rt ce 

recovery stage rt ce 
action de 
suppose case holds 
ft ce pe ft pe new numbers 
note successfully met potential reduction de 
family st changed new family st way ft naturally extended enumeration ft family st 
suppose second case holds 
case subcases 
subcase 
exist distinct numbers rt ai xi numbers ai previously participated operation 
case consider sequence ce 
corresponding finite sequence ft ft ce ft ft ft 
perform operations sequence 
put changed sets new elements 
family st changed new family st way ft naturally extended enumeration ft family st 
put mark ft index participated operation number marked go stage 
subcase 
suppose previous subcase hold 
case take distinct new elements 
set ft aj uj uj new distinct numbers 
add sets st family st changed new family st way ft naturally extended enumeration ft family st 
recovery stage put mark new ft index number marked case go stage 
concludes description construction 
define ft 
define family 
leave reader verification correctness construction details general construction 
ash nerode intrinsically recursive relations 
ash categoricity degrees ann 
pure appl 
logic 
ash knight pairs recursive structures ann 
pure appl 
logic 
ash knight manasse generic copies countable structures ann 
pure appl 
logic 
ash knight permitting forcing copies recursive relation appear 
remmel polynomial time versus recursive models ann 
pure appl 
logic 
goncharov khoussainov shore computably categorical structures expansions constants journal symbolic logic appear 
crossley ed aspects effective algebra proceedings conference monash university upside book glen australia 
yu 
ershov goncharov eds logic notebook university 
yu 
ershov goncharov nerode remmel eds handbook computable algebra appear 
fr shepherdson effective procedures field theory philos 
trans 
roy 
soc london ser 

goncharov computable families algebra logic 
goncharov models abelian groups algebra logic 
goncharov problem number non self equivalent algebra logic 
goncharov effectively infinite classes weak models algebra logic 
goncharov limiting equivalent russian tr 
inst 
mat 
sib 
akad 
nauk sssr 
goncharov models algebra logic 
goncharov khoussainov spectrum degrees decidable relations doklady mathematics 
effects ash nerode decidability conditions degree spectra ann 
pure appl 
logic 
possible turing degree nonzero member element degree spectrum ann 
pure appl 
logic 
pure recursive model theory recursive mathematics yu 
ershov goncharov nerode remmel eds appear 
recursive properties relations recursive models ph thesis monash university 
degree spectrum problem preparation 
knight metatheorem construction finitely workers journal symbolic logic 
knight constructions workers ann 
pure appl 
logic 
knight degrees coded jumps orderings journal symbolic logic 
khoussainov spectrum algorithmic dimensions homomorphisms models algebra logic 

khoussainov recursive unary algebras trees ann 
pure appl 
logic 
khoussainov nerode automatic presentations structure logic computational complexity proceedings international conference lcc leivant ed lncs springer verlag berlin 
decidable model computable scott family formulas algebra logic 
mal recursive abelian groups dokl 
akad 
nauk sssr russian 
mal constructive algebras matem 
nauk 
tr 
russian math 
surveys 
nerode recursion theory algebra algebra logic ed 
crossley lecture notes mathematics springer verlag berlin 
millar theory recursively presentable models ph dissertation cornell university 
millar recursive categoricity persistence journal symbolic logic 
strong weak computable families algebra logic 
rabin computable algebra general theory theory computable fields trans 
am 
math 
soc 
remmel recursive isomorphisms types recursive boolean algebras journal symbolic logic 
remmel recursive boolean algebras handbook boolean algebras monk ed north holland amsterdam remmel crossley anil nerode retrospective logical methods crossley remmel shore eds birkh user boston 
rogers jr theory recursive function effective computability new york 
sacks saturated model theory benjamin reading mass 
sacks higher recursion theory springer verlag berlin 
families general recursive functions algebra logic 

