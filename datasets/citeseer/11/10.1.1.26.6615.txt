focussed algorithm real time replanning finding lowest cost path graph central problems including route planning mobile robot 
arc costs change traverse remainder path may need 
case sensor equipped mobile robot imperfect information environment 
robot acquires additional information sensors revise plan reduce total cost traverse 
prior information grossly incomplete robot may discover useful information piece sensor data 
replanning robot wait new path computed move wrong direction rapid replanning essential 
algorithm dynamic plans optimal traverses real time incrementally repairing paths robot state new information discovered 
describes extension focusses repairs significantly reduce total time required initial path calculation subsequent replanning operations 
extension completes development algorithm full generalization dynamic environments arc costs change traverse solution path 
problem path planning stated finding sequence state transitions graph initial state goal state determining sequence exists 
path optimal sum transition costs called arc costs minimal possible sequences graph 
traverse path arc costs graph discovered 
research sponsored arpa contracts perception outdoor navigation contract number monitored army tec unmanned ground vehicle system contract number monitored 
anthony stentz robotics institute carnegie mellon university pittsburgh pennsylvania incorrect remaining portion path may need preserve optimality 
traverse optimal transition traverse part optimal path goal assuming time transition known information arc costs correct 
important application problem serve central example task path planning mobile robot equipped sensor operating changing unknown partially known environment 
states graph robot locations arc values costs moving locations metric distance time energy expended risk robot begins initial estimate arc costs comprising map environment partially known changing arc costs incorrect 
robot acquires sensor data update map replan optimal path current state goal 
important replanning fast time robot continue move suboptimal path 
number algorithms exist producing optimal traverses changing arc costs 
algorithm plans initial path nilsson distance transform jarvis prior map information moves robot path reaches goal sensor discovers discrepancy map environment updates map new path robot current state goal zelinsky 
brute force optimal grossly inefficient particularly expansive environments goal far away little map information exists 
boult maintains optimal cost map goal states environment assuming environment bounded finite 
discrepancies discovered map environment affected portion cost map updated 
map representation limited polygonal obstacles free space 
ramalingam reps extend approach handle graphs arc costs ranging continuum 
limitation algorithms entire affected portion map repaired robot resume moving subsequently additional corrections 
algorithms inefficient robot near goal affected portions map long shadows 
stentz overcomes proceedings international joint conference artificial intelligence august 
limitations incremental algorithm maintains partial optimal cost map limited locations robot 
likewise repair cost map generally partial re entrant reducing computational costs enabling real time performance 
algorithms exist addressing problem path planning unknown dynamic environments korf stepanov snyder algorithms emphasize fast operation low memory usage expense optimality 
describes extension focusses cost updates minimize state expansions reduce computational costs 
algorithm uses heuristic function similar propagate cost increases focus cost reductions 
biasing function compensate robot motion replanning operations 
net effect reduction run time factor 
begins intuition algorithm describes extension presents example evaluates empirical comparisons draws 
intuition algorithm consider solves robot path planning problem 
shows connected graph representing cartesian space robot locations 
states graph depicted arrows robot locations arcs encode cost moving states 
white regions locations known free space 
arc cost moving free states small value denoted empty grey regions known obstacle locations arcs connected states assigned prohibitively high value obstacle small black square closed gate believed open empty value 
loss generality robot assumed point size occupies location time 
compute optimal path costs goal states space initial set arc costs shown 
arrows indicate optimal state transitions optimal path state recovered arrows goal 
closed gate assumed open plans path 
robot starts initial location begins optimal path goal 
location robot sensor discovers gate large obstacles closed 
corresponds incorrect arc value graph empty higher value gate representing cost opening gate moving 
paths arc possibly longer optimal indicated labelled region 
recompute cost map inefficient environment large goal far away 
characteristics problem motivate better approach 
changes arc costs vicinity robot typically carries sensor limited range 
means plans need patched locally 
second robot generally near monotonic progress goal 
obstructions small simple path suffice avoiding high computational cost backtracking 
third remaining portion path location traverse tends get progressively shorter due second characteristic 
invalidated area optimal known known area obstacle obstacle unknown closed gate invalidated states graph described stentz leverages characteristics reduce run time factor large environments 
proves algorithm produces correct results regardless performance improvement affected validity problem characteristics 
maintains open list states expansion states consist types raise lower 
raise states transmit path cost increases due increased arc value lower states reduce costs re direct arrows compute new optimal paths 
raise states propagate arc cost increase invalidated states starting gate sweeping outward adding value gate states region 
raise states activate neighboring lower states sweep reduce costs re direct pointers 
lower states compute new optimal paths states previously raised 
states placed open list key value kx lower states current path cost cost state goal raise states previous hx value 
states list processed order increasing key value 
intuition previous optimal path costs raise states define lower bound path costs lower states discover 
path costs lower states currently open list exceed previous path costs raise states worthwhile processing raise states discover possibly better lower state 
process terminate lowest value open list equals exceeds robot path cost additional expansions possibly find better path goal see 
new optimal path computed old determined valid robot continue move goal 
note part cost map repaired 
efficiency algorithm 
algorithm described stentz propagates cost changes invalidated states considering expansions benefit robot current location 
heuristics focus search direction robot reduce total number state expansions 
focussing heuristic gx estimated path cost robot location define new function estimated robot path cost xr hx gx sort lower states open list increasing value 
function xr estimated path cost state provided satisfies monotone restriction hx optimal lower state removed open list optimal path computed nilsson 
notation refer function independent domain 
lower states raise states lower states reach robot case raise states previous value defines lower bound values lower states discover focussing heuristic types states previous values raise states define lower bounds values lower states discover 
values lower states open list exceed previous values raise states worthwhile processing raise states discover better lower states 
reasoning raise states sorted open list xr kx gx kx hx lower states raise state definition suffices kinds states 
avoid cycles backpointers noted ties sorted increasing open list stentz 
process terminate lowest value open list equals exceeds robot path cost subsequent expansions possibly find lower state low path cost close robot able reduce robot path cost reaches subsequent expansions 
note efficient cut previous considers criterion 
shows example focussed search 
states raise state wave front roughly value 
wave front narrow focussed case inclusion cost return robot penalizes wide 
furthermore lower states activated raise state wave front swept outer sides obstacles compute new optimal path robot 
note wave fronts narrow focussed robot location 
compare 
note raise lower state wave fronts covered ground focussed search search order compute new optimal path efficiency focussed algorithm 
problem focussing search new optimal path computed robot location robot moves new location 
sensor discovers arc cost discrepancy search focussed robot new location 
states open list focussed old location incorrect values 
solution recompute states open list time robot moves new states added 
empirical evidence cost re sorting open list offsets savings gained focussed search 
lower states raise states focussed lower states reach robot approach take advantage fact robot generally moves states replanning operations values small amount error 
assume state placed open list robot location value point xr robot moves location calculate xr adjust position open list 
avoid computational cost compute lower bound xr fl xr fx gr fl xr lower bound xr assumes robot moved direction state subtracting motion gx parameter arbitrarily small positive number 
repositioned open list fl xr fl xr lower bound xr selected expansion needed 
time expansion true xr value computed placed back open list xr approach appears worse open list re sorted fl partially adjusted replace fl values correct values 
gr subtracted states open list ordering preserved list need re sorted 
furthermore step avoided altogether adding gr states inserted open list subtracting list preserving relative ordering states list states added 
remaining computation adjustment step 
step needed states show promise reaching robot location 
typical problems amounts fewer states open list 
definitions formulation formalize intuition notation definitions stentz extend focussed algorithm 
problem space formulated set states denoting robot locations connected directional arcs associated cost 
robot starts particular state moves arcs incurring cost traversal states reaches goal state denoted visited state backpointer state denoted uses backpointers represent paths goal 
cost traversing arc state state positive number arc cost function cx arc undefined 
states neighbors space cx cy defined 
uses open list propagate information changes arc cost function calculate path costs states space 
state associated tag tx new open list tx open currently open list tx closed longer open list 
visited state maintains estimate sum arc costs path cost function hx proper conditions estimate equivalent optimal minimal cost state state open list open key function kx defined equal minimum hx modification values assumed hx placed open list 
key function classifies state open list types raise state kx hx lower state hx uses raise states open list propagate information path cost increases lower states propagate information path cost reductions 
propagation takes place repeated removal states open list 
time state removed list expanded pass cost changes neighbors 
neighbors turn placed open list continue process 
states sorted open list biased value fb xr state open list ri robot state time inserted adjusted open list 
rn sequence states occupied robot states added open list 
value fb fb xr fx ri dr estimated robot path cost xr hx gx ri accrued bias function dr gr gr gr ri dr function gx focussing heuristic representing estimated path cost open list states sorted increasing fb value ties fb ordered increasing ties ordered increasing ties ordered arbitrarily 
vector values fb stored state list 
state removed open list value examined see computed focal point 
fb values recalculated new focal point accrued bias respectively state placed back list 
processing fb values ascending order ensures encountered value current focal point minimum value denoted fmin 
corresponding value 
parameters comprise important threshold 
processing properly focussed values ascending order values ascending order constant value algorithm ensures states fmin fmin hx hx optimal 
parameter val store vector fmin purpose test 
current state search focussed initialized robot start state 
define robot state function rx returns robot state inserted adjusted open list 
parameter accrued bias robot start state current state shorthand dr curr initialized dr 
shorthand notation fb fb fb fx rx algorithm description algorithm consists primarily functions process state modify cost move robot process state computes optimal path costs goal modify cost changes arc cost function enters affected states open list move robot uses functions move robot optimally 
algorithms process state modify cost move robot detailed functions managing open list insert min state min val user provides function computes returns focussing heuristic gx embedded routines min returns minimum scalar values takes vector values vector returns true takes vectors returns true cost computes xr curr hx returns vector values fx hx state delete deletes state open list sets closed put state sets tx open inserts open list vector fb fx kx get state returns state open list minimum vector value null list empty 
insert function changes value hx hnew inserts open list 
value kx determined lines 
remaining values vector computed line state inserted line 
function insert hnew tx new kx hnew tx open kx hnew delete kx hnew hx hnew rx kx fb fx put state function min state returns state open list minimum value 
order function retrieves state open list lowest fb value 
state placed open list robot previous location line re inserted open list lines 
operation effect correcting state accrued bias robot current state leaving state values unchanged 
min state continues retrieve states open list finds placed open list robot current state 
function min state get state null rx hnew hx hx kx delete insert hnew return return null min val function returns values state open list minimum value fmin function min val min state null return val return fx kx function process state cost changes propagated new paths computed 
lines state lowest value removed open list 
lower state hx path cost optimal 
lines neighbor examined see path cost lowered 
additionally neighbor states new receive initial path cost value cost changes propagated neighbor backpointer regardless new cost greater old 
states descendants change path cost affects path costs 
backpointer redirected needed 
neighbors receive new path cost placed open list propagate cost changes neighbors 
function process state min state null return val val kx kx delete hx neighbor ty new cost val hx hy cy bx hx hy cy hx neighbor ty new hy hx cx hy hx cx insert cx neighbor ty new hy hx cx insert cx hy hx cx tx closed insert hx hy cy ty closed val cost insert return min val raise state path cost may optimal 
propagates cost changes neighbors optimal neighbors examined lines see hx reduced 
lines cost changes propagated new states immediate descendants way lower states 
able lower path cost state immediate descendant lines placed back open list expansion 
action required avoid creating closed loop backpointers stentz 
path cost able reduced suboptimal neighbor lines neighbor placed back open list 
update postponed neighbor optimal path cost 
function modify cost arc cost function updated changed value 
path cost state change placed open list 
expanded process state computes new hy hx cx places open list 
additional state expansions propagate cost descendants function modify cost cval cx cval tx closed insert return min val function move robot illustrates process state modify cost move robot state environment optimal traverse 
lines move robot set new states accrued bias focal point initialized hg set zero placed open list 
process state called repeatedly lines initial path computed robot state ts closed determined path exists val val ts new 
robot proceeds follow backpointers reaches goal discovers discrepancy line sensor measurement arc cost stored arc cost due detected obstacle 
note discrepancies may occur just path goal 
robot moved time discrepancies discovered state saved new focal point accrued bias updated lines 
modify cost called correct place affected states open list line 
process state called repeatedly line propagate costs compute new path goal 
robot continues follow backpointers goal 
function returns goal reached goal path unreachable 
function move robot state graph tx new insert val ts closed val val val process state ts new return path sx cx xy xy sx cx val modify cost val cost val val val process state return goal reached noted line move robot detects condition path exists robot state goal example graph disconnected 
detect condition paths goal obstructed obstacles 
order provide capability obstructed arcs assigned large positive value obstacle unobstructed arcs assigned small positive value empty 
obstacle chosen exceeds longest possible path empty arcs graph 
unobstructed path exists goal obstacle exiting loop line 
likewise unobstructed path exists goal state traverse obstacle exiting loop line 
robot state undergoing path rr hr optimality guaranteed state fmin hr fmin hr hr 
example shows cluttered state environment 
robot starts state moves state obstacles shown black unknown robot starts traverse map contains empty arcs 
robot point size equipped state radial field sensor 
shows robot traverse basic algorithm 
traverse shown black curve white arrows 
robot moves sensor detects unknown obstacles 
detected obstacles shown grey black arrows 
obstacles remain unknown traverse shown solid black black white arrows 
arrows show final cost field states examined traverse 
note states examined algorithm 
basic algorithm shows robot traverse focussed algorithm 
number new states examined fewer basic focussed algorithm focuses initial path calculation subsequent cost updates robot location 
note states examined algorithm fewer optimal paths goal 
note trajectories fully equivalent 
occurs lowest cost traverse unique algorithms break ties path costs arbitrarily 
focussed algorithm experimental results algorithms tested verify optimality compare run time results 
algorithm brute force bfr initially plans single path goal start state 
robot proceeds follow path sensor detects error map 
robot updates map plans new path goal current location focussed search repeats goal reached 
focussing heuristic gx chosen minimum possible number state transitions assuming lowest arc cost value 
second third algorithms basic bd focussed minimal initialization fd described stentz section respectively 
fourth algorithm focussed full initialization fd fd path costs propagated states planning space assumed finite initial path calculation terminating path reaches robot start state 
algorithms compared planning problems varying size 
environment square consisting start state center left wall goal state center right wall 
environment consisted mix map obstacles known robot traverse unknown obstacles measurable robot sensor 
sensor omnidirectional state radial field view 
shows environment model approximately states 
known obstacles shown grey unknown obstacles black 
results environments states shown table 
reported times cpu time sun microsystems sparc processor 
environment size algorithms compared randomly generated environments results averaged 
line time cpu time required compute initial path goal robot case fd goal states environment 
operation line performed advance robot motion initial map available 
line time total cpu time replanning operations needed move robot start goal 
typical environment comparison focussed full init focussed min init basic brute force line sec sec sec sec line sec sec sec sec line sec sec sec sec line sec sec sec min line sec sec sec sec line sec sec sec min table results empirical tests results algorithm highly dependent complexity environment including number size placement obstacles ratio known unknown obstacles 
test cases examined variations outperformed bfr line time reaching speedup factor approximately large environments 
generally performance gap increased size environment increased 
user wants minimize line time expense line time fd best algorithm 
algorithm path costs states computed initially cost propagations focussed 
note fd resulted lower line times higher line times bd 
fd algorithm resulted lower line times higher line times bd 
focussing search enables rapid start due fewer state expansions unexplored states examined anyway replanning process resulting longer execution time 
fd best algorithm user wants minimize total time line time considered line time 
focussed algorithm configured outperform basic total time line portion operation depending requirements task 
general strategy focussing search idea issue computational load distributed 
presents focussed algorithm real time path replanning 
algorithm computes initial path goal state start state efficiently modifies path traverse arc costs change 
algorithm produces optimal traverse meaning optimal path goal followed state traverse assuming known information step correct 
focussed version outperforms basic version offers user option distributing computational load line portions operation depending task requirements 
addition heuristic focussing function completes development generalization dynamic environments special case arc costs change traverse solution path 
acknowledgments author barry brumitt jay feedback algorithm 
boult boult 
updating distance maps objects move 
proceedings spie conference mobile robots 
jarvis jarvis 
collision free trajectory planning distance transforms 
mechanical engineering trans 
institution engineers september 
korf korf 
real time heuristic search results 
proceedings sixth national conference artificial intelligence july 
stepanov stepanov 
dynamic path planning mobile automaton limited information environment 
ieee transactions automatic control ac november 
nilsson nilsson 
principles artificial intelligence tioga publishing pp 

snyder snyder 
unified solution coverage search explored unexplored terrains indirect control 
proceedings ieee international conference robotics automation may 
ramalingam reps ramalingam reps incremental algorithm generalization short est path problem 
university wisconsin technical report may 
stentz stentz 
optimal efficient path planning unknown dynamic environments 
carnegie mellon robotics institute technical report cmu ri tr august 
stentz stentz 
optimal efficient path planning partially known environments 
proceedings ieee international conference robotics automation may 

differential adaptive search method illustrated robot path planning moving obstacles goals uncertain environment 
journal pattern recognition artificial intelligence 
zelinsky zelinsky 
mobile robot exploration algorithm 
ieee transactions robotics automation december 
