symbolic model checking real time systems thomas henzinger computer science department cornell university ithaca ny xavier nicollin joseph sifakis sergio yovine verimag rue montbonnot saint martin france 
describe finite state programs real numbered time language real valued clocks equivalently finite automata real valued clocks 
model checking answers question states real time program satisfy branching time specification extension ctl clock variables 
develop algorithm computes set states symbolically fixpoint functional state predicates constructing state space 
purpose introduce calculus computation trees real numbered time 
unfortunately standard program properties response nonzeno execution sequences time diverges characterized fixpoints show expressiveness timed calculus incomparable expressiveness timed ctl 
fortunately result impair symbolic verification implementable real time programs safety constraints machine closed respect diverging time fairness constraints restricted finite upper bounds clock values 
timed ctl properties programs shown computable finitely approximable fixpoints simple decidable theory 
model checking powerful technique automatic verification finite state systems 
modelchecking algorithms determine states satisfy modal formula graph theoretic analysis state space kripke structure qs ec ces 
main practical limitation model checking algorithms caused size state graph grows exponentially number parallel components system 
approach confine state explosion problem relies symbolic enumerative representation sets states computes set satisfies formula fixpoint functional state predicates 
preliminary version appeared proceedings seventh annual ieee symposium logic computer science lics pp 
extended version appeared information computation pp 

partially supported national science foundation ccr united states air force office scientific research contract 
partially supported esprit basic research action react 
theoretical possibility symbolic model checking computing fixpoints realized early ec sif method practical symbolic representation state sets binary decision diagrams bdds bry 
bdds verification purposes cbm model checking bcm 
implementations symbolic modelchecking techniques reported spectacular successes particular area hardware verification mcm 
history model checking considerably shorter case real time systems 
researchers focused discrete time integers untimed model checking methods readily extended emss ah eme 
new complexities arise insist compositional modeling asynchronous systems time discretized alu 
consider dense time reals 
standard dense time approach models real time system transition relation finite set real valued clocks proceed uniform rate constrain times transitions may occur ad lew afh ah 
graph theoretic model checking algorithm systems acd 
time component causes state space infinite algorithm depends clever construction finite quotient infinite state graph 
size region graph equivalence classes states grows exponentially number components system largest time constant number clocks specify timing constraints 
need alternative symbolic approach model checking avoids explicit construction region graph particularly pressing real time case 
main problem devising method lies definition proper state relation iteration allows compute program properties wish consider 
time domain dense state relation force time advance infinitesimal amount 
iteration force time advance bound 
upper bound clock constraints may restrict time system spend particular set states say loop 
system may loop finite number times time bound expires infinitely 
words upper bound constraint hides fairness condition 
requirements state relation precise technical sense discuss generally contradictory 
show result fortunately little relevance verification concrete real time programs including loops upper bounds 
define class divergence safe systems inevitability equivalent time bounded inevitability event divergence safe system time bound event need occur bound need occur 
class divergence safe systems contains systems fairness constraints induced constant upper bounds may argued implementable notion fairness 
case divergence safe systems show settle state relation force time advance 
relation allows compute possibility dual invariance directly 
inevitability reducible time bounded inevitability invariance time may progress upper bound event event occurring 
informally sketched course action computing bounded unbounded properties real time systems fixpoints functionals state relation 
formally introduce timed calculus interpreted timed computation trees 
compare fixpoint calculus standard real time extensions branching time logics find expressive powers incomparable basic operator branching time logics characterized fixpoints hinted able give translation ctl clock variables tctl alu agrees class behaved divergence safe models 
translation forms basis symbolic model checking procedure 
apply theory concrete real time programming language 
real time systems defined guarded command language clocks equivalent timed safety automata timed automata ad acceptance conditions 
guarded command real time program defines divergence safe real time system formulas tctl verified symbolically computing fixpoints finitely approximable fixpoints appropriate functionals 
practical computation functionals rests ability express program state relation symbolically 
extraction state relation program turns nontrivial case program nonzeno hen machine closed respect divergence time may prevent time diverging 
show symbolic fixpoint approach test guarded command real time program timed safety automaton nonzeno convert equivalent nonzeno program 
wish conclude pointing course magical symbolic methods 
timed model checking intrinsically difficult pspace hard known graph theoretic algorithm exponential region graph worst case nearoptimal acd 
practice intuitive complexity bcm state space typically smaller region graph 
symbolic method exploit phenomenon representing unions regions symbolically state predicates 
model checking algorithm constructs equivalent full region graph extreme cases typically works quotient region graph depends formula checked 
symbolic methods applied verification systems infinite state space known priori suitable finite quotient state space 
symbolic modelchecking procedure fail terminate quotient exists procedure remains sound led verification systems general state spaces 
remainder organized follows 
section define model real time systems 
section presents guarded command language automata language description real time systems 
section review branching time logic tctl introduce timed calculus section compares expressive power specification languages 
definition tctl formulas fixpoints leads section symbolic model checking algorithm tctl 
dense time model real time systems branching dense time semantics real time systems 
semantics integrates elements models proposed literature particularly indebted clocks ad dense trees acd transition delay dichotomy hmp relative safety hen 
state trajectories model time nonnegative real numbers state system determined values finite set boolean variables propositions representing data control values finite set real valued variables clocks 
clocks allow system time dependent decisions 
definition state state oe interpretation propositions clocks oe assigns proposition boolean value oe ftrue falseg clock nonnegative real oe write sigma set states 
delay ffi oe ffi denote state agrees state oe sigma propositions assigns value oe ffi clock set fv variables corresponding values ftrue falseg write oe state assigns value variable agrees state oe sigma propositions clocks 
execution system generates infinite succession states 
state system may take transition time pass 
transition system changes data control resets clocks values propositions modified certain clock values reset 
time passes clock values increase uniformly rate time 
follows state value clock equal amount time elapsed time reset 
definition trajectory divergence real time trajectory oe oe ffi oe ffi oe ffi oe ffi delta delta delta consists infinite sequence states oe sigma infinite sequence delays ffi nonnegative integers clocks oe oe oe ffi position trajectory oe pair ffi consisting nonnegative integer nonnegative real ffi ffi state position ffi oe oe ffi oe ffi time position ffi oe oe ffi ffi ffi trajectory oe diverges position ffi oe oe ffi pi set trajectories write pi div set divergent trajectories pi 
identify trajectories transformed repeated replacement state oe pair oe oe 
trajectory oe position ffi oe write oe ffi finite prefix oe ffi delta delta delta ffi gamma oe ffi oe ffi position ffi oe ffi infinite suffix oe ffi ffi gammaffi oe ffi oe ffi delta delta delta starting position ffi 
note oe ffi trajectory 
oe foe ffi ffi ffi denote set states th segment trajectory oe endpoints oe oe ffi 
positions trajectory oe ordered lexicographically position ffi precedes position ffl denoted ffi oe ffl iff ffi ffl 
model timed behavior system divergent trajectory 
decision reflects choices ah 
divergence requirement ensures progress time past real number 
second choose time weakly monotonic delay ffi time need advance consecutive transitions 
weak monotonicity time allows modeling simultaneous activities sequential interleaving 
researchers find abstraction convenient 
preference weak monotonicity precondition results may reversed 
third restrict modeling systems satisfy condition finite variability trajectory countable sequence states delays number transitions bounded time interval divergent trajectory finite 
possible behaviors system collected set real time trajectories 
set closed past fusion 
past closure result abstraction initial states system 
fusion closure asserts evolution system completely determined state system depend past fusion closed set pi trajectories state oe subset trajectories pi start oe form tree structure states root oe 
definition past fusion closure set pi trajectories closed suffix closed trajectories oe pi positions oe trajectory oe pi 
set pi past closed trajectories oe pi states oe sigma delays ffi oe oe ffi trajectory oe ffi ffi oe ffi oe ffi oe ffi delta delta delta pi 
set pi trajectories fusion closed trajectories oe oe pi positions ffi oe ffl oe oe ffi oe ffl trajectory oe ffi delta delta delta ffi gamma oe ffi oe ffi ffi gammaffl oe ffi oe ffi delta delta delta pi 
difficult check closure conditions pairwise independent 
note fusion closure set pi trajectories implies form stutter closure trajectories oe pi positions ffi oe trajectory oe ffi delta delta delta ffi gamma oe ffi oe ffi ffi gammaffi oe ffi oe ffi delta delta delta pi 
condition called time additivity ns asserts delay ffi ffi time units split consecutive delays ffi ffi time units respectively 
write gamma oe stutter closure trajectory oe gamma oe smallest stutter closed set trajectories contains oe 
definition premodel real time system premodel set trajectories closed past closed fusion closed 
real time system premodel contains divergent trajectories 
premodel pi state oe sigma reachable pi trajectory oe pi position oe oe oe 
write sigma pi set states reachable pi 
set pi trajectories closed past fusion subset pi div pi divergent trajectories 
conclude premodel subsumes real time system 
proposition pi premodel pi div real time system 
safety divergence safety safety property set admissible system behaviors closed certain limit behaviors set pi infinite state sequences closed limits iff infinite state sequence oe finite prefixes oe prefixes sequences pi limit sequence oe pi ads 
define corresponding notion safety real time trajectories 
definition safety set pi trajectories safe trajectory oe positions oe trajectory oe pi position oe oe oe oe pi 
safety closure pi smallest safe set trajectories subsumes pi 
suppose real time system pi contains trajectory initial state oe 
pi closed stuttering safety closure pi contain trajectory oe oe oe delta delta delta diverge 
follows nonempty real time system safe 
define stringent requirement divergence safety divergent limit trajectories 
definition divergence safety set pi divergent trajectories divergence safe divergent trajectory oe positions oe trajectory oe pi position oe oe oe oe pi 
divergence safety closure pi smallest divergence safe set trajectories subsumes pi 
example pi real time system changes value proposition false true time pi set divergent trajectories oe position clock positions oe 
oe oe false oe 
oe true 
oe oe 
difficult check set pi closed past fusion 
real time system pi divergence safe 
see take divergent trajectory oe finite prefix oe prefix trajectory pi oe diverges position oe 
oe prefix trajectory pi satisfies conditions position clock furthermore oe prefix trajectory pi positions oe oe true oe consider real time system pi changes value eventually pi set divergent trajectories oe position positions oe 
oe oe false 
oe true real time system pi divergence safe 
see oe divergent trajectory oe false positions oe 
finite prefix oe prefix trajectory pi oe pi reader familiar hen notice concept divergence safety corresponds notion safety relative divergence time 
close set pi trajectories divergent limits add divergent trajectory oe finite prefixes oe prefixes trajectories pi 
process need iterated 
follows divergence safety closure real time system pi obtained safety closure pi simply dropping trajectories diverge 
proposition sets pi divergent trajectories pi pi div corollary premodel pi safe real time system pi div divergence safe 
state relations safe premodels divergence safe real time systems defined binary transition relation state space indicates state oe sigma possible transition successors oe 
transition successor oe sigma oe results oe modifying propositional component state resetting clocks 
definition transition relation binary relation sigma states write sigma union domain range relation past closed states oe sigma delays ffi oe ffi sigma oe sigma relation self reflexive oe sigma oe oe transition relation sigma past closed self reflexive binary relation states oe oe implies clocks oe oe oe 
transition relation determines phase state relation advances time amount performs transition 
iteration phase relation generates real time trajectories 
transition relations required self reflexive infinite trajectories generated possibility deadlock 
definition generated trajectory transition relation delay ffi ffi oe oe ffi oe sigmag ffi 
ffi ffi transition relation defines relation ffi ffi trajectory oe oe ffi oe ffi oe ffi oe ffi delta delta delta generated transition relation oe ffi oe 
say oe trajectory write pi set trajectories 
difficult check set pi trajectories generated transition relation closed past fusion limits 
proposition transition relation set pi trajectories safe premodel 
corollary transition relation set pi div divergent trajectories real time system 
transition relation defines unique premodel pi safe unique real time system pi div divergence safe 
show closure conditions closure past fusion limits necessary sufficient set trajectories definable transition relation 
definition induced relation set pi trajectories induces smallest relation pi sigma trajectories oe ffi oe ffi oe ffi oe ffi delta delta delta pi nonnegative integers oe ffi oe pi pi set trajectories 
induced relation pi defined locally consecutive states trajectories pi sets trajectories safety closure induce transition relation 
proposition sets pi trajectories pi pi corollary sets pi divergent trajectories pi pi set pi trajectories closed past closed stutter closed induced relation pi past closed self reflexive reflexive states sigma pi reachable pi 
proposition pi premodel induced relation pi transition relation 
generalize known result infinite state sequences set infinite state sequences generated binary relation states iff closed suffixes fusion limits eme closure stuttering corresponds requirement self reflexivity generating relation 
safe premodel pi definable transition relation pi generates precisely trajectories pi 
likewise divergence safe real time system pi defined transition relation pi proposition premodels pi pi pi pi 
proof 
observe pi pi pi proposition pi pi pi see pi pi pi consider trajectory oe trajectory oe pi nonnegative integer oe ffi oe ffi oe oe pi closed trajectory oe pi oe ffi oe ffi oe oe pi past closed trajectory oe pi oe oe ffi ffi oe oe repeated application fusion closure pi follows positions oe trajectory oe pi position oe oe oe 
pi closed limits follows oe pi 
corollary real time systems pi pi div pi pi 
untimed systems premodels pleasing correspondence safety properties safe premodels state transition relations 
particular safe premodel pi defined operationally induced transition relation pi pi transition relation generates pi 
proposition transition relations pi corollary premodels pi transition relations pi pi iff pi safe pi corollary allows define divergence safe real time systems operationally transition relations just untimed safety properties defined state relations 
unique transition relation generates safe premodel pi pi transition relations generate divergence safe real time system pi call transition relation generates pi nonzeno iff suggests operational semantics pi iff finite prefix trajectory extended divergent trajectory hen 
see transition relations generate pi nonzeno pi suitable operational definition divergence safe real time system pi definition transition relation nonzeno trajectories oe positions oe divergent trajectory oe oe oe 
nonzeno transition relation suggests notion execution divergence safe realtime system pi div defined execution step consists phases time delay followed transition simple minded interpreter iterates execution steps generate precisely prefixes trajectories pi div hand transition relation zeno simple minded interpreter paint corner arrive state time diverge generating prefixes sequences pi prefixes sequences pi div 
example divergence safe real time system pi example induces transition relation pi oe false oe oe true oe oe oe oe oe false oe oe oe oe true oe oe transition relation pi nonzeno pi set divergent pi trajectories 
consider transition relation pi oe oe oe oe oeg set divergent trajectories pi transition relation zeno 
see observe nontrivial finite prefix trajectory false 
false 
false 
false delta delta delta extended divergent trajectory false stands state oe oe false oe 
transition relations pi define divergence safe realtime system pi relation suggests operational semantics pi iterate time delays transitions pi reader familiar concept machine closure realize requirement machine closure condition machine closure respect liveness property asserts divergence time 
show real time analogues proposition corollary reveal oneto correspondence divergence safe real time systems nonzeno transition relations 
follows divergence safe real time system pi defined operationally induced transition relation pi pi nonzeno transition relation defines pi 
proposition transition relation nonzeno iff pi div proof 
transition relation 
observe pi div suppose nonzeno 
see pi div consider pair oe oe self reflexive trajectory starts prefix oe oe nonzeno divergent trajectory starts prefix oe oe follows oe oe pi div suppose zeno show pi div zeno state oe occurs trajectory occur divergent trajectory 
oe oe pi div oe oe self reflexive 
corollary real time systems pi nonzeno transition relations pi pi div iff pi divergence safe pi real time programs languages defining divergence safe real time systems guarded command programming language clocks finite state machines clocks 
languages specify transition relations 
state predicates assert properties individual states define language state predicates 
recall state sigma interpretation boolean propositions real valued clocks definition state predicate set state predicates defined inductively grammar oe oe oe oe propositions clocks nonnegative integer constants state predicates interpreted states 
state oe sigma state predicate oe evaluates truth value oe oe ftrue falseg standard way 
state oe satisfies oe denoted oe oe oe oe true write oe sigma set states satisfy state predicate oe call oe states 
state predicates oe oe equivalent oe oe 
standard abbreviations state predicates true defined usual 
state predicates oe oe proposition write oe oe state predicate results oe replacing occurrence oe similarly clocks constant oe oe denote state predicate obtained oe replacing occurrence respectively 
set fv replacements write oe state predicate results oe simultaneously replacing variable corresponding expression delay ffi set fx ffi cg replacements write oe ffi state predicate oe 
satisfiability problem state predicates obviously simpler boolean satisfiability 
satisfiability problems equally difficult 
theorem satisfiability problem state predicates np complete 
proof 
state predicate oe largest constant oe number clocks oe 
suppose satisfying interpretation oe oe oe delta delta delta oe clocks oe 
construct interpretation oe agrees oe propositions ordering clock values oe gamma oe gamma oe gamma oe gamma oe gamma oe gamma assuming oe oe 
oe satisfies oe 
clock assigned value greater delta interpretation oe guessed checked time polynomial length oe 
evolving state predicates state predicates define static sets states 
time advances state clock values change may value state predicate 
describe motion state sets time binary evolves operator 
consider state predicates oe oe evolving state predicate oe oe defines set states state satisfying oe reached advancing time nonnegative amount oe satisfied oe reached 
definition evolving state predicate set evolving state predicates obtained adding evolves operator grammar state predicates oe oe evolving state predicates oe oe state oe sigma satisfies evolving state predicate oe oe written oe oe oe nonnegative real ffi oe ffi oe nonnegative reals ffl ffi oe ffl oe intuitive view evolves operator geometrically 
suppose state predicate oe contains clock variables propositions 
oe defines finite union polyhedra dimensional space evolving state predicate true oe defines shadow oe light source true oe ffi oe ffi example consider dimensional state predicates oe oe evolving state predicates true oe oe oe define polygons true oe gamma oe oe shown 
note evolving state predicates equivalent pure state predicates 
shall see accident 
true oe oe oe oe oe oe graphic representations true oe oe oe viewed logically evolves operator extends language state predicates restricted form quantification real numbers evolving state predicate oe oe equivalent quantified formula ffi ffi oe ffi ffl ffl ffi oe ffl eliminating quantifiers show evolving state predicates expressive state predicates 
tarski showed theory reals order addition admits quantifier elimination come surprise 
ensure quantifier free formula obtained eliminating evolves operator state predicate near optimal decision procedure ferrante rackoff order theory real addition order fr 
provide nonelementary translation evolving state predicates state predicates exact complexity satisfiability problem evolving state predicates open problem 
theorem evolving state predicate oe construct equivalent state predicate joej 
integer constants occurring joej bounded largest integer constant oe 
proof 
repeat eliminating innermost evolves operator 
consider subformula oe oe state predicates oe oe oe oe ffi ffi oe ffi ffl ffl ffi oe ffl proceed steps eliminate quantifiers 
eliminate inner existential quantifier 
atoms scope oe quantifier ffl oe forms ffl ffl ffi ffl ffl convert oe disjunctive normal form may cause exponential blowup 
observe existential quantifier distributes disjunction atoms forms rearrange remaining inequalities provide lower upper bounds ffl solve disjunct ffl may cause quadratic blowup ffl ffl ffl ffi ffl gamma gamma ffl ffi gamma gamma ffi gamma gamma ffi ffi eliminate outer existential quantifier 
atoms scope oe quantifier ffi oe forms ffi ffi ffi convert oe disjunctive normal form solve disjunct ffi ffi ffi ffi gamma gamma ffi gamma gamma gamma guarded command real time programs real time program consists set guarded commands program invariant 
transition corresponds execution guarded command 
guard command refers values propositions clocks asserts necessary condition corresponding transition take place 
program invariant refers values propositions clocks violated letting time advance asserts sufficient condition transition take place 
example guard clock puts lower bound time corresponding transition take place clock reaches value 
invariant hand implies upper bound time transition transition take place clock reaches value 
transition taken propositions assigned new values clocks reset 
definition real time program syntax guarded command real time program oe consists 
program body set guarded commands 
guarded command form state predicate guard command set fv cg simultaneous assignments propositions expression state predicate clocks expression clock reset clock left unchanged 

oe program invariant state predicate 
require oe past closed states oe sigma delays ffi oe ffi oe oe oe guarded command defines partial function sigma sigma 
guarded command fv cg oe sigma state 
guarded command enabled state oe oe 
guarded command enabled oe may executed oe 
execution particular leads state oe oe oe variables definition real time program semantics real time program oe defines transition relation sp oe oe sp 
oe oe guarded command oe oe oe 
oe oe oe oe divergent sp trajectory called run write pi pi div sp set runs sigma set states reachable pi real time programs equivalent runs pi pi 
real time program nonzeno transition relation sp nonzeno 
real time program oe defines safe premodel pi sp divergence safe real time system pi transition pi corresponds execution guarded command past closure invariant oe ensures oe oe states oe sigma occur run example divergence safe real time system pi example defined real time program single guarded command true invariant 
writing guarded commands suppress guard true assignments form 
sp pi alternatively divergence safe real time system pi defined real time program single guarded command true invariant 
pi pi sp ae sp real time programs runs nonzeno 
transition relation defined zeno transition relation example 
invariant oe real time program defines precisely set sigma sp states occur sp trajectory 
show program nonzeno iff strongest possible invariant invariant defines precisely set sigma states occur run proposition real time program invariant oe oe sigma sp real time program nonzeno iff oe sigma proof 
states occur sp trajectory satisfy invariant sigma sigma sp oe 
suppose state oe satisfies invariant oe oe oe oe delta delta delta sp trajectory oe sigma sp real time program nonzeno state occurs sp trajectory occurs run oe sigma conversely suppose state satisfies invariant oe occurs run show real time program nonzeno suffices show state occurs sp trajectory occurs run follows assumption states occur sp trajectory satisfy invariant oe follows nonzeno real time programs executed stepwise fashion start state satisfies invariant repeatedly choose guarded command enabled execution violate invariant advance time violating invariant 
iteration relation sp defined zeno real time program hand may lead state time diverge 
words nonzeno real time programs precisely real time programs executed looking ahead 
real time program zeno invariant weak 
section show real time program set sigma states occur run defined state predicate oe 
nonzeno real time program equivalent replace invariant oe 
give algorithm automatically converts real time program equivalent nonzeno program strengthening invariant 
consider second example 
example consider real time program oe ff ternary variable short boolean variables ranges fa cg clock ff ff ff ff ff ff oe ff ff ff program started ff value ff alternates arbitrarily finitely ff assigned point time 
lower bound imposed guard third guarded command upper bound imposed invariant 
ff set program time pass 
consider real time program oe ff ff ff ff ff ff oe ff ff ff difficult check real time programs equivalent 
nonzeno zeno invariant oe weak 
state oe oe ff fa bg oe occurs sp trajectory oe oe oe delta delta delta oe occur run executing stepwise interpreter may decide time pass state ff ff case commits zeno run converge time 
real time program guards invariant state predicates guarded commands assign value state predicates propositions 
follows transition relation sp characterized syntactically predicate transformer maps state predicates state predicates 
definition precondition state predicate oe guarded command weakest precondition oe respect state predicate pre oe oe characterizes states state satisfying oe obtained executing guarded command real time program oe weakest precondition oe respect state predicate pre oe oe oe pre oe oe characterizes oe states oe state satisfying oe obtained doing executing guarded command proposition real time program oe state predicate 
states oe sigma oe pre oe iff exists state oe sigma oe oe sp oe oe 
state predicate transformer pre execute nonzeno real time program symbolically 
timed safety automata real time program example represented graphically 
graph viewed transition diagram timed automaton ad finite automaton finite set real valued clocks 
define class timed automata timed safety automata specifying divergence safe real time systems 
definition timed safety automaton syntax timed safety automaton labeled directed multigraph consisting 
finite set vertices called locations 

multiset edges called transitions 

vertex labeling function assigns location past closed state predicate location invariant 

edge labeling function assigns transition guarded command 
timed safety automaton example timed safety automaton locations location invariant true guard true assignment suppressed 
defining transition relation sa timed safety automaton directly translate automaton real time program 
purpose new proposition location automaton write ff state predicate gammaf pm ff set fp trueg fp false gamma gg assignments 
definition timed safety automaton semantics timed safety automaton define real time program pa oe transition labeled guarded command contains guarded command ff fff reader familiar ad notice nonstandard variety timed automata permits clock constraints locations transitions interpreted weakly monotonic time ah 
furthermore ensure timed automaton defines divergence safe real time system assume locations automaton buchi accepting 
program invariant oe past closed state predicate ff timed safety automaton defines transition relation sa spa write pi pi pa set runs timed safety automaton example zeno timed safety automaton corresponds zeno real time program pa example 
conversely difficult translate real time program timed safety automaton ap single location transition guarded command ap define transition relation 
real time logics compare branching time logics specifying properties real time systems timed computation tree logic tctl timed calculus languages clocks arithmetic constraints clock values specify timing requirements 
timed computation tree logic important properties systems find natural expression temporal logic eme 
review real time temporal logic tctl acd extends branching time logic ctl ec clock variables 
formulas tctl interpreted states premodel pi built state predicates boolean connectives temporal operators possibly inevitably reset quantifier clocks 
intuitively formula uq uq holds state oe pi iff proposition true trajectory pi starts oe proposition true true 
formulas tctl contain kinds variables 
propositional variables clock variables occur freely refer states premodel pi 
addition may bind certain clock variables reset quantifiers express timing requirements specification 
specification clock clock control behavior system consideration consider trajectories oe positions oe oe oe oe write set specification clocks 
reset quantifier binds resets specification clock inspired freeze quantifier timed temporal logic ah example formula true asserts proposition necessarily true time units 
definition syntax tctl formulas timed computation tree logic tctl defined inductively grammar propositions clocks specification clocks nonnegative integer constants additional arithmetic boolean temporal operators defined usual 
particular temporal operators stand true respectively temporal operators stand true respectively 
note state predicates definable tctl example state predicate abbreviates tctl formula 
formulas tctl interpreted states premodel 
propositions free clock variables tctl formula evaluated states 
evaluate bound clock variables clock environments 
clock environment partial function set specification clocks nonnegative reals empty clock environment undefined specification clocks 
clock environment ffi delay ffi maps clock value ffi environment defined ffi undefined write environment agrees environment variables mapped value definition semantics tctl pi premodel oe sigma pi state reachable pi 
state oe satisfies tctl formula pi denoted oe pi oe pi empty clock environment 
satisfaction relation pi defined inductively clock environments oe pi iff oe true oe pi iff defined oe oe pi iff oe pi oe pi iff oe pi oe pi oe pi iff trajectory oe pi oe oe exists position ffi oe oe ffi pi oe ffi positions ffl oe ffl oe ffi oe ffl pi oe ffl oe pi iff trajectories oe pi oe oe exists position ffi oe oe ffi pi oe ffi positions ffl oe ffl oe ffi oe ffl pi oe ffl oe pi iff oe pi 
point density time domain causes subtle complication definition operators suppose formula oe oe holds trajectory oe iff oe true oe oe true oe oe true 
particular state predicate oe may true position oe left open interval immediately position oe compare formulas 
account possibilities require position oe oe true disjunction oe oe oe true positions oe follows tctl formula holds state real time system 
comments regarding particular version tctl order 
acd opted weakly monotonic time 
second time bounded temporal operators acd definable tctl 
instance time bounded response requirement asserts request followed response time units expressible tctl formula time bounded temporal operators abbreviations 
third version tctl freeze quantifiers static time variables replaced reset quantifiers dynamic clock variables 
approaches equivalent alu clock reset style fits better definition real time programs 
finite variability premodel pi formula tctl defines set sigma pi reachable states states satisfy 
refer characteristic set pi requirement pi specified 
definitions apply logics tctl formulas interpreted states premodel 
definition characteristic set characteristic set pi formula premodel pi set reachable states satisfy pi pi foe sigma pi oe pi interpreting formula premodel pi convenient consider place subformula set sigma states 
example write pi set states trajectory pi leads state formally states oe sigma pi environments oe pi iff oe definition finite variability trajectory oe nonnegative integer recall oe stands set states th segment oe section 
trajectory oe respects set sigma states oe oe 
set finitely variable oe trajectory oe gamma oe stutter closure oe oe respects set finitely variable set pi trajectories finitely variable trajectories pi 
logic finitely variable class premodels formulas premodels pi characteristic set pi finitely variable pi 
oe trajectory 
defined trajectories characteristic sets atomic state predicates finitely variable oe 
state sets finitely variable oe closed complement union finite intersection 
follows state predicates define finitely variable sets 
proposition logic state predicates finitely variable premodels 
tctl finitely variable premodels 
example presents tctl formula divergence safe real time system pi characteristic set pi finitely variable pi example pi real time system changes value proposition false true time gamma positive integer changes value back false time gamma precisely pi set divergent trajectories transition relation reflexive closure binary relation oe oe oe false oe gamma oe true oe oe oe true oe gamma oe false oe oe pi divergence safe tctl formula finitely variable pi pi foe oe false gamma oe branching structure real time system pi specified real time program 
restrict attention real time systems definable guarded command real time programs timed safety automata tctl finitely variable 
real time programs state sets defined tctl formulas defined state predicates 
state sets called regions 
definition region real time program formula cp set clocks occur guard program invariant freely largest integer constant occurs 
set states sigma region state predicate oe oe clock variables oe cp largest integer constant oe region minimal properly contain nonempty region 
suppose example cp fx 
state predicate oe defines region disjoint union minimal regions oe oe oe 
observations regions immediate 
real time program tctl formula 
finitely regions contain clocks constant larger delta 
minimal regions alu region finite disjoint union minimal regions 
second regions closed boolean operations 
third real time system pi closed past theorem implies lemma asserts regions closed time delays 
lemma real time program tctl formula oe oe state predicates 
oe oe regions oe oe region 
restate framework main theorem timed automata alur thesis 
proposition obtain finite variability tctl real time programs corollary 
theorem alu real time program tctl formula characteristic sets pi pi regions 
corollary tctl finitely variable class real time programs 
timed calculus introduce dense time calculus clocks 
formulas built state predicates boolean connectives temporal operator reset quantifier clocks fixpoint quantifier 
discrete time calculi rely unary time operator koz eme notion time time modeled real numbers 
binary operator best viewed single step operator temporal logic roughly speaking formula asserts true stays true transition taken transition establishes particular transition may arbitrarily close time arbitrarily far away 
example formula true 
asserts established single transition taken time units 
formulas contain kinds variables 
addition free propositional variables free clock variables specification clocks bound reset quantifiers formulas may contain formula variables bound fixpoint quantifiers 
set formula variables write fixpoint quantifier binds formula variable definition syntax formulas timed calculus defined inductively grammar modal operator similar operator proposed dense time extension hennessy milner logic 
formula variables propositions clocks specification clocks nonnegative integer constants require occurrence formula variable bound appears scope fixpoint quantifier positive appears number negations quantifier binds 
standard condition formula variables occur positively ensures arguments fixpoint quantifiers define monotonic functionals guarantees existence corresponding fixpoints 
additional arithmetic boolean operators defined usual case tctl state predicates definable write formula results replacing free occurrence formula variable expression abbreviation denotes greatest fixpoint quantifier stands formula 
formulas interpreted states sigma premodel 
purpose environment needs extended provide values specification clocks formula variables 
environment consists clock environment total function set formula variables power set sigma states specification clocks undefined formula variables sigma 
environment empty clock component empty 
environment ffi delay ffi consists clock component ffi component definition semantics pi premodel oe sigma pi state reachable pi 
state oe satisfies formula pi denoted oe pi oe pi empty environments satisfaction relation pi defined inductively environments clauses differ definition semantics tctl oe pi iff oe oe pi iff state oe sigma pi delay ffi oe ffi pi oe oe pi ffi delays ffl ffl ffi oe ffl pi ffl oe pi iff oe fs sigma pi foe sigma pi oe pi sg 
formula write pi sigma pi set reachable states satisfy 
pi premodel environment 
consider subformula formula may contain free formula variables 
semantic clause quantifier ensures formula defines fixpoint functional sigma pi sigma pi sigma pi oe sigma pi oe iff oe pi 
fixpoint functional exists tarski knaster theorem monotonic functional complete lattice sigma pi implies 
see recall free occurrences positive observe disjunction conjunction lemma operator monotonic arguments 
lemma pi premodel 
sets sigma pi pi pi pi pi semantic clause operator uses existential quantification successor states 
dual operator unary operator universal force definable premodels pi environments reachable states oe sigma pi oe pi true 
iff states oe sigma pi delays ffi oe ffi pi oe oe pi ffi stutter closure pi implies oe ffl pi ffl delays ffl ffi 
computing fixpoints pi premodel formula characteristic set pi fixpoint monotonic functional pi follows pi sufficiently large ordinal characteristic set pi limit successive approximation sequence show class real time programs elements sequence regions 
construct state predicates define regions 
lemma fundamental computing fixpoints zeno nonzeno realtime programs successive approximation 
accommodate nested fixpoint quantifiers need look formulas free formula variables 
lemma real time program fixpoint quantifier free subformula formula formula variables fx set assignments state sets formula variables 
state sets regions characteristic set pi real time program nonzeno pi pi proof 
oe invariant real time program induction structure subformula 
proof pi pi sp nonzeno pi pi suppose formula variable region defined state predicate oe proposition follows pi defined state predicate oe oe proposition clock constraint pi defined state predicate oe 
boolean cases follow fact regions closed boolean operations 
form pi defined state predicate oe pi defined state predicate oe 
suppose form characteristic sets pi defined state predicates oe proposition follows pi defined evolving state predicate oe oe pre oe lemma follows theorem 
nonzeno real time program 
finitely regions pi im sufficiently large integer limit successive approximation sequence reached finite number steps 
observation basis symbolic modelchecking algorithm section 
precisely number iterations functional necessary compute fixpoint bounded number minimal regions exponential representations 
general number iterations required method compute characteristic set pi arbitrary formula depends exponentially number clocks size largest constant nesting depth fixpoint quantifiers 
section show real time program equivalent nonzeno program 
theorem follows 
theorem real time program formula characteristic sets pi pi regions 
corollary finitely variable class real time programs 
contrast finitely variable premodels consider divergence safe real time system pi example formula true 

expressive power fixpoints compare expressive power timed calculus expressive power timed computation tree logic tctl 
expressive power logic measured determining requirements class premodels definable logic 
definition expressiveness class premodels 
formula equivalent formula class pi pi premodels pi logic expressive logic class formula formula equivalent depending class premodels consideration obtain different results relative expressiveness logics 
particular show tctl requirements real time systems specified tctl requirements guarded command realtime programs specified recall tctl temporal operators temporal operator 
proceed steps 
show possibility operator definable fixpoint premodels 
second show inevitability operator definable fixpoint real time systems 
third show inevitability operator definable fixpoint safe premodels finitely variable arguments divergence safe real time systems 
possibility premodels couple positive results 
show premodels possibility reachability operator definable operator definable tctl 
proposition premodels pi sets sigma pi reachable states pi pi proof 
show set pi solution equation pi pi 
pi oe sigma pi reachable state 
oe pi oe oe pi oe oe pi 
conversely oe oe pi pi closed fusion closed oe pi 
oe pi remains shown set pi solution equation pi sigma pi pi show pi oe sigma pi oe pi trajectory oe pi position ffi oe oe oe oe ffi positions ffl oe ffl oe ffi oe ffl 
induction follows oe gamma particular oe words characteristic set formula fixpoint functional pi proof proposition follows pi intuitively set contains states state reached transitions path point functional monotonic lemma necessarily continuous 
operator definable tctl provided set propositions clocks assumed finite 
define formula possibility operator ensure argument proposition changes value clock reset clock changes positive value value 
assurance finite disjunction formulas form oe oe state predicates oe enumerate possible proposition values boolean clock values zero positive state predicate oe agrees oe propositions asserting clocks positive 
follows tctl formula operators tctl formula operators equivalent premodels 
inevitability real time systems observation instrumental characterizing expressive power fixpoints timed calculus distinguish premodels induce transition relation 
proposition premodels pi pi formulas pi pi pi pi proof 
observe pi pi implies sigma pi sigma pi straightforward show induction structure reachable states oe sigma pi environments oe pi iff oe pi 
consider real time system pi contains trajectories clock reset including trajectory starts 
pi pi 
sigma pi 
corollary formula premodels pi pi pi real time systems pi pi pi apply proposition examples 
consider tctl formula div formula div satisfied state oe premodel pi iff time diverges trajectories start oe 
consequently div pi sigma pi iff premodel pi real time system 
difficult see formula equivalent tctl formula div premodels note formula true trivially equivalent div class real time systems 
suppose formula asserting premodel pi real time system pi sigma pi iff pi real time system corollary pi real time system contradiction real time system safe 
follows timed calculus premodels expressive branching time logic tctl 
strengthen observation class real time systems 
second recall real time system pi example eventually changes value proposition false true safety closure pi contains trajectory oe oe false positions oe 
reachable states pi satisfy case pi corollary follows property defined class real time systems 
part result 
theorem expressive tctl class real time systems tctl expressive class real time programs 
gamma gamma timed safety automata proof 
need show second part theorem 
recall ctl strictly expressive propositional calculus particular ctl formula fl asserts trajectory contains infinitely states defined ctl ec 
modify combinatorial proof result eh show formula inf 
definable tctl class real time programs 
proof proceeds contradiction 
suppose tctl formula pi inf pi real time programs nesting depth temporal operators set propositions occur 
consider sequences timed safety automata defined 
automata modify control variable ff value oe ff fa ng encoded propositions clocks write sigma sigma set states oe oe oe 
state oe sigma clock environment oe environment oe specification clocks avoid cumbersome notation write oe state oe ff suppress automaton designators possible note run starts state oe run oe vice versa 
show claims 
states oe sigma oe inf 
states oe sigma oe inf 
tctl formulas depth contain propositions states oe sigma oe environments integers oe iff oe 

tctl formulas depth contain propositions states oe sigma oe environments oe iff oe 
second part theorem follows claims applied claim establish claim 
show claim induction show claim foe oe sigmag observe 
pi proofs claims technical appendix 
theorem come surprise 
true untimed case logic ctl strictly expressive propositional calculus ec 
precisely operators definable propositional calculus systems generated transition relations safe systems eme 
stutter closure safe system may longer safe 
inevitability operator ctl defined propositional calculus stutter closures safe systems propositional calculus distinguish system safety closure 
systems safe ctl formula trivially equivalent second argument 
proposition shows observation applies timed case 
note formula inf define set states oe sigma pi state predicate true infinitely positions run starts oe set empty 
characteristic set inf pi set states may true arbitrarily finitely 
proposition pi premodel sigma pi sets reachable states 
pi safe pi proof 
observe pi premodels pi 
assume premodel pi safe 
see pi oe sigma pi reachable state suppose oe pi pi closed stutter closed safe contains trajectory oe oe oe delta delta delta oe pi follows oe subsection show expressive tctl class real time programs allow compute characteristic sets tctl formulas real time programs fixpoints 
proof depend divergence safety real time programs finite variability tctl real time programs 
proof part theorem shows finite variability sufficient condition defining inevitability know divergence safety sufficient 
words open problem expressive tctl class divergence safe real time systems 
inevitability real time programs show steps class real time programs fixpoint characterization inevitability 
recall real time programs define divergence safe real time systems 
proposition show divergence safe real time systems inevitability operator defined fixpoint time bounded inevitability operator uc positive integer constant 
second recall tctl requirements finitely variable class real time programs corollary premodels fixpoint characterization possibility proposition 
lemma show finitely variable arguments time bounded inevitability operator uc class real time systems definable possibility operator proposition pi real time system sigma pi sets reachable states positive integer constant 
pi divergence safe pi uc pi proof 
observe set pi solution equation uc pi pi uc pi assume real time system pi divergence safe 
show set pi solution equation uc pi sigma pi uc pi show pi assume state oe pi gamma show contradiction 
point condition divergence safety necessary consider real time system consists divergent trajectories value proposition changes finitely omitted 
see recall real time system pi example eventually changes value proposition false true 
corollary follows pi pi pi pi construct inductively infinite sequence states oe pi gamma suppose constructed oe oe pi closed trajectories pi diverge trajectory oe pi oe oe position oe oe 
position oe oe positions oe oe 
positions oe oe gamma 
oe pi condition happen condition implies 
positions oe oe pi gamma 
choose oe oe 
consider trajectory oe results trajectory prefixes oe oe oe oe oe delta delta delta trajectory oe diverges 
pi fusion closed divergence safe oe pi 
furthermore oe oe condition oe positions oe 
follows oe pi contradiction 
folk theorem formalized hen time bounded properties safety requirements 
consider time bounded properties time bounded invariance property puts lower time bound occurrence state written tctl formula easily recognized invariance 
hand time bounded response property puts upper time bound occurrence state written tctl formula formula class real time systems equivalent negated possibility invariance intuitively state inevitable time divergent trajectories iff possible time units pass state occurring 
generalization observation binary bounded inevitability operators uc surprisingly subtle argument uc different true restrict real time systems second argument finitely variable 
lemma pi real time system sigma pi sets reachable states nonnegative integer constant 
finitely variable pi uc pi pi proof 
recall uc stands premodels equivalent class real time systems equivalent operator defined follows premodels pi clock environments reachable states oe sigma pi oe pi iff trajectories oe pi oe oe 
exists position ffi oe oe ffi pi oe ffi positions ffl oe ffl oe ffi oe ffl pi oe ffl 
positions ffi oe oe ffi pi oe ffi second show premodels pi sets sigma pi reachable states finitely variable pi pi pi oe sigma pi reachable state 
oe pi oe pi conversely assume oe pi trajectory oe pi oe oe 
positions oe oe position oe oe oe 
position oe oe oe positions oe condition implies oe pi 
infimum positions oe oe positions oe oe oe oe finitely variable trajectory oe position oe positions oe oe oe case condition implies oe pi 
translating timed computation tree logic timed calculus propositions corollary lemma prescribe method computing real time programs tctl requirements fixpoints specifically translate tctl formula formula ffl replacing subformula form formula positive integer constant ffl replacing subformula form formula 
see finite variability condition omitted consider real time system pi reset clock pi foe sigma pi oe oe sigma pi oe oe pi oe pi 
choice may effect number iterations performed symbolic model checking algorithm section 
resulting formula equivalent original tctl formula class real time programs 
conclude theorem 
theorem expressive tctl class real time programs 
specifically tctl formula construct formula size linear size equivalent class real time programs 
symbolic model checking formula tctl premodel pi meets correct respect requirement reachable states pi satisfy formula pi sigma pi verification question deciding premodel specified system description language meets requirement specified logic called model checking problem model checking problem verifying tctl specifications real time programs solved alur courcoubetis dill acd 
solution relies explicit construction finite quotient graph called region graph infinite state transition graph defined input program construction region graph vertices minimal regions leads model checking algorithm exponential number input clocks size largest input constant 
theorem tells expect general verification procedure 
theorem acd model checking problem real time programs tctl pspacecomplete 
practice unnecessary construct entire region graph 
take advantage observation representing state sets required solving specific problem instance representing state sets symbolically state predicates 
words enumerating minimal regions symbolic model checking algorithm computes regions selectively symbolically 
algorithm real time program formula tctl theorems state predicate oe pi oe 
call oe characteristic predicate compute characteristic predicates tctl formulas steps 
apply theorem translate equivalent formula second apply algorithm compute characteristic predicate successive approximation fixpoints 
algorithm defined inductively structure formulas 
algorithm symbolic model checking input real time program invariant oe formula 
output state predicate ffl jpj oe ffl jx dj oe ffl oe ffl ffl pre see definition definition pre theorem computation joe oe ffl jz ffl jx result iteration false repeat oe oe oe return oe 
test oe state predicates oe decided theorem check satisfiability state predicate oe 
termination correctness algorithm follow constructive proof lemma 
theorem real time program formula input algorithm yields output finite number steps state predicate pi real time program nonzeno pi algorithm verify tctl specifications specifications nonzeno real time programs nonzeno real time program meets requirement iff characteristic predicate equivalent program invariant oe theorem decide equivalence state predicates 
corollary model checking problem real time programs decidable 
hand region graph real time program model checking formulas done time exponential number input clocks size largest input constant nesting depth fixpoint quantifiers 
hand reachability problem timed automata alu follows model checking problem real time programs pspace hard 
exact complexity known date untimed problem model checking propositional calculus 
optimizations computing fixpoints propositional calculus apply algorithm example intermediate results reused nested fixpoints polarity computed el 
practicality symbolic method depends furthermore representation state predicates 
algorithm compute characteristic predicates formulas directly region graph input program know implementations represent state sets symbolically avoid costly construction region graph 
verification system grenoble represents state predicates difference matrices integers dil verification system cornell represents state predicates mathematica formulas 
verification example consider gate controller railroad crossing 
system consists parallel processes train controller 
processes modeled timed safety automata shown 
app app railroad gate controller control variable ff train automaton ranges locations ff train far crossing ff train close crossing ff train crossing 
train approaches crossing proceeds location location sends signal app gate controller 
happens minutes train enters crossing 
train leaves crossing proceeds location location sends signal gate controller 
happens minutes app signal 
control variable fi controller automaton ranges locations fi controller waiting train arrive fi signal app received fi gate fi signal received 
controller receives app signal train responds closing gate minute minutes 
controller receives signal responds opening gate minute 
define product timed safety automata combines train process controller process synchronizing app signals 
providing formal definition parallel composition see instance ad real time program oe specifies resulting system ff fi app ff fi ff ff fi fi ff fi ff fi fi fi oe ff fi ff fi fi difficult check real time program nonzeno 
wish verify gate closed minutes 
requirement expressed tctl formula oe init fi fi initial condition oe init ff fi theorem tctl formula real time program equivalent formula oe init fi fi true apply algorithm compute characteristic predicate state predicate jx fi defines inner fixpoint computed iteratively false oe oe fi 
oe ff ff ff fi fi fi ff fi ff ff fi gamma ff fi gamma gamma ff fi ff fi gamma ff fi gamma gamma find fixpoint computation terminates compute state predicate jz ff ff ff fi fi compute outer fixpoint iteratively oe oe oe false oe oe fi oe oe 
computation converges oe oe oe fi oe oe ff ff ff fi difficult check state predicate oe oe init oe equivalent program invariant oe implies real time program meets specification 
symbolic analysis algorithm check real time program nonzeno convert equivalent nonzeno real time program 
check nonzeno compute characteristic predicate possibility requirement true states time advance time unit 
proposition real time program invariant oe nonzeno iff pi oe 
proof 
recall oe sigma sp proposition 
pi oe 
consider state oe sigma sp occurs sp trajectory 
real time program nonzeno state occurs sp trajectory occurs run oe pi 
conversely states oe sigma sp occur sp trajectories satisfy oe pi inductively construct divergent sp trajectory starts oe add segment length exactly time unit oe state oe 
convert zeno real time program equivalent nonzeno program need strengthen program invariant new invariant rules states time diverge 
bad zeno states pi sp states satisfy formula nz true states occur sp trajectory time advances infinitely time unit nz characterizes precisely states occur runs proposition real time program nz pi sigma characteristic predicate greatest fixpoint formula nz computed algorithm 
invariant oe nonzeno real time program defines precisely set sigma states occur runs proposition invariant oe equivalent characteristic predicate nz proposition 
hand real time program zeno invariant oe weaker nz replaced nz obtain equivalent nonzeno program 
theorem real time program equivalent nonzeno real time program obtained replacing program invariant state predicate nz computed algorithm 
concluding remarks discussed applications symbolic model checking automatic conversion real time program equivalent nonzeno program verification nonzeno real time programs 
ideas underly method devise various different symbolic verification strategies 
suppose wish check real time program oe state reached oe state oe define initial states oe set bad formula nz equivalent tctl formula premodels 
define extension tctl tctl analogous extension ctl eh ctl separates trajectory quantifiers temporal operators 
tctl formula nz written 
states 
solve problem backwards starting set oe states iterate precondition operator pre program transitions evolves operator time delays compute set oe pi states reach oe state check set contains oe state 
alternatively define symbolic postcondition operator post symbolic evolves operator gamma solve reachability problem forwards starting set oe states iterate post gamma compute set states reachable oe state check contains oe state 
third strategy constructs successive approximation coarsest bisimulation state space separates oe states oe states 
strategy implemented precondition evolves operators ach 
conclude pointing natural extension method allows analysis called hybrid systems contain variables change continuously general ways clocks 
acknowledgment 
peter careful reading 
appendix completion proof theorem 
show claim define equivalence relation pairs consisting states clock environments 
oe oe iff state predicates oe oe oe iff oe oe oe oe differ fractional parts clock values relative order fractional parts clock values preserved 
example clocks real time program assume oe oe 
oe oe belong minimal region tctl formula 
theorem follows tctl formulas oe pi oe iff oe pi oe oe pi oe iff oe pi oe 
call observation equivalent values lemma 
turn claim 
suffices show induction structure oe iff oe 
case atomic depends assumption contains propositions cases form straightforward 
assume oe exist delays ffi ffi oe ffi ffi ffl oe ffi ffi ffl ffi oe ffl ffl ffl oe ffi ffi ffi ffi ffl ffi oe ffi ffl ffi ffl ffl ffi oe ffl ffl ffl oe gamma ffi ffi ffi ffi ffl ffi oe ffi ffl ffi ffl ffl ffi oe ffl ffl observe ffi implies oe gamma ffi ffi ffi ffi oe gamma ffi ffi induction hypothesis case equivalent values lemma conclude oe ffl oe ffi ffi ffl ffi oe ffl ffl ffl oe gamma ffi ffi ffi ffi ffl ffi oe gamma ffi ffl ffi ffl ffl ffi oe ffl ffl ffl oe gamma ffi ffi ffl ffi oe ffl ffl converse implication case form checked similarly 
show claim induction structure 
atomic boolean reset quantifier cases easily checked 
assume oe exists delay ffi oe ffi ffl oe ffi ffi ffl ffi oe ffl ffl ffl oe gamma ffi ffi ffl ffi oe ffl ffl induction hypothesis conclude oe ffl oe ffi ffi ffl ffi oe ffl ffl ffl oe gamma ffi ffi ffl ffi oe ffl ffl conversely assume oe exists sequence ffi ffi delays oe delta delta kj ffi ffl oe delta gamma ffi ffi ffl ffi oe delta gamma ffl delta gamma ffl ffl ffi oe delta gamma ffl delta gamma ffl ffl oe gamma delta delta ffl ffi oe delta gamma ffl delta gamma ffl induction hypothesis claim conclude oe ffl oe delta gamma ffi ffi ffl ffi oe delta gamma ffl delta gamma ffl ffl ffi oe gammaj delta gamma ffl delta gamma ffl ffl oe gamma delta delta ffl ffi oe gammaj delta gamma ffl delta gamma ffl application claim yields oe case form checked similarly 
acd alur courcoubetis dill 
model checking real time systems 
proceedings fifth annual symposium logic computer science pages 
ieee computer society press 
ach alur courcoubetis halbwachs dill wong toi 
minimization timed transition systems 
smolka editor concur theories concurrency lecture notes computer science pages 
springer verlag 
alur courcoubetis henzinger 
ho 
hybrid automata algorithmic approach specification verification hybrid systems 
grossman nerode ravn rischel editors hybrid systems lecture notes computer science pages 
springer verlag 
ad alur dill 
automata modeling real time systems 
paterson editor icalp automata languages programming lecture notes computer science pages 
springer verlag 
ads alpern demers schneider 
safety stuttering 
information processing letters 
afh alur feder henzinger 
benefits relaxing 
proceedings tenth annual symposium principles distributed computing pages 
acm press 
ah alur henzinger 
really temporal logic 
proceedings th annual symposium foundations computer science pages 
ieee computer society press 
ah alur henzinger 
back theory timed regular languages 
proceedings rd annual symposium foundations computer science pages 
ieee computer society press 
ah alur henzinger 
logics models real time survey 
de bakker huizing 
de roever rozenberg editors real time theory practice lecture notes computer science pages 
springer verlag 
alur henzinger 
ho 
automatic symbolic verification embedded systems 
proceedings th annual real time systems symposium pages 
ieee computer society press 
abadi lamport 
existence refinement mappings 
proceedings third annual symposium logic computer science pages 
ieee computer society press 
abadi lamport 
old fashioned recipe real time 
de bakker huizing 
de roever rozenberg editors real time theory practice lecture notes computer science pages 
springer verlag 
alu alur 
techniques automatic verification real time systems 
phd thesis stanford university 
bcm burch clarke mcmillan dill hwang 
symbolic model checking states 
information computation 
bry bryant 
graph algorithms boolean function manipulation 
ieee transactions computers 
cbm coudert madre 
verification synchronous sequential machines symbolic execution 
sifakis editor cav automatic verification methods finite state systems lecture notes computer science pages 
springer verlag 
ces clarke emerson sistla 
automatic verification finite state concurrent systems temporal logic specifications 
acm transactions programming languages systems 
dil dill 
timing assumptions verification finite state concurrent systems 
sifakis editor cav automatic verification methods finite state systems lecture notes computer science pages 
springer verlag 
ec emerson clarke 
characterizing correctness properties parallel programs fixpoints 
icalp automata languages programming lecture notes computer science pages 
springer verlag 
ec emerson clarke 
branching time temporal logic synthesize synchronization skeletons 
science computer programming 
eh emerson halpern 
revisited branching versus linear time temporal logic 
journal acm 
el emerson lei 
efficient model checking fragments propositional calculus 
proceedings annual symposium logic computer science pages 
ieee computer society press 
eme emerson 
alternative semantics temporal logics 
theoretical computer science 
eme emerson 
temporal modal logic 
van leeuwen editor handbook theoretical computer science volume pages 
elsevier science publishers north holland 
eme emerson 
real time calculus 
de bakker huizing 
de roever rozenberg editors real time theory practice lecture notes computer science pages 
springer verlag 
emss emerson mok sistla srinivasan 
quantitative temporal reasoning 
kurshan clarke editors cav computer aided verification lecture notes computer science pages 
springer verlag 
fr ferrante rackoff 
decision procedure order theory real addition order 
siam journal computing 
hen henzinger 
sooner safer 
information processing letters 
holmer larsen wang 
deciding properties regular real timed processes 
larsen skou editors cav computer aided verification lecture notes computer science pages 
springer verlag 
hmp henzinger manna pnueli 
temporal proof methodologies real time systems 
proceedings th annual symposium principles programming languages pages 
acm press 
koz kozen 
results propositional calculus 
theoretical computer science 
lew lewis 
logic concrete time intervals 
proceedings fifth annual symposium logic computer science pages 
ieee computer society press 
mcm mcmillan 
symbolic model checking approach state explosion problem 
kluwer academic publishers 
nicollin olivero sifakis yovine 
approach description analysis hybrid systems 
grossman nerode ravn rischel editors hybrid systems lecture notes computer science pages 
springerverlag 
ns nicollin sifakis 
overview synthesis timed process algebras 
larsen skou editors cav computer aided verification lecture notes computer science pages 
springer verlag 
nicollin sifakis yovine 
compiling real time specifications extended automata 
ieee transactions software engineering se 
nicollin sifakis yovine 
atp timed graphs hybrid systems 
acta informatica 
qs sifakis 
specification verification concurrent systems cesar 
dezani ciancaglini montanari editors fifth international symposium programming lecture notes computer science pages 
springer verlag 
sif sifakis 
unified approach studying properties transition systems 
theoretical computer science 

