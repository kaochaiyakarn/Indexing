model 
epistemological ambiguity logic programming marc denecker department computer science leuven celestijnenlaan heverlee belgium 
phone fax email cs kuleuven ac september link woods pointed early approaches semantic nets epistemologically ambiguous 
di erent meanings attributed network 
current similar enterprise shows epistemological ambiguity arising context logic programming 
di erent logic programming formalisms semantics proposed 
logic programming seen family formal logics induced pair syntax semantics having di erent declarative reading 
may expect program belongs di erent logics family formal semantics logics declarative meaning attributed program di erent logics equivalent logic family associated distinct declarative readings 
show holds 
investigates causes consequences phenomenon 
critically analyses epistemological foundations extensions pure logic programming abductive logic programming answer set programming stable logic programming 
major roles logic computer science knowledge representation speci cation 
formal logic widely accepted tool par excellence expressing information communication information di erent human experts 
obviously di erent human experts communicate knowledge problem logical speci cations correct communication possible interpret logical formulas way 
assign meaning logical formulas statements world 
way human experts interpret logic formulas formal logic problem world logicians call declarative reading logic 
epistemological study logic aims investigate declarative reading 
aims explaining formulas describe world world looks formula true 
epistemological theory expresses logical statements true logicians call truth conditional semantics 
epistemological study logic programming lp extensions 
main model semantics formalism normal logic programs completion semantics stable semantics founded semantics 
semantics motivated mappings logic programming logics particular classical logic cl default logic dl autoepistemic logic ael 
embedding induces meaning logic program 
compare meanings 
rst example consider program fp qg 
clark completion program classical logic theory comp false denote deductive closure classical logic theory cn 
belief set set believed formulas represented completion cn qg cn pg gelfond proposed interpret program rules formulas kc moore autoepistemic logic 
ael denotes autoepistemic theory obtained applying transformation rules transformation de ne stable semantics shown stable model set atoms autoepistemic expansion ael 
embedding maps autoepistemic theory fp ael autoepistemic expansion corresponds belief set cn fpg marek truszczy nski proposed interpret rule default rule embedding program default logic denoted dl 
authors proved stable models sets believed atoms default extensions dl 
autoepistemic expansion deductively closed set ael formulas 
shown moore set classical logic formulas deductively closed completely determines dl default theory exactly default extension cn fpg authors proposed alternative mapping autoepistemic logic interpreting rule autoepistemic formula kb kc mapping denoted ael proved models completion sets atoms autoepistemic expansions ael 
holds ael ael consequently meaning program belief set cn fpg appears beliefs represented comp hand ael dl ael hand di erent 
particular known completion embeddings 
model semantics logic programs coincide unique model fpg 
unique interpretation satisfying comp set atoms unique extension expansion embeddings 
consider de nite logic program fp qg 
comp theory false unique belief set cn comp cn pg ael ael theory fp qg 
autoepistemic logic extends classical logic sense unique expansion theory formulas modal operator exactly set classical models theory 
consequently ael interprets de nite program horn theory 
unique belief set cn fp qg dl default theory theory unique extension cn fg set tautologies 
autoepistemic theory ael fp unique expansion extending belief set cn fg embeddings assign di erent meanings program unique model completion stable founded semantics fg 
logic programming seen family logics induced pair syntax formal semantics 
logics normal programs completion semantics stable semantics founded semantics partially coincide example case hierarchical programs 
general expect declarative reading underlying semantics equivalent coinciding cases 
expect logic family unique declarative reading 
claimed semantics formalises di erent readings readings equivalent deep sense 
shown examples expectations vain 
logics epistemologically ambiguous 
boils phenomenon 
assume logic program written expert represent knowledge 
assume know formal model semantics intended expert know models program 
unable know knowledge expert world looks expert 
famous case study showing epistemological ambiguity knowledge representation formalism woods study semantic networks 
woods showed link semantic networks interpreted di erent ways 
major drawn ai community hayes defense logic newell knowledge level declarative language needs formal account meaning 
phenomenon ambiguity lp addressed current similar nature ambiguity links pointed woods 
lp ambiguity surprising semantic nets middle seventies arises context logics model semantics 
formal semantics guarantee non ambiguity declarative reading 
main goals threefold goal clarify epistemological foundations lp 
discuss compare di erent declarative readings 
second main goal analyse ambiguity causes ects 
analysis seen case study go wrong epistemological foundations logic clear 
respect aims provide strong argument favour solid epistemological foundations formal logic 
discusses directions resolve ambiguity 
declarative readings lp section starts summary declarative semantics logic programs literature 
di erent approaches classi ed di erent categories de nition interpretation start negation failure inference rule introduced prolog systems realized soundness rule justi ed basis classical logic semantics logic program 
clark proposed interpret logic programs de nitions set rules predicates head represent exhaustive enumeration cases predicates true 
clark formalised intuition mapping logic program completion set completed de nitions 
completed de nition way non recursive de nitions expressed rst order logic 
view logic programs inductive de nitions appealing context prototypical logic programs member 
member member 
append 
append append trans 
trans tr 
programs naturally viewed inductive de nitions 
unfortunately turns clark completion semantics correctly formalise declarative reading de nite programs inductive de nitions 
general weak discussed relation logic programming semantics standard formalisations inductive de nitions 
view de nite logic programs inductive de nitions right formal semantics model semantics 
argued founded semantics formalises generalised principle inductive de nition involving positive monotone recursion negative non monotone recursion 
view logic program represents de nition predicates 
context knowledge representation useful able de ne concepts terms set open predicates 
idea elaborated 
de nition logic de nes set de ned predicates terms set open predicates 
example de nition transitive closure open predicate represented trans trans trans tr contrary standard semantics programming de nition assume de ned theory 
id logic theory consists set classical logic sentences set de nitions 
model semantics id logic integrates classical logic semantics founded semantics model id logic theory model classical logic axioms founded model de nition extending interpretation open predicates 
known inductive de nable concepts concept transitive closure expressed rst order logic 
modal interpretations interpretations discussed 
induced embeddings autoepistemic logic default logic 
consider embeddings ael dl ael embedding ael earliest rst proposed gelfond 
prolog system infers negative literal unable prove gelfond idea interpret literals knowledge theoretic way epistemic literals kp 
idea appealing ts nicely way default reasoning modeled nonmonotonic logic 
mentioned results hold stable models program sets atoms autoepistemic expansions ael 
stable models sets atoms autoepistemic expansions dl 
models comp sets atoms autoepistemic expansions ael 
view natural applications embeddings logic programming induce di erent declarative reading 
simple examples show di erent readings natural applications 
example application de nition view scenario 
expert wants reason life death abraham lincoln 
represents de nition dead terms alive rule dead alive completion program contains rule dead head contains completed de nition dead alive 
expert knows abraham lincoln dead 
explicitly represented completion semantics assumes alive de ned empty de nition false 
belief set expert cn alive 
belief set corresponds completion program modal embeddings 
example natural application modal view scenario husband re ects sucient reason unhappy sure spouse faithful 
assuming knows knowledge represented ael theory theory result applying gelfond embedding program wife formal semantics theory unique autoepistemic expansion extending belief set cn 
corresponds intuition expert know wife faithful unhappy 
consequently program correctly represents expert knowledge modal embeddings equivalent 
completion correctly represent knowledge expert 
example application application modal view logic programs innocent court guilty aims express rule innocent court guilt proven 
ael dl ael rule expresses knowing guilt suspect sucient reason innocent innocent court fact stronger expression holds 
able prove sucient necessary condition innocent innocent court stronger rule expressed logic programming negations innocent court guilty innocent court guilty programs examples identical modulo renaming instances program represent di erent expert 
example shows modal interpretations di erent 
example assume expert wants represent fact knows meeting planned brussels day day brussels 
knows may represent knowledge ael theory fin brussels knows knowledge meeting know brussels day 
knowledge correctly represented cn fg 
theory result applying embedding ael program fin brussels meeting program correctly represents experts knowledge embedding ael embedding dl ael dl equivalent 
hand meaning program expressed completion ael correct representation experts knowledge 
completion meaning theory cn meeting brussels match experts knowledge 
ael meaning cn fin brussels meeting 
expresses meeting brussels expert brussels 
clearly right 
knows meeting brussels 
case obtain di erent readings 
scenarios easily ael give right meaning summarizing observations embeddings logic programming induce di erent declarative meaning formalism 
examples illustrate di erent embedding logic programming natural applications 
respect unique right declarative reading logic programs 
context particular application declarative readings right matches human expert knowledge 
example modal embeddings correctly represent meaning prototypical logic programs representing inductive de nitions member append transitive closure 
di erence views caused purely underlying di erences view logic programming negation de nite programs di erent declarative reading 
formal semantics logic programming fail pinpoint di erences declarative readings 
main lp semantics motivated di erent embeddings declarative readings 
example completion semantics motivated clark interpretation logic programs rst order de nitions autoepistemic embedding ael stable semantics claimed formalise di erent readings expressed ael embedding ael dl embedding dl di ers shown 
founded semantics motivated dl embedding dl baral subramanian founded semantics default logic formalisation declarative reading logic programs inductive de nitions 
ambiguity caused phenomenon similar ambiguity early semantics nets demonstrated woods occurs despite existence formal model theories 
case lp formal model semantics ambiguous respect declarative reading aims formalise 
causes phenomenon investigated section 
ambiguity formal semantics simple explanation possible world semantics versus atom belief set semantics reason ambiguity di erent views model logic program tells world knowledge expert 
model classical logic theory completion program represents possible state world state world theory true 
hand gelfond lifschitz de ne stable model program set atoms autoepistemic expansion ael 
fact modal views lp embedding ael dl model set atoms autoepistemic expansion default extension embedding represents set believed atoms 
sequel set called atom belief set 
atom belief sets possible worlds represented type mathematical structures sets atoms 
di erent views sets totally di erent meaning 
consequently comparing meaning logic program di erent views embeddings naive comparison models comparing apples oranges may utterly misleading note general atom belief set possible world 
example atom belief set fp qg fg model disjunction 
theories obtained embedding logic programs ael dl special sense atom belief set possible world belief set theory 
may contributed confusion lp 
case logic program fp qg unique model fpg means de nition view world known state true false 
modal views just means believed truth believed 
correspondence way ael dl ael interpreted 
di erent ways formalizing declarative reading logic distinguished 
possible world semantics logic aims formalise declarative reading theory formally specifying possible worlds theory 
atom belief set semantics aims formalise reading specifying atom belief sets 
type theories kind mathematical structures principle possible mathematical model semantics possible world formalisation consistent natural declarative reading atom belief set formalisation consistent natural declarative reading 
remarkable phenomenon appears times logic programming models completion program sets believed atoms ael 
founded model program unique possible world interpreted inductive de nition set believed atoms dl founded semantics default logic 
models de nition view lp compared atom belief sets modal view lp comparison possible world semantics ael dl 
moore de ned possible world semantics ael casanova de ned possible world semantics dl 
general collection interpretations possible world model dl ael theory set models default extension autoepistemic expansion 
example unique possible world model theories ael ael dl set cn fpg fp 
set re ects known worlds true false 
worlds true consequently known 
simple algebraic relationship atom belief sets possible world models ael dl atom belief set ael dl theory intersection possible world model theory 
consequently corollary 
corollary stable model logic program possible world model ael dl intersection ambiguity atom belief set semantics ambiguity logic programming partly explained di erent roles models 
recall program fp qg di erent meaning ael dl stable model semantics shown atom belief set semantics embeddings 
reason ambiguity atom belief set gives information meaning theory 
example atom belief set disjunction empty set 
atom belief set non equivalent formulas true di erent formulas atom belief set di erent collections models 
illustrated logic program possible restrict case valued founded models point generalised valued founded models 
world models ael dl general di erent sets intersections possible world models coincide set stable models 
discriminating power possible world collections represent di erent re ned atom belief sets 
simple numerical argument see 
general set propositional symbols possible world sets representing di erent knowledge 
atom belief sets 
consequently ratio number distinguishable epistemic states atom belief set semantics possible world set semantics decreases exponentially fast 
problem imprecision holds answer sets disjunctive logic programming 
answer set consistent set literals representing set believed literals 
consistent sets literals lot possible world sets 
summary summarising ambiguities logic programming explained phenomena fact model theories interpreted possible world formalisations atom belief set formalisations 
lack precision atom belief set semantics capture declarative reading 
semantics inherently ambiguous 
problem appears answer set semantics disjunctive logic programming 
formal model theory speci cation declarative semantics right understand declarative reading formalises role models clear 
principle logics possible world semantics rst order logic alternative declarative readings current model semantics atom belief set formalisation 
alternative readings interesting natural 
case lp turns di erent natural declarative readings formalised model semantics possible world formalisation atomic belief set semantics 
sections methodological philosophical sociological consequences situation 
consequences ambiguity philosophical point view precise understood declarative reading vital logic 
mentioned formal logic play role precise tool expressing knowledge correct communication information di erent human experts experts clear understanding interpret theory logic interprets theories way 
current state art logic ambiguity principle unsuitable speci cation logic 
implications 
di erent interpretations mix investigate happens di erent declarative views program 
assume expert knowledge expressed naturally logic program rule modal view knowledge naturally expressed rules de ning predicate 
add rules program lp reason rules 
explore question scenario 
software consultant loses agenda realizes knowing meeting planned sucient reason missing consultation 
knows paid consultation session 
consultation secretary nds meeting planned 
knowledge represented rule consultation meeting planned interpreted ael get consultation planned expresses knowing planned meeting sucient necessary reason having consultation session 
knowledge represented rule gets payment consultation interpret rule completed de nition expressing paid consultation session takes place gets payment consultation knowledge represented atomic rule meeting planned ael theory correctly represents knowledge consultant consultation planned gets payment consultation meeting planned unique autoepistemic expansion theory corresponds cn payment re ects consultant knows meeting planned know consultation gets payment 
re ects fact sure attend paid 
possible worlds theory planned gets planned consider logic program meeting planned consultation meeting planned gets payment consultation expert may take account potential reasons attending meeting overlap meetings transportation problems 
single rule program true albeit di erent declarative reading obtain program entails erroneous gets payment 
program unique model planned gets 
model interpreted single possible world interpreted atomic belief set erroneously believes gets payment 
cause error straightforward follows di erent roles played models de nition view modal views 
fact atom consultation derived added model second autoepistemic rule merely means consultation believed 
third rule interprets absence consultation model assertion falsity concludes gets payment 
summarizing logic programming rules consistently interpreted di erent ways consequently representing di erent types knowledge expressions 
expert safely exploit multiple interpretations program logic program consisting rules individually correct statements problem domain di erent declarative interpretations may entail erroneous 
poses serious methodological treat lp knowledge representation 
logic programmer may create small modules correctly face unexpected problems merging small modules modules rely di erent declarative readings 
interpreting connections context logic programming impressive network formal relationships di erent semantics logic programs extensions shown 
mention stable model logic program model completion 
stable model de nite logic program model program interpreted horn theory 
hierarchical acyclic programs semantics valued completion valued stable founded semantics coincide 
founded model valued unique stable model 
model completion unique atom belief set ael 
epistemological level mathematical results pointless epistemological role models semantics identical 
comparing possible world semantics belief set semantics naive comparison models totally misleading respect readings formalised semantics 
example epistemological meaning fact stable model model completion 
result tell relation declarative readings underlying stable completion semantics ael dl comp 
tempted conclude ael stronger comp expresses stronger knowledge comp 
fact cases inverse true 
example recall belief set cn comp cn pg strict superset belief set cn fpg ael dl 
general simple relationship belief set cn comp belief sets ael dl 
consequently mathematical relationship completion stable semantics tells little relationship interpretation program set clark rst order de nitions theory ael 
epistemological level relation little mathematical 
example investigate epistemological meaning fact stable semantics coincides herbrand semantics de nite logic programs 
herbrand model de nite logic program unique possible world interpret program inductive de nition 
set believed atoms interpret default theory dl ael theory ael 
conclude dl ael equivalent interpretation inductive de nition absurd 
note way ael classical logic horn theory set believed atoms interpreted horn theory model course conclude reading horn theory equivalent reading inductive de nition 
epistemological level main problems semantic studies logic programming clear declarative reading semantics aims formalise formalises 
role models semantics clearly articulated 
studies logic programming semantics including papers de ning stable founded semantics examples shown models seen possible worlds examples models seen atom belief sets 
example introducing stable semantics gelfond lifschitz prove stable model atom belief set semantics ael time show stable model de nite program model program 
conclude stable semantics assigns right meaning transitive closure program tr tr tr tr tr unique stable model tr program tr tr transitive closure tr 
misleading may conclude ael dl correctly formalises meaning tr inductive de nition transitive closure 
ael tr horn theory merely expresses tr transitive relation including similar point dl 
stable model unique model de nite logic program interpreted inductive de nition 
knowledge proposed declarative reading logic programs satis es properties extends view de nite logic programs inductive de nitions case logic programs negation 
stable semantics possible world formalisation declarative reading 
consequently know interpret logic programming stable semantics way extends interpretation de nite programs inductive de nitions 
mathematical result inductive de nitions encoded correctly de nite logic programs stable semantics models interpreted possible worlds 
pointed section including inductive de nitions transitive closure rules expressing autoepistemic rules default rules program may lead general representation errors 
nature naf important issue study logic programming semantics epistemological nature negation failure 
modal interpretations logic programming interpret negation failure literals modal literals known proven consistently believed 
de nitional interpretations logic programming negation failure represents classical negation 
certainly case clark reading logic programs rst order logic de nitions 
clark completion maps negation failure literals classical negation 
rest section aims show case reading logic programs inductive de nitions 
argument context de nitions open predicates illustration consider de nition expressing dead means alive alive open 
rst order logic expressed dead alive 
id logic represented dead dead dead alive collection possible world models dead note dead model 
proposition aims show general set rules representing open de nition model sensible way negative literals body rules interpreted modal literals ael dl 
model id logic de nition open predicates de ned interpretation obtained extending arbitrary interpretation open symbols founded model technical details relevant purposes 
refer information 
interpretation open predicates freely chosen general open de nition including negation minimal model 
consider mapping maps sets rules ael dl satis es condition mapping dl default horn rule equivalent 
mapping ael ael formula substitute top level modal literals obtain horn rule formula equivalent horn rule 
de nition de nes predicates modal negation classical negation coincide 
predicates de ned possible world model 
consequently false atoms unique model exactly atoms believed 
restriction aims express condition negative literals body rule mapped classical negation literals modal literals 
proposition de nition open predicates set models wd model 
embedding satisfying condition wd possible world model 
proof lemmas give necessary condition possible world models ael dl theories 
proofs lemmas omitted 
lemma ael theory possible world set 
de ne tw classic non modal logic theory obtained substituting top level modal literals truth value possible world model class models tw weaker lemma holds dl lemma dl theory possible world set 
de ne tw set formulas default gn exists possible world model collection models classical logic theory tw proof proposition 
possible world model embedding lemmas set models tw tw classical logic theory equivalent horn theory model contains model wd model 
stated section autoepistemic theory default theory represents expert knowledge set beliefs expert expansion extension theory 
equivalently set possible worlds expert possible world model theory 
consequently proposition shows embedding correct representation knowledge theoretic analysis alp abductive logic programming alp de ned extension logic programming performing abductive reasoning 
kakas kowalski toni de ne abductive logic framework triple ha set predicates called abducible predicates logic program non abducibles head set fol formulas called constraints 
abductive solution abductive query pair answer substitution set ground abducible atoms 


consistent logic program 

de nition parametric semantics lp semantics de nes entailment relation notion consistent program abductive solution 
discusses variants de nition abduction constraints di erent role consistency view meta level view constraints 
concern section epistemological foundation alp declarative reading alp 
obvious problem alp language de nition gives clue answer 
explained de nition de nes formal correctness criterion abductive reasoning 
intended answer questions declarative reading alp extend lp 
meaning fol constraints 
interpret negation symbol program rules fol constraints negation symbol meaning appears fol constraints rules 
standard way extend formal model semantics logic programming case alp 
model abductive logic framework de ned interpretation set 
ground abducible atoms exists model logic program 
de nition parametric choice logic programming semantics 
main logic programming semantics extended way generalised completion generalised stable generalised founded semantics 
epistemological level obvious problem semantics inherit ambiguities epistemological confusion logic programming 
example generalised completion semantics de ned models abductive program represent possible worlds negation interpreted classical negation 
hand generalised stable semantics de ned models inherit interpretation atom belief sets stable semantics negation interpreted modal operator 
classical embeddings lp ael dl simply extended alp frameworks 
problem alp blurred relationship classical logic 
alp framework may contain arbitrary fol theory mean alp extension classical logic 
dicult explain 
alp de ned study abductive reasoning fol considered study deductive reasoning 
rst extension second 
question relationship alp fol blurred di erent roles views attributed constraints 
fair say point epistemological status alp confused lp 
natural solution 
alp framework interpreted theory consisting classical logic axioms constraints open inductive de nition non abducible predicates terms open abducible predicates 
embedding alp id logic expresses idea 
re nes earlier means true interpretation standard sense 
open logic programming view alp logic logic rst order assertions rst order de nitions expressed completion semantics 
embedding provides solid knowledge theoretic foundation alp logic 
view area alp involved study abductive inference sub logic id logic 
knowledge theoretic analysis asp answer set programming computational logic paradigm expert encodes problem disjunctive logic program classical negation negation failure answer sets represent solutions problem 
stable logic programming experts encode problem logic program stable models represent solutions 
implementation ecient stable model generator smodels allowed number promising computational experiments paradigms 
answer set programs easily transformed logic programs classical negation 
discussion focuses stable logic programming 
paradigm logic programming standardly viewed sub logic default logic autoepistemic logic 
correct view 
believe answer depends problem solved problem nd set believed atoms literals human expert view correct 
problem nd possible state world human expert correct 
stable model program represents possible state world expert knowledge wp set stable models possible world collection formalizing experts knowledge th wp set beliefs expert problem world 
interpreted ael dl theory representing expert knowledge premise stated section extension expansion representing expert believes coinciding th wp 
wp possible world model ael dl theory 
theorem shows impossible weak circumstances 
theorem embedding logic programming dl ael stable models logic program atom belief sets 
ael dl embeddings 
collection wp stable models logic program element wp possible world model 
proof assume collection wp stable models possible world collection 
case atom belief set wp stable model 
contradiction stable models minimal models logic program 
practical consequence theorem stable models program represent possible states world embedding program dl ael satisfying condition theorem may entail false formulas th wp may entail formulas th wp 
means applying sound complete ael dl theorem prover unsound incomplete reasoning expert knowledge 
illustrate dead alive example 
consider logic program dead alive alive dead stable models theory fdeadg 
correct stable logic programming implementation open de nition dead 
embeddings ael dl ael logically equivalent 
example embedding ael reads dead alive argued section formulas correct true sucient condition somebody dead unknown alive 
formula erroneous reason 
formula intuitively entailed de nition exclusive disjunction dead alive 
formula element th dead 
hand formula credulously entailed ael theory contained expansions theory 
ael theorem prover prove 
formula entailed belongs autoepistemic expansions 
expresses expert knows person alive knows dead 
formula obviously intuitively entailed belong set believed ael formulas 
mentioned ael dl view logic programming natural views lp natural applications 
far applications stable logic programming modal view inappropriate 
stable models encode possible states world atom belief sets 
stable logic programs solving graph problems computing hamiltonian paths kernels graph 
stable model represents di erent hamiltonian path respectively kernel 
stable logic programs answer set programs solve planning problems 
context planning problem logic program describes ects actions preconditions actions initial state goal state 
stable models represent plan sequence actions transforms initial state goal state 
experiments stable models represent possible states world human expert incomplete knowledge world 
context hamiltonian path program represents knowledge human knows graph properties hamiltonian path know concrete path satisfying properties 
likewise planning problems program encodes knowledge human expert knows initial nal states knows properties actions occur know plan 
alternative epistemology problem default ael view stable logic programs explain stable models belief sets practice represent possible worlds 
raises question possible nd alternative epistemology stable semantics 
question boils nd alternative declarative reading logic programming stable models arguably possible worlds declarative reading 
conjecture virtually applications asp stable logic programming described literature stable logic programs representations de nitions classical logic axioms seen compiled id logic theories 
observed standard methodology encode stable logic program produces programs rules form rules constitute core program 
describe knowledge de ning predicates head 
rules encode constraints solutions 
constraint represented rst order axiom encoded adding rule simplifying normal form standard transformation method lloyd topor 
new predicate symbol representing false 
rules encode open predicates 
predicates expert incomplete knowledge appear head rules 
open predicate new predicate introduced rules methodology seen easily way encoding id logic theory stable logic program 
sketch compilation works 
idea taken satoh iwayama transformation abductive logic programming pure lp 
context id logic theory 
id logic theory consisting set rst order axioms de nition de ning set predicates terms open predicates set rules transformed logic program keep set rules simplify applying lloyd topor transformation necessary transform fol axioms rules simplify necessary 
open predicates introduce new predicate symbol representing negation add rules resemblance transformation stable logic programming methodology evident 
summary stable logic programs default theories autoepistemic theories stable models encode atom belief sets human expert 
consider practical applications literature stable models systematically represent possible states problem world 
cases human expert beliefs world represented th wp wp set stable models 
shown theorem modal view assigns right declarative reading programs 
practical implication applying ael dl theorem prover unsound incomplete may fail prove expected beliefs th wp may prove counterintuitive properties th wp 
argued applications stable logic programs encode de nitions open predicates rst order axioms 
respect stable logic programming abductive logic programming tightly connected represent de nitions open predicates rst order axioms 
computational level paradigms tightly related solve similar kinds problems 
point areas develop di erent technologies solve problems 
shown technologies may er complementary advantages contributions computation 
synergy areas possible 
believe long run areas merge 
sociological ects unavoidably intuitive understanding logic governs way people implement applications develop semantics propose language extensions 
logic programming di erent declarative views articulated 
fact di erent people di erent intuitive interpretations aware caused serious confusion 
ambiguity caused methodological problems tried exploit di erent declarative readings simultaneously 
early days logic programming hoped semantical study logic programming bring clarity declarative meaning logic programs disappointed 
interpreted multiple formal relations embeddings logic programming logics proof exibility formalism knowledge representation 
ignored formal results re ect deep ambiguity language ignored practical fundamental problems ambiguity poses respect methodology status role logic programming context logic knowledge representation 
aim logic programming de ne computational logic combines advantages declarative logic procedural languages 
de nition declarative logic aims describing world contrast procedural languages aim describe procedures solve problems world 
big question extend logic programming er advantages declarative logic confusion declarative reading 
opinion ambiguity confusion caused created di image means program declarative means program declaratively advantages er 
terms terminology content 
believe logic programming ambiguity confusion involves causes fact logic programming lost unity 
application implementation oriented domains procedural interpretation de facto interpretation 
lp knowledge representation community split abductive logic programming disjunctive logic programming areas led di erent views logic programming 
confusion respect logic programming semantics major cause fact outside logic programming community logic programming seen useful tool implementation widely accepted knowledge representation language 
directions solution di erent views logic programming appeal believe inductive de nition view promising explore view applications knowledge representation 
view ts nicely natural interpretation prototypical prolog programs member append delete permute 
argued section applications logic programs stable semantics programs implement default theories combination de nitions open predicates classical logic assertions 
opinion logic programming fundamental original contribution logical study inductive de nitions particular understanding de nitions monotone induction 
point wellfounded semantics compared formalisations induction iterated inductive de nitions xpoint principle 
argued notion generalised inductive de nitions combined classical logic play important role context knowledge representation common sense reasoning ai 
respect modal views logic programming current answer set semantics inadequate give precise account declarative reading disjunctive logic programming 
problem solved de ning precise possible world semantics 
possible way proposing canonical embedding formalism default logic autoepistemic logic 
consider true challenge posed ambiguity integrated logic reasoning inductive de nitions default autoepistemic reasoning 
logic obtained extending id logic autoepistemic belief operator equivalently logic obtained extending autoepistemic default logic inductive de nitions 
extended logic allow safely represent modal de nitional kind knowledge theory 
kind logic de nition innocence represented de nition innocent innocent bene tted discussions maurice bruynooghe danny michael gelfond vladimir lifschitz victor marek truszczynski van 
aczel 
inductive de nitions 
barwise editor handbook mathematical logic pages 
north holland publishing 
baral subrahmanian 
duality alternative semantics logic programs nonmonotonic formalisms 
nerode marek subrahmanian editors intl 
workshop logic programming nonmonotonic reasoning pages washington dc 
mit press 
clark 
negation failure 
gallaire minker editors logic databases pages 
plenum press 
console torasso 
relationship abduction deduction 
journal logic computation 
denecker 
terminological interpretation abductive logic programming 
marek nerode truszczynski editors international conference logic programming nonmonotonic reasoning lecture notes arti cial intelligence pages 
springer 
denecker de schreye 
justi cation semantics unifying framework semantics logic programs 
proc 
logic programming nonmonotonic reasoning workshop pages 
mit press 
denecker de schreye 
representing incomplete knowledge abductive logic programming 
journal logic computation september 
denecker victor marek law truszczy nski 
uniform semantic treatment default autoepistemic logics 
cohn giunchiglia selman editors th int 
conference principles knowledge representation reasoning kr pages breckenridge april 
morgan kaufman 
marc denecker 
founded semantics principle inductive de nition 
dix nas del cerro furbach editors logics arti cial intelligence pages schloss october 
springer verlag lecture notes arti cial intelligence 
marc denecker 
extending classical logic inductive de nitions 
baral truszczynski editors th intl 
workshop non monotonic reasoning nmr pages colorado usa april 
marc denecker 
extending classical logic inductive de nitions 
lloyd editor international conference computational logic cl volume lecture notes arti cial intelligence pages london july 
springer 
gelfond 
strati ed autoepistemic theories 
proc 
aaai pages 
morgan kaufman 
gelfond lifschitz 
stable model semantics logic programming 
proc 
international joint conference symposium logic programming pages 
ieee 
casanova 
alternative semantics default logic 
th international workshop nonmonotonic reasoning south lake tahoe 
hayes 
defense logic 
proc 
th ijcai 
kakas kowalski toni 
abductive logic programming 
journal logic computation 
kakas mancarella 
generalised stable models semantics abduction 
proc 
european conference arti cial intelligence 
john wiley sons 
konolige 
relation default autoepistemic logic 
arti cial intelligence 
lifschitz 
answer set planning 
proceedings iclp pages 
lloyd 
foundations logic programming 
springer verlag 
lloyd topor 
making prolog expressive 
journal logic programming 
marek 
nonmonotonic reasoning advances questions directions 
invited talk workshop non monotonic reasoning nmr 
marek truszczy nski 
stable semantics logic programs default reasoning 
overbeek editors proc 
north american conference logic programming non monotonic reasoning pages 
marek truszczy nski 
re exive autoepistemic logic programming 
pereira nerode editors proc 
logic programming nonmonotonic reasoning workshop pages 
marek truszczy nski 
stable models alternative logic programming paradigm 
apt marek truszczynski warren editors logic programming paradigm years perspective pages pp 

springerverlag 
moore 
semantical considerations non monotonic logic 
proc 
ijcai pages 
moore 
possible world semantics autoepistemic logic 
non monotonic reasoning workshop pages 
moore 
logic representation volume csli lecture notes 
csli publications center study language information standford california 
moschovakis 
elementary induction structures 
north holland publishing amsterdam new york 
newell 
knowledge level 
arti cal intelligence 
presidential aaai 
niemel logic programs stable model semantics constraint programming paradigm 
annals mathematics arti cial intelligence 
emmanuel de mot marc denecker 
logic programming approaches representing solving constraint satisfaction problems comparison 
proceedings lpar th international conference logic programming automated reasoning 
accepted 
pereira alferes 
hypothetical reasoning founded semantics 
editor proc 
th scandinavian conference ai 
ios press 
founded semantics abductive logic programming 
reiter 
logic default reasoning 
arti cial intelligence 
satoh iwayama 
computing abduction tms 
proc 
international conference logic programming page 
van emden kowalski 
semantics predicate logic programming language 
journal acm 
van gelder ross schlipf 
founded semantics general logic programs 
journal acm 
woods 
link foundations semantic networks 
bobrow collins editors representation understanding studies cognitive science 
academic press new york 
brachman levesque readings knowledge representation morgan kaufman 
syntax semantics reading dl ael purpose suces consider nite propositional theories programs 
default logic dl introduced reiter known non monotonic logics 
default logic theory consists set classical logic formulas set default rules form classical logic formulas 
calls prerequisite justi cation consequent default 
intuitive meaning entailed entailed true 
semantics dl theory 
characterized terms belief sets 
belief set deductively closed set classical logic formulas satis es cn js reiter de nes default extension dl theory 
belief set satis es condition 
ds default 
set classical logic axioms 
default extension 
solution equation cn ds proven equation solution 
solution coincides default extension 
general default theory may di erent default extensions 
represents consistent view knowledge represented theory 
moore proposed autoepistemic logic ael extension classical logic belief operator takes arbitrary formulas argument 
moore de ned ael logic represent knowledge agent perfect introspection 
operator refers knowledge agent 
autoepistemic theory interpreted description agents knowledge 
example theory fp represents knowledge agent knows know true 
theory contains information kq true implied 
moore characterized formal semantics autoepistemic logic theory terms subclass stable autoepistemic theories 
stable autoepistemic theory represents knowledge ideally rational expert perfect introspection 
formally de ned set ael formulas satis es condition interpreting modal literals formulas propositional constants closed tautological consequence cn 
kf kf rst rule models fact agent ideally rational knows inferred 
second third rule models fact agent perfect introspection 
stable autoepistemic theory set satisfying equation cn js fg kf js fg semantics ael theory representing knowledge agent characterized subclass stable autoepistemic theories called autoepistemic expansions 
moore de nes autoepistemic expansion ael theory solution equation cn js fg kf js fg ael expansion candidate set representing beliefs agent 
ael extends propositional calculus 
propositional theory ael theory unique expansion collection models default logic autoepistemic logic designed model similar forms human knowledge 
soon clear logics strongly related 
konolige investigated embedding default logic autoepistemic logic default mapped ael rule konolige showed default extension default theory corresponds set classical logic formulas autoepistemic expansion ael translation 
general inverse true 
example default default extension cn fg ael embedding kp autoepistemic expansions extends cn fg extends cn fpg 
default theories prerequisite free defaults absent translation appears accurate logic programs mapped classical logic default logic autoepistemic theories 
goal compare meaning theories formal basis 
problem types logics formalise meaning theory terms di erent sorts mathematical structures specifying models case classical logic belief sets case dl stable autoepistemic theories case ael 
easy see relationships types structures 
model classical logic theory mathematical structure representing state world axioms true state world possible collection models describes possible states world sequel set interpretations aims describe possible states world theory human expert called possible world collection denoted strong correspondence possible world collections belief sets stable autoepistemic theories 
possible world collection naturally corresponds belief set th ff fg vice versa belief set corresponds naturally possible world collection models fm jm sg 
case nite propositional alphabets correspondence 
respect stable autoepistemic theories moore showed belief set extended unique way stable autoepistemic theory 
vice versa set classical formulas stable autoepistemic theory obviously belief set 
possible world collection corresponds unique belief set th unique stable autoepistemic theory 
de ned directly truth function 
possible world collection interpretation de ne hw truth function de ned normal truth recursion classical logic augmented rule modal literals hw kf hw characterized set ael formulas hw obvious de nition classical logic formulas exactly th 
light strong correspondences possible world sets autoepistemic belief sets surprising semantics dl ael characterized possible world sets 
moore de ned possible world semantics ael casanova de ned possible world semantics dl 
concepts illustrated context simple examples 
theories kp moore semantics weak accepts counterintuitive expansion known 
stronger semantics ael de ned accept expansion konolige embedding dl ael equivalence preserving 
example consider dl theory default extension closure classical axioms default theory subset consequents defaults 
case possible default extensions cn fg cn fpg 
easily veri es second set default extension 
unique possible world model models fpg fp 
unique possible world model autoepistemic theory kq pg obtained applying konolige embedding 
example consider dl theory verify default extension cn fg 
unique possible world set interpretations 
unique possible world model ael translation pg 

