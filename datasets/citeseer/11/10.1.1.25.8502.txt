array ssa form parallelization kathleen knobe vivek sarkar digital cambridge research laboratory mit laboratory computer science kendall square building technology square ne cambridge ma cambridge ma email knobe crl dec com email vivek lcs mit edu static single assignment ssa form scalars significant advance 
simplified way think scalar variables 
simplified design optimizations optimizations effective 
unfortunately said ssa form arrays 
current ssa processing arrays views array single object 
kinds analyses sophisticated compilers need perform arrays example drive loop parallelization element level 
current scalar ssa form provide element level data flow information required analyses 
introduce array ssa form captures precise element level data flow information array variables 
general simple coincides scalar ssa form applied scalar variables 
array ssa form provides renaming array variables uses oe function identify defining assignment array element 
combination array renaming ability specify element level merges distinct definitions array ssa form significantly increases potential code optimization 
discusses application array ssa form automatic parallelization 
parallelization techniques array ssa form exploit possibility computing oe functions runtime addition analyzing array indices compile time uncover general forms loop level region level parallelism past techniques 
static single assignment ssa form scalar variables significant advance 
simplified design optimizations optimizations effective 
earliest applications ssa form design new algorithms global constant propagation global value numbering 
popularity ssa form efficient algorithm computing ssa form available 
ssa form standard representation modern optimizing compilers industry academia 
appear proceedings th acm symposium principles programming languages popl january san diego california 
note preprint contains typographical corrections conference version 
see appendix list changes 
salient properties ssa form follows 
definition assigned unique name 

certain points program new names generated combine results definitions 

refers exactly name generated rules 
scalar case combining rule oe function determines values flow path traversed 
example ssa form converts code 
combining function oe depends path taken statement 
notice path unknown runtime may vary dynamic execution code 
code consider dealing arrays similar way recognizing special case elements written branch branch 
combining oe function chooses second definition array depending path taken runtime 
situation complicated nesting condition loop reversed 
combining oe function example merge definitions element element basis value conditional array booleans 
complication arises arrays assignment array element necessarily kill previous assignment array variable 
problem arises pointers aliases 
analysis required generate useful ssa form array variables complex scalar variables 
introduce array ssa form captures precise element level data flow information array variables cases 
general simple coincides standard ssa form applied scalar variables 
structures variable types modeled arrays 
rules standard ssa form apply array ssa form 
combining array ssa form powerful oe function merge values distinct definitions element element basis 
understand difference standard ssa array ssa forms consider loop running example rest 
element loop may refer initial value value defined inside loop 
control flow scalar definitions oe traditional scalar ssa trivial array ssa problem trivial array ssa problem fx initialized endif enddo loop conditional indirection subscript expression permutation value element may written times static assignment 
oe functions array ssa form capable handling complexity effectively 
potential uses array ssa form compiler analysis optimization uniprocessor multiprocessor systems 
focus application array ssa form area automatic parallelization 
general parallel execution program may inhibited variety control data dependences 
dependences true data flow dependences broken 
transformations proposed past break kinds data dependences anti output renaming privatization break control dependences conversion speculation 
show renaming oe functions array ssa form enhance automatic parallelization breaking anti output dependences control dependences general ways done past array variables 
specifically show array ssa form enable parallelization loop free loop carried true data dependences 
includes loops loop carried anti output dependences subscript expressions arbitrary control flow iteration loop 
performance measurements parallelization computer graphics rasterization application technique 
show array ssa form enable speculative execution parallelize loops loop carried true data dependences cycles contain control dependences 
show array ssa form break loop independent output anti data dependences enable parallel execution distinct regions program 
rest organized follows 
section introduces array ssa form discusses placement semantics optimization oe functions array ssa form 
section shows different ways array ssa form parallelization 
section discusses related section contains indicates possible directions 
array ssa form section addresses issue oe function placement array ssa form section discusses semantics oe functions oe functions implemented runtime desired 
section outlines optimizations performed functions oe functions 
oe function placement section addresses question place oe functions array ssa form 
scalar ssa key requirement oe placement enable refer single name 
initial placement extension oe placement scalar ssa choice fundamental subsequent optimization oe nodes addressed section may result different semantically equivalent placement oe functions 
initial placement oe functions follows rules 
define oe oe function inserted immediately definition array variable completely kill array value 
define oe merges values element modified definition values available immediately prior definition 
define oe need inserted definitions scalar variables definition completely kills old value variable need merge modified elements unmodified elements 
example consider def assume def renamed 
def variable reaches point just prior def oe function oe inserted immediately def represent element element merge subsequent variable intervening def simply refer 

merge oe oe function inserted exactly locations scalar ssa inserted oe function dominance frontier 
scalar ssa purpose merge oe function merge values computed distinct control paths 
way think oe functions simply identity assignment form called 
assignment semantically void conversion ssa lhs newly generated name 
rhs combines elements names generated source array listed arguments oe 
scalar ssa oe unique name source definition unique name source simply point renamed newly generated names 
example see placement define oe merge oe functions convert code loop array ssa form shown 
algorithm computing initial array ssa form program uses oe placement algorithm scalar ssa form determine placement merge oe functions 
addition define oe functions inserted described 
details placement algorithm array ssa form omitted sake brevity 
important property numbers assigned definitions array ssa form topologically sorted exists forward path path include back edge control flow graph def def require topological numbering simplifies discussion oe function semantics section 
oe function semantics implementation know oe functions placed array ssa form section addresses semantics implementation 
uses array ssa static analysis oe functions manifest runtime incur runtime overhead 
cases semantics relevant 
implementation oe functions relevant array ssa form way requires runtime evaluation oe functions parallelization examples section 
describe semantics oe functions array ssa form appear introducing lot runtime overhead 
section presents optimizations oe functions reduce overhead 
experimental results section initializing definition oe oe oe oe array ssa form loop array elements initial value 





oe max oe max oe max oe max insertion computation gamma gamma semantics oe functions loop provide evidence remaining overhead significant rasterization application high level structure similar loop define semantics oe functions introduce concept array 
static definition xk array xk identifies time element xk modified definition 
initial value array element xk indicates element modified static definition acyclic control flow graph static definition xk may execute zero times time 
cases simply encoded xk 
xk 
element 
control flow graph cycles loops static definition xk may execute arbitrary number times 
need detailed information xk 
case distinguish different dynamic execution instances static definition xk specifically xk contains iteration vector element modified static definition xk iteration vector static definition xk single point iteration space set loops enclose definition 
number loops enclose definition 
single point iteration space specified iteration vector tuple iteration numbers enclosing loop 
construction array ssa form require surrounding loops structured counted loops fortran loops surrounding loops tightly nested 
assumption loops single entry equivalently control flow graph reducible 
single entry loops know def executes iteration surrounding loops 
structured loops single entry contain multiple exits unstructured loops built goto statements real programs single entry 
multiple entry loop transformed multiple loops node splitting 
values array elements computed follows 
assume array elements xk value start program execution 
real non oe definition xk assume statement form xk inserted immediately def arbitrary subscript value current iteration vector loops surround xk 
oe definition associated array 
shows result inserting array computations obtain complete array ssa form loop consider array static definition 
recall known subscript function need monotonic need permutation 
setting correctly records iteration static definition assigned value element 
notice computation accurate permutation may overwritten subsequent iterations final value indicates iteration number modification 
accurate presence conditional updated exactly definition occurred 
leads notion dynamic definitions 
array element may defined multiple times execution program 
called dynamic definition element 
dynamic definition element specified ffl specific static definition ffl point iteration space definition 
consider dynamic definition element 
non oe static definitions initialization outside loop assigning indirection vector loop 
defined element initialization defined element iterations 
dynamic definitions 
case set set iterations final value 
array element execution point program dynamic definition executed visible 
dynamic definitions executed earlier occluded subsequent ones 
element visible dynamic definition time 
role oe function identify visible dynamic definition individual element array array 
semantics oe functions specified naturally conditional expressions 
example define oe function oe represents element merge array values recall oe function analog scalar ssa form 
conditional expression oe function defined follows notation denotes value dynamic definition definition xk iteration loop represents lexicographic relationship iteration vectors array element values 
conditional expression dictates value array element comes depending element computed 
selection controlled value array elements conditional expression sets conditional expression sets 
case conditional expression sets static definition selected definitions iteration vector topological numbering property array ssa form guarantees definition largest number 
arrays oe function definition oe pure function includes arrays arguments oe conciseness omit writing arrays explicit arguments just write oe 
note scalar ssa oe function oe pure function depends implicit information analogous variables identifies control path taken 
notice array oe def xk oe xh xh computed xk max xh xh 
element oe function selects result input xh value largest xh value 
analogous define oe value merge oe oe expressed conditional expression element follows semantics oe functions scalar ssa form conditional expression built branch conditions array ssa form arrays capture merging elements due branch conditions merging elements assigned different iterations 
shows conditional expressions oe functions 
consider computation merge oe value conditional expression 
takes value static assignments shared loops larger topological number forward path 
array ssa form far defined array variables special case scalar variables 
array ssa form easily constructed structure variables structure viewed array 
read write operation structure element viewed read write operation array element subscript compile time constant 
operations read write multiple elements structure structure copy modeled read write operations sets structure elements 
oe function array ssa form merge distinct fields modified distinct parts code exactly merges distinct elements array variables 
fact array ssa form structure variables simpler representation general arrays element accesses resolved compile time 
technique directly extends construction array ssa form nested arrays structures 
example array rank structures modeled array rank 
concluding section observe array ssa form enables new optimization element level dead code elimination 
notice code example may compute instances right hand side assignment loop 
loop side effects need computed 
simply suppress assignment rhs loop 
oe loop tells exactly computations needed 
determine element computed iteration execute rhs finalization loop computing rhs iteration execution loop 
notice classical dead code elimination typically eliminates static instances code 
statically code required eliminated execution dynamically elements 
optimization oe functions arrays section outline arrays oe functions optimized reduce runtime overhead cases functions manifest output code 
observation unoptimized array ssa form distinct array created real non oe definition array variable 
assignments conditions assignment occurs completely analyzable compile time 
cases storage computation arrays needed 
example assignment loop imin imax needs array 
oe function needs test 
substitute test imin imax 
addition show arrays oe functions analyzed optimized just variables instructions statements compiler intermediate language 
conditional expression semantics oe functions gives useful properties show oe functions associative 
traditional optimizations copy propagation loop invariant code motion common subexpression elimination elimination partial redundancies dead store elimination eliminate reposition computations arrays oe functions 
illustrate showing code structure naive placement oe computations transformed obtain optimized code structure 
consider array ssa form arrays shown 
goal remove computation arrays oe functions possible 
step copy propagate def uses def uses obtain code structure shown 
max associative function nested max expression max max rewritten simply max 
prove oe functions associative composing oe functions equivalent nesting conditional expressions 
example show oe oe oe oe noting oe oe oe oe result nested conditional expression examples conditional expressions oe functions seen gamma gamma oe associative oe shorthand oe oe example 
continue copy propagate defs obtain code structure shown uses flattened representations max functions oe functions 
easy see max simplified max 
relation defining conditional expressions oe functions simplify oe oe 
simplified max computation forms recurrence follows max gamma 
note value array monotonically nondecreasing function gamma element iteration assuming represents initial value 
recurrence solved obtain max 
similarly conditional expression simplified oe definition oe really recurrence defines function gamma follows gamma gamma gamma observing monotonically nondecreasing function leads solution simplicity show copy propagation implicit uses oe functions take input 
oe oe max max oe oe max max oe max transformation copy propagation oe max oe max transformation copy propagation oe max transformation solving recurrences copy propagation loop recurrence oe recursive oe definition oe gamma equivalent non recursive oe definition oe assuming contain values written iterations loop 
non recursive definitions observe inside loop final values propagated outside loop obtain oe oe max max simplified oe max resulting optimized code structure shown 
oe definition includes final values computed loop refer oe function finalization oe 
note code structure efficient oe function computations inside loop 
note loop contains array computation unavoidable example single real def array variable contains subscript expression 
see section overhead computation example small significant performance impediment 
overhead array computations significant loop contains multiple defs real def accompanied array computation 
conclude section briefly mentioning optimizations reduce computation storage overhead maintaining arrays 
consider loop insertion array computations 
assume control flow loop 
enddo discussion focused array computations show oe function details loop 
allow arbitrary function 
consider derive array values array values 
assume function known unique inverse 
max fij jg max gamma fij gamma delta gamma avoid computing array identity gamma look value gamma falls outside range array just set 
includes case gamma integer 
example 
means 
odd values reflects fact element array set assignment statement 
fact iteration modifies element captured examining set 
extra overhead looking lies computing gamma optimization best suited cases gamma simple function constant theta constant note making gamma simple function place constraint function 
reuse array valid assignments identically control dependent 
consider derive array values array values 
additional assumption monotonically increasing function 
max fij jg max gamma fg gamma gamma jg delta gamma avoid computing array identity gamma look value optimizations eliminating array computation quite general nature easily catch common cases sigma constant 
example just array defs 
shown optimization techniques reduce potential overhead oe computations 
include compile time analysis arrays classical optimizations copy propagation applied single function distinct assignments 
array ssa form automatic parallelization mentioned earlier potential uses array ssa form compiler analysis optimization 
section focus application array ssa form area automatic parallelization 
possible uses array ssa form mentioned briefly section subjects 
due renaming array variables ability compute arrays oe functions runtime array ssa form enables parallelization wider range loops past techniques 
discussion assume parallelization enhancing transformations loop distribution performed pre pass loop carried true data dependence inhibits parallelization belongs cycle data dependences 
serial execution fundamentally necessary cycle true data dependences value iteration computed value previous iteration statements distributed separate loops 
programs rely serial execution reasons 
array element may modified multiple iterations dependence cycle containing output dependence serial execution ensures correct final values visible loop terminates 
array element computed iteration determine direction conditional branch subsequent iteration may modify element array dependence cycle containing loop carried true data dependence loop independent control dependence serial execution ensures correct final values visible loop terminates 
oe function array ssa form alternative way ensuring correct values visible ensuring correct values visible loop termination requiring serial execution 
rest section organized follows 
section describes new loop parallelization technique array ssa form enable parallelization loop free loop carried true data dependences 
includes loops loop carried anti output dependences subscript expressions arbitrary control flow iteration 
section shows array ssa form enable speculative execution parallelize loops loop carried true data dependences cycles contain control dependences 
section shows array ssa form break loop independent output anti data dependences enable parallel execution distinct regions program 
parallelization loop iterations section show array ssa form parallelize loops containing loop carried anti output data dependences loop carried true data dependences 
parallelization technique works loops containing arbitrary array subscript expressions general scope loop parallelization techniques proposed past array data flow analysis array privatization loops containing affine array subscript expressions 
illustrate loop parallelization array ssa form running example previous section loop 
loop contains conditional write array element arbitrary subscript expression may depend program input 
subscript expression may may map element distinct iterations best knowledge loop parallelized compiler today amenable speculative parallel execution combined renaming software approach described building hardware approaches described 
contrast loop parallelization transformation described section speculative renaming arrays inserting oe function computations compiler knows compile time loop safely executed parallel run time 
rest section organized follows 
section describes parallelization loop follows directly optimized array ssa form 
parallelization reveals potential parallelism loop paying attention overhead issues real machines 
section describes concrete parallelization loop small scale multiprocessor 
concrete parallelization directs parallelism obtain efficient code machine 
parallelization parallelization reveals potential parallelism program specific computation mapping data distribution 
goal transform stylized serial code produced array ssa analysis parallel form 
code dependences prevent parallel execution output dependence distinct assignments output dependence distinct assignments due fact may result multiple modifications location 
enable assignments execute parallel expand iteration axis adding dimension extent range 
expansion permits distinct iterations loop concurrently write 
loop executed parallel 
computation oe function oe outside loop needs transformed expanded arrays 
semantics oe functions introduced section conditional expression finalization oe function oe array expansion expressed general computation finalization oe function array expansion inputs needs performed steps 
single assignment reduction performed static assignment 
multi assignment reduction performed combine results reductions array variable 
consider single assignment reduction 
serial version reduced potentially multiple iterations modified single iteration simply overwriting single location order 
serial order execution ensured largest iteration assigned 
parallel expanded version performs computation reduction operation locates largest value 
multi assignment reduction combines results distinct assignments 
simply modify conditional expression oe function oe teh conditional expression retrieve value correct location expanded resulting parallel version 
step performs initialization parallelization 
allocates array temporaries dictated optimized array ssa form 
step performs execution modified original loop 
step performs finalization recreating view arrays source remainder program 
single assignment reduction performed max function 
multi assignment reduction combining performed construct 
total theta time spent max computation largest amount extra introduced parallelization size original array number iterations loop 
significant source overhead done log parallel time 
see total amount required max operation gets reduced theta concrete parallelization number processors target machine 
concrete parallelization shows concrete parallelization parallelism 
concrete parallelization requires data computation mapped limited number processors target machine 
assume processor executes iterations relative order original loop 
concrete target assume discussion small scale multiprocessor physically distributed memories hardware support shared address space 
step performs initialization concrete parallelization 
allocates array temporaries importantly size array temporaries theta concrete parallelization compared theta parallelization significant reduction amount temporary storage required 
data distributions step provided optimization correctness parallelization transformation depend data distributions 
step performs execution concrete parallelization 
legal execute transformed loop parallel expansion arrays ensure data races occur assumption processor executes iterations relative order original loop necessary ensuring correctness 
note data distributions ensure writes arrays local concrete parallelization 
due unpredictable nature array subscript expression uniprocessor spatial locality writes performed original loop parallelized loop may poor 
step performs finalization concrete parallelization 
parallelization finalization loop step parallel loop extent equals number elements array number iterations loop involves step process described earlier single assignment reduction followed multi assignment reduction 
recall single assignment reduction achieved overwriting serial case actual reduction expanded dimension case 
concrete case accomplishes reduction overwriting processor reduction processors 
single assignment reduction computes temp index number processor assigned largest iteration number 
total amount time spent computation theta done parallel time processors 
finalization loop significant number remote memory spatial locality memory execution loop amenable latency hiding techniques prefetching 
show computation accessing shared non local data understood perform reduction distributed memory execution model hardware support shared address space 
multi assignment reduction determines final value adapting conditional expression oe function derived section 
temp set temp value element computed processor temp 
temp element written loop leave unchanged 
expect concrete parallelization scale linearly long total loop theta 
true theta 
initialization 
allocate array temporaries 
note array expanded 
allocate initialize 
execution 
execute loop parallel array temporaries level computation model processor iteration 
doall doall 
finalization 
compute final value doall temp max temp temp doall 
free parallelization loop iteration loop 
note distribution subscript function values affect scalability concrete parallelization 
concrete parallelization scale linearly happens map element iterations assuming total loop theta 
contrast schemes proposed hardware dynamic address resolution single location performance bottleneck receives disproportionately large number memory operations 
experimental results section performance results rasterization example computer graphics concrete parallelization technique previous section 
rasterization known scan conversion simple example real application includes loop containing loop carried output data dependences loop carried true data dependences 
polygons painted display buffer back front decreasing order values 
serial program experimental results code generic convex polygon scan conversion written paul heckbert distributed graphics gems book 
scan conversion code called randomly generated triangles target display buffer contains theta pixels 
triangle generated follows 
randomly generated value assigned vertices 
randomly generated pair selected vertex 
offsets second third vertices respect vertex randomly selected range gamma 
measurements 
initialization 
allocate array temporaries 
assume multiprocessor target distributed shared memory data distribution arrays places column separate processor 
compared parallelization note need arrays expansion factor processors iterations 
allocate distribute block block initialize 
execution 
execute loop parallel array temporaries concrete level computation model processor may execute iteration executes iterations relative order original loop 
doall processor number iteration doall 
finalization 
update array final value 
execute loop block computation mapping exploit spatial locality arrays doall due shrinking arrays theta theta need max 
returns smallest kn 
temp temp temp doall 
free concrete parallelization loop parallel parallel serial version version version speedup theta theta theta execution time measurements seconds rasterization polygons processor smp concrete parallelization transformation section separately cover reasonable range number polygons typically encountered rasterization 
parallel version code obtained renaming expanding display buffer array variable hand concrete parallelization technique described section 
execution phase processors processor performed rasterization randomly generated polygons stored output local copy expanded display buffer updating local array 
finalization phase performed reduction described section local arrays obtain final value global display buffer 
section said expected concrete parallelization scale linearly long total loop theta 
average time triangle means expect linear speedup long theta 
note array size larger values number iterations polygons means harder obtain linear speedup decreases 
value shows wallclock execution times measured rasterization phase generation random triangles cases 
serial version sequential code generic convex polygon scan conversion written paul heckbert distributed graphics gems book 
code executed single processor 

parallel version code obtained concrete parallelization executed single processor 

parallel version code obtained concrete parallelization executed processors 
execution times measured digital alphaserver smp containing alpha mhz 
speedup column reports ratio execution time parallel version processors execution time serial version 
speedups close linear theta theta respectively speedup drops theta 
shows concrete parallelization transformation section effective delivering speedup real application 
parallelization speculative execution section show array ssa form enable speculative execution parallelize loops loop carried true data dependences long cycle containing loop carried true data dependence includes loop independent control dependence 
section parallelization transformation works loops loop carried anti output dependences subscript expressions arbitrary control flow iteration 
example consider loop shown 
main difference loop section loop carried data dependence statement statement variable key dependence cycle code formed loop carried data dependence loop independent control dependence due construct 
array ssa form loop full insertion arrays oe functions shown fx initialized imin imax rhs endif enddo example loop imin imax oe max rhs oe max endif oe max enddo oe max array ssa form loop 
shows optimized array ssa form loop obtained copy propagation described section show explicit argument oe functions easier see dependence structure loop 
consider statements 
note statement executed speculatively array computation correctness array ssa form depends element set iterations condition evaluates true 
array ssa form gives option computing statement rhs speculatively iteration assuming rhs side effects inhibit speculative execution 
problem statement initializes extra elements array oe functions select elements computed statement original program 
shows dependences graphs different versions loop dependence graph original loop shown 
standard direction vector notation 
identify loop independent loop carried dependences 
addition true output anti data dependences variable loop independent control dependence due construct 
shows dependence graph optimized array ssa form 
new statements introduced oe function array computation 
dependence graph computed standard techniques array ssa form constructed 
notice anti output dependences dependence graph 
shows dependence graph true data dependence anti data dependence output data dependence control dependence dependence graph original loop 
dependence graph optimized array ssa form 
dependence graph selecting statement speculative execution 
dependence graphs loop imin imax oe rhs endif enddo oe max optimized ssa loop 
initialization 
allocate array temporaries 
note array expanded 
allocate initialize 
execution phase consists parallel loop statement sequential loop statements 
doall imin imax rhs enddo imin imax set temp temp temp temp endif enddo 
finalization 
compute final value doall doall 
free parallelization loop obtained decide execute statement speculatively 
statement longer control dependent statement 
reduces dependence cycle loop contain statements 
assuming significant computing rhs statement critical cycle significantly shorter 
fact array speculatively precomputed parallel see 
shows parallelization optimized array ssa form speculative execution statement 
analogous parallelization transformation section transformed code consists initialization phase execution phase finalization phase 
initialization phase allocates arrays array expanded 
parallelization expansion factor array equals number iterations loop section 
concrete parallelization limit expansion factor number processors 
execution phase consists parallel loop sequential loop 
parallel loop speculatively expanded array sequential loop executes dependence cycle consisting statements 
expansion required computed sequential loop 
conditional expression oe basis computing different points statement sequential loop execution phase simply computes temp obtain value single element array statement iteration array computed finalization phase analogous finalization phase section 
parallel loop written doall full barrier required parallel loop sequential loop execution phase 
parallel loop simply stay ahead sequential loop iteration parallel loop completed iteration sequential loop begins 
best accomplished depends target architecture 
possible concrete parallelization shown 
pipelining chunks iterations parallel sequential loops 
chunk size iterations single pipeline cycle consists executing chunk parallel loop conjunction chunk sequential loop 
degree parallelism single pipeline cycle 
array expansion factor needs concrete parallelization 
convenience shows concrete parallelization single pipeline cycle execution phase excludes prolog epilog software pipeline 
chunk size establishes granularity synchronization 
address mapping single pipeline cycle processors granularity processor mapping depend amount parallel sequential loops target machine 
parallelism regions array renaming provided array ssa form break loop independent output anti data execute th chunk parallel loop 
doall gamma mod rhs enddo execute th chunk sequential loop 
gamma set temp temp mod temp temp endif enddo concrete parallelization loop pipeline cycle fx initialized region enddo region cond endif enddo example code fragment regions dependences enable parallel execution distinct regions program 
example consider code fragment 
array ssa form optimizing oe functions shown 
consider regions original loops compute respectively finalization oe computes region values computed region regions executed concurrently 
region uses oe function oe combine results regions follows example renaming removed output dependence enabled parallel execution 
array region definition renaming broken anti dependence enabled parallel execution 
case final oe need combine values region enddo region cond endif enddo region oe ssa form region parallelism discussed parallelization section 
appropriate strategy concrete parallelization depend level parallelism exploited task parallelism multi threading parallel sections instruction level parallelism 
related currently important approaches program analysis 
discuss scalar ssa data dependence analysis array data flow analysis 
attack problem quite distinct ways distinct strengths weaknesses 
brief scalar ssa captures control flow renaming lacks array index information useful arrays 
dependence analysis historically useful arrays performs sophisticated index analysis capture control flow perform renaming 
array data flow analysis captures control flow index analysis include renaming array privatization 
array ssa form incorporates control flow analysis index analysis array renaming generally past approaches 
static single assignment ssa form scalar variables significant advance 
simplified design optimizations optimizations effective 
earliest applications ssa form design new algorithms global constant propagation global value numbering 
popularity ssa form efficient algorithm computing ssa form available 
ssa form standard representation modern optimizing compilers industry academia 
widely recognized ssa form effective array variables scalar variables 
approach recommended treat entire array single scalar variable ssa form 
example approach assignment single array element gets translated operation entire array update ssa renaming update 
serious limitation approach lacks precise data flow information element basis 
array ssa form addresses limitation providing oe functions combine array values element basis 
data dependence analysis historically analysis choice parallel community 
performs detailed analysis subscripts determine array common loops touch element 
observed past dependence analysis location insufficient array data flow analysis 
array data flow analysis received increasing amount attention see 
approaches suggested past write tree closely related array ssa form 
identifies instance write operation provides array element value instance read operation instances read write operations defined respect common surrounding loops 
restrictions placed program region enable construction 
assumed control flow region consists structured counted loops fortran loops 
assumed array subscripts contain affine functions index variables surrounding loops 
array ssa form far general scope 
discussed earlier array ssa form supports general reducible control flow places restrictions whatsoever array subscript expressions 
network oe functions connecting defs array ssa form viewed generalization 
combining rules oe functions identify def follow case 
special cases created oe functions represent information efficiently separate structure need created read operation 
summary array ssa form precise classical ssa form array variables element level approach 
precise dependence analysis takes control flow account 
general scope write tree representation allows arbitrary control flow arbitrary index expressions provides inherent support array renaming 
past experience runtime structures similar arrays 
notable example inspector executor model enable runtime parallelization loops containing array 
focus runtime scheduling communication optimization codes operate irregular grids 
contrast focus exposing arrays oe functions array ssa form increase scope compiler analysis transformation 
introduced array ssa form captures precise element level data flow information array variables 
general simple coincides standard ssa form applied scalar variables 
power lies simple mechanism combines control flow analysis array index analysis renaming 
important application array ssa form automatic parallelization 
showed array ssa form enable parallelization loop free loop carried true data dependences 
includes loops loop carried anti output dependences arbitrary conditionals loop bounds strides un analyzable subscript expressions 
validated array ssa form rasterization code showed speedups indicating overhead technique minimal 
plan pursue applications array ssa form including representing data flow information pointer accesses forms aliasing 
way array ssa form extended serve universal ssa form classes variables 
plan study improvements obtained register allocation instruction scheduling array ssa information 
plan investigating supporting compilation problems requiring summaries array accesses systems linear inequalities 
acknowledgments nikhil bert halstead matt frank norm rubin leonidas roy ju especially carl saman amarasinghe technical discussions contributing ideas 
addition bert halstead suggesting graphics algorithm help accessing understanding graphics code 
aho sethi ullman 
compilers principles techniques tools 
addison wesley 
bowen alpern mark wegman kenneth zadeck 
detecting equality variables programs 
fifteenth acm principles programming languages symposium pages january 
san diego ca 
amarasinghe 
parallelizing compiler techniques linear inequalities 
phd thesis computer systems laboratory stanford university january 
bodik gupta 
array data flow analysis load store optimizations superscalar architectures 
lecture notes computer science 
proceedings eighth annual workshop languages compilers parallel computing columbus ohio august 
ron cytron jeanne ferrante barry rosen mark wegman kenneth zadeck 
efficiently computing static single assignment form control dependence graph 
acm transactions programming languages systems october 
james foley andries van dam steven feiner john hughes 
computer graphics principles practice 
addison wesley publishing 
andrew glassner 
graphics gems 
academic press 
matthew hecht 
flow analysis computer programs 
elsevier north holland 
dror maydan saman amarasinghe monica lam 
array data flow analysis array privatization 
conf 
rec 
twentieth acm symposium principles programming languages january 
jeffery david heine shih wei liao monica lam olukotun 
software hardware exploiting speculative parallelism multiprocessor 
technical report csl tr stanford university computer systems lab february 
lawrence rauchwerger david padua 
lrpd test speculative run time parallelization loops privatization reduction parallelization 
proceedings acm sigplan conference programming language design implementation june 
barry rosen mark wegman kenneth zadeck 
global value numbers redundant computations 
fifteenth acm principles programming languages symposium pages january 
san diego ca 
saltz crowley 
run time scheduling execution loops message passing machines 
journal parallel distributed computing april 
shapiro saint 
representation algorithms 
technical report massachusetts computer associates february 
technical report ca 
sohi breach 
multiscalar processors 
proceedings nd international symposium computer architecture 
gregory todd mowry 
potential thread level data speculation tightly coupled multiprocessors 
technical report csri tr department electrical computer engineering university toronto february 
mark wegman ken zadeck 
constant propagation conditional branches 
conf 
rec 
twelfth acm symposium principles programming languages pages january 
michael wolfe 
optimizing supercompilers supercomputers 
pitman london mit press cambridge massachusetts 
series research monographs parallel distributed computing 
corrections preprint contains typographical corrections modifications conference version page boundaries remain unchanged ffl page column rewritten ffl page column loops replaced loop ffl page column replaced ffl page column inserted max xh xh ffl page column analagous replaced analogous ffl page column replaced form ffl page column replaced ffl page column space removed ffl page column extra removed ffl page column replaced max max ffl page column inserted iterations ffl page column replaced due due ffl page column replaced disproportionately ffl page column replaced ffl page column inserted find typographical errors please send email knobe crl dec com vivek lcs mit edu 

