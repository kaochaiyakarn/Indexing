fast plan generation heuristic search ff planning system fast plan generation heuristic search jorg hoffmann hoffmann informatik uni freiburg de bernhard nebel nebel informatik uni freiburg de georges kohler geb 
freiburg germany describe evaluate algorithmic techniques ff planning system 
hsp system ff relies forward state space search heuristic estimates goal distances ignoring delete lists 
hsp heuristic method assume facts independent 
introduce novel search strategy combines hill climbing systematic search show powerful heuristic information extracted prune search space 
ff successful automatic planner aips planning competition 
review results competition give data benchmark domains investigate reasons runtime performance ff compared hsp 

years seen significant increase efficiency planning systems 
increase mainly due new approaches plan generation 
approach developed blum furst 
seminal graphplan system blum furst described new plan generation technique planning graphs faster technique known time 
started series research efforts refined approach making efficient fox long kambhampati parker lambrecht extending cope expressive planning languages koehler nebel hoffmann dimopoulos knoblock anderson smith weld nebel 
second approach planning satisfiability method translates planning propositional satisfiability kautz selman 
particular hope advances state art propositional reasoning systems carry directly planning systems relying technology 
fact kautz selman predicted research planning methods superfluous state art propositional reasoning systems advance faster planning systems 
third new approach heuristic search planning proposed bonet geffner 
approach heuristic function derived specification planning instance guiding search state space 
demonstrated system ff planning competition aips approach proved 
article extended revised version published hoffmann 

ff stands fast forward 
hoffmann nebel competitive 
fact ff outperformed fully automatic systems nominated group distinguished performance planning system competition 
hsp goal distances estimated approximating solution length relaxation planning task bonet geffner 
ff uses relaxation deriving heuristics differs hsp number important details 
base heuristic technique seen application graphplan relaxation 
yields goal distance estimates difference hsp estimates rely independence assumption 
ff uses different search technique hsp enforced form hill climbing combining local systematic search 
employs powerful pruning technique selects set promising successors search node pruning technique cuts branches appears goal achieved early 
techniques obtained side effect base heuristic method 
concerning research strategy ff 
lot classical planning approaches partial order planning mcallester rosenblitt planning graph analysis blum furst generic problem solving methods developed theoretical concept tested examples literature 
approach exploring idea heuristic search clear distinction development testing 
search strategy pruning techniques generic methods motivated observing examples 
design decisions basis careful experimentation 
introduces system bias examples testing development 
testing algorithms range domains planning literature 
refer domains frequently literature tasks domains benchmarks 
development phase benchmark examples assembly blocksworld grid gripper logistics mystery domains 
describing algorithms indicate points testing examples played role decision 
planning known pspace complete simplest form bylander 
general case efficient algorithmic method 
worthwhile look algorithms efficient restricted subclasses 
extent idea pursued posing severe syntactical restrictions planning task specifications bylander 
approach complementary 
examining existing benchmarks finds exploit full expressivity underlying planning formalism 
fulfill obvious rigid syntactical restrictions particularly hard 
existing benchmark domains non optimal plan principle generated polynomial time 
benchmarks inspiration development able come heuristic method provably efficient empirically large class planning tasks 
class includes current planning benchmarks 
intuitively algorithms exploit simple structure underlying tasks 
ongoing concerned finding formal characterization simple structure formalizing class planning tasks ff works 
section gives schematic view ff system architecture section introduces notational conventions strips domains 
sections describe base heuristic technique search algorithm pruning methods 
section shows algorithms fast plan generation heuristic search extended deal adl domains 
system performance evaluated section demonstrating ff generates solutions extremely fast large range planning benchmark domains 
order illustrate intuitions kind structure ff exploit successfully section gives examples domains method appropriate 
clarify performance differences ff hsp section describes number experiments order estimate new algorithmic techniques useful 
show connections related points text apply overview connections section 
section outlines current avenue research 

system architecture give reader overview ff system architecture shows ff fundamental techniques arranged 
enforced hill climbing relaxed graphplan task specification solution fail state goal distance helpful actions ff base system architecture 
fundamental heuristic technique ff relaxed graphplan describe section 
technique gets called search state enforced hill climbing search algorithm 
forward searching engine described section 
state relaxed graphplan informs search goal distance estimate additionally set promising successors state helpful actions described section 
termination enforced hill climbing outputs solution plan reports failed 
top base architecture shown integrated optimizations cope special cases arose testing ffl planning task contains states goal unreachable dead ends defined section enforced hill climbing fail find solution 
case complete heuristic search engine invoked 
ffl presence goal orderings enforced hill climbing wastes lot time achieving goals need cared 
techniques trying avoid integrated added goal deletion introduced section cuts branches goal apparently achieved early 
hoffmann nebel goal agenda technique adapted koehler feeds goals planner order determined pre process section 

notational conventions introducing ff basic techniques consider simple strips planning tasks introduced fikes nilsson 
notations follows 
definition state state finite set logical atoms 
assume operator schemata grounded talk actions 
definition strips action strips action triple pre add del pre preconditions add add list del delete list action set atoms 
atom add say achieves result applying single strips action state defined follows result add del pre undefined case pre action said applicable result applying sequence action state recursively defined result ho result result ho gamma ho definition planning task planning task triple set actions initial state goals sets atoms 
heuristic method relaxed planning tasks defined follows 
definition relaxed planning task planning task 
relaxation defined pre add pre add del og words obtains relaxed planning task ignoring delete lists actions 
plans simple sequences actions framework 
definition plan planning task 
plan sequence ho actions solves task result holds 
action sequence called relaxed plan iff solves relaxation fast plan generation heuristic search 
graphplan heuristic estimator section introduce base heuristic method ff 
derived applying graphplan relaxed planning tasks 
resulting goal distance estimates hsp estimates rely independence assumption 
prove heuristic computation polynomial give notions distance estimates kept cautious describe method implemented efficiently 
consider heuristic method hsp bonet geffner 
planning task hsp estimates state reached forward search solution length task length relaxed plan achieves goals starting computing optimal solution length admissible heuristic np hard bylander hsp estimate rough approximation computing weight values 
weight min add pre weight gamma hsp assumes facts achieved independently sense weight set facts action preconditions estimated sum individual weights 
state heuristic estimate weight weight assuming facts achieved independently heuristic ignores positive interactions occur 
consider short example planning task initial state empty goals fg actions name pre add del fpg fg fpg fg opp fpg hsp weight value computation results having weight goal having weight 
assuming facts achieved independently distance initial state goal state estimated 
obviously task solvable steps share precondition order take account positive interactions idea start graphplan task extract explicit solution relaxed plan 
plan heuristic evaluation 
see section approach feasible graphplan proven solve relaxed tasks polynomial time 
planning graphs relaxed tasks examine graphplan behaves started planning task contain delete lists 
briefly review basic notations graphplan algorithm blum furst 
hoffmann nebel planning graph directed layered graph contains kinds nodes fact nodes action nodes 
layers alternate fact action layers fact action layer time step 
time step number fact layer corresponding initial state action layer corresponding actions applicable initial state 
subsequent time step layer facts possibly true time steps layer actions possibly applicable facts 
crucial thing graphplan building planning graph inference mutual exclusion relations 
pair actions time step marked mutually exclusive interfere action deletes precondition add effect 
pair facts time step marked mutually exclusive action level gamma achieves exclusive action level gamma achieves pair actions time step marked mutually exclusive actions interfere competing needs precondition exclusive precondition planning graph relaxed task contain exclusion relations 
proposition relaxed strips task 
started graphplan mark pair facts actions mutually exclusive 
proof proposition easily proven induction depth planning graph 
base case time step 
interfering actions marked mutual exclusive time step 
delete effects pair actions interferes 
inductive case time step time step 
induction hypothesis facts exclusive time step ahead 
follows pair actions competing needs 
interfere 
started planning task graphplan extends planning graph layer layer fact layer reached contains goal facts goal facts marked exclusive 
starting layer recursive backward search algorithm invoked 
find plan set facts layer initialize set selected actions layer gamma empty set 
fact consider achieving actions layer gamma select exclusive action selected 
exists action proceed fact 
backtrack fact try achieve different action 
achieving action selected fact collect preconditions actions new set facts time step earlier 
succeed fact layer initial state reached achieving actions need selected 
relaxed tasks backtracking occurs graphplan search algorithm 
proposition relaxed strips task 
started graphplan backtrack 
proof backtracking occurs fact exclusive selected action 
proposition know exclusions exist 
fact layer reached task proven unsolvable blum furst 
fast plan generation heuristic search happen 
graph layer layer gamma supporting 
argumentation sufficient showing proposition tell going starts graphplan task delete lists 
happens 
task solvable planning graph gets extended fact layer reached contains goals 
recursive search starts selecting goals level 
attempt succeeds new goals set time step earlier 
selection succeeds forth initial state reached 
search performs single sweep graph starting top layer going initial layer collects relaxed plan way 
particular procedure takes polynomial time size task 
theorem solvable relaxed strips task length longest add list action graphplan find solution time polynomial jo jij 
proof building planning graph polynomial jo jij number time steps built blum furst 
case total number jo actions upper limit number time steps 
just number time steps built actions appear layer graph 
layer new action comes action layer gamma identical action layer task solvable implies goals contained fact layer process right away 
similarly action layer jo identical action layer jo gamma implying termination 
graph building phase polynomial jo jij 
concerning plan extraction phase proposition search traverses graph top bottom collecting set achieving actions layer 
selecting set facts jo jij set facts size jo jij maximal number distinct facts graph 
achieving action fact constant time planning graph 
number layers looked jo search polynomial desired parameters 
starting graphplan solvable search state task yields polynomial time theorem relaxed solution ho om gamma set actions selected parallel time step number fact layer containing goals 
interested estimation sequential solution length define heuristic follows 
gamma jo estimation values obtained way testing examples usually lower hsp estimates equations extracting plan takes account positive interactions facts 
consider short example section empty initial state goals fg actions hoffmann nebel name pre add del fpg fg fpg fg opp fpg starting graphplan initial state goals contained fact layer causing selection action layer 
yields new goal fact layer achieved opp resulting plan hf opp gi giving correct goal distance estimate distinct hsp estimate 
solution length optimization graphplan heuristic estimates equation greedy strategy introduced section doesn take decisions back 
experience running strategy testing examples works best distance estimates cautious low possible 
said optimal sequential solution synthesized efficiently 
apply techniques graphplan return short solutions possible 
describe ways doing 
technique built feature ensures minimality criterion relaxed plan 
techniques heuristic optimizations 
original graphplan algorithm extensive called 
dummy actions simply propagate facts fact layer 
fact gets inserted fact layer noop corresponding fact inserted action layer time step 
noop effect adding precondition performing backward search considered just way making fact true time simply keep true time gamma 
graphplan implementation uses default heuristic noop achieving fact noop considered planner tries selecting real actions achieve relaxed tasks heuristic ensures minimality criterion returned plan follows 
proposition relaxed strips task solvable 
strategy plan graphplan returns contain action 
proof assume opposite action occurs twice plan ho om gamma graphplan finds 
layers action selected layer achieve fact layer 
algorithm strategy implies noop fact contained action layer noop action selected achieving contradiction action layer contain noop fact action appears action layer gets added appears fast plan generation heuristic search fact layer noop inserted action layer turn inserted action layer 
difficulty heuristic argumentation achieve fact noop 
question choose noop available 
certainly idea select preconditions easy 
graph building phase obtain simple measure difficulty action preconditions follows 
difficulty pre member fact layer time step ig difficulty action set inserted graph 
plan extraction facing fact noop available simply select achieving action minimal difficulty 
heuristic works situations ways achieve fact ways need effort 
action set linearization assume graphplan settled parallel set time step achieving actions selected goals time step 
interested sequential solution length choice linearize actions 
linearizations lead shorter plans 
action adds precondition action need include new set facts achieved time step earlier restrict execute question find linearization actions minimizes new fact set 
corresponding decision problem np complete 
definition optimal action linearization denote problem 
set relaxed strips actions positive integer function 
number unsatisfied preconditions executing sequence hf gamma gamma joj theorem deciding optimal action linearization np complete 
proof membership obvious 
hardness proven transformation directed optimal linear arrangement 
directed graph positive integer question exists function 
jv jg gamma directed graph define set actions follows 
node graph define action set simplicity presentation identify actions corresponding nodes 
set pre add edge create new logical facts hoffmann nebel new logical facts adjust precondition add lists express constraint edge 
say action ordered action linearization 
need simulate difference positions define actions way bigger difference unsatisfied preconditions executing linearization 
punish actions ordered giving unsatisfied precondition 
pre pre add add fp definition actions ordered unsatisfied precondition ordered get precondition added number unsatisfied preconditions get exactly 
secondly give reward action ordered simply letting actions add precondition go unsatisfied 
add add pre pre fr way exactly jv gamma gamma unsatisfied preconditions facts actions ordered summing number unsatisfied preconditions get linearization arrive jv gamma gamma gamma jaj jv define new positive integer jaj jv 
sure actions get ordered actions inserting new logical safety facts precondition add list 
pre pre fs add add fs altogether linearization actions leads unsatisfied preconditions satisfies requirements directed optimal linear arrangement 
obviously action set computed polynomial time 
sole purpose linearizing action set certain order achieve smaller number unsatisfied preconditions turn lead shorter relaxed solution 
certainly willing pay price finding optimal linearization actions cost theorem 
methods approximate linearization introducing ordering constraint action adds precondition action trying linearize actions constraints met 
experimentations parallel actions adding preconditions occur rarely testing tasks approximating worth effort 
simply linearize actions order get selected causing computational overhead 

noted optimal action linearizations time step guarantee resulting relaxed solution optimal give admissible heuristic 
fast plan generation heuristic search efficient implementation implemented version graphplan highly optimized solving relaxed planning tasks 
exploits fact planning graph relaxed task contain exclusion relations proposition 
implementation highly optimized repeatedly solving planning tasks share set actions tasks described section 
planning task specifications usually contain operator schemata set constants 
instantiating schemata constants yields actions task 
system instantiates operator schemata way reachable actions built 
reachability action means successively applying operators initial state action preconditions appear eventually 
build call connectivity graph 
graph consists layers containing reachable actions reachable facts 
action pointers preconditions adds deletes 
ff computations efficiently implemented graph structure 
subsequently described implementation relaxed graphplan need information preconditions adds 
relaxed planning graph contain exclusion relations information needs represent call layer memberships fact action number layer appears graph 
called intermediate task version graphplan computes layer memberships fixpoint computation 
layer memberships facts actions initialized 
action counter initialized 
fact layer built implicitly setting layer membership facts 
time fact gets layer membership set actions precondition get counter incremented 
soon counter action reaches total number preconditions put list scheduled actions current layer 
fact layer finished actions scheduled step layer membership set adds put list scheduled facts fact layer time step 
having finished action layer scheduled facts step membership set 
process continues goals layer membership lower 
noticed view planning graph building corresponds closely computation weight values hsp 
computed applying actions layers updating weight values propagating changes time action comes stopping changes occur layer 
having finished relaxed version planning graph building similarly trivial version graphplan solution extraction mechanism invoked 
see 
putting goals top layer graphplan style propagating goal simply put goal set located layer loop top initial layer 
layer achieving action layer membership gamma gets selected fact corresponding goal set 
best picked difficulty heuristic 
preconditions put corresponding goal sets 
time action selected adds marked true times gamma 
marker time prevents selected facts true hoffmann nebel fg layer membership ig endfor marked true time select action add layer membership gamma difficulty minimal pre layer membership marked true time gamma layer membership layer membership ffg endfor add mark true times gamma endfor endfor endfor relaxed plan extraction anyway 
marking time gamma assumes actions linearized order get selected precondition achieved action ahead considered new goal 

novel variation hill climbing section introduce enforced hill climbing ff base search algorithm 
discuss enforced hill climbing completeness derive ff search strategy 
hsp version bonet geffner hsp aips competition uses variation hill climbing selecting best successor state currently facing 
state evaluations costly chose local search 
settled different search algorithm enforced form hill climbing combines local systematic search 
strategy motivated simple structure search spaces testing benchmarks tend 
enforced hill climbing doing planning heuristic forward search search space space reachable states heuristic evaluation 
evaluating states testing benchmarks heuristic defined equation finds resulting search spaces simple structure specifically local minima plateaus tend small 
search state state strictly better heuristic evaluation usually steps away example logistics domain described section 
idea perform exhaustive search better states 
algorithm shown 
hill climbing algorithm depicted starts initial state 
facing intermediate search state complete breadth search starting invoked 
finds closest better successor nearest state fast plan generation heuristic search initialize current plan empty plan 
perform breadth search state state output fail endif add actions path current plan endwhile enforced hill climbing algorithm 
strictly better evaluation fails 
case algorithm fails case path added current plan search iterated 
goal state state evaluation reached search stops 
implementation breadth search starting standard states kept queue 
search iteration removes state queue evaluates running graphplan 
evaluation better search succeeds 
successors put queue 
repeated states avoided keeping hash table visited states memory 
new states reached anymore breadth search fails 
completeness iteration breadth search better state fails enforced hill climbing stops finding solution 
happen enforced hill climbing chosen include action plan takes decision back 
method complete tasks wrong decisions 
tasks contain dead ends sense 
definition dead planning task 
state called dead iff reachable sequence actions achieves goal iff result result 
naturally task called dead free contain dead states 
dead free implies solvability initial state dead 
proposition planning task 
dead free enforced hill climbing find solution 
proof assume enforced hill climbing reach goal 
intermediate state result current plan breadth search improve situation 
search stopped 
path goal state complete breadth search find path hoffmann nebel obtain terminate positively 
path exist showing dead state contradiction assumption 
proposition holds function states natural numbers including iff proposition identifies class planning tasks safely apply enforced hill climbing 
unfortunately pspace hard decide planning task belongs class 
definition deadend free denote problem planning task dead free theorem deciding deadend free pspace complete 
proof hardness proven polynomially reducing bylander decision problem solvable problem deciding deadend free 
simply add operator executable states re establishes initial state 
fo add iig applying state reachable leads back initial state facts true removed initial state added 
modified problem dead free iff solvable 
left right deadend free solvable implies solvable added new possibility reaching goal 
right left solvable solution plan states achieve goal going back initial state new operator executing 
membership pspace follows fact complement pspace 
non deterministic algorithm decides complement needs polynomial space specified follows 
guess state verify polynomial space reachable initial state 
verify goal reached algorithm succeeds follows instance dead free constitutes dead 
implies deadend free pspace 
efficiently decide task dead free easily testable sufficient criteria literature 
johnsson 
define notion symmetric planning tasks sufficient dead freeness np complete 
give polynomial sufficient criterion symmetry 
trivial 
hardly current benchmarks fulfills 
koehler hoffmann defined notions invertible planning tasks sufficient dead freeness inverse actions sufficient invertibility certain restrictions 
existence inverse actions sufficient criteria additional restrictions decided polynomial time 
benchmark tasks fact fulfill criteria efficiently proven dead free 
fast plan generation heuristic search adopt koehler hoffmann methodology existence inverse actions recognize dead free tasks 
test fails employ different search strategy enforced hill climbing 
reasons going way ffl testing benchmarks tasks contain inverse actions dead free 
example domain enforced hill climbing leads excellent results 
ffl enforced hill climbing quite successfully solve tasks contain dead ends necessarily get caught 
examples contained mystery domains look section 
observation forms basis way dealing completeness 
enforced hill climbing solve planning task usually fails quickly 
simply switch different search algorithm 
experimented randomizing enforced hill climbing doing restart attempt failed 
didn lead convincing results 
tried large variety randomization strategies find planning task testing domains randomized restart significantly better previous attempts suffered problems 
tasks enforced hill climbing solve right away apparently full dead ends avoid dead ends random 
arranged search strategy ff follows 
enforced hill climbing goal reached algorithm fails 

enforced hill climbing failed skip done far try solve task complete heuristic search algorithm 
current implementation russel norvig russell norvig term greedy best search 
strategy simply expands search nodes increasing order goal distance estimation 
summarize ff uses enforced hill climbing base search method complete best algorithm deal special cases enforced hill climbing run dead failed 

pruning techniques section introduce heuristic techniques principle prune search space forward state space search algorithm 
helpful actions selects set promising successors search state 
demonstrate section heuristic crucial ff performance domains 

added goal deletion cuts branches goal apparently achieved early 
testing heuristic yield savings tasks contain goal orderings effect tasks don 
hoffmann nebel techniques obtained side effect graphplan heuristic estimator manner described section 
preserve completeness hypothetical forward search 
context search algorithm integrate prune search space single enforced hill climbing try complete general anyway completely turn best search enforced hill climbing failed 
helpful actions state define set actions promising actions applicable technique derived having closer look relaxed plans graphplan extracts search states testing tasks 
consider gripper domain aips planning competition 
rooms certain number balls room initially shall moved room planner controls robot changes rooms move operator grippers pick drop balls 
gripper hold ball time 
look small task balls moved room say robot picked balls current search state robot room gripper holds ball 
applicable actions state move room drop balls back room relaxed solution heuristic extracts 
move drop ball left drop ball right parallel relaxed plan consisting time steps 
action set selected time step contains action sense state hand move room pursue idea restricting action choice planning state actions selected time step relaxed plan 
call actions helpful 
example state strategy cuts branching factor 
restricting oneself actions selected relaxed planner 
consider blocksworld example 
say known representation operators stack unstack pickup putdown 
planner controls single robot arm operators stack block top unstack block pickup block table put block arm holding table 
initially arm holding block blocks table 
goal stack started state relaxed graphplan return time step optimal solutions 
putdown pickup stack fast plan generation heuristic search stack pickup stack stack pickup stack valid relaxed solutions relaxation matter stacking deletes facts need 
pickup anymore stack anymore 
action relaxed plan inserted get rid free robot arm point view relaxed planner starting actions job 
relaxed solution extracted 
happens second third lose path optimal solution restricting corresponding actions stack stack define set helpful actions state follows 
fo pre add denotes set goals constructed graphplan time step level ahead initial layer started task 
words consider helpful actions applicable ones add goal time step 
blocksworld example freeing robot arm goals causes starting actions helpful initial state elements 
gripper example modification change 
notion helpful actions shares similarities drew mcdermott calls favored actions mcdermott context computing greedy regression graphs heuristic estimation 
nutshell greedy regression graphs goals facts reached contained current state 
things graphs provide estimation actions useful getting closer goal applicable ones members effective subgraph minimal cost subgraph achieving goals 
similarity helpful actions heuristic known relevance literature nebel dimopoulos koehler 
consider blocksworld task hundreds blocks table initially goal stack block top block set case contain single action pickup throwing away applicable actions moving blocks mentioned goal throwing away actions irrelevant 
main difference helpful actions heuristic concept relevance relevance usual sense refers useful solving task 
helpful hand refers useful step 
disadvantage helpful things need recomputed search state hoffmann nebel advantage possibly far things helpful relevant 
specific setting get helpful actions free anyway side effect running graphplan 
conclude subsection example showing helpful actions pruning preserve completeness remarks current integration technique search algorithm 
completeness short example helpful actions heuristic prunes solutions state space 
say initial state fbg goals fa bg actions name pre add del opa fag fbg opa fp fag fbg fag fp fbg planning task ways achieving missing goal opa deletes goal opa needs precondition pa achieved involves planning actions case 
relaxed graphplan recognizes alternative time step optimal 
set goals single time step created graph construction gives helpful actions opa cause state transition initial state 
opa leads state true 
state obtain set helpful actions containing opa time action causes state transition second leads back initial state 
helpful actions cuts solutions state space example task 
task dead free reach applying opa easily task invertible changing behavior 
strips domains theoretically overcome incompleteness helpful actions pruning considering relaxed plan graphplan finds computing kind union relaxed plans graphplan possibly find allowing non time step optimal plans 
precisely search state consider relaxed task 
extend relaxed planning graph fact level jo reached 
set goal set jo top fact level jo proceed fact level jo gamma fact level level set goals generated union fast plan generation heuristic search preconditions actions level add fact termination define helpful actions add fact proven way starting actions optimal solutions considered helpful 
strips testing domains complete method selects applicable actions helpful 
integration search noted section integrate helpful actions pruning search algorithm applying single enforced hillclimbing try leaving complete best search algorithm unchanged see section 
facing state breadth search better state enforced hill climbing look successors generated 
renders implementation enforced hill climbing incomplete invertible planning tasks 
testing domains tasks solved enforced hill climbing helpful actions pruning exactly solved enforced hill climbing anyway 
added goal deletion second pruning technique introduce section motivated observation planning domains goal ordering constraints recognized quite number researchers past irani cheng drummond currie joslin roach 
experiments tasks goal ordering constraints ff base architecture wasted lot time achieving goals needed cared 
developed heuristic inform search goal orderings 
classical example planning domain goal ordering constraints known blocksworld 
say blocks table initially want stack top top obviously point stacking 
imagine forward searching planner confronted search state goal just achieved resulted state applying action add 
ask situation idea achieve right 
goal achieved 
answer inspired koehler hoffmann argues achieving postponed remaining goals achieved destroying 
course finding involves solving remaining planning task 
arrive simple testing domains surprisingly accurate approximation relaxed plan graphplan generates state method simple relaxed solution plan graphplan generates contains action deletes del skip search space generate successors call method added goal deletion heuristic 
exemplify heuristic blocksworld example 
say planner just achieved false situation top standing table 
relaxed solution graphplan finds situation 
hoffmann nebel unstack pickup stack goal just achieved gets deleted action unstack consequently realize stacking right probably bad idea prune possibility search space results solution plan stacks 
preceding subsection conclude example showing pruning search states manner described preserve completeness remarks current search algorithm implementation 
completeness small example goals destroyed temporarily order achieve goal 
renders planning task unsolvable added goal deletion heuristic 
say initial state empty goals fa bg actions name pre add del opa fag fag fbg fag solutions task need apply opa re establish crucial point temporarily destroyed 
added goal deletion heuristic adequate planning tasks 
example dead free easily scenario invertible changing behavior heuristic 
helpful actions completeness regained enumerating relaxed plans situation 
example achieved false relaxed plans contain deleting integration search added goal deletion heuristic way similar integration helpful actions heuristic 
indicated section integrated single enforced hill climbing try search completely turned best search case enforced hill climbing didn goal 
goal ordering technique taken literature 
common approaches dealing goal orderings trying recognize preprocessing phase prune fractions search space planning irani cheng cheng irani joslin roach 
basic principle underlying called goal agenda approach koehler 
system implemented slightly simplified version goal agenda algorithm enhance performance 
short summary happens 
preprocessing phase planner looks pairs goals decides heuristically ordering constraint 
goal set split totally ordered series subsets respecting orderings 
fed enforced fast plan generation heuristic search hill climbing incremental manner 
precisely ordered series subsets enforced hill climbing gets started original initial state works search ends state satisfying goals enforced hill climbing called new starting state larger goal set state satisfying search gets started goals 
incremental agenda driven planning process applied planner principle preserves completeness dead free tasks koehler hoffmann enhancement loses completeness general 
goal agenda enforced hill climbing leaving complete best search phase unchanged 

extension adl far restricted planning tasks specified simple strips language 
show approach extended deal adl pednault tasks precisely adl subset pddl mcdermott nd international planning systems competition bacchus 
involves dealing arbitrary function symbol free order logic formulae conditional effects 
extension divided subareas 
apply preprocessing approach adl domain task description compiling specified task propositional normal form 

extend heuristic evaluation planning states deal normal form constructs 

adjust pruning techniques 

adjust search mechanisms 
preprocessing adl planning task ff preprocessing phase identical methodology developed ipp planning system 
details refer reader done koehler hoffmann give basic principles 
planner starts planning task specification subset pddl defined aips planning competition bacchus 
input set operator schemata initial state goal formula 
initial state simply set ground atoms goal formula arbitrary order logical formula relational symbols defined planning task 
operator schema defined list parameters precondition list effects 
instantiating parameters yields just strips tasks usually specified actions schema 
precondition arbitrary order formula 
action applicable state instantiation formula satisfied effect list form add del effect parameters effect condition arbitrary formula add del atomic add delete effects respectively 
hoffmann nebel atomic effects sets uninstantiated atoms relational symbols containing variables 
semantics instantiated action executed single effect list instantiation parameters condition evaluated 
holds current state corresponding instantiations atoms add added state instantiations atoms del removed state 
ff heuristic method single state evaluation involve thousands operator applications building relaxed planning graph needs determine applicable actions single fact layer 
invest effort compile operator descriptions simpler propositional normal form heuristic evaluation implemented efficiently 
final normal form actions format 
precondition pre effects pre add del pre add del 
pre add del precondition set ground atoms 
likewise effect conditions pre single effects restricted ground atoms 
represent goal state set atoms 
compile away conditional effects 
compiling away logical formulae involves transforming dnf causes exponential blow general 
testing domains transformation done reasonable time 
concerning conditional effects compiled away exponential blow want preserve solution length 
proven nebel 
see conditional effects efficiently integrated algorithmic framework need compiling away 
compilation process proceeds follows 
determine predicates static sense operator effect 
predicates common phenomenon benchmark tasks 
example gamma city facts logistics tasks location stays course located city planning process 
recognize static predicates simple sweep operator schemata 

transform formulae quantifier free dnf 
subdivided steps pre normalize logical formulae 
knoblock process expands quantifiers translates negations 
formulae conjunctions disjunctions atoms containing variables 
instantiate parameters 
simply done instantiating operator effect parameters type consistent constants 
fast plan generation heuristic search process knowledge static predicates sense instantiated formulae simplified 
example instantiated static predicate occurs formula instantiation contained initial state replaced false 
transform formulae dnf 
postponed instantiation costly applied small formulae possible 
fully instantiated formula static way predicate occurrences replaced true false resulting simpler formula structure 

dnf formula contains disjunct corresponding effect operator goal condition gets split manner proposed knoblock 
relaxed graphplan conditional effects show specialized graphplan implementation described section changed deal adl constructs 
building normalized task representation suffices take care conditional effects 
relaxed planning graphs conditional effects encoding planning graph building relaxed tasks immediately carries adl actions propositional normal form 
simply needs keep additional layer membership value effects action 
layer membership effect indicates layer effect conditions plus corresponding action preconditions 
compute membership integers efficient manner keep counter effect action gets incremented time condition pre time precondition pre corresponding action 
effect gets layer membership set soon counter reaches effect add effects add scheduled layer 
process iterated goals reached time 
relaxed plan extraction conditional effects relaxed plan extraction mechanism adl differs strips counterpart merely little details 
selecting achieving actions extraction mechanism selects achieving effects 
effect action selected effect conditions plus preconditions need put corresponding goal sets 
effect add effects add marked true time added facts effects implied effects pre pre particular unconditional effects empty effect condition 
adl pruning techniques pruning techniques section easily carry actions conditional effects 
hoffmann nebel helpful actions strips defined helpful applicable actions achieving goal time step cf 
section 
adl normal form simply change applicable actions having appearing effect achieves goal time step effect appears iff effect condition satisfied current state 
fo pre pre add added goal deletion originally cut state actions selected relaxed plan deleted goal just achieved cf 
section 
simply take criterion effects selected relaxed plan state cut effects selected relaxed solution deletes goal just achieved 
adl state transitions enabling search algorithms handle propositional adl normal form sufficient redefine state transition function 
forward search matter hill climbing best search whatsoever faces completely specified search state 
compute exactly effects executing context dependent action 
koehler define adl state transition function res mapping states adl normal form actions states follows 
res pre undefined pre add pre del 
performance evaluation implemented methodology preceding sections section evaluate performance resulting planning system 
empirical data divided subareas 
ff system took part fully automated track nd international planning systems competition carried alongside aips breckenridge colorado 
review results demonstrating ff runtime solution length behavior competition 
give intuitions ff behaves way 

holds initial state completely specified actions deterministic assume 

source code publicly available ff homepage www informatik uni freiburg de hoffmann ff html 
fast plan generation heuristic search 
experiments results obtained domains aips competition 
briefly summarize findings domains ff works 
illustrate intuitions reasons ff performance give examples domains approach appropriate 

detailed comparison ff performance hsp sense investigate differences ff hsp lead performance results 
aips planning systems competition march april nd international planning systems competition organized fahiem bacchus carried general setting aips conference breckenridge colorado 
main tracks fully automated planners planners hand tailored knowledge 
tracks divided parts concerned different planning domain 
ff system took part fully automated track 
competition ff demonstrated runtime behavior superior fully automatic planners granted group distinguished performance planning system bacchus nau 
won schindler award place elevator domain adl track 
section briefly data collected fully automated track give domain intuitions reasons ff behavior 
reader aware competition distinction optimal suboptimal planners putting runtime curves groups 
text domain state shown planners optimal solutions didn 
logistics domain domains competition logistics blocksworld domains 
look 
classical domain involving transportation packets trucks airplanes 
shows runtime curves planners able scale bigger instances competition 
logistics tasks subdivided sets instances easy harder ones 
planners easy instances run harder set 
planners ff hsp bonet geffner system grt mips stan long fox 
probably tiny examine details observations surely 
system significantly worse planners 

better planners behave quite similar ff mips tending fastest 
note times shown logarithmic scale looking linear time logistics planners 
concerning solution plan length show 
shown planners guarantees returned plans optimal 
turns hoffmann nebel problem size ff hsp system grt mips stan runtime curves large logistics instances planners scale 
time shown logarithmic scale 
stan finds shortest plans instances 
system finds significantly longer plans ranging stan plan lengths average 
lengths ff plans stan plan lengths average length 
concerning ff runtime behavior think mainly reasons 
iterations enforced hill climbing breadth search finds state better evaluation small depths motivating search algorithm cf 
section 
cases better successor depth direct 
cases better successor depth rarely breadth needs go depth 
observations independent task size 

helpful actions heuristic prunes large fractions search space 
looking states ff encounters search percent state successors considered helpful experiments tendency larger task helpful successors 
theoretical note observation 
common representation logistics tasks proven 
maximal distance locations number move actions mobile needs take get location 
heuristic function assigns state length optimal relaxed solution heuristic value distance state fast plan generation heuristic search better evaluated state maximal 
algorithm enforced hill climbing oracle function returning length optimal relaxed solution polynomial standard logistics representations upper limit benchmarks available mobiles reach location accessible just step maximal distance tasks constantly 
ff heuristic usually find optimal close optimal relaxed solutions enforced hill climbing needs look steps ahead 
blocksworld domain blocksworld best known benchmark planning domains planner needs rearrange bunch blocks goal stack position robot arm 
just logistics tasks competition instances divided set easier harder ones 
shows runtime curves planners scaled harder ones 
problem size ff hsp system runtime curves large blocksworld instances planners scale ff hsp system 
time shown logarithmic scale 
system scales steadily blocksworld tasks competition 
particular planner solve tasks 
hsp solves smaller instances ff solves thirds set 
ff succeeds instance quite fast 
example ff solves size tasks seconds system needs seconds 
planners finds optimal plans 
tasks hsp manages solve plans system plan hoffmann nebel lengths average 
tasks ff manages solve plans system plan lengths average 
experimenting different configurations ff behavior ff tasks largely due goal ordering heuristics section 
goal distance estimates planner grabs bunch blocks single arm helpful actions heuristic arm holds block positions possibly put usually considered helpful 
goal agenda section hand divides tasks small subtasks added goal deletion section prevents planner putting blocks stacks block beneath needs moved 
cases achieving goals earlier entries goal agenda cuts goals ahead 
aware blocks need stack achieving goals ahead planner put current blocks stacks need disassembled 
happens blocks depends randomly specific task actions planner chooses planner find way situation 
probably instances ff couldn solve competition 
schedule domain schedule domain planner facing bunch objects worked set machines planner required create job schedule objects shall assigned machines 
competition representation simple form quantified conditional effects 
example object gets painted red new color colors currently painted color anymore 
subset planners competition handle kind conditional effects 
runtime curves shown 
apart planners seen runtime curves ipp koehler holldobler 
ff outperforms planners orders magnitude remember time shown logarithmic scale 
concerning solution length ff plans tend slightly longer plans returned planners smaller instances 
optimal plans mips 
ff plan lengths optimal lengths average 
hsp finds longer plans ff range ff plan lengths average 
responsible outstanding runtime behavior ff schedule domain apparently helpful actions heuristic 
measuring example states percentage successors considered helpful usually close percent applicable actions considered planner 
example states ff looks solving size tasks successors altogether sum helpful successors 
better successors similar logistics domain lie shallow depths 
breadth search goes deeper steps schedule tasks competition suite 
goal agenda helps factor terms running time competition suite jobs need carried done 
fast plan generation heuristic search problem size ff hsp mips ipp runtime curves schedule instances planners handle conditional effects 
time shown logarithmic scale 
domain domain formalizes solitaire card game comes microsoft windows 
largest tasks entered competition size correspond directly real world sized tasks smaller tasks cards considered 
shows runtime curves best performing planners 
group best scaling planners shown hsp slowest stan fastest planner 
ff generally second place lot variation running times 
hand ff planner capable solving real world tasks size 
solves tasks 
shown planners guarantees plans optimal shown planners demonstrates superior performance concerning solution length 
stan produces unnecessarily long plans cases 
precisely tasks hsp ff manage solve hsp plan lengths range ff plan lengths average 
tasks solved mips ff plan lengths mips ff lengths average 
stan range average 
concerning ff runtime behavior big variation solving times capability solving larger tasks result way search algorithm arranged 
observed 
tasks get solved enforced hill climbing solved fast 
especially larger tasks enforced hill climbing runs dead situation cards moved anymore 
hoffmann nebel problem size ff hsp mips stan runtime curves tasks planners scaled bigger instances 
time shown logarithmic scale 
planner starts scratch complete best search takes time solve big instances quite reliably seen tasks size 
helpful actions works moderately selecting available actions better successors usually close lie depths steps 
domain final domain competition comes real world application moving sequences elevators need planned 
sequences due kinds restrictions need served 
formulate restrictions complex order preconditions representation koehler schuster 
planners handle full adl representation domain subdivided easier strips simple conditional effects classes full adl class expressive class numerical constraints number passengers elevator time needed considered 
show runtime curves participants full adl class 
ff outperforms full adl planners terms solution time 
noticed ipp generate provably optimal plans needs careful directly comparing running times 
hand ff plans quite close optimal instances range optimal solution lengths instances solved average 
fast plan generation heuristic search problem size ff ipp runtime curves elevator tasks planners handled full adl domain representation 
time shown logarithmic scale 
large variation ff running times apparently due phenomenon variation observed enforced hill climbing runs dead causes switch best search solving task time reliably 
helpful actions percentage takes low values average breadth search rarely goes deeper steps large majority better successors lies depth 
examples section results obtained domains aips competition 
give examples domains ff works illustrate intuitions reasons ff behavior examples domains ff appropriate 
evaluation ran ff collection benchmark planning domains including domains aips aips competitions domains literature 
precisely domains suite assembly operator representation fridge grid gripper hanoi logistics adl simple strips movie mystery schedule tsp 
instances taken published distributions literature modified show scaling behavior 
times ff 
pddl files available online appendix 
hoffmann nebel measured sparc ultra running mhz main memory mbytes 
running times show planners taken machine indicated text 
ff shows extremely competitive performance domains listed 
mystery shows satisfying behavior 
examples aips competition ffl assembly domain 
ff solves tasks aips test suite seconds unsolvable specification errors 
planner know solve assembly tasks ipp solves small instances hours running time 
ff plan lengths terms number actions shorter ipp time step optimal ones ranging 
ffl domain 
classical domain objects need transported briefcase 
briefcase moved conditional effect forces objects inside briefcase move 
suite ipp easily solves tasks objects fails solve task 
ff hand solves objects tasks second 
tasks ipp solves plan lengths ff ipp lengths average 
ffl grid domain 
competition featured instances 
tasks fastest planning mechanism know literature version grt enhanced simple kind domain dependent knowledge supplied user 
solves tasks seconds mhz machine 
ff solves tasks seconds respectively 
plan lengths ff grt lengths average 
ffl gripper domain competition 
number states ff evaluates returning optimal sequential solution linear size task 
biggest aips example gets solved seconds 
ffl domain 
original task formulated stuart russel asks planner find replace flat tire 
koehler hoffmann modified task arbitrary number tires need replaced 
ipp goal agenda technique solves tire tasks seconds respectively exhausts memory resources soon 
ff scales larger tasks tenth second solving tire task seconds 
ff plan lengths tasks ipp manages solve equally long terms number actions 
said intuition majority currently available benchmark planning domains represented domain collection simple structure simplicity solvable easily greedy algorithm ff 
illustrate intuitions give data domains simple structure 
challenging ff 
fast plan generation heuristic search mystery domains mystery domains aips competition 
variations logistics domain additional constraints capacity vehicle particular amount fuel available 
domains closely related difference fuel items transported locations item 
compare ff results domains reported drew mcdermott system mcdermott 
mystery ff ff task time steps time steps time steps time steps prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob prob running times solution length results aips mystery suites 
instances domains 
results taken mcdermott mhz pentium ii workstation mcdermott 
dash indicates task couldn solved corresponding planner 
needs careful comparing running times ff coded written lisp 
apparent runtime superiority ff significant 
contrary solve task collections reliably ff finds solutions mystery instances ff manage solve 
planners superior terms solution lengths mystery ff ranges lengths average ff ranges average 
think ff behavior domains due large amount dead ends corresponding state spaces tried randomize ff search strategy running hoffmann nebel mystery suits 
regardless randomization strategy tried tasks original ff couldn solve search ended stuck dead 
dead ends frequent phenomenon mystery domains example important vehicle run fuel 
sense tasks domains complex structure lot benchmark domains tasks dead free 
depending randomly task structure selected actions ff solve mystery tasks quite fast fails encounters dead state enforced hill climbing 
trying solve tasks complete best search exhausts memory resources larger instances 
random sat instances example domain classical planning benchmark 
give example planning task collection ff really encounters difficulties created planning domain containing hard random sat instances 
shows runtime curves ff ipp blackbox 
variables ff ipp blackbox runtime curves ff ipp blackbox run hard random sat instances increasing number variables 
tasks solvable sat instances randomly generated fixed clause length model times clauses variables mitchell selman levesque 
random instance generation translation software pddl provided jussi rintanen 
shows running times sat instances variables tasks size 
values tasks fast plan generation heuristic search size displayed turn data points axis show running times variable tasks 
data set small observation clear ff solve small instances bigger ones 
ipp blackbox scale better tendency blackbox fastest 
encoding sat instances 
operator corresponds assigning truth value variable clauses true contain respective literal 
variable assigned value fixed 
goal having clauses true 
surprising blackbox best 
planner uses sat technology solving tasks 
ipp ff search space space partial truth assignments 
due exclusion relations ipp rule quite assignments early finds completed 
ff hand reasoning gets lost exponential search space heuristic merely tells variables need assign truth values unaware interactions occur 
contrast current benchmark planning domains finding non optimal solution planning tasks np hard 
ff behavior tasks supports intuition ff efficiency due inherent simplicity planning benchmarks 
difference hsp 
questions authors asked frequently aips planning competition ff closely related hsp perform better 
ff uses basic ideas classical hsp forward search state space heuristic evaluation ignoring delete lists bonet geffner 
differences lie way ff estimates goal distances search strategy ff pruning techniques 
obtain picture new technique yields performance results conducted number experiments techniques turned independently 
combinations techniques measured runtime solution length performance large set planning benchmark tasks 
section describe experimental setup summarize findings 
raw data detailed graphical representations results available online appendix 
experimental setup focused investigation ff key features restricted experiments ff base architecture account ff new techniques 
remember ff base architecture cf 
section enforced hill climbing algorithm ff goal distances estimates pruning search space helpful actions heuristic 
additional techniques integrated deal special cases added goal deletion heuristic goal agenda concerned goal orderings complete best search serves kind safety net local search run dead 
considering techniques independently give different planner configurations 
special case techniques yields savings small subset 
experiments ran blackbox default parameters 
boost performance parameter tuning 
hoffmann nebel domains large groups configurations behave exactly majority domains 
decided concentrate ff fundamental techniques 
differences classical hsp ff base architecture 
goal distance estimates hsp approximates relaxed solution lengths computing certain weight values ff extracts explicit relaxed solutions cf 
section 
search strategy classical hsp employs variation standard hill climbing ff uses enforced hill climbing introduced section 
pruning technique hsp expands sons search node ff expands sons considered helpful cf 
section 
implemented experimental code algorithmic differences attached switch turning new technique 
different configurations switches yield different heuristic planners 
switches resulting planner exactly ff base architecture 
switches intention imitate classical hsp hsp aips competition 
concerning goal distance estimates switch pruning techniques switch implemented original methods 
concerning search strategy simple hill climbing design ffl select best evaluated successor randomly 
ffl keep memory past states avoid cycles hill climbing path 
ffl count number consecutive times child node improve heuristic estimate 
counter exceeds threshold restart threshold times initial state goal distance estimate 
ffl keep visited nodes memory restart trials order avoid multiple computation heuristic state 
hsp variations restart techniques implemented 
personal communication bonet hector geffner decided imitate variations affect behavior special cases simplest possible design 
compared performance implementation switches turned performance hsp running planners untyped strips domains input required hsp 
domains tasks solved planners 
logistics planner solved tasks apparently due implementation details hsp visit states planner smaller tasks ran memory larger tasks 
hanoi restarting techniques difference hsp solve tasks tire restarts getting close goal planner solves tasks tires hanoi implementation cope discs reason hsp solves tasks discs 
altogether cases close correspondence behavior hsp configuration switches turned 
case experiments provide useful insights fast plan generation heuristic search performance enforced hill climbing compared simple straightforward hill climbing strategy 
obtain data set large example suite containing total planning tasks benchmark domains 
said section domains assembly operator representation fridge grid gripper hanoi logistics adl simple strips movie mystery schedule tsp 
hanoi tasks discs moved domains different instances 
small instances produce noisy data tried avoid rejecting tasks solved ff seconds 
possible domains movie tasks aips suite get solved seconds 
blocksworld representations randomly generated tasks blocks state generator provided john slaney 
assembly grid aips instances plus number randomly generated ones similar size biggest examples competition suites 
gripper tasks contained balls transported 
remaining competition domains larger instances respective competition suites 
randomly generated large tasks objects locations respectively 
fridge compressors exchanged wheels needed replaced tsp locations needed visited 
pddl files available online appendix 
configurations switches ran respective planner tasks example suite 
configurations randomized hill climbing run times task results averaged 
complete experiments reasonable time restricted memory consumption mbyte time consumption seconds usually ff needs time memory planning task reasonable size doesn manage solve 
said section raw data available online appendix accompanied detailed graphical representations 
summarize results discuss interesting observations 
examined data separately domain algorithmic techniques typically show similar behavior tasks domain 
contrast essential differences behavior technique applied tasks different domains 
running time running time investigation configuration find solution plan task set respective running time value time limit seconds configuration terminate faster finding plan example enforced hillclimbing planner running dead 
designate switch configuration letters stands helpful actions stands enforced hillclimbing stands ff estimates 
switch turned respective letter replaced gamma ff base architecture configuration hsp imitation gamma gamma gamma gamma gamma example hill climbing hsp goal distances helpful hoffmann nebel actions pruning 
impression running time results see averaged values domain 
gamma gamma gamma gamma gammaf gammae gamma gamma gamma gammaf gamma assembly blocksworld ops blocksworld ops fridge grid gripper hanoi logistics adl simple strips movie mystery schedule tsp averaged running time domain configurations switches 
shows domain configuration averaged running time instances domain 
instances domain size typically scale smaller large tasks averaging running times course crude approximation runtime behavior 
data provides general impression runtime results domain gives hints phenomena data 
compare example values right hand side planners helpful actions left hand side planners expanding sons search nodes 
right hand side values higher domains considerably lower 
especially true rightmost columns showing values planners helpful actions enforced hill climbing 
indicates main sources performance lie pruning technique search strategy looking rightmost gamma columns differ goal distance estimate configuration values usually close compared configurations domain 
put observations solid basis looked domain pair configurations turn amounting pairs planner performances 
pair decided configuration performed significantly better 
decide significance counted number tasks fast plan generation heuristic search configuration solved faster 
reliable criterion things difference running times task 
tasks grow size taken population finite mean size parametric statistical procedures computing significance intervals runtime differences questionable assumptions distribution data 
non parametric statistical test 
assume planners perform equally domain 
random instance domain probability faster equal probability faster take null hypothesis 
hypothesis behave differently instance faster probability tasks faster distributed tasks different behavior binomial distribution compute probability observed outcome null hypothesis tasks behave differently tasks faster compute probability binomial distribution positive outcomes obtained trials 
probability equal reject null hypothesis say performs significantly better symmetrically decide performs significantly better domains movie tasks configurations behaved equally exactly solved configurations 
cases configuration performed significantly better configuration faster instances different behavior 
faster instance 
particularly interested pairs configurations results turning switches leaving unchanged 
deciding significant improvement cases tells effect respective technique performance domain 
pairs configurations switch turned 
shows findings cases 
understood follows 
shows results switches active turn left right 
switches configurations background switches displayed columns table 
column behavior respective background configuration active switch turned compared behavior active switch turned 
performance improved significantly table shows significantly degraded table shows gamma respective table entry empty 
example consider top left corner switch active background configuration gamma gamma hill climbing helpful actions 
planner gamma gamma gamma hsp distances planner gamma gammaf ff distances 
performance significantly better indicated 
contrast background configuration gammae column right enforced hill climbing helpful actions significant change switch hsp ff goal distances 
leftmost columns show results hsp distance estimates versus ff distance estimates 
clearly estimates superior domains sense background configuration behavior gets significantly improved domains 
contrast cases altogether performance gets worse 
quite scattered domains background configurations indicating lot result interactions techniques hoffmann nebel domain gamma gamma gammae gamma gamma gamma gammaf gamma hf gamma gamma gammaf gamma ef assembly gamma blocksworld ops blocksworld ops gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma fridge gamma gamma gamma grid gripper gamma hanoi logistics gamma adl simple strips movie mystery schedule gamma gamma tsp effect turning single switch keeping unchanged 
summarized terms significantly improved degraded running time performance domain switch configurations 
occur context certain domains 
example performance degraded background configuration uses helpful actions improved background configuration uses enforced hill climbing helpful actions 
kind behavior observed domain 
domains performance improved background configuration 
apparently cases interaction techniques occurs specific configuration 
running times ff estimates little better hsp estimates behavior gets improved reliably instances small factor get idea compare differences average running times configurations distance estimate changes 
domains ff estimates improve performance consistently background configurations indicating real advantage different distance estimates 
gripper described section example 
robot room holds ball ff heuristic prefers picking ball moving room picking action leads state better evaluation 
balls left room hsp heuristic estimate picking ball gamma estimate moving room 
fast plan generation heuristic search balls left room moving room gets better evaluation 
summing weights hsp overestimates usefulness moving action 
comparing hill climbing versus enforced hill climbing looking columns middle observation 
different search technique bit questionable background configuration helpful actions enforced hill climbing yields excellent results 
helpful actions performance gets degraded times gets improved helpful actions enforced hill climbing improves performance significantly domains 
draw 
search strategy adequate depends domain 
simple example hanoi domain hillclimbing restarts reach goal paths goal exponentially state transitions son better evaluation father 
second interaction enforced hill climbing helpful actions pruning occurs consistently planning domains 
explained effect pruning technique different search strategies 
hill climbing helpful actions pruning prevents planner looking superfluous successors single state path goes 
saves time proportional length path 
effects enforced hill climbing drastic 
helpful actions prunes unnecessary successors state breadth search cuts branching factor yielding performance speedups exponential depths encountered 
compare consideration actions versus consideration helpful ones 
look rightmost columns 
observation simply helpful actions really helpful improve performance significantly planning domains 
especially true background configurations enforced hill climbing due interaction outlined 
domains helpful actions pruning imposes rigid restriction search space schedule said section states hundreds successors considered helpful 
domains actions pruned hanoi actions applicable state considered helpful cases 
small degree restriction usually lead significant improvement performance 
domains helpful actions prune possibilities cut away solution paths 
happens relaxed plan ignore things crucial solving real task 
consider briefly described section objects need moved briefcase 
briefcase moved objects inside moved conditional effect 
relaxed planner needs take object briefcase delete effects say moving object means object longer start location 
ignoring keeping objects inside briefcase hurts 
solution length investigated effects ff new techniques solution length 
comparing configurations took data set respective solution length hoffmann nebel tasks managed solve obviously point comparing solution length planner find solution 
counted number tasks behaved differently number solution shorter decided significance described section 
shows results cases single switch turned 
domain gamma gamma gammae gamma gamma gamma gammaf gamma hf gamma gamma gammaf gamma ef assembly blocksworld ops blocksworld ops fridge gamma gamma grid gripper gamma hanoi logistics adl simple strips movie gamma gamma gamma gamma mystery schedule gamma tsp effect turning single switch keeping unchanged 
summarized terms significantly improved degraded solution length performance domain switch configurations 
data organized obvious manner analogous 
glance table tells ff new techniques useful shortening solution length comparison hsp useful improving runtime behavior 
focus leftmost columns hsp distance estimates versus ff distance estimates 
observations enforced hill climbing background ff estimates result shorter plans domains solution lengths improved background configurations 
concerning second observation due properties domain ff heuristic recognizes hsp doesn 
recall observed gripper domain preceding section 
robot standing room holding ball ff heuristic gives picking ball better evaluation moving room hsp heuristic doesn 
hsp heuristic results longer plans 
concerning observation improved fast plan generation heuristic search solution lengths enforced hill climbing background explanation 
greedy way enforced hill climbing builds plans just better suited distance estimates cautious low 
consider columns middle hill climbing versus enforced hill climbing 
cases different search strategy results shorter plans 
due different plateau behavior search methods exhibit behavior flat regions search space 
enforced hill climbing enters plateau performs complete search state better evaluation adds shortest path state current plan prefix 
hill climbing enters plateau randomly hits state better evaluation restarts 
actions journey better state kept final plan 
movie phenomenon 
planner chooses reset counter vcr chooses rewind movie initially heuristic distinction actions reset counter 
enforced hill climbing planners reset counter 
hill climbing planners hand randomly choose ordering equal probability 
said section hill climbing tries task results averaged 
tries half solutions correct ordering tasks average value lower corresponding value enforced hill climbing planners 
compare consideration actions versus consideration helpful ones results depicted rightmost columns 
coming bit unexpected single case solution length performance degraded turning helpful actions 
indicates actions shortest path goal fact usually considered helpful solution paths thrown away case domains 
quite way round think pruning search space helpful actions leads significantly shorter solution plans especially underlying search method hillclimbing 
may sound paradoxical simple explanation 
consider said plateau behavior hill climbing randomly adding actions current plan search better state 
search engine armed helpful actions successors choice focusing direction goals take steps find way plateau 

related important connections ff approach methodologies reported literature ffl hsp basic idea forward state space search heuristic evaluation ignoring delete lists bonet geffner 
ffl view heuristic special case graphplan blum furst connection hsp heuristic method 
ffl similarity helpful actions heuristic mcdermott favored actions irrelevance detection mechanisms nebel 
hoffmann nebel ffl inspiration added goal deletion heuristic done koehler hoffmann adaption goal agenda approach koehler 
ffl adaption ipp adl preprocessing phase koehler hoffmann inspired ideas knoblock 
discussed connections respective sections 
focus connection mentioned 
recognized planning competition aips main bottleneck hsp recomputation heuristic single search state 
approaches observation repeated recomputation necessary hsp forward search forward heuristic directions search heuristic 
authors hsp stick heuristic change search direction going backwards goal hsp bonet geffner 
way need compute weight values estimating fact distance initial state sum weights state search 
invert direction hsp heuristic 
hsp computes distances going current state goal grt goes goal fact 
function extracts state forward search states heuristic estimate uses pre computed distances information facts probably achieved simultaneously 
interestingly ff recomputes hsp heuristic scratch search state outperforms approaches 
seen section part due ff search strategy helpful actions pruning technique 

outlook approach domain independent planning time outperforms existing technology majority currently available benchmark domains 
just known hsp system relies completely forward state space search heuristic evaluation states ignoring delete lists 
hsp method uses graphplan style algorithm find explicit relaxed solution search state 
solutions give careful estimation state difficulty 
second major difference hsp system employs novel local search strategy combining hillclimbing complete search 
method powerful heuristic pruning techniques examining relaxed solutions 
mentioned earlier intuition reasons ff efficiency lie structural properties current planning benchmarks tend 
matter fact simplicity benchmarks quite immediately meets eye tries look 
clear gripper tasks balls need transported room exhibit totally different search space structure example hard random sat instances 
intuitively unsurprising different search methods appropriate tasks traditionally 
efficiency ff benchmarks seen putting observation surface 

hsp integrated hsp option configuring search process bonet geffner 
fast plan generation heuristic search explicit hypotheses stated currently investigating state spaces planning benchmarks 
frank 
strand research collection empirical data identifying characteristic parameters different kinds planning tasks density size local minima plateaus search space 
approach hypotheses theoretical point view measure degree interaction facts planning task exhibit draw search space structure 
goal research arrive taxonomy planning tasks dividing degree complexity state spaces exhibit respect relaxed goal distances devise method automatically decides part taxonomy planning task belongs 
context remarks ai planning research heading 
point view goal field develop technology works kinds tasks express planning languages 
hardly possible simple languages strips express np hard problems sat 
possible devise technology works tasks human solver works 
planning task constitute problem uninformed human solver planning algorithms 
ff system method accomplishes quite sequential planning strips adl 
remains get formal notion simple planning task 
taxonomy planning tasks currently aiming offers possible answer 
experience tasks intuitively easy exhibit simple state space structure respect relaxed goal distances 
best exemplified simple huge tasks contained gripper logistics collections comparison random sat instances section 
fact degree interaction occurs task trying achieve goals key factors determining difficulties human solver encounters solving task 
sheds critical light predictions kautz selman suspected planning technology superfluous fast advance state art propositional reasoning systems 
methods developed surely useful solving sat 
appropriate typical structures tasks ai planning interested 
acknowledgments authors wish bonet hector geffner help setting experiments comparison ff hsp 
jussi rintanen providing software create random sat instances pddl language acknowledge anonymous reviewer comments helped improve 
aips 
proceedings th international conference artificial intelligence planning systems aips 
aaai press menlo park 
hoffmann nebel aips 
proceedings th international conference artificial intelligence planning systems aips 
aaai press menlo park 
anderson smith weld 

conditional effects graphplan 
aips topology pp 

bacchus 

subset pddl aips planning competition 
aips planning competition 
bacchus nau 

ai planning systems competition 
ai magazine 
forthcoming 
fox 
eds 

advances ai planning 
th european conference planning ecp durham uk 
springer verlag 
blum furst 

fast planning planning graph analysis 
proceedings th international joint conference artificial intelligence ijcai pp 
montreal canada 
morgan kaufmann 
blum furst 

fast planning planning graph analysis 
artificial intelligence 
bonet geffner 

hsp heuristic search planner 
aips planning competition pittsburgh pa bonet geffner 

planning heuristic search new results 
fox fox 
bonet geffner 

planning heuristic search 
artificial intelligence 
forthcoming 
bonet geffner 

robust fast action selection mechanism planning 
proceedings th national conference american association artificial intelligence aaai pp 

mit press 
bylander 

computational complexity propositional strips planning 
artificial intelligence 
cheng irani 

ordering problem subgoals 
ijcai ai planning 
th european conference planning ecp pp 

drummond currie 

goal ordering partially ordered plans 
ijcai pp 



heuristic search planning bdds 
ecai workshop 


np completeness arrangement problems 
tech 
rep department computer science haifa israel 
fikes nilsson 

strips new approach application theorem proving problem solving 
artificial intelligence 
fast plan generation heuristic search fox long 

automatic inference state invariants tim 
journal artificial intelligence research 
frank cheeseman stutz 

gravity fails local search topology 
journal artificial intelligence research 
knoblock 

combining expressiveness ucpop efficiency graphplan 
steel alami steel alami pp 

hoffmann 

heuristic domain independent planning enforced hill climbing algorithm 
proceedings th international symposium methodologies intelligent systems ismis pp 

springer verlag 
holldobler 

solving entailment problem fluent calculus binary decision diagrams 
proceedings international conference computational logic cl 
appear 
ijcai 
proceedings th international joint conference artificial intelligence ijcai detroit mi 
morgan kaufmann 
irani cheng 

subgoal ordering goal augmentation heuristic problem solving 
mcdermott 
ed proceedings th international joint conference artificial intelligence ijcai pp 
milan italy 
morgan kaufmann 
jonsson backstrom 

planning randomized approach 
artificial intelligence 
joslin roach 

theoretical analysis conjunctive goal problems 
artificial intelligence 
kambhampati parker lambrecht 

understanding extending graphplan 
steel alami steel alami pp 

kautz selman 

unifying sat graph planning 
proceedings th international joint conference artificial intelligence ijcai pp 
stockholm sweden 
morgan kaufmann 
kautz selman 

pushing envelope planning propositional logic stochastic search 
proceedings th national conference american association artificial intelligence aaai pp 

mit press 
koehler 

solving complex planning tasks extraction subproblems 
aips aip pp 

koehler hoffmann 

reasonable forced goal orderings agenda driven planning algorithm 
journal artificial intelligence research 
hoffmann nebel koehler hoffmann 

instantiation adl operators involving arbitrary order formulas 
proceedings ecai workshop new results planning scheduling design 
koehler nebel hoffmann dimopoulos 

extending planning graphs adl subset 
steel alami steel alami pp 

koehler schuster 

elevator control planning problem 
aips ai planning 
th european conference planning ecp 
long fox 

efficient implementation plan graph stan 
journal artificial intelligence research 
long fox 

extracting route planning steps automatic problem decomposition 
proceedings aips workshop analysing exploiting domain knowledge efficient planning 
mcallester rosenblitt 

systematic nonlinear planning 
proceedings th national conference american association artificial intelligence aaai pp 
anaheim ca 
mit press 
mcdermott 

heuristic estimator means ends analysis planning 
proceedings rd international conference artificial intelligence planning systems aips pp 

aaai press menlo park 
mcdermott 

pddl planning domain definition language 
aips planning competition 
mcdermott 

regression match graphs control search planning 
artificial intelligence 
mitchell selman levesque 

hard easy distributions sat problems 
proceedings th national conference american association artificial intelligence aaai pp 
san jose ca 
mit press 
nebel 

expressive power propositional planning formalisms 
journal artificial intelligence research 
nebel dimopoulos koehler 

ignoring irrelevant facts operators plan generation 
steel alami steel alami pp 

pednault 

adl exploring middle ground strips situation calculus 
brachman levesque reiter 
eds principles knowledge representation reasoning proceedings st international conference kr pp 
toronto 
morgan kaufmann 


grt domain independent heuristic strips worlds greedy regression tables 
fox fox 


exploiting state constraints heuristic state space planning 
aips aip pp 

fast plan generation heuristic search russell norvig 

artificial intelligence modern approach 
prentice hall englewood cliffs nj 
slaney 

blocks world revisited 
artificial intelligence 
steel alami 
eds 

advances ai planning 
th european conference planning ecp vol 
lecture notes artificial intelligence toulouse france 
springer verlag 

