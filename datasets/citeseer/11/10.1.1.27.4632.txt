inductive logic programming theory methods stephen muggleton luc de raedt journal logic programming 
inductive logic programming ilp new discipline investigates inductive construction order clausal theories examples background knowledge 
survey important theories methods new field 
firstly various problem specifications ilp formalised semantic settings ilp yielding model theory ilp 
secondly generic ilp algorithm 
thirdly inference rules corresponding operators ilp resulting proof theory ilp 
fourthly inductive inference produce statements assured follow inductive inferences require alternative form justification 
take form probabilistic support logical constraints hypothesis language 
information compression techniques ilp unifying bayesian approach confirmation corroboration hypotheses 
different ways constrain hypothesis language specify declarative bias 
advanced topics ilp addressed 
include aspects computational learning theory applied ilp issue predicate invention 
survey applications implementations ilp 
ilp applications fall different categories firstly scientific discovery knowledge acquisition secondly programming assistants 

inductive logic programming ilp defined intersection inductive learning logic programming 
ilp employs techniques address correspondence university computing laboratory wolfson building parks road oxford ox qd uk 
address correspondence 
computing science katholieke universiteit leuven celestijnenlaan heverlee belgium 
machine learning logic programming 
inductive machine learning ilp inherits goal develop tools techniques induce hypotheses observations examples synthesise new knowledge experience 
computational logic representational mechanism hypotheses observations inductive logic programming overcome main limitations classical machine learning techniques top induction decision tree tdidt family 
limited knowledge representation formalism essentially propositional logic 
difficulties substantial background knowledge learning process 
limitation important domains expertise expressed order logic variant order logic propositional 
problem obvious domain logic program synthesis examples 
logic programs defined propositional logic 
domain knowledge crucial wellestablished findings artificial intelligence domain knowledge essential achieving intelligent behaviour 
logic offers elegant formalism represent knowledge incorporate induction task 
computational logic inductive logic programming inherits representational formalism semantical orientation various established techniques 
contrast approaches inductive learning inductive logic programming interested properties inference rules convergence algorithms computational complexity procedures 
inductive logic programming systems benefit results computational logic 
additional benefit potentially derived making termination types modes knowledge base updating algorithmic debugging abduction constraint logic programming program synthesis program analysis 
inductive logic programming extends theory practice computational logic investigating induction deduction basic mode inference 
computational logic theory describes deductive inference logic formulae provided user inductive logic programming theory describes inductive inference logic programs instances background knowledge 
manner ilp may contribute practice logic programming providing tools assist logic programmers develop verify programs 
ilp distinguished traditional investigations inductive inference areas grammatical induction induction finite state automata emphasis universal representation 
clearly universal representations promise wider scope applicability 
logic programs arguably easier manipulate machine learning algorithm universal representations investigated universal turing machines programs lisp programs 
due fact pure clausal logic changes program simply adding deleting complete clauses literals clause worrying ordering effects 
semantics logic programs closely allied syntax changes clear simple effect generality resulting program 
addition logic programs allow single representation examples background knowledge hypotheses 
provide ilp 
focusses believe foundations field 
bottom describing small differences different systems 
top synthetic overview concepts terminology methods 
overly concerned discussing implementation details particular systems approaches differences quite minor great interest general audience 
aim providing conceptual framework presenting ilp levels description semantic level defining problem ilp generic ilp algorithm level proof theoretic level defining inference rules ilp probabilistic semantics belief defining justification induced hypotheses 
organised follows 
section introduce inductive logic programming informally means examples section formally define problem inductive logic programming model theoretic semantic level section provide generic ilp algorithm section study inductive inference rules ilp yielding proof theory ilp section information compression techniques ilp unifying bayesian approach confirmation corroboration hypotheses section survey methods constrain search space ilp syntactic semantic bias section convergence computationally complexity ilp learnability investigated section problem inventing new predicates addressed section various ilp implementations discussed compared section applications ilp scientific discovery automatic programming summarised section conclude 
appendix contains list symbols notations 

general setting inductive inference common form everyday reasoning 
consider examples 

family example imagine learning relationships people close family circle 
told grandfather father parents know parent beliefs 
grandfather father parent father henry jane mother jane john mother jane alice facts positive examples concerning relationships particular grandchildren 
ae grandfather henry john grandfather henry alice told addition relationships hold negative examples 
gamma ae grandfather john henry grandfather alice john believing faced new facts gamma guess relationship 
parent mother note consequence gamma gamma prior satisfiability allows explain relative posterior sufficiency note consistent gamma gamma posterior satisfiability question arises possible derive tentatively hypothesis 
example tweety suppose know birds bird bird bird carnivore imagine expedition upper za ire basin comes creature shall call convenience tweety 
expedition leader know tweety wings beak 
represented logic program ae tweety tweety negative examples take inspired belief set hazard guess tweety bird 
written bird tweety seen working hypothesis tweety 
clearly refuted evidence revealed tweety plastic require sophisticated belief set 
note grandfather example allows explain relative note entertain speculative hypothesis tweety explain evidence 
tweety know speculative 

sorting example inductive inference viewed form program synthesis 
imagine learning program taught logic program quick sort 
definitions provided background knowledge 
part part jt js 
partition part jt js part app app xjt xjr app program provided set positive ground examples quick sort qsort qsort qsort negative examples gamma qsort qsort case hope algorithm sufficient number examples suggest clauses quick sort 
qsort qsort xjt part qsort qsort app xjs ilp systems golem foil learn definition quick sort examples 
background knowledge required learn quick sort mentioned ilp systems able select correct hypothesis huge space possible hypotheses 
parts employ background theory examples easy induce permutation sort 
perm perm xjp del perm del xjt del jt jt del sorted sorted sorted jt sorted jt 
inductive inference philosophy science form reasoning demonstrated examples known inductive inference common natural sciences 
aristotle describes posterior analytics 
francis bacon discussing empiricism new natural sciences th century gave numerous examples inductive inference paradigm scientific method 
despite efforts philosophers hume mill pierce popper carnap foundations inductive reasoning clear deductive mathematical logic 
researchers computer science attempted varying degrees success find logical basis inductive inference 
researchers included plotkin shapiro new school inductive logic programming 
describe theoretical basis inductive logic programming framework order predicate calculus bayesian statistics algorithmic complexity theory 
examples generally involve definite clauses results extend quite naturally full clausal logic see section 
theory ilp related implementations applications 

hypothesis formation justification examples sections clear process hypothesis formation abduction hypothesis justification need clarification 
assumed induction abduction justification abduction 
philosopher pierce abduction process hypothesis formation 
term logic programming 
denote form non monotonic reasoning see section 
pierce describes basis abduction follows hypothesise extensive definition appropriate ilp section 
justification 
degree belief ascribed hypothesis certain amount evidence 
followers carnap talk degree confirmation claiming absolute justification possible 
hand follower popper see problem justification problem deciding competing hypotheses 
talk corroboration 
term justification introduce nexus related problems 
problem justification discussed detail section 
fact scientific theory formation involves elements induction 
facts gathered experiments planned alternative theories tested 
abduction justification seen central components process 
ilp applications section involved discovery new pieces scientific knowledge empirical evidence 
ilp potentially contributes experimentation testing hypotheses 

model theory ilp logical elements semantics involved inductive inference described relationships hold 
describe different semantics ilp normal non monotonic semantics discuss definite semantics gamma roughly speaking gamma special case normal semantics 
employ notion syntactic bias see section 
syntactic bias defines set formed hypotheses constitutes parameter ilp task 
syntactic bias omni ilp write explicitly assume hypotheses wellformed regard bias 

normal semantics general setting ilp allow examples background theory hypotheses formed logical formula 
problem inductive inference follows 
background prior knowledge evidence evidence gamma consists positive evidence negative evidence gamma aim find hypothesis conditions hold 
definition 
normal semantics prior satisfiability 
gamma posterior satisfiability 
gamma prior necessity 
posterior sufficiency 
sufficiency criterion named completeness regard positive evidence posterior satisfiability criterion known consistency negative evidence 
ilp systems background theory hypotheses restricted definite 
definite setting simpler general setting definite clause theory unique minimal herbrand model logical formulae true false minimal model 
setting formalised definite setting definition 
definition 
definite semantics prior satisfiability 
gamma false posterior satisfiability 
gamma false prior necessity 
false posterior sufficiency 
true special case definite semantics evidence restricted true false ground facts examples called example setting 
notice example setting equivalent normal semantics definite clauses set ground unit clauses 
example setting main setting ilp 
employed large majority ilp systems important setting 
example setting illustrated section 
reason allowing evidence examples definite semantics useful allow general clauses evidence cf 
section 
clausal evidence usually captures knowledge factual evidence consisting ground facts 
instance family example section positive example grandfather henry john father henry jane mother jane john positive evidence include grandfather stating grandfather 
analogously sorting example section sorted quicksort quicksort sorted positive evidence definition sorted background theory 
clausal evidence provides learner incomplete partial specification sorting predicate 
constrains space acceptable hypotheses 
positive evidence true minimal model hypothesis theory negative evidence false setting 

non monotonic semantics non monotonic setting ilp introduced nicolas flach variants considered 
define variant related normal setting 
non monotonic setting ilp background theory set definite clauses evidence empty hypotheses sets general clauses expressible alphabet background theory 
reason evidence empty positive evidence considered part background theory negative evidence derived implicitly making kind closed world assumption realised minimal herbrand model 
term non monotonic introduced order link forms non monotonic reasoning relation closed world assumption variants 
non monotonic setting conditions hold definition 
non monotonic semantics validity true completeness general clause true minimality proper subset valid complete validity requirement assures clauses belonging hypothesis hold database true properties data 
completeness requirement states information valid database encoded hypothesis 
requirement understood regard syntactic bias determines set formed hypotheses see section 
minimality requirement aims deriving non redundant hypotheses 
illustrate non monotonic setting consider example taken assume hypothesis formed consists clauses containing single variable male luc female human human luc possible solution female male human male human female female male human explain differences example setting non monotonic setting consider ae bird tweety bird oliver lies tweety acceptable hypothesis example setting flies bird 
notice clause realises inductive leap flies oliver true 
hand solution non monotonic setting exists substitution fx clause false non valid 
demonstrates non monotonic setting properties hold database 
non monotonic semantics realises induction deduction 
induction principle non monotonic setting states hypothesis sense deduced set observed examples background theory kind closed world closed domain assumption holds possible sets examples 
produces generalisation observations 
consequence properties derived non monotonic setting conservative derived normal setting 
differences settings related closed world assumption 
applications example setting ilp set positive examples specified set negative examples derived applying closed world assumption gamma gamma illustration results gamma oliver modified gamma hypothesis contribute solution normal setting 
hand ignore difference background theory examples define gamma gamma clause part solution normal setting 
intuitively shows solutions problems normal setting closed world assumption applied valid non monotonic setting 
theorem 
hypothesis posterior sufficient posterior satisfiable background theory examples gamma gamma valid non monotonic setting bp 
proof 
prove assumptions 
define bp ae true posterior sufficiency true true ae ae gamma posterior satisfiability gamma gamma ae bp gamma gamma ae opposite hold reveals main difference settings 
normal setting induced hypothesis replace examples theory hypothesis entail observed examples possibly examples 
non monotonic setting hypothesis consists set properties holding example set 
language bias cf 
section restricts syntactic form clauses explicit guarantee concerning prediction 
instance non monotonic setting language bias restricting hypotheses single clauses hypothesis solution predict example non monotonic semantics require closed domain assumption hold background theory evidence 
example medical application patients completely specified means symptoms diseases fully described 
notice different requiring complete universe described possible patients 
non monotonic normal semantics appear quite dif gamma ff gamma complement minimal herbrand model denotes negation definite clause program herbrand base ferent turn ilp techniques refinement apply frameworks 
semantics allow different kind application see section 
generic ilp algorithm section generic ilp algorithm model 
generic ilp algorithm abstraction specific ilp algorithms aims providing reader general understanding ilp algorithms implementations 
key observation leading generic ilp algorithm regard ilp search problem 
view ilp follows immediately ilp section 
ilp space candidate solutions set formed hypotheses constitutes syntactic bias language bias problem cf 
section acceptance criterion characterizing solutions ilp problem 
general artificial intelligence principles solve ilp naive generate test algorithm 
approach known literature enumeration algorithm 
artificial intelligence problems enumeration algorithm computationally expensive practical interest 
question arises space possible solutions structured order allow pruning search 
concept learning ilp search space typically structured means dual notions generalisation specialisation 
view generalisation corresponds induction specialisation deduction implying induction viewed inverse deduction definition 
hypothesis general hypothesis said specific search algorithms notions generalisation specialisation incorporated inductive deductive inference rules definition 
deductive inference rule maps conjunction clauses conjunction clauses called specialisation rule 
example deductive inference rule consider resolution 
dropping clause hypothesis realises specialisation 
definition 
inductive inference rule maps conjunction clauses conjunction clauses called generalisation rule 
example inductive inference rule absorption stick gamma probably controversial gamma view offers clear operational framework induction 
contrasts alternative frameworks mainly rest philosophical intuitions clear logical formalisations 
absorption rule absorption entails condition 
notice applying rule absorption reverse direction applying resolution deductive inference rule 
inductive inference rules generalise adding clause hypothesis dropping negative literal clause 
inductive inference rules absorption clearly sound 
fact applied unrestricted fashion spirit logical inference 
soundness problem circumvented associating hypothesised label hjb probability holds background knowledge evidence hold 
bayesian approach computing conditional probability section 
assuming subjective assignment probabilities consistent labelled rules inductive inference sound deductive inference 
simply claimed hold certain proportion interpretations generalisation specialisation form basis pruning search space 
ffl background theory hypothesis positive evidence specialisations imply evidence 
hypothesis assigned probability label jb 
pruned search 
ffl background theory hypothesis negative evidence generalisations inconsistent jb 
example family example section consider specialisations imply positive examples 
hand sorting example section consider generalisations hypothesis qsort inconsistent negative examples 
key ideas ilp search inference rules labeled hypotheses generic ilp system defined algorithm 
qh initialize repeat delete qh choose inference rules applied apply rules yield hn add hn qh prune qh criterion qh satisfied algorithm works follows 
keeps track queue candidate hypotheses qh 
repeatedly deletes hypothesis queue expands hypotheses inference rules 
expanded hypotheses added learning literature assignments degrees belief usually ad hoc section known inductive bias 
inductive bias taken binary accept reject assignment 
reject simply viewed prior probability zero 
queue hypotheses qh may pruned discard unpromising hypotheses consideration 
process continues criterion satisfied 
algorithm generic procedures type written 
algorithm generic parameters ffl initialize denotes hypotheses started 
ffl denotes set inference rules applied 
ffl delete influences search strategy 
different instantiations procedure realise depth delete lifo breadth delete fifo best algorithm 
ffl choose determines inference rules applied hypothesis ffl prune determines candidate hypotheses deleted queue 
usually realized labels probabilities hypotheses qh relying user employing oracle 
combining delete prune easy obtain advanced search strategies hill climbing beam search best ffl criterion states conditions algorithm stops 
frequently employed criteria require solution adequate hypothesis obtained current queue 
notice algorithm searches solutions hypotheses level clause level done algorithms foil golem 
take general approach 
example instantiation algorithm consider duce cigol algorithms realize hill climbing search strategy 
time delete invoked queue contains single hypothesis 
initially hypothesis inference rules inverting resolution see section details include absorption rule 
pruning phase best hypothesis kept discarded queue qh 
pruning realized mixture minimal description length principle see section relying user oracle decide clause true intended model 
duce cigol systems representatives class specific systems 
systems start examples background knowledge repeatedly generalize hypothesis applying inductive inference rules 
search take care hypothesis remains satisfiable imply negative examples 
representatives class include clint marvin golem pga 
dual class systems searches general specific starts general hypothesis inconsistent clause repeatedly specializes hypothesis applying deductive inference rules order remove inconsistencies negative examples 
search care taken hypotheses remain sufficient regard positive evidence 
systems type include foil claudien mis ml smart 
search strategies valid non monotonic setting cf 

non monotonic setting interested boundary maximally general hypotheses true minimal model 
boundary hypotheses false boundary false non maximal 
locate boundary search specific general general specific 
sections give detailed overview different types inductive inference rules applied ilp proof theory ilp see section provide unifying framework abstraction specific labelling schemes employed ilp probabilistic semantics ilp see section 
aspects lie heart ilp 
implementation aspects search strategy usually follow general artificial intelligence principles 

proof theory ilp section give detailed overview different frameworks inductive inference rules 
remember section induction viewed inverse deduction 
formulae deriving deduction deriving induction 
inductive inference rules obtained inverting deductive ones 
inverting deduction paradigm studied various assumptions corresponding different assumptions deductive rule format background theory evidence different models inductive inference obtained 
simplest model subsumption see section background knowledge supposed empty deductive inference rule corresponds subsumption single clauses 
deductive inference rule subsumption incomplete regard implication clauses extensions inductive inference subsumption studied header inverting implication see section 
extensions subsumption take account background knowledge studied section 
attractive complicated framework inductive inference studied section 
framework takes account background knowledge aims inverting resolution principle best known deductive inference rule 
going details different frameworks discuss difference inference rules inference operators important searching space hypotheses 

rules inductive inference operators recall section inference rules basically state inferred 
known problem artificial intelligence unrestricted application inference rules results combinatorial explosions 
control application inference rules artificial intelligence employs operators expand node search tree set successor nodes search 
properties generalisation specialisation discussed earlier motivates specialisation generalisation operators see definition 
specialisation operator maps conjunction clauses set maximal specialisations maximal specialisation special specialisation specialisation specialisation definition 
generalisation operator maps conjunction clauses set minimal generalisations minimal generalisation generalisation generalisation generalisation generalisation spirit restricting application inference rules usually imposes conditions operators 
conditions see require instance generated hypotheses satisfy language bias operators complete generate clauses language 
subsumption start discussing simplest model deduction ilp subsumption introduced plotkin definition 
clause subsumes clause exists substitution generalisation specialisation subsumption 
definition clauses seen sets positive negative literals 
subsumption inductive inference rule subsumption example father parent male subsumes father jef paul parent jef paul parent jef ann male jef female ann fx jef 

properties properties subsumption include see implication 
subsumes opposite hold self recursive clauses subsume deduction subsumption equivalent implication clauses see section 
infinite descending chains 
exist infinite descending chains 
series bounded 
simplified form subsumption studied steven vere 
equivalence 
exist different clauses equivalent subsumption parent mother mother subsumes parent mother vice versa 
clauses equivalent subsumption logically equivalent implication ilp systems generate clause equivalence class 
extended discussion equivalence see 
reduction 
get problem plotkin defined equivalence classes clauses showed unique representative variable renamings clause named reduced clause 
reduced clause clause minimal subset literals equivalent algorithm reduce clauses follows 
ilp systems get problem equivalent clauses working reduced clauses 
lattice 
set reduced clauses form lattice clauses unique lub general generalisation gamma lgg see clauses unique glb 

operators discuss specialisation subsumption 
shapiro introduced notion refinement operator ae clauses corresponds notion specialisation rule subsumption restriction contain single clause 
refinement operators basically employ operations clause 
apply substitution clause 
add literal set literals clause 
issues designing refinement operators 
definition assume specific language bias see section 
loss generality assume general element 
definition 
properties refinement operators global completeness 
refinement operator ae transitive closure ae globally complete language ae 
general element local completeness 
refinement operator ae transitive closure ae locally complete language ae fc maximal specialisation cg 
optimality 
refinement operator ae transitive closure ae optimal language ae ae ae ae 
reasons discussed desirable reduced clauses generated refinement operators refinement operator full clausal logic developed patrick van der 
secondly consider hypotheses operators globally complete preferably language containing reduced clauses 
thirdly heuristic general specific search strategy hill climbing foil employed operator locally complete 
operator locally complete successors node hypothesis search space considered 
hand complete search strategy breadth depth iterative deepening desirable operator optimal generate candidate clause exactly 
non optimal refinement operators shapiro mis generate candidate clauses getting trapped recomputing things 
optimal refinement operator full clausal logic developed wim van laer non monotonic setting claudien 
definitions properties generalisation operators subsumption single clauses derived refinement operators 
locally globally complete generalisation rule full clausal logic definite clause logic exists infinite descending chains 
additional assumptions language bias specific generalisation subsumption contains infinite number literals 
generalisation operators depend language bias employed 
discuss 
generalisation operators subsumption single clauses subsumption exist full clausal logic generalisation rule starts pairs clauses exist 
known general generalisation rule plotkin computes greatest lower bound input clauses subsumption 
compute lgg clauses consider 
lgg terms lgg lgg 
lgg terms variable represents pair terms 
lgg atoms lgg lgg lgg undefined sign predicate symbols unequal 
lgg clauses example lgg father tom ann parent tom ann male tom female ann father jef paul parent jef paul male jef male paul father parent male male 

relative subsumption plotkin extended notion subsumption relative subsumption follows 
defines derivations defines deductive inference rule way implemented 
definition 
resolution derivation clause conjunction clauses called derivation clause appears plotkin defines relative subsumption follows 
definition 
conjunction clauses relatively subsumes clause exists derivation clause subsumes subsumption straightforward define relatively reduced clauses straightforward definition relative clause equivalence 
relative tion forms lattice relatively reduced clauses 
plotkin defines relative general generalisation rlgg follows 
definition 
general generalisation clauses relative lub relative subsumption ordering 
plotkin shows rlgg clauses necessarily finite 
language bias ij determinacy introduced unique finite rlgg constructed 
buntine defined special case relative subsumption called generalised subsumption 
generalised subsumption applicable definite clauses 

inverting resolution stated section inductive inference rules viewed inverse deductive rules inference 
deductive rule resolution complete deduction inverse resolution complete induction 
idea inverse resolution introduced order logic 
authors expanded ideas 
rules inverse resolution introduced 
absorption identification intra construction inter construction rules lower case letters atoms upper case letters conjunctions atoms 
absorption identification invert single resolution step 
shown diagrammatically premises base arms 
new clause clause arm reason absorption identification called collectively operators 
rules inter intra construction introduce new predicate symbol 
inductive inference rules introduce new predicates said carry predicate invention see section 
constructing logic programs insertion sort ilp systems cigol intra construction introduce new predicate insert 
new predicate generalised operator 
diagrammatically see construction operators shown linked resolution 
premises placed bases top clauses shared resolutions 
intra inter construction 
absorption operator 
intra construction operator collectively called operators 
operators specific forms see definition shown see 
absorption identification intra construction inter construction note form operators realise generalisation specialisation entail premises 
specific operators usually implemented having stage operation 
phase inverse resolution operators applied examples called saturation 
second phase clauses reduced generalisation subsumption lattice see section 
shown lgg examples saturated relative background knowledge equivalent rlgg relative result established relationship generalisations subsumption inverse resolution 

matching just resolution requires unification match terms inverse resolution operators require matching operation 
clauses including examples flattened 
involves introducing new ary predicate ary function symbol 
clause member member dot dot nil new predicate symbol separately defined 
instance dot xjy flattening problem matching clauses applying inverse resolution operators reduces sided matching clause bodies 
saturation specific operations shown complete respect plotkin derivations see section 
kind completeness result demonstrated independently 
derivations cover cases problem known inverting implication 

inverting implication plotkin show subsumption implication clauses equivalent 
difference important inductive algorithms generalise order clauses invert subsumption implication 
inevitably leads form incompleteness algorithms 
section methods constructing inverse implicants clauses explored 
section shown methods extended problem inverting implication presence background knowledge 
difference plotkin subsumption implication clauses reviewed 
remember section clause subsumes clause implies converse hold 
instance plotkin shows clauses implies simply self resolved 
subsume discussing problem niblett proves various general results 
particular shows unique generalisation implication arbitrary pair clauses 
instance clause clause clause generalisations 
niblett claims implication horn clauses decidable shown false 
gottlob proves number properties concerning implication clauses 
notably gamma positive negative literals gamma subsumes gamma subsumes gamma 
sub unification problem inverting implication discussed matwin 
note inverse resolution section incapable reversing sld derivations hypothesised clause 
fact plotkin showed problem appears relative general generalisation clauses see definition derivations 
matwin go describe sub unification process matching sub terms 
demonstrate sub unification able construct recursive clauses fewer examples required ilp systems golem foil 
instance atoms append append sub unification construct recursive clause append jv xjy append approach taken originally inverse resolution matwin derive sub unification resolution 
sub unification definition general sub unifiers 
operations described matwin shown number examples clear general mechanism complete non deterministic algorithm inverting implication 
complete deterministic method almquist 
new simple inverse implication technique called forced simulation described 

implication resolution section relationship resolution implication clauses investigated 
definition equivalent robinson resolution closure 
function rl contains linear derivations robinson function closure equivalent renaming variables linear derivation opposed input derivation known complete 
definition 
resolution closure set clauses 
function rl recursively defined rl rl fc rl gamma resolvent resolution closure rl rl rl 
nth powers nth roots clauses set clauses constructed rl fcg partitioned levels function rl 
viewing resolution product operation muggleton buntine stated problem finding inverse resolvent pair clauses finding set quotients clauses 
analogy set rl fcg called squares clause rl fcg cubes definition captures idea 
definition 
nth powers clause clauses 
nth power alphabetic variant clause rl fcg 
analogy bit talk nth roots clause 
definition 
nth roots clause clauses 
nth root nth power terms nth roots clause 
corollary 
implication clauses terms nth roots arbitrary clause non tautological clause 
positive integer nth root clause subsumes fairly straightforward enumerate set clauses subsume clause 
problem finding set clauses imply clause reduces enumerating set nth roots clauses subsume special case clauses immediately subsume occurs 
algorithm constructing nth roots 

implication background knowledge normal setting inductive logic programming section generalisation carried presence background knowledge 
section solution inverting implication clauses extended case background knowledge 
assume background clausal theory clause example entailed assume single clause problem transformed involving implication single clauses follows 



line replaced conjunction ground literals derived 
viewed replacing formula model formula 
conjunction literals line represents implication clauses 
clause constructed finite length range restricted generative see elements model constructed finite depth resolution 
clause construct algorithm constructing nth roots 

probabilistic semantics confirmation belief utgoff mitchell bias influences concept learner draws inductive inferences evidence 
fundamentally different forms bias declarative bias defines space hypotheses considered learner search preference bias determines search space hypotheses focus ones prune section discuss probabilistic semantics ilp underly preference bias 
section presents different forms declarative bias 
generally candidate hypothesis explains examples need sound basis grading hypotheses preference bias 
ilp algorithms foil information techniques guide search 
section information compression techniques described unifying bayesian approach confirmation corroboration hypotheses 
relationship probabilistic view information view shown principles 
general approach advantage applicable positive examples available 

probability calculus deductive inference inductive inference assured follow known 
inductively inferred logical statement accompanied degree belief probability value see section 
probability calculus predicate calculus basis set theory 
venn diagram depicting intersecting sets universal set probability randomly chosen element written defined follows 
jpj juj similarly randomly chosen element probability written pjq pjq pjq probability known conditional probability 
noting pjq qjp 
venn diagram probabilities rearranging gives bayes theorem pjq qjp suppose represents set herbrand models wff wff pq set herbrand interpretations simply proportion interpretations models probability randomly chosen interpretation model jq proportion models models probabilistic interpretation order predicate calculus suggested philosopher science carnap 
properties gamma undefined infinite set herbrand models 

justification suppose attempting induce definition predicate positive examples 
abduction extreme solutions 
xn negative examples application posterior satisfiability condition section replace unique topmost element set topmost elements 
assume degree belief formula represented subjective probability 
bayes theorem follows 
je assume evidence correct 
mentioned carnap took view proportion interpretations models leads paradox finite set models infinite set interpretations necessarily false 
solomonoff took alternative approach probabilities re interpreting information terms 
recursively enumerable set finite information denoted finite formula 
theory infinite information 
ways solomonoff syntactically oriented approach provides usable approximation carnap probabilistic interpretation logic formulae 
carnap interpretation approach ascribe prior probabilities logic programs 
solomonoff case gammaoe oe number bits minimum encoding information content formula 
carnap solomonoff case number logic programs large prior probabilities sum prior probability particular logic program small 
larger logic programs composed smaller logic programs conjunction 
models logic programs independent average case 
independent carnap interpretation see 
shannon information theory information content logic program gammalog 
definition properties information content logic programs 
empty program 

empty clause 

additive composition 
implies 
note additive composition assumes independence corollary bayes theorem 
corollary 
information bayes 
represent evidence theory je gamma proof 
simply log form bayes formula 
possible certain je 
case say compress examples greater information content examples 
random data called noise compressed 
principle choosing theory minimises je known rissanen minimum description length principle mdl mdl principle machine learning quinlan rivest 
mdl ilp 
generalisation bayesian confirmation techniques 
result shows choice theory minimum description equivalent choosing theory maximum bayes posterior probability 
fisher maximum likelihood principle maximise prior probability assumed theorem 
equivalence minimum description maximum posterior probability 
evidence set potential theories chosen sigma 
min sigma je gammalog max sigma je proof 
follows trivially fact log monotone je gammalog je 
oe function computable due halting 
variety approximations approach 
fine details functions scope 

declarative bias section briefly discuss important forms declarative bias 
current ilp systems distinguish kinds declarative bias syntactic bias called language bias semantic bias 
syntactic bias imposes restrictions form syntax clauses allowed hypothesis 
illustrate syntactic bias consider abduction usually perceived logic programming 
roughly speaking abduction considered special case normal setting inductive logic programming syntactic bias restricts hypotheses positive ground unit clauses positive evidence true ground fact negative evidence set integrity constraints 
semantic bias imposes restrictions meaning behaviour hypotheses 
illustrate semantic bias consider types modes 

syntactic bias formally speaking syntactic bias defines set formed hypotheses set formed hypotheses usually defined language bias set syntactically acceptable clauses 
syntactic bias ilp system determines actual result important parameter ilp system 
previously ilp systems employed implicit built syntactic bias growing interest general rissanen principle variant maximum entropy principle sophisticated william ockham razor principle advocates minimising je 
formalisms specify syntactic bias 
advantage general formalisms language bias decoupled particular ilp implementations 
true portable parameter system facilitates comparison different systems 
remainder section different frameworks bias specification briefly study link syntactic bias efficiency ilp algorithms 

general frameworks bias specification exist general frameworks specify language bias specify set clauses allowed hypotheses 
includes inductive logic programming language bergadano antecedent description grammars cohen schemata blip team variants 
fourth framework parametric languages defined discussing link complexity learning 
bergadano inductive logic programming language uses notation close prolog aims mainly applications programming 
extends prolog means clause sets predicate sets 
example consider expression female parent mother female parent set expressions denoted fg express subset literals clauses may final hypothesis 
expression denotes hypotheses space consisting subsets set clauses male female parent father female parent father male parent father parent mother male female parent mother female parent mother male parent mother parent framework introduced bergadano aims readability framework cohen aims generality computing power 
cohen employs kind definite clause grammar calls antecedent description grammars describe set formed clauses 
clauses encoded formalism follows goal formula father 
goal formula mother 
body father parent body mother parent male female notation goal formula defines predicates learned body starting symbol grammar learning clauses head definite clause grammars square brackets enclose terminal symbols 
type syntactic bias inductive logic programming form second order schemata 
formalism introduced emde adapted employed 
slightly different related formalisms considered 
second order schema basically clause predicate names existentially quantified predicate variables 
second order schema xw xw set second order schemata defines language bias set clauses obtained instantiating second order schema second order substitution 
second order substitution substitution replaces predicate names 
schema theta connected part second order substitution 
instantiated schema theta yields connected part xw part yw touches xw yw ways specifying bias advantage specification closely connected structure search space subsumption 
kietz wrobel showed theoretically system second order schemata partially ordered effectively searched extension subsumption cohen showed generality determined sentential level sentences containing terminals non terminals effectively guide search bergadano formalism structure search space follows directly set notation 
formalisms easily general specific framework subsumption 
note cohen formalism powerful declarative framework bergadano framework blip complementary 
bergadano framework easy abstraction number literals clause language bias having fixed number literals result huge number expressions 
schemata complementary opposite true 
interesting consider straightforward generalisation models set expressions allow predicate variables 

syntactic bias complexity search 
earlier approaches bias specification employed parametric approach number parameters determined syntax clauses hypotheses 
parametric approach advantage easy implement shift bias occurs learner changes language bias 
changing language bias may necessary exists solution certain syntactic bias 
parametric approach shifting bias realized modifying parameters way language expressive 
parametric approach various parameters employed straightforward include criteria restrictions maximum number variables clause maximum number literals clause predicates allowed hypotheses presenting advanced notions introduce linked clauses 
definition 
clause linked variables linked 
variable linked clause occurs head literal contains variables linked linkage requirement meant exclude usually useless clauses instance 
linked clause instance 
parameters important determine computational complexity learning 
definition 
depth term depth variable 
depth constant 
depth term max 
limiting depth terms hypotheses corresponds working functor free clauses 
definition 
level term level term linked clause occurs argument head min occur arguments literal variable father male parent level variable father male parent level variable grandfather male parent parent level level term corresponds muggleton feng parameter de raedt level existential quantification 
level depth terms frequently employed ilp learners define language restrictions see example 
notions especially important context specific general ilp systems golem clint pga class learners starts learning called starting clause 
starting clause sc function background theory language bias positive example sc yields specific clause linked languages maximum depth level starting clause unique number literals grow exponential level see example 
example 
defined follows parent jef paul parent jef ann male paul female ann father son jef clauses languages maximum depth maximum level 
starting clause father jef parent jef ann parent jef paul female ann male paul specific general systems complete languages gamma additional semantic restrictions gamma necessarily inefficient cf 

starting clauses necessarily unique number starting clauses exponential maximum number variables allowed clauses 
illustrated example 
example 
example example clauses having maximum variables clauses legal starting clauses father parent male father parent female easy extend example show number starting clauses grow exponentially number variables 

semantic bias modes types usually employed optimise efficiency prolog compilers relevant bias set acceptable hypotheses inductive logic programming 
shapiro mis quite standard inductive logic programming provide learner type mode declarations cf 

modes types known logic programming formalise illustrate example 
example ilp system progol allows user specify declarations predicates background theory mode append list list mode append list list nil list xjt integer list mode states predicate append succeed arguments instantiated lists return third argument instantiated list 
types list user defined monadic background predicates 
second declaration states append succeed finitely times third argument instantiated list 
specified limit degree indeterminacy call natural number modes useful inductive logic programming reasons 
single predicate learning context background predicates modes correctly specified learner guarantee termination assuring queries generates mode conform 
secondly learner optimise search answering queries 
declaration append learner need backtrack having solution query matching declaration 
type declarations predicate learned learner need consider type conform subset hypothesis space 
drastically reduce computation needed 
semantic bias employed ilp systems golem foil linus notion determinate clauses 
adopt simpler definition original 
definition 
adapted definite clause determinate respect background knowledge examples substitution unifies ground instance unique substitution ground true 
roughly speaking clause determinate literals determinate literal determinate variables appear preceding literals possible binding bindings variables appear preceding literals 
illustrate determinacy reconsider background theory example 
clause father parent determinate unique instantiation true 
hand clause father parent determinate exist true instantiations notice clauses shown example determinate 
determinate clauses way get problems indicated examples 
results computational learning theory show certain classes determinate clauses learned efficiently cf 
section 
cost losing completeness 

learnability discussion sections far process hypothesis formation justification 
noted section part larger scientific setting facts gathered experiments planned alternative theories tested 
simplified scenario kind studied theory learnability 
learnability concerns convergence properties process forming revising predictive hypotheses 
main approaches learnability discussed chapter 
ffl gold identification limit 
approach derived computability theory 
deals finite time convergence computational learning procedure 
ffl valiant probably approximately correct pac learning 
derived computational complexity theory deals expected rate convergence 
current learnability results address definite example settings inductive logic programming 

identification limit identification limit pac learnability assume predefined class hypothesised theories derived syntactic bias defines clauses part hypothesis 
assumed contain sets definite clauses 
presentation definite clause theory defined follows 
set clauses true alphabet gamma set clauses false alphabet gamma definition 
presentation gamma fe gamma ilp oriented variant gold definition 
definition 
definite clause background theory class definite clause theories 
ilp algorithm positive negative evidence gamma returns hypothesis posterior satisfiability posterior sufficiency holds 
algorithm identifies class limit presentation finite intuition gold formalism certain class learning tasks learnable exists algorithm find correct hypothesis finite time learning tasks algorithm provided evidence 
gold gives various results showing certain classes theories identified limit 
class illustrated example example adapted 
example 
suppose fh defined follows ae presentation hp distinguish implying finite class finite ground unit clauses identified limit positive examples 
implicitly assume unique minimal model exists may contain general clauses 
main results identification limit ilp due shapiro de raedt 
shapiro proves mis system equipped eager search strategy identifies easy definite clause theory presentation consisting positive negative examples oracle answer membership existential questions 
roughly speaking easy definite clause theory definite clause theory exists function herbrand base natural numbers returns fact maximum depth sld proof tree needed prove fact true 
value returned depth bound proof fact order guarantee termination 
membership question asks oracle truth value ground fact existential question asks oracle truth value non ground fact 
membership questions oracle answer true false 
existential questions oracle answer ground substitutions fact true false meaning instantiation fact true 
de raedt bruynooghe upgraded shapiro result presentations presentation containing positive clausal evidence adaptation shapiro mis restrict attention functor free clauses 
restriction gamma certain conditions gamma lifted clint system 
results identification limit due plotkin banerji 

pac learnability variant valiant definition pac learnability 
definition 
definite clause theory class definite clause theories 
algorithm positive negative examples gamma returns hypothesis posterior sufficiency posterior satisfiability holds 
error probability example drawn see section distribution true false vice versa 
algorithm pac learns class probability distribution ffl ffi ffl ffi polynomial function random sample examples size ffl ffi drawn distribution probability error ffl gamma ffi 
pac learnability results ilp learning limit results established ilp literature logic definite clause logic 
results tell little efficiency learning 
contrast valiant pac correct framework aimed providing complexity results machine learning algorithms 
furthermore pac framework require convergence correct hypothesis hypothesis high notice negative example definite setting expressed positive evidence probability gamma ffi approximately correct gamma ffl resulting realistic framework 
haussler negative pac result concerning existentially quantified formulae initially exclude possibility pac results order logic 
situation improved positive results significant sized subsets definite clause logic 
results possible particular language biases see section 
single constrained horn clauses depth level section clause ij determinate non recursive single predicate logic programs simple distributions 
denotes maximum number clauses hypotheses denotes level denotes maximum arity predicates background knowledge simple distributions limited computable 
recursive ij determinate predicates shown pac learnable membership queries allowed 
definition quick sort membership queries 
kietz showed languages pac learnable ffl clause determinate programs recursion ffl clause ij indeterminate programs recursion second result disables learning simple non determinate clause 
male cohen showed single definite clauses bounded indeterminacy polynomial literal support pac predictable pac learnable hypotheses 
cohen restriction indeterminacy single clause hypothesis follows 
definition 
indeterminate clause called indeterminate respect background knowledge possible substitution oe ground instance distinct substitutions oe ground true 
clause defining male learned bound put maximum number brothers sisters individual expected 

predicate invention theoretical characterisation predicate invention follows 
logic program set predicate symbols heads clauses called definitional vocabulary 
ilp definitional vocabularies 
observational vocabulary gamma theoretical vocabulary gamma invented vocabulary gamma learner carries predicate invention 

necessary predicate invention ling discusses conditions predicate invention necessary 
requires addition satisfiability necessity sufficiency requirements section 
necessary invention provides sufficiency consistency 
words predicate invention necessary exist finite axiomatisation predicates containing predicate symbols theorem stahl 
theorem 
decidability fixed vocabulary 
recursively enumerable deductively closed set formulas order language undecidable finitely stahl proof application rice theorem undecidability non trivial index sets recursively enumerable 
result means necessity invention needs heuristic general case 
constraints language depth inference discussed sections applied problem decidable 
result due kleene shows importance new predicates constructing finite axiomatisations 
theorem 
finite axiomatisation additional vocabulary 
recursively enumerable deductively closed set formulas order language finitely additional predicate symbols kleene proof constructive introduces new predicates regardless necessary 
clearly potentially infinite set new predicates introduced 
reasonable necessary extend vocabulary done conservative manner possible 
requires notion ordering invented predicates 
lattice utility invented predicates introduced 
lattice unique topmost bottom element 
equivalence class set possible invented predicates allows investigate set invented predicates equivalent re ordering arguments removal redundant arguments 
making upper bound greatest lowerbound operators utility lattice provide sound complete approach searching invented predicates 

predicate invention techniques ilp systems carry predicate invention inverse resolution operators see section 
necessarily involves specific general search 
exception approach search employed 
search guided mode declarations see section 
authors operators introduce new predicates 
auxiliary sub predicates generalised inverse implication see 
allows certain sub predicates learned learned 

ilp implementations till discussed gamma view gamma foundations field inductive logic programming particular model theory proof theory probabilistic semantics bias notions predicate invention learnability 
underlying assumption foundations lie heart ilp sufficient understanding ilp 
consequence ignored issues ilp mainly closely connected particular ilp implementations applications 
includes instance oracle theory revision handling numerical data 
time study particular ilp system detail 
section briefly touch matters 
discuss dimensions issues ilp perceived users ilp systems 
secondly give short overview selected ilp systems 

characteristics ilp systems practical ilp systems classified different dimensions perceived users ilp systems 
obvious characteristics studied earlier include types bias employed ability invent new predicates heuristics employed handle imperfect data noise 

incremental non incremental dimension describes way evidence examples obtained 
non incremental empirical ilp evidence start changed incremental ilp examples input user piecewise fashion 
non incremental systems search typically specific general general specific 
incremental systems usually employ mixture strategies may need correct earlier induced hypotheses 
incremental ilp systems include mis clint forte rx lfp cigol 
nonincremental systems include golem foil focl claudien linus 

interactive non interactive interactive ilp learner allowed pose questions oracle user intended interpretation 
usually questions query user intended interpretation example clause 
answers queries allow prune large parts search space generic algorithm queries normally generated procedure prune 
obviously implies incrementality 
systems noninteractive 
interactive systems include cigol mis clint 

single multiple predicate learning theory revision suppose represent predicate symbols formula single predicate learning examples evidence composed examples predicate singleton 
multiple predicate learning restricted aim learn set possibly interrelated predicate definitions 
theory revision usually form incremental multiple predicate learning starts initial approximation theory 
theory revision systems marvin mis followed banerji blip ml smart cigol clint renewed interest theory revision multiple predicate learning cf 

newer approaches differ previous ones sense try learn requiring oracle 
note ml smart blip require oracle 
commonly believed theory revision multiple predicate learning algorithms fundamentally different single predicate learners types systems fit natural way generic algorithm outlined section 
main differences theory revision systems single predicate learners 
theory revision systems typically variety deductive inductive inference rules combining abduction specialisation generalisation 
secondly incremental systems generalise specialise 
specialisation occurs negative example implied hypothesis generalisation positive example implied 
theory revision important modify theory little possible stay close original theory possible 
issue formalised stefan wrobel 

numerical data mesh domain section involves predicting number sections edge cad object broken efficient finite element analysis 
rules developed golem form 
mesh obj connected obj obj small number examples hard get examples prediction exact number 
rules predict interval mesh obj connected obj obj kind construction handled elegantly existing systems linus foil tdidt extensions introduce tests 
statistics problem numerical prediction known regression 
efficient statistical algorithms exist handling numerical data 
ilp system designers starting look smoothly integrating approaches systems 
introducing linear inequalities inductively constructed definite clauses provides elegant logical framework problem 
approach allows constraint logic programming clp techniques ilp 

ilp systems section give overview number important inductive logic programming systems 
clear complete overview systems outside scope large number ilp systems implementations 
overview centres systems mis blip cigol golem foil claudien 
systems selected fundamentally different contributed significantly inductive logic programming 
furthermore systems related 
real inductive logic programming systems sense related lp involved theory implementation mis system ehud shapiro 
mis system introduced important techniques inductive logic programming 
include refinement graphs see section general specific search backtracing algorithm locate incorrect clauses programs identification limit easy programs see section handling multiple predicates realizing theory revision coping functors definite clause programs realizing program synthesis examples 
systems techniques related mis lfp clint forte mist tr rx markus 
important developments mis type systems include definite semantics clausal evidence merely examples relating mis intensional knowledge base updating see section predicate invention techniques elimination questions user oracle specific general search 
mis originated interest logic program synthesis computational learning theory inductive inference system predecessors blip originates knowledge acquisition knowledge discovery perspective 
main contribution line research second order schemata associated theory model driven learning yields practical knowledge acquisition tools 
schemata originally meant specify syntactic bias schemata variants proven useful purposes 
includes learning syntactic bias higher order logic learning predicate invention intelligent general specific search aids analogical reasoning mechanisms 
real inverse resolution operator see section absorption operator employed marvin system 
marvin underlying theory inverting resolution formalised 
done propositional logic duce definite clause logic cigol lfp 
paradigm explored 
ways innovative extension introduced duce cigol concept predicate invention 
earlier full historic overview inductive logic programming outside scope 
personal view claude sammut developments lead inductive logic programming contained 
frameworks plotkin shapiro 
new departures line research come system inverting implication see section 
golem system special case inverse resolution corresponds rlgg operator gordon plotkin see 
special case inverse resolution restricted determinate clauses cf 
section proved tractable complicated inverse resolution paradigm 
part increased efficiency golem applied real scientific discovery tasks 
determinacy restriction proved relevant computational complexity learner 
foil system traditional concept learning techniques 
particular relates greedy tdidt algorithms aq family algorithms michalski 
matter fact relations express background knowledge learning concepts induce algorithm ml smart system 
algorithms gamma adopting classical concept learning framework gamma produced rules fixed number classes 
consequence aq induce learned kind functor free definite clauses propositions condition part 
furthermore aq induce employed non standard logic represent concepts examples 
main contribution quinlan foil recognize power logic programming representation language inductive learning upgrade machine learning techniques expressive datalog representation 
furthermore foil system widely known demonstration order learning really sense works efficiently broad range problems involving large noisy datasets 
foil incorporated ij determinate constraint introduced 
variants refinements foil developed including focl cham 
related traditional concept learning techniques foil linus transforms certain classes ilp problems attribute value form runs classical algorithms transforms result back logical clauses 
claudien system efficient inductive logic programming working non monotonic setting deriving full clausal theories databases 
claudien simple general specific iterative deepening search refinement subsumption 
time offers natural approach empirically learning multiple predicates requires interaction user presentations normal setting see 
nonmonotonic setting easy learn multiple predicates clauses valid conjunction valid 
contrast normal setting conjunction clauses contributing individually solution may violate posterior satisfiability requirement 
remains seen new approach yield successful applications golem foil 

application areas computational techniques neural networks said mimic human learning 
sense neural networks techniques statistical regression viewed making form inductive inference 
neural networks ilp algorithms output rules easily understood people 
ilp particularly appropriate scientific theory formation tasks comprehensibility generated knowledge essential advancement scientific subjects 
relational logic formalism allowed successful application ilp systems number domains concepts learned easily described attribute value language 
applications include prediction drug design protein secondary structure prediction finite element mesh design automatic construction qualitative models 
worth noting results produced ilp produce new knowledge refereed journals application area drug design protein folding understandable meaningful scientists application domain realized general purpose ilp systems 
examples ai combination achieved 
programming assistants tools assist programmer design implementation software 
straightforward application ilp area program synthesis examples bias partial specifications see 
applications include algorithmic debugging program testing verification automatic derivation properties programs databases reverse engineering knowledge base updating 

scientific discovery knowledge acquisition 
drug design majority pharmaceutical finding slightly improved variants patented active drugs drugs introduced kind 
involves laboratories chemists synthesising testing hundreds compounds random 
ability automatically discover chemical properties affect activity drugs provide great reduction pharmaceutical costs 
average cost developing single new drug 
shown ilp techniques capable constructing rules predict activity untried drugs 
rules constructed examples drugs known activity 
accuracy rules higher traditional statistical methods 
importantly easily understandable rules provide key insights allowing considerable reductions numbers compounds need tested 

protein primary secondary shape prediction predicting dimensional shape proteins amino acid sequence widely believed hardest unsolved problems molecular biology 
considerable interest pharmaceutical companies shape generally determines function protein 
ilp techniques developed turing institute considerable success area 
years attempts apply methods ranging statistical regression decision tree neural net learning problem 
published accuracy results general prediction problem ranged close random prediction 
ability biological background knowledge ability describe structural relations boosted restricted sub problem independently chosen test set 

satellite diagnosis ilp techniques applied problems aerospace industry 
case complete correct set rules diagnosing power supply failures developed generating examples qualitative model power sub system existing satellite 
resulting rules guaranteed complete correct single faults examples generated original model 
rules described simple temporal formalism predicate associated time variable 

rheumatology application linus system learning medical rules early diagnosis diagnosis showed relational background knowledge provided domain expert substantially improved quality induced rules compared results attribute value learning techniques 

finite element meshes successes achieved applying golem finite element mesh design drawn interest industry applying techniques state art cad packages 
finite element methods extensively engineers modelling scientists analyse stresses physical structures 
structures represented quantitatively finite collections elements 
deformation element computed linear algebraic equations 
order design numerical model physical structure necessary decide appropriate resolution modelling component part 
considerable expertise required choosing resolution values 
fine mesh leads unnecessary computational overheads executing model 
coarse mesh produces intolerable approximation errors 
ilp techniques develop rules deciding appropriate resolution values inductively expert provided examples 
case relational language required reflect relations elements physical structure modelled 

programming assistants study relation interests logic programming ilp 
places argue tighter interpretation ilp lp paradigm 
interpretation allows import ilp lp export lp inductive techniques general permitting cross fertilization 
discuss application claim logic program synthesis reverse engineering algorithmic debugging deductive databases program testing verification 

logic program synthesis logic program synthesis transformation tries develop techniques derive efficient programs specification synthesis inefficient implementation transformation 
usually logic program synthesis transformation employ deductive techniques achieve aim 
show alternatively induction 
advantage logic program synthesis incomplete specifications plausible 
briefly illustrate sorting example 
logic program synthesis transformation setting predicate sort specified sort permutation sorted corresponding definitions permutation sorted see section background theory aim improve definition permutation sort efficient sorting predicate quicksort insertion sort bubble sort 
techniques achieve aim logic program synthesis transformation basically deductive instance fold unfold mathematical induction techniques 
ilp setting tackle problem permutation sort sorted sort sort permutation sorted includes sorted permutation possibly predicates partition append member language bias permutation sorted hypotheses 
definition sort satisfying requirements equivalent specification permutation sort correct 
depending predicates background theory bias different definitions sort derived 
example partition background theory induce quicksort 
shows ilp derive logic programs complete specifications 
hand gamma shows flexibility ilp gamma relaxing evidence ilp induce programs incomplete specifications possible synthesis approaches see 
instance third clause replaced positive examples 
disadvantage ilp techniques logic program synthesis guarantee induced hypothesis efficient original specification 
verified empirically 
extreme case application ilp area programming synthesis examples 
automatic ilp researchers cf 
test illustrate techniques believe program synthesis examples promising direction ilp 
examples needed correct definition induced cf 

automatic programming examples practical easier program manually specify hundreds thousands examples 
time follows upgrading representation examples ground facts general formulae prime concerns ilp cf 


inducing properties programs databases database program interested regularities database program 
highlevel regularities satisfying program regarded partial specifications program 
specifications judge correctness program 
regularities satisfying database relevant integrity constraints new knowledge discovered cf 
higher 
inducing properties programs databases corresponds form reverse engineering 
principle normal setting ilp discover highlevel regularities programs databases non monotonic setting ilp appropriate cf 

setting database program induced hypothesis contains high level regularities interested 
example database context section 
illustrate programming context consider sorting example assume contains quicksort sorted permutation 
systems working non monotonic setting claudien induce hypothesis containing clauses listed previous section 

program testing debugging relation algorithmic debugging inductive inference known shapiro influential mis 
basically debugging program corresponds credit assignment problem inductive inference 
furthermore bug located may try repair incremental inductive inference techniques 
algorithmic debugging starts known bug program program testing verification tries discover exist bugs program 
aim generate test set example behaviours program judged correctness user 
generate test set program knowledge base satisfying certain desirable properties employ ilp techniques cf 

suppose starts program test ilp system example setting 
roughly speaking ilp approach test generation computes minimal set examples program behaviour sufficient induce program equivalent uniquely distinguish set alternatives 
underlying assumption states behaves correctly correct 
computation done incrementally 
initially empty program generated ilp system correct regard equivalent example generated true program 
example added process inducing generating examples repeated equivalent example set required test set 

knowledge base updating roughly speaking problem knowledgebase updating see specified follows 
deductive database satisfying set integrity constraints formula explained database 
aim find updated database explains formula integrity constraints remain satisfied 
illustrate grandparent father parent parent mother father henry jane mother jane john mother jane alice integrity theory ae father mother update request ask grandparent george henry true 
typical knowledge base updating methods realise update requests adding deleting ground facts database mixture abduction techniques shortcut proofs 
example update request realised adding fact father george henry problem knowledge base updating formulated corresponds incremental ilp problem definite setting update request considered positive evidence cf 

advantage reformulating knowledge base updating terms ilp allows extend allowed transactions 
existing knowledge base updating methods allow induction non factual clauses techniques delete non factual clauses database 
contrast ilp setting natural 
database integrity theory appropriate evidence incremental ilp techniques induce missing clauses parent grandparent 
hand ilp techniques benefit knowledge base updating spent lot effort cope normal program clauses sldnf setting 
ilp techniques handle negation general sound manner see 

abduction abduction currently perceived logic programming considered special case example setting inductive logic programming hypotheses restricted sets ground facts evidence single positive examples statement reveals important difference techniques ilp facts examples usually assumed stable clauses learned contrast abductive logic programming clauses stable facts learned 
techniques considered opposite complementary 
ilp systems include abductive component mis clint abduction special case inverse resolution 
applications abduction may extendable inductive logic programming 
application discussed intensional knowledge base updating 

directions plotkin early shapiro early set scene interest area learning order formulae 
ilp grown theoretical mainstream area research evidenced annual international workshops 
problems encountered way solutions developed machine learning statistics logic programming 
mentioned abduction considered complicated representations background theories including normal program clauses 
advances ilp come established techniques drawn logic programming 
instance ilp systems exceptions system require mode type information concerning predicates background knowledge provided user 
type mode declarations derived automatically analysis background knowledge 
addition benefit potentially derived making termination knowledge base updating algorithmic debugging abduction constraint logic programming program synthesis program analysis 
clear section logical theorem proving heart ilp methods 
reason worth asking technology prolog interpreters sufficient purposes 
reconsider tweety example section 
implementing general system carried inference example require full clausal theorem prover 
ilp systems merely prolog interpreter carry theorem proving 
worth going computationally expensive techniques 
learning full clausal theories de raedt bruynooghe stickel efficient full clausal theorem prover 
stickel theorem prover compiles full clauses set definite clauses 
definite clauses executed prolog interpreter iterative deepening 
technique maintains prolog efficiency allowing full theorem proving 
learning full clausal theories largely unexplored new area ilp 
problem dealing efficiently effectively numerical data important challenge ilp 
earlier systems linus dealt problem allowing simple inequalities hypothesis language 
introducing general linear inequalities inductively constructed definite clauses provides elegant logical framework problem 
approach allows constraint logic programming clp techniques ilp 
ilp research issues deal directions go 
maintaining strong connections theory implementations applications ilp potential develop powerful widely technology 
authors especially maurice bruynooghe katholieke universiteit leuven lincoln wallen oxford university computing laboratory useful input research 
reviewers constructive comments suggestions 
supported partly esprit basic research action ilp project serc advanced research fellowship held stephen muggleton belgian national fund scientific research 
stephen muggleton research fellow wolfson college oxford luc de raedt post doctoral researcher belgian national fund scientific research 
appendix notational conventions false true logical entailment conjunction implication double implication ae proper subset subset maximally general element maximally specific element complement depth term glb greatest lower bound level term clause lub upper bound prior probability xjy prior probability prior information content xjy information content ae refinement operator ae transitive closure ae herbrand base conjunction clauses set formed hypotheses contains set sets clauses language bias set clauses minimal herbrand model definite clause program gamma ff gamma complement minimal herbrand model definite clause program finite success set subset derived proofs depth gamma finite failure set subset gamma derived failed proofs depth set predicate symbols occurring logical formula set clauses true alphabet gamma set clauses false alphabet rl nth linear resolution definite clause theory 
ade de raedt bruynooghe 
theory revision 
muggleton editor proceedings rd international workshop inductive logic programming pages 

ali pazzani 
hydra noise tolerant relational concept learning algorithm 
proceedings th international joint conference artificial intelligence 
morgan kaufmann 

angluin 
complexity minimum inference regular sets 
information control 

banerji 
learning limit growing language 
ijcai pages los angeles ca 
kaufmann 

banerji 
learning theoretical terms 
muggleton editor inductive logic programming 
academic press london 

giordana saitta 
learning mutually dependent relations 
journal intelligent information systems 

bell weber 
close relationship foil frameworks plotkin 
muggleton editor proceedings rd international workshop inductive logic programming pages 

bergadano 
inductive logic programming language 
technical report esprit project ilp deliverable computer science department university torino 

bergadano giordana saitta 
concept acquisition noisy environments 
ieee transactions pattern analysis machine intelligence 

bergadano 
interactive system learn functional logic programs 
proceedings th international joint conference intelligence 
morgan kaufmann 

biermann 
fundamental mechanisms machine learning inductive inference 
bibel editors fundamentals artificial intelligence 
springer verlag 

biermann 
inference regular lisp programs examples 
ieee transactions systems man cybernetics 

biermann feldman 
synthesis finite state machines samples behaviour 
ieee transactions computers 

biermann krishnaswamy 
constructing programs example computations 
ieee transactions software engineering 

bratko grobelnik 
inductive learning applied program construction verification 
muggleton editor proceedings rd international workshop inductive logic programming pages 

bratko muggleton 
learning qualitative models dynamic systems 
proceedings eighth international machine learning workshop san mateo ca 
morgan kaufmann 

brunk pazzani 
investigation noise tolerant relational concept learning algorithms 
proceedings th international workshop machine learning 
morgan kaufmann 

bruynooghe janssens 
instance interpretation integrating type mode inferencing 
proceedings th international conference symposium logic programming pages 

francois bry 
intensional updates abduction deduction 
warren szeredi editors proceedings th international conference logic programming pages 
mit press 

buntine 
induction horn clauses methods plausible generalization algorithm 
international journal man machine studies 

buntine 
generalised subsumption applications induction redundancy 
artificial intelligence 

carnap 
continuum inductive methods 
chicago university chicago 

cohen 
compiling knowledge explicit bias 
proceedings th international conference machine learning 
morgan kaufmann 

cohen 
grammatically biased learning learning logic programs explicit antecedent description language 
artificial intelligence 
appear 

cohen 
learnability restricted logic programs 
muggleton editor proceedings rd international workshop inductive logic programming pages 

cohen 
pac learning restricted class logic programs 
muggleton editor proceedings rd international workshop inductive logic programming pages 

conklin witten 
complexity induction 
technical report dept computing information science queen university kingston ontario canada 

datta kibler 
concept sharing means improve multi concept learning 
proceedings th international conference machine learning san mateo ca 
morgan kaufmann 

decker 
drawing updates derivations 
abiteboul kanellakis editors proceedings nd international conference database theory volume lecture notes computer science 
springer verlag 

deville lau 
logic program synthesis 
journal logic programming 
submitted special issue 

muggleton 
application inductive logic programming finite element mesh design 
muggleton editor inductive logic programming 
academic press london 

dzeroski bratko 
handling noise inductive logic programming 
muggleton editor proceedings nd international workshop inductive logic programming 

dzeroski muggleton russell 
pac learnability determinate logic programs 
proceedings th acm workshop computational learning theory pittsburg pa 

emde 
inference engine multiple theories 
morik editor knowledge representation organization machine learning volume lecture notes artificial intelligence 
springer verlag 

emde habel 
discovery equator concept driven learning 
proceedings th international joint conference artificial intelligence pages 
morgan kaufmann 

bergadano 
inductive test case generation 
muggleton editor proceedings rd international workshop inductive logic programming pages 

feng 
inducing temporal fault rules qualitative model 
muggleton editor inductive logic programming 
academic press london 

feng muggleton 
general generalisation higher order logic 
appear 

flach 
framework inductive logic programming 
muggleton editor inductive logic programming 
academic press 

deville 
logic program synthesis journal symbolic computation 
appear 

gold 
language identification limit 
information control 

gottlob 
subsumption implication 
information processing letters 

grobelnik 
markus optimized model inference system 
proceedings ecai workshop logical approaches machine learning 

lloyd 
updating knowledge bases 
new generation computing 

lloyd 
updating knowledge bases ii 
technical report tr university bristol department computer science 

haussler 
applying valiant learning framework ai concept learning problems 
kodratoff michalski editors machine learning artificial intelligence approach volume pages 
morgan kaufman san mateo ca 


learning systems order rules 
proceedings th international workshop machine learning pages 
morgan kaufmann 


induction nonmonotonic inference 
proceedings st international conference principles knowledge representation reasoning pages 
kaufmann 

hume sammut 
inverse resolution learn relations experiments 
birnbaum collins editors proceedings eighth international workshop machine learning pages san mateo 
morgan kaufmann 

almquist 
generalisation implication 
brazdil editor proceedings th european conference machine learning volume lecture notes artificial intelligence pages 
springer verlag 

kakas kowalski toni 
abductive logic programming 
journal logic computation 

kakas mancarella 
database updates abduction 
mcleod sacks davis editors proceedings th international conference large databases pages 
morgan kaufmann 

kawamura furukawa 
inductive generalization constraint logic programs 
proceedings ijcai workshop inductive logic programming 


kietz wrobel 
controlling complexity learning logic syntactic task oriented models 
muggleton editor inductive logic programming 
academic press 

kietz 
incremental reversible acquisition taxonomies 
gaines editors proceedings nd european knowledge acquisition knowledge systems workshops 

kietz 
lower bounds computational complexity inductive logic programming 
brazdil editor proceedings th european conference machine learning volume lecture notes artificial intelligence pages 
springer verlag 


efficient learning logic programs non determinate non discriminating literals 
muggleton editor inductive logic programming 
academic press london 

king muggleton lewis sternberg 
drug design machine learning inductive logic programming model structure activity relationships analogues binding 
proceedings national academy sciences 

sterling 
refinement strategies inductive learning simple prolog programs 
proceedings th international joint conference artificial intelligence 
kaufmann 

kleene 
finite axiomatizability theories predicate calculus additional predicate symbols 
kleene editor papers predicate calculus memoirs american mathematical society 
american mathematical society providence ri 

van der cheng 
subsumption refinement model inference 
brazdil editor proceedings th european conference machine learning volume lecture notes artificial intelligence pages 
springer verlag 

ling matwin 
constructive inductive logic programming 
muggleton editor proceedings rd international workshop tive logic programming 

matwin 
sub unification tool efficient induction recursive programs 
proceedings ninth international machine learning conference los altos 
morgan kaufmann 

lau clement editors 
logic program synthesis transformation 
workshops computing 
springer verlag 

lavrac dzeroski 
inductive logic programming techniques applications 
ellis horwood 

lavrac dzeroski grobelnik 
learning non recursive definitions relations linus 
yves kodratoff editor proceedings th european working session learning volume lecture notes artificial intelligence 
springer verlag 

lavrac dzeroski 
background knowledge learning medical diagnostic rules 
applied artificial intelligence 

ling 
inventing necessary theoretical terms scientific inductive logic programming 
technical report dept comp 
sci univ western ontario 

maher 
equivalences logic programs 
proceedings third international conference logic programming berlin 
springer 


undecidability horn clause implication problem 
proceedings rd ieee annual symposium foundations computer science pages 
ieee 

chris mellish 
global optimizations prolog compiler 
journal logic programming 

michalski 
theory methodology inductive learning 
michalski mitchell editors machine learning artificial intelligence approach pages 
tioga palo alto ca 

mishra 
theory types prolog 
proceedings international symposium logic programming pages atlantic city 
ieee computer society press 

mitchell 
generalisation search 
artificial intelligence 

mizoguchi 
constraint directed generalization learning spatial relations 
proceedings second inductive learning workshop tokyo 
icot tm 

moore 
experiments sequential machines 
shannon mccarthy editors automata studies pages 
princeton university press princeton nj 

morik 
sloppy modeling 
morik editor knowledge representation organization machine learning volume lecture notes artificial intelligence 
springer verlag 


logic induction 
ellis horwood chichester england 

muggleton 
duce oracle approach constructive induction 
ijcai pages 
kaufmann 

muggleton 
strategy constructing new predicates order logic 
proceedings third european working session learning pages 
pitman 

muggleton 
inductive logic programming 
new generation computing 

muggleton editor 
proceedings international workshop inductive logic programming 
university porto porto portugal 

muggleton editor 
inductive logic programming 
academic press 

muggleton editor 
proceedings second international workshop logic programming 
icot tokyo japan 

muggleton 
inverting implication 
artificial intelligence journal 
appear 

muggleton 
predicate invention utility 
journal experimental theoretical artificial intelligence 
appear 

muggleton editor 
proceedings third international workshop inductive logic programming 
jozef stefan institute bled slovenia 

muggleton 
mode directed inverse resolution 
furukawa michie muggleton editors machine intelligence 
oxford university press appear 

muggleton buntine 
machine invention order predicates inverting resolution 
proceedings fifth international conference machine learning pages 
kaufmann 

muggleton feng 
efficient induction logic programs 
proceedings conference algorithmic learning theory tokyo 
ohmsha 

muggleton king sternberg 
protein secondary structure prediction logic machine learning 
protein engineering 

muggleton srinivasan bain 
compression significance accuracy 
proceedings ninth international machine learning conference san mateo ca 
morgan kaufmann 

niblett 
study generalisation logic programs 
ewsl london 
pitman 

page frisch 
generalization learnability study constrained atoms 
muggleton editor inductive logic programming 
academic press london 

pazzani kibler 
utility knowledge inductive learning 
machine learning 

pereira 
refining knowledge base updates 
technical report ai center portugal november 

piatetsky shapiro frawley editors 
knowledge discovery databases 
mit press 

plotkin 
note inductive generalization 
machine intelligence volume 
edinburgh university press 

plotkin 
note inductive generalisation 
meltzer michie editors machine intelligence pages 
elsevier north holland new york 

plotkin 
automatic methods inductive inference 
phd thesis edinburgh university august 

quinlan 
induction decision trees 
machine learning 

quinlan 
determinate literals inductive logic programming 
ijcai proceedings twelfth international joint conference artificial intelligence pages san mateo ca 
morgan kaufmann 

quinlan cameron jones 
foil midterm report 
brazdil editor proceedings th european conference machine learning volume lecture notes artificial intelligence pages 
springer verlag 

quinlan rivest 
inferring decision trees minimum description length principle 
information computation 

quinlan 
learning logical definitions relations 
machine learning 

de raedt 
inductive logic programming scientific discovery 
technical report katholieke universiteit leuven department computing science 
submitted 

de raedt 
interactive theory revision inductive logic programming ap proach 
academic press 

de raedt bruynooghe 
friendly concept learners 
proceedings th international joint conference artificial intelligence pages 
morgan kaufmann 

de raedt bruynooghe 
indirect relevance bias inductive 
knowledge acquisition 

de raedt bruynooghe 
belief updating integrity constraints queries 
artificial intelligence 

de raedt bruynooghe 
interactive concept learning constructive induction analogy 
machine learning 

de raedt bruynooghe 
unifying framework concept learning algorithms 
knowledge engineering review 

de raedt bruynooghe 
theory clausal discovery 
proceedings th international joint conference artificial intelligence 
morgan kaufmann 

de raedt lavrac 
faces inductive logic programming 
komorowski editor proceedings th international symposium methodologies intelligent systems lecture notes artificial intelligence 
springer verlag 

de raedt lavrac dzeroski 
multiple predicate learning 
proceedings th international joint conference artificial intelligence 
morgan kaufmann 

de raedt bruynooghe 
interactive concept learning knowledge base validation verification 
laurent editors validation verification testing knowledge systems pages 
john wiley sons 

rice 
classes recursively enumerable sets decision problems 
transactions american mathematical society 

richards mooney 
order theory revision 
proceedings th international workshop machine learning pages 
morgan kaufmann 

rissanen 
modeling shortest data description 
automatica 

robinson 
machine oriented logic resolution principle 
jacm january 

rouveirol 
extensions inversion resolution applied theory completion 
muggleton editor inductive logic programming 
academic press london 

rouveirol puget 
simple general solution inverting resolution 
ewsl pages london 
pitman 

sammut 
origins inductive logic programming tale 
muggleton editor proceedings rd international workshop inductive logic programming pages 

sammut banerji 
learning concepts asking questions 
michalski mitchell editors machine learning artificial intelligence approach 
vol 
pages 
kaufmann los altos ca 

shapiro 
algorithmic program debugging 
mit press 

shapiro 
inductive inference theories facts 

lassez plotkin editors computational logic essays honor alan robinson 
mit press 

silverstein pazzani 
relational constraining constructive induction relational learning 
proceedings sixth international workshop machine learning los altos ca 
kaufmann 

solomonoff 
formal theory inductive inference 
information control 

stahl 
constructive induction inductive logic programming overview 
technical report fakultat informatik universitat stuttgart 

stahl wirth 
methods improving inductive logic programming systems 
brazdil editor proceedings th european conference machine learning volume lecture notes artificial intelligence 

sternberg lewis king muggleton 
modelling structure function enzymes machine learning 
proceedings royal society chemistry discussions 

stickel 
prolog technology theorem prover implementation extended prolog compiler 
journal automated reasoning 

summers 
program construction examples 
phd thesis yale university new haven ct 


refining relational theory multiple faults concept subconcepts 
proceedings th international workshop machine learning pages 
morgan kaufmann 


unifying representation language restrictions 
muggleton editor proceedings rd international workshop inductive logic programming 

taylor 
inverse resolution normal clauses 
muggleton editor proceedings rd international workshop inductive logic programming pages 

thieme 
acquisition model knowledge model driven machine learning approach 
morik editor knowledge representation organization machine learning 
springer verlag 

tomasic 
view update translation deduction annotation 
proceedings nd international conference database theory volume lecture notes computer science pages 
springer verlag 

utgoff mitchell 
acquisition appropriate bias concept learning 
proceedings nd national conference artificial intelligence pages 
kaufmann 

valiant 
theory learnable 
communications acm 

van laer 
van logische 
master thesis katholieke universiteit leuven dept computing science 
dutch 

vere 
induction concepts predicate calculus 
proceedings th international joint conference artificial intelligence pages 
morgan kaufmann 

wirth 
learning failure prove 
ewsl pages london 
pitman 

wirth 
completing logic programs inverse resolution 
ewsl pages london 
pitman 

wirth 
constraints predicate invention 
proceedings th international workshop machine learning pages 
kaufmann 


revising relational theories 
proceedings th international workshop machine learning pages 
morgan kaufmann 

wrobel 
automatic representation adjustment observational discovery system 
ewsl pages london 
pitman 

wrobel 
proper definition minimality specialisation theory revision 
proceedings th european conference machine learning vol ume lecture notes artificial intelligence pages 
springer verlag 

yokomori 
logic program forms 
new generation computing 
