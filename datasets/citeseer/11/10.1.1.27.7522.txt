highly reliable upgrading components jonathan cook jeffrey department computer science new mexico state university las cruces nm usa cs nmsu edu system deployed fixes enhancements modifications occur change components system 
unfortunately new versions components introduce new errors break existing depended behavior 
happens old component version provided correct behavior longer part system 
propose framework hercules upgrading system components removing old version component keeps multiple versions component running 
doing allows behavior utilized versions maintains system integrity correctness presence newly introduced errors 
framework ensures move dynamic configurable software systems lessen provides capabilities enhance reliability software achieve century 
keywords component systems dynamic change upgrading version management reliability 
users fear upgrades 
unfortunate true statement reflects current paradigm software systems 
fear irrational comes experience 
just user comfortable system learns works developers release new version new functionality promises latest greatest features 
happens existing functionality user depended broken just supported part national science foundation ccr department education 
content information necessarily reflect position policy government official endorsement inferred 
annoying new features losing crucial functionality depended 
currently system construction moved away monolithic systems component architectures 
component mean building block system underlying framework programming language treats separate entity defined interface encapsulated behavior 
shared dynamic link libraries java class files distributed component frameworks provide separation components system 
settings individual components replaced relatively independent 
individual component replacement offers step direction reliable upgrades 
system upgraded particular components upgraded selecting changes desired ignoring 
component replacement easier roll back upgrade turns new version component break existing functionality 
component upgrade rolled back act replacement system integrity compromised fashion new version component breaks existing functionality functionality broken upgrade action rolled back 
rise dynamic distributed component software architectures active techniques pursued help maintain reliability system execution system change 
versions system components longer statically related dynamic ways 
missing currently realization old new version components offer contribution correct execution entire system 
new version aims correct deficiencies detected old version old version offers example correct behavior outside deficiencies 
versions run parallel result taken version 
sense old new components multi versioned system 
independent redundant versions voting correct output versions intimately related derived 
changes create new version know behavior meant changed conditions occurs 
behavior meant changed changed exactly breaking existing functionality want avoid 
framework hercules highly reliable upgrading components reliability provided keeping existing versions component running fully removing old component determination new component fully satisfies role 
section discusses threads research contribute 
section discusses proposed framework particular 
section details example 
section concludes ideas 
background approaches take research highly reliable component systems related different threads going research 
distributed configurable systems self checking systems multi version programming replicated systems configuration management 
areas summarized briefly 
distributed configurable systems research area distributed configurable systems focussed dynamically changing relationships connections components replacing components system running :10.1.1.48.2587
transaction models generally control replacement takes place mechanisms developed transfer state new component 
emphasis reconfiguring system new task simply thefly component replacement general assumption component reliable new task 
held workshop upgrading critical systems noted fundamental reliability concerns need addressed field frameworks far focussed support mechanisms ensuring system reliability 
reliability begun simplex architecture upgrading real time controllers analyzing impacts reconfiguration architectural level checking new configuration meets requirements constraints extending semantic analysis variants components pre deployment phase 
similar ideas pursued current microkernel operating systems research components embody operating system services dynamically changed 
tends concerned performance 
self checking systems self checking systems employ type run time specification checking formal assertions state software values inputs outputs checked execution program 
type dynamic formal verification different static verification checks states reached execution 
enables partial models checked offers relatively inexpensive method ensuring certain properties met run time tested conditions 
methods taken approach level programming language taken system level view 
multi version programming independently developing multiple versions component investigated way system reliable 
assumption errors exhibited version different system execution versions component process requests data voting schemes decide version correct 
manner reliability component displayed system greater reliability version 
empirical evidence indicates assumptions independence may valid notions failure diversity devised better understand conditions multi version programming :10.1.1.29.363
redundant replicated systems redundant replicated systems run copy exact component usually protect hardware network faults provide better service terms speed availability :10.1.1.30.591
frameworks addressed software fault tolerance issues addressed research come bear investigations 
issues include maintaining consistent states replicas managing reconfigurable groups replicas 
configuration management field configuration management cm provides standard framework terminology relating component versions 
term version applied unique instance component 
certain versions prove stable foundational designated baseline versions 
new revision component created existing version modifying way linear relationship 
existing com ponent version multiple descendants descendant fixes single problem independent descendants 
case descendants variants siblings parent essentially 
tree versions exists 
point may decided merge variants incorporating specialties single new version 
accepted cm term type version offer term fusion refer merging multiple variants 
case new version multiple parent versions directed acyclic graph versions exist 
general case relating component versions dag revisions variants fusions 
relationships play important role component upgrading 
new research directions configuration management involve extending versions architectural level especially realm distributed configurable component systems 
methods section presents methods active framework supports reliable upgrading component 
overview key insight approach successive versions component constitute multi versioned system albeit independence assumption multi version programming 
version component offer 
new version offers specific fixes known encountered problems old version 
old version offers proven reliable behavior outside known errors 
multiple new versions fix different problem 
essence approach take task ffl formally specify specific subdomain new version component correctly addresses 
ffl invocation component system run multiple versions component parallel 
ffl select computational result version specified domain contains invocation parameters voting domain resolution ambiguous 
ffl gather statistics logging information version correctness 
new version component created meant address specific conditions domain existing version failed 
specifying conditions formally constraint expression term variant describe different implementations design specification 
main system version arbiter invoke component receive results constraint evaluator version 
hercules framework 
detect run time conditions occur 
new version component assumed producing correct answer existing version result external system result new version 
invocation conditions new component specifically addressed true new version produces result different existing version assumed new version broken correct behavior existing version result external system produced existing version new version 
manner system reliability increased upgrade process 
note evaluating correctness result component regard specification 
deciding version component assumed correct domain meant address 
version called authoritative version particular invocation 
version produces result authoritative version correct invocation 
logging number times version produces correct result point decide new version reliable take old version line 
presentation concerned versions component approach considers general task having arbitrary number versions component running relate 
framework shows hercules framework propose highly reliable component upgrading 
external system uses component component versions place arbiter acts deciding results trivial equality comparison data types problem domains need expressive tests deciding values equal floating point numbers 
create new version test new version specify version domain install new version run system gather statistics evaluate statistics modify domain constraints version remove version obsolete remove version faulty component upgrading process 
system image single component 
arbiter invokes component versions system requests sends selected result back system 
arbiter contains component management facilities 
select result arbiter uses constraint evaluator ce providing invocation parameters component state information ce 
ce evaluates formal specifications version addressed domain decides version component produce correct result 
arbiter selects result send back external system logs statistics versions produced presumably correct result 
arbiter contains management facilities dynamically adding removing component versions issues discussed 
address technical issues problems topics successfully solved see background distributed configurable systems replicated systems section 
discuss actions insofar relate framework 
component upgrading process shows process component upgrading envision 
new version component created tested specific domain 
domain may specified version constructed part change order specification place testing domain may change testing decided version constructed operates different domain originally specified 
new version installed running system system runs gathers statistics running versions 
chosen points time engineer inspect statistics versions component may take different actions doing existing version removed faulty existing version removed obsolete statistics show descendants correctly implement behavior 
domain constraints version modified decided operating correctly larger domain failing part domain 
new version component may created installed 
process system reliability increased evolution components engineer takes active role maintaining configuration system running 
important note framework process allow capabilities automating process 
statistics evaluation moved running system rule action specifications automated decisions component faulty remove obsolete actions specified require human intervention 
specifying relating version constraints depicts view versions relate terms domains invocation attempt address 
initial version component version specifies input domain operates 
revision version corrects behavior subdomain version introduces allowable domain input outside version 
second revision variants corrects behavior version unrelated version 
require domains variants non overlapping 
version revised produce version 
version assumed contain changes contains version specific domain unique changes specified 
automatically inherits domain parent 
note despite inheritance long version running authoritative version domain 
inheritance comes play intermediate version example removed 
specifying version constraints techniques similar run time specification checking assertion checking 
methods usually form order logic evaluate exist version version version version version version version version constraint relationships individual domains version tree removed 
ing state system 
initial investigation allow specification include constraints input values current state specific component version constraint applies 
standard limitations assertion techniques certainly allow possible domain specifications practice worked provide sound initial foundation 
specifications involve history component stated terms current state component previous devised techniques handle history specifications may adaptable framework 
framework different types constraints specified domain constraints standard constraints specify specific domain correctness version 
constraint evaluates true invocation parameters domain 
may easier think specify negation domain domain version specifically address constraint case simply needs negation front 
illegal domain constraints specify domain version executed illegal evaluate version domain 
domain constraints central constraints framework possible 
determine version defined authoritative 
illegal domain constraints introduced allow control versions execute domain system component version known crash certain circumstances 
example version may acquire illegal domain constraint portion version extends original domain 
note constraints created modified version place illegal constraint version may specified version installed 
adding component versions add new version component things specified new version version derived domain input space version addresses 
setting complete formal specification component behavior unnecessary 
required formal description portion input domain changes version address 
domain version assumed authoritative 
authoritative domain version need wholly contained parent domain 
example shows domains version extending outside parents versions respectively 
domains overlap children override parents authority 
lowest version version tree domain contains specific invocation parameters authoritative 
current framework requires domains non related versions nonoverlapping requirement relaxed allowing voting resolve domain conflicts 
removing component versions point execution multiple versions component decided specific version removed 
reasons correctly implementing behavior children correctly implementing behavior concerned 
case decided component version adding correct behavior execution worthwhile 
removing allow ing previous version incorrect behavior problem letting continue run 
case domain specification version discarded children inherit domain 
children assumed contain behavior parent specifically changed 
children providing important functionality specific domains inherit faulty parent domain 
second case version essentially obsolete 
derived components correctly implement behavior need supply outputs system 
removed immediate descendant takes inherited domain specification version removed authoritative domain 
shows domain parent removed 
version removed descendant variants removing second case means descendant inherits domain specification 
existed authoritative version domain 
removed descendants way deciding authoritative longer single version domain 
descendants voting decide correct result 
descendants exist selected authoritative wrong respect wrong 
explicit specification authoritative imagine selection strategies ffl choose oldest running longest logged statistics back ffl choose youngest created parent running longer modified better understood presumably modified safely 
descendants possible majority answer single descendant chosen provide correct result 
favor explicit designation authoritative descendant allowing voting descendants designating oldest version default authoritative descendant explicit designation 
performance issues framework performance concerns naturally arise 
having direct execution single component version introduced arbiter constraint evaluator execution multiple versions component 
additions certainly change expected performance system 
cases system distributed parallel machine overlapping execution part framework multiple component versions enhance response time 
expect types systems dominant paradigm 
component frameworks dynamic link libraries support methods single processor machines 
cases techniques alleviate performance penalty 
case authoritative version determined version run result returned system 
threads separate running system idle cpu time versions run log correctness 
system real time constraints performance tracked number versions run limited arbiter ensure time constraints met 
limitation run versions vote correct result just authoritative version exists reliable versions current statistics 
techniques previous nonreal time settings improve performance take form configuration parameters framework 
example section describe prototype implementation reliable component upgrading framework example framework 
prototype implementation prototyped hercules tcl programming language 
tcl offers meta level language features functional eval command ability replace built commands customized ones providing easy hooks language execution 
tcl main component procedure function level implemented prototype 
version component separate procedure definition 
tcl built procedure definition command proc add command proc define procedure 
addition standard procedure name argument list body proc takes proc requires specifying version id parent version id domain constraint delayed concurrent execution non authoritative versions assumes state dependencies dependencies directed authoritative ones 
specific version 
evaluating constraints prototype takes advantage previous author done tcl assertions 
expression constructs especially existential universal quantifiers lists arrays provide order logical expressions domain constraints 
prototyped framework terms important facets ideas implemented features upgrade transactions state translation new versions previously researched features dynamic component replacement 
mechanisms integrated prototypes 
example application example application consider problem steering automobile 
just turning front wheels wheels turn 
front wheels directly controlled steering wheel computation performed decide rear wheels turn relation front wheels 
computation uses angle front wheels speed automobile travelling determine angle rear wheels turn 
initially computation decided rear wheels turn opposite direction front wheels 
doing gives tighter turning radius automobile responsive steering 
version procedure speed return expr speed procedure name version parent version version parameters degrees speed kilometers hour body denotes simple linear relation computes rear angle small negative fraction front angle diminishes zero faster automobile travelling 
example invocation procedure shows computes small negative angle turn rear wheels positive angle front wheels different speeds discovered high speeds relation harmful 
high speeds car tcl language run interactive shell mode examples procedure invocation just entered hand 
prompt returned value printed line 
responsive turning body direction away direction travelling 
useful keep body direction 
example changing lanes high speed turning lane better slide lane 
accomplished turning rear wheels direction front wheels 
analysis new version procedure constructed speed speed return expr speed return expr speed domain speed version id derived version 
version supposed keep linear computation speeds change computation move rear wheels direction front speeds diminish zero speed increases 
programming error version body procedure applies second computation speeds 
example invocations show arbiter selects result values authoritative result version result authoritative result version result authoritative result version result invocations text parentheses printed arbiter tracing returned result appears trace messages 
trace message version arbiter decided authoritative domain constraints subsequent trace message result non authoritative version 
invocation speed domain second version presumed correct result returned computed second version 
second invocation shows version operating correctly particular input outside specifically addressed domain 
version authoritative version agrees 
third example speed range incorrectly programmed second version arbiter maintains system integrity returning result computed version second version displays erroneous behavior 
furthermore realized linear computations second version programmed right lead discontinuity point computation switches 
third version constructed corrects error second version adds transition relation linear relationships 
version speed speed return expr speed elseif speed return expr speed return expr speed domain speed speed give version id child version specifically addressed domain speeds 
expect correct speeds meant changing behavior parent speed range 
run system versions procedure collect statistics versions 
invocation example authoritative result version result version result example version agrees authoritative version 
continuing run system allows gathering statistics versions 
checking statistics stat command gives ustat name tot pct statistics show version failing point decision remove previous versions allow version sole running version 
upgrade process framework maintained system integrity provided statistics gathering testbed various versions component 
technique enhance system reliability change keeping multiple versions component running contributing system 
preliminary investigation demonstrated basic foundations specifying version domains arbiter select version time invocation gathering statistics understand version reliability 
investigation shown reasoning component versions enhances knowledge engineer bring bear system maintenance change appears feasible extend version information run time issues component upgrading 
believe great potential new techniques provide users highly reliable dynamic systems 
ideas need restricted user execution 
domains large embedded systems testing requires extensive high cost facilities testing time premium ideas may offer mechanisms continual testing system new components created 
current test processes systems select specific configuration system build reserve test facility install configuration run tests remove configuration release test facility engineer 
methods keep test facility running multiple component versions extending statistics gathering may able provide information configurations stable 
initial prototype hercules built environment language fairly restrictive goal evaluate ideas current component frameworks exist today 
leading candidate application corba distributed component standard promising frameworks include dynamic link libraries javabeans 
existing research frameworks exploring issues distributed configurable systems may provide foundations needed directions transfer current component frameworks :10.1.1.39.8014
include ffl extending current handle voting mechanisms state computations including global persistent state component access 
ffl investigating control multiple versions non leaf components 
described far directed leaf components turn invoke parts system 
having multiple versions non leaf component introduces control state management problems 
ffl extending domain relations versions allow overlapping domains 
current restrictions non overlapping variant domains relaxed voting coordinate situations 
ffl integrating general multi version abilities voting mechanisms 
allowing variant implementations domain restrictions introduce ability handle general multi version concepts framework 
ffl automating portions component management process 
involve designing implementing mechanism customizable automation rule triggers 
ffl parallelizing framework incur time penalty multiple cpus available 
capability exists framework able cpu available 
directly needed threads include investigating possibilities specifying performance constraints control versions run automatically deducing domains versions source differences parent exploring mechanisms testing process special needs 
software written today increasingly dynamic component oriented malleable 
directions contribute positively ensuring changes place software industry lessen provide capabilities enhance reliability software achieve century 
andr van der hoek critiquing ideas anonymous reviewers helpful comments 
andrews 
executable assertions testing fault tolerance 
proceedings th international symposium fault tolerant computing ftcs pages new york 
ieee 

information model configuration management 
proceedings fourth international conference configurable distributed systems pages 
ieee computer society press may 
avizienis 
version approach fault tolerant software 
ieee transactions software engineering 

dynamic reconfiguration service corba 
proceedings fourth international conference configurable distributed systems pages 
ieee computer society press may 
brilliant knight leveson 
analysis faults version software experiment 
ieee transactions software engineering 
conradi westfechtel 
version models software configuration management 
acm computing surveys june 
cook 
assertions tcl language 
proc 
th annual tcl tk workshop pages 
usenix july 
cristian :10.1.1.30.591
understanding fault tolerant distributed systems 
communications acm feb 
diaz 
observer concept formal line validation distributed systems 
ieee transactions software engineering 
digital equipment hewlett packard ncr object design sunsoft common object request broker architecture specification version 
object management group framingham massachusetts dec 
eckhardt lee 
theoretical basis analysis redundant software subject coincident errors 
ieee transactions software engineering 
feiler li 
consistency dynamic reconfiguration 
proceedings fourth international conference configurable distributed systems pages 
ieee computer society press may 
ford back benson lepreau lin shivers 
flux oskit substrate os language research 
proc 
th acm symposium operating systems principles oct 
fritzson 
assertions declarative operational models automated debugging 
journal systems software 
weinstock eds 
workshop state practice upgrading critical systems 
technical report cmu sei sr software engineering institute aug 
kramer 
maintaining node consistency face dynamic change 
proceedings third international conference configurable distributed systems pages 
ieee computer society press may 
hamilton ed 
javabeans api specification 
technical report sun microsystems hauptmann 
line fly software replacement 
proceedings third international conference configurable distributed systems pages 
ieee computer society press may 
magee 
replication protocol support dynamically configurable groups servers 
proceedings third international conference configurable distributed systems pages 
ieee computer society press may 
knight leveson 
empirical study failure probabilities multi version software 
proceedings th international symposium faulttolerant computing ftcs pages new york july 
ieee 
knight leveson 
experimental evaluation assumption independence multi version programming 
ieee transactions software engineering 
kramer magee 
evolving philosophers problem dynamic change management 
ieee transactions software engineering nov 
little shrivastava 
application specific knowledge configuring object replicas 
proceedings third international conference configurable distributed systems pages 
ieee computer society press may 
miller 
conceptual modelling coincident failures multiversion software 
ieee transactions software engineering dec 
luckham 
programming specifications anna language specifying ada programs 
texts monographs computer science 
springer verlag new york 
magee dulay eisenbach kramer 
constructive development environment parallel distributed systems 
proceedings second international workshop configurable distributed systems 
ieee press mar 
matos white 
application dynamic reconfiguration design fault tolerant production systems 
proceedings fourth international conference configurable distributed systems pages 
ieee computer society press may 
meyer 
object oriented software construction 
prentice hall new york 
taylor 
role software architectures runtime system reconfiguration 
proceedings fourth international conference configurable distributed systems pages 
ieee computer society press may 
orr mecklenburg lepreau 
dynamic program monitoring transformation omos object server 
kluwer academic boston massachusetts feb 
ousterhout 
tcl tk toolkit 
professional computing series 
addison wesley reading ma 

polylith software bus 
acm transactions programming languages systems jan 

environment developing fault tolerant software 
ieee transactions software engineering jan 
rodriguez ierusalimschy 
dynamic configuration corba components 
proceedings fourth international conference configurable distributed systems pages 
ieee computer society press may 
rosenblum 
automated monitoring component integrity distributed object systems 
advanced topics workshop rd usenix conference object oriented technologies systems 
usenix association june 
rosenblum 
practical approach programming assertions 
ieee transactions software engineering 
sha rajkumar 
evolving dependable real time systems 
componentbased software engineering selected papers software engineering institute pages 
ieee computer society press 
reprinted proc 
aerospace applications conf 
shrivastava 
lessons learned building distributed programming system volume lecture notes computer science 
springer verlag new york 
van der hoek heimbigner wolf 
software architecture configuration management configurable distributed systems trois 
technical report cu cs university colorado jan 
warren sommerville 
model dynamic configuration preserves application integrity 
proceedings third international conference configurable distributed systems pages 
ieee computer society press may 
welch 
building self reconfiguring distributed systems compensating reconfiguration 
proceedings fourth international conference configurable distributed systems pages 
ieee computer society press may 
yau cheung 
design self checking software 
proc 
international conference reliable software pages new york 
acm 
