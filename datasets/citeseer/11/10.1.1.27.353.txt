til type directed optimizing compiler ml david tarditi greg morrisett perry cheng chris stone robert harper peter lee february cmu cs school computer science carnegie mellon university pittsburgh pa appear proceedings acm sigplan conference programming language design implementation philadelphia pennsylvania may 
published fox memorandum cmu cs fox describe new compiler standard ml called til technologies intensional polymorphism tag free garbage collection conventional functional language optimization loop optimization 
intensional polymorphism tag free garbage collection provide specialized representations sml polymorphic language 
conventional functional language optimization reduce cost intensional polymorphism loop optimization generate code recursive functions 
example til compiling sml function machine code compare performance til code widely compiler standard ml new jersey 
research sponsored part advanced research projects agency title fox project advanced languages systems software arpa order 
issued esc ens contract 
part national science foundation 
ccr part isaac newton institute mathematical sciences cambridge england 
david tarditi partly supported bell labs phd scholarship 
views contained document authors interpreted representing official policies expressed implied advanced research projects agency government national science foundation keywords standard ml compilation type theory polymorphism tag free garbage collection optimization applicative functional programming investigating new approach compiling standard ml sml key technologies intensional polymorphism nearly tag free garbage collection conventional functional language optimization loop optimization 
explore practicality approach constructed compiler sml called til far encouraged results dec alpha workstations programs compiled til roughly times faster fifth total heap allocation half physical memory programs compiled sml new jersey sml nj 
results preliminary investigated improve compile time til takes times longer compile programs sml nj 
implemented full module system sml provide support structures separate compilation 
expect performance programs compiled til improve significantly tune compiler implement optimizations 
key issues compilation advanced languages sml presence garbage collection type variables 
compilers universal representation values unknown variable type 
particular values forced fit tagged machine word values larger machine word represented pointers tagged heap allocated objects 
approach supports fast garbage collection efficient polymorphic functions result inefficient code types known compile time 
advances sml compilation leroy representation analysis values placed universal representation stored updateable data structures arrays recursive data structures lists 
intensional polymorphism tag free garbage collection eliminate need universal representation compiling polymorphic languages 
til uses technologies represent data values naturally 
example til provides tag free unallocated word sized integers aligned unboxed floating point arrays unallocated multi argument functions 
natural representations calling conventions improve performance sml programs allow interoperate legacy code written languages fortran 
types unknown compile time til may produce machine code slower bigger conventional approaches 
types constructed passed polymorphic functions polymorphic functions examine types run time determine appropriate execution paths 
types known compile time overhead incurred support polymorphism garbage collection 
technologies polymorphic functions slower important eliminate polymorphic functions compile time possible 
inlining uncurrying known techniques eliminating polymorphic higher order functions 
benchmarks techniques eliminate polymorphic functions higher order functions programs compiled 
applying traditional loop optimizations recursive functions common sub expression elimination invariant removal important 
fact optimization reduce execution time median 
important property til optimizations key transformations performed typed intermediate languages name til 
maintaining correct type information optimization necessary support intensional polymorphism garbage collection require type information run time 
strongly typed intermediate languages ensure type information maintained principled fashion relying ad hoc invariants 
fact intermediate forms til untrusted compiler produce fully optimized intermediate code client automatically verify type integrity code 
ability strong engineering benefit type checking output optimization transformation helps identify eliminate bugs compiler 
remainder describe technologies til detail give overview structure til detailed example showing til compiles ml code give performance results code produced til 
overview technologies section contains high level overview technologies til 
intensional polymorphism intensional polymorphism eliminates restrictions data representations due polymorphism separate compilation datatypes garbage collection 
supports efficient calling conventions multiple arguments passed registers tag free polymorphic structural equality 
intensional polymorphism types constructed passed values run time polymorphic functions functions branch types 
example extracting value array til uses typecase expression determine type array select appropriate specialized subscript operation fun sub ff ff array int typecase ff int 
float 
ptr 
type array determined compile time optimizer eliminate typecase sub float 
intensional polymorphism comes costs 
construct pass representations types polymorphic functions run time 
furthermore compile polymorphic functions support possible representation insert typecase constructs select appropriate code paths 
code generate polymorphic functions bigger slower minimizing polymorphism quite important 
second order type information run time intensional polymorphism garbage collection propagate types stage compilation 
address second problem compilation stages including optimization closure conversion expressed type directed type preserving translations strongly typed intermediate languages 
key difficulty typed intermediate languages formulating type system expressive statically type check terms branch types run time sub 
type system til approach suggested harper morrisett 
types represented expressions simply typed calculus extended inductively generated base kind monotypes corresponding induction elimination form 
induction elimination form essentially typecase type level allows write type expressions track run time control flow term level typecase expressions 
type system til remains sound decidable 
implies stage optimization automatically verify type integrity code 
conventional loop oriented optimizations program optimization crucial reducing cost intensional polymorphism improving loops recursive functions eliminating higher order polymorphic functions 
til employs optimizations conventional functional language compilers including inlining uncurrying dead code elimination constant folding 
addition til set generalized optimizations improve recursive functions 
optimizations include elimination invariant removal array bound check removal 
spite large number different optimizations optimization produces type correct code 
til applies optimizations entire compilation units 
inlining uncurrying eliminate higher order functions interfere loop oriented optimizations 
optimizations applied entire compilation units may programs paid close attention algorithmic efficiency individual optimization passes 
passes logn worst case asymptotic complexity excluding checking types equality program size 
nearly tag free garbage collection nearly tag free garbage collection uses type information eliminate data representation restrictions due garbage collection 
basic idea record representation information compile time point garbage collection occur possible determine values pointers traced garbage collector 
recording information compile time possible code untagged representations 
called conservative collectors see example information recorded til sufficient collect unreachable objects 
collection nearly tag free tags placed heap allocated data structures records arrays values registers stack data structures remain tagless 
construct tags monomorphic records arrays compile time 
records arrays unknown component types may need construct tags partially run time 
polymorphic operations intensional polymorphism construct tags 
registers components stack frames tagged 
generate tables compile time describe layout registers stack frames 
associate tables addresses call sites functions compile time 
garbage collection invoked collector scans stack return address frame index table 
collector looks layout stack frame determine stack locations trace 
record additional liveness information variable avoid tracing pointers longer needed 
approach understood monomorphic languages requiring garbage collection 
tolmach extended polymorphic language follows variable type unknown saved stack frame type variable saved stack frame 
tolmach evaluate substitutions ground types type variables eagerly lazily 
due part technical reasons see chapter part avoid class space leaks result lazy substitution 
compilation phases til shows various compilation phases til 
phases including closure conversion typed intermediate language 
phase closure conversion untyped front parse elaborate eliminate pattern matching inlining uncurrying cse invariant removal conventional loop optimizations closure conversion close functions choose environment representations conversion untyped language gc info 
calculate gc info variables choose representation types conversion rtl choose machine representation variables introduce tagging records arrays conversion introduce intensional polymorphism choose data representations type directed optimization flatten args flatten constructors box floats register allocation graph coloring register allocation construct tables gc assembly typed intermediate languages registers annotated gc info phases til compiler language variables annotated garbage collection information 
low level phases compiler languages registers annotated garbage collection information 
sections describe phases til intermediate languages detail 
front phase til uses front ml kit compiler parse elaborate type check sml source code 
kit produces annotated syntax sml compiles subset syntax explicitly typed core language called lambda 
compilation lambda eliminates pattern matching various derived forms 
extended lambda support signatures structures modules separate compilation 
source module compiled lambda module explicit list imported modules signatures 
imported signatures may include transparent definitions types defined modules til supports limited form translucent manifest types 
currently mapping lambda handle signatures nested structures functors 
principle constructs supported til intermediate languages 
type directed optimizations stands ml intensionally polymorphic language provides explicit support constructing passing analyzing types run time 
constructs translation lambda provide efficient data representations user defined datatypes multi argument functions tag free polymorphic equality specialized arrays 
conversion lambda til performs series type directed optimizations 
sml provides single argument functions multiple arguments passed record 
optimization argument flattening translates function takes record argument function takes components record multiple arguments 
arguments passed registers avoiding allocation create record memory operations access record components 
function takes argument variable type ff typecase determine proper calling convention instantiation ff run time 
functions datatype constructors sml take single argument 
example cons data constructor ff list takes single record consisting ff value ff list value 
naively constructor represented pair consisting tag cons pointer record containing ff value ff list value 
tag small integer value distinguish constructors datatype nil vs 
constructor flattening rewrites constructors take records arguments components records flattened 
addition constructor flattening eliminates tag components unneeded 
example cons applied hd tl simply represented pointer pair hd tl pointer distinguished nil 
constructor takes argument unknown type typecase determine proper representation instantiation ff run time 
lists sml sml nj compiler flattens cons cells constructors 
violation sml definition sml nj prevents programmers abstracting type constructors order prevent representation mismatches definitions datatypes uses 
contrast til supports fully datatype components uses intensional polymorphism determine representations datatypes potentially run time 
addition specializing calling conventions datatypes conversion lambda polymorphic equality explicit term language 
arrays specialized cases int arrays float arrays pointer arrays 
intensional polymorphism select appropriate creation subscript update operations polymorphic arrays 
til boxes floating point values values stored floating point arrays 
chose box floats record operations faster typical sml code manipulates records floats 
issue floating point values bits scalars pointers bits 
floats unboxed record offset calculations done compile time 
fortunately optimizer eliminates box unbox operations constant folding phase straight line floating point code runs fast 
combination type directed optimizations reduce running times roughly allocation chapter 
improvement realized techniques example sml nj uses leroy unboxing technique achieve comparable improvements calling conventions :10.1.1.14.4810
advantage approach single mechanism intensional polymorphism specialize calling conventions flatten constructors unbox floating point arrays eliminating tags polymorphic equality garbage collection 
optimizations til employs extensive set optimizations 
optimizations include typically done compilers functional languages 
include loop oriented optimizations invariant removal applied recursive functions 
til translates subset called 
normal form regular intermediate language facilitates optimization 
translation names intermediate computations binds variables construct 
names potentially heap allocated values including strings records functions 
allows nested expressions switches branch expressions 
translation linearizes names nested computations values 
translation til performs conventional transformations ffl alpha conversion bound variables uniquely renamed 
ffl dead code elimination unreferenced pure expressions functions eliminated 
ffl uncurrying curried functions transformed multi argument functions possible 
ffl constant folding arithmetic operations switches constant values reduced projections known records 
ffl sinking pure expressions branch switch pushed branch 
expressions pushed function definitions 
ffl inlining non escaping functions called inlined 
small nonrecursive functions inlined bottom pass 
recursive functions directly inlined 
ffl inlining switch continuations continuation switch inlined branch raises exception 
example expression raise transformed raise expressions available optimizations common sub expression elimination 
ffl minimizing fix mutually recursive functions broken sets strongly connected components 
improves inlining dead code elimination separating non recursive recursive functions 
addition standard functional language transformations til applies optimizations recursive functions ffl common subexpression elimination cse expression pure effect may raise exception occurrences replaced expressions excluded cse side effecting expressions function calls 
ffl eliminating redundant switches expression nested statement replaced true point 
ffl invariant removal call graph calculate nesting depth function 
nesting depth analogous loop nesting depth languages 
til assigns bound variable expression binds nesting depth equal nearest enclosing function 
pure expression free variables nesting depth til moves definition right definition free variable highest lexical nesting depth 
ffl hoisting constant expressions hoisted top program 
expression constant expression uses constants variables bound constant expressions 
ffl eliminating redundant comparisons set simple arithmetic relations form propagated top program 
rule signs interpretation determine signs variables 
information eliminate array bounds checks tests 
til applies optimizations follows performs round reduction optimizations including dead code elimination constant folding inlining functions called cse eliminating redundant switches invariant removal 
optimizations increase program size result faster code 
iterates optimizations reductions occur 
performs switch continuation inlining sinking uncurrying comparison elimination fix minimizing inlining 
entire process starting reduction optimizations iterated times 
closure conversion til uses type directed closure conversion style suggested minamide morrisett harper convert programs closure programs :10.1.1.141.7192
closure extension provides constructs explicitly constructing closures environments 
escaping function til generates closed piece code type environment value environment 
code takes free type variables free value variables original function extra arguments 
types values corresponding free variables placed records 
records paired code form closure 
til uses flat environment representation type value environments 
known functions til generates closed code avoids creating environments closure 
kranz modify call sites known functions pass free variables additional arguments 
til closes variables function arguments bound functions 
locations top level variables resolved compile time traditional linking values need stored closure 
conversion untyped language simplify conversion low level assembly code til translates closure programs untyped language called 
simpler language similar type level term level constructs collapsed term level constructor 
example translation closure til replaces typecase conventional switch expression 
simplifies generation low level code fewer cases 
til annotates variables representation information tells garbage collector kinds values variables contain pointers integers floats pointers code 
representation variable may unknown compile time case representation information name variable contain type run time 
conversion rtl til converts programs rtl register transfer language similar alpha risc style assembly language 
rtl provides infinite number pseudo registers annotated representation information 
representation information extended include pointers middle objects 
pseudo registers containing live point garbage collection occur 
rtl provides heavyweight function call return mechanisms form interprocedural goto implementing exceptions 
conversion rtl decides variables represented constants labels pseudo registers 
eliminates exceptions inserts tagging operations records arrays inserts garbage collection checks 
register allocation assembly doing register allocation til converts rtl programs alpha assembly language extensions similar rtl 
til uses conventional graph coloring register allocation allocate physical registers pseudo registers 
generates tables describing layout garbage collection information stack frame described section 
til generates actual alpha assembly language invokes system assembler instruction scheduling creates standard object file 
example section shows ml function passes various stages til 
sml code defines dot product function inner loop integer matrix multiply benchmark val sub array int int 
fun dot cnt sum cnt bound val sum sum sub cnt sub cnt dot cnt sum sum function sub built array subscript function front expands fun sub rows vg int int orelse rows orelse orelse columns raise subscript unsafe sub columns figures show actual intermediate code created dot sub pass various stages til 
readability renamed variables erased type information performed minor optimizations eliminating selections fields known records 
shows functions converted 
sub function takes type argument 
function parameterized type written function parameterized value written dot function sub function applied type applied actual values 
function takes argument record fields selected 
quality code level quite poor function applications record constructions numerous checks array bounds 
shows fragment converted 
functions transformed take multiple arguments records intermediate named 
shows fragment optimized 
function applications body loop eliminated 
ai av application sub fix ty 
fix arg 
arg arg arg columns rows check test switch enum test 
enum 
test rows switch enum test 
enum 
test switch enum test 
enum 
columns switch enum check 
raise subscript 
unsafe sub ty fv fix dot cnt sum cnt bound switch enum 
sum sum sub int fa sub int fb cnt jg sum 
sum conversion sub fix dot cnt sum 
test cnt bound switch enum test 
sub int cnt sub int cnt sum cnt dot 
sum optimization unsafe integer array subscript primitive 
comparisons array bounds checking safely eliminated body loop consists expressions 
loop improved implement form strength reduction induction variable elimination 
shows fragment converted 
variable annotated representation information garbage collector 
int denotes integers trace denotes pointers tagged objects 
function closed closure converted converting 
shows fragment converted rtl 
pseudo register annotated precise representation information collector 
representation information extended include locative denotes pointers middle tagged objects 
live garbage collection points 
indicates points ai primitive expanded rtl instructions 
indicates induction variable elimination profitable rtl level 
return instruction operand pseudo register containing return address 
shows actual dec alpha assembly language generated dot function 
code corresponds rtl code 
code epilogue prologue code entering exiting function 
note tagging operations occur function 
fix dot cnt sum 
test cnt bound switch enum test 
cnt ai av columns cnt ai bv sum cnt dot 
sum optimization fix dot bound int columns int bv trace av trace int int cnt int sum int 
test int bound cnt int test 
int cnt int ai av int columns cnt int int ai bv int int sum int cnt int dot bound columns bv av 
sum int conversion dot bound int columns int bv trace av trace int int cnt int sum int bound int cnt int test int bne test int mv sum int result int br addl int cnt int int add int av trace locative ldl int locative columns int cnt int int addl int int int add int bv trace locative ldl int locative int int int addl sum int int int addl cnt int int mv int cnt int mv int sum int br return label conversion rtl ent lv dot arguments bound columns bv av cnt sum results result return addr destroys lv dot mask 
frame sp prologue gp lda sp sp stq sp stq sp stq sp mov bne mov br addl addl ldl addl addl ldl br mov mov ldq sp ldq sp lda sp sp ret lv dot actual dec alpha assembly language performance section compare performance programs compiled til programs compiled sml nj compiler 
measure execution time heap allocation physical memory requirements executable size compile time 
measure effect loop optimizations 
performance analysis til appears morrisett tarditi theses 
benchmarks table describes benchmark programs range size lines lines code 
programs previously measuring ml performance 
benchmarks cover range application areas including scientific computing list processing systems programming compilers 
compiled programs single closed modules 
lexgen simple standard benchmarks eliminated functors hand til support full sml module language 
programs compiler optimizer naturally eliminated polymorphic functions 
consequently benchmark suite run time cost support intensional polymorphism 
extended built ml types safe dimensional arrays 
array operations bounds checking dimension unsafe array operations 
arrays stored column major order 
comparison sml nj compared performance til sml nj dimensions execution time total heap allocation physical memory footprint size executable compilation time 
til compiled programs optimizations enabled 
sml nj compiled programs default optimization settings 
internal release sml nj variant version produces code faster current standard release sml nj 
til prefixes set operations module compiles order facilitate optimization 
inline prelude contains array operations commonly list functions forth 
avoid sml nj created separate copies benchmark programs sml nj placed equivalent prelude code program hand 
til creates stand executables facility sml nj create stand programs 
function sml nj dumps part heap disk throws away interactive system 
measured execution time dec alpha axp lx workstations running osf version unix function 
sml nj started timing heap reloaded 
til measured entire execution time process including load time 
runs program unloaded workstation chose lowest execution time 
workstation mbytes physical memory paging factor measurements 
measured total heap allocation instrumenting til run time system count bytes allocated 
existing instrumentation sml nj run time system 
measured maximum amount physical memory execution 
size program measure size executables til 
sml nj size program program lines description checksum checksum fragment doing checksums byte array 
fft fast fourier transform multiplying polynomials degree knuth bendix implementation knuth bendix completion algorithm 
lexgen lexical analyzer generator processing lexical description standard ml 
life game life implemented lists 
matmult integer matrix multiply integer arrays 
pia perspective inversion algorithm deciding location object perspective video image 
simple spherical fluid dynamics program run iterations grid size 
table benchmark programs measure size run time system added size heap created 
measured compilation time including time assemble files produced til 
figures measurements raw numbers appendix 
benchmark measurements til normalized sml nj graphed 
sml nj performance mark graphs 
presents relative running times 
average programs compiled til run times faster programs compiled sml nj 
fact programs knuth bendix life substantially faster compiled til 
speculate speed seen knuth bendix life heavy list processing sml nj job compiling 
compares relative amounts heap allocation 
average amount data heap allocated til program amount allocated sml nj program 
surprising til uses stack sml nj allocates frames heap 
presents relative maximum amounts physical memory 
average til programs half memory sml nj programs 
see floating point programs amount memory relative comparable sml nj programs 
speculate due til ability keep floating values unboxed stored arrays 
til stand programs half size stand heaps runtime system sml nj 
difference size due different sizes runtime systems standard libraries compilers 
til runtime system sml nj runtime 
program sizes til confirm generating tables nearly garbage collection consumes modest amount space inlining strategy til produces code reasonable size 
compares compilation times til sml nj 
sml nj better til comes compilation time compiling times faster 
tune til compilation speed 
fft kb lexgen life pia simple til execution time relative sml nj fft kb lexgen life pia simple til heap allocation relative sml nj fft kb lexgen life pia simple til physical memory relative sml nj fft kb lexgen life pia simple til compilation time relative sml nj exec time opt exec time heap alloc opt heap alloc fft kb lexgen life pia simple effects loop optimizations loop oriented optimizations investigated effect loop oriented optimizations cse invariant removal hoisting comparison elimination redundant switch elimination 
benchmark compared performance loop optimizations performance loop optimizations 
presents ratios execution time loop optimizations execution time loop optimizations similar ratios total heap allocation 
loop optimizations reduce execution time median reduction 
effect heap allocation ranges increase decrease median decrease 
matmult matrix multiplication function small optimizer inlines making array dimensions known 
array dimensions held unknown loop optimizations speed matmult factor 
related morrison ad hoc approach implement polymorphism implementation napier 
particular passed representations types polymorphic routines run time determine behavior 
knowledge napier types implement tag free garbage collection 
description internals napier compiler account performance code generated compiler 
peyton jones launchbury suggested types unbox values polymorphic language 
supported limited set unboxed types ints floats restricted types instantiating type variables 
leroy suggested general approach unboxing values ml type system 
leroy approach extended implemented including sml nj compiler :10.1.1.14.4810
support unboxed array components flattened recursive datatypes 
tolmach combined leroy approach tag free garbage collection 
ad hoc approach propagate type information collector 
researchers suggested polymorphism eliminated entirely compile time style templates 
prevents separate compilation polymorphic definition uses 
contrast intensional polymorphism particular intermediate forms til support separate compilation polymorphic definitions take advantage 
tag free garbage collection originally proposed monomorphic languages pascal 
britton suggested associating type information return addresses stack 
appel suggested extending technique ml unification 
goldberg improved appel algorithm 
algorithms implemented due complexity algorithms overhead performing unification garbage collection 
aditya flood hicks type passing support fully tag free garbage collection id 
independently tolmach implemented type passing garbage collection algorithm ml 
approach differs nearly tag free collection 
particular records arrays heap tagged 
difference calculate type environments eagerly implementations construct type environments lazily garbage collection 
loop oriented optimizations known imperative languages 
results reported lisp scheme ml 
appel serrano report common subexpression elimination optimizations similar 
appel cse useful sml nj compiler 
serrano restricted cse pure expressions cse handles expressions may raise exceptions 
results show core sml programs compiled intensional polymorphism remove restrictions data representation cost literally due effectiveness optimization 
show loop optimizations improve program performance significantly 
results suggest ml compiled conventional languages pascal 
til produces code similar important respects code produced pascal compilers 
example function calls known higher order functions left integers untagged code monomorphic 
numerous areas investigate 
explore effect separate compilation 
separate compilation polymorphic functions may compiled separately uses leading cost intensional polymorphism 
measure cost explore kinds optimizations reduce 
direction investigate approach performs larger programs 
add support ml module system large ml programs extensive module system 
improve til compile times large programs compiled 
continue improving performance ml programs 
extend register allocation strategy lines chow steenkiste 
investigate loop optimizations strength reduction elimination loop unrolling 
speculative note explore stack allocation data structures 
aditya christine flood james hicks 
garbage collection strongly typed languages run time type reconstruction 
lfp pages 
alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley publishing 
andrew appel 
critique standard ml 
journal functional programming october 
andrew appel 
runtime tags aren necessary 
lisp symbolic computation 
andrew appel 
compiling continuations 
cambridge university press 
andrew appel james mattson david tarditi 
lexical analyzer generator standard ml 
distributed standard ml new jersey 
robert harper peter lee brian 
signatures network protocol stack systems application standard ml 
lfp pages 
lars birkedal nick rothwell mads tofte david turner 
ml kit version 
technical report diku 
guy blelloch 
nesl nested data parallel language version 
technical report cmu cs school computer science carnegie mellon university april 
hans juergen boehm 
space efficient conservative garbage collection 
pldi pages 

scheme storage allocation garbage collection algol 
algol implementation 
north holland publishing amsterdam 
ellen britton 
heap storage management programming language pascal 
master thesis university arizona 
fred chow 
minimizing register usage penalty procedure calls 
proceedings acm sigplan conference programming language design implementation pages atlanta georgia june 
acm 
demers weiser hayes boehm bobrow shenker 
combining generational conservative garbage collection framework implementations 
conference record th annual acm sigplan sigact symposium principles programming languages san francisco california january 
acm 
amer diwan eliot moss richard hudson 
compiler support garbage collection statically typed language 
proceedings acm sigplan conference programming language design implementation pages san francisco ca june 
acm 
amer diwan david tarditi eliot moss 
memory system performance programs intensive heap allocation 
transactions computer systems august 
arvind 
simple exercise scientific programming 
technical report computation structures group memo mit cambridge ma july 
simultaneously published ibm watson research center research report yorktown heights ny 
cormac flanagan amr sabry bruce duba matthias felleisen 
essence compiling continuations 
pldi pages 
benjamin goldberg 
tag free garbage collection strongly typed programming languages 
proceedings acm sigplan conference programming language design implementation pages toronto canada june 
acm 
benjamin goldberg michael 
polymorphic type reconstruction garbage collection tags 
proceedings acm conference lisp functional programming pages san francisco california june 
acm 
cordelia hall simon peyton jones patrick sansom 
unboxing specialisation 
turner hammond editor functional programming 
springer verlag 
robert harper mark lillibridge 
type theoretic approach higher order modules sharing 
popl pages 
robert harper greg morrisett 
compiling polymorphism intensional type analysis 
conference record nd annual acm sigplan sigact symposium principles programming languages pages san francisco california january 
acm 
fritz henglein jesper jrgensen 
formally optimal boxing 
popl pages 
jones 
partial evaluation dictionary free overloading 
research report yaleu dcs rr yale university new haven connecticut usa april 
simon peyton jones john launchbury 
unboxed values class citizens 
proceedings conference functional programming computer architecture volume lecture notes computer science pages 
acm springer verlag 
david kranz richard kelsey jonathan rees paul hudak james philbin norman adams 
orbit optimizing compiler scheme 
proceedings sigplan symposium compiler construction pages palo alto california june 
acm 
xavier leroy 
unboxed objects polymorphic typing 
conference record th annual acm sigplan sigact symposium principles programming languages pages albuquerque nm january 
acm 
xavier leroy 
manifest types modules separate compilation 
popl pages 
proceedings acm conference lisp functional programming orlando florida june 
acm 
robin milner mads tofte robert harper 
definition standard ml 
mit press 
minamide morrisett harper :10.1.1.141.7192
typed closure conversion 
conference record rd annual acm sigplan sigact symposium principles programming languages st petersburg florida january 
acm 
greg morrisett 
compiling types 
phd thesis school computer science carnegie mellon university pittsburgh pa december 
published technical report cmu cs 
greg morrisett matthias felleisen robert harper 
models memory management 
acm conference functional programming computer architecture pages la jolla june 
morrison dearle connor brown 
ad hoc approach implementation polymorphism 
acm transactions programming languages systems july 
proceedings acm sigplan conference programming language design implementation albuquerque new mexico june 
acm 
conference record st annual acm sigplan sigact symposium principles programming languages portland oregon january 
acm 

representation analysis efficient implementation polymorphism 
technical report department computer science diku university copenhagen april 
master dissertation 
chris 
elements functional programming 
addison wesley reading massachusetts 
manual serrano pierre weis 
optimizing caml compiler 
technical report inria june 
zhong shao 
compiling standard ml efficient execution modern machines 
phd thesis princeton university princeton new jersey november 
zhong shao andrew appel :10.1.1.14.4810
type compiler standard ml 
proceedings acm sigplan conference programming language design implementation pages la jolla california june 
acm 
peter steenkiste 
advanced register allocation 
peter lee editor topics advanced language implementation 
mit press 
bjarne stroustrup 
programming language nd edition 
addison wesley 
david tarditi 
optimizing ml 
phd thesis school computer science carnegie mellon university 
forthcoming 
andrew tolmach 
tag free garbage collection explicit type parameters 
lfp pages 
kevin waugh patrick greg michaelson 
parallel implementations function prototypes case study 
technical report computer science heriot watt university edinburgh august 

methods garbage collection algol 
algol implementation 
north holland publishing amsterdam 
raw performance numbers program exec 
time til nj til nj checksum fft knuth bendix lexgen life matmult pia simple geo 
mean table comparison running times program heap alloc 
kbytes til nj til nj checksum fft knuth bendix lexgen life matmult pia simple geo 
mean excluding matmult table comparison heap allocation program phys 
mem 
kbytes til nj til nj checksum fft knuth bendix lexgen life matmult pia simple geo 
mean table comparison maximum physical memory program exec 
size kbytes til nj til nj checksum fft knuth bendix lexgen life matmult pia simple geo 
mean table comparison stand executable sizes program comp 
time til nj til nj checksum fft knuth bendix lexgen life matmult pia simple geo 
mean table comparison compilation times program exec 
time heap alloc 
checksum fft knuth bendix lexgen life matmult pia simple median geo 
mean table ratios performance loop optimization performance loop optimization 
