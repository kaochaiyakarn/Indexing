automatic sat compilation planning problems michael ernst todd millstein daniel weld department computer science engineering university washington box seattle wa usa todd cs washington edu kautz provides tantalizing evidence large classical planning problems may efficiently solved translating propositional satisfiability problems stochastic search techniques translating resulting truth assignments back plans original problems 
explore space transformations providing simple framework generates major encodings generated selecting action representations frame axioms number subsidiary ones 
describe fully implemented compiler generate encodings test compiler suite strips planning problems order determine encodings best properties 
despite early formulation planning theorem proving green researchers long assumed special purpose planning algorithms necessary practical performance 
improvements performance propositional satisfiability methods cook mitchell cast doubt 
initial results compiling bounded length planning problems sat unremarkable kautz selman experiments kautz selman suggest compilation sat yield world fastest strips style planner 
open questions answered concluding sat planning dominates specialized algorithms 
experiments kautz selman hand crafted sat encodings kautz describe methods compilation reported experiments automatically compiled problems knows encodings best 
encodings kautz selman included domain information inexpressible strips action language fluent irreflexive noncommutative extent information responsible speedup observed 
addresses issues appears proceedings th international joint conference artificial intelligence ijcai nagoya japan august pp 

research funded part office naval research national science foundation iri arpa rome labs gift rockwell international palo alto research 
ffl analytic framework accounts previously reported non causal encodings including novel possibilities 
parameterize space encodings major dimensions action frame representation 
twelve points twodimensional space list axioms necessary minimal encoding calculate asymptotic encoding sizes 
ffl describe automatic compiler generates encodings 
difficult compiler produce encodings lean hand coded versions kautz selman describe factoring techniques get close 
experiments demonstrate methods reduce number variables half formula size 
ffl run compiler suite strips style planning problems determining regular simply split explanatory encodings smallest solved fastest 
space encodings section presents framework describes encodings causal encodings new alternatives 
previous described individual encodings variety ways direct statebased avoid terms 
parameterized space dimensions ffl choice regular simply split overloaded split bitwise action representation specifies correspondence propositional variables ground plan actions 
choices represent different points tradeoff number variables number clauses formula 
ffl choice classical explanatory frame axioms varies way stationary fluents constrained 
encodings standard fluent model time takes nonnegative integer values 
state fluents occur times actions odd times 
encodings set universal axioms init initial state completely specified time zero including properties presumed false assumption 
goal order test plan length desired goal properties asserted true time 
omitted state encodings obtained resolving away actions encodings kautz 
actions imply preconditions effects 
odd time consistent ground action axiom asserts execution action time implies effects hold preconditions hold 
example suppose initial conditions specify blocks strips operator inconsistent instantiated yields axioms shown analogous axioms preconditions 
action representation major encoding choice represent actions regular simply split overloaded split bitwise 
regular representation ground action represented different logical variable total ao variables defines symbols systematic solvers take time exponential number variables large numbers variables slow stochastic solvers reduce number 
order kautz selman introduced simple operator splitting replaces ary action fluent unary fluents encoding 
example move replaced conjunction 
doing fully instantiated actions reduces number variables needed represent actions simple splitting instances operator share propositional variables 
alternative overloaded splitting operators share split fluents 
overloaded splitting replaces move conjunction act move arg arg arg different action paint red replaced act paint arg arg red 
technique reduces number variables needed represent actions 
bitwise representation shrinks number variables representing actions dlog ae propositional symbols odd time step representing bit 
ground actions numbered 
number encoded bit symbols determines ground action executes odd time step 
instance ground actions bit bit replace action bit bit replace second forth 
frame axioms frame classical explanatory frame axioms constrain unaffected fluents action occurs 
classical frame axioms mccarthy hayes state fluents left unchanged action 
example classical frame axiom move operator say moving block leaves clearness unchanged clear move clear adding classical frame axioms action odd time universal axioms produces valid encoding planning problem 
action occurs time axioms encoding infer truth value fluents time take arbitrary values 
solution add axioms time step 
move precond block clear table clear effect clear clear move clear move move clear move top strips definition blocks world operator moving object source destination 
bottom axiom schema showing instance move implies effects 
number operators number predicate symbols number constants domain number odd time steps plan may plan length ap max arity predicates ao max arity operators ar length action representation predicate symbols action regular simple split ao overloaded split ao bitwise dlog ae ao number ground actions ap number ground fluents po max num fluents mentioned operator symbols complexity analyses 
disjunction possible action ensures action occurs odd time step 
op action inserted preprocessing step 
note action representation huge effect size axioms 
resulting plan consists totally ordered sequence actions corresponds roughly linear encoding kautz include exclusion axioms see ensure action active time 
exclusion axioms unnecessary classical frame axioms combined axioms ensure actions occurring time lead identical world state time 
action occur time step selected form valid plan 
explanatory frame axioms haas enumerate set actions occurred order account state change 
example explanatory frame axiom say actions caused clearness status change true false 
clear clear move move move table supplement universal axioms explanatory frame axioms added ground fluent odd time produce reasonable encoding 
explanatory frames change fluent truth value implies action occurs action occurs time step correctly treated op 
axioms required 
explanatory frames explicitly force fluents affected executing action remain unchanged axioms necessary bitwise action representation spare bit patterns refer actual ground actions 
axiom action representation clauses clause size init goal arbitrary formula typically small ar frame classical nfa ar explanatory simple factored overloaded factored representations nar exclusion simple factored ao overloaded factored ao representations ara partial simple factored overloaded factored ao sizes axiom schema function action representation 
note combinations entries identical may different sizes value ar function action representation see 
permit parallelism 
specifically actions preconditions satisfied time effects contradict executed parallel 
kind parallelism problematic create valid plans linear solution 
example suppose action ff precondition effect action fi precondition effect actions executed parallel effects contradictory legal total ordering actions problematic non instantaneous real world actions 
exclusion linearizability resulting plans guaranteed restricting actions may occur simultaneously 
kinds exclusion enforce different constraints resulting plan ffl complete exclusion odd time step distinct fully instantiated action pairs ff fi add clauses form ff fi complete exclusion ensures action occurs time step guaranteeing totally ordered plan 
ffl conflict exclusion odd time step distinct fully instantiated conflicting action pairs ff fi add clauses form ff fi framework actions conflict precondition inconsistent effect 
conflict exclusion results plans actions form partial order 
total order consistent partial order valid plan 
wish consider minimal encoding corresponding choice action frame representations assume conflict exclusion possible 
conflict exclusion exploited split action representation splitting causes unique variable fully instantiated action 
example simple splitting impossible instantiations operator execute time split fluents interfere 
overloaded splitting disallows instantiations different operators execute time 
bitwise action representation requires action exclusion axioms 
time step action index represented bit symbols total ordering guaranteed 
contrast definition conflict graphplan blum furst kautz selman kautz selman parallel encoding linear encodings axioms stating actions imply effects parallel encoding prohibits effect effect conflicts 
optimizing axioms factoring base encodings generated choosing regular simple split overloaded split bitwise action representations choosing classical explanatory frames 
unfortunately choices lead small number variables splitting strategies bitwise tend explode number clauses size clause 
consider axiom disjunction fully instantiated actions 
substituting conjunction split bitwise variables regular action literal produces disjunctive normal form formula blows exponentially converted conjunctive normal form 
simple splitting axiom grows clauses size clauses size see 
formula blowup results blindly substituting complete conjunction split variables action frame exclusion axioms 
factoring dramatically reduce number clauses sizes simple overloaded splitting 
idea subset full conjunction action possible 
partially instantiated action represents set fully instantiated actions consistent 
bitwise action representation admit easy method factoring partial conjunctions bit variables useful clever action numbering scheme created 
factoring frame axioms frame axioms relate single fluent single action partial action instantiations 
example shows move operator axioms possible instantiation operator 
ordinary simple splitting transform axiom bottom clear similar axiom generated pairs constants move consistent action 
argument values irrelevant axiom simpler axiom clear eliminating need explicitly consider values 
number logically independent clauses may substantially smaller worst case bound results naive conversion clauses may contain duplicated literals clauses may logically imply 
implementation eliminates unnecessary literals clauses 
action representation regular simple overloaded bitwise factored factored vars nf na nf nf nf ao nf ao nf log classical nfa partial ao partial ao nfa log explanatory exclusion nfa na exclusion aoa exclusion partial ao exclusion nf aao exclusion partial ao nf log composition worst case size encodings 
bitwise action representation yields smallest number variables clauses regular actions exact opposite 
encodings init goal frame axioms 
additional clauses noted total size clauses 
reported numbers asymptotic numbers literals product numbers clauses clause sizes 
factoring axioms relies idea relating action fluent need include parts action conjunct pertaining arguments appear affected fluent 
technique extends easily classical explanatory frame axioms 
consider classical frame example section 
naively splitting move observe source object move irrelevant generate clear clear formula implicitly represents set classical frame axioms relating clearness move action having destination argument 
note factoring optimization crucial practice see section equivalent ordinary splitting worst case 
particular arity precondition effect fluents equal arity operator factoring possible 
factoring exclusion axioms pairwise exclusion clauses relate actions actions move move relating actions fluents previous technique 
factor axioms noting excluding actions occurring simultaneously independently exclude values argument action 
example factored exclusions move operator look ranging arguments distinct constants ensures fully instantiated move action active time doing operators ensure instance operator active time complete exclusion need ensure operators active instance time accomplished pairwise excluding possible arguments operator 
words add clauses distinct operators ff fi necessarily distinct constants shows factoring reduces asymptotic number size clauses compared split exclusion axioms 
factoring axioms factoring axiom explodes exponential conversion cnf 
fortunately factored easily yielding disjunction possible arguments operators axiom form op arg op arg op arg op arg 
axiom requires clauses size quite reduction case 
preventing partial action execution previous subsections show factor part encoding 
parts rely ability refer parts action referring complete instantiation action 
underlying assumption part instantiated rest action 
example want factored frame clause effect full action implied frame executed current time step 
frame constrain resulting plan action referred frame fully executed 
partial add axioms state part operator instantiated rest 
partial action elimination axioms move operator axioms ensure split fluent move true complete instantiation move true 
shows number size resulting clauses 
medic planner encodings described implemented classical planner accepts traditional inputs initial state goal formula strips action schemata returns sequence actions achieve goal 
medic planner operates compiling planning problem clausal form solving sat problem translating satisfying truth assignment back actions 
depending switch settings sat encodings described generated 
medic planner forms unique testbed exploring properties different encodings 
architecture planner shown 
action schemata parsed preprocessor contrast implementation kautz selman accepts direct encodings logical constraint language strips actions 
initial state actions axiom schemas decode type opt plan goal action repr frame repr shift time duplicate simplify solve repeat needed varying plan length solution architecture medic planner 
ucpop planner penberthy weld type optimization see performed 
guided choice action frame representations compiler creates master axiom schema representing action possibilities time step 
periodic axiom schema instantiated multiple times plan length currently considered 
output duplication module combined initial state goal specification simplified pure literal elimination unit clause propagation duplicate literal elimination fast linear time procedure van gelder tsuji resulting clauses solved walksat selman tableau crawford auton optimizations planning reduction propositional satisfiability impractical number optimizations determine truth values fluents limit ground instantiations actions 
foremost type optimizations 
type fluent action affects 
types constrain operator instantiation ruling impossible ground versions 
instance blocks prune instantiation move operator assign preconditions reflected operator instantiations types need appear final encoding instance block precondition removed move 
mechanism generalization obvious handling equality inequality constraints special cases types 
usefulness type information explored methods inferring types arguments operators specify 
suppose block appear move definition clear appears action effect variable action precondition contains fluent block 
constant clear block 
constant clear initial conditions block deduce clear constant block add block move precondition 
similarly inequality constraints inferred fluent appears positively negatively operator bindings identical 
move operator effects constraint inferred 
operator instantiations pruned eliminating symmetric operator instantiations 
instance operator ff takes arguments identically sense considering bindings ff ff arbitrarily select possibilities 
analysis cuts number ground instantiations order magnitude refrigerator domain 
medic planner reduces bindings infers invariant fluents enforcing form consistency 
approximation set fluents true false computed iterative dataflow analysis 
approximation initial condition step fluents effects actions fire current approximations added sets 
process guaranteed terminate tantamount solving planning problem time ignored permitting impossible situations presence fluent negation 
cnf simplification step quite important fast reduce formula size enormously 
cnf simplification operates knowledge structure problem effects similar optimizations listed 
instance type elimination described 
performing steps earlier reduce encoding time factor due generation smaller formulae 
optimizations allow simplifier reduce formula 
optimization factoring factored action representations reduce benefit type optimizations 
performing factored simple splitting unary types eliminated effect restricted fully reflected just action predicate symbols 
binary types eliminated consider binary operator ff takes non equal arguments 
objects instantiations ff ff possible new action fluents take argument necessary leave axiom encoding prevent illegal argument combinations 
overloaded action representations admit elimination unary types single action fluent represents nth argument different operators different constraints 
searching minimal plan far assumed trying find plan known length general plan length known advance 
medic planner capable linear binary search plan lengths 
encodings support linear search strategy modification 
implement binary search minimal plan length include explicit op maintain action classical frame axioms 
allows plans longer minimal length succeed 
walksat stochastic finding minimal length plan requires systematic solver tableau addition walksat 
moderately sized problems tableau take unreasonably long time verify solution exists 
verification moot sat solving time potentially exponential encoding size conjecture linear search strategy better haven performed serious tests 
log log log log log loga small bw med bw big bw bw hanoi hanoi monkey monkey tire tire ferry ferry fridge fridge variables fi fi fi fi fi fi fi log log log log log loga small bw med bw big bw bw hanoi hanoi monkey monkey tire tire ferry ferry fridge fridge clauses fi fi fi fi fi fi fi log log log log log loga small bw med bw big bw bw hanoi hanoi monkey monkey tire tire ferry ferry fridge fridge literals fi fi fi fi fi fi fi log log log log log loga small bw med bw big bw bw hanoi hanoi monkey monkey tire tire ferry ferry fridge fridge time seconds fi fi fi fi fi fi fi regular split overloaded bitwise classical explanatory ffi satplan fi numbers variables clauses literals simplified cnf formulas resulting encodings plus satplan hand encoding sans domain specific axioms 
values reported cnf simplifier solved problem 
times tenth second reported tenth 
trying find satisfying plan shortest 
experiments test various encodings encoded suite planning problems encodings 
factoring applied split action representations 
plots number variables clauses literals final simplified cnf formulae 
reports walksat solution times averaged runs note timing data hard interpret 
walksat fastest solution method 
suggested walksat flag settings satplan planner flags favor encodings 
timings reported kautz selman minima walksat runs varying parameter values 
believed solution time correlates cnf size report encoding simplification times medium large problems dominated solution time 
automatically determining solver flags best particular problem open problem selman progress mcallester asymptotic size bounds expect bitwise encodings smallest number variables regular encodings largest number variables 
surprisingly expectation fulfilled 
smallest encodings smallest encodings regular simply split explanatory encodings encodings quick solve times 
successes bring light interesting points relative merits encodings 
clear explanatory frame clauses superior classical frame clauses 
explanatory frames smaller state changes change action occurs 
general expect action affect relatively fluents 
parallelism big advantage shown success regular explanatory encoding 
parallel plans shorter length formula contains fewer copies periodic axioms 
additionally conflict exclusion axioms subset complete exclusions prohibit pairs actions 
conflict exclusion excludes pairs actions excluded order guarantee existence linearization partial order plan returned 
quite surprising regular explanatory encoding variables 
kautz selman dismiss encoding impractical 
size blow prohibitively worst case see practice encoding maintains excellent variable clause sizes 
remains competitive problems increase size problem sequence log log loga 
suspect compiler type optimizations handicapped factored splitting deserve credit 
largest encodings worst encodings regular bitwise classical encodings 
mentioned superiority explanatory classical frames 
regular classical outperformed split classical encodings 
worst case splitting clause sizes bigger regular encoding practice factoring keep sizes competitive 
splitting may provide simplifier flexibility allowing deduce reason parts actions actions hope generalizing 
encodings aided great decrease number variables compared regular encoding 
hand bitwise encoding smallest number variables simplification worst encoding 
simplification relatively ineffective encoding encodings fewer variables simplification phase 
may related fact bitwise uses set variables encode possible actions domain making impossible simplifier reason truth values variables 
graph number literals points obvious blow bitwise incurs exchange small variable size 
comparison satplan encodings expected compact hand satplan encodings best encodings surprisingly competitive 
problems include ranking satplan direct encoding problem domain specific axioms see section removed purposes comparison 
best encodings outperform satplan encodings smaller problems simplification process able satisfy formulas completely 
problems get larger satplan encodings dominate 
best automatic encoding appears factor satplan size 
type optimizations type optimizations substantially reduce formula size compares formula sizes optimizations 
numbers benefits optimizations include data problems large solve type optimizations regular simple overloaded bitwise classical explanatory ratio simplified formula size type optimizations simplified formula size 
numbers reported averages problems ratios variables clauses literals average usually closer 
classical explanatory simple overloaded simple overloaded variables clauses literals ratio simplified formula size factoring simplified formula size 
solved 
optimizations critical classical encodings cutting size thirds 
optimizations effective explanatory encodings 
fact optimizations appear superfluous regular explanatory encoding cnf simplifier obtains type optimization benefits considering structure problem resulting formula 
contrasts may attributable way simplifier interacts various encodings 
classical encodings constraining explanatory encodings explicitly enforce truth values time action occurs time rigidity may hard simplifier reduce encoding size relying heavily type optimizations deductions encoding 
regular explanatory encoding uses conflict exclusion flexible encodings 
static optimizations easily encoding simplifier 
factoring shows factoring big difference compared splitting 
factoring reduce variable size base encoding lead small drops variable size simplification 
factoring big effects clause especially literal size 
important reduction precisely reason introduced idea factoring 
worst case factoring effect clear factoring critical practice 
domain specific axioms direct encodings kautz selman provide hand coded domain specific information impossible specify terms strips actions natural writing general logical axioms 
example blocks world problems kautz state relation non commutative irreflexive block may time block exactly object blocks clear table 
determine additional information affected planning problem removed domain specific axioms encodings compared size speed resulting sat problems 
shows eliminating axioms decreased number clauses increased number variables presumably unit clause domain specific axioms domain specific axioms problem vars clauses time sec oe vars clauses time sec oe bw large bw large bw large hand coded domain specific axioms led clauses fewer variables simplification substantial speedup 
problem run times sgi indy walksat settings tries noise cutoff set number variables squared 
solve time standard deviations reported oe 
pure literal simplification effective 
domain dependent axioms planning problems took substantially longer 
results suggest useful investigate compiler deduce axioms automatically 
believe type optimizations start achieving goal 
contributions ffl develop simple framework generates major encodings account non causal encodings novel ones 
particular overloaded splitting bitwise representation combined regular simply split encodings creates spectrum choices highlighting tradeoff variable clause sizes 
ffl describe automatic compiler takes classical strips planning problems generates sat problems encodings 
compiler includes interesting features including type inference optimization mechanism 
ffl compiler perform empirical analysis tradeoffs space encodings 
show explanatory frames conflict exclusion dominant regular representation surprisingly effective 
exciting problems remain 
clearly need better investigate solve time characteristics encodings 
automatically generating domain specific axioms section promising direction 
hope investigate additional type inference methods 
hybrid encodings interesting explore 
allowing inter operator parallelism explanatory encoding take advantage best encodings 
mentioned earlier simple splitting prevents possibility parallel instantiations operator split variables interfere 
hybrid option addition action variables similar overloaded splitting simple splitting encoding 
extra variables greatly compact parts factored split encoding 
third hybrid bitwise representations split fluents simple overloaded split actions avoiding disadvantages bitwise action representation reducing number variables 
imagine compiling part domain theory encoding different encoding parts 
interesting automate statebased encodings integrate causal encodings framework 
full source code medic planner available ftp ftp cs washington edu pub ai medic tar gz 
acknowledgments jared nick kushmerick marc friedman contributed implementation testing framework 
david smith insightful observations led major reformulation encoding space 
bart selman david mcallester henry kautz engaged helpful discussions kindly provided satplan code 
jimi crawford provided tableau code 
blum furst blum furst 
fast planning planning graph analysis 
proc 
th int 
joint conf 
ai pages 
cook mitchell cook mitchell 
finding hard instances satisfiability problem survey 
proceedings dimacs workshop satisfiability problems appear 
crawford auton crawford auton 
experimental results cross point satisfiability problems 
proc 
th nat 
conf 
ai pages 
green green 
application theorem proving problem solving 
proc 
st int 
joint conf 
ai pages 
haas haas 
case domain specific frame axioms 
frame problem artificial proceedings workshop 
morgan kaufmann 
kautz selman kautz selman 
planning satisfiability 
proc 
th eur 
conf 
ai pages vienna austria 
wiley 
kautz selman kautz selman 
pushing envelope planning propositional logic stochastic search 
proc 
th nat 
conf 
ai pages 
kautz kautz mcallester selman 
encoding plans propositional logic 
proc 
th int 
conf 
principles knowledge representation reasoning 
mcallester david mcallester bart selman henry kautz 
evidence invariants local search 
proc 
th nat 
conf 
ai providence rhode island july 
mccarthy hayes mccarthy hayes 
philosophical problems standpoint artificial intelligence 
machine intelligence pages 
edinburgh university press 
penberthy weld penberthy weld 
ucpop sound complete partial order planner adl 
proc 
rd int 
conf 
principles knowledge representation reasoning pages october 
see www cs washington edu research projects ai www ucpop html 
selman selman kautz cohen 
local search strategies satisfiability testing 
dimacs series discrete mathematics theoretical computer science 
selman bart selman henry kautz david mcallester 
computational challenges propositional reasoning search 
proc 
th int 
joint conf 
ai 
van gelder tsuji van gelder tsuji 
satisfiability testing reasoning guessing 
johnson trick editors cliques coloring satisfiability second dimacs implementation challenge dimacs series discrete mathematics theoretical computer science 
american mathematical society 
