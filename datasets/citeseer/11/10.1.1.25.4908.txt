effective implementation lin kernighan traveling salesman heuristic helsgaun mail dk department computer science roskilde university dk roskilde denmark report describes implementation lin kernighan heuristic successful methods generating optimal nearoptimal solutions symmetric traveling salesman problem 
computational tests show implementation highly effective 
optimal solutions solved problem instances able obtain including city problem largest nontrivial problem instance solved optimality today 
furthermore algorithm improved best known solutions series large scale problems unknown optima city problem 

lin kernighan heuristic generally considered effective methods generating optimal near optimal solutions symmetric traveling salesman problem 
design implementation algorithm heuristic trivial 
design implementation decisions decisions great influence performance 
report describes implementation new modified version lin kernighan algorithm 
computational experiments shown implementation highly effective 
new algorithm differs details original 
notable difference search strategy 
new algorithm uses larger complex search steps original 
new sensitivity analysis direct restrict search 
run times algorithms increase approximately new algorithm effective 
new algorithm possible find optimal solutions large scale problems reasonable running times 
typical city problem optimal solution second typical city problem optimum minute mhz power macintosh 
algorithm approximate optimal solutions produced impressively high frequency 
produced optimal solutions solved problems able obtain including city problem time writing largest nontrivial problem solved optimality 
rest report organized follows 
section defines traveling salesman problem gives overview solution algorithms 
section describes original algorithm lin kernighan including refinements algorithm 
sections new modified algorithm implementation 
effectiveness implementation reported section 

traveling salesman problem formulation salesman required visit cities starting city returning original place departure 
tour choose order minimize total travel distance 
distances pair cities assumed known salesman 
distance replaced notion time money 
term cost represent notion 
problem traveling salesman problem tsp widely studied problems combinatorial optimization 
problem easy state hard solve 
mathematically problem may stated follows cost matrix ij ij represents cost going city city find permutation integers minimizes quantity 
ni properties cost matrix classify problems 
ij ji problem said symmetric asymmetric 
triangle inequality holds ik ij jk problem said metric 
ij euclidean distances points plane problem said euclidean 
euclidean problem course symmetric metric 
motivation importance tsp stems massive need salesmen wishing minimize travel distance 
importance comes wealth applications seemingly traveling routes 
example consider process planning problem 
number jobs processed single machine 
machine process job time 
job processed machine prepared cleaned adjusted 
processing time job switch time pair jobs task find execution sequence jobs making total processing time short possible 
easy see problem instance tsp 
cij represents time complete job job switch time plus time perform job 
pseudo job processing time marks state machine 
real world problems formulated instances tsp 
versatility illustrated examples application areas computer wiring vehicle routing crystallography robot control drilling printed circuit boards chronological sequencing 
tsp typical problem genre combinatorial optimization 
means theoretical practical insight achieved study tsp useful solution problems area 
fact progress combinatorial optimization traced back research tsp 
known computing method branch bound context tsp 
worth mentioning research tsp important driving force development computational complexity theory 
interest tsp stems practical theoretical importance 
intellectual challenge solving problem plays role 
despite simple formulation tsp hard solve 
difficulty apparent considers number possible tours astronomical relatively small number cities 
symmetric problem cities possible tours 
tours 
city problem successfully solved algorithm described report contains possible tours 
comparison may noted number elementary particles universe estimated solution algorithms proven tsp member set np complete problems 
class difficult problems time complexity probably exponential 
members class related polynomial time problem polynomial time algorithms exist 
commonly believed polynomial algorithm exists 
attempt construct general algorithm finding optimal solutions tsp polynomial time probably fail 
algorithm possible construct problem instances execution time grows exponentially size input 
note time complexity refers algorithm behavior worst cases 
excluded exist algorithms average running time polynomial 
existence algorithms open question 
algorithms solving tsp may divided classes exact algorithms approximate heuristic algorithms 
exact algorithms exact algorithms guaranteed find optimal solution bounded number steps 
today find exact solutions symmetric problems cities reports solution problems thousands cities 
effective exact algorithms cutting plane facet finding algorithms 
algorithms quite complex codes order lines 
addition algorithms demanding computer power 
example exact solution symmetric problem cities determined period hours powerful super computer 
took roughly years cpu time large network computers determine exact solution previously mentioned city problem 
symmetric problems usually difficult solve asymmetric problems 
today city problem largest nontrivial symmetric problem solved 
comparison optimal solution city asymmetric problem reported 
approximate algorithms contrast approximate algorithms obtain solutions guarantee optimal solutions 
algorithms usually simple relative short running times 
algorithms give solutions average differs percent optimal solution 
small deviation optimum accepted may appropriate approximate algorithm 
class approximate algorithms may subdivided classes tour construction algorithms tour improvement algorithms composite algorithms 
tour construction algorithms gradually build tour adding new city step 
tour improvement algorithms improve tour performing various exchanges 
composite algorithms combine features 
simple example tour construction algorithm called nearestneighbor algorithm start arbitrary city 
long cities visited visit nearest city appeared tour 
return city 
approach simple greedy 
distances construction process reasonable short distances process usually long 
lot construction algorithms developed remedy problem see example 
tour improvement algorithms achieved greatest success 
simple example type algorithm called opt algorithm start tour 
replace links tour links way new tour length shorter 
continue way improvements possible 
illustrates opt exchange links called opt move 
note opt move keeps tour feasible corresponds reversal subsequence cities 
opt move generalization simple principle forms basis effective approximate algorithms solving symmetric tsp lin kernighan algorithm 
original algorithm implemented lin kernighan average running time order able find optimal solutions problems fewer cities 
lin kernighan algorithm simple implement 
survey authors wrote implementation algorithm time shown efficiency obtained lin kernighan 

lin kernighan algorithm basic algorithm opt algorithm special case opt algorithm step links current tour replaced links way shorter tour achieved 
words step shorter tour obtained deleting links putting resulting paths new way possibly reversing ore 
opt algorithm concept optimality tour said optimal simply opt impossible obtain shorter tour replacing links set links 
definition obvious optimal tour optimal 
easy see tour containing cities optimal optimal 
general larger value final tour optimal 
fairly large appears intuitively optimal tour optimal 
unfortunately number operations test exchanges increases rapidly number cities increases 
naive implementation testing exchange time complexity 
furthermore nontrivial upper bound number exchanges 
result values commonly 
study values 
drawback specified advance 
difficult know achieve best compromise running time quality solution 
lin kernighan removed drawback introducing powerful variable opt algorithm 
algorithm changes value execution deciding iteration value 
iteration step algorithm examines ascending values interchange links may result shorter tour 
exchange links considered series tests performed determine link exchanges considered 
continues stopping conditions satisfied 
step algorithm considers growing set potential exchanges starting 
exchanges chosen way feasible tour may formed stage process 
exploration succeeds finding new shorter tour actual tour replaced new tour 
lin kernighan algorithm belongs class called local optimization algorithms 
algorithm specified terms exchanges moves convert tour 
feasible tour algorithm repeatedly performs exchanges reduce length current tour tour reached exchange yields improvement 
process may repeated times initial tours generated randomized way 
algorithm described detail 
current tour 
iteration step algorithm attempts find sets links links deleted replaced links result better tour 
interchange links called opt move 
illustrates opt move 
opt move sets constructed element element 
initially empty 
step pair links added respectively 
order achieve sufficient efficient algorithm links fulfill criteria may enter 
sequential exchange criterion share endpoint 
denotes endpoints general 
see 

restricting choice yi xi 
seen sequence constitutes chain adjoining links 
necessary sufficient condition exchange links links results tour chain closed 
exchange called sequential 
generally improvement tour may achieved sequential exchange suitable numbering affected links 
case 
shows example sequential exchange possible 
nonsequential exchange 
feasibility criterion required chosen joined resulting configuration tour 
feasibility criterion guarantees possible close tour 
criterion included algorithm reduce running time simplify coding 
positive gain criterion required chosen gain proposed set exchanges positive 
suppose gain exchanging sum 
criterion plays great role efficiency algorithm 
demand partial sum positive immediately restrictive 
case follows simple fact sequence numbers positive sum cyclic permutation numbers partial sum positive 
proof simple 
criterion required sets disjoint 
simplifies coding reduces running time gives effective criterion 
outline basic algorithm simplified version original algorithm 

generate random initial tour 

choose 
choose 
choose 
possible go step 


choose joined resulting configuration tour better tour go step 
choose exists 
exists go step 
untried alternative go step 
untried alternative go step 

untried alternative go step 

untried alternative go step 

untried alternative go step 

go step 
comments algorithm 
basic lin kernighan algorithm step 
random tour chosen starting point explorations 
step 
choose link tour 
chosen choices verb choose means select untried alternative 
time improvement tour step alternatives considered untried 
step 
choices possible close tour addition 
choice results disconnected 
case unfeasible choice allowed 
shows situation 
close chosen lies tour closed step 
may side see original algorithm investigated alternatives 
choices hand chosen lies choice lie lie side see original algorithm investigated alternative maximum 
unique choice limited choice 
choices condition step step ensures sets disjoint previously broken link xi link previously added 
steps 
steps cause backtracking 
note backtracking allowed improvement levels 
step 
algorithm terminates solution tour values examined improvement 
required new random initial tour may considered step 
algorithm described differs original reaction tour improvements 
algorithm tour replaced shorter tour soon improvement step 
contrast original algorithm continues steps adding potential exchanges order find shorter tour 
exchanges possible best improvement recorded far search stops current tour replaced advantageous tour 
lin kernighan state reasons introducing method 
complicates coding results better solutions shorter running times 
lin kernighan refinements bottleneck algorithm search links enter sets order increase efficiency special care taken limit search 
exchanges reasonable chance leading reduction tour length considered 
basic algorithm preceding section limits search rules sequential exchanges allowed 
provisional gain positive 
tour closed exception 
previously broken link added previously added link broken 
limit search lin kernighan refined algorithm introducing rules search link enter tour limited nearest neighbors 
link tour broken common link small number solution tours 
search improvements stopped current tour previous solution tour 
rules heuristic rules 
expectations links belong optimal tour 
save running time expense achieving best possible solutions 
rule saves running time influence quality solutions 
tour previous solution tour point attempting improve 
time needed check improvements possible checkout time may saved 
lin kernighan time saved way typically percent running time 
addition refinements purpose primarily limit search lin kernighan added refinements purpose primarily direct search 
algorithm choice alternatives heuristic rules give priorities alternatives 
cases alternatives chosen highest priority chosen 
cases alternatives tried alternatives tried descending priority order backtracking 
specific rules link chosen possible choice priority 
alternatives highest chosen 
rule heuristic rule ranking links added priority yi length unique link broken xi yi included tour minus length yi 
way algorithm provided look ahead 
maximizing quantity xi yi algorithm aims breaking long link including short link 
rule deals special situation choices 
rule gives preference longest link case 
cases see alternatives available 
situations algorithm examines choices backtracking improved tour 
lin kernighan specify sequence alternatives examined 
refinement lin kernighan included limited defense situations nonsequential exchanges may lead better solution 
local optimum algorithm tests links allowed broken possible improvement nonsequential opt change shown 
lin kernighan pointed effect post optimization procedure varies substantially problem problem 
time test small relative total running time cheap insurance 

modified lin kernighan algorithm lin kernighan original algorithm reasonably effective 
problems cities probability obtaining optimal solutions single trial close percent 
problems cities probability dropped percent 
running trials time starting new random tour optimum problems nearly percent assurance 
algorithm evaluated spectrum problems drilling problem points 
due computer storage limitations problem split smaller problems 
solution tour obtained solving subproblems separately joining tours 
time lin kernighan wrote optimum problem unknown 
optimum known may noted solution percent optimum 
modified extended version algorithm 
new algorithm considerable improvement original algorithm 
example mentioned city problem optimal solution trials approximately short time second mhz power macintosh 
general quality solutions achieved algorithm impressive 
algorithm able find optimal solutions problem instances able obtain including city problem largest nontrivial problem instance solved optimality today 
increase efficiency primarily achieved revision lin kernighan heuristic rules restricting directing search 
heuristic rules natural critical analysis shows suffer considerable defects 
candidate sets central rule original algorithm heuristic rule restricts inclusion links tour nearest neighbors city rule section 
rule directs search short tours reduces search effort substantially 
certain risk application rule may prevent optimal solution 
optimal solution contains link connected nearest neighbors cities algorithm difficulties obtaining optimum 
inadequacy rule manifests particularly clearly large problems 
example city problem links optimal solution nd nearest neighbor city points 
order find optimal solution problem number nearest neigh considered ought 
unfortunately enlargement set candidates results substantial increase running time 
rule builds assumption shorter link greater probability belongs optimal tour 
reasonable may result poor tours 
measure nearness described better reflects chances link member optimal tour 
measure called nearness sensitivity analysis minimum spanning trees 
known graph theoretical terminology reviewed 
undirected weighted graph set nodes set edges 
edge associated weight 
path set edges cycle set edges tour cycle subset length 
optimal tour tour minimum length 
symmetric tsp simply formulated weighted graph determine optimal tour 
graph said connected contains pair nodes path connecting 
tree connected graph cycles 
spanning tree graph nodes tree edges minimum spanning tree spanning tree minimum length 
important concept tree may defined 
tree graph spanning tree node set combined edges incident node 
choice node special node arbitrary 
note tree tree contains cycle containing node see 
tree 
minimum tree tree minimum length 
degree node number edges incident node 
easy see optimal tour minimum tree node degree minimum tree tour tour optimal 
alternative formulation symmetric tsp find minimum tree nodes degree 
usually minimum spanning tree contains edges common optimal tour 
optimal tour normally contains percent edges minimum tree 
minimum trees suited heuristic measure nearness 
edges belong nearly belong minimum tree stand chance belonging optimal tour 
conversely edges far belonging minimum tree low probability belonging optimal tour 
lin kernighan algorithm far edges may excluded candidates enter tour 
expected exclusion cause optimal tour missed 
special node formally measure nearness defined follows minimum tree length denote minimum tree required contain edge 
nearness edge defined quantity 
length minimum tree nearness edge increase length minimum tree required contain edge 
easy verify simple properties 
belongs minimum tree 
measure systematically identify edges conceivably included optimal tour disregard remainder 
promising edges called candidate set may example consist nearest edges incident node edges having nearness specified upper bound 
general measure specifying candidate set better nearest neighbors 
usually candidate set may smaller degradation solution quality 
nearness construction candidate set implies computations values 
efficiency time space computations important 
method practical value computations expensive 
algorithm computes values 
algorithm time complexity uses space 
complete graph graph nodes edge algorithm finds minimum tree done determination minimum spanning tree contains nodes followed addition shortest edges incident node 
minimum spanning tree may example determined prim algorithm run time complexity 
additional edges may determined time 
complexity part 
nearness determined edges 
minimum tree 
definition minimum spanning tree easy see minimum spanning tree containing edge may determined action rules belongs equal 
node obtained replacing longest edges incident node 
insert creates cycle containing spanning tree part obtained removing longest edges cycle 
cases simple 
suitable representation trees treated constant time 
case difficult treat efficiently 
number edges produced cycles 
suitable representation possible treat edge time complexity 
edges treated way total time complexity unsatisfactory 
possible obtain total complexity exploiting simple relation values 
denote length edge removed spanning tree edge added 

fact may exploited see 
edge minimum spanning tree remaining nodes cycle arises adding edge tree may computed maximum 
may computed 
node values computed time complexity remaining nodes traversed suitable sequence 
seen sequence produced byproduct prim algorithm constructing minimum spanning trees topological order node descendants tree placed node 
total complexity 
sketches style notation algorithm computing algorithm assumes father node tree dad precedes node dad 
max dad dad computation unfortunately algorithm needs space storing values 
space may saved storing values quadratic matrix example values stored lower triangular matrix values stored upper triangular matrix 
large values storage limitations may approach impractical 
half space may saved values stored computed needed example euclidean distances 
question possible save space needed values sight values stored order achieve time complexity computation 
case demonstrated 
algorithm uses dimensional auxiliary arrays mark 
array corresponds matrix contains values node 
array mark indicate computed node determination done phases 
computed nodes path node root tree node 
nodes marked forward pass compute remaining values 
values available inner loop 
mark dad max mark mark max dad dad available space efficient computation easy see algorithm time complexity uses space 
values provide estimate edges chances belonging optimal tour 
smaller edge promising edge 
nearness possible limit search relative nearest neighbors node obtain optimal tour 
computational tests shown measure provides better estimate likelihood edge optimal usual measure 
example city problem worst case optimal edge nd nearest edge node worst case measure optimal edge th nearest 
average rank optimal edges candidate edges reduced 
quite satisfactory 
measure improved substantially making simple transformation original cost matrix 
transformation observations tour tree 
length minimum tree lower bound length optimal tour 
length edges incident node changed amount optimal tour remains optimal 
cost matrix ij transformed ij ij ij optimal tour optimal tour length tour increased transformation leaves tsp invariant usually changes minimum tree 
minimum tree respect length lower bound length optimal tour lower bound length optimal tour aim find transformation vector maximizes lower bound tour exact optimum 
appears intuitively values computed better estimates edges optimal values computed usually maximum close length optimal tour 
computational experience shown maximum typically percent optimum 
finding maximum trivial task 
function piece wise linear concave differentiable 
suitable method maximizing subgradient optimization subgradient generalization gradient concept 
iterative method maximum approximated stepwise changes 
step changed direction subgradient subgradient vector positive scalar called step size 
actual maximization problem shown subgradient vector vector having elements degrees nodes current minimum tree 
subgradient algorithm strive obtaining minimum trees node degrees equal minimum trees tours 
edges incident node degree shorter 
edges incident node degree greater longer 
edges incident node degree changed 
values called penalties 
determination set penalties called ascent 
shows subgradient algorithm computing approximation maximum 


find minimum tree 
compute 
max 

contains degrees nodes 
optimal tour criterion satisfied 

choose step size 

go step 
subgradient optimization algorithm 
proven converge maximum conditions satisfied example arbitrary initial step size 
convergence guaranteed slow 
choice step size crucial decision viewpoint algorithmic efficiency adequacy 
convergence guaranteed important long approximations obtained short time 
general methods determine optimum strategy choice step size known 
strategies suggested quite effective practice 
strategies heuristics different variations different effects different problems 
implementation modified lin kernighan algorithm strategy chosen inspired step size constant fixed number iterations called period 
period finished length period step size halved 
length period set number cities 
initial step size set doubled period increase 
happens step size remains constant rest period 
iteration period leads increment period doubled 
algorithm terminates step size length period zero 
furthermore basic subgradient algorithm changed points inspired updating replaced special node tree computations fixed 
minimum tree determined computing minimum spanning tree adding edge corresponding second nearest neighbor leaves tree 
leaf chosen longest second nearest neighbor distance 
practical experiments shown changes lead better bounds 
having penalty vector maximizes transformation original cost matrix improve measure substantially 
example city problem edge optimal tour nearest neighbors endpoints 
improvement measure reduces average rank optimal edges candidate edges 
close ideal value optimal edge rank 
table shows percent optimal edges having rank nearest neighbors respect measure measure improved measure respectively 
rank improved table 
percentage optimal edges candidate edges city problem 
appears table transformation cost matrix effect optimal edges come nearer measured values 
transformation cost matrix conditions problem speak 
transformed matrix lin kernighan search process 
quality solutions improved means 
greatest advantage measure usefulness construction candidate set 
measure cardinality candidate set may generally small reducing algorithm ability find short tours 
test problems algorithm able find optimal tours candidate edges edges nearest edges incident node 
problems solved search restricted nearest edges 
candidate edges node sorted ascending order values 
edges value smallest cost ij comes 
ordering effect candidate edges considered inclusion tour promise belonging optimal tour 
measure limit search focus search promising areas 
speed search algorithm uses dynamic ordering candidates 
time shorter tour edges shared new tour previous shortest tour candidate edges nodes 
method selecting candidates inspired stewart demonstrated minimum spanning trees accelerate opt heuristics 
subgradient optimization candidate sets minimum spanning trees usually produce better results nearest neighbor candidate sets size 
johnson alternative implementation lin kernighan algorithm precomputed candidate sets usually contained ordinary nearest neighbors node 
problem type candidate set candidate subgraph need connected large fraction edges included 
example case geometrical problems point sets exhibit clusters 
contrast minimum spanning tree definition connected 
candidate sets may considered 
interesting candidate set obtained exploiting delaunay graph 
delaunay graph connected may computed linear time average 
disadvantage approach candidate sets computed geometric problem instances 
contrast measure applicable general 
breaking tour edges candidate set prune search edges included tour 
correspondingly search edges excluded tour may restricted 
actual implementation simple effective pruning rules edge broken belong currently best solution tour 
solution tour known determination solution tour belong minimum tree 
edge excluded basic move previously included current chain basic moves 
rule prunes search level algorithm original algorithm lin kernighan prunes level higher edge broken common edge number solution tours 
experiments shown new pruning rule effective 
addition easier implement 
second rule prevents infinite chain moves 
rule relaxation rule section 
basic moves central lin kernighan algorithm specification allowable moves subset opt moves consider attempt transform tour shorter tour 
original algorithm considers opt moves decomposed opt move followed possibly empty sequence opt moves 
furthermore opt move sequential feasible connected chain edges edges removed alternate edges added move result feasible tour 
minor deviations general scheme allowed 
opt moves 
special case move sequence may sequential opt move see moves opt moves 
second nonsequential opt moves tried tour longer improved sequential moves see 
new modified lin kernighan algorithm revises basic search structure points 
foremost basic move sequential opt move 
moves considered algorithm sequences opt moves 
construction move stopped immediately discovered close tour results tour improvement 
way algorithm attempts ensure optimality 
opt move basic move broadens search increases algorithm ability find tours expense increase running times 
due small candidate sets run times increased small factor 
furthermore computational experiments shown backtracking longer necessary algorithm course edge excluded 
removal backtracking reduces runtime degrade algorithm performance significantly 
addition implementation algorithm greatly simplified 
new algorithm improved performance compared original algorithm accordance observations christofides 
observed optimality expected yield relatively superior improvement optimality compared improvement optimality optimality 
deviation original algorithm examination nonsequential exchanges 
order provide better defense possible improvements consisting nonsequential exchanges simple nonsequential opt move original algorithm replaced powerful set nonsequential moves 
set consists opt move producing cycles followed opt move produces feasible tour joining cycles opt move producing cycles followed opt move produces feasible tour joining cycles 
seen simple nonsequential opt move original algorithm belongs extended set nonsequential moves 
set moves chances finding optimal tours improved 
candidate sets positive gain criterion time search nonsequential improvements tour small relative total running time 
original algorithm search nonsequential improvements seen post optimization maneuver 
improvement attempts improve tour ordinary sequential nonsequential exchanges 
initial tours lin kernighan algorithm applies edge exchanges times problem different initial tours 
original algorithm initial tours chosen random 
lin kernighan concluded construction heuristic wastes time 
construction heuristics usually deterministic may possible get solution 
question construction heuristic simple answer 
instance farthest insertion construction heuristic capable producing initial tours lin kernighan algorithm 
clarke wright savings heuristic general improved performance algorithm 
reinelt better start random tour 
proposed locally tours containing major errors example heuristics christofides 
observed difference performance decreases elaborate versions lin kernighan algorithm 
experiments various implementations new modified lin kernighan algorithm shown quality final solutions depend strongly initial tours 
significant reduction run time may achieved choosing initial tours close optimal 
implementation simple construction heuristic 
choose random node 
choose node chosen follows possible choose candidate edge belongs current best tour 
possible choose candidate edge 
choose nodes chosen 

nodes chosen go step 
node may chosen step node chosen random alternatives 
sequence chosen nodes constitutes initial tour 
construction procedure fast diversity initial solutions large edge exchange heuristics find final solutions 
specification modified algorithm section presents overview modified lin kernighan algorithm 
algorithm described top programming language 
sketch main program 
void main bestcost dbl max run run runs run double cost cost bestcost bestcost cost program reads specification problem solved creates candidate set 
specified number runs local optimal tours modified lin kernighan heuristics 
best tours printed program terminates 
creation candidate set nearness 
void double lowerbound ascent long excess fabs lowerbound function ascent determines lower bound optimal tour length subgradient optimization 
function transforms original problem problem values reflect likelihood edges optimal 
function computes values associates node set incident candidate edges 
edges ranked values 
parameter specifies maximum number candidate edges allowed node puts upper limit values 
value set fraction excess lower bound 
pseudo code function ascent shown reasonable self explanatory 
follows description section 
value node degree minus 
norm sum squares values measure minimum tree discrepancy tour 
norm zero tree constitutes tour optimal tour 
order speed computations algorithm uses candidate sets computations minimum trees 
double ascent node double int period minimum norm return long max pi period period pi minimum norm return pi period period pi return minimum shown pseudo code function 
node candidate edges determined 
upper limit may exceeded symmetric neighborhood desired case candidate set complemented candidate edge associated nodes 
void long long node long alpha candidate edge mark beta long min dad dad dad beta max beta cost dad mark alpha father alpha father mark beta max dad beta cost alpha beta alpha ismember candidate set created function called predetermined number times runs 
performs number trials trial attempts improve chosen initial tour modified lin kernighan edge exchange heuristics 
time better tour tour recorded candidates reordered function 
precedence edges common currently best tours 
candidate set extended tour edges current set 
original candidate set re established exit 
double int trial double dbl max cost trial trial trials trial cost cost cost return function seeks improve tour sequential nonsequential edge exchanges 
double node int failures long gain double cost cost suc failures failures dimension pred suc continue gain gain cost gain failures goto failures gain gain cost gain gain function computes cost initial tour 
long improvements may achieved attempts find improvements sequential opt moves possible nonsequential moves gain 
sequential exchange basis edge selecting set nodes selecting neighboring nodes tour 
edge trial best tour basis edge 
function sketched 
function sequential edge exchanges 
possible opt move improves tour 
promising opt move fulfils positive gain criterion 
node node node long long gain node node long long min int gain reversed suc pred suc continue pred suc gain return pred suc continue determine maximum previously included process legal move gain move exit immediately gain return return part function opt part detail 
rest function follows pattern 
tour circular list 
flag reversed indicate reversal tour 
prevent infinite chain moves edge deleted opt move previously included chain 
detailed description data structures implementation issues may section 

implementation modified lin kernighan algorithm implemented programming language software approximately lines code entirely written ansi portable number computer platforms compilers 
subsections describe user interface central techniques employed implementation 
user interface software includes code reading problem instances printing solutions 
input separate files problem file parameter file 
problem file contains specification problem instance solved 
file format tsplib publicly available library problem instances tsp 
current version software allows specification symmetric asymmetric hamiltonian tour problems 
distances costs weights may explicitly matrix form full triangular matrix implicitly associating dimensional coordinate node 
case distances may computed euclidean manhattan maximum geographical pseudo euclidean distance function 
see details 
distances integral 
problems may specified complete sparse graph option require certain edges appear solution problem 
parameter file contains control parameters solution process 
solution process typically carried default values parameters 
default values proven adequate applications 
computational tests reported default settings 
information left name problem file 
format follows problem file string specifies name problem file 
additional control information may supplied format runs integer total number runs 
default 
max trials integer maximum number trials run 
default number nodes dimension problem file 
tour file string specifies name file best tour written 
optimum real known optimal tour length 
run terminated soon tour length equal optimum achieved 
default dbl max 
max candidates integer symmetric maximum number candidate edges associated node 
integer may followed keyword symmetric signifying candidate set complemented candidate edge associated nodes 
default 
ascent candidates integer number candidate edges associated node ascent 
candidate set complemented candidate edge associated nodes 
default 
excess integer maximum value allowed candidate edge set excess times absolute value lower bound solution tour determined ascent 
default dimension 
initial period integer length period ascent 
default dimension 
initial step size integer initial step size ascent 
default 
pi file string specifies name file penalties values determined ascent written 
file exits penalties read file ascent skipped 
precision integer internal precision representation transformed distances ij precision ij ij ij integral 
default corresponds decimal places 
seed integer specifies initial seed random number generation 
default 
subgradient specifies values determined subgradient optimization 
default 
trace level integer specifies level detail output solution process 
value signifies minimum amount output 
higher value information 
default 
solution process information progress written standard output 
user may control level detail information value trace level parameter 
program terminates summary key statistics written standard output specified tour file parameter best tour written file tsplib format 
user interface somewhat primitive convenient applications 
simple requires programming user 
current implementation modular alternative user interface may implemented rewriting modules 
new user interface example enable graphical animation solution process 
representation tours moves representation tours central implementation issue 
data structure chosen may great impact run time efficiency 
obvious major bottleneck algorithm search possible moves edge exchanges execution moves tour 
special care taken choose data structure allows fast execution operations 
data structure support primitive operations find predecessor node tour respect chosen orientation pred find successor node tour respect chosen orientation suc determine node nodes tour respect chosen orientation move undo sequence tentative moves 
necessity operations stems need determine possible close tour see figures 
operations necessary keeping tour date 
modified lin kernighan algorithm move consists sequence basic moves basic move opt move opt moves case improvement tour possible 
order simplify tour updating fact may opt move equivalent finite sequence opt moves 
case opt moves shown opt move equivalent sequence opt moves 
opt move opt move equivalent sequence opt moves 
exploited follows 
move executed sequence opt moves 
move execution opt moves recorded stack 
bad move undone opt moves making inverse opt moves reversed sequence 
efficient execution opt moves needed 
opt move called swap consists moving edges current tour resulting paths best possible way see 
operation seen reverse paths 
tour represented array nodes doubly linked list nodes reversal path takes time 
turns data structures exist allow logarithmic time complexity achieved 
data structures selected notice 
time overhead corresponding update algorithms usually large problem large typically nodes update algorithms data structures outperformed update algorithms array list structures 
addition simple implement 
current implementation modified lin kernighan algorithm tour may represented ways doubly linked list twolevel tree 
user select representations 
doubly linked list recommended problems fewer nodes 
larger problems level tree chosen 
doubly link list representation node problem represented structure outlined 
struct node unsigned long id rank struct node pred suc variable id identification number node id 
rank gives ordinal number node tour 
quickly determine node nodes tour 
pred suc point predecessor node successor node tour respectively 
opt move swapping pred suc node segments segments suitable settings pred suc segments nodes 
addition rank updated nodes reversed segment 
small code fragment shows implementation opt move 
edges exchanged edges see 
rank suc suc suc pred pred rank suc pred pred suc segments defined opt move may reversed 
segment fewest number nodes reversed order speed computations 
number nodes segment constant time rank values nodes 
way run time spared 
example problem nodes average number nodes touched reversal random reversal touched nodes average 
random euclidean instances length shorter segment grow roughly 
worst case time cost opt move costs tour manipulation grow dominate running time increases 
worst case cost opt move may achieved level tree representation 
currently fastest robust representation large instances arise practice 
idea divide tour roughly segments 
segment maintained doubly linked list nodes pointers labeled pred suc 
node represented structure outlined 
struct node unsigned long id rank struct node pred suc struct segment parent rank gives position node segment facilitate queries 
parent pointer segment containing node 
segment represented structure 
struct segment unsigned long rank struct segment pred suc struct node bit reversed segments connected doubly linked list pointers labeled pred suc segment contains sequence number rank represents position list 
pointers segment nodes 
reversed reversal bit indicating segment traversed forward reverse direction 
just switching bit reverses orientation segment 
query operations pred suc performed constant time list representation albeit slightly larger constants move operations worst case cost move 
implementation operations closely follows suggestions 
see pp 
details 
distance computations bottleneck applications computing distances 
example euclidean distances substantial part run time may spent computing square roots 
sufficient space available distances may computed stored matrix 
large problems say nodes approach usually possible 
implementation distances computed stored matrix problem smaller specified maximum dimension 
larger problems techniques reduce run time 
candidate edge including length associated node emanates 
large fraction edges considered solution process candidate edges 
cases length edge may simple search candidate edges associated nodes 
computational cheap functions calculating lower bounds distances 
example lower bound euclidean distance dx dy may quickly computed maximum dx dy 
reasonable lower bound distance sufficient deciding point computing true distance 
may example quickly deciding tentative move possibly lead tour improvement 
current gain plus lower bound distance closing edge positive tour improved move 
number distance computations reduced caching technique described 
distance nodes computed distance stored hash table 
hash index computed identification numbers nodes 
time distance nodes computed table consulted see distance available 
see details 
effect caching technique measured solution node problem 
optimum times fewer ordinary distance calculations technique running time halved 
reduction checkout time algorithm local optimum time spent check progress possible 
time called checkout time avoided local optimum 
point attempting find improvements situation previously checked 
checkout time constitutes substantial part running time 
lin kernighan report checkout times typically cent running time 
modified algorithm reduces checkout time techniques 
moves edge broken belongs currently best solution tour investigated 
hashing technique 
hash function maps tours locations hash table 
time tour improvement hash table consulted see new tour happens local optimum earlier 
case fruitless checkout time avoided 
technique described detail 
concept don look bit introduced bentley 
choice algorithm previously failed find improvement tour neighbors changed time improving move algorithm looks 
exploited follows 
node don look bit initially 
bit node set search improving move fails set improving move node edges 
considering candidates nodes don look bit ignored 
done maintaining queue nodes bits zero 
speeding ascent subgradient optimization determine lower bound optimum 
step minimum tree computed 
number steps may large important speed computation minimum trees 
purpose trees computed sparse graphs 
tree computed complete graph 
remaining trees computed sparse subgraph determined measure 
sub graph consists specified number nearest neighbor edges incident node 
prim algorithm computing minimum spanning trees 
achieve speed necessary quickly find shortest edge number edges 
current implementation binary heap purpose 
combination methods results fast computation minimum spanning trees number candidate edges allowed node large 
hand number small lower bound computed ascent valid 
implementation number default 

computational results performance approximate algorithm lin kernighan algorithm evaluated ways worst case analysis probabilistic average case analysis empirical analysis goal worst case analysis derive upper bounds possible deviations optimum provide quality guarantees results produced algorithm 
known approximate algorithms tsp poor worst case behavior 
assume example problems solved metric triangle inequality holds 
approximate algorithm known best worst case behavior algorithm christofides 
algorithm guarantees tour length longer optimum 
ropt algorithm number cities problems may constructed error 
non metric problems proven impossible construct algorithm polynomial complexity find tours length bound constant multiple optimal tour length 
purpose second method probabilistic analysis evaluate average behavior algorithms 
example approximate tsp algorithm probability analysis estimate expected error large problem sizes 
worst case probability approach drawbacks 
mathematics involved may complex results achieved methods may little solving practical instances tsp 
statements concerning problems certainly occur practice pathological problems problems infinite number cities irrelevant connection practical problem solving 
respect third method empirical analysis appropriate 
algorithm executed number test problems results evaluated relation optimal solutions 
test problems may generated random may constructed special way 
test problems representative problems algorithm supposed solve computations useful evaluating appropriateness algorithm 
section documents computational results modified lin kernighan algorithm 
results include qualitative performance run time efficiency current implementation 
run times measured seconds mhz power macintosh 
performance implementation evaluated spectrum problems symmetric problems asymmetric problems hamiltonian cycle problems pathological problems problem solved number independent runs 
run consist series trials trial tour determined modified lin kernighan algorithm 
trials run independent edges belonging best tour current run prune search 
experiments number runs varies 
problems cities number runs 
larger problems number runs 
number trials run equal dimension problem number cities 
problems optimum known current series trials stopped algorithm finds optimum 
symmetric problems tsplib library meant provide researchers set sample instances tsp related problems 
tsplib publicly available ftp rice edu contains problems various sources various properties 
instances problem classes available symmetric traveling salesman problems asymmetric traveling salesman problems hamiltonian cycle problems sequential ordering problems capacitated vehicle routing problems 
information length optimal tours lower upper bounds length provided available 
symmetric traveling salesman problems included library largest problem cities 
performance evaluation follows problems optimum known 
today problems type library ranging problem cities problem cities 
test results reported table 
table displays results subgradient optimization phase 
table gives problem names number cities problem type optimal tour length lower bound gap optimum lower bound percentage optimum time seconds subgradient optimization 
problem type specifies distances 
entry matrix indicates distances explicitly matrix form full triangular matrix 
entry names refer functions computing distances city coordinates 
entries euc ceil indicates distances dimensional euclidean distances differ rounding method 
geo indicates geographical distances earth surface att indicates special pseudo euclidean distance function 
distances integer numbers 
see details 
name cities type optimum lower bound gap time euc ali geo att att att att geo bays geo berlin euc bier euc brazil matrix brg matrix geo ch euc ch euc euc euc euc euc euc dantzig matrix ceil eil euc eil euc eil euc fl euc fl euc fl euc euc fri matrix gil euc gr matrix gr matrix gr matrix gr matrix gr geo gr matrix gr geo gr geo gr geo gr geo gr geo hk matrix kroa euc euc euc euc euc kroa euc table determination lower bounds part name cities type optimum lower bound gap time euc kroa euc euc lin euc lin euc euc euc euc pa matrix pcb euc pcb euc pcb euc pla ceil pr euc pr euc pr euc pr euc pr euc pr euc pr euc pr euc pr euc pr euc pr euc pr euc rat euc rat euc rat euc rat euc rd euc rd euc rl euc rl euc rl euc si matrix si matrix si matrix st euc swiss matrix ts euc tsp euc euc euc euc euc euc euc table determination lower bounds part ii name cities type optimum lower bound gap time euc euc ulysses geo ulysses geo vm euc vm euc table determination lower bounds part iii average gap optimum lower bound 
small problems berlin fri gr gr gr ulysses ulysses gap zero optima determined subgradient optimization marked 
table documents performance search heuristics 
table gives problem names ratio runs succeeding finding optimal solution minimum average number trials run minimum average gap length best tour obtained optimum percentage optimum minimum average time seconds run 
example problem att padberg rinaldi optimal solution determined runs 
minimum number trials find optimum 
average number trials run run stopped optimal solution number trials equals number cities 
average gap length best tour obtained optimum percentage optimum 
maximum gap 
minimum average cpu time run seconds respectively 
instances solved optimality default parameter settings 
name success trials avg gap avg gap max time min time avg ali att att bays berlin bier brazil brg ch ch dantzig eil eil eil fl fl fl fri gil gr gr gr gr gr gr gr gr gr gr gr hk kroa kroa table determination solutions part name success trials min trials avg gap avg gap max time min time avg kroa lin lin pa pcb pcb pcb pla pr pr pr pr pr pr pr pr pr pr pr pr rat rat rat rat rd rd rl rl rl si si si st swiss ts tsp table determination solutions part ii name success trials min trials avg gap avg gap max time min time avg ulysses ulysses vm vm table determination solutions part iii addition problems tsplib contains symmetric problems optimum solutions known today 
dimension problems varies cities 
table lists problems currently best known lower upper bound published tsplib october 
name cities type lower bound upper bound brd euc euc euc euc fl euc pla ceil pla ceil rl euc rl euc rl euc usa euc table problems tsplib unknown optimal solutions new algorithm executed problems tour lengths equal best known upper bounds problems fl rl rl 
remaining problems algorithm able find tours shorter best known upper bounds 
new upper bounds listed table 
name new upper bound brd pla pla rl usa table improved upper bounds new upper bound largest problems pla weeks cpu time 
difficult predict running time needed solve problem algorithm 
seen table size 
problem may require running time larger problem 
guidelines may 
random problems may provide estimates running times 
solving randomly generated problems different dimensions measuring time solve problems possible get idea running time grows function problem dimension 
algorithm randomly generating traveling salesman problem known optimal tours described arthur purpose 
show total running times seconds solving symmetric problems generated algorithm 
dimension varies cities 
parameter values chosen suggested arthur dimension problem 
see details 
time seconds run time function problem dimension non metric problems problems produce required satisfy triangle inequality 
problems simple algorithm 
problems optimum trial 
curve depicts function correlation coefficient 
depicts total running time function dimension randomly generated problems satisfying triangle inequality 
problems harder solve probably due smaller diversity distances 
optimum problems trial 
curve depicts function correlation coefficient 
nodes time seconds run time function problem dimension metric problems results indicate average running time algorithm approximately 
method studying average performance tsp heuristics solve problem instances consisting random points rectangle euclidean metric 
instances solved increasing values compared theoretical value expected length optimal tour opt 
known formula opt cities distributed uniformly randomly rectangular area units 
ratio optimal tour length approaches constant experiments johnson mcgeoch suggest approximated 
shows results obtained modified lin kernighan algorithm solve problems square ranging increasing 
depicts tour length divided results consistent estimate large nodes solutions random euclidean problems square shows total running time seconds find best local optimal tour function problem dimension 
curve depicts function correlation coefficient 
time seconds run time function problem dimension nodes nodes asymmetric problems implemented algorithm primarily intended solving symmetric tsps 
asymmetric problem may transformed symmetric problem solved algorithm 
transformation method jonker transforms asymmetric problem nodes problem nodes 
ij denote nxn cost matrix asymmetric problem 
ij nx symmetric matrix computed follows sufficiently large number max ij 
easy prove optimal solution new symmetric problem corresponds optimal solution original asymmetric problem 
obvious disadvantage transformation doubles size problem 
practice advantageous algorithms dedicated solving asymmetric problems 
seen table performance modified lin kernighan algorithm asymmetric problems quite impressive 
optimum obtained asymmetric problems tsplib 
largest problems rbg nodes transformed problem nodes 
problems prefixed ft size equal suffix number plus 
name success trials min trials avg gap avg gap max time min time avg br ft ft ftv ftv ftv ftv ftv ftv ftv ftv ftv kro rbg rbg rbg rbg ry table performance asymmetric problems hamiltonian cycle problems hamiltonian cycle problem problem deciding undirected graph contains cycle 
problem answered solving symmetric tsp complete graph edges cost edges positive cost 
contains hamiltonian cycle optimal tour cost 
tsplib includes hamiltonian cycle problems ranging size nodes 
instance problems contains hamiltonian cycle 
table shows excellent performance modified lin kernighan algorithm problem instances 
name success trials min trials avg gap avg gap max time min time avg alb alb alb alb alb alb alb alb alb table performance hamiltonian cycle problems tsplib interesting special hamilton cycle problem called knight tour problem 
knight moved chessboard way squares visited exactly moves taken constitute round trip board 
depicts solution problem 
moves shown arrows 
solution knight tour problem problem instance general problem starting square board visit square exactly return starting square 
knight tour problem problem board 
table shows performance statistics problems 
small program included tsplib generating graphs 
edges belonging graph cost remaining edges cost 
problem success trials min trials avg gap avg gap max time min time avg table performance problems variant problems optimal tour length 
problems contain hamiltonian cycle optimum tour length 
table shows performance problems edges graph cost remaining edges cost 
lin kernighan observed knight tour problems edge costs hard solve algorithm 
problem success trials min trials avg gap avg gap max time min time avg table performance problems variant seen new implementation unaffected 
pathological problems lin kernighan algorithm effective random typical problems 
papadimitriou steiglitz constructed special class instances tsp local search algorithms lin kernighan algorithm appears ineffective 
papadimitriou steiglitz denote class problems perverse 
problem nodes 
exactly optimal tour cost 
tours best arbitrary large cost improved changing fewer edges 
see precise description constructed problems 
difficulty problem class illustrated table showing performance algorithm subgradient optimization left 
note results cases 
optimum frequently implementation lin kernighan algorithm papadimitriou steiglitz unable discover optimum 
success trials min trials avg gap avg gap max time min time avg table performance perverse problems subgradient optimization problems solved search subgradient optimization provided initial period sufficiently large dimension 
table shows time seconds find optimal solutions subgradient optimization 
time table time find optimal solutions perverse problems subgradient optimization 
report described modified lin kernighan algorithm implementation 
development algorithm great emphasis put achieving high quality solutions preferably optimal solutions reasonable short time 
achieving simplicity minor concern 
comparison modified lin kernighan algorithm mak morton simple algorithmic structure 
simplicity achieved expense reduced ability find optimal solutions 
algorithm guarantee opt optimality 
computational experiments shown new algorithm highly effective 
optimal solution obtained problems known optimum 
remarkable considering modified algorithm employ backtracking 
running times satisfactory test problems 
running time approximately may impractical solve large problems 
current implementation feasible problems fewer cities depends course available computer resources 
distances implicitly space requirements 
space required geometrical problems linear 
problems space run time usually limiting factor 
effectiveness algorithm primarily achieved efficient search strategy 
search opt moves restricted carefully chosen candidate sets 
measure sensitivity analysis minimum spanning trees define candidate sets small large allow excellent solutions usually optimal solutions 
lin kernighan effective heuristic algorithm traveling salesman problem oper 
res 

lawler lenstra rinnooy kan shmoys eds traveling salesman problem guided tour combinatorial optimization wiley new york 
dantzig fulkerson johnson solution large scale traveling salesman problem oper 
res 
little murty karel algorithm traveling salesman problem oper 
res 
karp reducibility combinatorial problems miller thatcher eds complexity computer computations plenum press new york 
padberg rinaldi branch cut algorithm resolution large scale symmetric traveling salesman problems siam review 
gr holland solution large scale symmetric travelling salesman problems math 
programming 
applegate bixby chv tal cook finding cuts tsp preliminary report dimacs tech 
report 
malone pathology traveling salesman subtour elimination algorithms oper 
res 
miller exact solution large asymmetric traveling salesman problems science 
rosenkrantz stearns lewis ii analysis heuristics traveling salesman problem siam comput 
laporte traveling salesman problem overview exact approximate algorithms eur 
oper 
res 
reinelt traveling salesman computational solutions tsp applications lecture notes computer science 
melamed kh 
sigal traveling salesman problem 
approximate algorithms 

lin computer solutions traveling salesman problem bell system tech 

christofides algorithms large scale travelling salesman problems oper 
res 
quart 
johnson local optimization traveling salesman problem lecture notes computer science 
johnson mcgeoch traveling salesman problem case study local optimization aarts lenstra eds local search combinatorial optimization wiley new york 
padberg rinaldi optimization city symmetric traveling salesman problem branch cut oper 
res 

held karp traveling salesman problem minimum spanning trees oper 
res 
held karp traveling salesman problem minimum spanning trees part ii math 
programming 
prim shortest connection networks generalizations bell system tech 

jonker symmetric traveling salesman problem edge exchanges minimal trees eur 
oper 
res 
toth new lower bounds symmetric travelling salesman problem math 
programming 
held wolfe crowder validation subgradient optimization math 
programming 
poljak general method solving extremum problems soviet math 
dokl 
crowder computational improvements subgradient optimization ibm res 
rept 
rc 
fratta improving relaxation methods modified gradient techniques math 
programming study 
sherali choice step size subgradient optimization eur 
oper 
res 
jonker branch bound algorithm symmetric traveling salesman problem tree relaxation eur 
oper 
res 
hansen improvements held karp algorithm symmetric traveling salesman problem math 
programming 
stewart jr accelerated branch exchange heuristics symmetric traveling salesman problems networks 
reinelt fast heuristics large geometric traveling salesman problems orsa comput 
computational experiments approximation algorithms traveling salesman problem 
mat 
significance initial solution travelling salesman heuristics oper 
res 
soc 
clarke wright scheduling vehicles central depot number delivery points oper 
res 
christofides worst case analysis new heuristic travelling salesman problem report 
graduate school industrial administration carnegie mellon university pittsburg 
reinelt tsplib traveling salesman problem library orsa comput 

mak morton distances traveling salesman tours disc 
appl 
math 
applegate bixby chv tal cook data structures lin kernighan heuristic talk tsp workshop rice university 
rs reversible segment list report discrete mathematik bonn 
quick updates opt tsp heuristics oper 
res 

fredman johnson mcgeoch data structures traveling salesmen algorithms 
bentley fast algorithms geometric traveling salesman problems orsa comput 
bentley trees point sets sixth annual acm symposium computational geometry ca 
martin otto felten large step markov chains traveling salesman problem complex systems 
sahni gonzales complete approximation algorithms assoc 
comput 
mach 
arthur generating travelling salesman problems known optimal tours opl res 
soc 
hammersley shortest path points proc 
cambridge philos 
soc 
johnson mcgeoch asymptotic experimental analysis held karp traveling salesman problem proc 
th acm siam symp 
discrete algorithms society industrial applied mathematics philadelphia york 
jonker transforming asymmetric symmetric traveling salesman problems oper 
res 

knuth graphs math 

papadimitriou steiglitz examples difficult traveling salesman problems oper 
res 

mak morton modified lin kernighan traveling salesman heuristic oper 
res 


