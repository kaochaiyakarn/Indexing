automatic generation software test cases formal specifications thesis submitted fulfilment requirements degree doctor philosophy faculty science queen university belfast christophe may software testing consumes large percentage total software development costs 
usually performed manually non rigorous fashion 
techniques limited automatic support generation test data actual code system test researched test cases generation high level specification intended behaviour system developed hardly addressed 
thesis rationale tests derived high level formal specifications set find efficient technique generation adequate test sets specifications written study language vdm sl 
formalise traditional high level partitioning technique previously researched test cases generator prototype extend take semantics vdm sl fully account 
discuss illustrate shortcomings technique results tests generated potentially large sections specification employed test generation process 
strand research test generation predicates examined extended formalism include quantified expressions complex constructs formal specification languages 
show refined technique complements previous combination allow generation adequate test sets formal specifications 
formalism illustrate synthesise pragmatically techniques find heuristics detection redundant test cases 
central heuristic justified probabilities independence divisions input domain system test allows contraction test sets impairing likelihood revealing error system test 
propose technique efficient generation adequate test cases 
wish dr spence supervisor help patience course 
john clark prof john mcdermid university york allowing pursue employed projects 
partially funded year serc number 
generously funded eu human capital mobility number ct years 
prof maurice clint department computer science queen large efforts obtaining latest 
am indebted wife tracey son mikael putting difficult times encouraging way 
memory parents 
ii contents software testing fuzzy state affairs 
gap filled 
outline thesis 
previous automatic tests generation preliminaries 
theory 
overview 
random testing 
structural testing 
functional testing 
specific areas 
theory 
experience 
random atgs 
structural atgs 
functional atgs 
specific areas 
experience 
existent atgs 
testing formal specifications benefits testing formal specifications 
high level specification languages test generation 
iii brief vdm sl 
triangle problem suitable test cases 
north test cases 
invalid input domain problem 
boundary values 
testability 
context testing formal specifications 
formal specifications implementations 
testing explicit operations statements 
oracle problem 
executing tests 
test cases generator software life cycle 
data type transformations 
instantiation consistency checking 
constraint satisfaction problems 
constraint logic programming 
constraint logic programming languages 
solver vdm sl predicates 

systematic partitioning partitioning vdm sl expressions 
justification attempt 
coarse partitioning rules 
valued logic lpf consequences 
embedded path expressions 
implementation considerations 
refinements 
partitioning coarse 
partitioning expressions non logical operators partitioning scoping expressions 
quantified expressions 
set comprehension expressions 
iv direct synthesis 
systematic formal partitioning 
combinatorial explosion 
sensible tests generation controlling partitioning 
context dependent combination 
rationale context dependent combination 
notation 
constructing test sets initial approaches 
naive approach 
graphs 
systematic test cases generation 
parsing 
algorithm overview 
phase establishing dependencies 
second phase systematic partitioning labels 
third phase redundancy analysis 
fourth phase sampling 
examples 
function dependence 
function dependence 
function call 
functions dependence 
multiple function calls 

triangle problem aspects remaining aspects 
recursion 
looseness 
triangle problem 
initial checks 
seq 
elems delta nat 
len 
elems delta sum 
pursuing classify 
evaluation 
permutations 
overflow 
scalene outcome 
invalid outcome 

contributions 
closing gap 
appropriate technique 
automation 

pragmatic considerations 
theoretical advances 
vi list figures approach 
venn diagrams partition 
venn diagrams partition binds delta 
simple partitioning graph 
merging dependent vertices 
complex graph 
merging dependent vertices complex graph 
vii list tables north test cases triangle problem 
lpf truth table logical operators 
dick faivre test cases triangle problem 
stocks domain division 
domain division binds delta 
test cases triangle problem part 
test cases triangle problem part 
reminder north test cases triangle problem 
viii chapter formal specifications derive software tests may odd idea 
think formal specification derived informal requirements surely allow proving program code case proper testing side stepped 
may paradoxical product formal development process help constitute informal controversial phases software life cycle 
thesis aim removing paradoxical element demonstrate automatic generation software test cases formal specifications complements existing software testing techniques showing performed 
software testing fuzzy state affairs software testing defined activity entire software development life cycle value contested basis famous dijkstra comment program testing show presence bugs show absence 
aim software testing firmly established variations purpose literature mention industry find errors possible special values testing inspire confidence program test tests mimics operational distribution typical usage 
confusions mainly due lack agreement place testing software development life cycle absence complete theory testing 
various arguments software testing 
principal considered ultimate program validates best tests devise imply correctness system consideration respect specification formal proving achieve aim 
background kept mind formal proving program correctness completely automated error prone activity inspire confidence program delivered software testing necessary proof program established 
early note testing necessary correctness proof construction 
testing program environment means compiler operating system run time environment taken account establishing reliability software delivered 
furthermore ignore prevalence testing everyday software development formal development 
hand accommodating current formal framework advocated software engineers academics may productive 
doing may remove myths testing formal development 
formality faced mass ad hoc techniques constitute testing phase believe incorporating formality testing process clarify situation allow progress 
gap filled outlined software testing taken large fuzzy subject see 
reason existence automated tests generating tools ing 
testing activity increasingly automated 
crucial area tests generation largely performed manually important aspect software testing requiring automation 
manual testing demands performed non rigorously need automated tests generating tools software engineering community strong 
automated testing tools valuable sound theoretical base provide theoretical researchers testing needed experience data basic testing detail view 
reviewing tests generating tools existence ad hoc techniques originate fail notice gap terms research interest actual structural tests generating tools derive tests code program test functional tests generating tools derive tests specification 
usually require significant amount manual prior automatic tests generation 
due part having write test scripts non standard notations 
thesis show deriving tests standard high level formal specifications performed 
examine north review technique light dick faivre stocks carrington original automatic technique test cases generation formal specifications 
side issue try show may benefit software testing formal development techniques 
outline thesis chapter conduct extensive review automatic tests generators atgs theoretical underpinnings 
essential comprehension main results included show continuity necessity testing process taken 
hoped provide rationale undertaken 
chapter elucidates related areas concern testing formal specifications 
introduces vdm sl study language 
north case study feasibility testing formal specifications discussed example triangle problem revisited 
general remarks activity put reader 
partitioning thrust functional testing reviewed chapter 
build new formalism systematic partitioning vdm sl specifications 
discuss depth synthesise results dick faivre stocks carrington 
small examples illustrate discussion 
chapter systematic partitioning vdm sl reviewed heuristics reduce number tests generated impairing quality test sets generated introduced 
discuss techniques investigated automatic construction reduced test sets 
test sets small examples vdm sl specifications generated 
chapter discuss looseness recursion view integrate approach 
conclude chapter test set triangle problem introduced chapter generated technique 
followed discussion degree adequacy achieved test set 
chapter outline contributions suggestions improve quality test sets generated technique 
chapter previous automatic tests generation chapter introduce aspects automated tests generation examining theoretical results existent testing tools 
introduce preliminary considerations need addressed examining automatic tests generation 
section introduces theoretical background general purpose automatic tests generators atgs 
categorising atgs easy task mixed strategies 
roughly agreed atgs categorised random structural functional classes partition adopted 
theoretical flaws advantages strategy 
complementary formal approach 
specific testing areas general purpose strategies usually considered suitable reviewed 
implementations general purpose strategies described theory section introduced discussed length experience section 
presentation pretend exhaustive examination representative tools class atgs sufficient allow understand problems hinder everyday 
specific areas testing tools 
conclude suggestions improved atg 
specifically emphasis features tool widely acceptable software engineering community 
preliminaries number books articles introduce testing process diverse tests generation techniques 
myers book classic book shaped current ideas software testing needs supplemented subsequent effort beizer example get date picture software testing 
describe evolution views testing activity origin time 
british computer society specialist interest group software testing bcs released standard component testing 
component unit testing concerned testing individual software items separate specification available 
standard prescribes characteristics test process describes number techniques test case design measurement 
automatic tests generators see techniques 
glossary terms software testing produced 
documents represent remarkable improvement situation prevailing standardisation process started standard available testing components performed 
note concentrate component testing integration system testing testing performed components put form coherent system 
component testing traditionally received attention tool developers 
usually case limit scope discussion automatic software testing dynamic testing 
dynamic testing requires execution program test data opposed static testing 
static testing see practical established approach includes program proving anomaly analysis called data flow analysis 
conclude preliminaries discuss primary aim testing process 
hinted primary aim software testing clearly defined 
give main variations ffl aim defect testing find errors possible program test special values testing 
ffl aim operational testing increase reliability program test tests mimics operational distribution typical usage 
theoreticians clearly separated practices 
article choosing testing method deliver reliability frankl hamlet littlewood clearly shown testing practices distinct 
particular highlighted main shortcoming defect testing informally defect testing may lead reliable software inputs remaining erroneous behaviour software test occur operational distribution typical usage software 
detecting defects possible software test may efficient way increasing reliability software delivered 
problems operational testing 
example highly reliable piece software may unacceptable remaining defects catastrophic consequences 
example software package contains error occur causes formatting hard drive personal computer unacceptable 
highlights problems reliability measures take account seriousness errors 
errors may easily revealed defect testing techniques may low likelihood detection operational testing 
simply inputs leading errors may appear distribution typical usage 
main reason remainder concentrate defect testing difficult operational testing find tests applied software test 
due difficulty knowing advance input distribution typical usage 
particular automatic tool discover distribution typical usage 
objective reveal defects possible software test 
keep mind shortcomings defect testing highlighted primarily may straightforward method increasing reliability software test 
theory section briefly examine theoretical background general purpose tests generators 
general purpose mean generators able test programs specific strategies testing necessary 
testing areas usually deemed unsuitable general purpose tests generators include user interfaces object oriented systems real time systems concurrent systems 
testing areas examined 
testing knowledge systems concerned validation knowledge stored data base validation implementation system examined 
complementary explanations consistently 
strategies partially automated 
overview ultimate goal atgs perfectly implement testing strategies verify criteria stating testing performed 
criteria formally called test data adequacy criteria 
teams currently working deriving criteria 
zhu hall research particularly promising generality criteria prove formal taken account design atgs 
leads notion adequacy criteria rules test sets bad functions specifications programs subsets data degree adequacy real interval 
retain definition allows discuss relative adequacy various test sets derived problem 
date definite practical criteria test adequacy 
testing strategies needless say atgs try reach imperfect goal 
problem having sound theoretical base puts doubt efficiency testing strategy consequently atg 
reason research test data adequacy area needed 
testing strategies evaluated formal criteria tempting try compare mathematical models 
unfortunately difficult construct mathematical models different testing strategies available random testing assess performance 
human factors involved software development process partially blame difficult formalise 
hazardous construct models argue error revealed input partially depends team developed program entirely supposed ill foundation input chosen 
models developed far consequently grossly imperfect unstable minor variations parameters parameters set subjectively result huge differences terms efficiency strategy supposed model 
research area obviously needed theoretical means evaluate degree adequacy test sets generated particular strategy 
intuition loose arguments common means evaluation testing strategies despite availability mutation analysis techniques 
mutation analysis valuable evaluating efficiency test set finding errors program 
method universal solution comparing testing strategies mathematical models aim evaluation test sets generated finite number programs 
technique 
mutation analysis uses program evaluate adequacy test data 
performing minor modifications mutations program test mutants program created 
evaluate adequacy particular test set sufficient execute set mutants test set count number mutants detected 
process requires executions mutant created extremely time consuming 
choi mathur mimd architecture perform mutation analysis hope reducing execution time 
objective pursued simd architecture 
mutation analysis intrinsically demanding computational power 
various testing strategies compared mutation analysis example 
small study program turned favour constraint testing see part devoted structural testing 
result surprising goal constraint testing precisely score highly mutation adequacy criteria 
mutation analysis considered ultimate decision technique ruling testing strategy effective generating high performance test sets 
argue significance results mutation analysis strategies structural strategies 
mutation analysis valuable technique especially seen theoretical result moment allows human tester evaluate efficiency automatically matter manually generated test set 
experimental results tests produced program useful theorists designers atgs 
coverage analysis methods example measure proportion program test executed test set evaluate adequacy test generated common 
methods controversial mutation analysis significance results fully understood advantage easily automated having low overheads 
described benchmark framework evaluation software testing techniques 
effect faced low level theoretical results agreed experimental means evaluate testing technique efficiency left consider establishing rigorous repository correct incorrect software side test sets generated different techniques 
huge undertaking invaluable practitioners academics alike allow time classification software techniques empirical scientific studies emerge 
hoped firmly anchor software testing software engineering 
random testing random testing strategy generates test set randomly selecting inputs input domain description program test 
form random testing purely automatic 
refined form random testing probable operational input distribution generate test set discussed preliminaries chapter 
probable operational input distribution typical usage difficult obtain prior software delivery difficult agree automation actual generation tests difficult envisage scheme 
random testing intuitively poorest strategy selection inputs test program 
early books software testing discuss dismiss 
study hamlet efficiency random testing tends dismiss intuitive view 
follows report ntafos 
partition testing strategies see examined comparison random testing 
weyuker reviews results hamlet clarifies 
experimental approach hamlet ntafos weyuker uses analytic approach 
results tune intuitive feeling random testing poor value 
absence real consensus efficiency random testing obliged accept particular areas especially strategies complex implement random testing acceptable strategy 
seen article frankl somewhat clarifies debate focussing operational testing pure random testing demonstrating may appropriate testing technique achieving high reliability 
clarifies random testing seen helping gain confidence program test 
structural testing structural testing strategies generate test set analysing code program test 
atgs structural approach primarily generators 
considering generators programs imperative sequential language common 
specific generators described section devoted specific areas testing 
generators may may symbolic execution described experience section 
ideal criteria ensure possible paths program test go traversed 
astronomical number possible paths vast number infeasible paths strategy impractical 
weaker criteria adopted statements branches linear code sequence jumps program test executed 
similar criteria 
order fulfill generate possible paths program examining code generate test inputs accordance criteria chosen 
problems raised vast number potential paths checking feasibility hinder strategies 
radically different strategy generating tests mutation analysis developed demillo offutt 
strategy constraint testing cbt uses algebraic constraints describe test cases designed find particular kind errors program test 
mutations introduced program test similar fashion mutation analysis algebraic constraints specifying error introduced program generated 
solving constraints tests created detect construction errors introduced program 
original program tested tests generated 
strategy interesting received sufficient attention needs mature spread researchers fully judged 
computationally intensive despite works described 
woodward describes various variants mutation testing introduces current research area 
random testing structural strategies provide prospect automated oracle means determine correctness test results obtained 
generators black box strategy generally provide means implement oracles 
functional testing atgs black box strategies random test generators degenerate form require code source examined generating tests 
tests derived solely specification modelled system requirements intended behaviour program test scripts describing loosely tests generated 
take account internal structure program functional testing strategies implementation language independent 
atgs test scripts considerably simpler devise atgs specifications tests requirements explicitly stated 
test scripts manually derived specific notation useful generation test sets 
comparison specifications useful level software life cycle 
atgs scripts impose significant extra burden human tester compared atgs specifications 
limit review atgs specification behaviour program test tools fact automate entire tests generation process 
specification take forms 
highly mathematical expression vdm sl algebraic axiomatic form finite state machine fsm specification program handled obtain test set closely related style specification 
highly mathematical specifications example form equivalence partitioning usually applied 
test selection methods deterministic fsms developed area testing theory developed useful theoretical results exists 
cite method output uio method wp partial method method 
methods identification number fault models 
way define fault models specifying set implementations erroneous behaviour mutants detected test suite 
set mutants considered methods allow derivation test suites completely identify kill mutants 
typically mutation types considered fsms output faults output transition wrong transfer faults state transition wrong 
extensions fsms limited modelling ability control aspect systems specified 
formal notations extend usefulness fsms specification technique lotos estelle sdl 
area current research focused partitioning strategies high level mathematical notations 
partitioning strategies divide input domain program test sub domains points 
sufficient select member particular sub domain represent entire sub domain sub domain homogeneous respect fail pass criterion correct behaviour program 
test data adequacy criteria evident find structural testing 
test set size important concern techniques reduce size test sets generated respecting chosen criteria devised 
theory partitioning 
mathematical definition partition adapted software testing 
definition partition equivalence classes definition domain predicate partition set definition domain subsets formally called equivalence classes nonempty disjoint union 
equivalence class nonempty subset input domain program 
software testing members partition informally called classes equivalence classes 
general tests generated black box techniques need transformed execution possible test specification representation particular representation implementation language program test 
case tests generated white box techniques 
program behaviour formal specification behaviour program form graph representation algebraic specification entirely contained specification best strategy providing expected output generation test cases 
impossible obtain expected result computation model specification languages 
primarily languages non executable allow implicit loose specifications constructed 
see chapter possible specifications ensure result computed consistent specification sufficient purpose 
furthermore black box testing code independent allows tester tool language implement program test 
advantages black box testing described 
specific areas testing strategies described principally applicable programs imperative sequential language 
testing strategies programs historically investigated testing requirements better understood 
research carried specific areas software testing 
arbitrarily gathered heading specific areas testing user interfaces object oriented systems concurrent systems real time systems 
testing strategies systems share large part contents mainstream testing strategies usually pose specific problems 
specific problems examine 
user interface systems difficult formally specify research active area structural testing intuitively inefficient systems 
testing strategies systems mainly random statistical strategies 
noted structural testing strategies language dependent tied called specific testing areas 
example construct tool white box test programs necessary identify features inherent object oriented systems inheritance message passing 
functional testing theoretically sufficient obtain specification program test apply mainstream functional strategies 
example object oriented systems tested functional testing specification takes account specific programming style object oriented systems theoretically irrelevant 
similarly functional testing concurrent systems performed specifications specify concurrent aspect system 
specialist formal notations object oriented systems see example extension effort vdm sl concurrent systems csp 
notations author knowledge examined tests generation point view 
considering real time systems confronted non functional requirements constraining worst case response time 
static analysis techniques applied rigorously deal inherent concurrency systems rely accurate worst case execution time wcet sequential code 
automatic testing technique tool determining wcet sequential code currently developed university york uk 
seen specific areas testing reviewed infancy 
volume research areas growing rapidly offering hopes development 
theory testing strategy advantages flaws 
example white box testing detect missing functions black box testing detect unused code accepted combined strategies best way achieve high quality testing existent strategy sufficient variety strategies applied constructing test set 
random testing considered attractive testing strategy suitable inspiring confidence program test strategy 
testing performed random input values reassuring human tester testing carried special values boundary analysis strategy refinement partitioning strategies example 
notion confidence program tested important atgs accepted trusted 
pointed automation test set generation process valuable objective encompass generation expected output test input means ensure consistency computed result 
specification program automated oracle devised 
see detailed example 
experience section briefly presents existent atgs 
emphasis weaknesses systems 
details implementation strategy system described 
automatic software testing old idea atgs implemented 
far everyday 
summary principal reasons poor concluding section 
qualities atg exhibit acceptable software engineering community 
sketch new system having qualities cited 
random atgs random atgs random atgs rarely cited literature reflecting little applied research carried area 
lack intuitive attractiveness method probably random testing area theoretical research applied 
intrinsic simplicity huge need automatic testing tools certain areas reasonable suppose implemented industry case case basis test particular products 
author knowledge general atg reported literature 
generators need precise description program input domain source knowledge generate purely random test set 
test set generated chosen specific distribution operational distribution example reflect everyday product 
input entered user higher probability chosen generator 
kind information easy obtain prior product release course testing little value 
random atgs description areas random atgs encounter wider 
area compiler testing appreciated relative simplicity implementation 
describe atg randomly test pascal compilers 
syntactical description source language needed generate compilable programs 
formalism utilised context free parametric grammar permits testing context sensitive aspect programming language 
writing context free parametric grammar language described authors certainly trivial 
process automation relies heavily tester ability write correct description language 
compiler test generator pl test generator developed ibm described 
random generator tuned test known weak areas compiler 
system weights introduced direct generator statements selected 
programs generated executable 
generator specific language processed compiler large parts rewritten test compilers language 
introduces random atgs specific systems graphics package sort merge program 
random tests generators limited scope application 
accordance authors beliefs tests generator specific general purpose 
generators developed principles design random atgs 
principles described 
principles applied developing random atgs cost development higher ready general random atg 
random atgs random test generators easier construct functional counterparts 
method selection input random random number generator needed heart selection process 
simplicity attractive 
doubts potentiality randomly chosen test set find errors software high 
random tests generators trusted 
developed easiest method test set selection implement 
absence simple technique test particularly difficult software compilers testers chosen random approach 
done randomly chosen sets inputs proved testing strategy area concerned 
intuitive poor value theory underpinning random testing strategy tester tempted random tests generator heavily program large number outputs check 
need automatic oracle acute random testing methods 
general tools high level notations specify input domain system test place case case tools developed widen random test generators 
thing testing general surprisingly open theoretical question 
structural atgs structural atgs test generators white box strategy structural atgs called undoubtedly atgs encountered success widest industry 
random strategies structural strategies intuitive means test program 
area automation advanced 
wide range white box strategies 
structural atgs generators exception generators constraints testing examined 
introductions generators differ means overcome path revelation problem criteria apply generate tests 
symbolic execution widely means generating path traversal conditions 
structural atgs description gives review systems symbolic execution generate different paths program traverse 
illustrate small example symbolic execution help generation tests 
fragment pascal program input variables output variable 
symbolic executor control path program express output variables terms input variables constants 
path traversal condition generated terms input variables constants path input exercise path condition satisfied 
example paths 
path condition result gamma 
path condition result gamma test set exercise example path program generated finding path traversal condition inputs satisfy condition 
example tests exercise paths program 
problems occur symbolic execution ffl evaluation loops 
ffl module calls 
ffl array 
ffl feasibility path 
illustrated 
techniques try overcome problems described 
criteria testing system said symbolic execution ffl produces path condition path traversed 
ffl determines path condition feasible 
ffl output variable produces expression terms input variables constants 
systems described literature pass criteria select attest ips fortran testbed 
systems symbolic execution level automation achieve quite uneven 
system uses symbolic execution generate set paths program traverse satisfy criteria said unsuitable automatic generation test inputs 
described 
system consists components ffl fortran source code processor 
ffl path generator 
ffl path constraint generator 
ffl solving constraint system 
path generator uses information produced fortran source code processor flow graph symbol table representation source code generate set paths cover branches 
path constraint generator produces path condition path 
solving constraint system generates values satisfy particular condition 
strength probably full coverage fortran language 
reliable values generated isosceles triangle 
inspire great confidence value test generated 
sym bol developed attempt improve symbolic execution techniques avoid problems 
attempt generalise generators primarily intended numerical software written fortran commercial systems written cobol 
sym bol uses path condition list constraints representing feasibility path 
common problem encountered generators discussed article strategy adopted sym bol described 
tool represents new wave interest generators closely examined structural atgs designers 
full cobol language accepted tool sym bol offers hopes developments 
korel describes automatic test data generator actual execution program test dynamic data flow analysis function minimisation related symbolic execution approach 
generator encounter problems associated symbolic execution 
basic operations korel generator program control flow graph construction path selection test generation 
steps automated 
korel approach problem free limited ability detect infeasible path simplicity language program test subset pascal requires research fully judged 
korel presents interesting possible areas research technique 
system kind 
conducts path analysis maintaining maximum minimum values variable 
constraint testing cbt implemented fortran 
new testing strategy difficult evaluate 
problems method difficulty eliminating redundant ineffective tests 
structural atgs atgs promising software development tools nearly decades research field technical problems hinder general 
problems lie generation possible paths illustrated symbolic execution approach actual selection test set satisfies criteria 
cbt promising strategy efficient require implementation oracle method cater 
functional atgs functional atgs automatic test generators black box strategies extract information need generate tests specification program test specification 
differ mainly type specification sampling method 
functional atgs oblige tester write testing oriented specification 
oriented specifications theoretically program specification rarely done 
specifications constraining general purpose program specification difficult write 
functional atgs description statistical approach particular requirements tested identified filtered statistical considerations concerning operational risk factors investigated 
unfortunately method offers room complete automation statistical values assigned requirement tested largely subjective 
theoretical results operational testing deserves attention 
agent system uses function diagram extension cause effect graph generate test cases 
cause effect graph diagrammatic notation expressing logical statements function diagram composed state transition diagram set boolean functions specified cause effect graph decision table 
tests automatically generated agent satisfy fairly natural criteria defined function diagram ffl validate input output conditions states 
ffl pass transitions 
graph models considered automata petri nets generate test sets employing graph coverage criteria 
systems advantage having defined criteria test set selection suffer difficulties faced attempting write required appropriate function graph complex algorithm 
due difficulty hard see systems widely 
generation expected output generally straightforward due low level abstraction graphs 
tsai describe system automatically generates test cases relational algebra query 
relational algebra chosen database data processing applications 
efficiency system compared random testing 
efficient reliable investigations needed fully assess real performance finding errors 
small scope relational algebra specification language weakest point system limits system database testing 
fsm testing received lot attention relation testing communication protocols 
communication protocols rules dictate different components distributed system communicate 
fsms extensions protocol specifications 
required testing protocols high iso protocols tested standardised test purposes scripts 
mention results area tests generation lotos specifications 
lotos formal description technique particularly suited protocol specifications 
mention particular early pitt considered laws constructing tests lotos specifications adapted ad hoc manual practices 
lotos subset considered small excluded lotos expressions containing data parameters automatic tool constructed 
automatic tool derivation test cases lotos expressions data parameters constructed li taniguchi 
kind expressions allowed restricted allow automatic decidability simple linear integer programming 
strategy transformation lotos specification transition tree representing behaviour static level depth 
description test cases generated transitions deadlock nondeterministic branches detected 
widely reviewed researchers late english translation despite promises 
mention results prolog specification language allow automatic testing subset class iv protocols 
describes site system able generate test cases axiomatic specification data type 
oracle provided automatically generated implementation reflects behavioural properties specification 
test set generated syntactic part specifications 
valid expressions produce instances data type maximum level depth generated 
tests generated applying different behaviour operations instances 
approach distinctive problems limited scope application difficulty encounter writing axiomatic specifications complex data types lack theory underpinning method test selection large number tests generated 
system high level automation interesting 
unfortunately difficult see enlargement scope application systems site 
axiomatic specifications general means specify complex algorithms various areas software development oracles provided automatic generation implementation specification confined simple problems highly restricted areas generalised 
formally described method construct test cases formal specifications 
theory applied algebraic specifications system constructs test cases 
despite case study approach limited difficulty writing algebraic specifications general purpose programs 
technique described formal hope interesting developments domain model specification languages 
hoffman introduces tools techniques writing scripts prolog automatically test modules implemented language 
selection method generating test sets automated left human tester consider set tools forming atg 
ostrand approach category partitioning pretend directly automated automation method envisaged investigated 
remarked notion category ostrand approach informal hope immediate implementation method discussed 
mention chang richardson tentative method test conditions generation adl assertions 
stocks carrington formal framework test generation specifications 
unfortunately automation discussed results reviewed 
dick faivre promising tool built generates test inputs vdm specifications 
discussed great length 
functional atgs seen research demonstrated black box testing practical technique 
difficulty assessing actual systems lies judging fairly level automation achieved course efficiency systems finding errors program 
great advance black box testing tools able process established specification languages areas software development testing 
languages vdm sl processed burden writing specific specifications testing purposes lifted greater automation way achieved 
specific areas developed commercial tools testing os windows applications graphical user interface 
main characteristics ffl allow storage manipulation user sessions 
ffl testing language provided test specific situations 
ffl basic facilities helping validation results provided 
result logs automatic comparison baseline case application performed correctly tools facilities 
tools facilitate testing interfaces automating repetitive tasks performed human tester 
general considerations testing object oriented systems reviewed graham 
tools exist example white box test object oriented systems ad hoc techniques specific problems posed systems systematically studied 
particularly difficult generate specific test sets real time systems 
formally specifying systems notoriously difficult despite development real time csp 
structural testing strategies specifically developed determining worst case execution time sequential code research area just 
current practice randomly test code large test sets devised validation functional properties system measure execution time research area ongoing 
specific strategy automatically testing systems available moment 
glass presents survey problems associated testing real time systems 
problems structural testing concurrent programs examined 
path analysis developed sequential programs applied concurrent programs reproducibility program execution ensured 
yang chung approach construct graphs model execution concurrent program program flow graph program rendezvous graph 
graphs combined obtain concurrent path model 
authors article discuss problems test path selection test generation test execution 
korel approach roughly similar 
starting point atg sequential programs modified cater concurrent programs 
works subset ada 
research area fairly apart isolated early works brinch hansen need pursued implementation general structural atg concurrent programs possible 
testing tool ada programs human tester write test scripts ada test scripts analysed tool tests applied program test 
tool simply help testing ada programs considered atg 
experience seen wide variety atgs suffer serious deficiencies 
summarise problems atgs ffl efficiency difficult assess 
ffl level automation achieved generally high 
ffl single strategy 
ffl scope application usually limited 
problems briefly discussed 
evaluate efficiency atgs short theoretical means mutation analysis technique currently available 
unfortunately actual significance measures produced technique fully agreed implementation problems remain 
breakthrough test data adequacy area emerges difficult imagine improvement situation near 
designers atgs aim faithfully implement formally described criteria hope mathematical models able represent accurately 
human tester majority cases intervene help execution atgs 
efforts pursued area lift burden basic testing human testers 
software testing environments created gather friendly manner various consistent testing strategies 
multitude tools testing process tedious single testing environment atgs 
scope application atgs extended mainstream strategies 
random atgs general specific 
structural atgs accept complete language definition subsets usually case 
functional atgs high level abstraction languages specially developed mathematical notations 
existent atgs seen current atgs fulfilled engineers expectations 
lack theory underpinning tools partially blame deception 
author believes better automatic testing tools developed frame current testing theory 
details view 
generalise atgs problems described conclusive part experience section addressed 
construction testing environment depends availability distinctive trusted testing strategies 
unfortunately mainstream testing strategies reached stage full automation achieved strategy trusted 
limited concentrate strategy hoping improvements 
area functional testing development stable specification languages vdm sl offers platform implementation multitude supportive tools 
current standardisation re enforce development 
software testing tools benefit standardisation 
detailed chapter north showed manual test generation vdm sl feasible 
great advance efficient way test software designed high level specification languages 
means determine consistency computed results provided specifications 
course test data difficult generate functional strategies combined approach great value 
bear mind stated human competence ingenuity remain sine qua non condition success testing process 
chapter testing formal specifications chapter examine characteristics generating test cases formal specifications 
re state benefits activity introduce main established formal languages vdm sl having briefly described vdm sl case study language chosen examine specification example understood triangle problem 
study expand discuss general manner issues involved performing testing test cases generated formal specifications 
sketch general approach automatic test cases generation 
benefits testing formal specifications seen previous chapter testing formal specifications functional strategy completes common structural approach taken testing software systems 
completeness re state benefits performing functional testing side structural testing ffl potential detect missing functionalities 
ffl language independent 
ffl may provide automatic oracle 
addition benefits note global point view process testing software formal specifications brings cohesion software development life cycle helps long established paradoxes formal methods general 
particular formal specifications derive software test cases odds techniques formally proving software correctness 
particularly true proofs rarely provided entire specification generally derived parts specification highly safety critical 
formal proving testing usually required acquire confidence system developed 
remarking formal methods opposition testing weaken perceived paradox arising generating test cases formal specifications 
testing formal specifications brings double edged benefit software development process testing acceptable proponents formal software development brings added value formal specifications ultimate role seen formal proving entire system development 
myths attached formal methods testing formal specifications 
introduces illustrates areas formal specification formality software development general best exploited just proving correctness system testing prototyping requirements capture 
notion adding usefulness formal specifications highlighting benefits formality software development formal methods acceptable wider community mind 
testing high level specifications idea hayes showed derive tests specifications 
technique purely manual prospect automation 
size typical specifications automation necessary condition success testing formal specifications 
mirrors structural testing strategies non negligible degree automation achieved techniques rarely complete limited usage 
human testers concentrate error guessing generally apply expertise non basic testing complete automation allow take place 
implicitly far discussed testing software systems 
view tests generation formal specifications test specification 
view notably expressed authors toolbox 
variant tests derived show conformance refinements specification 
proof obligations provided vdm ensure mathematical self consistency vdm sl specifications 
prove obligations automatic theorem provers progress lindsay surveyed systems available mechanical proving late provers require interactions skilled user construct proofs required 
method translating vdm sl specification language theorem prover pvs described 
difficulty manually mechanically proving proof obligations led idea testing specifications conformance 
testing detect immediately inconsistencies underlying specification alleviating subsequent wasted effort formally proving required obligations 
keep mind tests derived formal specification potential usages test specification test corresponding system 
rest thesis place emphasis testing software systems specifications appropriate mention consequences findings specification validation 
high level specification languages test generation seen previous chapter attempts generating tests formal specifications different styles 
attempts achieved low level automation difficulty writing specification hindering wider usage technique 
particularly true tests generation algebraic specifications technique applied field applications suitable algebraic specification languages moment limited simple data types 
algebraic specification languages infancy may bring improvements specification process software systems 
recall objectives generate tests automatically versatile specification language automatically possible constrained consider algebraic specification languages stage 
move away test scripts specific notations consider established general purpose formal languages 
north reports feasibility study concerning automatic test generation specifications 
aim find style specification language promising automatic test generation 
study triangle problem introduced myers 
discuss triangle problem details 
suffice say problem classifying triangle scalene isosceles equilateral length sides extremely simple problem illustrates difficulty finding suitable test set problem documented example 
north took representative formal specification techniques different style specified triangle problem technique showed derive tests suggested myers triangle problem hand tried systematically generate set tests specification 
north choice specification languages ffl vdm sl model language ffl miranda functional language ffl prolog logical language report 
desirable feature suitable specification language information possible explicitly available test generator 
example language typed allow type invariants expressed easy boundary values generation 
away implementation details 
considerations prolog deemed unsuitable re specification necessary parts specification concerned implementation details implementation sets 
surprise prolog hardly designed specification language place 
needed covered purpose confusing prototyping specifying activities 
miranda deemed worth considerations 
quite benefits executable specifications advantage considering problem oracle 
vdm sl deemed suitable high level nature doubts raised ability generating test cases vdm sl specifications executable 
north remarks main difference miranda language vdm executability vs abstractness price executability loss abstractness 
north findings knowledgeable decision style specification base efforts 
clearly test cases generation functional language potentially easier model language 
oracle problem immediately solved functional language case executing specification generated test inputs 
take account effort writing specification degree acceptance specification language 
currently model languages widespread choice specifying software systems 
widest tool support 
aims reduce effort required test software imposing burden developers having write specification problem somewhat unusual format reduce search suitable specification language model languages try overcome problem oracle 
describes fundamentals model specifications introduces main representative notations vdm sl briefly model specification languages concentrate specification machines specifying states operations applied algebraic specification languages concentrate specifying data types 
strictly speaking vdm formal method specification language vdm sl simply notation set theory 
vdm method largely refinement capabilities possibility refine specification verifiable manner high level abstractness near implementation level proof obligations formed specifications 
refinements programming language level limited difficulty proving refinement steps correct 
choosing functional language target language process eased 
purpose need discuss specification language vdm 
shall discuss differences verification level vdm shall concentrate syntactic expressibility differences notations 
verification comparisons 
reported vdm sl differences superficial 
note vdm sl strictly typed language compared schemas elegant way constructing large specifications maximum reuse components 
test case generation point view difficult foresee language suitable potential choices 
need choose language approach explicit facts vdm sl formal structure distinguishes states types operations requires pre conditions explicitly operations functions notation semantics vdm sl stable variants availability agreed ascii syntax suitable automatic treatment time choose vdm sl study language automatic test cases generation formal specifications 
standard vdm sl provides means clarify aspects semantics 
size complexity standard viewed providing language far suited purpose 
doubts aspects semantics refer standard 
provide short vdm sl standard particular standards non executable specification languages general 
note consequence similarities vdm sl findings applicable notation 
case shall explicitly point 
brief vdm sl briefly introduce vdm sl point notable characteristics purpose 
comprehensive vdm sl 
vdm sl model specification language provides model system state terms collection state variables 
state variable models aspects system 
states specified mathematical objects common basic types integer real number boolean sets maps sequences records 
powerful predefined operators types available vdm sl 
low level difference vdm sl valued logic system true false undefined known logic partial functions lpf 
briefly described 
undefined values arise vdm sl operator function operation outside definition domain 
example division zero returns undefined value 
conditional boolean quantified expressions systematically spread undefinedness 
example boolean expression true undefined evaluates true 
hand expressions propagate undefinedness fo example expression undefined evaluates undefined 
specification written vdm sl classically composed state operations state functions 
basic means modularisation available large vdm sl specifications re developed example give state representing date state date year month day inv mk date leap leap state record composed fields year month day particular type 
invariant property hold specification provided date specifies date represented valid date common sense term 
invariant preserving operations provided change state example advance current date 
functions modify state 
leap implicit function leap year post mod mod mod explicitly follows leap year leap mod mod mod result implicit function validate postcondition introduced post 
allow greater degree flexibility explicit functions result defined evaluating result type expression result constructed constrained 
functions side effect free call operations 
functions loose result completely defined 
example consider parameterless function taken returns number defined 
post div result function constrained return natural number specific number requested 
loose functions interpreted specified nondeterministic case operations 
means correct result allowed result returned set parameters 
loose operations interpreted nondeterministic assumptions result set possible solution returned 
example function may true false true 
operation may true false evaluate false 
shall see loose expressions loose specifications general lead surprising results looseness powerful concept allowing greater expressiveness language integral part vdm sl 
looseness enables respect principle minimality specification language force user specific wishes 
implicit operation update date day day date date post day day day elseif day month leap year day day month day day elseif month day month year year day month month explicit operation calculate number days separating current date state arbitrary date diff days date diff days ext rd st date dcl diff int temp date st temp temp day temp diff diff return gamma diff explicit operations specified statements similar programming language constructs assignments example allowed 
statements just precisely defined rest vdm sl 
proofs involving statements straightforward proofs involving vdm sl expressions 
explicit operations closer implementation conventional programming language 
vdm sl vdm general small suggests 
vdm sl large complex language versatile specification languages currently available 
depth discussion language reader refer 
triangle problem suitable test cases give small useful specification example illustrate test cases suitable testing eventual implementation 
allow clarify aspects testing formal specifications triangle problem proposed myers follows program reads integer values card 
values interpreted representing lengths sides triangle 
program prints message states triangle scalene isosceles equilateral 
remarked north informal specification fails mention behaviour program integers denote invalid triangle 
north completes specification adding invalid returned integers represent valid triangle 
north test cases north vdm sl specification triangle problem intuitive chosen illustrate ways problems specified 
vdm sl denotes sequence possibly empty natural numbers 
note specification loose 
triangle type scalene isosceles equilateral invalid triangle inv triangle sides len sides sum sides elems sides delta sum sum seq seq hd seq sum tl seq variety triangle triangle type variety sides cases card elems sides equilateral isosceles scalene classify triangle type classify sides triangle sides variety sides invalid north presents test cases suitable triangle problem 
test cases arise north interpretation myers test requirements 
table reproduces north test set triangle problem denotes greatest natural number available 
id test input oracle id test input oracle invalid invalid invalid invalid invalid isosceles invalid equilateral invalid gamma scalene invalid invalid equilateral invalid isosceles invalid isosceles invalid isosceles invalid isosceles invalid isosceles invalid isosceles invalid scalene gamma invalid scalene gamma gamma gamma invalid scalene invalid scalene invalid scalene invalid scalene table north test cases triangle problem rest consider test set adequate triangle problem 
represents state art tests derivation black box techniques 
general test data adequacy criteria criteria stating testing performed executing checking tests subjective seen matter theoretical research 
give definition adequate test set 
definition adequate test set adequate test set test set manually derived state art testing principles systematically generated state art principles 
ways checking degree adequacy test set comparing manually derived test set ensuring generated established test generation techniques 
particular considering tests generation formal specifications theory partitioning outlined section 
play central role technique 
remember adequacy test sets subjective matter ongoing research debate 
return north test set triangle problem 
firstly triangle problem illustrates simple problems may require large number tests 
note tests invalid triangles 
north shows rationale tests generated 
specification tests inputs validating requirement seq nat evaluate invalid result specification undefined state 
test gamma represent valid sequence integers assumption classify gamma evaluates undefined invalid scalene suggested north 
shall return matters 
north uses aspects partitioning theory derive tests 
high level partition specification obtained starting classify immediately divides inputs valid invalid equivalence classes shown 
triangle sides classify sides variety sides triangle sides classify sides invalid step arises partition 


expression truth value condition triangle sides 
equivalence class vdm sl boolean expression 
note omission higher level partition implied north seq nat sides result classify sides seq nat sides result invalid variety sides partitioned simple case expression rule obtain partition triangle sides card elems sides classify sides equilateral triangle sides card elems sides classify sides isosceles triangle sides card elems sides classify sides scalene triangle sides classify sides invalid triangle sides triangle sides expressions course partitioned 
see specification loose 
facilitates verification output results implementation test simple comparison required ensure correctness behaviour particular test 
north study outlines way partitions constructed vdm sl specifications combination symbolic execution partitioning rules 
resulting expressions vdm sl predicates defining equivalence classes satisfied tests generated 
predicates constraints variables specification need checked consistency ensure equivalence classes define empty 
predicates len sides sides example inconsistent part partition 
great care taken devising partitioning rules respect vdm sl semantics 
example semantics vdm sl case expression partition consisting equivalence class generated variety sides triangle sides card elems sides classify sides equilateral triangle sides card elems sides card elems sides classify sides isosceles triangle sides card elems sides card elems sides card elems sides classify sides scalene triangle sides classify sides undefined general necessary ensure choice conditions satisfiable vdm sl case expression allowed taken 
necessary alternatives disjoint 
discuss fundamental underlying assumptions taken north 
invalid input domain problem attempting generate tests manually equivalence partitioning triangle problem specification north adopts valid invalid input distinction introduced myers 
myers invalid input domain input representing valid triangle considered special case equivalence classes identified 
trying cover equivalence classes possible minimum number tests valid classes myers suggests invalid classes covered individual test cases 
rationale idea reproduced 
reason invalid classes covered individual cases certain erroneous input checks mask supersede checks 
instance specification states enter book type loose amount test case xyz expressing error conditions invalid book type amount probably exercise check amount program may say xyz unknown book type bother examine remainder input 
north adopts view constrained deal invalid input incorporates invalid triangles separate manner 
note specification point view non sequences integers invalid inputs 
north artificially includes non valid triangles invalid inputs 
automatic test cases generator require prior human analysis specification decide classes ought considered invalid 
accordingly north identifies invalid classes ffl type input sequence natural numbers ffl length input ffl value sides ffl elems sides delta described test cases generation technique account perceived difference valid invalid input domains 
led components say operation specified vdm sl treated separately ffl basic type invariant variable ffl pre condition ffl exception handling part ffl post condition test generation technique variable driven common operator driven approach variable chosen depending testing valid invalid input domain tests input variables generated 
cumbersome dick faivre technique feel myers recommendation somewhat misplaced new formal specification context 
effect acknowledge myers point strong judge argument artificial subjective 
particular semantic differences pieces specification correct input incorrect input cases implementation may consistently ignore parts condition artificial differentiation treatment equivalent classes semantically 
shows need address myers concerns valid inputs invalid inputs 
myers solution incomplete runs risk detecting combinations invalid features myers example xyz 
example implementation pass myers test cases incorrect book amount invalid input elseif book amount invalid input 
valid inputs believe concerns addressed specifying behaviour system invalid inputs strict adherence semantics 
way myers informal specification incomplete failing specify program behaviour invalid triangles invalid inputs north formal specification fails indicate intended behaviour system invalid inputs non sequences natural numbers 
semantic point view behaviour system specified north defined vdm sl semantics undefined non sequence natural numbers encountered 
reluctant generate tests behaviour specification undefined reasons 
firstly clear behaviour implementation 
interface level may assume error message generated execution program terminated 
left problem deciding system behaved correctly 
vdm sl semantics matching undefined expression undefined 
decide automatically test passed failed 
theoretical point view incorrect inputs leave system undefined state incorrect input rejected non intended consequences 
specified specification system user interface level input validation part specification 
secondly clear sample class north seq nat example basic types sets maps records fact type sequence selected sampling principle apply elements non basic types chosen 
clearly type negation requirements needs handled care large inefficient test sets avoided 
triangle problem specified consider generating tests sequences natural numbers 
input validation requirement system appear explicitly specification 
mentioned interface level functionalities case robust systems software libraries concerned 
way include input validation triangle problem add seq int token seq int sides seq sides elems sides delta nat classify modified follows classify token triangle type invalid input classify sides seq nat sides invalid input vdm sl error handlers allow circumstances specified explicitly 
different error messages specified classes invalid inputs increase testability facilitate debugging 
triangle problem invalid input raised seq nat sides true seq nat sides undefined 
simple partitioning rule expressions form ab partitioned classes allows generation test cases inputs invalid domain 
illustrated detail chapter 
conclude matter started position invalid inputs treated differently valid inputs moved unique consistent complete approach deal inputs 
approach described implicitly 
suggested specification writing style encourages robustness increase testability 
help error tracking case incorrect behaviour system test 
boundary values complete triangle problem specification provide atg developers range example natural numbers defined implementation restricted finite domain 
notation north part specification nat token nat gamman constant set accordance system requirements 
generalising approach data type sets records sequences maps fixing maximal size assume validation input output variables vdm sl expression finite domain including desired reals 
means proof obligations simpler finiteness sets specifications easier establish vdm sl sets finite requirement gives rise proof obligations 
requirements may drastic necessary reasons 
firstly choose boundary values sampling classes experimentally deemed offer best prospect finding error system test 
need concrete value boundaries 
secondly easy see nearly system fail behave correctly respect specification test large exceed available finite memory underlying hardware 
avoid possibility inputs outputs constrained specification finite domains 
note large values say length valid sequence need chosen purpose test memory usage 
advantageously consistency checks test generation proper quantified expressions small sets transformed equivalent logical assertions 
testability point apparent north case study system specification consisting operations functions automatic test cases generator provided list functions operations tests required 
north implicitly assumes classify explicitly tested 
sum variety implicitly tested called functions 
necessarily best solution 
particular robustness testing required specification part library facilitate regression testing example test function operation explicitly 
consider function operation able called inputs just passed 
example general purpose function sum north specification triangle problem required tested robustness test sequences different length generated 
performing explicit testing functions operations leads larger test set see may pose problems trying perform tests 
triangle problem sum simply implemented invariant part triangle type 
executing test sum certainly difficult due broken isomorphism specification implementation test respect functions operations structures isomorphism assumed certainly meaningless 
sum tested explicitly implicitly 
situation arise specified function separately implemented tested unit stub available stub simulates actions functions called tested function 
note specification facilitate coding stubs 
matter functions explicitly tested ought left human tester requires knowledge implementation test requirements system 
suggest list functions operations tested explicitly passed automatic test cases generator 
context testing formal specifications discussing tests cases generation put context meaning test cases 
section assume test set function operation available consider significance perform tests 
formal specifications implementations firstly take note relationships formal specifications implementation counterpart 
important basic considerations mentioned discussing testing formal specifications 
consideration error detected oracle provided specification specification wise error 
words detect differences specified behaviour system test modelled specification actual behaviour 
acknowledge specification may fail model original intended behaviour system 
occur system requirements properly captured requirements properly modelled 
leads corruption automatic oracle 
human oracles expensive error prone especially test set small 
deciding specification models intended behaviour system done validation specification opposed verification intrinsically step formally decidable 
animation tools help process mentioned tests conducted specification 
problem lies scope 
assume specification correct 
vdm sl example numerous proofs derived ensure correctness consistency specification 
assurance assumption specification correct ensure validity errors detected 
note require proof satisfiability specification long specification syntactically correct test cases generated 
brief assume specification models perfectly intended behaviour system syntactically semantically correct proofs proof obligations constructed 
relationship implementations specifications needs considered suppose implementation tested consequence algorithm specifications tests generator 
seen triangle problem specification north specifications may intuitive may cumbersome deal consider vdm sl remarked true false abc valid expression simplified simply writing 
obvious different specifications problem lead different test sets 
begs question specification style increase adequacy test set produced 
specifications refined target implementation language may produce tests closer test data tests may problematic transform representation suitable actual execution see section 
details increasing testability implementation foresee theoretical argument tests generated specifications adequate tests generated higher level specifications 
definite answer hard imagine provided large amount experimental results guidelines issued rationale statistical 
testing explicit operations statements explicit operations final stages refinement means get closer target implementation language 
explicit operations executable feature exploited fully toolbox 
achieved seen statements close imperative language constructs benefit formal semantic definition 
proofs involving statements far easy statements considered guide concentrating proofs vdm 
statements closeness imperative implementation languages different ordinary vdm sl expressions example seen assign loop return statements 
choosing partitioning rules generation partition explicit operation difficult due sequential style specifications 
structural techniques ordinarily generate tests programs source code appropriate explicit operations 
amount black box testing tests generated specification 
clear explicit operations benefit devising new testing technique generating tests statements 
opposed ordinary vdm sl expressions test generation far understood apply nearly directly technique range white box testing techniques described previous chapter 
considerations choose concentrate test cases gener ation vdm sl specifications excluding explicit operations 
precisely exclude statements discussion believe available white box testing techniques 
needs course experimented confirmed 
oracle problem recall non executability specification language deemed difficulty generation expected result computation specification 
classically oracle provides expected result test detection error amounts simple comparison expected result provided oracle actual result system test may terminate crash 
classical approach feasible specifications bind totally outputs instantiation inputs test input vector 
arise situations solver unable find unique solution system constraints course non determinism 
case solver find solution satisfiable set constraints 
consider implicit specification function returning largest integer set positive integers max gammaset post delta implicit specifications result constructed constrained 
solver general fail find result max particular case easy deal cases find expected result generate test approach available lead extremely long searches 
hand actual result test run provided oracle reduced consistency checking 
check correct result max oracle check consistency delta great advantage moving away classical oracle possibility deal loose specifications 
simple example loose function consider post test yields oracle expression 
test result available oracle instantiate decide satisfiability boolean expression constituting oracle 
classical approach intractable leads generating reals greater actual result equals 
actual result fact incorrect specification example entire set implementation representable reals greater generated oracle safely declare actual output incorrect 
test inputs actual output instantiate specification obtain boolean expression true results correct 
cases truth resulting boolean expression straight forward establish simple simplifications seen oracle triangle problem amounts simple comparison actual result uniquely identified expected result 
loose specifications envisage satisfiability oracle expression relatively easy establish current constraints solvers 
case human intervention necessary 
constraints solving discussed chapter 
finding inconsistency test results oracle expression left difficult task debugging implementation 
hard see atg formal specifications direct help regard 
having executed entire test set useful reveal common features failed results terms test requirements exercised 
formal specification available misunderstanding intended behaviour implementation validity error detected readily established 
complete mentioned oracle side testing technique deciding success failure test automated structural techniques error guessing 
kind oracle unsuitable validating specification user requirements animation tools helpful verifying results specification testing toolbox 
executing tests test involving vdm sl state execute implementation validate behaviour 
problem relates way states instantiated calling appropriate operation 
views problem 
execute tests generated try instantiate states indirectly appropriate test sequence pure black box technique instantiate directly states technique coined white 
difference arises presence systems states vdm sl specifications approximation states vdm sl related global variables structured imperative language pascal pure black box technique system states reached test suites 
test suites devised reach chosen system state described test inputs 
white technique test inputs system states initialised direct access global variables program test 
method sequence tests described relies finite state automaton fsa 
remarks approach 
firstly technique hard automate version described fsa constructed hand axiomatic approach facilitate construction fsa algebraic languages may suited construction test suites see 
secondly importantly tests carried method states may unreachable 
thing specifications general discussed 
impossibility testing unreachable states technique implies robustness testing impossible test software consideration unexpected states system 
system tests correct respect specification specification valid robustness testing waste time 
may assume assuming denying efforts find errors system respect specification 
restrain specifications eliminate instances states fully reachable 
require prior manual analysis specification 
eliminate unreachable states formal specifications developer strengthen state invariants 
remarked highly desirable specifications intended reuse 
incentive developer remove unreachable states specification code tested states unexpected code 
deriving tests robustness clearly advantageous errors implementation testing specification revealed 
assume states reachable means directly instantiate state system test available tester 
requires manipulation system test sequencing tests formal specification testing conjunction structural testing techniques carried form test drivers stubs 
furthermore unit testing level little manipulation required 
system entirely specified robustness testing requirement testing user interface level eliminate need harness stubs 
direct means state instantiation unreachable state necessity replaced test sequencing cases states reachable 
test sequencing automatic total reliance direct means seen defect approach temporary solution 
research test sequencing needed believe problem test set generation proper needs solved tests sequencing focus research formal specification testing 
test cases generator software life cycle consider place automatic test cases generator development life cycle 
specification system written prior development system case reverse engineering course huge impact tests generated executed 
specification written prior system coding envisage approach test inputs developers indication errors coding process 
intuitively idea errors committed particular test inputs errors may difficult detect atypical 
traditional approach scope applications test generator vast especially specification limited units extends entire system 
envisage unit testing system testing regression testing 
describes semi automatic testing techniques incorporated life cycle various projects 
shows global approach validation adopted large projects achieve higher quality systems reducing inefficiencies development process proper 
offers insight industrial systems validation practices 
alternatively offers global view introduces ideas possible position automatic test cases generator life cycle 
conclude subject believe test generator specifications discussed wide ranging entire life cycle systems just unit level assumed 
experience re enforce view 
data type transformations test system specification need address problem transform test inputs generated specification test data suitable initialising system test order execute 
similarly test results transformed implementation form vdm sl form exercise oracle 
problem emerges high level data types implementation concrete data types may internal structure 
example vdm sl integer type may certainly match integer type target language system test certainly case vdm sl sets 
set data usually represented arrays 
note problem absent testing system level interface refined specification problematic expect problem 
problem akin encountered verifying specifications retrieval functions provided concrete data types 
aspect described jones 
addresses problem formal point view 
explicit need data type transformation clarify potential extra required human tester illustrate problem set data type chosen concrete data type array 
consider vdm sl set input concrete representations 
implementation level representations available vdm sl data 
set representation impose order elements specification behaviour system test representation 
may case requirement needs tested 
test result form unique representation vdm sl set 
transformations specified vdm sl 
allow atg generate multiple test data vdm sl test input 
transformations specified human tester im 
mask original errors undetectable performing tests generated system test performed adequately 
incorrect implementation transformations required create undue apparent inconsistencies system test 
specification involves high level data types sets maps suggest transformation functions provided specification test system thoroughly intended behaviour reduce amount imposed human tester eliminate risk introducing undue errors 
point mention ubiquity floats implemented programming languages 
vdm sl type real defined mathematical sense 
real vdm sl representable floats 
suggests transformation vdm sl reals implementation language floats straight forward 
problem relates precision testing area considered formal specification point view 
instantiation consistency checking implicitly far mentioned availability solver perform consistency checking vdm sl expressions generated partitioning forming core oracle 
need sample classes partition obtain set tests 
consider simple vdm sl expression part larger implicit operation specification expression replaced semantically identical expression 
bad style specification writing ignored 
furthermore property null specification arise implicitly 
partition original expression consistency checking obtain equivalence classes classes obtained partitioning 
classes inconsistent trying sample instantiation 
needs detected relying exhaustive search inefficient possible perform finite domain input output variables 
note entire partition generated consistency checking may large partition classes inconsistent 
envisage checking partition consistency step construction order avoid problems relating size partition generated 
moment techniques tools available consistency checking generating unique solution required 
clarify ideas giving series definitions 
recall mathematical definition partition previous chapter definition domain predicate partition set definition domain subsets formally called equivalence classes nonempty disjoint union 
express equivalence classes vdm sl predicates specify value part subset 
definition constraint constraint represented predicate domain variables 
definition domain variable domain variable pair variable symbol finite set called domain variable 
vdm sl variables domain variables definition domain finite 
view vdm sl predicate constraint vice versa represent constraint vdm sl variables vdm sl predicates 
terminology interchangeable 
definition satisfaction solution set variable instantiations satisfies associated predicate true interpretation 
set variable instantiations called solution 
definition consistency predicate consistent associated constraint satisfiable 
definition constraint satisfaction problem constraint satisfaction problem csp set constraints 
solution csp satisfy constraint csp 
relations vdm sl predicates constraints sets solutions justify flexible terminology 
example equivalence class viewed set values predicate constraint 
differentiate problem difficult problem automatic theorem proving 
view equivalence class expressed vdm sl predicates set solutions associated csp 
definition consistency checking consistency checking class process determining existence solution associated csp 
solution exists class consistent satisfiable inconsistent unsatisfiable denotes empty set part partition 
definition sampling sampling consistent class process finding solution sample associated csp 
definition solver solver automatic tool determine existence solutions csps find solution 
sections review techniques available implementing solvers domain 
constraint satisfaction problems constraint satisfaction problems informal csps refer general np complete simple generate test strategy solution candidate generated tested system constraints consistency tractable 
constraint satisfaction problems long researched artificial intelligence heuristics efficient search techniques 
example linear rational constraints constraints expressed linear arithmetic predicates rational numbers solved known simplex method 
linear arithmetic predicates built relational operators expressions composed numbers variables basic arithmetic operators gamma 
linearity property satisfied multiplication operands variable division denominator number 
implement kind solver require implement heuristics writing specialised program procedural language 
heuristics readily available approach require substantial amount effort resulting program hard maintain modify extend 
ideally concentrate interested problem combining heuristics achieve goal implementing internal mechanism individual heuristic search technique 
advantages logic programming mainly form prolog programming language procedural programming long recognised easily separated prolog order predicate logic built sld resolution computation mechanism 
prolog relative poor efficiency compared procedural languages hindered general acceptance 
csps prolog language choice 
searches built depth search procedure backtracking facilities 
area prolog suffers general lack facilities express complex relationships objects terms semantics objects explicitly coded term 
cause perceived poor mathematical handling capabilities prolog compared facilities instantiated mathematics dealt readily 
basic depth strategy tends lead generate test approach problems specialised heuristics implemented prune search space 
constraint logic programming constraint logic programming clp introduced jaffar lassez reviewed colmerauer discussed alleviates short falls providing richer data structures constraints expressed constraint resolution mechanisms known decision procedure reduce search space 
decision procedure incomplete example nonlinear arithmetic constraints problematic constraints suspended delayed linear 
nonlinear arithmetic constraints linear variable instantiated bound 
happen constraints added system constraints considered labeling 
labeling mechanism constrains system constraints strategy viewed process assumptions system constraints consideration 
powerful mechanism awake delayed constraints generate solution known satisfiable system constraints 
labeling strategies critical efficiency solver 
discussion constraint satisfaction clp 
example prolog equality results failure prolog equality holds syntactically identical terms just variable particular type 
clp language possible code semantics constrain holds 
constraint resolution mechanism detect constraint nonlinear reduce follows delayed system constraints satisfiable subject consideration delayed constraints simplified version internally held 
labeling strategy impose constraints satisfiability system constraints confirmed 
efficient strategy select sampled 
sampling strategy instantiate say simplifying delayed constraint 
constraint delayed 
labeling strategy attempts instantiate repeatedly success failure occurs entire definition domain induces backtracking traditional logic programming manner 
eventually instantiated value say reducing constraint store delayed labeling mechanism attempts awake delayed constraint achieved instantiating value 
eventually instantiated system constraints declared satisfiable sample say available 
succeed labeling strategy generated thousands initial domain variables order futile assumptions 
efficient labeling strategy recognise variable linearity delayed constraint depends attempt constrain 
value domain delayed constraint linear allowing constraint resolution mechanism underlying solver detect satisfiability directly 
awake delayed constraint solver directly yield latest labeling strategy obviously suitable case assumption yielding positive outcome 
add decisions procedure employed clp languages system constraints known satisfiable addition constraints require entire system constraints 
advantage theorem provers 
clearly clp languages ideal purpose built resolution mechanism remove needed development effort offer flexibility logic programming 
fact allow rapid development efficient dedicated solvers 
mentioned relation testing choquet 
constraint logic programming languages clp languages quite progressing fast clp languages available 
clp languages offer differ mainly constraint domains handle degree completeness resolution mechanisms 
basic requirements constraints integers real numbers boolean expressions dealt appropriately case general logic programming scheme 
example clp language cite ecl ps ecrc common logic programming system 
ecl ps generic development system designed facilitate extensions example ecl ps written hard coded usually case prolog implementations 
constraint solvers available libraries allow wide ranging experimentations examples better comprehension general clp scheme 
reservation ecl ps terms efficiency compared dedicated clp languages clp 
chip prolog iii 
solver vdm sl predicates 
systems constraints arising vdm sl specification general np complete solve problem simplified fact variables finite domain sets vdm sl finite 
need find solution satisfying system constraints set possible solutions demonstrate satisfiability generate tests 
atg dick faivre underpinned purpose built partition analysis tool labeling capabilities prolog 
integrated ecl ps clp language simplify implementation solvers certainly versatile 
example solver developed dick faivre inference rules simplification consistency checking partition classes implicit clp language 
vdm sl complex language set constraints handled instantiated sets constraint solvers exist set constraints involving arithmetic open research 
research artificial intelligence focusing adding constraints solving capabilities theorem provers 
mention attempts generating tests specifications optimisation techniques genetic algorithms simulated annealing described 
optimisation techniques constraints solving consideration match conventional solvers terms efficiency 
conventional techniques fail optimisation techniques 
fact area research ecl ps ii optimisation techniques available improve labeling conventional methods fail 
note technique probably limited performance underlying solver features vdm sl may eliminated achieve full automation human intervention required 
chapter clarified important aspects surrounding generation test cases formal specifications 
discussed length testing activity proper light tests generated vdm specifications 
choices concerning approach taken white test generation unspecified requirements consequences examined 
represents coarse design technique discussed far 
specification partition consistency report test data result output test inputs partitioning rules test cases generation result data oracle expression program execution transformation transformation oracle approach concentrate partition generation sampling techniques examine oracle considerations 
chapter systematic partitioning chapter devise basic partitioning technique necessary automatic processing formal specifications view generating test cases 
having illustrated need finer partitioning refine technique include lower level vdm sl constructs 
examples show refinements introduced valuable problematic relation number test cases generated 
partitioning vdm sl expressions suggested previous chapter may possible partition specification equivalence classes 
equivalence classes theory homogeneous respect likelihood finding error behaviour system test allowing single random sample class taken obtain test set possibly test cases 
demonstrated dick faivre straightforward partitioning rules logical expressions vdm sl control expressions 
attempts justifying technique rules 
semantic subtleties vdm sl considered 
dick faivre placed emphasis implementing prototype tool exploring fundamental issues 
attempt justify partitioning techniques formal specifications flexible new formalism allow express partitioning rules 
formalism derive partitioning rules vdm sl logical operators control constructs account subtleties semantics vdm sl 
extend rules account vdm sl valued logic 
show apply technique context vdm sl language expressions 
conclude section showing prototype built dick faivre improved tackle larger specifications 
justification attempt apply partitioning theory reviewed previous chapter mitigated applied formal specifications ignorance characterise homogeneous equivalent classes terms intrinsic formal features technical difficulties may arise attempting extract classes formal specification 
advantage taken intrinsic mathematical nature formal specifications generate partitions mathematical sense fuzzy notion homogenous classes respect likelihood finding error system test 
bearing mind left consider ad hoc techniques structure specification 
homogeneity classes may generated highly subjective 
partitioning rules introduced formal arguments kind justification emanate ad hoc practices borrowed structural testing 
claim concerning universality adequacy left assume mathematical classes homogeneous terms likelihood finding error behaviour system test 
assume isomorphism mathematical classes theoretical classes potentially misbehaving inputs 
isomorphism implicit discussion theory partitioning chapter 
ruled applying partitioning technique vdm sl statements implicit vdm sl specifications said control structure forms cases expressions resembling imperative programs 
recalling paths structural testing elucidated individually tested testing efficiency claims attached technique suggest technique applied vdm sl specifications 
control structure specifications usually far limited computer source programs number paths source program usually far greater number control classes specification counterpart thought due greater expressiveness mathematics imperative programming language constructs concern specifications express 
logical structure specifications form pre post conditions logical operators widely taken advantage similar way control structures attempting generate equivalent classes 
example expression form validated valued logic ways true false true true false true 
conditions represent logical decomposition original expression way decomposed true true false true 
propose grounds similarity extend common structural partitioning techniques logical expressions formal specifications hope improving homogeneity classes generated 
abuse language purpose terminology terms paths 
definition path expression term path expressions vdm sl expressions relate control structure specification cases expressions logical expressions expressions logical operators definition path partitioning rule path partitioning rules rules allowing generation partition path expressions 
definition path path equivalence class partition generated path expression path partitioning rule 
path infeasible class represents inconsistent 
shall denote inconsistent class 
coarse partitioning rules give path partitioning rules valued logic 
rules similar dick formal framework 
logical expressions logical expressions vdm sl built common logical operators negation disjunction conjunction implication equivalence equality inequality 
equivalence equality operators synonymous booleans inequality stands equivalent 
shall give rules negation disjunction conjunction build 
conjunctive expression give rise class possible instantiation true true 
note theta denotes partitioning function theta full combination operator 
informally full combination operator combine class partition class 
similarly negation expression path expression gives rise class false 
suggested disjunction form partitioned equivalence classes 
arises fact distinct instantiations expressions 
assuming predicates satisfiable set vdm sl predicates generated form partition ab phi phi phi exclusive operator 
example introduce justify notation partitions rest thesis 
formally set vdm sl predicates fe partition satisfiable vdm sl predicate ng delta consistent consistent predicate provided solver takes vdm sl predicate argument returns true satisfiable false 
addition empty set denoted considered represent partition inconsistent expressions 
partitioning function signature partition 
full combination operator theta defined partition theta partition partition theta fe je note partition braces denote set partitions distributed union operator applied obtain partition 
theta full partition combination performed stage wished obtain theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta path expressions fag ag performing theta operation identical fa dg fa dg fa dg fa dg fa dg fa dg dg dg dg performing distributed union obtain note classes conjunctive expressions notation changed keep notion partition set sets equivalence class denoted fe ji 
avoided retain concise notation 
rules common relationships operators equivalent obtain partitioning rules vdm sl logical operators 
fag path expression ag path expression theta path expression develop partitioning rules 
example partitioning rule conjunctive expressions equivalent theta path expressions find ab ag thetaf bg yields bg larger example sequence partitioning operations expression follows rule theta rule theta fd nog rule theta theta theta theta fd nog applying operator theta theta theta theta fd nog rule theta theta theta theta theta theta fd nog rule fx theta fy theta fx fx theta fy theta fx fx theta fy fx theta fy fx theta fy theta fx theta fd nog applying innermost theta operators fx fx fx fx fx theta fx theta fd nog applying internal distributed union fx fx theta fx theta fd nog applying internal combination operator fx fx theta fd nog applying distributed union theta fd nog applying remaining theta operator obtain final partition paths individually checked inconsistencies obtain usually equivalence classes partitions representation easily readable human say simplify predicates 
simplifications necessary performed clarity 
gammay gammay shall give details intermediary steps partition derivation 
control expressions consider composite vdm sl expressions cases expressions 
expressions form expression expression expression expression expression elseif expression clause elseif expression expression simple expression form partitioned generally elseif 
elseif gives rise partition 
delta delta delta gamma delta delta delta cases expressions form cases expression cases expression expression choice list expression choice expression choice list expression choice expression expression choice pattern list expression expression choice expression expression cases 
nm partitioning rule devised bind pt bind pt bind bind bind bind 
bind bind delta delta delta bind gamma bind gamma gamma bind bind nm bind bind bind bind nm bind semantically equivalent vdm sl binding function bind equivalent match 
patterns omnipresent vdm sl cases quantified comprehension expressions 
matching binding process described considerations 
forms binds set binds type binds pattern forms 
examples ffl set bind identifier pattern ffl mk gammat type bind record pattern identifier pattern don care pattern ffl fm ng set bind set enumeration pattern ffl mk gamma theta type bind tuple pattern ffl ff gg set bind set union pattern ffl set bind sequence enumeration pattern ffl set bind sequence concatenation pattern matching subsequent binding processes subtle semantics :10.1.1.104.4138
potentially set enumeration set union sequence patterns behave non deterministically introduce looseness expressions expressions evaluation process yields possible outcomes 
example pattern matched set yields bindings 

loose expressions notoriously difficult reason 
return thesis considering ways include technique 
preserve notation developed far exclude set constructs partitioning rules apply bindings introduce looseness 
note totally exclude patterns mentioned example tl introduce looseness :10.1.1.104.4138
recognition bindings loose may straightforward feasible automatically 
return partitioning case expressions noting takes account non deterministic choice matches pattern expression choice 
conclude formalism clearly shows partitioning rules far mechanically combined 
performed dedicated parser 
particular areas difficulty consider ffl fact vdm sl valued logic lpf logic partial functions 
ffl path expressions non path expressions valued logic lpf consequences vdm sl valued logic 
ignore effect lpf expressions partitions generated incomplete 
consider example partitioned yields phi original expression 
semantics operator undefined undefined semantics vdm sl expressions satisfied 
partition expressions evaluate undefined satisfiable 
test input generated randomly classes satisfy expressions 
incompleteness dire consequences 
consider piece specification expression yields empty partition tested technique 
specifications lpf effect semantics testing implementation specification highly desirable test effects rarely obvious reading specification comments highlight benefit reader instances undefined expressions intended may carry risk overlooked misinterpreted 
feel compelled test effects 
example rule simplest form denotes undefinedness satisfied undefined 
theta theta theta theta theta theta theta theta partitioning rules modified vdm sl valued logic similar way 
give truth tables vdm sl logical operators 
lpf introduce extra testing requirements feel taken account incompleteness lower test set quality accepted 
slightly complex process automated operator definition input domain defined vdm sl semantics 
table lpf truth table logical operators example divide operator undefined operands number type denominator equals 
principle holds map application example map element domain map map 
tractability point view behaviour lpf specifications induces paths specifications 
paths infeasible common specification writing style assumed 
supposes specification correctly models intended behaviour system kind annotation indicate places lpf induce different behaviour specification restrict extended partitioning rules instances 
greatly reduce number expressions check consistency 
annotations absent unreliable object test specification left doubts necessity extra effort required 
embedded path expressions definition embedded path expression call embedded path expressions path expressions contained non path expression 
example path expression contained embedded partitioned directly rules far 
leave expressions intact partitioning process testing achieve great coverage potential behaviour 
internal embedded expression subject partitioning rules 
expression semantics internal expression brought fore 
apply previous partitioning rules obtain refined partition case ad hoc partitioning rules improve homogeneity classes generated 
expression thought simple shorthand second expression 
technique bringing path expressions fore applicable 
example scope quantified expressions delta semantically equivalent delta delta 
delta equivalent delta delta 
expression form bind delta partitioned bind delta bind delta bind delta bind delta bind delta bind delta equivalence bind delta bind delta bind delta 
may stretching notion paths specifications far 
importantly subtle semantics vdm sl respect testing may lost approach interesting test cases elucidated 
example classes revealed bind delta bind delta bind delta bind delta 
problem arises vdm sl expressions containing embedded path expressions 
fact local scope introduced bringing path expressions fore directly feasible 
vdm sl constructs introduce local scope quantified expressions sequence set map comprehension expressions 
definition scoping expression term scoping expressions designate quantified expressions sequence set map comprehension expressions 
decide path expressions brought fore non scoping expressions 
solves dilemma having specify constructs path expressions brought fore expression existential quantified expression universal quantified expression 
compromise potential extensive behaviour coverage scoping expressions 
technique developed far leaves vdm sl constructs introduce variable scoping intact partitions 
scoping constructs considered chapter 
implementation considerations having extended basic partitioning rules dick faivre ask tool implementation withstand generalisation 
leaving consistency checking apart feel discussed previous chapter constraint programming offers best potential dick faivre tool simple prolog generation rules 
replaced notation extended rule just easily automatically generated rules simple syntactic manipulations 
implementation tool generate extended partitions feasible 
dick faivre tool described process large specifications generate numerous large expressions 
address aspect final partitions potentially larger due treatment lpf shall see partition refining technique 
annotations proposed reviewing lpf behaviour constructs extended cover non deterministic choices case constructs reduce size intermediate partitions final 
advocates reducing vdm sl specification disjunctive normal form dnf prior partition generation rules 
example post condition max operation operands form max max max max reduced dnf distributing obtain max max max max max max generation rule applied get max max max max max max max max max max max max simplified max max max max max max dnf reduction acknowledged dick faivre generate large intermediate expressions 
rule performed larger expressions original expression manual derivation rule clearly show lead long manipulations large expressions numerous extra consistency checks 
studying partitioning process formalism clearly see dnf reduction superfluous 
partition post condition max directly follows fmax max bg fmax max bg fmax max bg fmax max max max bg theta fmax max bg processed equal max max max max max max max max undefined 
need explicit dnf reduction intrinsic part partitioning process classes generated conjunctions non path expressions construction mutually exclusive complete 
way proceeding considerably computationally intensive 
dick faivre tool partition generated purely syntactic rules partitioning rules purely syntactic symbolic manipulations required dnf expression 
path partition checked individual satisfiability 
conclude partitions potentially larger generated dick faivre tool take account lpf behaviour specifications readily generated 
shortcomings technique lie implementability problems fundamental issue specification behaviour coverage 
refinements test generation technique far dick faivre 
having extended results need address acknowledged problem simple logical partitioning classes generated coarse comparison manually generated classes tests 
illustrate problem address 
partitioning coarse 
far evaluation technique 
triangle problem introduced previous chapter suffice illustrate inadequacy 
evaluate technique compare north test set triangle problem deemed adequate dick faivre automatically generated tests 
technique described far similar dick faivre 
north manually derived test cases recommendations myers triangle problem dick faivre tool generates classes illustrated single random sample taken 
tests automatically generated north equivalent table listed table 
test input oracle north ref 
scalene isosceles isosceles isosceles equilateral invalid invalid invalid table dick faivre test cases triangle problem automatically generated tests represented north test set encouraging 
considered north test set adequate triangle problem large number missing tests difficult accommodate 
example north deems necessary manually derive tests cover invalid outcome automatically generated current technique 
tests said test requirement sequence integers length arguable 
missing tests due absence permutations sequence integers isosceles scalene triangles 
boundary values covered tool 
omission mentioned issue discussed 
boundary value generation perfectly implemented tests missing 
extended partitioning technique substantially improve quality coverage lpf plays limited role north specification triangle problem 
conclude classes generated far homogenous coarse allow elucidation interesting tests single random sampling 
hinted trying tackle vdm sl scoping constructs technique apply 
stocks remarked implicit dick faivre standard approach specification testing reduce specification disjunctive normal form choose inputs satisfying preconditions disjunct 
tends simplistic model specifications generally quite flat specification languages powerful operators built notation hide complexity input domain disjunctive normal form transformation 
semantics operators generate adequate test sets 
simple way illustrate problem consider expression natural number 
currently expression partitioned representing equivalence class single test generated random sampling say 
case equivalence classes generated consistency checking random sampling tests generated say 
obviously gives greater coverage semantics expression 
expressions semantically equivalent feel partition generated directly 
flatness specifications caused example large conjunctions non path expressions raises concern potentially lead generation partition consisting single equivalence class representing entire specification 
decide resolve problem randomly sample equivalence class number times 
admitting defeat constitute ultimate recognition classes non homogeneous 
furthermore coverage difficult achieve randomly generate take unknown usually large number tries 
better try refine partition information encapsulated vdm sl complex operators scoping constructs 
illustrate achieved 
partitioning expressions non logical operators seen expression constructed basic operators need partitioned 
example assuming real partition may obvious partition theoretically valid ultimate choice partitioning rules informal notion likelihood finding error system test 
robust arguments justify partition choices 
attempt possible 
consider reasonable partition simply fx 
test boundary conditions partition ffi ffi ffi smallest increment type integers ffi reals ffi specified requested precision real variables suitable 
integers test certainly potential reveal errors real variables partition thought enclosing tests precision testing 
simple operators choice reasonable partitioning rule large ultimately rest degree test quality requested 
partitioning rules expressions composed basic vdm sl operators conventions 
expressions partitioning rules basic conventions partitioning technique 
example obtain justified partitioning rule expressions form start basic equivalence assumed integers theta theta theta simplifications stocks carrington framework specification testing purpose language 
discuss test derivation test oracle regression testing test suites 
interested informal partitioning expressions constructed binary operators 
note discuss automation coverage tests derivation formal specification limited 
give table informal domain division expressions set union operator sub domain rectified correct version expected outcome 
divisions justified 
note predicates form partition expression satisfiable mutually exclusive disjunction equivalent 
give informal justification drawing venn diagrams obtained expression form ref 
domain division fg fg fg fg fg fg fg fg fg fg fg fg ae fg fg ae fg fg fg fg fg ae ae table stocks domain division give diagram equivalent informal derivation 
venn diagrams partition see expressions involving basic operators partitioned 
problems discussed stocks carrington expressions constructed basic operators partitioned 
allow partitioning expressions form example 
example theta theta abs abs abs abs abs abs theta fr yg partition highly subjective may pointless generate complex partition simple expressions 
argued equivalence classes containing constraint gammay value 
certainly expressions containing complex arithmetic operators mod rem partitioning performed likelihood confusion 
keep formalism path expressions partitioning change terminology differentiate equivalence classes generated non path expressions 
definition sub domain sub domain equivalence class partition generated non path expression non path partitioning rule 
conclude partitioning basic expressions noting ffl different partitions expression generated 
ffl basic choices informally justified likelihood error detection subjective 
ffl formalism developed coarse partitioning re non path expressions partitioning 
area discussed dick faivre stocks carrington partitioning scoping expressions 
scoping expressions omnipresent formal languages certainly left partitioning specifications simply give rise complex classes single class entire specification consideration example large quantified expression 
partitioning scoping expressions recall scoping expressions vdm sl take forms quantified expressions sequence set map comprehension expressions 
difficult manipulate complexity semantics 
illustrate approach considering set comprehension expressions quantified expressions identify problematic areas concerning semantics 
quantified expressions show quantified expressions partitioned sub domains 
existential quantified expression form delta expression universal quantified expression delta expression 
simplicity consider cases binding expression form binding possible existential quantified expression evaluates false universal quantified expression evaluates true 
lpf quantified expressions needs highlighted 
informally existential quantified expression undefined binding evaluates true binding evaluates undefined 
universally quantified expression undefined binding evaluates false bindings evaluating true undefined 
binding process undefined quantified expressions evaluate undefined 
formally propose delta exp delta exp theta delta exp delta exp delta exp theta delta exp consider delta exp 
exp fc propose delta exp fg theta delta exp delta exp phi exp theta delta delta theta theta delta delta stems delta exp delta exp phi delta exp delta exp phi exp delta exp delta delta delta delta delta delta delta delta delta 
propose delta exp fg delta exp theta delta delta theta theta delta delta obtain rule 
lpf behaviour disabled course rules considerably easier manipulate 
easily show delta exp exp equal fg fg theta delta exp delta exp exp equal fg theta delta exp delta exp theta delta exp conforms intuition example non empty set integers delta delta 
partitioning quantified expressions result large number classes partitions generated shown adequate 
example consider delta 
partition theta theta theta valued logic 
limit example valued logic assume inconsistent 
assume path expressions fag fbg 
short form expression delta expression similarly existential quantifier 
partition final simplification consistency checking equal list table resulting classes final simplification 
ref 
domain division table domain division binds delta illustrate results venn diagrams considering sets set variable tuples expression evaluates true similarly set shown 
venn diagrams partition binds delta partitioning total partitioning feasible level 
apply quantified expressions rules leads long partition derivation basic quantified expressions 
unique quantified expressions form 
delta expression study offers insight semantics vdm sl particularly relation looseness 
classic mathematics equivalences form fa cg delta fa cg delta fa cg delta hold 
partitioning rule unique quantifier derived existential universal quantifiers rules 
loose expressions seen considering pattern matching lead complex expressions allowed behaviours 
circumstances straightforward establish veracity equivalence 
vdm sl standard provides example complex unique quantified expression unique ff gg delta elems elems expression shown done standard evaluate unique true expression globally loose internally looseness level mirror iota expression iota expression evaluates unique binding unique existential expression true evaluated yields different values :10.1.1.104.4138
loose expressions lead surprising non intuitive results efforts evaluate complex expressions proof theorems higher degree complexity 
rely equivalence circumstances proof established 
argued complex examples find way real specifications envisage identify automatically easy define safe vdm sl subset allows pattern forms looseness arises complex expression allowed grounds introduce looseness global level 
argued allow degree complexity specifications hinders development formal methods support tools formal methods 
discussion reinforces decision exclude patterns may introduce looseness set enumeration set union sequence patterns 
clear example expressions form st excluded 
thesis return loose expressions attempt accommodate 
restrictions equivalence unique existential expressions holds generate partition 
set comprehension expressions set comprehension expressions form expression bind list expression approach partitioning sub domains set comprehension expressions model sequence map comprehension expressions partitioning semantics syntax similar 
consider ff jx delta set empty expression equivalent delta propose ff jx delta equal fg theta fgg fg theta delta theta fgg fg theta delta theta delta theta sg example consider map comprehension fa 
ja dom map set 
note absent considered true 
agree partition new operators dom 

tmp theta tmp theta fp tmp 
tmp dom tmp fg tmp dom tmp theta tmp ne tmp fg tmp fg fg tmp fg tmp fg tmp tmp fg tmp fg fg tmp fg tmp fg tmp tmp fg tmp tmp fg tmp fg tmp ae tmp fg tmp fg tmp fg tmp ae tmp tmp tmp fg tmp fg tmp tmp fg tmp fg tmp fg tmp tmp fg tmp ae tmp tmp ae tmp tmp tmp tmp thetap tmp theta tmp note sub domains set difference subdomains 
proceed partitioning fa 
ja dom dom ns fg theta gg dom ns fg theta dom ns delta true theta gg dom ns fg theta dom ns delta trueg theta dom ns delta true 
theta tg partition expression concerns case map comprehension empty dom ns empty 
dom ns fg theta gg equal fg fg fg dom ae fg dom dom ns delta true equivalent 
inconsistent dom ns fg dom ns delta true second partition expression evaluates concentrate partition expression 
dom ns delta trueg equivalent context ftrueg 
need consider dom ns fg theta dom ns delta 
theta tg 
fa 
tg dom ns delta 
amounts dom ns delta 
tg context 
left dom ns fg theta dom ns delta 
tg evaluated simplified equal fa 
ja dom fg fa 
ja dom fg dom fg fa 
ja dom fg ae dom fa 
ja dom fg dom ae ae dom dom similar generation performed set sequence comprehension expressions 
simplifications straightforward derivations large 
illustrate coarse partitioning rules corresponding logical control vdm sl constructs combined finer partitioning rules vdm sl scoping expressions simple expressions built operators 
direct synthesis previous sections discussed extended major results dick faivre coarse partitioning stock carrington finer partitioning 
main contributions consist ffl informal justification coarse partitioning ffl extended coarse partitioning rules ffl showing limitation coarse partitioning ffl showing dick faivre prototype improved ffl informal justification basic finer partitioning rules expressions set union operator ffl finer partitioning rules scoping expressions ffl formalism suitable activities highlighting mechanical nature partition generation formalism developed allows directly synthesize coarse finer partitioning 
examine potential quality test classes generated 
systematic formal partitioning having formal partitioning rules basic vdm sl constructs apply short example combining logical mapping operators illustrate continuity partitioning process coarse finer partitioning 
consider expression dom coarse partition dom cm theta 
decompose dom cm dom dd cm definition domain restriction operator fa 
ja dom generated partition previous example find dom cm equal fg fg fg dom ae fg dom fa 
ja dom fg fa 
ja dom fg dom fg fa 
ja dom fg ae dom fa 
ja dom fg dom ae ae dom dom theta fg dom combination consistency checking equivalent dom ae dom dom dom fa 
ja dom fa 
ja dom dom dom fg fa 
ja dom dom ae dom fa 
ja dom dom ae dom dom ae dom dom dom partitioning map merge expression equivalent dom dom dom theta ng re set union partitioning rule table 
simplify derivation note example dom dom fg 
equal dom fg dom fg dom fg dom fg dom fg dom fg dom fg dom fg dom dom fg dom equal dom ae dom dom dom fa 
ja dom fa 
ja dom dom dom fg fa 
ja dom dom ae dom fa 
ja dom dom ae dom dom ae dom dom dom see coarse partitioning finer partitioning combined generate finer partitions 
expression dom cm definition map override operator partition generated directly justified partitioning rule expressions 
example shows basic partitioning rules complex expressions systematically sound partitioning rule 
course implies direct partitioning rules vdm sl constructs decomposition process performed repeated 
stock carrington informally derive partition similar map override operator decomposition process informal basic partitioning rules applied 
partition equivalence class dom ae dom appear explicitly 
difference arises informal partition expressions domain restriction operator decomposing expression map comprehension expression developed partitioning rule 
consequence desirable test dom ae dom generated partition 
believe partition homogeneous single random sample taken equivalence class 
partition covers semantics expressions map override operator eventual test set increased adequacy 
combinatorial explosion process informally partitioning basic expressions coarse partitioning criticised attempt reconcile coarse finer partitioning 
seen direct synthesis formalism appropriate expressions 
example partition operator may large justified informally terms likelihood finding error system test venn diagrams necessary 
direct synthesis allows systematic generation compact partitions satisfied result concentrate implementation matters crucial technique 
note expressions number classes generated explodes justification individual test say dubious 
example expression part input validation specification example partitioned lpf behaviour disabled follows theta theta theta theta theta theta theta generate sub domains non path expressions indiscriminately obtain set classes total equivalence classes gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma clearly exhaustive partitioning generate tests compared normal testing practices 
add example illustrate explosion number classes generated considering expression integers lpf plays role semantics expression 
systematic partitioning expression leads classes gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma partition generated thetap contain redundant equivalence classes classes tests better random tests ad hoc testing practices generated 
caused full combination operator systematically combines equivalence classes operands 
ad hoc testing principles probably lead partition gamma gamma course partitions see chapter latest partition encompass previous partition 
course partitioning convention relaxed environment deemed domain coverage complete 
lead smaller test set 
knowledge particular system tested partitioning conventions difficult simplify 
need modify conventions partitioning process circumstances able generate adequate test sets state art testing practices 
chapter pursued development complete partitioning technique acknowledge test sets generated adequate 
chapter devoted identifying circumstances technique suitable developing justified appropriate approach 
chapter sensible tests generation show systematic partitioning vdm sl specifications previous chapter lead large test sets difficult reconcile aim finding maximum number errors system test minimum number tests 
lead find heuristics identification redundant equivalence classes 
argue adoption heuristics results small loss coverage behaviour specification leads justifiable compromise degree coverage size test sets generated 
extend formalism introduced far illustrate arguments 
controlling partitioning remarked previous chapter systematic partitioning expressions generate equivalence classes necessary sample testing point view 
partitioning extended non path expressions systematic partitioning technique uniquely reconciles coarse finer partitioning achieve complete uniform coverage specifications combinatorial explosion classes observed 
partitioning technique specifications far complete uniform simply extended previous results area integrated unique procedure blindly taken partitioning logical 
faced explosion classes generated attempt mitigate results re examining impact probability revealing error system test hope finding ways reducing number tests generated impairing quality test sets produced 
reluctant dismiss hand partitioning theory applied software testing absence alternatives realise ways identify redundant classes restore confidence practicability approach 
large test sets systematically generated simplest expressions mapping individual tests ad hoc justifications broken value technique justifiably judged worthless impracticable 
explosion number classes generated exacerbated partitioning rules non path expressions 
partitioning non path expressions disallowed case dick faivre approach geometric growth number classes generated observed specifications 
example expression partitioning non path expressions gives rise partition practice beizer sub domains attached case need systematically combined boundaries orthogonal 
orthogonality domain testing discussed discussion limited variables 
attempt justifying practice limiting combination sub domains circumstances 
combinations limited set classes obtained sampling cover original sub domains minimal number tests 
note set classes amount partition original expression disjunction equivalent 
predicate classes selected original final partition 
theoretical weyuker zhu give indications reduce number classes generated impairing adequacy shed light ad hoc practice beizer justifiable respect likelihood finding error system test 
beizer indication circumstances sub domains need systematically combined relevance 
criteria relevant formal expressions indicate systematic partitioning necessary minimal cover domains sufficient reduce number classes generated impairing quality test set produced 
set find criteria 
context dependent combination re examine previous chapter expression corresponding partition gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma arising operator partitioning rule 
reason classes generated redundant subsequent test set examined individual test justification difficult due independence variables expression analysed independent value variables affects constrain value 
sub domains attached defined predicates involving functions similarly intuitively need exhaustively combine sub domains generated variable separate expressions constrain 
fact independence sub domains implies orthogonality notion discussed beizer relation software testing 
respect convention expressions involving operator set classes gamma gamma sufficient test expression sub domains generated original partition represented set classes 
similar sets classes 
point view deem potential test sets equivalent probability finding error system test equal 
similar considering redundant test reveal error implementation random test tests deem redundant eliminated final test set 
note set classes amount partition mathematical sense definition original expression 
call elements sets classes origin 
reduce number classes specifications embedded function calls 
suppose function specification implemented independently subprogram remarks ffl behaviour implemented needs covered case calls classes generated eliminated 
ffl dependence sub domains local function call dependent calling context dependence implied generating classes vice versa dependent implied calling environment 
general function specification considered independent rest specification 
example triangle problem sum implementation 
function fulfils role sum implemented knowledge specification surely taken account implement said sum implementation models sum specification sum independent rest specification 
knowledge implementation judgement functions implemented independently lead large reductions number classes 
example partitioning leads classes expression covered minimal number classes 
treatment function calls important consequences quantified expressions 
recall previous chapter expression form delta convention lead set classes denoted fg fx greater 
independent rest implementation sub domains delta entirely covered classes fg illustrate consequences context dependent combinations justify intuitive notion identify circumstances applied 
rationale context dependent combination give definition variable dependence 
definition dependence variables dependent specification exists non path expression variables appear 
mitigated independently implemented functions discussed previous section 
dependence relation commutative associative 
extension talk dependence sub domains 
clarity give definitions definition final partition final partition partition obtained systematic partitioning process described chapter definition cover set dependent sub domains equivalence classes final partition covered class class part final partition set dependent sub domain class 
definition minimal set classes set classes minimal ffl composed classes final partition ffl covers dependent sub domains final partition ffl exist smaller set classes final partition properties valid 
case final partition minimal set classes candidates 
set classes chosen sampling 
definition redundant class redundant class element final partition element minimal set classes chosen 
shall formalise definitions 
justify minimal set classes 
conjunction independent predicates representing independent domains partitioned sub domains equivalence classes forming final partition argue selection classes aimed covering dependent sub domains minimal set classes sampled probability revealing error underlying implementation original set tests generated final partition 
basic probability laws demonstrate 
feel explanation necessary reveal underlying assumption possible consequences way testing performed probabilities surely underpin rationale testing strategy absolute value probability finding error particular application domain usually unknown 
content rely notion orthogonality sub domains 
domain representing various dependent variables 
domain representing various dependent variables 
suppose independent 
fa fb partitions generated technique domains respectively 
space choose probabilistic event denote presence error domain 
example denotes probability implementation respect specification input variable 
theory partitioning sub domains homogenous probability sub domain contains input respect specification tested unique sample domain 
words sample sub domain needs taken subsequently tested detect error belonging sub domain 
probability sub domain contains input cause erroneous behaviour implementation respect specification equal probability single random test sample taken sub domain reveal erroneous behaviour 
rationale partitioning testing 
basic law probability theory gamma 
recall domain divisions constitute partition similarly 
basic probability law find ai gamma gamma intersections kind empty family partition sub domains disjoint 
intersections forms empty disjoint independent denotes probability error implementation belongs 
probability event occuring empty set null knowing probability error particular domain write domains independent 
covering thetab cartesian product yield probability finding error 
example implies need select sub domains example take single sample combination perform tests obtain maximum likelihood revealing error underlying implementation 
performing test say increase chances finding error 
demonstrated assuming domains independent combination partitions just find error underlying implementation exhaustive combination 
contrast domains dependent say need sample intersection sub domain probability empty domain events law jd jd denotes probability error implementation input domain lies 
fact demonstrates need full combination dependent sub domains 
overlooked implicit assumption justifying technique independence domains specification level preserved implementation level 
possible say domains independent specification implementation case implementation probably erroneous 
practice independence domains preserved 
remarks justify assumption 
logical point view domains separate specification difficult envisage correct implementation independence domains 
usually clear specification point view variables constrain interfere implementation written specification dichotomy clear developer normally occur 
possible implementation independence variables 
consider predicate specification independent implementation extraneous constraint emerge 
error detected considered domains dependent specification case implementation 
important stress cases assumption invalid full combination alternative context dependent combination just reveal error underlying implementation 
conclude matter example shows benefit correctness point view investigate instances independence variables specification implementation 
outside scope points static data flow analysis programs specification see example 
function calls functions implemented independently rest system deemed implemented independently rest system implemented function model specification 
case sum implementation able deal sequence natural numbers specification knowledge implementation judgement considered shorthand notation test generation purpose 
cases partitioning function performed partition obtained simply replaces function call consequences minimum coverage specification 
envisaged specification implementation closer enhance testability system 
net effect context dependent combination allow reduce size test sets assumptions reducing quality test sets generated 
notation section investigate various techniques construct test sets 
denote sub domain belonging particular group dependency lower alphabetical letter 
theta denote earlier example representing constructing test sets initial approaches implicitly far taken approach systematically generating final partition identifying redundant classes obtain minimal set classes 
section attempt reduce size set classes generated performing partitioning consistency checking combining sub domains context dependent combination principle analysing expressions 
attempt fact minimum coverage sub domains specification achieved theta partition expressions systematic combination sub domains dependent classes 
extract specification exp exp exp exp construct directly set classes inter dependence apparent operand operator 
performing combination sub domains revealed partitioning predicates exp exp far independent specification violates rule dependent sub domains exhaustively combined 
issue deserves investigated sub domain dependence restricted paths specification enhancing potential test set size reduction 
example expression paths exp exp exp exp exp exp exp exp dependence sub domains appear envisaged path combination performed basis 
amount defining sub domain dependence path wide scope specification wide 
decided reject temptation define sub domain dependence specification wide property restrictions called functions mentioned 
feel domain dependence path level preserved implementation logical paths specification preserved implementation 
purely pessimistic decision reversed cases knowledge implementation available 
examine approaches obtain minimal set classes respecting criteria 
sections assume means determine dependence sub domains generated 
simplicity consider function calls 
naive approach assuming partitioning skeleton form theta theta theta theta theta unsatisfiable expressions proceed doing local combinations partitioning expressions 
example having generated theta combine sub domains obtain local consistency checking 
similarly having generated theta expression form exp exp non path expressions reveal sub domains obtain performing distributed unions partition theta theta theta performing combination yields theta theta consistency checks performed combination occurs sub classes eliminated minimising subsequent amount effort 
combination performed independent domains long sub domains covered combination valid theta minimal set classes 
expressions approach partial combinations general performed total combinations completed checked satisfiability 
example naive construction test set expression form exp exp exp follows exp exp exp exp exp theta exp exp exp exp theta exp say exp exp exp exp example sub domains independent combination valid 
obtain exp exp exp theta exp exp yield unfortunately unsatisfiable classes sub domain covered set classes inadequate 
test set adequate circumstances done perform partial combination unnecessarily committing unsure global satisfiability intermediate classes 
better delay partial combinations certain potential classes generated far satisfiable 
naive approach combinations performed soon sub domains generated inadequate 
partial combinations performed immediately wait combinations dependent sub domains performed checked consistency 
graphs proposal graphs stems fact partitioning expressions represented graphs may offer efficient way generate test sets 
example partitioning expression theta theta underlying partition expression exp exp exp analysed previous section represented directed graph vertices represent sub domains arcs possible combinations 
simple partitioning graph way perform combinations dependent sub domains regroup dependent sub domains singleton vertices find minimal terms number classes necessary cover graph 
process challenging difficult 
way get closer solution transform graph vertices dependent set variables adjacent merging straightforward 
partitioning expressions complex subsequent graph difficult manipulate 
example consider partitioning expression theta theta theta theta theta theta dependency sub domains denoted difficult find general solution merging vertices problem 
merging dependent vertices particular manipulation intermediate sub paths dependent vertices problematic 
illustration purposes graph corresponding partitioning expression associated graph merged vertices 
assuming combinations performed satisfiable recalling remaining sub domains disjoint assumed independent minimal path covering algorithm applied obtain example set paths complex graph deeper study graph theory may rewarded efficient general algorithmic solution problem especially study bipartite graphs set covers abandoned particular approach complexity 
pursue approach need consider function calls case multiple calls introduce cycles graphs 
return initial approach final partition generated systematic approach minimal set classes identified systematic test cases generation seen previous section discovering algorithm direct construction minimal set classes straightforward anticipated 
algorithm generation test sets 
algorithm systematic partitioning technique previous chapter redundancy analysis phase detect eliminate redundant classes partition obtain minimal set classes merging dependent vertices complex graph suitable sampling 
highlight relation syntax vdm sl expressions partitioning concept parsing 
parsing parser program recognising sentences particular language performing actions 
parsing principally compiler technology best explained example 
need description syntax language parsed 
give syntax similar fashion commonly backus naur form notation 
eventually vdm sl syntax illustrate principle parsing small language 
syntax series production rules assign variable exp exp number exp exp exp exp exp gamma exp exp exp exp exp exp exp exp exp rules specify assign sentence composed variable followed symbol followed exp sentence defined grammar 
exp sentence alternatives listed 
seen exp sentence recursively defined 
grammar number terminal syntax rule exp non terminal defined grammar 
language expressions valid gamma 
expressions non valid grammar parser generator program converting grammatical specification language parser parse sentences language performing actions 
actions performed added syntax rules 
example calculate value right hand side actions noted square brackets assign variable exp print exp number exp exp exp exp exp gamma exp gamma exp exp exp exp exp exp exp exp values attached non terminals terminals 
denotes value returned syntax rule value attached left non terminal rule 
right hand side syntax rule value non terminal terminal denoted second value particular notation simplification notation yacc parser generator distributed unix 
parser generated rules behave appropriately precedence associativity operators taken account 
explain notations available specifying precedence associativity operators ensuring correct rule applied case alternatives 
ensures parser generated deterministic 
notation specify parsers 
syntax rules need transformed particular input format parser generator adopted 
note transformations straightforward complex language vdm sl effort involved underestimated 
give partitioning rule syntax rules 
show formalism far mapped syntax rules order underline algorithmic nature technique 
parsing rules difficult manipulate partitioning rules previously notation 
merit clearly linking partitioning process syntax vdm sl 
assume specification input correct syntax checking 
algorithm overview phase establish dependency relations variables specification 
second phase consists generating final partition specification 
partition composed classes associated dependency information represented labels 
third phase perform redundancy analysis final partition detect eliminate redundant classes 
outcome penultimate phase minimal set classes 
fourth final phase consists generating actual test cases 
performed sampling remaining class solver 
phase establishing dependencies outcome phase function getlabel vdm sl predicate return dependency label denoting dependency characteristic predicate 
proceed number steps 
step parse specification collect set sets variables appearing non path expression 
second step transformed partition variables equivalence class partition non empty set dependent variables equivalence classes mutually disjoint variable represented partition 
step set sets variables initially empty 
syntax rules denotes outer level non path expression 
simple syntax rules vdm sl syntax 
exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp exp variables appearing omitted rules example deal cases expressions second step algorithm builds partition variables dependence initial call merge 
merge set sets vars set sets vars dependence 
fg take set variables ss fs deltas dependence dependence ss ss dependence dependence ss return dependence merge equivalence class dependence partition mapped unique identifier examples chosen letter 
getlabel vdm sl expression outer level path expression getlabel returns label composed ffl unique identifier chosen letter assigned equivalence class dependence contains variables appearing expression 
identifier represents dependency characteristic expression 
ffl unique identifier chosen integer subscript particular call getlabel particular dependency characteristic 
expression contain variables returned 
examples dependency characteristics denoted lower case letters particular call denoted integer subscript 
second phase systematic partitioning labels phase vdm sl expression partitioned systematic partitioning rules previous chapter 
express rules form syntax rules suitable parser generation 
negate function need negate function return negation vdm sl expression 
negate function defined terms parser specify syntax rules 
clarity prefix syntax rules name current parser defined 
prefixes rules negate parser example vdm sl syntax conjunctive expressions exp exp exp associate action disjunction negated operands returned 
similarly rules devised exp exp exp exp exp rule illustrates express fact negation expression need negated considered terminal notation 
implicitly case simply echo expression 
aim rules necessary negation vdm sl expressions illustrate performed parsing techniques 
simple rules illustrate process 
exp exp variable false exp true false exp false true exp exp exp give simple rule 


expressions exp exp exp rule need extended general vdm sl expressions may contain elseif parts 
similarly parsing rules cases expressions need devised 
problems extending parser expressions apart length parsing rules 
conclude give parsing rules negating quantified expressions exp delta exp delta exp delta exp delta parsers partitioning keep track dependence sub domains generated partitioning non path expressions associating label getlabel function predicate representing particular sub domain 
class composed vdm sl predicate denoted pred set labels lab denoting original sub domains making class recall 
partition predicate set equivalence classes composed sub domains delta consistent pred pred theta operator theta partition theta partition theta pred pred lab lab delta consistent pred pred operator denotes usual mathematical distributed union sets 
accordance systematic partitioning technique differentiate levels partitioning 
coarse partitioning rules applied path expressions refined partitioning rules applied non path expressions 
need differentiate parsing expression want evaluate true expression needs undefined 
suffixes true undef purpose 
need define parsers coarse true coarse undef refine true refine undef 
ct cu rt ru respectively 
syntax rules part returned value denotes partition expression exp designates expression literal prior parsing 
actions produce expression literals repetitive consist expressions omit 
see syntax rules non path expression encountered coarse parser appropriate refine parser called expression generate sub domains refined partitioning rules 
coarse true parser coarse true parser relatively simple example rules logical operators ct exp exp exp part part theta part ct exp exp exp coarse true negate exp coarse true negate exp coarse undef exp coarse undef exp part part theta part part theta part part theta part part theta part part theta part latest rule calls coarse undef parser define take account potential lpf behaviour logical conjunctions 
rules simple transformations corresponding coarse partitioning rule section 
theta theta theta theta theta expressions dealt manner ct exp exp exp exp coarse true negate exp coarse undef exp part part theta part part theta part part theta part subset necessary syntax 
ct exp coarse true negate path expression parsed refine true parser 
ct exp refine true coarse undef parser similar fashion give grammatical rules coarse undef parser 
rules simple original partitioning rules 
example rules expressions logical operators checked partitioning rules previous chapter derived table detailing valued logic conventions vdm sl cu exp exp exp coarse true exp coarse true exp part part theta part part theta part part theta part cu exp exp exp coarse true negate exp coarse true negate exp part part theta part part theta part part theta part cu exp exp rule deal expressions cu exp exp exp exp coarse true exp coarse true negate exp part part theta part part theta part part theta part path expression partitioned refine undef parser cu exp refine undef refine true parser assign labels predicates sub domain new subdomain created 
done getlabel function obtained phase 
follows argument getlabel usually implicit predicate part current sub domain 
labels allow differentiate sub domains generated third phase concerned detection redundant classes 
example syntax rule arithmetic relation rt exp exp exp associate action part exp exp getlabel exp exp getlabel thetas part theta part equal expression integers specified precision amount explained previous chapter 
detail way type expression determined modifications parser similar necessary compiler technology 
syntax rule arithmetic relation rt exp exp exp associate action part exp exp getlabel exp exp getlabel thetas part theta part rules simple partition vdm sl expression 
example systematic partitioning technique described previous chapter decided partitioning arithmetic additions 
rt exp exp exp part part theta part expressions partitioned sub domains 
give example set union expression partitioned sub domains identified 
rt exp exp exp associated action part exp fg exp fg getlabel exp fg exp fg getlabel exp fg exp fg getlabel exp fg exp fg exp exp fg getlabel exp fg exp fg exp ae exp getlabel exp fg exp fg exp ae exp getlabel exp fg exp fg exp exp getlabel exp fg exp fg exp exp fg exp ae exp exp ae exp exp exp getlabel thetas part theta part generates specific sub domains set union expression 
give rules deal syntax terminals 
rt exp part true getlabel rt exp number part true fg example integer refine true part fy fy theta true theta true fg refine true part represented fy fy need provide syntax rules embedded path expressions need include rules coarse true refine true parser 
rules included minimum changes need ensure correct parser called 
example give simplified rule sense elseif part omitted 


expressions rt exp exp exp exp refine true negate exp refine undef exp part part theta part part theta part part theta part example rule embedded path expressions give simple rule logical conjunctions 
rt exp exp exp part part theta part deal function calls fashion rt exp parameter list part part theta part partition returned terminal final partition specification function obtained separate analysis 
rt parameter list exp rt parameter list parameter list exp part part theta part conclude give complex refined partitioning rules quantified expressions 
rules transformations rules section apart labels semantics equivalent 
changed presentation style partitioning rules performing combinations situ set comprehension notation gives direct approach 
ts denotes conjunction expression ts 
rt exp exp delta exp tmp part ts exp delta pred fs exp delta pred ts lab ts part ts fs part tsg part exp getlabel exp delta exp getlabel theta tmp part thetas part rt exp exp delta exp tmp part ts exp delta pred fs exp delta pred ts lab ts part ts fs part tsg part exp delta exp exp getlabel exp delta exp exp getlabel part theta part refine undef parser parser want partition non path expressions obtain undefined expressions 
example create rule deal arithmetic relations 
arithmetic relation undefined operands undefined number 
ru arith rel ru exp exp arith rel exp part num exp getlabel part num exp getlabel part num exp getlabel part num exp getlabel part part theta part part theta part part theta part part theta part part theta part part theta part part theta part part theta part binary operators behave fashion divide operator divisor lead undefined expressions special circumstances 
example give syntax rule partitioning integer division expressions 
ru exp exp div exp part int exp getlabel part int exp getlabel part int exp getlabel part int exp getlabel part exp getlabel part part theta part part theta part part theta part part theta part part theta part part theta part part theta part part theta part part theta part part theta part part theta part non recursive rules ru exp part getlabel ru exp number part false getlabel need course reproduce rules coarse undef parser deal embedded path expressions ru exp exp exp refine true exp refine true exp part part theta part part theta part part theta part ru exp exp exp refine true negate exp refine true negate exp part part theta part part theta part part theta part ru exp exp rule deal expressions ru exp exp exp exp refine true exp refine true negate exp part part theta part part theta part part theta part third phase redundancy analysis outcome second phase final partition 
equivalence class partition composed satisfiable predicate set labels representing sub domains combined obtain predicate 
set labels need detect eliminate redundant classes partition obtain minimal set classes suitable sampling 
step need denote group dependent labels appearing classes final partition unique label dependent labels readily identifiable convention role predicate dependent 
give algorithm regroup function takes set labels associated predicate class returns set sets dependent labels regroup quite similar getlabel function 
regroup set labels set sets labels gl 
take label fl delta dependent gl gl fgg return gl regroup example regroup fa equal ffc fa fb gg 
set groups dependent labels final partition represented set gs fg regroup lab constructed 
group gs mapped unique label convention terms letters subscripts 
set labels lab class final partition replaced new set labels associated regroup lab mapping defined 
second step final step third phase technique identify eliminate redundant classes obtain minimal set classes 
interest formally characterise minimal set classes mcs final partition ccs set sets classes cover groups dependent sub domains appearing final partition ccs fcs cs ae delta fc lab csg fc lab pgg minimal set classes mcs mcs ccs mcs ccs delta smaller set classes ccs mentioned minimal sets classes final partition viewed equivalent testing point view algorithm propose derive minimal set classes non deterministic 
initial call minimal fg minimal rc mc set classes set classes rc return mc rc delta rc mc delta lab lab return minimal rc gamma fcg mc rc delta label lab delta rc mc delta label lab return minimal rc gamma fcg mc fcg rc return minimal rc gamma fcg mc minimal fourth phase sampling result third phase minimal set classes 
minimal set classes sampled solver obtain set test cases 
examples section illustrate technique small examples 
lack space illustrate atomic step generated step step parsing process 
keep second phase systematic partitioning relatively short examples vdm sl arithmetic expressions lpf behaviour disabled 
aim show kind minimal set classes obtained technique omit fourth phase 
labels associated predicates represented alongside predicates 
equivalence classes clarity 
function dependence consider expression 
phase set set variables mapped labels respectively 
second phase coarse true part fx fx fx fx fx fx fx fx fx fx fx fx third phase step final partition fa fa fa fa fa fa fa fa fa fa fa fa algorithm minimal set classes fa fa fa fa function dependence consider expression 
phase set sets variables mapped labels second phase coarse true fx fx fx fx fx fx fx third phase step final partition fa fa fa fa fa fa fa redundancy analysis detect redundant class minimal set classes 
function call consider expression 
deemed human tester implemented separately 
generate final partition consider expression phase set sets variables ffx gg mapped label second phase coarse true gamma gamma gamma gamma fa fa fa fa fa fa fa fa third phase step final partition gamma gamma gamma gamma ff ff ff ff ff ff ff ff final partition called 
labels independent respect remarks 
called functions 
return original expression phase set sets variables mapped labels 
second phase coarse true fx fx fx fx fx fx fx fx fx fx fx fx theta fx theta gamma gamma gamma gamma ff ff ff ff ff ff ff ff classes combined indication simplifications performed readability coarse true gamma gamma gamma gamma fx fx fx fx fx fx fx fx fx fx fx fx fx fx fx third phase step final partition gamma gamma gamma gamma fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa second step yields minimal set classes gamma gamma gamma fa fa fa fa fa fa fa fa latest systematic partitioning followed redundancy analysis phase complex reasonably 
able tests generation process complex expressions detail phase 
regroup dependent labels generated possible denoting unique label influence results done reasons clarity 
functions dependence consider 
coarse true part fx fx fx fx fx regrouping labels get fa fa fa fa fa class number detected redundant leaving simplified minimal set classes test data generation fa fa fa fa multiple function calls consider coarse true part ff ff coarse true part fx fx fx fx fx fx fx fx minimal set classes final partition ae oe fx previous examples illustrated effects context dependent combination 
dealt direct approach graphs described functions may induce contradictions classes renders impracticable 
chapter recursion looseness specifications examined 
systematically generate test set triangle problem described chapter technique evaluate efforts north manually derived test set dick faivre automatically generated test set 
chapter triangle problem aspects chapter discuss remaining aspects generating test cases vdm sl specifications view integrating technique recursion looseness 
test cases triangle problem generated technique results analysed 
remaining aspects analysing specification triangle problem test cases generation technique evaluating adequacy discuss propose deal recursive functions non deterministic behaviour looseness specifications 
recursion considered dick faivre looseness mentioned 
recursion difficult feature deal appropriately analysing techniques 
example symbolic execution imperative programming language code usually curtailed recursive functions 
difficulty deciding times recursive functions symbolically unfolded 
typically recursive functions unfolded fixed number times result analysed 
approach taken 
argue purpose identifying sub domains recursive function recursive calls need unfolded 
see may satisfactory generation adequate test cases 
illustrate argument sum example triangle problem sum sum seq seq hd seq sum tl seq partitioning rules recursive call sum obtain len len theta len hd sum len hd sum tl general apply partitioning rules unfolding recursive calls able generate partition function contain adequate sub domains 
sum fs ng theta len hd len hd sum tl recursive functions tested isolation rest specification calls may encounter problems generating adequate tests 
sum function raise difficulties argument eventually cover case sequence empty 
particular class implicitly covered argument empty sequence calling contexts 
function style sum sum seq seq elseif seq hd seq sum tl seq create problems sequence passed argument calling contexts 
example length sequences calling contexts means generate sequence type natural exercise particular aspect revised sum function 
partition revised sum function sum fs ng theta len hd len hd sum tl particular instance sum unfolded reveal extraneous classes allow generation appropriate test cases general decide times recursive function unfolded allow generation equivalence classes 
generate adequate partition recursive functions ensure circumstances generation test cases exercise equivalence class generated 
propose recursive function calls unfolded accept classes recursive functions tested separately rest system test exercised test cases generated 
circumstances analysis labels covered test cases generated reveal sub domains generated exercised testing highlight classes recursive functions unable cover 
decide non covered classes exercised calls specification manually generate tests exercise non covered classes 
classes covered inconsistencies specification shortcomings approach dealing recursive functions 
looseness seen chapter looseness specifications may induce high level complexity may mechanical analysis envisaged handle appropriately 
examine effects looseness simple circumstances test generation technique 
illustration propose example post div equal result function non deterministic specified equal 
partially partitioning lpf behaviour simplicity obtain theta div fy theta interested classes test cases generated sampling input variables tests oracle 
serious problems tests 
firstly oracle wrong implementation outputs gamma inputs specification implementation behaved correctly instances 
partitioned expression effect sub domains input variables function analysis 
general identify expressions affect input sub domains particular function partitioning probably infeasible complex expressions impractical perform routinely simple circumstances 
accept loose specifications oracle may biased unspecified behaviour value 
specification identified human tester non deterministic complex specifications particularly difficult infer test input fed back specification symbolic execution specification expression specifying expected output obtained 
second problem particular tests generated correct oracle generated specification obtain apparent tests cover sub domains redundant 
redundancy identified proposal redundancy analysis previous section 
simple example allowed show elementary circumstances loose specifications raise difficult problems automatic generation test cases 
proposal deal problems relies human intervention identification loose specifications 
triangle problem return triangle problem illustrate kind consistency checks performed automatically mechanical assistance generation test cases approach 
take account potential lpf behaviour specification illustrate importance difficulties raises 
note specification deterministic 
vdm sl standard understanding type undefined function call proceeds undefined value argument undefined returned automatically 
able compare test set produced north dick faivre specification classify chapter classify token triangle type classify seq nat triangle variety invalid give test cases generation process details lack space 
shorten generation test cases triangle problem places insight tests generation process avoid deriving equivalent classes know inconsistent systematic approach 
important note affect final result 
initial checks rule obtain classify token theta type theta seq nat triangle theta variety seq nat triangle seq nat triangle theta invalid convention token fs specification loose choose type fr typeg generating sub domains expression lengthen derivation process affecting final result 
rule classify fs token typeg theta seq nat triangle theta variety seq nat theta triangle seq nat theta triangle seq nat theta triangle seq nat theta triangle seq nat theta triangle seq nat theta triangle seq nat theta triangle seq nat theta triangle theta invalid vdm sl semantics seq nat replaced seq nat triangle replaced triangle 
definition seq nat seq elems delta nat definition triangle len elems delta sum 
abbreviation seq elems delta nat len elems delta sum consider variety 
variety function specification deemed implemented system test simplified cases rule applies context shorten derivation variety fs triangle triangle typeg theta card elems theta equilateral card elems theta card elems theta isosceles card elems theta card elems theta card elems theta scalene simplify variety fs triangle triangle typeg theta card elems theta equilateral card elems theta isosceles card elems theta scalene classify fs token typeg theta theta theta theta theta card elems theta equilateral card elems theta isosceles card elems theta scalene theta theta theta theta theta theta theta theta theta theta theta theta theta invalid theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta simplifications predicate level classify fs token typeg theta theta theta theta theta card elems theta equilateral card elems theta isosceles card elems theta scalene theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta invalid need generate sub domains expressions seq seq seq fs fs seq ae seq oe fs seq ae oe fs elems delta nat assume nat implemented function system test 
need nat nat ff ff ff nat function labels remain independent labels rest specification 
elems delta nat elems delta elems delta nat elems delta elems delta nat elems delta elems delta elems delta nat elems delta elems delta elems delta nat elems delta elems delta elems delta nat elems delta elems delta elems delta represent sub domains follows internally implementation sub domains represented fashion elems delta nat elems fg elems elems fx elems fmg elems elems mg elems fx mg elems mg fs fs fs fs fs fs fs fs sub domain ng delta consider 
need nat int real nat int real ff ff ff modified partitioning expression existentially quantified expressions function call discussed previous chapter get elems delta nat elems fi elems fr elems ft elems fi elems fi elems fr elems fi elems fi elems fr elems ft elems fi elems fi elems fr elems fi fs fs fs fs fs fs fs fs fs fs fs fs fs fs sub domain 
ng delta int mg delta real pg delta int real nat delta nat consider elems delta nat need nat ae oe ff elems delta nat seq elems fn fs fs fs len straightforward len ae len oe fs len len len len len fs fs fs fs len seq fs fs elems delta sum need sum 
expression dependent partitioning step yields sum gamma gamma theta sum recall sum specified follows sum sum seq seq hd seq sum tl seq sum fs ng theta theta theta hd sum tl sum function implementation test type membership 
necessary testing specification proper fs fr len len fsg hd sum tl transformed sum theta hd theta tl recursive call sum re partitioned 
ensure potential lpf behaviour preserved hd fr hd sg theta len len tl fr tl sg theta len len obtain hd sum tl len hd sum len hd sum tl sum fs ng theta len len theta len hd sum len hd sum tl developing partitioning expression get exp sum fs ng theta len hd len hd sum tl sum simplified executing argument fully known 
sum fs sum ng theta gamma len hd gamma len hd sum tl gamma gamma len hd gamma len hd sum tl gamma list potential combinations arising elems delta sum note inconsistencies arise empty sequence partitioning proper sub domains sum length specified different len len combined 
contradictions detected earlier 
elems delta sum fs sum ng theta len elems delta hd gamma len elems delta hd sum tl gamma len elems delta hd gamma len elems delta hd sum tl gamma len elems delta sum elems delta hd gamma elems delta hd gamma len elems delta sum elems delta hd sum tl gamma elems delta hd sum tl gamma simplify elems delta sum fs sum ng theta gamma len elems delta hd sum tl gamma gamma len elems delta hd sum tl gamma sum gamma gamma len elems delta sum elems delta hd sum tl gamma elems delta hd sum tl gamma consistency checking obtain elems delta sum fs sum ng theta len elems delta hd sum tl gamma len elems delta sum elems delta hd sum tl gamma elems delta hd sum tl gamma fs fs fs fs need consider elems delta sum 
re exp sum derived earlier obtain sum fs sum ng theta len hd len hd sum tl len hd len hd sum tl fact elems delta sum equivalent elems delta consistency checking obtain elems delta sum fs sum ng theta len elems delta hd len elems delta hd sum tl len elems delta hd len elems delta hd sum tl len elems delta sum elems delta hd len elems delta sum elems delta hd sum tl len elems delta sum elems delta hd len elems delta sum elems delta hd sum tl len elems delta sum elems delta hd elems delta hd len elems delta sum elems delta hd sum tl elems delta hd sum tl len elems delta sum elems delta hd elems delta len elems delta sum elems delta elems delta hd sum tl len elems delta sum elems delta hd elems delta len elems delta sum elems delta elems delta hd sum tl len elems delta sum elems delta hd elems delta hd elems delta len elems delta sum elems delta hd sum tl elems delta hd sum tl elems delta account potential lpf behaviour specification 
existence undefined value sequence naturals renders sum undefined type argument sequence naturals undefined value part natural type addition operator propagates undefinedness 
undefined value entire expression elems delta sum undefined sum renders sub domains unsatisfiable 
simplifying elems delta sum fs sum ng theta len elems delta hd sum tl len elems delta hd sum tl len elems delta sum elems delta hd sum tl len elems delta sum elems delta hd sum tl elems delta sum fs sum ng theta len elems delta hd sum tl len elems delta sum elems delta hd sum tl len elems delta sum elems delta hd sum tl fs fs fs fs fs consider straightforward elems delta sum seq elems delta nat fs fs fs pursuing classify recall classify fs token typeg theta theta theta theta theta card elems theta equilateral card elems theta isosceles card elems theta scalene theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta invalid perform combinations theta fs sum ng theta len elems delta hd sum tl gamma len elems delta sum elems delta hd sum tl gamma elems delta hd sum tl gamma fs fs fs theta fs sum ng theta len elems delta sum elems delta hd sum tl len elems delta sum elems delta hd sum tl fs fs fs theta ae len elems delta nat oe fs theta fs sum ng theta len elems delta hd sum tl gamma len elems delta sum elems delta hd sum tl gamma elems delta hd sum tl gamma len elems delta hd sum tl gamma len elems delta sum elems delta hd sum tl gamma elems delta hd sum tl gamma fs fs fs fs fs theta fs sum ng theta len elems delta sum elems delta hd sum tl len elems delta sum elems delta hd sum tl len elems delta sum elems delta hd sum tl len elems len elems delta sum elems delta hd sum tl len elems delta sum elems delta hd sum tl fs fs fs fs fs fs fs fs fs fs theta len elems delta nat len elems delta nat len elems delta nat len elems delta nat fs fs fs fs theta seq fs fs generate sub domains remaining partition expressions card elems elems fs card elems elems fs card elems elems fs equilateral fr fr isosceles fr fr scalene fr fr invalid fr fr theta theta theta card elems theta equilateral card elems theta isosceles card elems theta scalene fs sum ng theta equilateral equilateral len elems delta hd sum tl gamma card elems isosceles len elems delta sum elems delta hd sum tl gamma elems delta hd sum tl gamma card elems isosceles len elems delta hd sum tl gamma card elems scalene len elems delta sum elems delta hd sum tl gamma elems delta hd sum tl gamma card elems scalene fs fs fs fs fs fs theta theta theta invalid len elems delta nat invalid len elems delta nat invalid len elems delta nat invalid len elems delta nat invalid fs fs fs fs theta theta theta invalid fs sum ng theta invalid len elems delta hd sum tl gamma invalid len elems delta sum elems delta hd sum tl gamma elems delta hd sum tl gamma thetar invalid len elems delta hd sum tl gamma invalid len elems delta sum elems delta hd sum tl gamma elems delta hd sum tl gamma invalid fs fs fs fs fs theta theta theta invalid fs sum ng theta invalid len elems delta sum elems delta hd sum tl invalid len elems delta sum elems delta hd sum tl invalid fs fs fs theta theta theta invalid ae len elems delta nat invalid oe fs theta theta theta invalid ae seq invalid oe fs theta theta theta invalid ae invalid oe fs theta theta theta invalid fs sum ng theta invalid invalid invalid len elems delta sum elems delta hd sum tl invalid invalid len elems delta sum elems delta hd sum tl invalid len elems delta sum elems delta hd sum tl invalid len elems invalid len elems delta sum elems delta hd sum tl invalid len elems delta sum elems delta hd sum tl invalid fs fs fs fs fs fs fs fs fs fs combine simple sub domains obtain set equivalence classes invalid seq invalid invalid fs fs fs detect redundant classes generate minimal set classes 
sub domains arising need find consistent combination sub domain label ff consider covered 
combination len elems delta hd sum tl gamma invalid elem mg label fs remaining combinations performed subdomains obtain fx gg theta equilateral equilateral len elems delta hd sum tl gamma card elems isosceles len elems delta sum elems delta hd sum tl gamma elems delta hd sum tl gamma card elems isosceles len elems delta hd sum tl gamma card elems scalene len elems delta sum elems delta hd sum tl gamma elems delta hd sum tl gamma card elems scalene len elems delta sum elems delta hd sum tl gamma elems delta hd sum tl gamma thetar invalid len elems delta hd sum tl gamma invalid fs fs fs fs fs fs fs fs followed elems delta nat theta len elems delta sum elems delta hd sum tl gamma elems delta hd sum tl gamma invalid invalid invalid invalid len elems delta sum elems delta hd sum tl invalid invalid len elems delta sum elems delta hd sum tl invalid len elems delta sum elems delta hd sum tl invalid len elems invalid len elems delta sum elems delta hd sum tl invalid len elems delta sum elems delta hd sum tl invalid invalid len elems delta sum elems delta hd sum tl invalid len elems delta sum elems delta hd sum tl invalid fs fs fs fs fs fs fs fs fs fs fs fs fs fs find covering 
invalid invalid invalid len elems ft invalid len elems invalid len elems fi invalid len elems fi invalid len elems invalid fs fs fs fs fs fs fs fs sample final classes obtain adequate set test cases triangle problem shown table 
evaluation evaluate adequacy tests generated technique recall test set derived north table feasibility study test case generation formal specifications 
compare results dick faivre 
remarked chapter fact test cases generated dick faivre tool classes generated sampling manual roughly included north test set encouraging 
absence boundary tests circumstances invalid outcome arises prompted refine partitioning process 
examine test set inclusion north test set discuss differences arising 
permutations examine isosceles outcome 
tests number north set represented say 
permutations represented test set 
globally permutations north test set represented set concerns north tests number id test input oracle class invalid invalid invalid invalid equilateral equilateral isosceles isosceles scalene scalene invalid invalid invalid invalid invalid invalid invalid invalid invalid table test cases triangle problem part id test input oracle class invalid invalid invalid invalid invalid invalid invalid gamma invalid gamma invalid invalid invalid invalid gamma invalid gamma gamma invalid invalid table test cases triangle problem part id test input oracle id test input oracle invalid invalid invalid invalid invalid isosceles invalid equilateral invalid gamma scalene invalid invalid equilateral invalid isosceles invalid isosceles invalid isosceles invalid isosceles invalid isosceles invalid isosceles invalid scalene gamma invalid scalene gamma gamma gamma invalid scalene invalid scalene invalid scalene invalid scalene table reminder north test cases triangle problem permutations original test :10.1.1.104.4138
dick faivre test set contain permutations 
examining test generation process absence explained higher level remarking specification implies different behaviour system permutations sequence parameter 
introduce permutations tests generated options ffl introduce permutations boundary feature sequences 
ffl decide include testing requirement sampling sampling yield tests class permutations sequences 
important remarks concerning particular testing requirement 
argue specification requirement sequences permuted fact error guessing aspect test cases derivation process 
accepted north 
testing tool systematic test generation technique design include tests 
proposed ways tests generated technique shows error guessing general incorporated proposal 
part basic technique value underpinned empirical evidence partitioning classical basic boundary testing 
secondly argue permutations north test set redundant 
particular implementations testing permutations sufficient 
unknown implementation north test set adequate respect permutation sequences 
accept permutations input sequence improve adequacy test set generated concerns systematic permutation sequences specification incorporated technique error guessing testing requirement 
testing specifications difficult argue permutations sequences 
overflow equilateral outcome illustrates divergence test set north 
equilateral outcome tests represented tests north test set 
test perfectly matched north appears designed test boundary value integer possibility arithmetic overflows implementation test 
goal test representation integers implementation handle large numbers specified specification sensibly value need take maximum 
design test cases formal specifications explicit testing potential overflows system test believe doomed failure implementation certain reproduce specification terms computational steps 
better apply static analysis techniques code system test reveal instances overflow occur 
input sequence numbers sufficient test implementation handles large possible input correctly 
test set may problem fact large value input length concern return 
scalene outcome absence permutations test set discussed differences emerge test set north presence sequences results scalene outcome compared north test set 
closer inspection north test number cover tests number represents case digit change alter outcome test number flat triangle test number cover separately 
difficult say test set contain redundant test circumstance 
sure tests cover north single test safe 
find high level argument removal kind tests assumes identify place refrain changing rules suit particular example 
designing approach taken care dubious choices suit particular examples 
invalid outcome area differences test set north differences outcomes results broadly similar exception absence permutations test set 
difference inclusion undefined elements tests number completely undefined input 
undefined values test set stems close adhesion semantics vdm sl 
recognise may difficult take potential lpf behaviour specifications systematically account eventual test generator 
tests may difficult generate automatically 
argued circumstances undefined input value equivalent system test difficult exercise implementation values 
note robust systems undefined values interest input file said equivalent undefined value specification totally spurious value testing assembly code 
tests undefined values input desired specification changed rule partitioning process 
test set includes empty sequence input sequence tests 
absent north test set opinion part adequate test set 
sequences length set recommended north sequences values integers 
generate tests length lead invalid outcome 
length problem striking difference tests derived reflect fact implementation input composed exactly values correctly dismissed immediately invalid triangle 
implies tests length different redundant classes cover covered tests length 
example test number contains largest number implementation able handle probably exercise implementation aspect 
applies non naturals tests 
origin invalid test cases 
propose change approach remedy problem 
remarked chapter specification triangle problem detailed error messages issues specification form classify token triangle sequence nat lenght classify seq nat sequence nat elseif len lenght elseif elems delta sum invalid variety allow generation test cases closer ideal north 
developing approach introduced special features suit specification triangle problem north find results encouraging 
differences test cases north adequate test set minor argued results fact increase likelihood finding error system test 
triangle problem illustrates recommendations detailed error messages increase adequacy test cases generated 
triangle problem specified north proved challenging brief permit detailed derivation test cases included 
approach general confident technique suitable generation high adequacy test sets formal specifications 
chapter chapter thesis outlined assumptions concerning test cases generation formal specifications ffl strengthen testing activity formal software engineering methods 
ffl technique generation high adequacy test sets 
ffl automated 
review concerns highlighting contributions issues resolved propose area 
contributions chapter underpinned assumption 
chapter broadly concerned finding appropriate test cases generation technique 
parts chapter chapter addressed concern 
review issues 
closing gap chapter outlined current state art automatic test generators 
stressed shortcomings current techniques noted relatively little amount research carried automatic test cases generation formal specifications 
stressed complementary nature various approaches testing random white box black box 
chapter showed atg high level specifications integrated software development process potential benefits 
possibility testing specifications introduced 
particular section benefits testing formal specifications discussed relevance testing process means add value formal software engineering methods 
able generate rigorous test cases early stage software development go testing activity 
doing automatically mean large case studies carried view improving current testing theory lacks empirical data 
automatic oracle formal specifications advantage testing phase 
kind undertaken ultimately allow current practices academic wisdom welcomed 
appropriate technique chapter clarified aspects testing formal specifications integrate global testing activity 
contributions technique high adequacy test set generation summarised follows ffl extended dick faivre account potential lpf behaviour vdm sl specifications 
introduced formalism suitable study partitioning rules formal specifications 
ffl shown coarse partitioning rules developed insufficient generation adequate test sets refinements introduced 
ffl stock carrington fine partitioning rules extended expressions introduce notion scope formal notation 
particular developed rules quantified expressions 
shown partitioning conventions operator expressions systematically obtained definition basic operators 
ffl shown integrate coarse partitioning rules necessary refinements discussed heuristics detection redundant classes necessary 
proposed heuristic underpinned probability revealing error system test 
heuristic integrated formalism 
illustrated potential benefits heuristic includes natural treatment functions 
ffl completeness discussed recursion specifications 
examined consequences test cases generation formal specifications difficult area non determinism 
synthesis previous basic results area test sets generation formal specifications shown triangle problem reach high level adequacy compared manually derived test set north 
refrained development technique introduce non established ad hoc testing methods far possible justified aspect technique confident generality results 
automation pioneering dick faivre allowed suggestions development efficient pragmatic technique 
particular shown dnf reduction specification prior partitioning necessary 
introduced constraint logic programming show eventual solver implemented 
technique systematic reservations possible automation 
particular study simple triangle problem shown complexity consistency checks necessary current technology 
strengths vdm sl specification language mainly high level level abstractness contribute weaknesses far basis test generation concerned 
complexity language tools notation difficult design implement 
note example principal functionalities toolbox available subset language theoretical limitations 
suggested demonstrated simple triangle problem generality precision standardisation vdm sl basis tests generation 
reported north 
stress language may complex high level automation test generation technique achieved 
review current automatic tests generators section listed problems affecting current atgs ffl efficiency difficult assess 
ffl level automation achieved generally high 
ffl single strategy 
ffl scope application usually limited 
admit eventual tool proposed systematic test cases generation vdm sl specifications technique affected problems 
remains done 
propose strands 
pragmatic considerations considerable benefit implement prototype test cases generator adopting approach 
currently prototype tool dick faivre available 
reported approach numerous pragmatic suggestions improvement achievements 
rapid progress constraint logic programming languages implementation taken account positive effect capabilities 
ultimately possible full automation technique entire vdm notation 
implementation considerations propose compromises ease somewhat heavy implementation efforts involved building prototype 
ffl study particular constraint solving requirements eventual tool automated oracle high level formal notation developed 
automated oracle valuable entail kind constraint solving facilities necessary tests generation 
establish extend systematic technique automated 
ffl approach flexible rules simplified instance 
example lpf behaviour broadly passed generating specific tests validation suggested chapter annotations indicate lpf behaviour intended 
basic operators simpler rules employed 
ffl integration tests generator toolbox envisaged 
addition useful tool benefit toolbox specification manipulation facilities toolbox reduce amount effort required compared stand tests generator 
ffl simpler formal notation 
example simpler semantics vdm sl operates valued logic nondeterministic behaviour explicit 
rapidly growing range tool support approach integrated 
convinced implementation technique help development rigorous software testing techniques positive impact formal software engineering methods 
tend concentrating pragmatic aspects suggest theoretical considerations deserving attention 
theoretical advances declared chapter main concern find technique automated generation component tests formal specifications 
suggestions style specifications better testing point view see example sections 
low level suggestions mainly concerned generation component tests se 
interest study specification styles suitable building testable software area system level testing general 
argued software built specifications extended finite state machines easier practical point view test intrinsic design test features 
concerns known hardware community testing afterthought case software integral part system development 
worthwhile investigate theoretical point view context dependent combination heuristic extended circumstances 
analysis specification implementation manual reveal parts specification specified separately functions effect independently implemented system consideration 
allow contraction test sets generated circumstances 
implications system specific information generation tests formal specifications essentially black box testing technique interest 
suggest refine partitioning theory new forms constraints domain divisions investigated 
example benefit generate optimum constraints expression form constraint small possible greater interest 
currently sub domains generated may possible global unsatisfiability generate test cases opportunity generating tests boundary input domain 
example interesting generate sets sequences minimal size allowed specification size explicitly implied predicates 
availability tests generator tool allow statistical evaluation beneficial domain divisions 
lead simplification partitioning rules refinement 
particular quantified expression rules simplified sub domains statistically shown little value 
development different sets rules different areas application envisaged deal example safety critical systems 
bibliography 
dahl dijkstra hoare structured programming vol 
apic studies data processing 
academic press 
hamlet taylor partition testing inspire confidence ieee transactions software engineering vol 
pp 
dec 
tanenbaum defense program testing correctness proofs considered harmful acm sigplan notices vol 
pp 
may 
hall myths formal methods ieee software pp 
sept 
bowen hinchey myths formal methods ieee software pp 
july 
glass flavors testing journal systems software vol 
pp 

testing challenge method tool developers software engineering journal vol 
pp 
mar 
growth software testing communications acm vol 
pp 
june 
ramamoorthy 
ho testing large software automated software evaluation systems ieee transactions software engineering vol 
pp 
mar 
hamlet special section software testing communications acm vol 
pp 
june 
north automatic test generation triangle problem tech 
rep npl feb 
spence generation software tests specifications software quality management ii building quality software ross staples eds vol 
edinburgh uk pp 
computational mechanics publications july 
dick faivre automatic partition analysis vdm specifications tech 
rep tr bull 
dick faivre automating generation sequencing test cases model specifications fme industrial strength formal methods woodcock larsen eds vol 
lecture notes computer science pp 
springer verlag 
stocks carrington test template framework testing case study issta usa 
stocks carrington framework specification testing ieee transactions software engineering vol 
pp 
nov 
overview automated software testing journal systems software vol 
pp 

myers art software testing 
wiley interscience publication 
beizer software system testing quality assurance 
international thomson computer press 
deutsch software verification validation realistic project approaches 
prentice hall series software engineering 
kopetz reliability 
macmillan computer science series 
complete guide software testing 
qed information sciences 
review software testing information software technology vol 
pp 
apr 
software project management quality assurance 
mcgraw hill 
british computer society specialist interest group software testing bcs version april standard software component testing 
british computer society specialist interest group software testing bcs april glossary terms software testing 
barnes high integrity ada spark approach 
addison wesley 
isbn 
frankl hamlet littlewood choosing testing method deliver reliability proceedings th international conference software engineering pp 
acm press may 
omar mohammed survey software functional testing methods software engineering notes vol 
pp 
apr 
weyuker evaluation program software test data adequacy criteria communications acm vol 
pp 
june 
zweben analysis refinement software test data adequacy properties ieee transactions software engineering vol 
pp 
june 
zhu hall test data adequacy measurement software engineering journal pp 
jan 
duran ntafos evaluation random testing ieee transactions software engineering vol 
pp 
july 
weyuker analyzing partition testing strategies ieee transactions software engineering vol 
pp 
july 
demillo lipton hints test data selection help practicing programmer ieee computer vol 
pp 
apr 
choi mathur high performance mutation testing journal systems software vol 
pp 

mathur rego high performance software testing simd machines ieee transactions software engineering vol 
pp 
may 
demillo offutt experimental results automatic test case generator ieee transactions software engineering methodologies vol 
pp 
apr 
miller roper wood brooks benchmark evaluation software testing techniques information software technology vol 
pp 

beizer review computing reviews jan 
demillo offutt constraint automatic test data generation ieee transactions software engineering vol 
pp 
sept 
king offutt fortran language system mutation software testing software practice experience vol 
pp 
july 
woodward mutation testing origin evolution information software technology vol 
pp 
mar 
hoffman automated module testing prolog ieee transactions software engineering vol 
pp 
sept 
chow testing software design modeled finite state machines ieee transactions software engineering vol 
pp 
may 
protocol test generation procedure vol 
pp 

fujiwara test selection finite state models ieee transactions software engineering vol 
pp 
june 
brinksma iso specification language lotos vol 

dembinski estelle specification language distributed systems vol 

ccitt specification description language sdl vol 

hall relationship specifications testing information software technology vol 
pp 
jan feb 
gaudel software testing formal specifications theory tool software engineering journal vol 
pp 
nov 
wilson formal methods object oriented analysis bt technology journal vol 
pp 
july 
henderson formal description object oriented programming vdm vdm vdm formal method vol 
lecture notes computer science pp 
springerverlag mar 
hoare communicating sequential processes 
prentice hall international 
logic specification extending vdm sl advanced formal specification 
chapman hall 
audsley burns richardson wellings applying new scheduling theory static priority pre emptive scheduling software engineering journal pp 
sept 
brown ii automated oracle software testing ieee transactions reliability vol 
pp 
june 
automatic generator compiler testing ieee transactions software engineering vol 
pp 
july 
bird munoz automatic generation random self checking test cases ibm systems journal vol 
pp 

symbolic execution systems review software engineering journal vol 
pp 
nov 
ramamoorthy bun ho chen automated generation program test data ieee transactions software engineering vol 
pp 
dec 
king symbolic execution program testing communications acm vol 
pp 

boyer select formal system testing debugging programs symbolic execution proceedings international conference reliable software pp 
apr 
clarke system generate test data symbolically execute programs ieee transactions software engineering vol 
pp 
sept 
degano levi martelli montanari sirovich turini flexible environment program devel opment symbolic interpreter proceedings fourth international conference software engineering munich germany pp 
sept 
automatic test data generation related topics 
phd thesis liverpool university uk 
software testbeds roles capabilities proceedings ieee software fair conference arlington va usa july 
symbolic execution testing information software technology vol 
pp 
jan feb 
korel automated software test data generation ieee transactions software engineering vol 
pp 
aug 
miller system construct samples data processing program debugging ieee transactions software engineering vol 
pp 

dyer distribution statistical sampling approach software functional test journal systems software vol 
pp 

furukawa tokunaga agent advanced testcase generation system functional testing afips press national computer conference vol 
pp 

high level petri nets testing concurrent real time systems real time systems theory applications ed pp 
north holland 
tsai keefe automated test case generation programs specified relational algebra queries ieee transactions software engineering vol 
pp 
mar 
pitt derivation conformance tests lotos specifications ieee transactions software engineering vol 
pp 
dec 
li taniguchi automatic derivation test cases lotos expressions data parameters vol 
pp 

automatic test case generation prolog tech 
rep npl jan 
specification testing data types computer language vol 
pp 

gaudel algebraic specifications software testing case study software automatic subway journal systems software vol 
pp 

ostrand category partition method specifying generating functional tests communications acm vol 
pp 
june 
formal specification testing journal software testing verification reliability vol 
pp 

chang richardson sankar structural specification testing adl software engineering notes vol 
pp 
jan 
proceedings international symposium software testing analysis issta 
jones systematic software development vdm 
prentice hall international uk second edition ed 
hayes specification case studies 
series computer science prentice hall international 
spivey notation manual 
series computer science prentice hall international 
cambridge uk automated test facility 
software research usa software tool suite 
software quality automation usa sqa 
graham turner verification validation testing object oriented systems bt technology journal vol 
pp 
july 
testing objectoriented software software quality management ii building quality software ross staples eds vol 
edinburgh uk pp 
computational mechanics publications july 
software products group ipl bath uk 
glass lost world software debugging testing communications acm vol 
pp 

yang chung path analysis testing concurrent programs information software technology vol 
pp 
jan 
korel ferguson dynamic method test data generation distributed software information software technology vol 
pp 
aug 
software products group ipl bath uk 
plat larsen overview iso vdm sl standard acm sigplan notices vol 
pp 
aug 
dick matthews woods making formal specification animation testing proof science computer programming vol 
pp 

hayes specification directed module testing ieee transactions software engineering vol 
pp 
jan 
vdm sl tool group users manual vdm sl tool 
institute applied computer science sept 
vdm sl tool group vdm sl language 
institute applied computer science sept 
larsen lassen vdm sl toolbox practical approach formal specification acm sigplan notices vol 
pp 

mukherjee computer aided validation formal specification software engineering journal pp 
july 
lindsay survey mechanical support formal reasoning software engineering journal pp 
jan 
translating specifications vdm sl pvs theorem proving higher order logics tphols von wright grundy harrison eds vol 
lecture notes computer science pp 
springer verlag 
monahan shaw model specifications software engineer book mcdermid ed ch 
london 
fitzgerald lindsay moore ritchie proof vdm practitioner guide 
springer verlag 

banatre jones prospects functional programming software engineering 
project volume research reports esprit springer verlag 
lindsay reasoning specifications vdm perspective tech 
rep university queensland australia oct 
hayes vdm comparative case study formal aspect computing vol 
pp 

hayes jones understanding differences vdm tech 
rep umcs university manchester aug 
draft international standard iso iec jtc sc wg information technology programming languages vdm sl nov 
vdm sl guide 
pitman 
larsen plat standards non executable specification languages computer journal vol 
pp 

symbolic execution specifications user interface scenarios tech 
rep umcs university manchester uk 
unreachable states model oriented specifications tech 
rep university western ontario london ontario canada sept 
analytical techniques verification validation testing bt technology journal vol 
pp 
apr 
freuder paths satisfaction proceedings ecai workshop constraint processing meyer ed amsterdam aug 
dantzig linear programming extensions 
princeton new jersey princeton university press 
bratko prolog programming artificial intelligence 
international computer science series addison wesley publishing second ed 
isbn 
gallier logic computer science foundations automatic theorem proving 
john wiley sons 
jaffar 
lassez constraint logic programming popl proceedings th acm symposium principles programming languages munich pp 
acm jan 
colmerauer prolog iii communications acm vol 
pp 
july 
cohen constraint logic programming languages communications acm vol 
pp 
july 
hentenryck simonis dincbas constraint satisfaction constraint logic programming artificial intelligence vol 
pp 

choquet test data generation prolog constraints workshop software testing pp 
banff ieee 
ecrc common logic programming system ecl ps user manual feb 
ecrc project ecl ps url www ecrc de research projects eclipse 
jaffar michaylov stuckey yap clp 
language system acm transactions programming languages systems vol 
pp 
july 
dincbas van hentenryck simonis graf berthier constraint logic programming language chip fgcs proceedings international conference fifth generation computer systems tokyo pp 
icot dec 
jeavons cohen cooper substitution operation constraints principles practice constraint programming second international workshop borning ed vol 
lecture notes computer science pp 
springer verlag 
constraint logic programming finite set domains tech 
rep ecrc ecrc 
yang automatic generation software test data specifications tech 
rep cs university wales uk feb 
beizer software testing techniques 
international thomson computer press nd ed 
isbn 

carr information flow data flow analysis programs acm transactions programming languages systems vol 
pp 
jan 

abrial book assigning programs meanings 
cambridge university press 
isbn 
holcombe integrated methodology specification verification testing systems journal software testing verification reliability vol 
pp 

reed building testable software software engineering notes pp 
sept 

