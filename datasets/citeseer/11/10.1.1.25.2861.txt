compilation pipeline synthesis reconfigurable architectures markus universit karlsruhe fakult ur informatik karlsruhe germany ipd info uni karlsruhe de 
gives survey novel programming method reconfigurable architectures 
combines techniques vectorizing compilers high level synthesis hardware software codesign imperative high level language program specifies host program software coprocessor configuration hardware application 
renders reconfigurable architectures useful users hardware design experience 
input program analyzed vectorized 
suitable loops hardware pipelines synthesized 
execute loops operators parallel reconfigurable hardware speeding program 
partitioner dynamically selects software hardware execution loop 
show feasibility method built prototypical pipeline compiler 
automatically synthesizes coprocessors integrates configuration control host program 
results experiments small fpga board compiler 
reconfigurable architectures custom computing machines proven useful applications 
combine flexibility software speed application specific hardware 
part application executed software takes advantage universality general purpose host processor 
portions executed reconfigurable hardware coprocessor accelerated enormously 
programming machines remains difficult task tradeoffs software hardware considered circuits accelerating application designed manually 
aims automatically extracting generating coprocessors programming language 
circuits exhibit considerable parallelism accelerate application despite large configuration communication overheads 
pipeline compiler sequential input program synthesizes pipeline circuits 
targets combination conventional host computer reconfigurable processing unit consisting fpga hardware local memory 
section presents vectorization suitable loops section details pipeline synthesis 
section deals pipeline control interfaces section supported deutsche forschungsgemeinschaft systeme 
presents hardware software partitioner 
discuss related report results draw 
vectorization section presents loop transformations tests check pipeline generated loop 
contrast classical vectorization explicitly generate vector instructions 
instructions loop body vectorized implicitly executed pipeline 
vectorization consists steps hardware candidate selection regular iterative computations perform operations large set data benefit hardware acceleration 
loops candidates coprocessors attempt vectorize 
handle nested loops inner loops unrolled completely 
furthermore additional restrictions candidate loops contain recursive function calls external operating system library calls 
due limitations current fpga technology floating point operations allowed 
explain complete compilation process running example shown 
combines fir filter length bit numbers feedback register random number generation 
chose somewhat strange combination explain features single example 
program pipelined circuit synthesized 
rand rand rand rand rand rand rand original loop rand rand rand rand rand rand rand normalized loop example program loop normalization attempt transform candidate loops loops induction variable detection 
efficient pipelined coprocessors synthesized loops consider loop types candidates 
normalize candidate loops transformations additionally non standard bit level functions proven useful hardware acceleration 
hardly account considerable amount program runtime seldomly warrant overhead involved considered 
occur loop pipelined execution combines benefits parallelism bit level optimization 
ffl inline function calls completely unroll inner loops loop body 
ffl remove additional induction variables normalize loop form 
induction variable substitution 
ffl normalize index expressions linear expressions induction variable subscript normalization 
possible loop hardware candidate 
normalizing example loop results program shown 
alias analysis order construct unambiguous dataflow graph loop body exclude aliases 
allow pointer operations indirect array accesses 
additionally detect aliases arrays scalar variables introduced assignments outside loop parameters 
alias exists loop hardware candidate 
dependence analysis vectorization loop tested loop carried dependences vectorizing compilers 
consider nested loops test reduces solving dimensional linear diophantine equations checking dependences stemming scalar variables 
pipeline execution overlaps loop iterations maintains order consider true anti output dependences 
detected true loop carried dependence check regular occurs loop iterations distance 
case dependences scalar variables array accesses stride 
dependences realized feedback cycles circuit 
don prevent pipeline synthesis reduce parallelism pipelining possible feedback cycle 
irregular loop carried dependences prevent loop pipelining vectorization 
example aliases loop carried dependences array accesses dependence stemming scalar variable rand 
pipeline synthesis vectorizable loop synthesize pipeline circuit 
operation requires phases load array data local memory scalar variables fpga registers 
operate pipeline stand transfer results back host 
pipeline operation array vector inputs fed pipeline data streams vector output streams written local memory 
pipeline synthesized steps acyclic dataflow graph generation step generate purely combinational dataflow graph dg loop body loop iteration 
body contains control constructs conditional statements multiplexers select correct values conditionally assigned variables 
treat array accesses scalar variables uniformly 
index shifted accesses array realized cf 

delayed values input stream reduces number vector input ports avoids accessing value memory 
need additional operation phase filling shift registers pipeline operation 
shows example dg inputs rand outputs rand 
input registers shaded vector ports 
clarity constant inputs included optimization overlap slow host communication pipeline operation 
implemented compiler prototype 
operator node 
additionally control logic shown needed provide data input ports store output values 
xor 
div div div rand div rand select bit rand acyclic dataflow graph feedback cycles realize regular loop carried dependences feedback cycles added dg 
dependences array accesses transformed scalar dependences introducing new scalar variables 
scalar feedback variables processed assume execute loop iteration clock cycle 
variable input register contain value computed previous cycle 
achieve multiplexer added dg register input 
selects input value initialization feedback value normal operation 
add feedbacks registers resulting circuit remains synchronous 
feedback cycle variable rand multiplexer selecting correct input added example dg 
div div rand xor 
scalar div div rand rand select bit dg feedback cycle pipelining dgs generated far inefficient entire dg evaluated clock cycle 
performance indicated circuit throughput improved pipelining inserting additional registers 
correct operation number registers inserted non cyclic paths input register output 
register insertion forbidden feedback cycles change circuit behaviour 
developed method integer linear programming inserts minimal number fpga necessary achieve cycle time 
cycle time determined number ports see section delay feedback cycles 
shows example dg pipeline stages 
additionally chain inserted control feedback register delayed output values 
div scalar xor 
rand div div div valid rand rand select bit ce valid pipelined dg netlist generation instantiating dg operators corresponding hardware modules circuit netlist generated 
combined pipeline control unit see section processed shelf vendor tools resulting configuration bitstream 
pipeline control unit manually designed optimized pipeline control unit controls pipeline operation provides interface local memory host 
programs 
shows embedding experimental environment sun sparcstation evc board 
pipeline reads vector input ports provides results output ports simultaneously 
limited number memory banks case just 
simulate simultaneous read write accesses reading buffering input data local memory writing pipeline output values 
takes memory cycles combined time accesses defines cycle time pipeline 
pipeline frequency throughput determined number input output ports ports mean poorer performance 
standard functions copy data operate pipeline sending control words interpreted appropriately 
runtime system functions configuration reset allow automatically access accelerators 
facilitates porting compiler encapsulates host interface local memory access details 
ported manually new shown vector input ports 
output port implemented writing ram slower reading applications need input ports output port 
evc board local ram fpga pipeline control unit sun workstation control address clk program specific pipeline circuit data address data control evc pipeline control unit architecture 
pipeline synthesis architecture independent 
runtime partitioning reconfiguration pipeline circuits hardware speedup loop execution depends length loop theta delta sw hw gamma delta sw hw speedup single loop iteration constant overhead accessing filling flushing pipeline 
relationship phase partitioning method 
compile time phase statically loops considered 
checks expected speedup larger amortized configuration communication overhead loop execution 
estimates average loop length avg constant communication time comm set pipeline data download configuration time tdl number loop executions avg program region intermediate communication region intermediate reconfiguration avg 
fpga configuration generated inequality holds avg theta delta sw hw gamma comm avg tdl avg second phase data dependent dynamic selection runtime 
chooses hardware see details hardware software interface 
avg avg determined static program analysis improved programmer annotations indicating typical iteration counts relevant loops 
iterations software hardware hardware speedup speedup execution overhead overhead overhead fir filter random number generator image smoothing table runtimes speedups region inequality holds cur theta delta sw hw gamma comm cur local selection current values don consider configuration overhead 
related previous research generating hardware accelerators software programs performed 
example prism system extracts coprocessors functions 
massively exploit hardware parallelism 
hand uses vector code synthesize operator pipelines 
enables hardware parallelism requires programmer write programs general vector code 
method contains automatic hardware software partitioning produces general pipelines compiler 
ideas occured areas computer science vectorization parallelization techniques supercomputer compilers pipelining methods data flow computers static partitioning algorithms hardware software codesign 
pipeline synthesis uses methods high level synthesis compiler optimization 
results compiler prototype synthesizes pipelines modula programs target architecture 
implemented example program 
upper part table shows software runtime hardware execution time pure pipeline operation hardware overhead communication configuration time 
speedup values overhead computed 
numbers show achieve speedup time overhead computation 
set experiments performed image smoothing algorithm 
measured processing pixel grey scale image processing image prototype contains software optimizer compare hardware speedups software optimizations 
times rows iteration iterations lower part table 
experiment configuration communication necessary iterations 
speedup increased iteration 
results previous section show compiler prototype yields considerable speedups computationally intensive programs smallest commercially available fpga boards evc 
speedup reduced overhead 
better architectures reconfigurable hardware overhead better numbers nearer speedups overhead achieved 
compared processors synthesized programming language sources vectorization pipelines offer higher degree parallelism 
additionally reuse input intermediate values saves memory access cycles 
direct connections register outputs operator inputs effectively move address calculations runtime compile time 
aho sethi ullman 
compilers principles techniques tools 
addisonwesley 
zima chapman 
supercompilers parallel vector computers 
addison wesley 

programming fine grained reconfigurable architectures 
phd thesis university texas austin may 

pipeline synthesis optimization reconfigurable custom computing machines 
bericht universitat karlsruhe fakultat fur informatik 

engineers virtual computer users guide evc 
virtual computer 

portable pipeline synthesis 
field programmable logic applications th international workshop darmstadt germany september 
springerverlag 
athanas silverman 
processor reconfiguration instruction set metamorphosis 
computer march 
gao 
algorithmic aspects balancing techniques pipelined data flow code generation 
journal parallel distributed computing 
ernst henkel th 
benner 
hardware software microcontrollers 
ieee design test computers pages december 
jantsch 
hardware software partitioning minimizing memory interface traffic 
proc 
european design automation conf 

ieee computer society press september 
gajski dutt wu st lin 
high level synthesis chip system design 
kluwer academic publishers 
