unreliable failure detectors asynchronous distributed systems dissertation faculty graduate school cornell university partial fulfillment requirements degree doctor philosophy tushar deepak chandra may fl tushar deepak chandra rights reserved unreliable failure detectors asynchronous distributed systems tushar deepak chandra ph cornell university known fundamental problems fault tolerant distributed computing consensus atomic broadcast solved asynchronous systems crash failures 
impossibility results stem lack reliable failure detection systems 
circumvent impossibility results introduce concept unreliable failure detectors mistakes study problem solve consensus atomic broadcast 
easy solve consensus perfect failure detector mistakes 
perfect failure detection necessary solve consensus 
show consensus solvable unreliable failure detectors infinite number mistakes 
leads question weakest failure detector solving consensus 
introduce notion algorithmic reducibility allows compare seemingly incomparable failure detectors 
concept show failure detectors introduce weakest failure detector solving consensus asynchronous systems majority correct processes 
show consensus atomic broadcast equivalent asynchronous systems 
results regarding solvability consensus failure detectors apply atomic broadcast 
thesis funded ibm graduate fellowship nsf darpa nasa ibm programming laboratory siemens natural engineering research council canada 
biographical sketch tushar deepak chandra born new delhi india november 
spent childhood various cities india bombay calcutta kanpur 
completing high school school went bachelor technology computer science indian institute technology kanpur 
joined graduate program computer science cornell university august 
iii thesis dedicated parents taught think 
iv large number people contributed directly indirectly thesis 
extremely fortunate sam toueg advisor 
guidance trying shave deltas broadcast algorithms cooking knowledge learnt cook pasta sauce la 
sam put thesis 
am indebted hadzilacos author invaluable contributions 
help chapter happened 
critical readings chapter greatly influenced way 
idea unreliable failure detectors came invaluable discussions isis folks particular ricciardi ken birman see rb 
biswas dexter kozen george odifreddi rod downey taught recursion theory gave tools prove result chapter 
introduced rotating coordinator paradigm homework solution see 
prasad greatly simplified algorithm 
earlier algorithms place algorithm twice text 
thesis committee ken birman dexter kozen anil nerode sam toueg guidance support 
babaoglu cynthia dwork keith marzullo gil mike reiter fred schneider distributed systems group cornell comments criticisms 
special various bhaskar sandip bose suresh radha jagadeesan parikh stimulating discussions influenced thesis 
family chandra putting erratic hours providing love support 
vi table contents models distributed systems solving agreement problems unreliable failure detectors model failures failure patterns failure detectors completeness accuracy failure detector definitions algorithms runs reducibility weak completeness strong completeness reliable broadcast consensus problem solving consensus unreliable failure detectors strong failure detector eventually strong failure detector lower bound fault tolerance atomic broadcast reducing atomic broadcast consensus weakest failure detector solving consensus model failure detectors algorithms configurations runs environments consensus problem reducibility outline result reduction algorithm dag forest vii tagging simulation forest hooks forks extracting correct process reduction algorithm td omega discussion granularity atomic actions weak consensus failure detectors infinite range output values open problems related partial synchrony application failure detection shared memory systems isis toolkit hierarchy failure detectors bounds fault tolerance mistakes hierarchy failure detectors tight bounds fault tolerance bibliography viii list figures failure detector specifications accuracy completeness 
transforming weak completeness strong completeness reliable broadcast message diffusion solving consensus solving consensus consensus solve atomic broadcast generating schedule delta compatible path delta upsilon fork deciding process hook deciding process generating path upsilon decision gadgets upsilon bivalent critical lemma lemma selecting correct process process communication component process computation component time implementation models partial synchrony 
hierarchy failure detectors ordered reducibility 
shows maximum number faulty processes consensus solved failure detector hierarchy 
ix chapter design verification fault tolerant distributed applications widely viewed complex endeavour 
years paradigms identified simplify task 
key consensus atomic broadcast 
roughly speaking consensus allows processes reach common decision depends initial inputs despite failures 
consensus algorithms solve problems arise practice electing leader agreeing value replicated sensor 
atomic broadcast allows processes reliably broadcast messages agree set messages deliver order message deliveries 
applications paradigms include sift state machines lam sch isis bj pbs amoeba mul delta pow transis cri faa cdd atomic commitment 
wide applicability consensus atomic broadcast extensively studied theoretical experimental researchers decade 
thesis focus solutions consensus atomic broadcast asynchronous model distributed computing 
informally distributed system asynchronous bound message delay clock drift time necessary execute step 
say system asynchronous timing assumptions whatsoever 
model attractive gained currency reasons simple semantics applications programmed basis model easier port incorporating specific timing assumptions practice variable unexpected workloads sources asynchrony synchrony assumptions best probabilistic 
asynchronous model computation attractive reasons outlined known consensus atomic broadcast solved deterministically asynchronous system subject single crash failure flp dds 
essentially impossibility results consensus atomic broadcast stem inherent difficulty determining process crashed slow 
circumvent impossibility results previous research focused randomization techniques cd definition weaker problems solutions dlp abd bw study models partial synchrony dds dls 
impossibility deterministic solutions agreement problems consensus atomic broadcast remains major obstacle asynchronous model computation fault tolerant distributed computing 
thesis propose alternative approach circumvent impossibility results broaden applicability asynchronous model computation 
impossibility results asynchronous systems stem inherent difficulty determining process crashed slow propose augment asynchronous model computation model external failure detection mechanism mistakes 
particular model concept unreliable failure detectors systems crash failures 
consider distributed failure detectors process access local roughly speaking crash failure occurs process executing correctly stops prematurely 
process crashes recover 
failure detector module 
local module monitors subset processes system maintains list currently suspects crashed 
assume failure detector module mistakes erroneously adding processes list suspects suspect process crashed running 
module believes mistake remove list 
module may repeatedly add remove processes list suspects 
furthermore time failure detector modules different processes may different lists suspects 
important note mistakes unreliable failure detector prevent correct process behaving specification process erroneously suspected crashed processes 
example consider algorithm uses failure detector solve atomic broadcast asynchronous system 
suppose failure detector modules wrongly permanently suspect correct process crashed 
atomic broadcast algorithm ensure delivers set messages order correct processes 
furthermore broadcasts message correct processes deliver define failure detectors terms properties opposed giving specific implementations hardware software implementation failure detectors concern thesis 
approach allows design applications prove correctness relying solely properties referring low level network parameters exact duration time outs implement failure detectors 
presentation applications proof correctness modular 
approach suited model existing systems decouple design fault tolerant applications different approach taken isis system rb correct process wrongly suspected crashed forced leave system 
words isis failure detector forces system conform view 
applications failure detector mistakes 
detailed discussion see section 
underlying failure detection mechanisms isis toolkit asynchronous fault tolerant distributed computing 
characterize failure detector specifying completeness property accuracy property satisfy 
informally completeness requires failure detector eventually suspects process crashes accuracy restricts mistakes failure detector 
define completeness accuracy properties gives rise failure detectors consider problem solving consensus 
introduce concept reducibility failure detectors 
informally failure detector reducible failure detector distributed algorithm emulate reduction algorithm done failure detector done 
failure detectors equivalent reducible 
concept partition failure detectors equivalence classes consider solve consensus class 
show failure detectors solve consensus systems number processes may crash 
assume majority processes crash failure detectors solve consensus 
order better understand majority requirement necessary study infinite hierarchy failure detectors contains failure detectors mentioned show exactly hierarchy majority requirement necessary 
special interest weakest failure detector considered thesis 
informally satisfies properties say failure detector suspects process crashed local failure detector module suspects crashed 
show consensus atomic broadcast equivalent asynchronous systems consensus algorithm transformed atomic broadcast algorithm vice versa 
focus consensus results automatically apply atomic broadcast 
ffl completeness time process crashes suspected correct process 
ffl accuracy time correct process suspected correct process 
failure detector infinite number mistakes local failure detector module repeatedly add remove correct processes list suspects reflects inherent difficulty determining process link just slow crashed 
correct processes may erroneously suspected crashed processes entire execution 
properties state eventually hold forever may appear strong requirement implement practice 
solving problem terminates consensus really required properties hold forever merely hold sufficiently long time long algorithm uses failure detector achieve goal 
instance practice algorithm solves consensus needs properties hold relatively short period time 
asynchronous system possible quantify sufficiently long single process step single message transmission allowed take arbitrarily long amount time 
convenient state properties stronger form 
advantage opposed stronger failure detectors 
consider application relies correctness 
application run system failure detector malfunctions fails meet specification may lose liveness properties application safety properties violated 
failure detector abstraction clean extension asynchronous model computation allows solve problems able 
naturally question arises support abstraction actual system 
specify failure detectors terms properties committed particular implementation 
instance envision specialised hardware support abstraction 
implementations failure detectors time mechanisms 
purpose illustration outline implementation 
informally process times process adds list suspects broadcasts message processes including information 
process receives broadcast adds list suspects 
crashed broadcasts refutation 
process receives refutation removes list suspects 
purely asynchronous system scheme implement unbounded sequence premature time outs corresponding refutations may cause correct process repeatedly added removed correct process list suspects violating accuracy property 
practical systems choose time periods eventually premature time outs correct process gives accuracy property time permanently removed lists suspects 
recall practice necessary hold permanently sufficient holds long application failure detector complete task 
accordingly necessary premature time outs cease permanently sufficient cease long 
having point implemented practical systems time outs reiterate reasoning failure detectors algorithms done terms properties terms scheme implement purely asynchronous system show section implementation solve consensus system contradicting impossibility result flp 
particular implementation 
important feature approach reader refrain thinking failure detectors terms specific time mechanisms 
failure detection properties sufficient solve consensus asynchronous systems 
necessary 
example consider failure detector satisfies completeness property weakening accuracy property ffl accuracy time correct process suspected correct processes 
clearly weaker 
possible solve consensus 
weakest failure detector sufficient solve consensus asynchronous systems 
trying answer fundamental question run problem 
consider failure detector satisfies properties ffl completeness time process crashes suspected correct processes 
ffl accuracy time correct process suspected majority processes 
incomparable completeness property stronger accuracy property weaker 
possible solve consensus asynchronous system 
answer turns provided asynchronous system majority correct processes requires 
appear incomparable may tempted conclude weakest failure detector consensus solvable 
worse raises possibility weakest failure detector exists 
closer examination reveals comparable distributed algorithm transform failure detector properties 
works asynchronous system majority correct processes 
words reducible system 
prove reducible failure detector solve consensus result holds asynchronous system 
show reduction giving distributed algorithm td transforms 
precise sense failure detector necessary sufficient solving consensus asynchronous systems majority correct processes 
result evidence importance faulttolerance asynchronous distributed computing 
discussion far focused consensus problem 
section show consensus equivalent atomic broadcast asynchronous systems crash failures 
shown reducing problem 
words solution automatically yields solution 
reductions apply asynchronous system particular require assumption failure detector 
atomic broadcast solved unreliable failure detectors described thesis 
furthermore weakest failure detector solve atomic broadcast 
different tack circumventing unsolvability consensus pursued dds dls 
approach papers observation completely synchronous completely asynchronous models distributed systems lie variety intermediate partially synchronous models 
particular papers consider different models partial synchrony model determine consensus solved 
thesis argue partial synchrony assumptions encapsulated unreliability failure detector 
example show implement failure detectors stronger models partial equivalent asynchronous systems arbitrary byzantine failures 
reduction complex omitted thesis 
synchrony considered dls 
immediately implies consensus atomic broadcast solved models 
approach unify seemingly unrelated models partial synchrony 
argued earlier asynchronous model computation highly desirable applications results code simple portable robust 
fact fundamental problems consensus atomic broadcast deterministic solutions model major obstacle fault tolerant distributed computing 
model unreliable failure detectors provides natural simple extension asynchronous model computation consensus atomic broadcast solved deterministically 
extended model retains advantages asynchrony inheriting disadvantages 
believe approach important contribution bridging gap known theoretical impossibility results need fault tolerant solutions real systems 
remainder thesis organised follows 
chapter informally describe different models fault tolerant distributed computing 
puts perspective 
chapter briefly describe model introduce failure detectors terms properties 
describe solutions consensus problem failure detectors 
show consensus atomic broadcast equivalent 
solutions consensus problem transformed solutions atomic broadcast 
chapter detailed model asynchronous distributed computing unreliable failure detection 
prove reducible failure detector solving consensus model 
shows weakest failure detector solving consensus asynchronous systems 
chapter discusses related particular describe implemen detailed discussion see chapter 
tation unreliable failure detector powerful models partial synchrony 
appendix define failure detector hierarchy strength accuracy derive lower bounds fault tolerance 
chapter models distributed systems problems fault tolerant distributed computing studied variety computational models 
order put perspective give broad overview models 
models fall broad categories message passing shared memory 
processes communicate sending receiving messages links network communicate accessing shared objects registers queues thesis focus message passing models 
parameters determine particular message passing model types process failures process faulty execution behaviour deviates prescribed algorithm running correct 
types failures studied literature 
include crash failures faulty process stops prematurely point lf omission failures faulty process intermittently omit send receive messages pt arbitrary failures faulty processes behave arbitrarily lsp 
thesis consider crash failures 
types communication failures models link failures considered literature including crash omission arbitrary failures 
thesis assume communication subsystem reliable link failures occur 
network topology types network topologies studied literature 
fall broad categories point point networks broadcast networks mixed networks permit broadcasts limited number processes 
thesis focuses point point networks 
types point point networks studied 
include completely connected networks link pair processes rings processes arranged ring physical network completely connected network layer protocols build virtual links pair processes 
thesis assume network completely connected 
deterministic versus randomized processes process behavior may deterministic randomized 
general process modeled possibly infinite state automaton 
roughly speaking state transition relation deterministic process uniquely determines state results execution step current state 
randomized process execution step current state may result possible states transition associated probability 
informally process toss coins determine transition take 
impossibility consensus applies deterministic processes primary focus thesis 
results section regarding equivalence consensus atomic broadcast apply deterministic randomized processes 
synchrony synchrony attribute processes communication 
say system synchronous satisfies properties ffl known upper bound ffi message delay consists time takes sending transporting receiving message link 
ffl process local clock known bounded rate drift ae respect real time 
ae gamma gamma gamma ae reading real time ffl known upper lower bounds time required process execute step 
system asynchronous bound message delay clock drift time necessary execute step 
say system asynchronous timing assumptions whatsoever 
synchronous asynchronous models extremes spectrum possible models 
intermediate models studied 
example processes may bounded speeds perfectly synchronized clocks message delays may unbounded dds 
message delays may bounded unknown dls 
thesis focuses asynchronous model computation 
direct impact models partial synchrony considered detail section 
chapter solving agreement problems unreliable failure detectors chapter describe algorithms consensus atomic broadcast unreliable failure detectors 
informal model distributed computing unreliable failure detectors 
informal model give sufficient presentation algorithms proofs 
chapter extend model precise order prove subtle lower bound 
model consider asynchronous distributed systems bound message delay clock drift time necessary execute step 
model asynchronous computation failure detection patterned flp 
system consists set processes pi fp pair processes connected reliable communication channel 
simplify presentation model assume existence discrete global clock 
merely fictional device processes access 
take range clock ticks set natural numbers 
failures failure patterns processes fail crashing prematurely halting 
failure pattern function pi denotes set processes crashed time process crashes recover 
define crashed correct pi gamma crashed 
crashed say crashes correct say correct consider failure patterns process correct correct 
failure detectors failure detector module outputs set processes currently suspects crashed 
failure detector history function pi theta pi value failure detector module process time say suspects time omit obvious context 
note failure detector modules different processes need agree list processes suspected crashed possible 
informally failure detector provides possibly incorrect information failure pattern occurs execution 
formally failure detector function maps failure pattern set failure detector histories 
set failure detector histories occur executions failure pattern failure detector thesis define failure detectors terms specific implementations 
implementations refer low level network parameters network topology message delays accuracy local chapter study general class failure detectors modules output values arbitrary range 
general executions failure pattern executions may differ pattern message exchange 
execution may give different failure detector history 
clocks 
avoid problem specify failure detector terms properties satisfy completeness accuracy 
allows design applications prove correctness relying solely properties 
completeness consider completeness properties ffl strong completeness eventually process crashes permanently suspected correct process 
formally satisfies strong completeness crashed correct ffl weak completeness eventually process crashes permanently suspected correct process 
formally satisfies weak completeness crashed correct completeness useful property 
see consider failure detector causes process permanently suspect process system 
failure detector trivially satisfies strong completeness clearly useless provides information failures 
useful failure detector satisfy accuracy property restricts mistakes 
consider properties 
accuracy consider accuracy properties ffl strong accuracy process suspected crashes 
formally satisfies strong accuracy pi gamma difficult impossible achieve strong accuracy practical systems define ffl weak accuracy correct process suspected 
formally satisfies weak accuracy correct pi gamma weak accuracy guarantees correct process suspected 
type accuracy may difficult achieve consider failure detectors may suspect process time 
informally require strong accuracy weak accuracy eventually satisfied 
resulting properties called eventual strong accuracy eventual weak accuracy respectively 
example eventual strong accuracy requires time strong accuracy holds 
formally satisfies eventual strong accuracy pi gamma observation order 
faulty processes crash finite time pi gamma correct equivalent simpler formulation eventual strong accuracy ffl eventual strong accuracy time correct processes suspected correct process 
formally satisfies eventual strong accuracy correct similarly specify eventual weak accuracy follows ffl eventual weak accuracy time correct process suspected correct process 
formally satisfies eventual weak accuracy correct correct refer eventual strong accuracy eventual weak accuracy eventual accuracy properties strong accuracy weak accuracy perpetual accuracy properties 
failure detector definitions failure detector specified stating completeness property accuracy property satisfy 
combining completeness properties accuracy properties defined previous section gives rise different failure detectors defined 
example say failure detector eventually strong satisfies strong completeness eventual weak accuracy 
denote failure detector 
algorithms runs thesis focus algorithms unreliable failure detectors 
describe algorithms need informal definitions algorithms runs 
formal definitions chapter 
algorithm collection deterministic automata process system 
computation proceeds steps step process may receive message sent queries failure detector module undergoes state transition may send message 
model asynchronous systems messages may experience arbitrary finite delays 
furthermore bound relative process speeds 
accuracy completeness strong weak eventual strong eventual weak eventually eventually strong perfect fd strong fd perfect fd strong fd eventually weak weak fd weak fd failure detector specifications accuracy completeness 
informally run algorithm failure detector tuple hf failure pattern hd history failure detector failure pattern initial configuration infinite sequence steps list increasing time values indicating step occurred 
run satisfy certain formedness fairness properties 
particular process take step crashes process takes step queries failure detector module gets current value output local failure detector module process correct takes infinite number steps eventually receives message sent 
notation 
variable algorithm denote process copy history run denoted value time run denote process local failure detector module 
value time run hf hd 
algorithm uses emulated transforming reducibility define means algorithm transform failure detector failure detector algorithm uses maintain variable output process variable reflected local state emulates output algorithm transforms run hf output 
reduction algorithm done failure detector done 
see suppose algorithm requires failure detector available 
execute follows 
concurrently processes run transform modify algorithm process follows required query failure detector module reads current value output concurrently maintained 
illustrated 
intuitively able emulate provides information process failures 
algorithm transforms write say reducible say weaker write say equivalent 
note general need emulate failure detector histories require failure detector histories emulates histories consider identity transformation process periodically writes current value output local failure detector module output immediate td definition reducibility 
observation 
weak completeness strong completeness give reduction algorithm transforms failure detector satisfies weak completeness failure detector satisfies strong completeness 
furthermore failure detector defined gives failure detector accuracy property roughly speaking strengthens completeness property preserving accuracy 
result allows focus failure detectors defined row strong completeness 
observation shows failure detector second row equivalent corresponding failure detector 
informally works follows 
process periodically sends suspects suspects denotes set processes suspects local failure detector module processes 
process process executes output cobegin jj task repeat forever fp queries local failure detector module suspects send suspects jj task receive suspects output output suspects gamma fqg coend weak completeness strong completeness receives message form suspects adds suspects output removes output hf arbitrary run failure detector run failure pattern fixed 
say process crashes mean crashes similarly say process correct mean correct show output satisfies properties transforming weak completeness strong completeness process crashes 
eventually correct process permanently suspects hd eventually correct processes permanently suspect output formally crashed correct hd correct output preserving perpetual accuracy process 
process suspects hd time process suspects output time formally pi pi gamma hd pi gamma output preserving eventual accuracy correct process 
time correct process suspects hd time correct process suspects output formally correct correct hd correct output lemma satisfies 
proof process crashes 
suppose time correct process permanently suspects hd show time correct process suspects output crashes time process receives message consider execution task process time max 
process sends message type suspects suspects processes 
eventually correct process receives suspects adds output see task 
correct process receives messages time correct process removes output time time correct process permanently suspects output lemma satisfies 
proof process 
suppose time process suspects hd process sends message type gamma suspects suspects time process adds output time lemma satisfies 
proof correct process 
suppose time correct process suspects hd processes suspect time eventually crash 
time correct process receives message type gamma suspects suspects 
correct process 
show time suspect output consider execution task process time process sends message suspects receives removes output see task 
receive messages type gamma suspects suspects time add output time time suspect output theorem transforms 
proof lemma transforms failure detectors satisfy strong completeness 
lemma preserves strong accuracy weak accuracy lemma preserves eventual strong accuracy eventual weak accuracy 
theorem immediately follows 
theorem observation corollary 
process executes execute broadcast send including deliver occurs follows receive time sender send deliver reliable broadcast message diffusion reliable broadcast define reliable broadcast communication primitive algorithms 
informally reliable broadcast guarantees correct processes deliver set messages messages broadcast correct processes delivered spurious messages delivered 
formally reliable broadcast defined terms primitives broadcast message drawn set possible messages 
process executes broadcast say broadcasts process executes deliver say delivers reliable broadcast satisfies properties validity correct process broadcasts message correct processes eventually deliver agreement correct process delivers message correct processes eventually deliver uniform integrity message process delivers simplicity assume message unique 
practice achieved tagging identity sender sequence number message 
broadcast process 
give simple reliable broadcast algorithm asynchronous systems 
informally process receives message time relays message processes delivers 
easy show algorithm satisfies validity agreement uniform integrity asynchronous systems gamma crash failures 
proof obvious omitted 
consensus problem consensus problem correct processes propose value reach unanimous irrevocable decision value related proposed values fis 
define consensus problem terms primitives propose decide value drawn set possible proposed values 
process executes propose say proposes similarly process executes decide say decides consensus problem specified follows termination correct process eventually decides value 
uniform validity process decides proposed process 
uniform integrity process decides 
agreement correct processes decide differently 
proved deterministic algorithm consensus asynchronous systems subject single crash failure flp dds 
show unreliable failure detectors solve consensus asynchronous systems 
validity condition captures relation decision value proposed values 
changing condition results types consensus fis 
solving consensus unreliable failure detectors show solve consensus failure detectors defined 
theorem need show solve consensus failure detectors satisfy strong completeness 
solving consensus perfect failure detector simple left exercise reader 
section give consensus algorithm uses section give consensus algorithm uses 
algorithm solves consensus 
consensus algorithm uses tolerate number failures 
contrast uses requires majority correct processes 
show requirement necessary uses failure detector stronger 
algorithm solving consensus optimal respect number failures tolerates 
strong failure detector strong failure detector algorithm solves consensus asynchronous systems 
algorithm runs phases 
phase processes execute gamma asynchronous rounds denotes current round number process broadcast relay proposed values 
process waits receives round message process proceeding round 
note possible waiting message round added rule stops waiting message proceeds round 
phase correct processes agree vector proposed values processes 
ith element vector contains proposed value process 
show vector contains proposed value process 
phase correct processes decide non trivial component vector 
denote maximum number processes may crash 
phase algorithm consists gamma rounds usual rounds traditional consensus algorithms synchronous systems 
intuitively correct process may suspected crashed processes 
case messages may ignored appears commit send omission failures 
gamma processes may appear commit failures 
note satisfies weak accuracy correct process suspected maximum number processes may fail appear fail gamma denotes current estimate proposed value 
delta round receives value proposed time round hf run algorithm correct processes propose value 
show termination uniform validity agreement uniform integrity hold 
lemma phases 
proof obvious algorithm 
lemma correct process eventually reaches phase 
proof sketch way correct process prevented reaching phase blocking forever wait statements phase respectively 
happen waiting forever message process joins cases consider 
crashes 
satisfies strong completeness time literature notation adopted 
thesis reserve denote real time 
process executes procedure propose fp estimate proposed delta phase rounds gamma gamma send delta wait received delta failure msgs delta received delta delta delta msgs delta delta delta delta phase send wait received failure fv received phase decide non 
component solving consensus 
crash 
case show easy tedious induction round number eventually sends message waiting 
cases blocked forever reaches phase 
satisfies weak accuracy correct process suspected process pi gamma 
pi denote set processes complete gamma rounds phase pi denote set processes complete phase 
say pi 
lemma round gamma processes pi receive delta process delta msgs 
proof pi completes gamma rounds phase 
round waits receives message delta lemma pi phase 
proof suppose process phase 
lemma consider pi show phase 
obvious consider case round received define 
algorithm clear delta round cases consider 
gamma 
round gamma relays sending message delta delta 
lemma receives delta round 
algorithm clear sets round 

gamma 
case received time round gamma 
process relays vector delta easy see relayed gamma processes pi gamma fcg including received sets relaying follows phase 
lemma pi phase 
proof consider pi pi 
show phase 
cases consider 
phase 
lemma processes pi including phase 
vectors sent phase remain equal phase 
phase 
waits receives phase 
sets phase 
lemma pi phase 
proof clear algorithm phase 
lemma pi phase 
process sends phase 
algorithm clear pi phase 
theorem strong failure detector algorithm solves consensus asynchronous systems proof algorithm clear process decides satisfies uniform integrity requirement consensus 
lemma correct process eventually reaches phase 
lemma vector correct non 
component phase 
algorithm process reaches phase decides non 
component correct process decides non 
value phase satisfies termination consensus 
lemma processes reach phase vector correct processes decide value agreement consensus satisfied 
lemma non 
decision value proposed value process 
uniform validity consensus satisfied 
theorems corollary weak failure detector consensus solvable asynchronous systems eventually strong failure detector previous solution consensus failure detector satisfies weak accuracy correct process suspected 
solve consensus failure detector satisfies eventual weak accuracy 
processes may erroneously added lists suspects time 
correct process time process suspected crashed 
note time processes determine specific process correct correct process suspected time eventually strong failure detector algorithm solves consensus asynchronous systems majority correct processes 
show solving consensus requires majority 
algorithm optimal respect number failures tolerates 
algorithm uses rotating coordinator paradigm rei fact show majority correct processes required uses stronger failure detector 
cm dls bgp ct 
computation proceeds asynchronous rounds 
assume processes priori knowledge round coordinator process mod 
messages current coordinator 
time process coordinator tries determine consistent decision value 
current coordinator correct suspected surviving process succeed broadcast decision value 
algorithm goes asynchronous epochs may span asynchronous rounds 
epoch decision values possible 
second epoch value gets locked decision value possible 
third epoch processes decide locked value 
round consensus algorithm divided asynchronous phases 
phase process sends current estimate decision value timestamped round number adopted estimate current coordinator phase gathers gamma estimates selects largest timestamp sends processes new estimate estimate phase process possibilities 
receives estimate sends ack indicate adopted estimate estimate 
consulting failure detector module suspects crashed sends nack phase waits gamma replies acks nacks 
gamma replies acks knows gamma processes changed estimates estimate estimate locked 
consequently broadcasts request decide estimate time process delivers request decides accordingly 
proof algorithm solves consensus follows 
run algorithm correct processes process executes procedure propose estimate estimate decision state undecided fr denotes current round ts fthe round estimate updated initially coordinators decision state undecided mod fc current phase fall processes send estimate current send estimate ts phase fthe current coordinator gathers gamma estimates proposes new wait gamma processes received estimate ts msgs estimate ts received estimate ts qg largest ts estimate ts msgs estimate select estimate estimate msgs send estimate phase fall processes wait new estimate proposed current wait received estimate failure received estimate cp fp received estimate cp estimate estimate cp ts send ack send nack fp suspects phase current coordinator waits gamma replies 
replies indicate gamma processes adopted estimate coordinator sends request decide 
wait gamma processes received ack nack gamma processes received ack broadcast estimate decide receives decide message deliver estimate decide state undecided decide estimate state decided solving consensus propose value 
show termination uniform validity agreement uniform integrity hold 
lemma processes decide differently 
proof process decides lemma trivially true 
process decides case coordinator broadcast message type gamma gamma gamma decide 
coordinator received gamma messages type gamma gamma ack phase 
smallest round number gamma messages type gamma ack sent coordinator phase 
denote coordinator round mod 
estimate denote estimate phase round claim rounds coordinator sends estimate phase round estimate estimate proof induction round number 
claim trivially holds assume claim holds coordinator round mod 
show claim holds sends estimate phase round estimate estimate algorithm clear sends estimate phase round received estimates gamma processes 
process sent ack message phase round estimate ts msgs phase round sent ack phase round ts phase round ts non decreasing ts phase round phase round estimate ts msgs ts easy see message estimate ts msgs ts largest ts estimate ts msgs 
phase round executes estimate estimate property called uniform agreement stronger agreement requirement consensus applies correct processes 
estimate msgs 
clear adopted estimate estimate phase round coordinator round sent estimate phase round induction hypothesis estimate estimate sets estimate estimate phase round concludes proof claim 
show process decides value decides estimate suppose process delivers estimate decide decides estimate process broadcast estimate decide phase round received gamma messages type gamma ack phase round definition claim estimate estimate lemma correct process eventually decides value 
proof possible cases 
correct process decides 
delivered message type gamma gamma gamma decide 
agreement property reliable broadcast correct processes eventually deliver message decide 

correct process decides 
claim correct process remains blocked forever wait statements 
proof contradiction 
smallest round number correct process blocks forever wait statements 
correct processes reach phase round send message type gamma estimate gamma current coordinator mod 
gamma messages sent cases consider eventually receives messages replies sending estimate 
block forever wait statement phase 
crashes 
case correct process receives estimate 
second case satisfies strong completeness correct process time permanently suspected case correct process blocks second wait statement phase 
correct process sends message type gamma ack gamma nack phase 
gamma correct processes block wait statement phase 
shows correct processes complete round contradiction completes proof claim 
satisfies eventual weak accuracy correct process time correct process suspects processes suspect time eventually crash time process sends message type gamma nack coordinator round mod 
claim round correct processes reach round time process suspects 
coordinator round mod 
phase round correct processes send estimates phase receives gamma estimates sends estimate processes 
phase suspected correct process time correct process waits estimate eventually receives replies ack furthermore process sends nack happen process suspects 
phase receives gamma messages type gamma ack messages type gamma nack broadcasts estimate decide 
validity property reliable broadcast eventually correct processes deliver message decide contradiction 
case impossible concludes proof lemma 
theorem eventually strong failure detector algorithm solves consensus asynchronous systems proof termination lemma 
agreement lemma 
uniform integrity clear algorithm process decides 
uniform validity algorithm clear estimates coordinator receives phase proposed values 
decision value coordinator selects estimates value proposed process 
uniform validity satisfied 
theorems corollary eventually weak failure detector consensus solvable asynchronous systems weakest failure detector considered thesis sufficient solve consensus asynchronous systems 
leads question weakest failure detector solving consensus 
concept reducibility chapter show weakest failure detector solving consensus asynchronous systems majority correct processes 
precisely show theorem failure detector solve consensus asynchronous system system 
corollary theorem corollary weakest failure detector solving consensus asynchronous system lower bound fault tolerance section showed failure detectors perpetual accuracy solve consensus asynchronous systems number failures 
contrast failure detectors eventual accuracy consensus algorithms required majority processes correct 
show requirement necessary algorithm uses strongest failure detectors eventual accuracy solve consensus requires majority correct processes 
algorithm optimal respect fault tolerance 
theorem eventually perfect failure detector algorithm solves consensus asynchronous systems proof describe behaviour eventually perfect failure detector algorithm run ra satisfy specification consensus 
partition processes sets pi pi pi contains processes pi contains remaining processes 
consider consensus algorithm runs ffl run hf processes pi propose processes pi propose 
processes pi correct pi crash run pi possible 
process pi permanently suspects process pi pi pi run clear satisfies specification eventually perfect failure detector 
ffl run hf processes pi propose processes pi propose 
processes pi correct pi crash run pi process pi permanently suspects process pi pi pi clearly satisfies specification eventually perfect failure detector run 
assume loss generality satisfy specifications consensus 
pi pi time decides time decides possible cases case construct run ra hf algorithm satisfies specification eventually perfect failure detector ra violates specification consensus 

decides 
ra hf run identical processes pi propose 
processes pi crash right run indistinguishable decides ra violating uniform validity condition consensus 

decides 
case symmetric case 
decides decides 
construct hf follows 
processes crash fa fa 
processes pi propose processes pi propose 
messages processes pi pi vice versa delayed time max 
time max process pi suspects process pi process pi suspects process pi time max process suspects process max pi pi pi ha pi max pi ha clearly satisfies specification eventually perfect failure detector 
time max ra indistinguishable processes pi ra indistinguishable processes pi run ra decides time decides time decide differently ra violates agreement condition consensus 
appendix refine result theorem considering infinite hierarchy failure detectors ordered number mistakes showing exactly hierarchy majority requirement necessary solving consensus hierarchy contains failure detectors defined 
note theorem corollary theorem dls theorem 
atomic broadcast consider atomic broadcast fundamental problem fault tolerant distributed computing show results consensus apply atomic broadcast 
informally atomic broadcast requires correct processes deliver messages order 
formally atomic broadcast reliable broadcast satisfies ffl total order correct processes deliver messages delivers delivers total order agreement ensure correct processes deliver sequence messages 
atomic broadcast powerful communication paradigm fault tolerant distributed computing cm bj pgm bgt sch 
show consensus atomic broadcast equivalent asynchronous systems crash failures 
shown reducing 
words solution automatically yields solution 
reductions apply asynchronous system particular require assumption failure detector 
equivalence important consequences regarding solvability atomic broadcast asynchronous systems 
atomic broadcast solved deterministic algorithm asynchronous systems assume process may fail fail crashing 
consensus deterministic solution systems flp 

atomic broadcast solved randomization unreliable failure detectors asynchronous systems 
consensus solvable techniques systems survey randomized consensus algorithms see cd 
consensus easily reduced atomic broadcast follows 
propose value process atomically broadcasts 
decide value process picks value message atomically delivers 
total order atomic broadcast correct processes deliver message 
choose value agreement consensus satisfied 
properties consensus easy verify 
section reduce atomic broadcast consensus 
equivalent asynchronous systems arbitrary failures 
reduction complex omitted 
note reduction require assumption failure detector 
reducing atomic broadcast consensus show transform consensus algorithm atomic broadcast algorithm asynchronous systems 
resulting atomic broadcast algorithm tolerates faulty processes consensus algorithm 
reduction uses reliable broadcast repeated possibly concurrent completely independent executions consensus 
processes disambiguate executions tagging messages pertaining th execution consensus number tagging message number constitutes minor modification consensus algorithm 
informally th execution consensus decide th batch messages atomically delivered 
propose decide primitives corresponding th execution consensus denoted propose gamma decide gamma 
atomic broadcast algorithm uses broadcast deliver primitives reliable broadcast 
avoid possible ambiguities atomic broadcast reliable broadcast say process broadcasts delivers refer broadcast delivery associated atomic broadcast delivers refer broadcast delivery associated reliable broadcast 
process intends broadcast message broadcasts task 
process delivers adds set delivered task 
delivered contains messages submitted atomic broadcast currently aware 
delivers message adds set delivered task 
delivered gamma delivered set messages submitted atomic broadcast adelivered set denoted undelivered undelivered empty proposes undelivered batch messages adelivered 
batch denotes th batch messages delivers set messages agreed th execution consensus process executes initialization delivered delivered execute broadcast task broadcast deliver occurs follows deliver task delivered delivered fmg delivered gamma delivered task undelivered delivered gamma delivered propose undelivered wait decide batch gamma delivered atomically deliver messages batch deterministic order delivered delivered batch consensus solve atomic broadcast minus delivered messages delivered 
lemma correct processes message delivered eventually delivered proof delivered delivered task 
correct agreement reliable broadcast eventually delivers inserts delivered possible process deliver message delivers occurs proposed process agreed consensus delivers lemma correct processes 
executes propose gamma eventually executes propose gamma 

delivers messages batch eventually delivers messages batch batch batch 
proof proof simultaneous induction 
show executes propose gamma eventually executes propose gamma 
executes propose gamma delivered contain message lemma eventually delivered delivered initially empty eventually delivered gamma delivered 
eventually executes task propose gamma 
show delivers messages batch eventually messages batch batch batch 
algorithm delivers messages batch previously executed propose gamma 
part lemma correct processes eventually execute propose gamma 
termination uniform integrity consensus correct process eventually executes decide gamma exactly 
agreement consensus correct processes eventually execute decide 
delivered delivered initially empty batch batch assume lemma holds show executes propose gamma eventually executes propose gamma 
executes propose gamma delivered contain message delivered gamma batch 
induction hypothesis batch batch gamma 
gamma batch 
delivered lemma eventually delivered time delivers batch gamma message delivered gamma delivered eventually executes task propose gamma 
show delivers messages batch delivers messages batch batch batch 
delivers messages batch executed propose gamma 
part lemma correct processes eventually execute propose gamma 
termination uniform integrity consensus correct process eventually executes decide gamma exactly 
agreement consensus correct processes eventually execute decide 
note batch gamma gamma batch batch gamma gamma batch 
induction hypothesis batch batch gamma 
batch batch 
lemma algorithm satisfies agreement total order 
proof immediate lemma fact correct processes deliver messages batch deterministic order 
lemma validity correct process broadcasts correct processes eventually deliver proof proof contradiction 
suppose correct process broadcasts correct process delivers lemma correct process delivers task broadcasts validity reliable broadcast correct process eventually delivers inserts delivered task 
correct processes deliver insert delivered 
correct process time permanently delivered gamma delivered lemma correct processes execute propose gamma sets include faulty processes eventually crash faulty process executes propose gamma max 
correct processes execute propose gamma termination agreement consensus correct processes execute decide 
uniform validity consensus process executed propose 
definition correct contains correct processes deliver contradiction concludes proof 
lemma uniform integrity message process delivers broadcast process 
proof suppose process delivers delivers inserts delivered algorithm clear deliver 
algorithm executed decide contains uniform validity consensus process executed propose 
previously delivered messages including uniform integrity reliable broadcast process broadcast broadcast theorem consider system synchronous asynchronous subject crash failures reliable broadcast implemented 
algorithm transforms algorithm consensus atomic broadcast algorithm 
proof immediate lemmata 
reliable broadcast implemented asynchronous systems crash failures section theorem shows atomic broadcast reducible consensus systems 
argued earlier converse true 
corollary consensus atomic broadcast equivalent asynchronous systems crash failures 
equivalence consensus atomic broadcast asynchronous systems immediately implies results regarding consensus particular corollaries theorem hold atomic broadcast corollary weak failure detector atomic broadcast solvable asynchronous systems corollary weakest failure detector solving atomic broadcast asynchronous system corollary eventually perfect failure detector algorithm solves atomic broadcast asynchronous systems furthermore theorem shows plugging randomized consensus algorithm ones cd algorithm automatically get randomized algorithm atomic broadcast asynchronous systems 
corollary atomic broadcast solved randomized algorithms asynchronous systems crash failures 
chapter weakest failure detector solving consensus previous chapter showed consensus solved asynchronous systems unreliable failure detectors 
particular showed solve consensus eventually weak failure detector 
recall eventually weak failure detector failure pattern failure detector history satisfies properties ffl weak completeness time process crashes permanently suspected process correct ffl eventual weak accuracy time process correct suspected process correct previous chapter denoted eventually weak failure detector 
chapter reserve denote particular eventually weak failure detector failure pattern consists failure detector histories satisfy properties 
definition eventually weak failure detector failure pattern 
identity transformation 
shows weakest eventually weak failure detectors 
theorem failure detection properties sufficient solve consensus asynchronous systems majority processes correct 
chapter show necessary prove reducible failure detector solve consensus result holds asynchronous system 
show reduction giving distributed algorithm transforms 
weakest failure detector solve consensus asynchronous systems furthermore failure detector solve consensus strictly stronger 
task transforming failure detector solve consensus runs serious technical difficulty reasons ffl strengthen result restrict output lists suspects 
output value encodes information failures 
example failure detector allowed output boolean formula crashed encoding formula 
output arbitrarily complex unknown encoding failure information 
transformation able decode information 
ffl failure information provided encoded clear extract failure detection properties 
consequently isolation task transforming may possible 
fortunately solve consensus corresponding algorithm consensus able decode information failures provided knows solve consensus 
reduction algorithm td uses consensus extract information transforms properties 
chapter focuses proof subtle lower bound need extend model distributed computation section precise 
extended model section introduces new concepts ffl range values output failure detector mentioned earlier main result chapter applies failure detectors arbitrary sets output values 
formalise associating failure detector range output values 
ffl environment previous chapter proved algorithm uses solve consensus requires failure detectors requirements may different 
example failure detector solve consensus crash 
general failure detector solve consensus depends assumptions underlying environment 
environment asynchronous system set possible failure patterns 
show solve consensus environment transformation algorithm td transforms model failure detectors associated failure detector range values output failure detector 
failure detector history range function pi theta value failure detector module process time failure detector function maps failure pattern set failure detector histories range rd rd denotes range failure detector outputs 
denotes set possible failure detector histories permitted failure pattern chapter considered special class failure detectors 
failure detector module output set processes suspected crashed 
words failure detector rd pi formally define failure detector mentioned 
failure detector module outputs set processes suspected crashed pi failure pattern set failure detector histories range satisfy properties 
time process crashes suspected process correct crashed correct 
time process correct suspected process correct correct correct algorithms model asynchronous communication channels message buffer contains messages form data indicating process sent data addressed process received message 
algorithm collection deterministic automata processes 
denotes automaton running process computation proceeds steps algorithm step process performs atomically phases receive phase receives single message form data message buffer null message denoted meaning message received step 
failure detector query phase queries receives value failure detector module 
say sees value value returned failure detector module send phase changes state sends message processes automaton state step message received receive phase value sees failure detector query phase 
message received process receive phase chosen non deterministically messages message buffer destined null message null message may received messages message buffer destined fact message buffer merely indicates sent model asynchronous systems messages may experience arbitrary finite delays amount time may remain message buffer received unbounded 
model allow message sent received earlier 
message delays arbitrary want finite 
model introducing liveness assumption message sent eventually received provided recipient sufficiently attempts receive messages 
precise 
non determinism arising choice message received reflects asynchrony message buffer due non send phase sends message processes atomically 
shown flp ability sufficient solving consensus 
alternative formulation step restrict process sending message single process send phase 
show formulations equivalent purposes see section 
deterministic choices process 
automaton deterministic sense message sends step new state uniquely determined state message received step failure detector value seen step 
keep things simple assume process sends message 
allows speak contents message buffer set multiset 
easily enforce adding counter message sent assumption damage generality 
configurations runs environments configuration pair function mapping process local state set triples form data representing messages presently message buffer 
initial configuration algorithm configuration initial state 
step algorithm transforms configuration 
step uniquely determined identity process takes step message received step failure detector value seen step 
identify step tuple 
message received step null message type gamma gamma 
say step applicable configuration fg 
write denote unique configuration results applied schedule algorithm finite infinite sequence steps denotes empty schedule 
say schedule algorithm applicable configuration applicable applicable finite schedule applicable denotes unique configuration results applying note denote ith element sequence 
configurations say configuration prefix 
partial run algorithm failure detector tuple hf failure pattern hd failure detector history initial configuration finite schedule finite list increasing time values indicating step occurred jsj jt applicable jsj form ffl crashed time ffl value failure detector module time hd informally partial run represents finite point execution run algorithm failure detector tuple hf failure pattern hd failure detector history initial configuration infinite schedule infinite list increasing time values indicating step occurred 
addition satisfying properties partial run run satisfy properties ffl correct process takes infinite number steps formally correct type gamma gamma ffl message sent correct process eventually received 
formally correct data type gamma appendix prove algorithm uses solve consensus requires failure detectors requirements may different 
example failure detector solve consensus crash 
general failure detector solve consensus depends assumptions underlying environment 
formally environment asynchronous system set possible failure patterns 
consensus problem chapter study weaker form consensus defined chapter 
prove lower bound strengthens result 
define weaker consensus describe differs previous version 
consensus problem chapter process initial value reach irrevocable decision values 
algorithm process distinct initial states oe oe signifying initial value 
disjoint sets decision states sigma sigma enters state sigma say decided say algorithm uses failure detector solve consensus environment run hf satisfies termination correct process eventually decides value 
formally correct sigma sigma validity correct process decides proposed process 
formally synchronous system assumptions underlying environment may include characteristics relative process speeds maximum message delay degree clock synchronization system elaborate definition environment required 
correct sigma pi oe uniform integrity process decides 
formally pi sigma sigma agreement correct processes decide differently 
formally correct sigma sigma consensus problem defined differs previous chapter version ways ffl previous chapter consensus multi valued process allowed propose value arbitrary range 
chapter consensus binary process propose 
difficult show versions consensus equivalent reducible asynchronous systems 
ffl validity property consensus imposes requirement decision value correct processes 
contrast uniform validity property previous version consensus imposed requirement faulty process decides 
ffl previous chapter processes execute independent instances consensus 
instance process distinct proposal reaches corresponding decision 
chapter processes ability solve repeated consensus crucial reduction atomic broadcast consensus see algorithm 
execute single instance consensus 
model unique proposal process initial value 
reducibility define means algorithm transform failure detector failure detector environment algorithm uses maintain variable output process algorithm transforms run hf output 
algorithm transforms write say reducible say weaker outline result section showed solve consensus environment show weaker failure detector solve consensus 
result holds environment result section implies weakest failure detector solve consensus environment prove result define new failure detector denoted omega gamma strong 
show failure detector solve consensus strong omega gamma strong 
output failure detector module omega process single process currently considers correct say trusts case omega pi 
failure pattern omega gamma set failure detector histories omega range omega satisfy property ffl time correct processes trust correct process correct correct omega output failure detector module omega process may change time may trust different processes different times 
furthermore time processes may trust different processes 
theorem environments omega 
proof sketch reduction algorithm omega transforms omega follows 
process periodically sets output pi gamma fqg process currently trusts omega gamma easy see environment output satisfies properties 
theorem environments failure detector solve consensus omega gamma proof reduction algorithm td omega shown section 
core result 
corollary environments failure detector solve consensus 
proof solve consensus theorem omega gamma theorem omega 
transitivity 
section proved environments solve consensus 
corollary shows theorem environments weakest failure detector solve consensus reduction algorithm environment failure detector solve consensus consensus consensus algorithm uses describe algorithm td omega transforms omega intuitively algorithm works follows 
fix arbitrary run td omega failure pattern failure detector history hd 
shall construct infinite directed acyclic graph denoted vertices failure detector values occur hd edges consistent time values occur 
show induces simulation forest upsilon encodes infinite set possible runs consensus show extract upsilon identity process correct induced simulation forest infinite computed process 
information needed extract finite subgraph forest 
sufficient correct process construct increasing finite approximations simulation forest upsilon eventually include crucial finite subgraph 
times uses approximation upsilon select identity process approximation upsilon includes crucial finite subgraph selected process forever 
time correct processes trust correct process exactly omega requires 
say process correct crashes correct crashes simplicity assume process sees value enforced tagging counter value seen 
rest chapter refer run consensus mean run consensus furthermore consider schedules consensus write consensus denote step 
dag forest failure pattern corresponding failure detector history hd fixed infinite directed acyclic graph properties 
vertices form pi vertex time hd time crashed value failure detector module 

edge hd hd 
transitively closed 

correct process finite subset vertices failure detector value vertices edge note dag represents sampling failure detector values occur hd particular require contain values occur hd relate edge values time occur 
property implies dag contains infinitely samplings failure detector module correct process 
lemma finite subset vertices infinite path ffl edge vertex vertex ffl gamma vertex correct correct infinitely vertices gamma proof repeated application property 
finite infinite path schedule compatible length possibly null messages say compatible compatible path initial configuration consensus define simulation tree upsilon induced follows 
vertices upsilon finite schedules compatible applicable root upsilon empty schedule 
edge vertex vertex delta step edge labeled finite infinite path upsilon associate unique schedule consisting sequence labels edges path 
note path starts root upsilon finite schedule associated vertex path 
lemma schedule associated path upsilon starts root schedule compatible applicable proof lemma obviously holds finite schedule immediate definitions 
infinite schedule 
define delta general gammai delta assume compatible applicable show schedule associated path upsilon starts root 
see note finite schedule compatible applicable schedules gamma vertices upsilon gamma delta edge gamma labeled 
schedule associated infinite path gamma upsilon path starts root sequences finite delta denotes concatenation sequences 

assume schedule associated infinite path upsilon starts root 
show compatible applicable note vertex upsilon compatible applicable compatible contain path 
note delta extension path contains infinite path compatible furthermore applicable definition applicability infinite schedule applicable compatible applicable lemmata show finite infinite paths upsilon correspond partial runs runs consensus initial configuration lemma schedule associated finite path upsilon starts root 
sequence times hf partial run consensus proof lemma applicable compatible compatible finite path property applied vertex path sequence times hd 
property applied edge path sequence increasing times definition hf partial run consensus lemma schedule associated infinite path upsilon starts root 
correct process takes infinite number steps message sent correct process eventually received sequence times hf run consensus proof similar lemma 
lemmata show richness properties simulation trees induced lemma initial configurations vertex upsilon applicable vertex upsilon proof follows directly definitions 
lemma vertex upsilon correct process 
message message buffer addressed null message 
child delta upsilon proof definition upsilon compatible finite path applicable denote vertex property edge delta path delta compatible remains show delta applicable applicable suffices show applicable 
true hypothesis message buffer addressed null message 
lemma vertex upsilon process 
message message buffer addressed null message 
descendent delta upsilon vertex path inclusive delta upsilon proof vertices upsilon delta compatible finite paths delta delta delta delta respectively 
property transitive closure delta delta path delta compatible path show delta applicable vertex upsilon vertex upsilon applicable obviously applicable 
suppose delta vertex upsilon applicable message buffer 
message sent message buffers edge type gamma path message buffer applicable 
lemma vertices upsilon finite schedule containing steps correct processes 
delta vertex upsilon correct processes decided delta 

applicable delta vertex upsilon proof vertex upsilon compatible finite path applicable similarly compatible finite path respectively lemma applied vertices infinite path properties 
edge vertex vertex 
delta delta delta infinite paths 

gamma vertex correct correct infinitely vertices gamma show construct required schedule consider infinite sequence schedules constructed algorithm 
easy induction shows applicable compatible delta delta delta prefix path delta vertex upsilon consider infinite path upsilon starts root upsilon goes infinite fs compatible applicable ig repeat forever th vertex path oldest message addressed message buffer gamma message exists gamma delta fs compatible delta delta delta applicable ig generating schedule delta compatible path delta upsilon schedule associated path delta delta delta delta note schedule delta delta delta compatible path property path correct process takes infinite number steps delta 
steps receives oldest message addressed message sent eventually received 
lemma hf run consensus termination requirement consensus finite prefix correct processes decided 
cases ffl prefix decisions irrevocable correct processes remain decided 
empty schedule required ffl prefix delta finite prefix compatible compatible prefix consider argument applies 
compatible delta compatible prefix delta path delta compatible delta applicable definition upsilon vertex upsilon argument holds remains show contains steps correct processes 
immediate property fact compatible prefix denote initial configuration consensus initial values initial values 
simulation forest induced set upsilon upsilon upsilon simulation trees induced initial configurations tagging simulation forest assign set tags vertex tree simulation forest induced vertex tree upsilon gets tag descendent correct process decided 
upsilon denotes tagged tree upsilon upsilon denotes tagged simulation forest upsilon upsilon upsilon lemma vertex upsilon tag 
proof lemma vertex upsilon descendent delta correct processes decided 
vertex upsilon tag bivalent tags 
vertex valent tagged valent similarly defined 
lemma vertex upsilon valent valent bivalent 
proof immediate lemma 
lemma ancestors bivalent vertex bivalent 
descendents valent vertex valent 
proof immediate definitions 
lemma vertex upsilon tag correct process decided gamma 
proof tag descendent correct process decided 
lemma hf partial run consensus decided agreement requirement consensus correct process decided gamma 
descendent correct process decided gamma 
lemma vertex upsilon bivalent correct process decided 
proof immediate lemma 
recall processes initial value initial value 
lemma root upsilon valent root upsilon valent 
proof show root upsilon valent 
suppose contradiction root upsilon tag 
vertex upsilon correct process decided 
lemma hf partial run consensus violates validity requirement consensus contradiction 
root upsilon tag 
lemma root upsilon tag valent 
symmetric argument root upsilon valent 
index critical root upsilon bivalent root upsilon gamma valent root upsilon valent 
case say index bivalent critical second case say critical 
lemma critical index proof apply lemmata roots upsilon upsilon upsilon critical index key extracting identity correct process 
fact critical shall prove correct lemma 
pivot 
root delta delta fork deciding process pivot 
root delta delta delta hook deciding process bivalent critical correct process focusing tree upsilon explained section 
hooks forks describe types finite subtrees upsilon referred decision gadgets upsilon type decision gadget rooted root upsilon exactly leaves valent valent 
common ancestor leaves called pivot 
pivot clearly bivalent 
type decision gadget called fork shown 
leaves children pivot obtained applying different steps process process deciding process fork step pivot determines decision correct processes 
second type decision gadget called hook shown 
pivot hook 
step delta leaf leaf delta delta process deciding process hook decision correct processes determined takes step shall prove deciding process decision gadget correct lemma 
intuitively crashes process taken step determines decision value 
existence critical hidden step core impossibility proofs starting flp 
case hiding difficult processes recourse failure detector despite hiding step deciding process decision gadget possible 
lemma index bivalent critical upsilon decision gadget deciding process 
proof starting bivalent root upsilon generate path upsilon vertices bivalent follows 
consider correct processes round robin fashion 
suppose generated path far turn process oldest message destined message buffer message exists take null message 
try extend path edge extension corresponds receiving target edge bivalent vertex 
path construction ends extension longer possible 
construction shown 
iteration loop extends path slight abuse notation identify finite path root associated schedule 

fs bivalent root upsilon repeat forever correct process round robin order oldest message addressed message buffer message exists descendent delta bivalent vertex upsilon delta fs exit generating path upsilon edge 
path generated iterations finite infinite depending loop terminates 
claim finite 
proof suppose contradiction infinite 
schedule associated construction correct process takes infinite number steps message sent correct process eventually received 
lemma hf run consensus construction vertices bivalent 
lemma correct process decides violating termination requirement consensus contradiction 
claim vertex clearly bivalent 
correct process round robin order loop terminates 
oldest message addressed message buffer message exists null message 
loop exit condition lemma imply descendents delta gamma 
lemma child delta upsilon delta 
loss generality assume valent 
valent valent pivot hook bivalent valent valent hook case fork case decision gadgets upsilon bivalent critical claim descendent delta valent vertex upsilon path contains edge labeled gamma 
proof bivalent descendent correct process decided 
lemmata valent 
cases 
path edge labeled gamma 
suppose message buffer receive path message buffer 
lemma delta upsilon valent lemma delta valent 
case required 
path edge labeled gamma 
edge path 
source edge 
delta 
delta valent descendent lemma delta valent 
claim consider vertex edge claim 
lemma vertex path inclusive delta upsilon vertices delta 
particular delta 
cases see 
delta valent 
delta valent upsilon fork pivot 
delta valent 
recall delta valent vertex delta 
path vertices parent delta valent delta valent 
upsilon hook pivot extracting correct process lemma critical index critical lemma shows extract correct process 
bivalent critical correct process applying lemmata 
lemma index critical correct 
proof suppose contradiction crashes 
lemma applied root 
upsilon finite schedule contains steps correct processes step correct processes decided 
index critical root 
upsilon valent 
correct processes decided 
gamma differ state applicable contain steps easy induction number steps shows applicable gamma state processes gamma 
lemma implies vertex upsilon gamma correct processes decided gamma 
root upsilon gamma tag 
critical root upsilon gamma valent contradiction 
lemma bivalent vertex upsilon valent valent descendents paths contain steps form gamma gamma correct 
proof suppose contradiction crashes 
lemma schedule containing steps correct processes step 
delta vertex upsilon correct processes decided delta 

delta applicable delta vertex upsilon delta correct processes assumed decided delta valent valent bivalent 
lemma loss generality assume correct processes decided delta 
refer 
steps path steps state process 
furthermore message addressed process message buffer message buffer 
applicable contain steps easy induction number steps shows applicable state process delta delta 
ii implies delta vertex upsilon correct processes decide delta 
tag 
valent contradiction 
lemma deciding process decision gadget correct 
proof fl decision gadget upsilon cases consider 
fl fork 
lemma deciding process fl correct 

fl hook 
assume loss generality pivot fl delta valent leaf fl delta delta 
bivalent delta delta delta delta delta valent valent lemma valent leaf fl see 
cases lemma correct 
suppose contradiction crashes 
lemma schedule containing steps correct processes step delta vertex upsilon correct processes decided delta 
valent correct processes decided delta 
ii 
applicable delta vertex upsilon delta parent state process 
furthermore message addressed process message buffer message buffer 
delta delta state process 
addition message addressed process message buffer message buffer 
applicable contain steps easy induction number steps shows applicable state process delta delta 
ii implies delta vertex upsilon correct processes decide delta 
receives tag 
valent contradiction 
may critical indices decision gadgets simulation forest 
lemmata may identify correct processes 
selection rule choose failure detector omega requires follows 
determines smallest critical index critical selects hand bivalent critical chooses smallest decision gadget upsilon encoding gadgets selects corresponding deciding process 
easy encode finite graphs natural numbers 
decision gadget just finite graph selection rule encoding 
method selecting correct process shown 
theorem algorithm selects correct process 
proof lemma critical index critical line returns lemma correct 
bivalent critical lemma upsilon contains decision gadget 
fl decision gadget upsilon smallest encoding 
lemma deciding process fl correct line returns identity process correct 
tag simulation forest upsilon induced gg upsilon simulation tree induced vertex upsilon descendent correct process decided add tag process tagged simulation forest upsilon smallest critical index critical return return deciding process smallest decision gadget upsilon selecting correct process reduction algorithm td omega selection correct process described distributed algorithm td omega seeking involves infinite simulation forest centralized 
turn distributed algorithm modify follows 
process cooperate processes construct increasing finite approximations simulation forest 
approximations eventually contain decision gadget tagging information necessary extract identity correct process chosen selection method 
note selection method involves stages construction graph representing samples failure detector values temporal relationship construction tagging simulation forest induced selection correct process forest 
algorithm td omega consists components 
component process repeatedly queries failure detector module sends failure detector values sees processes 
component enables correct processes construct increasing finite approximations interprocess communication occurs component call communication directed acyclic graph empty graph repeat forever receive phase receives failure detector query phase query failure detector send phase form add edges vertices output computation component sends pi process communication component component td omega second component process repeatedly constructs tags simulation forest induced current approximation selects identity process current simulation forest 
component require communication call computation component td omega communication component component processes cooperate construct increasing approximations denote current approximation roughly speaking process periodically performs tasks receives incorporates information replacing union 
ii process queries failure detector module 
value sees vertex currently clearly saw saw adds edges vertices 
process sends updated processes 
communication component td omega shown 
denote value time takes step time denotes value step 
lemmata establish certain useful properties graphs constructed communication component 
reading proofs results useful keep mind model phases step receive failure detection query send occur atomically single time lemma vertex contained local graph execution communication component 
graph contains 
process time 
saw time 
edge contained local graph execution communication component contained 

subgraph graph contains proof 
process adds line 
case result follows immediately 
case received message time graph contains process sent message graph time contradicting choice graph contain 
consider earliest time edge added graph say process definition time process receives message contains graph edge sender message graph contained edge time contrary choice part wanted 

suppose contradiction graph contains supergraph 
choose graph say 
definition clearly removes vertices edges graph 
time process receives message graph contains supergraph 
sender message graph contains supergraph time contrary choice 
recall considering fixed run td omega failure pattern failure detector history hd 
prove graphs constructed communication component omega satisfy certain properties 
reader note similarity properties graphs defined section 
lemma correct process time 
vertices form pi rd vertex time 

edge hd hd 
transitively closed 

time failure detector value vertices edge 

subgraph 
correct time subgraph 
proof property consider graph contains vertex 
lemma graph time saw time means taken step time seen hd wanted 
property lemma edge 
time inserted vertex course cases 
lemma graph time hypothesis case 
received graph containing time graph sent 
course lemma graph property path 
show edge 
time inserted induction show path 
basis trivial 
induction step suppose gamma gamma path gamma gamma 
gamma gamma edge lemma edge 
gamma gamma vertex lemma gamma gamma subgraph 
particular contains path gamma gamma 
path wanted 
vertices 
time adds edge vertex 
edge 
lemma subgraph contains 
wanted 
property vertex edge added removed 
property correct takes step time failure detector query phase step queries failure detector module obtains value say line step adds vertex edge vertices 
property subgraph result follows 
property correct eventually sends processes including occurs execution line time 
correct eventually receives replaces say time subgraph 
property lemma allows define 
property get lemma correct processes proof vertex edge time 
lemma time subgraph 
subgraph symmetric argument subgraph lemma allows define limit graph correct process properties lemma immediately imply lemma limit graph satisfies properties dag defined section 
upsilon denotes tagged simulation tree induced initial configuration upsilon denotes tagged simulation forest upsilon upsilon upsilon computation component limit graph properties dag apply centralized selection method identify correct process 
method involved ffl constructing tagging infinite simulation forest upsilon induced ffl applying rule upsilon select particular correct process computation component td omega approximates method repeatedly ffl constructing tagging finite simulation forest upsilon induced finite approximation ffl applying rule upsilon select particular process 
limit upsilon time upsilon information necessary select finite subgraph upsilon show eventually keep selecting correct process forever 
quite tagging method method requires knowing processes correct 
assigns tag vertex upsilon descendent decided 
correct eventually equivalent tagging method 
crashes care tags forest 
exactly selection method current simulation forest upsilon may critical index contain decision gadget eventually 
case just selecting 
computation component td omega shown compare selection method 
show upsilon simulation forest constructs increasingly accurate approximation upsilon lemma 
show tag simulation forest upsilon induced upsilon simulation tree induced vertex upsilon descendent decided add tag process tagged simulation forest upsilon critical index return smallest critical index critical return upsilon decision gadgets return return deciding process smallest decision gadget upsilon process computation component tags gives vertex upsilon eventually ones tagging rule gives upsilon lemma 
upsilon denote upsilon time upsilon finite simulation forest induced 
lemma correct time 
upsilon subgraph upsilon 
upsilon subgraph upsilon 
upsilon upsilon proof property vertex tree upsilon 
definition upsilon compatible path applicable subgraph path compatible applicable vertex upsilon subgraph graph equality relations ignore tags 
similarly edge upsilon 
vertices upsilon delta edge upsilon property follows lemma 
property show upsilon subgraph upsilon 
vertex tree upsilon upsilon definition upsilon compatible finite path applicable finite path time path 
compatible applicable vertex upsilon 
edge upsilon argument time vertices upsilon delta time edge upsilon vertex edge upsilon upsilon upsilon subgraph upsilon 
property upsilon upsilon lemma correct process vertex upsilon time tags upsilon tags upsilon proof suppose time assigns tag vertex tree upsilon means descendent upsilon decided 
lemma descendent upsilon correct tag upsilon 
conversely suppose vertex tree upsilon upsilon tag show eventually assigns tag upsilon tag upsilon descendent upsilon correct process decided cf 
tagging rule 
lemma descendent upsilon correct processes including decided 
lemma configuration partial run consensus agreement property consensus decided 
consider path starts root upsilon goes vertex lemma time path upsilon executes tagging rule time assigns tag upsilon decided descendent upsilon 
recall correct process obtained applying selection rule infinite simulation forest upsilon show time correct selects applies corresponding selection rule finite approximation simulation forest upsilon roughly speaking reason follows 
lemma time tags roots forest upsilon infinite forest upsilon tags determine sets bivalent critical indices time sets upsilon minimum critical index sets consider situation time critical selection rule selects case 
bivalent critical selects deciding process current minimum decision gadget upsilon 
case examined 
fl minimum decision gadget upsilon deciding process fl 
fl may minimum decision gadget upsilon may fl tags upsilon lemmata fl including tags eventually upsilon alternatively may upsilon contains subgraph fl encoding smaller fl fl looks decision gadget tags 
lemma eventually determine tags fl discover fl really decision gadget 
finitely graphs encoding smaller fl eventually discard fake decision gadgets fl smaller fl select fl minimum decision gadget 
time selects deciding process fl precisely case 
theorem correct processes time output forever 
proof denote critical index selected line applied upsilon lemma time init root upsilon tags corresponding root upsilon time init sets line 
show time computation component return cases 
critical 
case process line selection rule 
similarly time init sets line returns line 

bivalent critical 
fl denote smallest decision gadget upsilon case deciding process fl fl finite subgraph upsilon lemma time fl subgraph upsilon lemma time fl finitely vertices fl receive tags upsilon upsilon time fl fl decision gadget upsilon graph encoded unique natural number finitely graphs smaller encoding fl denote set graphs smaller encoding fl fl graph show time fl decision gadget upsilon cases fl subgraph upsilon case lemma fl subgraph upsilon fl subgraph upsilon fl smallest decision gadget upsilon fl smaller fl fl decision gadget upsilon lemma time fl finitely vertices fl tags upsilon upsilon time fl fl decision gadget upsilon finite time graph decision gadget upsilon consider process returned computation component time max init fl 
init sets line 
fl fl decision gadget upsilon 
fl smallest decision gadget upsilon 
bivalent time max init fl line returns deciding process fl time max init fl computation component returns time sets output forever line 
pieces needed prove main result theorem section theorem environments failure detector solve consensus omega gamma proof consider execution algorithm td omega environment theorem time correct processes set output forever 
theorem correct process 
td omega reduction algorithm transforms omega gamma words omega reducible discussion granularity atomic actions model incorporates strong assumptions atomicity steps 
phases step assumed occur single time 
particular failure process happen middle step 
allows associate single time step think step occurring time 
second send phase step message sent processes 
entire step indivisible means correct processes eventually receive message sent step 
steps occur time 
assumptions convenient formal model simpler describe 
consistent model flp provided impetus 
hand chapter model weaker properties 
phases step need occur may occur different times 
send phase messages sent different processes may sent different times 
failure may occur middle send phase resulting correct processes eventually receiving messages sent step 
actions different processes may take place simultaneously subject restriction message received strictly sent 
chapter mainly concerned showing various types failure detectors achieve consensus weaker model strengthens results 
fact negative results appendix hold model chapter stronger atomicity assumptions 
question naturally arises result applies weaker reflected formal model fact list times run indicate events run schedule occur increasing 
model 
words failure detector solve consensus weak model true transform model 
turns answer affirmative 
see note solves consensus weak model surely solves consensus strong model 
result transformed strong model 
remains show transformed weak model 
obvious conceivable extra properties strong model crucial transformation 
fortunately transformation chapter works weak model 
see sufficient sure communication component transformation cf 
section constructs graphs satisfy properties listed lemma run weak model 
difficult verify 
proof virtually fact distinguish time process queries failure detector time adds value saw proof assume weak model similar comments apply actions step longer assumed occur instant time 
changes proofs slightly cumbersome introduce notation different times relevant actions step take place reasoning remains essentially 
result merely fortuitous consequence choice model 
view robustness result different models asynchrony testimony significance failure detector 
problem confronted proofs lemmata refer graph vertex edge 
strong model difficulty processes execute steps simultaneously 
weak model justify sense speak graph contain vertex edge spite fact certain actions executed time 
fact message received sent needed 
weak consensus flp showed weak consensus problem solved deterministically asynchronous system 
weak consensus consensus validity property replaced weaker property non triviality run protocol correct processes decide run correct processes decide 
validity property explicitly prescribe conditions correct processes decide merely states possible reach decisions 
natural ask result holds weaker problem 
know holds theorem environments failure detector solve weak consensus omega gamma definition non triviality quite right 
shall argue problem really lies definition 
slightly stronger definition appropriate model incorporates failure detectors theorem true 
intuitively problem definition non triviality model failure detectors possible decision correct processes depend entirely values returned failure detector 
consider example failure detector failure pattern fh processes times words run failure detector returns binary value processes times independent run failure pattern 
trivial failure detector solve weak consensus process merely queries failure detector decides value returned 
easy see omega gamma environment provides absolutely information processes correct faulty 
point reader may justifiably object cheating really failure detector mechanism non deterministically chooses decision value 
possible way fixing problem definition failure detector general presently try prove theorem restricted definition failure detectors 
approach fraught danger restricting definition ruling legitimate failure detectors addition bogus ones intuitively failure detector supposed provide information faulty processes 
information may encoded complex way arbitrarily rule encodings doing may inadvertently ruling useful failure detectors 
modifying definition failure detector strengthen property require failure detector values seen processes determine decision value 
formalise run consensus algorithm schedule denote fd sequence sequence failure detector values seen processes consider relation runs fd fd 
immediate equivalence relation 
redefine non triviality property model processes access failure detectors follows non triviality equivalence class relation run protocol correct processes decide run correct processes decide 
captures idea decision value ascertained merely basis failure detector values seen processes 
depend fact solve consensus 
aspects run initial values particular messages sent features 
define weak consensus version non triviality theorem stated fact true 
briefly sketch modifications proof needed obtain strengthening theorem 
validity property proof lemma states root upsilon valent root upsilon valent 
turn proof lemma states critical index exists 
prove stronger theorem concentrate forest induced initial configurations just forest trees 
consider initial values processes initial configuration bit vector fix bit gray code 
gamma initial configurations listed order specified gray code upsilon tree upsilon gamma 
definition critical index index gamma critical root upsilon bivalent root upsilon valent root upsilon gamma valent 
difference take subtraction modulo gamma gamma gamma 
prove analogue lemma 
lemma critical index gamma 
proof claim forest contains nodes tagged nodes tagged 
see node tree forest 
lemma tag loss generality assume tag 
consider infinite path extends lemma fact tagged run weak consensus algorithm correct process decides 
non triviality run correct processes decide infinite schedule initial configuration bit gray code sequence possible bit vectors successive vectors vectors differ value position 
known codes exist 
run definition relation construction induced forest easy show finite prefix node upsilon correct processes decide nodes tagged 
nodes tagged nodes tagged lemma roots tagged roots tagged 
root upsilon tagged bivalent done 
roots trees valent roots 
exist gamma root upsilon valent root upsilon valent 
considering sequence upsilon upsilon upsilon addition modulo easy see root upsilon appears sequence valent root upsilon gamma valent 
definition critical index 
rest proof remains unchanged 
failure detectors infinite range output values failure detectors rb chapter output lists processes suspected crashed 
set processes finite range possible output values failure detectors finite 
chapter model allows failure detectors arbitrary ranges output values including possibility infinite ranges 
illustrate significance generality describing natural class failure detectors range output values infinite value output finite 
example apparent weakness formulation failure detection brief change value output failure detector module may go unnoticed 
example process module failure detector may output time time time due asynchrony system take step time may notice failure detector module briefly output natural way overcoming problem replace failure detector property maintains list suspects queried returns entire history list suspects time 
manner correct processes guaranteed notice change list suspects 
system continues executing values output grow size 
means infinite range output values 
function failure pattern encountered function described model 
result chapter applies natural failure detector infinite range output values 
open problems model process polls failure detector module time takes step 
conceive alternative model failure detector module interrupt process example issue interrupt time change list suspects 
know results apply model 
model specification failure detector allowable outputs depends failure patterns 
words set failure detector outputs allowed execution depends identity processes crash timing crashes execution 
studied general failure detectors specification depends aspects executions timing content messages state processes major problem needs resolved issue pursued identify aspects execution fair allow failure detector depend 
clearly failure detector allowed depend entire state system powerful practical value impossible implement 
recall allow implementation failure detector aspect execution local time order messages sent received 
thesis focused failure detectors systems crash failures 
extending results types failures omission cf 
msf pt arbitrary failures cf 
psl remains goal 
showed weaker failure detector solve consensus 
solve consensus environment weakest failure detector solving consensus environment 
appendix show solve consensus environments known weakest failure detector solving consensus environments exists provided properties 
chapter related partial synchrony fischer lynch paterson showed consensus solved asynchronous system subject crash failures flp 
fundamental reason consensus solved completely asynchronous systems fact systems impossible reliably distinguish process crashed merely slow 
words consensus unsolvable accurate failure detection impossible 
hand known consensus solvable deterministically completely synchronous systems systems clocks perfectly synchronised processes take steps rate message arrives destination fixed known amount time sent 
system timeouts implement perfect failure detector process wrongly suspected faulty process eventually suspected 
ability solve consensus system intimately related failure detection capabilities system 
realisation led augment asynchronous model computation unreliable failure detectors described thesis 
different tack circumventing unsolvability consensus pursued dds dls 
approach papers observation completely synchronous completely asynchronous models distributed systems lie variety intermediate partially synchronous models 
particular dds defines space models considering key parameters admits favourable unfavourable setting 
instance parameters maximum message delay bounded known favourable setting unbounded unfavourable setting 
models corresponds particular setting parameters 
dds identifies minimal models consensus solvable 
minimal sense weakening parameter favourable unfavourable yield model partial synchrony consensus unsolvable 
space models considered dds delineates precisely boundary solvability unsolvability consensus provides answer question amount synchrony sufficient solve consensus 
dls considers models partial synchrony 
model assumes bounds relative process speeds message transmission times bounds known 
second model assumes bounds known hold unknown time 
models crash failures easy implement eventually perfect failure detector 
fact implement weaker model partial synchrony bounds message transmission times relative process speeds bounds known hold unknown time 
stronger corollaries implementation immediately gives consensus atomic broadcast solutions model partial synchrony fortiori models dls 
implementation proven 
process executes output pi delta denotes duration time interval qg delta default time interval cobegin jj task repeat periodically send alive message jj task repeat periodically pi output receive alive delta seconds output output fqg fp times suspects jj task receive alive output fp knows prematurely timed output output gamma fqg 
andg delta delta 
increases time period qg coend time implementation models partial synchrony 
process periodically sends alive message processes 
receive alive message process delta units time adds list suspects 
receives alive process currently suspects knows previous time premature 
case removes list suspects increases length time 
theorem consider system time bounds relative process speeds message transmission times hold assume value bounds known 
algorithm implements eventually perfect failure detector system 
proof sketch show strong completeness holds eventually process crashes permanently suspected correct process 
suppose process crashes 
clearly eventually stops sending alive messages time correct process receives message 
time correct processes time task receive message time 
algorithm clear time correct processes permanently suspect strong completeness satisfied 
show eventual strong accuracy satisfied 
correct processes time suspect possible cases 
process times finitely task 
correct keeps sending alive messages forever eventually receives message time point permanently removed list suspects task 

process times infinitely task 
note times adds output output added removed output infinitely 
process removed output task time occurs time period delta increased 
occurs infinitely delta grows unbounded 
eventually bounds relative process speeds message transmission times hold delta larger correct time bounds 
point time contradiction assumption times infinitely 
case occur 
failure detectors viewed modular way incorporating partial synchrony assumptions model computation 
focusing operational features partial synchrony parameters considered dds consider axiomatic properties failure detectors order solve consensus 
problem implementing failure detector specific model partial synchrony separate issue separation affords greater modularity 
studying failure detectors various models partial synchrony advantages 
showing consensus solvable specific failure detector show consensus solvable systems failure detector implemented 
algorithm relies axiomatic properties failure detector general modular simpler understand relies directly specific operational features partial synchrony implement failure detector 
point view question amount synchrony sufficient solve consensus translates weakest failure detector sufficient solve consensus 
contrast dds identified set minimal models partial synchrony consensus solvable able exhibit single minimum failure detector solve consensus 
technical device possible notion reduction failure detectors 
suspect corresponding notion reduction models partial synchrony possible complex 
models comparable general sense tasks possible vice versa comparable far failure detection concerned matters solving consensus 
connection useful recall earlier observation failure detector implemented different incomparable models partial synchrony 
application failure detection shared memory systems loui abu showed asynchronous shared memory system atomic read write registers consensus solved process may crash la 
raises natural question circumvent impossibility result unreliable failure detectors 
lo shows possible lo 
particular shows strong failure detector atomic registers solve consensus number failures 
shows systems majority correct processes sufficient eventually strong failure detector atomic registers 
isis toolkit isis programming toolkit building fault tolerant distributed systems bj 
isis employs asynchronous model distributed computing provides powerful primitives including atomic broadcast 
roughly speaking isis internal architecture 
lowest layer isis modeled asynchronous system failure detector 
higher layers isis lowest layer implement primitives including atomic broadcast 
section compare model lowest layer isis system 
approach correct process repeatedly suspected crashed processes required behave correct process system 
example atomic broadcast required deliver messages order correct processes 
furthermore prevented broadcasting messages messages eventually delivered correct processes including processes local failure detector modules permanently suspect crashed 
summary application programs unreliable failure detection aware information get failure detector may incorrect take information imperfect hint processes really crashed 
furthermore processes discriminated falsely suspected crashed 
isis takes alternative approach assumption failure detectors rarely mistakes rb 
cases correct process falsely suspected failure detector effectively forced crash group membership protocol removes groups belongs 
application failure detector distinguish faulty process really crashed correct forced 
essentially isis failure detector forces system conform view 
application point view failure detector looks perfect visible mistakes 
isis approach low level time outs detect crashes set conservatively premature time outs costly results removal process lead system shutdown 
contrast approach premature time outs failure detector mistakes deleterious delay application 
words pre example time period current version isis greater seconds 
mature time outs affect liveness safety application 
example consider atomic broadcast algorithm uses 
failure detector malfunctions messages may delayed message delivered order correct process removed 
failure detector stops malfunctioning outstanding messages eventually delivered 
set time periods aggressively isis practice set failure detector time periods closer average case isis set time outs worst case 
seen approach taken lowest layer isis system fundamentally different approach 
approaches achieve result augmenting asynchronous model computation failure detection mechanism practical 
interesting study higher layers isis built approach 
left subject research 
works fault tolerant computing time outs primarily exclusively purpose failure detection 
example approach algorithm adls pointed authors viewed asynchronous algorithm uses fault detection timeout mechanism 
appendix hierarchy failure detectors bounds fault tolerance preceding chapters introduced concept unreliable failure detectors mistakes showed solve consensus despite mistakes 
informally mistake occurs correct process erroneously added list processes suspected crashed 
appendix formalise concept study related property call 
informally process learns failure detector module mistake requires take corrective action 
mistakes define hierarchy failure detector specifications unify results refine lower bound fault tolerance section 
infinite hierarchy consists continuum failure detectors ordered maximum number mistakes 
mistakes define mistake 
hf run failure detector mistake time process process time begins suspect crashed 
formally mistake denoted tuple hr ti 
set mistakes denoted 
note erroneous addition counted mistake continuous retention count additional mistakes 
failure detector multiple mistakes process process repeatedly adding removing set practice mistakes caused premature time outs 
define types accuracy properties failure detector mistakes ffl strongly mistakes 
formally strongly jm ffl weakly correct process mistakes formally weakly hf correct ti hr ti gj ffl strongly finitely mistaken finite number mistakes 
formally strongly finitely mistaken finite 
case clear time stops making mistakes 
ffl weakly finitely mistaken correct process finite number mistakes formally weakly finitely mistaken hf correct ti hr ti finite 
case time stops making mistakes values properties mentioned powerful useful 
example suppose process permanently suspects process 
case failure detector gamma mistakes clearly useless provide information 
core problem failure detectors forced reverse mistake mistake obvious say process replies inquiry sent suspected crashed 
impose natural requirement circumvent problem 
consider scenario 
failure detector module process erroneously adds time subsequently sends message receives reply 
reply proof crashed time knows failure detector module mistake reasonable require irrefutable evidence mistake failure detector module takes corrective action removing general require property ffl correct process eventually knows time formally hf pi knowledge theoretic operator defined formally hm 
informally oe iff run time predicate oe holds 
say iff run time run time indistinguishable oe oe 
detailed treatment knowledge theory applied distributed systems reader refer seminal done hm 
recall section defined failure detector function maps failure pattern set failure detector histories 
specification failure detector depends solely failure pattern encountered 
contrast definition depends knowledge mistakes process 
turn depends algorithm executed communication pattern encountered 
failure detectors specified solely terms failure pattern encountered 
important property failure detectors satisfy 
rest appendix informally define hierarchy failure detectors differ accuracy maximum number mistakes 
just noted failure detectors specified solely terms failure pattern encountered fit formal definition failure detectors section 
hierarchy failure detectors define infinite hierarchy failure detectors 
failure detector hierarchy satisfies weak completeness types accuracy defined previous section 
name failure detectors accuracy property satisfy ffl sf denotes strongly mistaken failure detector sf consensus solvable iff sf consensus solvable iff gamma sf gamma gamma sf gamma consensus solvable iff sf consensus solvable iff sf sf sf wf wf wf consensus solvable iff wf weakest sf strongest consensus solvable consensus solvable hierarchy failure detectors ordered reducibility 
shows maximum number faulty processes consensus solved failure detector hierarchy 
ffl sf denotes strongly finitely mistaken failure detector ffl wf denotes weakly mistaken failure detector ffl wf denotes weakly finitely mistaken failure detector 
clearly sf sf sf sf sf similar order holds wfs 
consider system processes may crash 
system gamma correct processes 
sf gamma gamma fewer mistakes number correct processes correct process suspects 
sf gamma gamma weakly mistaken sf gamma gamma wf 
furthermore clear sf wf infinite hierarchy failure detectors ordered reducibility illustrated edge denotes relation 
failure detectors considered section equivalent failure detector hierarchy 
particular easy show observation ffl sf ffl wf ffl sf ffl wf example easy see reduction algorithm transforms wf 
conversions similar straightforward omitted 
note strongest weakest failure detectors hierarchy respectively 
corollaries observation corollary wf consensus atomic broadcast solvable asynchronous systems similarly corollaries observation corollary wf consensus atomic broadcast solvable asynchronous systems tight bounds fault tolerance consensus atomic broadcast equivalent asynchronous systems number faulty processes theorem focus establishing fault tolerance bounds consensus 
section showed failure detectors perpetual accuracy solve consensus asynchronous systems number failures 
contrast failure detectors eventual accuracy consensus solved majority processes correct 
refine result considering failure detector infinite hierarchy failure detectors determining correct processes necessary solve consensus results illustrated 
cases depending assume system majority correct processes 
weakest failure detector hierarchy solve consensus majority processes correct observation consensus solved failure detector hierarchy 
consider solvability consensus systems majority correct processes 
systems determine maximum consensus solvable sf wf 
show consensus solvable sf number mistakes equal gamma number correct processes 
show consensus solvable wf 
theorem suppose gamma strongly mistaken failure detector sf algorithm solves consensus sf asynchronous systems 
proof sketch describe behaviour strongly mistaken failure detector sf algorithm run ra sf satisfy specification consensus 
gamma partition processes sets pi pi pi crashed pi pi non empty sets containing gamma processes pi crashed possibly empty set containing remaining gamma gamma processes 
rest proof consider runs processes pi crashed crash run 
pi pi consider consensus algorithm runs sf ffl run hf processes pi propose processes pi pi crashed propose 
processes pi correct processes pi pi crashed crash run pi pi crashed process permanently suspects process pi pi crashed pi pi crashed 
process suspects process 
run clear sf satisfies specification strongly mistaken failure detector 
ffl run hf processes pi propose processes pi pi crashed propose 
processes pi correct processes pi pi crashed crash run pi pi crashed process permanently suspects process pi pi crashed process suspects process 
clearly sf satisfies specification strongly mistaken failure detector run 
assume loss generality satisfy specification consensus 
time decides time decides possible cases case construct run ra hf algorithm sf sf satisfies specification strongly mistaken failure detector ra violates specification consensus 

decides 
ra hf run identical processes pi pi crashed propose 
processes pi pi crashed crash right run ra indistinguishable decides ra violating uniform validity condition consensus 

decides 
case symmetric case 
decides decides 
construct ra hf follows 
processes pi propose processes pi pi crashed propose processes pi crashed crash fa run 
messages processes pi pi vice versa delayed time time identical processes pi crash slow take steps time time distinguish ra decides time ra 
note time failure detector sf gamma mistakes ra erroneously suspected processes pi crashed slow 
time construction ra continues follows 
time processes pi crash fa 
time time suspects processes pi pi crashed ha pi pi crashed process suspects process 
processes pi including failure detector mistake process 
time sf total gamma mistakes ra gamma sf mistakes ra time 
time processes pi wake 
time time execute exactly time time perceive real time shift 
time run ra decides time 
decide differently ra violates agreement condition consensus 
time onwards run ra continues follows 
processes crash correct process suspects exactly processes crashed 
sf satisfies weak completeness mistakes 
sf satisfies specification strongly mistaken failure detector run run uses sf violates specification consensus 
show lower bound tight sf consensus solved asynchronous systems gamma theorem gamma consensus solved asynchronous systems strongly mistaken failure detector sf 
proof suppose gamma number mistakes sf number correct processes correct process sf suspects 
sf satisfies weak accuracy 
definition sf satisfies weak completeness 
sf weak failure detector solve consensus corollary 
suppose gamma sf mistake correct process solve consensus majority processes faulty 
algorithm uses rotating coordinators similar 
similarity omit details appendix 
theorems corollary suppose consensus solved asynchronous systems sf gamma turn attention weakly mistaken failure detectors 
theorem suppose weakly mistaken failure detector wf algorithm solves consensus wf asynchronous systems 
proof theorem described failure detector solve consensus asynchronous systems easy verify failure detector mistake correct process weakly mistaken failure detector 
corollary theorem corollary suppose consensus solved asynchronous systems wf 
bibliography abd attiya bar noy danny dolev daphne koller david peleg reischuk 
achievable cases asynchronous environment 
proceedings eighth symposium foundations computer science pages 
ieee computer society press october 
amir dolev kramer malki 
transis communication sub system high availability 
technical report cs computer science department hebrew university jerusalem november 
adls attiya cynthia dwork nancy lynch larry stockmeyer 
bounds time reach agreement presence timing 
proceedings third acm symposium theory computing may 
kenneth birman robert cooper thomas joseph kenneth kane frank bernhard schmuck 
isis distributed programming environment june 
bgp piotr berman juan garay kenneth perry 
optimal distributed consensus 
proceedings thirtieth symposium foundations computer science pages 
ieee computer society press october 
bgt gopal sam toueg 
early stopping distributed bidding applications 
proceedings fourth international workshop distributed algorithms 
springer verlag september 
press 
bj kenneth birman thomas joseph 
reliable communication presence failures 
acm transactions computer systems february 
ofer shlomo moran shmuel 
combinatorial characterization distributed tasks solvable presence faulty processor 
proceedings seventh acm symposium principles distributed computing pages august 
bw 
fault tolerant decision making totally asynchronous distributed systems 
proceedings sixth acm symposium principles distributed computing 
cristian raymond strong danny dolev 
atomic broadcast simple message diffusion byzantine agreement 
proceedings fifteenth international symposium fault tolerant computing pages june 
revised version appears ibm research laboratory technical report rj april 
cd benny chor cynthia dwork 
randomization byzantine agreement 
advances computer research 
cdd cristian robert jon 
fault tolerance advanced automation system 
technical report rj ibm research laboratory april 
cm chang maxemchuk 
reliable broadcast protocols 
acm transactions computer systems august 
cri cristian 
issues design highly available computing services 
annual symposium canadian information processing society pages july 
ibm research report rj july 
ct tushar deepak chandra sam toueg 
time message efficient reliable broadcasts 
proceedings fourth international workshop distributed algorithms 
springer verlag september 
press 
dds danny dolev cynthia dwork larry stockmeyer 
minimal synchronism needed distributed consensus 
journal acm january 
dlp danny dolev nancy lynch pinter eugene stark william weihl 
reaching approximate agreement presence faults 
journal acm july 
dls cynthia dwork nancy lynch larry stockmeyer 
consensus presence partial synchrony 
journal acm april 
fis michael fischer 
consensus problem unreliable distributed systems brief survey 
technical report department computer science yale university june 
flp michael fischer nancy lynch michael paterson 
impossibility distributed consensus faulty process 
journal acm april 
gopal ray strong sam toueg cristian 
atomic broadcast 
proceedings ninth acm symposium principles distributed computing pages august 
hadzilacos 
issues fault tolerance concurrent computations 
ph dissertation harvard university june 
department computer science technical report 
hm joseph halpern yoram moses 
knowledge common knowledge distributed environment 
journal acm july 
la loui abu 
memory requirements agreement unreliable asynchronous processes 
advances computing research 
lam leslie lamport 
implementation reliable distributed multiprocess systems 
computer networks 
lf leslie lamport michael fischer 
byzantine generals transaction commit protocols 
technical report sri international april 
lo wai kau lo 
failure detectors solve consensus asynchronous shared memory systems 
masters dissertation university toronto january 
lsp leslie lamport robert shostak marshall pease 
byzantine generals problem 
acm transactions programming languages systems july 
yoram moses danny dolev joseph halpern 
cheating husbands stories case study knowledge action communication 
distributed computing 
msf mohan strong finkelstein 
methods distributed transaction commit recovery byzantine agreement clusters processors 
proceedings sixth acm symposium principles distributed computing 
mul mullender editor 
amoeba distributed operating system selected papers 
centre mathematics computer science 
pbs peterson richard schlichting 
preserving context information interprocess communication 
acm transactions computer systems pages august 
pgm frank hector garcia molina 
reliable scheduling tmr database system 
acm transactions computer systems february 
pow powell editor 
delta generic architecture dependable distributed computing 
springer verlag 
psl pease shostak leslie lamport 
reaching agreement presence faults 
journal acm april 
pt kenneth perry sam toueg 
distributed agreement presence processor communication faults 
ieee transactions software engineering march 
rb ricciardi ken birman 
process groups implement failure detection asynchronous environments 
proceedings tenth acm symposium principles distributed computing pages 
acm press august 
rei reischuk 
new solution byzantine general problem 
technical report rj ibm research laboratory november 
sch fred schneider 
implementing fault tolerant services state machine approach tutorial 
acm computing surveys december 
john leslie lamport jack goldberg milton green karl levitt melliar smith robert shostak charles weinstock 
sift design analysis fault tolerant computer aircraft control 
proceedings ieee october 
