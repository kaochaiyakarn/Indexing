constrained dependencies michael maher school computing information technology griffith university maher cit gu edu au extend notions functional finiteness dependencies apply subsets relation specified constraints 
dependencies applications 
able characterize constraint domains admit polynomial time solution implication problem assuming np give efficient algorithm cases modulo cost constraint manipulation 
cases offer approximate algorithms 
outline applications dependencies analysis optimization clp programs database queries 
study constrained dependencies particular constrained functional dependencies cfds constrained finiteness dependencies 
cfds extend traditional notion functional dependency fd expressing functional dependency holds subset relation subset defined constraint 
example cfd relation expresses subrelation consisting tuples fourth argument lies range value functionally determined value main advantage cfds fds greater expressiveness 
consequently provide greater precision describing analyzing relations 
furthermore smooth interaction semantic knowledge relations represented constraints example lengths positive 
information may available directly definition relation integrity constraints approximation relation 
cfds provide framework exploiting information course analyses usually simply fds 
inference directly cfds constraints powerful common alternative representing constraints dependencies hold inference dependencies 
focus inference constrained dependencies particular solution implication problem 
greater expressiveness constrained dependencies implication problem correspondingly difficult 
research initiated ibm watson research center 
author address school computing information technology griffith university nathan queensland australia cases problem np hard show 
look tractable subclasses approximations 
keeping principles scheme try develop approach parameterized constraint domain 
able characterize constraint domains admit polynomial time solution implication problem cfds assuming np give efficient algorithm cases modulo cost constraint manipulation 
domains problem appears intractable provide tractable approximations 
slightly weaker results constrained finiteness dependencies 
closely related constraint generating dependencies general class dependencies includes cfds constrained finiteness dependencies 
provides elegant reduction implication problem validity problem constraint formulas suggest efficient algorithm cfds 
earlier related problems includes klug elkan 
give section unifying result complexity implication problem classes polynomial time solution implication problem 
cfds applications query processing constraint logic programming clp languages constraint databases data represented constraints see example conventional relational deductive databases 
investigate detail subsumption analysis takes advantage extra power cfds 
analysis generalizes analysis omit unnecessary subsumption tests bottom execution avoid unnecessary memoization top executions tabling 
optimization enabled cfds 
extend expand optimizations clp programs 
furthermore provided constraint solver complete certain sense cfds determine groundness information done logic programming 
cfds detecting query emptiness independent underlying database applications transaction scheduling recomputation materialized views 
applications semantic query optimization design database schemas knowledge discovery 
original finiteness dependencies determining safety queries determining queries involving infinite relations produce finite answer 
finiteness dependencies define class cdb queries trivial constraint solving needed computing answers 
constrained finiteness dependencies allow expansion class 
section provides brief overview notation terminology concerning constraints constraint domains 
inference rules cfds completeness result algorithm solving implication problem 
sections discuss inference finiteness dependencies 
describe subsumption analysis clp programs cdb queries outline applications 
describe applications cfds 
constraints notation notation definitions concerning constraints follow 
write denote collection distinct variables xn appropriate determined context 
constraint formula write denote free variables established free variables denotes similar formula free variables renamed disjoint set variables denotes substitution terms collection variables respectively write denote existential universal quantification 
write gamma gamma denote existential universal quantification variables write existential universal closure important notational convenience employ additional quantifiers abbreviations complex operations 
expression defined 
intuitively statement says value fewer distinct values holds 
example parent says object fewer parents 
particular equivalent expresses functional dependency note equivalent general 
deliberate confusion attributes relation variables expression xn 
set attributes variables 
consequently equivalently regard relation set tuples set valuations 
constraint holds tuple relation write equivalently write tuple values variables tuple fx delta delta delta similarly renamed denotes subset variables rename variables write gammai respectively gamma constraints consideration specified constraint domain 
definition signature sigma sigma structure class sigma formulas 
pair called constraint domain 
underlying domain values class constraints 
assume class constraints contains equations terms closed variable renaming conjunction 
constraint domain trivial contains constraints identically true false generally dealing clp constraints convenient assume closed existential quantification necessary dependencies consider introduce existential quantification 
note general class dependencies need closure existential quantification 
example constrained tuple generating dependencies need closure 
briefly mention useful constraint domains domains see domains linear arithmetic constraints integers rational number real numbers denoted lin lin lin respectively domain linear equations real numbers denoted herbrand universe function symbols sigma denoted sigma constraints equations terms sigma constraints may incorporate existential quantifiers similarly rt sigma rt sigma denote corresponding domains rational trees domain feature trees denoted feat set sorts set features element boolean algebra denoted bool free boolean algebra generated infinite set generators denoted bool important property constraint domains generally phrased form independence 
property investigated generality 
significance property optimization bottom execution clp programs discussed 
definition constraint domain independence negative constraints property constraints delta delta delta cn iff alternative formulation independence negative constraints emphasizes aspect property useful weakness disjunction constraint domains property 
delta delta delta iff constraint domains mentioned sigma rt sigma independence negative constraints property 
sigma rt sigma property sigma infinite sigma finite 
similarly feat property infinite 
clearly bool property 
lin lin lin fact domains elements linear ordering relation independence negative constraints elements variables gives counterexample independence 
similarly domain strict non strict ordering distinction draw relations constraints assume existence algorithms test properties constraints importantly test constraint implies 
way relation defined relevant results relevant application 
concreteness mind relations defined constraints possibly infinitely generalized tuples relations defined formulas constraints example maxfx yg composition conjunction disjunction 
class includes relations defined clp programs cdb queries 
constrained dependencies constrained dependency generalizes traditional dependencies functional dependencies expressing dependency applies entire relation subset tuples relation described constraint 
consider possibly infinite relation set variables attributes take values assume free variables constraints simplicity presentation assume constraints allowed constrained dependency language constraints underlying clp language cdb 
note useful different class constraints constrained dependencies clp language 
theoretical considerations extension straightforward practice difficulties necessary constraint solver handles classes constraints 
combination reasons including efficiency subset best choice 
definition constrained functional dependency relation variables attributes constraint domain form fpg constraint free variables intuitively expression denotes functional dependency holds subset tuples holds 
relation evident context omit constrained dependency 
conformity existing notation fds omit set notation expressing listing elements 
write fx fy constrained dependencies provide expressive flexible basis analysis constraint logic programs database queries traditional dependencies 
constraints directly account simply abstracting dependency information obtain accurate analysis 
furthermore happens dependency holds holds exceptions holds simply defined sub relation 
constrained dependencies provide ability express manipulate information ignored 
example consider relation defined functional dependency xy holds relation dependencies xz yz hold division function 
precisely take value value determined similarly second dependency 
weaker constrained functional dependencies xz xz hold 
situation constraint possible infer dependency xz example query fragment travel distance efficiency distance know travel relation distance functionally dependent values positive safely infer efficiency functionally dependent 
inference reasoning dependencies 
relations functions divided pieces functional relation piecewise functional 
example consider relation defined jxj takes absolute value functional dependency constrained functional dependencies execution constraint programming language encounters constraint jxj bound sign positive negative known expect implementation bind furthermore implementation combination simple constraint information cfds provides accurate groundness analysis simple groundness dependencies 
finiteness dependencies fin fin value finitely values relation value finitely values relation fact 
constrained dependencies useful conventional database setting arithmetic explicit constraints occur 
example consider database involving students courses instructors university 
relation describing courses contain attributes course identifier level instruction room time instructor generally attributes room instructor functionally dependent course identifier 
courses year high attendance unusual university offers class 
case functional dependencies hold constrained functional dependency instructor holds relation 
inference rules cfds enumerate inference rules constrained functional dependencies 
range subsets gamma ij denote fixed constraint domain fixed relation inference rules 
true 



gammai 
denote gammai gammai gammai gammai 
rules correspond armstrong axioms functional dependencies 
rule expresses simple closure property dependency holds constraint holds stronger constraint 
rule derived rules consider rule combine cfd generated rule 
armstrong axioms complete fds rules obvious extension armstrong axioms sufficient cfds 
rule generates cfds independent underlying relation hold consequence constraint 
example constraint see functional dependencies hold example inferred relation 
cfds called tautologies 
special case determines inferred 
rule special case rule 
condition rule amounts requiring expresses directly restriction functionally determined positions free reformulate gamma ij gamma ij naively stated gammai fails address correctly possibility 
write gammai rule allows constrained functional dependency inferred fragments 
conditions require possible tuple addressed new cfd addressed fragment including possible tautological fragment fragments overlap shown compatible consideration single fragment 
precisely valuation overlap cfd covers extensions fragments 
rule considered special case rule single input cfd rule special case input cfds 
conditions rule clearer consider rationale 
condition gammai consider functional fragments cover entire relation constrained verify union fragments produce non functional behavior value value union satisfies need consider values common fragments values satisfy gammai gammai 
verify non functional behavior require common value union fragments represented restricted contained fragment 
gammai holds common value note general constraint formula named purely notational convenience 
example consider relation real numbers defined jxj 
cfds combined infer take true fxg fyg rule 
equivalent false gammai satisfied 
furthermore main formula rule holds need consider remaining case 
gammai cc gammai cc equivalent equivalent true 
gammai equivalent equivalent occur main formula rule false course holds 
rule applies 
hand cfds rightly combined infer fyg fxg rule defined 
equivalent false need consider 
gammai gammai equivalent true equivalent true 
gammai equivalent main formula rule true false course hold 
rule takes account constraints variables may known explicitly relation defined constraints implicitly integrity constraints approximating relation constraints 
constraints say pure relation 
pure equivalent true case rule reduces rule 
cfd derived set cfds inference rules write write derived rules rule uses constraints true relation set constraints 
say relation satisfies tuple satisfies constraint say relation satisfies cfd functional dependency holds set tuples satisfy satisfies set cfds satisfies relation satisfies satisfies write empty write proposition states soundness inference rules 
proposition consider inference rules fixed constraint domain 
ffl ffl set constraints true applications rule proof suffices show inference rule sound 
rules straightforward 
examine rules closely 
suppose cfds hold relation conditions rule hold 
arbitrary tuples hold hold 
assumption solution gammai gammai 
conditions rule solutions case solutions application appropriate cfd condition arbitrary cfd holds rule suppose conditions hold relation 
tuples hold second condition hold third condition follows hold 
provide counter example condition 
inference rule hold rule sound 
notation restriction constraint 
rj 
cfd say denotes ff fg 
cfd cons denotes fd denotes fd ffd fg 
say tautology tautological iff holds relation containing variables 
derivation proof tree node labelled cfd node leaf labelled element consequence inference rules children including rule case node children 
derivation labels root tree 
minimal derivation derivation minimal number nodes 
properties tautologies restriction inference rules 
proposition cfd set cfds 

tautological iff inferred rule iff 
contains tautologies tautological 
relation satisfies iff rj satisfies 
relation satisfies iff rj satisfies iff rj satisfies 
iff 
rule cfd minimal derivation cons 
derivation tautology generated rule satisfies cons 
rule derivation tautology generated rule satisfies cons proof sketch 
clearly inferred rule soundness tautology 
remaining part proof uses contrapositive 
inferred rule negation formula rule hold valuation demonstrating truth negated formula construct relation hold 
tautology 

easy check input cfds inference rule tautological output cfd tautological 

rj set tuples satisfying 
cfd definition satisfies iff rj cons satisfies fd 
satisfies gj iff rj cons satisfies fd iff rj satisfies fact rj cons rj cons reasoning satisfies gj iff rj satisfies gj relations hold result follows 

clearly rule 
direction induction prove proof gj similar proof cfds constrained applying result constrained recall 

minimality ensures cfd derivation input cfd inference rule 
rules consideration input cfd infer cfd stronger equivalent constraint input cfds 
simple induction gives result 

derivation proof part required property 
initial applications rule needed produce 
applying technique proof part minimal derivation cons cons part 
subsection example plausible invalid inference 
example consider cfds may soundly infer example consider relation consisting tuples template relation hw zi 
original cfds hold tuples satisfy clearly hold completeness theorem expresses soundness completeness inference rules method inferring cfds pure relations constraint domain independence negative constraints property 
theorem consider inference rules fixed constraint domain independence negative constraints property 
cfd finite set cfds iff furthermore completeness holds rule omitted 
proof soundness shown lemma 
prove completeness contrapositive omitting rule 
part proposition rule omitted follows iff fd fc gamma largest set variables clearly tuple variables cfds defined yi list variables consider formula independence negative constraints formula satisfiable constraint holds rule contradicts maximality holds contradicts definition formula solution define relation tuples hv hv follows denote tuples consider cfd cfd hold iff hold particular cfds gamma hold construction suppose consequently hold hand suppose cfd hold hold tuples satisfy consequently variable gamma conclude contradicts maximality holds holds holds proof complete 
careful examination proof extend result 
weaken formula proof tuple constructed relation satisfies furthermore reasoning holds constraint domain independence negative constraints 
corollary consider inference rules fixed constraint domain 
cfd finite set cfds 
proof 
inference rules sound complete inferring important case linear arithmetic constraints independence negative constraints hold 
obtain weaker version theorem weaker notion independence 
constraint domain independence inequations property constraints conjunctions equations delta delta delta en iff lin lin property 
corollary suppose constraint domain lin lin cfd finite set cfds 
proof 
constraints equational inference rules sound complete inferring proof independence inequations domains play role independence negative constraints restriction equational constraints 
remainder proof 
simple corollary theorem see rules form minimal complete set inference rules pure relations independence negative constraints 
recall rule special case rule rule simulated rules 
cases independence holds obtain efficient algorithm inferring cfds modulo cost testing constraint implication 
constraint implication problem constraint domain problem determining problem major concern implementing concurrent constraint languages constraint languages incorporating delaying mechanisms 
note problem determining cfd tautology special case constraint implication problem tautology constraint domains discussed section ptime constraint implication problems lin lin arithmetic constraint domains tree domains sigma sigma rt sigma rt sigma feat 
lin lin independence negative constraints conditions stated definition 
theorem algorithm provide ptime solution cfd implication problem domains 
theorem independence negative constraints constraint implication problem solved polynomial time problem determining solved polynomial time 
algorithm basis theorem follows 
seen extension algorithm fds 
input algorithm finite set cfds cfd output statement indicating indicating 
denote closure respect fd fv fd vg 
defined algorithm 
algorithm implication problem 

tautology return 

return 

cons delete 
resulting subset 
replace fx vars xg gamma 
return return 
part algorithm lines checks simple special cases initializes variables second part lines removes set cfds useful inferring part proposition 
parts proposition need generate tautologies constraint part ignore constraints remaining cfds 
problem reduces generating closure similar algorithm 
third part algorithm line computes closure rules repeatedly closure rule closure rules closed 
note vars useful tautology 
exiting loop theorem algorithm determines fl denote maximal cost deciding constraint implication problem size denote maximal cost determining cfd size tautology 
upper bound complexity algorithm fl size ffg 
case elements normal unconstrained functional dependencies upper bound existing algorithms iteration loop performed cost testing implications tautologies constant 
cost line reduced incremental constraint solver 
initially constraint solver receives constraints variables added line corresponding equations constraint solver 
provided constraint solver detect implicit equations variables need perform distinct tautology test value vars 
case upper bound expressed fl represents cost processing initial constraints represents cost processing additional equation 
example demonstrate operation algorithm domain linear equations real numbers 
assume relation attributes set gh cd true true gamma ac ab cd refer constraint execution reaches line tests cons holds cfds second 
cfd eliminated form upper bound fl 
ease comparison similar algorithm inferring constrained finiteness dependencies section prefer account costs problems separately 
loop line entered fa bg 
closing fd line results fa gg 
easy see tautologies second constraints respectively 
line completed fa gg fc 
entering line second time generate fa gg cfd fa gg 
line find useful tautologies loop exited 
fc dg algorithm outputs 
cfd omitted second pass loop results fa gg consequently algorithm outputs 
note tautologies attributes need tested 
observe necessary interleave closure fd computation tautologies generate attributes need conclude turn implication problem constraint domains satisfy independence negative constraints 
key lemma concerns complexity extended constraint implication problem problem determining lemma suppose independence negative constraints 
extended constraint implication problem np hard 
proof independence negative constraints constraints choose minimized 
minimality assume replace reduce problem problem determining propositional formula disjunctive normal form dnf tautology 
propositional formula dnf propositional variables corresponding formula unnegated occurrences replaced negated occurrences replaced 


truth instance extended constraint implication problem 
show true iff tautology 
consider formulas defined 
solutions exist minimality observed soln denote set solutions tuple form solution 
represented note soln soln definition valuations map xng soln soln called binary valuations 
binary valuations correspond valuations propositional variables way true corresponds 
soln false corresponds 
soln 
choice evaluates true false propositional valuation iff evaluates true false corresponding binary valuation 
non binary valuation xng false true 
non binary valuation evaluates true considering binary valuations value true false clearly tautology holds valuations holds valuations 
tautology valuation propositional variables evaluates false 
consequently evaluates false corresponding binary valuation variables 
tautology iff evaluates true valuations 
special case lemma constraint domain lin shown 
constraint domains linear order van der meyden shown equivalent problem pi hard 
lemma extended constraint implication problem reduces ffl problem determining ffl problem determining proof reduce problem determining problems 
consist cfds assume simplicity relation tuples form yi 
clearly iff inferred rule 
furthermore second condition rule holds equivalent disjunct entailed 
iff soundness lemma relation satisfies satisfies suppose valuation holds consist tuples satisfies satisfy iff combining previous lemmas establish intractability general implication problem cfds 
proposition suppose independence negative constraints 
problem determining np hard 
summary independence negative constraints holds implication problem cfds ptime iff constraint implication problem ptime 
independence negative constraints hold implication problem cfds np hard 
theorem suppose np 
implication problem cfds constraint domain ptime iff independence negative constraints constraint implication problem ptime 
proof theorem independence negative constraints constraint implication problem ptime implication problem cfds constraint domain ptime 
proof converse parts 
proposition assuming np independence negative constraints implication problem cfds ptime 
reduction extended constraint implication problem implication problem cfds proof proposition constraint implication problem ptime implication problem cfds 
view intractability general problem resort incomplete practical algorithms 
algorithm implication problem discussed modified replacing line don know 
represents approximation ignores disjunctive reasoning 
cases cost testing constraint implication tautologies great approximate operations 
employ test correct identifying detect holds 
example linear arithmetic constraints test eliminate variables basis equations test resulting constraints occur approximation applied testing tautologies test tautology form constraint implication 
approximation previous algorithm delete cfds line accumulate fewer variables line 
replace occurrences don know 
resulting algorithm sound detecting cfd implication course complete 
different approximation original algorithm basis testing non implication case approximate test correct identifying replace occurrences don know 
resulting algorithm proceeds approximate test detect tautology 
compared original algorithm deletes fewer cfds line accumulates variables line 
approximate algorithm sound constraint domains independence negative constraints 
see approximate algorithm sound general consider example 
consist cfds true consider approximate test implication recognise true true true algorithm delete cfds terminate 
independence negative constraints rules form complete set inference rules 
reasonable expect addition rule gives completeness independence assumption 
conjecture consider inference rules fixed constraint domain 
cfd finite set cfds iff consequently rules form minimal complete set inference rules 
constrained relations information relation simply dependencies 
example database may know integrity constraints knowledge meaning data value attribute age non negative 
furthermore stored relation store limited data range values attributes optimize query processing 
know age data relation 
refer relations constrained relations knowledge really description relation constraint 
information relation may available form infinite family cfds constraints 
ideally achieve completeness cases 
unfortunately relation compact cfd consequence infinite set cfds consequence finite subset example shows 
example consider cfds constraint domain lin fx zg finite lack compactness occurs finite set constraints relation satisfies infinite 
example consider cfds constraint domain extends lin permitting disequality constraints 
fx zg fx yg finite expect inference rules complete infinitely pieces information relation 
done section consider completeness respect finite sets turns rule sufficient extend inference system complete pure relations inference system complete relations 
proposition inference system complete pure relations addition rule produces inference system complete 
proof finite set constraints denote conjunction 
claim iff infer completeness apply rule infer prove claim 
suppose rule true infer rule sound proposition suppose relation holds 
part proposition holds rj 
consequently case set constraints hold relation fixed proof proposition shows compile constraints cfds rule need example constraint domain lin relation satisfies infinitely non redundant linear inequalities tangent graph 
applied 
seen form partial evaluation 
constraints expected derived part inference procedure compilation approach appropriate rule 
finiteness dependencies symbol fin constrained finiteness dependencies distinguish dependencies constrained functional dependencies 
constrained finiteness dependency fpg 
fin denotes fixed valuation variables finitely values variables tuples satisfying valuation variables unconstrained dependencies known inference rules functional dependencies complete finiteness dependencies 
fact longer true constrained dependencies 
example consider finiteness dependencies 
fin 
fin validly infer finiteness dependency 
fin inferring functional dependency invalid relation fh gamma ig demonstrates 
second example consider dependency 
fin variables range integers 
finiteness dependency tautology corresponding cfd 
necessary modify rules 
rules section remain replacement fin 
denote gamma ij denote true 
fin 
fin 
fin 
fin 
fin 
fin 
fin 
fin gammai 
fin 
fin gammai 
fin 
fin 
fin rule combining fragmentary constrained finiteness dependencies rule considerably simpler constrained functional dependencies 
finiteness sets known property preserved finite union 
contrast corresponding property functional dependencies set empty singleton preserved finite union 
case conditions necessary guarantee result finite union empty singleton 
rule inferring constrained finiteness dependencies rule involves condition general expressed order statement underlying domain values domains discussed section condition decided quite simply see shortly 
adjustments inference rules results finiteness dependencies mirror closely functional dependencies 
particular algorithm previous section extends finiteness dependencies proviso tautologies referred finiteness dependencies 
hand completeness result employs extra condition comparison theorem 
define condition summarize main results theorem 
constraint domain representation elements constraints property element constraint valuation satisfies iff example lin property positive element represented delta delta delta delta delta delta equation similarly negative rationals 
hand lin property example define finitely equations inequalities 
theorem 
inference rules gamma sound inference finiteness dependencies 

inference rules gamma complete inference finiteness dependencies pure relations infinite constraint domains satisfy independence negative constraints representation elements constraints 

constraint domains algorithm implication problem finiteness dependencies complexity fl size ffg refers cost determining finiteness dependencies tautologies 

constraint domain infinite satisfy independence negative constraints implication problem finiteness dependencies np hard 
proof proofs observation proposition extends 

proof essentially proof cfds 

structure argument proof proof cfd version necessary construct infinite relation infinite subset finiteness dependency 
fin holds subset iff construct iteratively relation containing exactly tuples defined 

fin part proposition adapted rule omitted follows iff fd 
fin fc 
fin gamma largest set variables 
fin clearly tuple variables defined yi list variables need notation related property representation elements constraints 
eq denote constraint forces take value similarly eq denotes constraint forces tuple variables take values assume variables eq chosen distinct variables occurring formula eq 
consider formula independence negative constraints formula satisfiable constraint holds rule contradicts maximality holds contradicts definition formula solution denote purpose induction argument suppose tuples consider formula eq eq independence negative constraints formula satisfiable constraint eq eq eq contradicted existence solution contradicted solution induction hypothesis takes different value formula solution 
induction infinite relation containing tuples satisfies consider 
fin hold iff holds infinitely tuples follows construction guarantees suppose consequently hold hand suppose 
fin hold 
fin hold tuple satisfies consequently variable gamma conclude 
fin 
fin contradicts maximality holds holds holds proof complete 

analysis algorithm section applies 

proof essentially cfds lemma reduction extended constraint implication problem 
difference proof lemma construct infinite relation tuples ptime decision procedure implication problem provided constraint implication problem tautology problem ptime 
priori appears difficult problem 
wide class constraint domains show problem reduces problem cfds 
need definitions 
class constraints constraint equivalent existential quantification constraint say weak independence inequations iff conjunction equations 
example lin weak independence take independence result lin independence negative constraints 
similarly constraint domain sigma independence negative constraints sigma finite weak independence 
case take quantifier free subset condition constraints exactly independence negative constraints sigma 
clearly constraint domain independence negative constraints weak independence 
proposition infinite constraint domain weak independence inequations representation elements constraints 
constraint 

fin tautology iff tautology 
proof clearly tautological cfd tautological 
establish direction 
suppose 
fin tautology gammai valuation constraint valuation satisfies denotes tuple variables correspond variables appear constraint exists represent elements constraints 
represents valuation satisfy gammai clearly gammai gammai supposition satisfies gammai gammai gammai rearranging formula denotes tuple variables positions defined 
consider subclass constraints establish weak independence inequations 
express existential quantifiers bracketed expression moved outward universal bracketed expression expressed constraint weak independence inequations simplifying expressing differently gammai gammai symmetry statement true pair argument applies valuation gammai words tautology 
proposition applies constraint domains discussed section 
lin proposition apply reals defined constraint 
cases equivalence cfd tautologies shown directly convexity sets defined constraints constraint domains density elements domains 
corollary constraint domains rt rt feat lin lin tautology iff 
fin tautology 
course domain values finite example bool finiteness dependencies tautologies 
lin tautologies cfds differ example shows 
decidability tautology problem questionable domain 
observation variable constrained finite set values iff variable bounded 
condition rule reformulated requiring gammai yu fy formulation clear testing tautologies decidable lin general inference systems cfds different 
proposition similarities inference systems cfds identify large class constraint domains inference systems identical 
say inference systems isomorphic bijection oe mapping dependencies system dependencies dependency inferred rule dependencies oe inferred rule oe similarly inverse function oe gamma proposition infinite constraint domain independence negative constraints representation elements constraints 
fd denote inference relation rules fin denote inference relation rules denote corresponding cfds 
fd iff fin furthermore fd fin isomorphic 
proof isomorphism obvious function changes arrow fin clearly rules isomorphic 
proposition rules isomorphic 
independence negative constraints necessary condition equivalence inference systems property rules different inferences shown example 
general representation elements constraints necessary 
provides example 
currently clear condition omitted entirely 
note inference system containing cfds difficult inference systems separately 
inferring cfds cfds useful inferring functional dependency finiteness dependency 
proposition fix constraint domain 
respectively cfd respectively set cfds set 
conjunction constraints 
ffl iff ffl iff maps cfds corresponding 
proof 
relation satisfies satisfy backward direction established 
direction suppose necessarily infinite relation satisfies 
fin assume rj cc tuples value tuples value cfd valuation variables delete tuples satisfy step delete finitely tuples satisfies 
fin consequently resulting relation infinite satisfy construction satisfies satisfies tuples deleted 

backward direction trivial 
direction suppose relation chosen exactly tuples satisfies finite satisfies constraint generating dependencies complexity implication problem examined large range dependencies including constrained functional dependencies constrained finiteness dependencies called constraint generating dependencies 
definition constraint generating dependency takes form constraints relations contains expresses valuation tuple holds hold constrained functional dependency formulated 
containing fewer relation expressions called dependency 
false call negative integrity constraints 
true call approximation expressions 
classes permit expression properties relation conjunction relations specifically relation intersect set described relation contained set described properties basis approximate reasoning relations useful integrity checking databases analysis defined relations example database queries clp programs 
constraint domain fixed 
implication problem problem determining relation set holds satisfy 
shown expressed validity formula involving constraints appearing obtain complexity results assumption constraint language closed negation assumptions 
assumption implies independence negative constraints hold extend results follows lemma 
proposition suppose independence negative constraints 
implication problem dependencies np hard 
particular structure closed negation conjunction non trivial implication problem dependencies np hard 
proof proof reduces extended constraint implication problem implication problem dependencies 
fr ng 
iff result follows lemma 
tuple values assigned valuation result helps explain necessary consider classes constraints closed conjunction limiting number atomic constraints dependency obtain cases implication problem dependencies ptime 
shows find different finer classification dependencies find classes tractable implication problem 
close section classes 
implication problem classes addressed narrow range constraint domains respectively 
proofs results characterization 
results admit classes constraints closed conjunction 
shown cfds constraint domains satisfy independence negative constraints implication problem ptime characterization 
show classes specifically classes dependencies fixed characterization establish ptime solution implication problem 
proposition suppose independence negative constraints 
dependencies negative integrity constraints dependencies fixed total size constraints ffg 
implication problem solved jf jk fl time fl maximal cost solving constraint implication problem size 
proof proof uses characterization 
consider form 
associated formula ranges variable renamings formula denoted cf 
shown iff cf cf 
iff formula form 
valid derived derived false negative integrity constraints formula case form equivalently independence negative constraints equivalent jf jk constraint implication problems form implication problem addressed narrow range constraint domains 
similar proof result require independence negative constraints 
proposition dependencies approximation expressions dependencies fixed total size constraints ffg 
implication problem solved fl jf jk time fl maximal cost solving constraint implication problem size 
proof previous proof iff formula form valid conjunctions may contain omit details formula 
see 
subformulas 
true approximation expressions formula case form constraint implication problem 
classes restrictions respective propositions follows implication problem ptime iff ptime algorithm constraint implication problem 
results extend results dependencies atomic constraint dependency 
factors results come directly reduction 
noted dependencies symmetric factor reduced 
subsumption analysis clp programs fds define sufficient condition atoms generated logic program subsumed generated facts 
extend analysis clp programs 
extra power cfds supports accurate analysis clp programs show example 
main analysis detecting atoms subsumed 
applications analysis elaborated 
simplicity assume program rules written expanded form atoms contain distinct variables 
function defined multisets facts form complete lattice sub multiset ordering 
continuous informally copy element generated finitely elements fp rule rule facts renamed apart gamma gc denotes fixedpoint multiset facts derived resolution multiplicity fact number different ways derived see details 
simply write gc apparent context 
gcn denotes multiset facts derivable fewer steps multiplicity number distinct derivations 
write denote function rule program consisting fact 
facts considered equal iff gamma gamma say non overlapping 
overlapping 
say multiset facts non overlapping implies non overlapping element identity 
say subsumes iff gamma gamma subsumes strictly addition 
program subsumption free strict subsumption free non overlapping fact gc subsumed subsumed strictly overlapped remaining facts gc 
associate relation rule program follows ffl free variable occurring rule corresponds argument position hx list free variables order position ffl hd tuple valuation holds head body refer respectively set variables appear head set variables occur non constraint atom body theorem frg head body denotes functional dependence relation corresponding rule theorem program consisting rules suppose conditions hold ffl gc gc implies non overlapping ffl rule frg head body 
strict subsumption free 
condition strengthened ffl gc gc implies non overlapping gc non overlapping 
particular subsumption free 
proof part suffices show elements gc non overlapping 
induction induction hypothesis gcn non overlapping base case trivial 
suppose gcn overlapping unequal 
condition gcn rule body atoms constraint ik facts gcn produce 
assume facts variable disjoint suppose valuation holds valuations holds ij 
valuations exist consistent generated appropriate facts gcn valuations determine different tuples construct valuation 
agree head existence tuples contradicts second hypothesis theorem 
valuation described exist consistent induction hypothesis contradicts original supposition 
induction step established 
proof second part combines proof careful handling cardinality elements generated manner closely analogous proof theorem 
requires substantial notation terminology leave details interested reader 
constraint domain herbrand domain result reduces theorem corollary 
applications subsumption analysis bottom execution application extension 
bottom execution clp programs deductive newly generated facts tested subsumption order achieve termination greatest possible extent 
execution test fact subsumed existing accumulated facts 
test equivalent extended constraint implication problem constraint domain 
test np hard general lemma 
independence negative constraints holds repeated tests subsumption represent considerable overhead 
clp programs subsumption free 
cases subsumption test unnecessary overhead 
theorem detect cases 
example consider program multiplication integers 
mult 
mult mult 
mult mult 
expanded version mult 
mult mult 
mult mult 
strengthened condition theorem satisfied generates facts mult generates facts generates facts 
second condition theorem vacuous rule straightforward fact gammax implies functionally dependent similarly 
fact implies functionally dependent theorem program subsumption free 
argued class logic programs clp programs amenable analysis large 
similar arguments hold clp programs general 
programs exhibit significant speedups unnecessary subsumption tests removed 
expect greater speedups constraint domains subsumption tests typically expensive 
example consider program exponential function natural numbers exp iff exp 
exp 
exp exp expanded version exp 
exp 
exp exp 
condition theorem satisfied generates facts exp generates facts generates facts 
second condition theorem vacuous rules fact implies functionally dependent implies cfd xz combining constraint obtain unconstrained fd 
functionally dependent theorem program non overlapping subsumption free 
consider verification second condition theorem example 
infer unconstrained fd establish fd fds holding component relations 
extra expressiveness cfds necessary 
alternative formulation non overlapping ground atom successful derivation fixed computation rule 
cardinality analysis compute bound number solutions query able perform nonoverlapping analysis 
unfortunately implementation adapted easily provide non overlapping analysis 
implementation abstracts top depth execution may execute parts program contribute overlapping 
naive implementation unsound non overlapping analysis 
cases implementation detect sure nontermination clauses program exercised implementation provides sound nonoverlapping analysis 
fact examples successfully analyzed cardinality analysis domain conditional values domain cfds provides greater accuracy analysis things equal 
example consider program non overlapping real num undefined 
referee pointing 
bers 
mult 
mult 



difficulty analyzing program precisely analyses including cardinality analysis detecting called ground called ground cf 
example 
need represent effect mult cfd constrained groundness dependency see section xz combined accurately constraint determine employ inference expressed cfd represented explicitly analysis domain 
analyses domains admit conditional values cfds find difficult achieve similar precision additional techniques 
discussion points way extension analysis domains domain elements consider domain elements form constraint 
direction done 
top execution memoing second application systems employ top execution memoization tabulation answers calls predicates 
approach successfully logic programming deductive database systems 
xsb prime example 
systems calls placed table successful answers subsequent calls instances tabled calls executed table look 
similar techniques applied clp programs 
initial attempt 
clearly memoization pointless subsequent calls instances 
detect situation applying magic sets transformation original clp program magic computes calling patterns applying subsumption analysis magic magic subsumption free analysis call instance memoization omitted 
program correctness declarative approach showing strongest postcondition assertions logic programs developed 
approach uses fact strongest postconditions captured semantics certain circumstances semantics captured herbrand model semantics 
circumstances essentially program non overlapping 
examine extension approach clp programs 
strongest postconditions defined terms instances query extend clp define terms constraints 
take sp multiset answer constraints query program counterpart semantics gc thought multiset version ss semantics 
consequently strongest postconditions captured gc 
addition model program consider multiset version non overlapping programs multisets discussed fact sets 
situation logic programs non overlapping clp programs model different semantics 
restrict attention constraint domains language constraints closed existential quantification domain satisfies independence negative constraints gc captured model 
cases theorem apply approach clp programs 
applications mentioned potential cfds variety situations discussed uses cfds subsumption analysis 
outline applications 
ffl established cfds top clp systems optimize performance 
context logic programs proposes functionality information refine backtracking behaviour wise atom selections systems dynamic control 
applications extend clp programs 
furthermore cfds permits flexible approach applications 
cfd known procedure constraint cfd tested runtime depending result pass control code refined backtracking 
ffl groundness analysis detecting variables bound single value basis important optimizations execution clp programs database queries 
clp programs groundness information shows calls constraint solver replaced simple calculations 
plays important part making analyses efficient 
major input planning query execution indexing schemes require ground value index 
groundness analysis helps verify top execution query non floundering negation involved 
groundness dependencies logic programming essentially functional dependencies 
general applies inference constrained groundness dependencies cf 
example 
resulting groundness analysis useful constraint solving power execution reflected analysis 
may true constraint solver consider example programs fp gamma gamma fp gamma gamma 
model fp 
weak example incomplete unable detect equivalence cases constrained groundness dependencies subtly different cfds directly applicable 
dependencies groundness finiteness suspension demonstrated 
constrained dependencies provides ability precise analyses hinders efficient algorithms discussed 
ffl cfds offer different approach horizontal decomposition relations de bra 
decomposing relation maximal sense subrelation fd holds remaining tuples relation decomposed simple condition defined constraints 
approach flexible requires characterization constraints fd definitely hold relation example fail represent full collection tuples satisfy fd courses class 
hand results simpler updates relation method necessity transfer tuple subrelation tuple added deleted relation 
ffl cfds perform semantic query optimization queries relational databases 
simple example query satisfies cfd query simplified provided ffl elkan uses fds detect query emptiness examining underlying database 
cfds generally provide powerful flexible framework approximate queries detect query emptiness 
introduced constrained functional finiteness dependencies extended approach beeri bernstein solving implication problem fds dependencies 
large class constraint domains satisfying independence negative constraints property approach provides efficient solution cfd implication problem modulo cost constraint manipulation 
constraint domains class cfd implication problem tractable outlined tractable approximations 
constrained finiteness dependencies similar results class constraint domains remains open implication problem tractable 
independence negative constraints established class constraint domains implication problem intractable classes implication problem tractable 
outlined applications cfds mainly analysis optimization relational database cdb queries clp programs 
points way extension analysis domains domain elements consider domain elements form constraint 
dart marti shepherd anonymous referees discussions comments version 
apt declarative interpretations reconsidered proc 
th international conference logic programming 
armstrong marriott sndergaard boolean functions dependency analysis algebraic properties efficient representation proc 
static analysis symposium lncs 

hierarchy constraint systems data flow analysis constraint logicbased languages manuscript 
chomicki wolper constraint generating dependencies proc 
th international conference database theory lncs 
beeri bernstein computational problems related design normal form relational schemas acm transactions database systems 
le charlier van hentenryck cardinality analysis prolog proc 
international symposium logic programming 
codish dams bottom interpretation logic programs theoretical computer science 
chakravarthy minker foundations semantic query optimization deductive databases foundations deductive databases logic programming minker ed morgan kaufmann 
dart derived dependencies connected databases journal logic programming 
de bra paredaens horizontal decomposition handling exceptions functional dependencies advances database theory ii gallaire minker nicolas eds plenum press 
debray ramakrishnan interpretation logic programs magic transformations journal logic programming 
debray warren functional computations logic programs acm transactions programming languages systems 
elkan decision procedure conjunctive query disjointness proc 
th acm symp 
principles database systems 
elkan independence logical database queries updates proc 
th acm symp 
principles database systems 
falaschi levi martelli palamidessi new declarative semantics logic languages proc 
th international conference symposium logic programming 
levi modeling answer constraints constraint logic programs proc 
th iclp 
gao warren powerful evaluation strategy clp programs proc 
workshop principles practice constraint programming 
jaffar 
lassez constraint logic programming proc 
th acm symposium principles programming languages munich january 
jaffar maher constraint logic programming survey journal logic programming 
kanellakis elements relational database theory handbook theoretical computer science vol 
van leeuwen ed 
kanellakis kuper revesz constraint query languages journal computer system sciences appear 
preliminary version appeared proc 
th acm symp 
principles database systems 
kemp stuckey analysis constraint query optimization proc 
th international conference logic programming 
klug calculating constraints relational expressions acm transactions database systems 

lassez mcaloon canonical form generalized linear constraints journal symbolic computation 

lassez mcaloon constraint sequent calculus proc 
symp 
logic computer science 
maher logic programming view clp proc 
th international conference logic programming mit press 
maher ramakrishnan ej vu fixpoints logic programs proc 
north american conference logic programming cleveland october 
maher ramakrishnan ej vu fixpoints logic programs manuscript 
fuller version 
maher srivastava chasing constrained tuple generating dependencies proc 
th acm symp 
principles database systems 
marriott notes tutorial interpretation logic programs distributed 
van der meyden complexity querying indefinite data linearly ordered domains proc 
th acm symp 
principles database systems 
paredaens de bra gyssens van gucht structure relational database model eatcs monographs theoretical computer science vol 
springerverlag 
ramakrishnan bancilhon silberschatz safety recursive horn clauses infinite relations proc 
th acm symp 
principles database systems 
ramakrishnan personal communication 
sagonas swift warren xsb efficient deductive database engine sigmod record 
srivastava subsumption indexing constraint query languages linear arithmetic constraints annals mathematics artificial intelligence 
vardi fundamentals dependency theory ibm research report rj 
wang bettini brodsky jajodia logical design temporal databases multiple granularities manuscript 
zhang ozsoyoglu efficient reasoning implication constraints proc 
conf 
deductive object oriented databases lncs 
zhang ozsoyoglu results containment minimization equality queries information processing letters 
discovery analysis representation data dependencies databases knowledge discovery databases piatetsky shapiro frawley eds aaai press 

