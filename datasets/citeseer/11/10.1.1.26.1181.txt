address space sparsity fine granularity jochen liedtke german national research center computer science gmd jochen liedtke gmd de operating systems review january modified version th sigops european workshop th th september dagstuhl germany fully exploit potential large address spaces byte sparsity problem solved efficient manner 
current address translation schemes cause enormous space overhead page table trees support address space structuring object grouping mixed page sizes inverted page tables 
furthermore essential handicap current virtual address spaces coarse granularity 
restricts concept relevance low level os technology 
constraint mapping vertically integrating paradigm useful levels hardware application programming 
guarded page tables help solving problems 
permit significant extensions current programming model performance degradation sparse occupation coarse grain pages handled purely conventional hardware fine grain byte pages fine grain aliasing possible conventional cache tlb technology combined stochastically colored allocation 
unrestricted aliasing unlimited user level mapping performance degradation may possible hardware innovation 
motivation upcoming bit processors lead quantum leap virtual address space paradigm 
sized spaces proved convenient sufficiently powerful local tool problems 
sized spaces permit handle larger problems offer new possibilities means flat global address spaces 
promising paradigm distributed systems especially ob gmd rs sankt augustin germany ject oriented persistent ones supercomputers 
strong reasons move bit addressing bit address space revolutionary evolutionary respect way operating systems applications virtual memory 
chase eggers 
experimental single address space operating systems example opal similar design described 
system especially relies rich page protection facilities 
serious problem coming context sparsity 
byte address space sparsely occupied 
space 
learned history murphy expect systems applications real life tend unlimited sparsity 
imagine example complete usenet huge distributed databases mapped single address space 
sparsity essential architectures relying anonymity protection mechanism 
critical point supporting sparsely occupied huge spaces efficiency mapping mechanism 
currently address translation schemes explode space requirements support structuring 
need scheme tree efficient independent degree sparsity efficient existing ones 
conventional schemes meet requirements page table trees called multilevel page tables support sparsity inverted page tables support solely page abstraction obstruct grouping pages 
addition scheme restricts os architecture high page sharing costs permit mixed page sizes essential fine granularity 
sparsity strongly related granularity point view space page byte page look different 
sparsity address granularity 
fine grained address spaces potentially strong architectural impacts obvious fields object orientation example code generation data bases distributed systems supercomputers file systems multi media applications 
sparsity problem solved solely better address translation mechanism affecting hardware components fine granularity strongly interferes tlb cache system 
guarded page tables main problem multilevel page tables sparsity need huge amounts page table entries non mapped pages 
look example mapping page shown 
demonstration small addresses small page tables 
additionally assume pages mapped regions 
corresponding nil pointers marked ffl 
xxx qs delta delta delta delta delta delta qs data page sparse multilevel page tables 
second third level page table extremely sparse page tables contains single non nil entry 
consequently valid path tables leftmost bits remaining address bits addresses lead page faults 
shown omit page tables skip associated translation steps 
entry top level page table reached xxx qs delta delta delta delta delta delta qs data page guarded page tables 
check prefix remaining address 
prefix stripped translation process directly continue level page table 
entry augmented bit string variable length referred guard 
key idea guarded page tables 
translation process works follows page table entry selected highest part virtual address transformation step way conventional multi level page table method 
selected entry contains pointer access attribute guard prefix remaining virtual address translation process continues remaining postfix terminates postfix page offset 
example presents transformation address bits page tables 
note length gamma gamma gamma psi theta bn theta bn theta offset data page guarded page table tree guards may vary entry entry 
furthermore page table sizes mixed powers admissible 
holds data pages mixture entry page tables pages 
guarded page tables contain conventional tables special case guard length zero translation step works exactly conventional mechanism 
cases conventionally requiring table valid entry guard 
replace sequence single entry page tables 
saves memory capacity transformation steps guards act shortcut 
guarded page table algorithms implemented purely software 
non regular operations guard checking stripping substantially accelerated dedicated hardware 
parallel execution speed algorithm checking adjacent page table entries parallel doubles walking speed nearly minimal trees 
guarded page table mechanisms described detail 
sparsity guarded page tables advantages conventional page table trees support hierarchical operations sharing subtrees outperform inverted page tables cases see 
require maximum page table entries mapped page regardless pages allocated wide virtual addresses 
restricting operating system architecture guarded page tables solve sparsity problem bit systems page table overhead user data chosen mapping pages 
contrast conventional page table trees require overheads compact sparse pages 
sparsity problem addressed unique page size conventionally coarse grained overhead means user data requires additional megabyte page table data fragmentation 
axis denotes minimal object size 
byte objects expensive due fragmentation 
page size chosen way sum page table data fragmentation minimal 
note usually leads pages smaller minimal object size 
mpt entries bytes page tables ipt entries bytes occupied hash table assumed gpt entries bytes 
pages sufficient 
case guarded page table mmu integrated conventional processor changing tlb cache architecture 
fine granularity worst case memory overhead depending object size multi level mpt inverted ipt guarded gpt page tables shown 
note practice overhead lower 
guarded page tables support fine granularity better mechanisms 
detailed cost analysis worst case models contained 
object granularity 
mpt gaps 
mpt gaps 
ipt 
gpt worst case memory overhead fine granularity rely page table mechanism tlb cache architecture 
example difficult handle small pages todays favorite caches virtually indexed physically tagged 
may suspect performance degradation higher hardware costs due fine granularity 
combined stochastically colored allocation conventional caches virtually indexed physically tagged tlbs fortunately constructed perform conventional ones fine granular coarse granular case 
surprisingly combination permits larger caches conventional technology preserve system performance increase 
mpt overhead strongly depends sparsity 
scenarios shown gaps objects located consecutive aligned addresses gaps consecutive aligned ones 
visions fine grained aliasing higher demands cache system 
increases cache latency requires additional hardware base address caches virtually tagged cache supporting synonyms 
section highly speculative imagine unrestricted aliasing sufficiently cheap 
mechanism experiments user level mapping described 
guarded page tables obtainable granularity magnitude program variable explore techniques replace mapping parameter passing mapping 
example compiler assemble statically determinable sets parameters construct alias regions 
objects synthesized mapping 
database queries result mapping objects copying 
extremely useful distributed databases easily permits lazy evaluation queries 
extending guarded page table mechanism permits user programs manipulate mapping directly efficient user controlled aliasing object synthesis constructing alternate views parameter passing call possible 
facility enables user programs associate specific access semantics address space regions pages example delay read access variable value computed signal write access remote object invocation access proxies simply access protocol 
costs unrestricted fine grained aliasing clear possibilities amazing 
required exploration including construction really usable virtual machine appropriate kernel experiments code generators applications 
appel li 
virtual memory primitives user programs 
th international conference architectural support programming languages operating systems pages santa clara ca april 
carter cox johnson 
distributed operating systems protected global virtual address space 
rd ieee workshop workstation operating systems pages key fl april 
chase levy freely lazowska 
sharing protection single address space operating system 
technical report univ washington dept computer science seattle wa 
chase levy lazowska 
shared objects bit operating system 
oopsla pages 
chiueh katz 
eliminating address translation bottleneck physical address cache 
th international conference architectural support programming languages operating systems pages boston ma october 
heiser russell 
distributed single address space operating system supporting persistence 
scs report univ new south wales school computer science kensington australia march 
hosking moss 
protection traps alternatives memory management object oriented language 
th acm symposium operating system principles pages asheville nc december 
chase eggers 
architectural support single address space operating systems 
th international conference architectural support programming languages operating systems pages boston ma october 
liedtke 
theorems guarded page tables 
der gmd german national research center computer science gmd sankt augustin 
liedtke 
guarded page tables 
unpublished march 
liedtke 
mmu impacts system architecture 
unpublished june 
liedtke 
page table structures fine grain virtual memory 
ieee technical committee computer architecture newsletter pages xx xx xx 
published der gmd german national research center computer science gmd sankt augustin 
liedtke 
theorems restricted guarded page tables 
der gmd german national research center computer science gmd sankt augustin 
liedtke 
verfahren und zum einer eine 
deutsches unchen february 
patent application 
liedtke 
virtually indexed cache efficient synonym handling 
der gmd german national research center computer science gmd sankt augustin 
okamoto shin maeda saito 
micro kernel architecture generation processors 
usenix workshop micro kernels kernel architectures pages seattle wa april 
shapiro 
structure encapsulation distributed systems proxy principle 
th international conference distributed computing systems cambridge ma may 
anderson 
anonymous rpc low latency protection bit address space 
summer usenix conference pages cincinnati oh june 

