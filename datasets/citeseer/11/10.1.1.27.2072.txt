second look overloading proc 
fpca conf 
functional programming languages computer architecture martin odersky philip wadler martin study minimal extension hindley milner system supports overloading polymorphic records 
show type system sound respect standard untyped compositional semantics 
show typable term system principal type give algorithm reconstruct type 
arithmetic equality showing value string operations guaranteed give language designer 
usually dealt form overloading form best 
limit attention languages highly successful hindley milner type system nd di ering treatments overloading 
language may treat di erent operators di erently di erent languages may treat operator di erently language may treat operator di erently time 
instance miranda arithmetic de ned single numeric type equality polymorphic function de ned types including types breaks abstraction barrier show function may de ned user new types 
rst version sml equality simply overloaded monomorphic types second version introduced special equality type variables 
type classes introduced haskell order provide uniform framework overloading wb 
idea time come independently described kaes kae 
type classes attracted considerable attention re nements variants described ns np aug pj jon cho jon 
attracted criticism app 
view serious criticisms type classes program assigned meaning independent types 
consequence institut fur universitat karlsruhe karlsruhe germany mail odersky ira uka de department computing science university glasgow glasgow qq scotland mail wadler dcs gla ac uk celebrated properties hindley milner type system satis ed presence type classes semantic soundness result principal types result holds weak form 
semantic soundness result shows correspondence typed static semantics program untyped dynamic semantics 
summarised milner typed programs go wrong 
formulate result type classes untyped dynamic semantics exists 
principal type result shows typable program single general type 
true type classes 
utility result arises property hindley milner system typeable program remains typeable type declarations removed type declarations required 
fails type classes programs inherently ambiguous require type declarations disambiguation 
put way hindley milner program may meaning type classes program may meanings 
absence properties merely lack technical arise meaning program understood separately type 
reduces range ways understanding programs available programmer reduces range ways implementing programs available compiler 
restricting type classes simple restriction type classes may ensure program possesses meaning determined independently type 
recall type class limits type variable say range types operator de ned overloaded operator may involving examples representing simpli ed form parts haskell standard prelude 
class num neg frominteger integer class eq eq bool class text show string string read string instance rst states type belongs class num operators neg frominteger speci ed types de ned restriction follows type class variable overloaded operator type form may involve neg show satisfy restriction frominteger read 
remarkably simple restriction enables construct untyped dynamic semantics ensures ambiguity arise type soundness strong form principal types hold 
resulting system powerful handle overloading arithmetic equality showing value string powerful handle overloading numerical constants reading string value 
essential miranda sml support overloading sort kaes considered restricted form overloading original kae 
example value restriction consider phrase 
haskell phrase stands ambiguous meaningless disambiguate specifying type list elements 
meaning program translation eqlist eqlist equality lists equality list elements 
restricted system guaranteed phrase meaning independent valid translations yield meaning 
implementor choice overloading may implemented run time branching corresponding untyped dynamic semantics section compile time translation corresponding typed static semantics section 
case valid translation program eqlist undef undef function unde ned coherence guarantees program doesn force translation translation 
unrestricted haskell compiler writer choose translation dynamic semantics choose undef suitable coherence result 
restriction type classes ensures additional useful properties hold 
additional properties turn possible consider generalisation type classes 
generalising type classes type classes constrain type variables range types certain overloaded operators de ned 
appears closely related bounded polymorphism constrains type variables range types subtypes type cw 
type classes mimic bounded polymorphism usual subtyping relation records pet 
mimicry works monomorphic records type classes quite powerful handle polymorphic records 
instance expect operations xcoord ycoord apply record type contains elds instance apply type point containing just elds type cpoint contains elds plus colour 
mimic records haskell class pointed xcoord float ycoord float data point float float data cpoint float float colour instance pointed point xcoord ycoord instance pointed cpoint xcoord ycoord distance pointed float distance sqrt sqr xcoord sqr ycoord function distance computes distance point origin 
type signature optional may inferred class declaration function body 
note alas mimicry depends eld record having monomorphic type appear class declaration 
polymorphic equivalent operations second return corresponding components pair triple may restricted float 
way haskell 
source problem class declarations 
xcoord instances xcoord point float xcoord cpoint float arise instantiations class declaration xcoord float instances corresponding class declaration 
solve problem getting rid class declarations 
declaring group operators belong class specifying type declaration specify operator overloaded give declaration 
previous example new notation 
xcoord ycoord data point float float data cpoint float float colour inst xcoord point float xcoord inst ycoord point float ycoord inst xcoord cpoint float xcoord inst ycoord cpoint float ycoord distance xcoord ycoord float float distance sqrt sqr xcoord sqr ycoord type declaration distance may inferred body ignoring simplicity overloading sqrt sqr 
furthermore possible overload second polymorphic pairs triples 
second third inst inst second second inst inst second second inst third third demo second demo second function demo takes pair triple returns second rst components order 
type inferred 
short eliminating class declarations type classes powerful model bounded polymorphism 
eliminating class declarations means need longer decide advance operations belong class 
situations positive advantage 
instance re dealing pairs want second grouped re dealing triples ll want third 
example consider di culties haskell designers deciding group numeric operators classes 
design argued ring class 
problem exacerbated mechanism haskell user may break class smaller classes 
hand eliminating class declarations means inferred types verbose overloaded operator mentioned 
records provide relief allow group related operations common overloaded identi er 
explained detail section 
contributions combine restrictions generalisations type classes de ne system atype system overloading properties 
system possesses untyped dynamic semantics satis es corresponding type soundness theorem 
system strong principal types property 
necessary add type declarations disambiguate program 
type classes standard dictionary transform takes typed programs system equivalent typed programs hindley milner system 
system powerful model limited form bounded polymorphism records including polymorphic records 
believe system interesting alternative classes 
related 
overloading polymorphic programming languages rst studied kaes kae wadler blott wb 
similar concepts earlier symbolic algebra jt 
tradition kaes overloading restricted functions 
seen simpli cation system gets rid syntactic declarations predicates type classes 
extend scope proof type soundness relationship record typing 
overloading driven design implementation haskell type classes nipkow ns np type reconstruction augustsson aug peterson jones pj implementations hall hammond peyton jones wadler formal de nition type classes haskell 
compared system haskell 
generalisations haskell type classes proposed 
wadler blott jones consider type classes multiple type variables wb jon 
chen hudak odersky parametric type classes cho multiple type variables functional dependence imposed primary class variable dependent parameters 
parametric type classes model container classes records 
constructor classes generalize type classes type constructors jon 
constructor classes modeling containers operations mediate similar containers di erent element types 
consider important problem determine type system generalized type constructors 
systems discussed far implement open world approach empty classes instances considered legal 
approach works system separate compilation type checker complete knowledge instance declarations 
contrast closed world approach rou smi kae rules empty type schemes 
duggan support approaches distinguishing open closed kinds 
volpano vol argued previously known open world systems unsound 
volpano negative results arise works untyped dynamic semantics programs type classes 
argued permissible haskell programs 
proving type soundness respect untyped dynamic semantics system show volpano critique apply open world systems general 
alternative treatment regards special case dynamic typing typecase construct discriminate overloaded variants hm 
semantics lines studied thatte tha 
thatte semantics maps programs explicitly typed polymorphic language similar xml mh 
type classes denote sets recursive types language 
contrast semantics maps untyped language types type schemes denote ideals 
outline rest organized follows 
section presents syntax typing rules system section develops compositional semantics proves type soundness theorem 
section discusses dictionary passing transform 
section presents encoding polymorphic record calculus 
section discusses type reconstruction principal type property 
section concludes 
type system unique variables overloaded variables constructors dg variables terms ee programs inst type variables datatype constructors type constructors types arity type schemes constraints distinct xn taut tv base discussion simple functional language overloaded identi ers 
gives syntax terms types 
split variable alphabet unique variables ranged overloaded variables ranged data constructors ranged letter ranges unique overloaded variables constructors 
assume non overloaded variable bound program 
syntax terms identical language exp mil 
program consists sequence instance declarations term 
instance declaration inst overloads meaning identi er function arguments constructed type constructor type type variable function type datatype 
datatypes constructed datatype constructors simplicity assume value constructors selectors datatype prede ned bindings xed initial 
user de ned type declarations simply collect selectors constructors declared program 
kd set value constructors yield value types syntax system xn xn ee inst typing rules system set inst assume exists bottom datatype 
note type miranda written absent haskell value constructor written 
range datatype constructors function type constructor writing 
synonym type scheme consists type quanti ers type variables hindley milner polymorphism quanti ed variable comes constraint possibly empty set bindings variable appear constraint 
constraints restrict instance types type scheme requiring overloaded de ned types 
hindley milner type scheme regarded syntactic sugar de nes typing rules system type system identical original hindley milner system dm modi cations 
rule constraint introduced bound variable traded type scheme 
rule premise instantiation eliminated constraint 
constraints derived rule set 
note rules symmetric rules 
additional rule inst instance dec 
rule similar overloaded variable explicit type scheme required type constructor di erent instantiation variable range closed type schemes outermost argument type constructor 
tv ng tv tv explicit declaration rule inst necessary ensure principal types exist 
declare instance declaration inst type constructor overloaded determined uniquely 
syntactic restrictions type schemes enforce properties overloaded instances uniformly arguments type constructor 
second argument type determine result type uniquely 
constraints apply component types argument 
restrictions necessary ensure termination type reconstruction algorithm 
example section 
syntactic restrictions type schemes explain overloaded variables constraint pairwise di erent 
monomorphic argument function completely determines instance type function 
argument type overloaded variable instance type arguments type embodying rule form type variable constraints enforce earliest possible time 
example program fragment gives instance declarations equality function 
adapt notation haskell conventions writing typing writing writing inst inst inst int int bool bool bool true xs ys xs ys inst bool bool note directly second instance declaration instance declarations recursive 
extension system recursive instance declaration worthwhile omitted simplicity 
example example demonstrates object oriented style programming shows expressive haskell type classes 
write instances polymorphic class set member test operations compute union intersection difference sets 
haskell sets xed element type expressed 
example uses record extension section look explanation record syntax 
type set sa union diff sa sa member bool inst set bool set set xs union ys xs ys ys ys elem xs diff ys xs ys member elem xs inst set bool tree set tree set functions sets 
union set sa set sa sa sa sa union xs ys union set xs ys diff set sa set sa sa sa sa diff xs ys diff set xs ys set sa set sa sa sa sa xs ys union diff xs ys diff ys xs semantics give compositional semantics system show typings sound respect 
semantics speci es lazy evaluation functions overloaded functions strict rst argument 
alternatively assumed strict evaluation uniformly functions little change de nitions change results 
meaning term value cpo solution equation 
kv denote coalesced sums continuous function space 
value denotes type error pronounced wrong 
show meaning typed program di erent wrong 
meaning function terms 
takes arguments term environment yields element ofv environment maps unique variables arbitrary elements maps overloaded variables strict functions 
notation stands extension environment binding note semantics lazy detecting wrong terms milner semantics mil 
milner semantics maps function application semantics strict 
semantics correspond better dynamic type checking practice performed argument evaluated 
anticipate change results milner stricter error checking adopted 
give meaning types 
start types contain type variables called monotypes 
range monotypes 
mil injection projection functions sums generally left implicit avoid clutter 
mn mn arity ee inst extend extend extend kd arity semantics terms 
mps monotypes denote ideals 
purposes ideal set values contain closed limit closed 
elements directed set meaning function takes monotype ideal 
de ned follows 
fk 
mg ff fv proposition monotype 
isan ideal 
proof straightforward induction structure trying extend meaning function type schemes encounter di culty instances constrained type scheme depend overloaded instances environment 
accounted indexing meaning function type schemes environment 
de nition 
monotype semantic instance scheme environment written derived rules 

monotype de nition 
meaning closed type scheme de nition 
en ei meaning type schemes compatible meaning types proposition monotype environment 
proof direct de nitions show type schemes denote ideals 
proof needs facts bottom type 
lemma environment 

variable monotype 
type scheme 
proof assume 
constructors 
isa strict function element monotype 
follows de nition 
proposition scheme environment 
ideal 
proof closure properties shown straightforward inductions structure remains shown 
lemma monotype 
isan ideal contain proposition expresses important property semantics type scheme ideal contains type variable constraint explicitly declared instances 
consequently need rule atype scheme statically 
corresponds haskell open world approach type checking opposed closed world approach smi 
interestingly thing distinguishes approaches semantics type schemes absence presence bottom type 
show system sound syntactic type judgements re ected semantic type judgements de nition 
term closed closed type scheme 
environments implies rst step prove soundness theorem terms 
needs auxiliary lemma proof straightforward 
lemma theorem type soundness terms typing judgement substitution closed 
proof assume 
induction derivation show cases corresponding inference rules di er hindley milner system 
proofs rules similar treatment mil 
case step derivation tv taut uo tv uo show pick arbitrary de nition exists 
tv 
induction hypothesis follows lemma case step derivation show pick arbitrary induction hypothesis 
follows de nition lemma extend type soundness theorem programs contain instance declarations 
theorem type soundness programs valid closed typing judgement 
proof induction structure term result follows theorem 
instance declaration top level 
step derivation inst type scheme wehave show inst theorem implies function 
extend 
step show monotypes oi dictionary passing transform inst uo inst 
fv 
de nition extend fv 
cases fv 
arbitrary 
arbitrary implies follows furthermore contains premise rule inst binding wehavethat 
taken induction hypothesis implies proposition 
corollary theorem supports slogan typed programs go wrong 
corollary closed typing judgement environment 
proof immediate theorem proposition 
translation section studies dictionary passing transform system hindley milner system 
central idea convert term type function takes arguments implementations overloaded variables arguments called dictionaries 
target language translation hindley milner system obtained system eliminating overloaded variables instance declarations constraints type schemes 
translation terms 
formulated function type derivations augment type judgements additional component de nes translation term program ensure coherence translation assume overloaded identi ers oi type variable constraint fo ng ordered lexicographically 
types type schemes translated follows 

clause violates type syntax type scheme generated result part arrow 
compensated de ning def bindings translated follows 
uo translates overloaded variable new unique variable uo identity depends name type scheme derivation rule system corresponds derivation translated terms type schemes hindley milner system 
proposition valid valid hindley milner system believe translation preserves semantics sense 
conjecture program monotype environment 
contain overloaded variables 
claim clearly correct formal proof trivial 
note coherence translation follow immediately conjecture 
coherence property appears obvious notoriously tricky demonstrate blo jon surprising conjecture shares property 
relationship record typing section study extension type system simple polymorphic record calculus similar ohori 
details extended calculus 
add system record types fl ln ng record expressions fl ln eng selector functions easy add record updates ohori di cult handle record extension wand wan remy rem 
jones jon shown remy system extensible records extending uni cation ac theory records multi parameter type classes stating absence elds record 
updates extensions omitted simplicity 
leaving open moment type selector functions system far corresponds roughly way records de ned standard ml 
selectors treated standard ml overloaded functions 
overloaded functions type argument selector known statically isn overloading resolution error results 
record extension treats selectors overloaded functions uses overloading concept system general type scheme selector fl says applied records eld case yield value type type scheme uses subtype constraint subtype constraints validated subtyping rules 
respects behave just overloading constraints 
example program typable system typing max added convenience 
max bool 
key key max data ag data bg standard ml program typable argument type selector key argument type overloaded function statically known 
note bound variable subtype constraint appear constraining record type fl limited form bounded polymorphism cch limited calculus lacks subsumption contravariance rules associated bounded polymorphism cw 
remains seen suitable system modeling object oriented programming 
developments object oriented programming languages go direction restricting subtyping classes som 
show record extension adds essentially new language 
presenting encoding system records plain system source encoding program records assume labels ln record expressions fl ln eng source program sorted lexicographically just rearrange elds 
details encoding follows 

record eld label program represented overloaded variable called 
record expression fl ln eng program add fresh ary datatype rl ln constructor name selectors declaration data rl ln rl ln 
datatype rl ln created step label li add instance declaration inst li rl ln rl ln xn xi pattern notation formal parameter convenience 

record expression fl ln eng translates rl ln en 

selector function translates 
record type fl ln ng translated rl ln additional syntax subtyping rules field labels terms fl ln eng record types fl ln ng ln distinct types constraints taut fl ln ln ln kg rec fl ln ng additional typing rules fgi en fl ln eng fl ln ng 
subtype constraint fl ln ng overloading constraint ln result applying translation term atype scheme 
proposition proposition enables extend type soundness principal type properties system record extension having validate 
points implementation scheme records implementation scheme overloaded identi ers 
example program example translates inst data key key xy xin inst key key key xy yin max bool key 
key key max key key records help contain number overloaded identi ers type signatures 
idea put related operations record constructed single overloaded identi er 
example expresses shows model simpli ed num class way 
haskell syntax parentheses 
braces 
records 
type num plus minus neg num inst num int num int num 
num num neg num num extension record types 
fl 
plus num minus num neg neg num note similarity dictionary passing 
shortcoming scheme respect haskell class declarations concerns subclassing 
instance pass variable type num num function type num plus bool minus bool introducing full subtyping records may helpful supplement system way dealing common case 
experience required determine 
type reconstruction figures type reconstruction uni cation algorithm system compared milner algorithm mil extensions 
case binding type variable uni cation algorithm extended 
bind type variable type constraints satis ed 
function ensures type statis es constraints function tp extended branch instance declarations inst case checked inferred type overloading term general type state soundness completeness results algorithms unify tp 
proofs results lines che omitted 
abbreviations fo set type variables 
de nition 
con guration pair substitution dom 
unify 

unify case tv foldr foldr unify zip de nition 
de nes preorder substitutions con gurations preorder type schemes 
say general substitution 
dom 


case unify fo algorithm constrained uni cation dom dom implies de nition 
constrained uni cation problem pair tuples types isa con guration 
con guration called unifying con guration 
unifying con guration general unifying con guration 
de nition 
typing problem triple con guration term program fv dom 
typing solution problem triple typing solution general typing solution holds theorem constrained uni cation problem general unifying con guration 
fails exists unifying con guration 
theorem problem 
general solution 
fails solution 
corollary theorem get typable program principal type tp 
corollary principal types id problem tv 
assume gen tp id type schemes id fails type scheme case unify termination unify critically depends form overloaded type schemes 
tv ng tv tv show example needs parametric arguments consider program kt xy inst kx oy ky fx computation tp id leads call tp 
leads turn call unify assumptions hold fo tg substitution dom 
unfolding unify gives leads turn calls 
fo tg fresh type variable 
unify 
unfolding results attempt unify leads call unify 
equivalent original call unify modulo renaming unify loop situation 
need restrictions shown similar constructions 
remains seen general system feasible lifts restrictions extending uni cation regular trees kae 
shown modest extension hindley milner system support overloading polymorphic records limited form bounded polymorphism 
resulting system stays tradition ml typing type soundness principal type properties completely analogous hindley milner system 

new type variable 
new ary type constructor gen 
gen tv tv gen tp 
tp tp encoding polymorphic record calculus system indicates deeper relationships bounded polymorphism overloading 
suggested similarities dictionary transform type classes penn translation bounded polymorphism 
study relationships remains topic 
acknowledgments grateful kung chen john valuable comments previous drafts 
section records motivated part discussion led simon peyton jones mark jones haskell mailing list 
discussions numerous participants contributed 
app andrew appel 
critique standard ml 
journal functional programming 
aug lennart augustsson 
implementing haskell overloading 
proc 
acm conf 
functional programming languages computer architecture pages june 
blo stephen blott 
approach overloading polymorphism 
phd thesis department computer science university glasgow sept 
type reconstruction algorithm system tp new type variable tp fu tp ee tp tp new type variable unify tp gen tp tp fu tp inst gen tp unify de ned tp fo tg val breazu tannen thierry coquand carl gunter andre scedrov 
inheritance implicit coercion 
information computation 
cch peter canning william cook walter hill walter john mitchell 
polymorphism object oriented programming 
functional programming languages computer architecture pages september 
che kung chen 
parametric extension haskell type classes 
phd thesis yale university new haven connecticut december 
yaleu dcs rr 
cho kung chen paul hudak martin odersky 
parametric type classes 
proc 
acm conf 
lisp functional programming pages june 
cw luca cardelli peter wegner 
understanding types data abstraction polymorphism 
computing surveys december 
dm luis damas robin milner 
principal type schemes functional programs 
proc 
th acm symposium principles programming languages january 
dominic duggan john 
kinded parametric overloading 
technical report cs university september 
catherine dubois francois pierre weis 
extensional polymorphism 
proc 
nd acm symposium principles programming languages pages january 
cordelia hall kevin hammond simon peyton jones philip wadler 
type classes haskell 
proc 
th european symposium programming pages 
springer lncs 
hm robert harper greg morrisett 
compiling polymorphism intensional type analysis 
proc 
nd acm symposium principles programming languages pages january 
jon mark jones 
quali ed types theory practice 
phil 
thesis oxford university september 
jon mark jones 
theory quali ed types 
proc 
th european symposium programming pages february 
springer lncs 
jon mark jones 
system constructor classes overloading implicit higher order polymorphism 
proc 
acm conf 
functional programming languages computer architecture pages june 
jt 
language computational algebra 
proc 
acm symposium symbolic algebraic manipulation pages 
kae stefan kaes 
parametric overloading 
proc 
nd european symposium programming 
springer verlag 
springer lncs 
kae stefan kaes 
type inference presence overloading subtyping recursive types 
proc 
acm conf 
lisp functional programming pages june 
mh john mitchell robert harper 
essence ml 
conference record fifteenth annual acm symposium principles programming languages pages 
acm acm press january 
mil robin milner 
theory type polymorphism programming 
journal computer system sciences dec 
mps macqueen plotkin sethi 
ideal model recursive polymorphic types 
information control 
np tobias nipkow christian prehofer 
type checking type classes 
proc 
th acm symposium principles programming languages pages 
ns tobias nipkow gregor snelting 
type classes overloading resolution uni cation 
proc 
acm conf 
functional programming languages computer architecture pages august 
springer lncs 
atsushi ohori 
compilation method polymorphic record calculi 
proc 
th acm symposium principles programming languages pages january 
pet john peterson 
structures yale haskell 
draft 
pj john peterson mark jones 
implementing type classes 
proc 
acm conf 
programming language design implementation pages june 
sigplan notices 
rem remy 
typechecking records variants natural extension ml 
proc 
th acm symposium principles programming languages pages 
acm january 
rou francois 
safe run time overloading 
proc 
th acm symposium principles programming languages pages january 
smi geo rey smith 
polymorphic type inference languages overloading subtyping 
phd thesis cornell university ithaca ny august 
som clemens szyperski stephen omohundro stephan 
engineering programming language type class system sather 
programming languages system architectures pages 
springer verlag lecture notes computer science november 
tha satish thatte 
semantics type classes revisited 
proc 
conference lisp functional programming pages 
vol dennis volpano 
critique type systems global overloading 
computer science technical report naval postgraduate school october 
wan mitchell wand 
complete type inference simple objects 
proc ieee symposium logic computer science pages june 
wb philip wadler stephen blott 
ad hoc polymorphism ad hoc 
inproc 
th acm symposium principles programming languages pages january 
