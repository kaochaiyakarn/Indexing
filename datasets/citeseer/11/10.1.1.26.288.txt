secure composition insecure components peter sewell jan vitek software systems heterogeneous small number large programs established sources user desktop may consist smaller components interact intricate ways 
components downloaded network sources partially trusted 
user know number security properties hold personal data leaked net typically infeasible verify components behaved 
executed secure environment provides fine grain control allowable interactions components system resources 
study wrappers focusing expressed way enables security properties stated proved rigorously 
introduce model programming language box calculus supports composition software components enforcement security policies 
example wrappers expressed calculus explore delicate security properties guarantee 
software systems evolving 
increasingly monolithic applications replaced software components coming different sources 
small number large programs established suppliers nowadays user desktop smaller applications software modules interact intricate ways carry variety information processing tasks 
software base fairly static controlled system administrator easy download code network technologies java allow application program extended new components program running 
fluid operating environments traditional security mechanisms policies appear irrelevant 
passwords access control mechanisms adequate protect integrity computer system utterly fail address issue protecting user downloaded code run account 
approaches java sandbox promise security isolation satisfactory components interact freely 
needed finer grained protection extended appear proceedings th ieee computer security foundations workshop csfw italy june 
mechanisms take account interconnection software components specific security requirements individual users 
give small motivating example true story involving fictional character karen performing financial computation 
manage accounts downloads software package called quickest karen want information leaked consent run quickest environment allow access internet observed uploads information presumably marketing purposes 
hand needs stock quotes allow net access 
runs instances quickest isolated pc financial records connected obtain stock quotes 
transfers data second floppy disc manually ensuring information flows converse direction 
karen dispose isolated pc software solution prevent personal data leaked net 
quickest large piece commercial software programmed karen 
source code available internal behaviour complex inaccessible ensuring desired properties program analysis feasible 
run copies package secure software environments allow control information flow package net 
generally wish run packages trusted different ways want able dynamically control interactions packages resources net regions local disc terminal audio video capture devices cases wish log data sent wish limit allowed bandwidth disallow audio video channels 
general notion data considered sensitive context dependent 
web browser may choose consider mail address secret protected broadcast junk mail lists mail treated specially text editor 
feasible analyse modify large third party software packages possible intercept communications package parts system interposing code boundaries different software components 
possible monitor control operations components able invoke data exchanged 
call code fragment encapsulates untrusted components security wrapper wrapper short 
clearly task writing wrappers left solely user 
envision wrappers reusable software components users pick appropriate wrappers customize parameters install 
process dynamic wrappers harder add running system new applications 
user require clear description security properties wrapper guarantees 
wrappers compose clear notion properties preserved 
goal study secure environments focusing expressed way enables security properties stated proved rigorously 
appears wide range delicate properties making hard designers develop sufficiently clear intuitions rigour 
wrappers critical may small pieces software making feasible prove properties mild 
express reason wrappers require small programming language defined semantics allows composition software components expressed straightforwardly supports enforcement security policies 
language box calculus introduced 
simple example wrapper written calculus 
encapsulates single component controls interactions environment limiting channels 
written unary context def creates box new name installing parallel forwarders receives messages environment channel sends wrapped program receives messages wrapped program channel sends environment 
arbitrary program possibly malicious wrapped give design calculus ensures matter behaves wrapped program interact environment channels 
achieved simply forbidding interaction outside world unsatisfactory wrapper honest faithfully forwards messages 
informal properties precise propositions 
discuss sense wrapping behaved effect behaviour 
atypical behaviour forwarding legitimate messages reasonable unary wrappers may perform kind logging control interface wrapper 
honesty property hold reasonable wrapper somewhat delicate state security properties extensive labelled transition semantics calculus 
wrapper controls interaction single component environment 
second main example goes solving karen problem allowing control interaction components 
defined binary wrapper encapsulates components allowing interact environment limited way allowing information flow vice versa directed communication channel 
making precise subject 
chosen simple possible particular fixed interfaces components interact environment 
generalising arbitrary interfaces wrappers number components straightforward complicates notation generalisations discussed 
overview section introducing calculus giving operational semantics 
number wrappers defined including logs traffic 
basic properties honesty behaviour introduced 
information flows wrapped components studied conclude discussion related 
describes progress sections contain number conjectures proved hope stimulate discussion 
technical report extended version appearing computer security foundations workshop csfw 
boxed calculus language known box calculus studying encapsulation properties allow interacting components composed 
components typically executing concurrently introducing nondeterminism 
natural base language process calculus 
box calculus lies large design space distributed calculi build calculus milner parrow walker 
related calculi number authors 
brief overview design space highlight main design choices box deferring comparison related 
calculus asynchronous message passing components interacting exchange unordered asynchronous messages 
box asynchronous calculus build large body studying calculi notably 
known expressive supporting programming idioms including functions objects turing complete box process may perform arbitrary internal computation 
add primitives constraining communication standard calculi process send message way prevent information flowing reverse direction impose type system observed appropriate 
add boxing primitive 
boxes may nested giving hierarchical protection domains communication box boundaries strictly limited 
underlying calculus design principle box able control interactions children outside world 
communication allowed box parent process running particular box 
particular sibling boxes interact assistance parent 
enable box interact particular child boxes named analogously channel names 
security properties wrappers depend ability create fresh box names 
turning values may communicated convenient allow arbitrary tuples names tuples 
note allow communication process terms 
primitives movement boxes provided 
calculus entirely order important tractable theory behaviour labelled transition semantics require state prove security properties 
calculus untyped wish consider wrapping ill understood probably buggy possibly malicious programs 
syntax syntax calculus follows names take infinite set names ranged lower case roman letters 

boxes communication channels named names play role variables calculus 
values patterns processes interact communicating values pattern matching reception 
values names tuples patterns correspondingly tuple structured name hv tuple wildcard name pattern pk tuple pattern repeated names processes main syntactic category processes ranged introduce primitives groups 
boxes box name contain arbitrary process box names necessarily unique process consists distinct boxes named containing empty process parallel 
box named containing parallel nil process communication standard asynchronous calculus communication primitives xv indicating output value channel named xp process receive value output channel binding refine tag indicating direction communication box hierarchy 
input tag input box input parent box name input sub box named output tag similarly 
technical reasons allow output tag indicating output received parent interacted input indicating output received child interacted 
communication primitives output channel input channel replicated input replicated input behaves essentially infinitely copies parallel 
gives computational power allowing recursion encoded simply keeping theory simple 
names occurring pattern bind new name creation box channel names created fresh standard calculus operator 
declares free instances instances globally fresh name 
new name creation binds alpha conversion bound names writing free name function defined obvious way values tags processes fn 
reduction simplest semantic definition calculus reduction semantics step reduction relation indicating perform step internal computation define complement tag obvious way 
define partial function pattern value giving defined partial function names values 
fg xg fx vg hv defined undefined natural definition application substitution names values process term written partial operation syntax allow arbitrary values places free names occur 
write pgp result applying substitution pg may undefined pg undefined pg substitution application substitution undefined 
note result xgp applying name name substitution defined 
define structural congruence congruence relation axioms hold 
allows parts redex brought syntactically adjacent 
fn reduction relation relation processes satisfying axioms rules 
red comm red repl axioms subject condition pgp defined 
red red pgp red comm pgp red repl red par red res red box red struct red axiom allows output parent box cross enclosing box boundary 
similarly red axiom allows output child box cross boundary red comm axiom allows synchronisation complementary output input box 
red repl axiom similar preserves replicated input resulting state 
communications box boundaries take reduction steps example upwards downwards communications 
pgp pgp removes need way synchronisations box output input simplifying semantics implementation model 
labelled transitions reduction semantics defines internal computation processes 
statements security properties involve interactions processes environments requiring structure labelled transition relation characterising potential inputs outputs process 
give labelled semantics box explicitly indexed early style defined inductively process structure sos 
labels internal action output action input action ranges output tags 
labelled transitions divided involved moving messages box boundaries involved communications outputs inputs 
movement labels sending child box receiving parent sending parent say mv true form 
communication labels local output local input output received child input message received child output received parent input message received parent labels synchronise pairs 
labelled transition relation form finite set names fn read state names may known environment process 
relation xn par box res pgp pgp repl fn box fn yo yo res struct right box comm res rule subject fn res rule subject fn fn mv fn fn 
indexing elided rules involved interesting way 
rules forma implicit side condition fn repl axioms implicit side condition fv pgp defined 
symmetric versions par comm elided 
box labelled transitions defined smallest relation satisfying rules 
write fxg assumed union names occurring pattern assumed disjoint 
new binding labelled transition rules straightforward instances reduction rule red correspond uses box par instances red correspond uses comm box instances red comm correspond uses comm 
derivations corresponding transitions proof lemma 
addition new binding introduces subtleties inherited calculus related scope extrusion intrusion box boundaries 
discuss briefly 
red rule involves synchronisation box name channel name reductions new bound name enters box boundary 
correctly match transition side condition res labels output tag requires bound name occur channel value position comm rule binder right hand side 
similarly red rule allows new bound names channel position exit box boundary example res condition output tag requires bound name occur channel value position box rule binder right hand side 
reductions generated red comm involve synchronisation tags channel name 
res condition output tags analogous standard calculus open rule requiring bound name occur value tag channel 
comm rule output tags analogous standard rule particular guaranteed see lemma 
auxiliary notation useful 
sequence labels write mean pk ai pi write semantics coincide sense 
pk theorem fn iff pi ai fn 
defined give confidence labelled semantics carries information 
proof somewhat delicate appendix bisimulation statements relationships behaviour wrapped unwrapped program require operational equivalence relation 
box asynchronous appropriate notion weak asynchronous bisimulation 
consider family relations indexed finite sets names sa symmetric relation fn say weak asynchronous bisimulation sa sa fn output transition imply sa sa fn 
imply sa fn write union weak asynchronous bisimulations 
definition thoroughly tested particular proved congruence 
security wrappers section gives example wrappers 
encapsulates single component restricting interactions outside world communications obeying certain protocol 
second similar writes log communications 
third wrapper encapsulates components allowing interact outside world limited way allowing information flow second vice versa 
wrapper design context fixed protocol components communication environment 
wrappers fix channel names components receive send messages respectively 
assume components executed box communicating parent box 
trivial component receives values copies pairs hv vi output written hy yi malicious component write data illicit output channel available environment net hy yi eavesdrop communications parts system net express component obeys protocol terms labelled transition semantics say behaved unary wrapper iff lk lj form 
filtering wrapper filter wrapper simply restricts communication abilities process 
consider static filter allows interaction channels 
def executes component freshly named box installing forwarders move legitimate messages boundary 
note wrappers non binding contexts equivalently assume apply process new bound occur free implementation ensured probabilistically linear time scan 
irrespective behaviour obey protocol stated clearly labelled transition semantics proposition program fn lk lj form 
proof explicit characterisation states reachable labelled transitions 
proof properties appendices 
say unary wrapper property pure 
logging wrapper filter extended maintain log communications process sending copies channel log environment def log log wrapped program interact limited ways 
proposition program fn ln lj form log 
pipeline wrapper pipeline wrapper allows controlled flow information components 
give binary wrapper takes processes 
execution wrapped processes qi interact environment channels ini addition send messages channel mid 
pipeline implemented unordered 
def mid mid non binding context assume apply processes fa fn 
say binary wrapper pure iff programs satisfying appropriate free name condition fa fn lk lj form ini outi 
proposition pure 
example blocked attempt second process send value suppose mid mid mid mid parallel composition forwarders 
output mid final state interact environment restricted forwarder mid mid 
wrappers assume simple fixed protocol 
straightforward generalise arbitrary sets channels mid 
straightforward allow ary wrappers encapsulating components allowing information flow preorder 
generalisations discussed 
honesty composition properties wrappers stated previous section weak 
example unary wrapper def pure useless 
section identify class honest wrappers guaranteed forward legitimate messages 
gives authors components clear statement properties environment relied 
initial attempt take specification defining unary wrapper honest iff program processes operationally equivalent 
unsatisfactory rules wrappers give clear statement properties may assumed honest wrapper 
better attempt say unary wrapper honest iff behaved processes operationally equivalent 
unsatisfactory ways 
firstly intuitively sound wrappers additional interactions environment logging outputs considered honest definition 
secondly definition constrain behaviour wrappers non behaved component attempted error single illicit communication behave arbitrarily 
address points give explicit definitions honesty unary wrappers binary style weak asynchronous bisimulation 
consider family indexed finite sets names ra relation fn say bisimulation ra 
ra fn 
ra fn fn 
label fn symmetric versions clauses 
say unary wrapper honest program satisfying appropriate free name condition fn bisimulation ra loosely clauses symmetric versions ensure legitimate communications internal reductions weakly matched 
clause ensures wrapper performs additional communication affect state seen wrapped process 
proposition unary wrappers honest 
give examples dishonest wrappers 
take def honest transition matched violating symmetric version clause 
consider wrapper dishonest perform actions protocol essentially affect state example take hi 
suppose ra bisimulation hi hi clause hi ra clause hold left hand side perform hi transition matched right hand side 
def composition wrappers protocol communication component unary wrapper designed wrappers may nested 
conjecture composition honest unary wrappers honest 
conjecture honest unary wrappers honest 
analogous results non unary wrappers require wrappers complex interfaces input output mid channels connected correctly 
desirable property pure wrapper affect behaviour behaved component expect pure honest behaved fn 
unfortunately hold wrapper input transitions matched 
check behaved 
practice expect environment wrapper able detect inputs precise require operational equivalence relativised behaved environments 
simpler property multiple effect 
conjecture idempotent behaviour weak asynchronous bisimulation conjecture program fn fn 
honesty binary wrappers definition honesty binary wrappers take account mid communication 
consider family indexed finite sets names ra relation terms pairs terms free names contained say binary bisimulation ra clauses hold 
key difference unary definition clause clauses routine albeit notationally complex 

outi qi outi ra fn 

ini qi qi ra fn 

label ra fn 
qi 
qi ini fn ra 
outi ra fn ini ini ra fn ra fn 
mid ra fn mid 
binary wrapper honest satisfying appropriate free name condition fn exists binary bisimulation ra 
conjecture honest 
constrained interaction components motivating example karen required fine grain control information flows components binary case allowing unidirectional flow 
examining code intuitively clear achieves preventing information flowing 
comes intuition precise far clear exactly behavioural properties guarantees satisfactory wrapper user point view examine wrapper code 
honesty prohibit bad flows 
section give number candidate properties stating precisely informally 
conjecture satisfied equivalent 
entirely satisfactory hope provoke discussion exactly guarantees desired users component designers 
simplicity pure binary wrappers considered recall pure binary labelled transitions forms ini outi 
new name directionality calculus creation new names test wrapper supplying new name second component observing output component 
say directional new names fn new fn subsequently input component fn output component fn 
property prevent information flow variant containing reverse forwarder forwards particular values mid mid satisfy 
free names 
note binary wrapper intended limit information flow 
wish place constraint environment wrapper example forbidding environment copy values received 
restriction imposed measures waiting terminate starting acceptable desktop user 
programs essentially non terminating executing concurrently user prevented reading output copying 
circumstances explicitly supported desktop cut paste warning signal 
permutation second property formalises intuition observable behaviour due depends behaviour trace possible move actions associated actions associated 
say permutation property exists permutation kg transition occurs transition 
example wrapper property consider def mid mid messages forwarded input received environment 
sense information flow second component 
new name directionality permutation properties expressed purely terms externally observable behaviour fact properties trace set extensional semantics 
note intuitive statement information flow depends understanding internal computation reduction labelled transition relations way associate subterms origin 
properties involve intensional semantics output input processes tagged sets colours 
semantics propagates colours interaction steps tracking dependencies reductions 
coloured reductions take set col colours disjoint range subsets col define coloured box calculus annotating outputs inputs sets colours coloured term write jp term original syntax obtained erasing annotations 
conversely term original syntax denotes term particle coloured coloured write coloured term unioned set colours occurring 
write cd union reduction relation takes form coloured terms set colours indicating reduction depends 
defined follows structural congruence defined axioms 
red red cd cd fv pgp red comm cd cd pgp red repl red par red res red box red struct coloured calculus essential behaviour original calculus proposition coloured jp iff jp mediation capture intuition interaction wrapped components mediated wrapper 
consider coloured reduction sequences wrapper components initial state coloured differently 
gr bl rd distinct singleton subsets col suppose gr bl rd bl rd ii parallel composition messages ini terms form ini say mediating iff red cj blue cj green cj 
colour flow coloured semantics express property output depend second wrapped component 
say colour directionality property reduction sequence red example wrapper conjecture permutation property colour directionality property consider version extra parallel component 
establishes additional shot forwarder forwarding message 
statements mediation coloured directionality share defect reduction semantics awkward consider inputs values containing new names previously output wrapped components 
address need coloured labelled transition semantics allowing refined colour directionality property stated follows 
gr bl rd inputs properly coloured ci blue ci red outputs properly coloured red ci causality strong directionality property ask strongest execution output causally dependent action 
casual semantics process calculi studied name true concurrency semantics see overview 
interesting give causal semantics box calculus 
trade semantics complex understood order understand property stated 
coloured reduction semantics considered tractable approximation real causality 
point causal property strong usable wrapper may allow low bandwidth communication reverse direction carrying data values permit messages 
causal property hold modified colour flow property 
code base modern systems increasingly diverse 
previously typical system involve small number monolithic applications obtained trusted organisations users routinely download components partially trusted untrusted sources 
downloaded mobile code fragments commonly run user authority access system resources permit interaction software components 
presents obvious security risks secrecy integrity user data 
developed theory security wrappers 
small programs regulate interactions untrusted software components enforcing dynamic flexible security policies 
minimal concurrent programming language studying problem box calculus proved basic metatheoretic result reduction labelled transition semantics coincide 
expressed number security wrappers calculus begun investigation security properties wrappers provide 
related extensive literature information flow properties various kinds 
context multi level security fixed lattice security levels concerned properties state component expressed purely semantically set traces respects levels 
theory applied design components large multi user system relatively static security policy proving components obey particular properties 
concise survey mclean 
problem designing understanding wrappers appears different focussed protection required single user executing variety partially trusted components obtained third parties 
requires flexible protection mechanisms static assignment security levels inadequate depend static analysis components 
related dynamic enforcement policies schneider 
studied type systems ensure security properties type systems volpano irvine smith slam calculus heintze riecke systems allowing declassification myers liskov type systems hennessy proof carrying code :10.1.1.40.1122
producers components uses adopt systems may effective 
type systems provide flexible policies required partially trusted code practice run dangerously wrapped 
extensive techniques process calculi operational semantics 
provide fruitful ways studying problems security distributed systems including analysis security protocols example general secure language design including ambient calculus secure join calculus mobile agent calculi seal calculus 
works studied different problems variety calculi designed purpose 
common reduction labelled transition operational semantics providing clear rigorous semantics high level constructs involved 
distinguishing feature consider mobility primitives allowing tractable early labelled transition system 
appears important statement delicate security properties wrappers 
directions opens number directions pursue 
immediately gives conjectures proved refuted better understanding properties binary wrappers 
extensions typing richer interfaces mobility primitives 
typing primarily interested components infeasible statically determine behaved 
simple components conservatively ensure behaviour standard type system simply types box ht tk type channel names communicate values type obvious inference rules 
typed respect typing context types containing instances expect behaved unary wrappers 
richer interfaces wrappers allowed encapsulated components interact simple interfaces 
ultimately understand wrappers realistic interfaces 
example mild extension box express wrapper encapsulates components allows internal flow arbitrary preorder permits component open close windows character io 
suppose pk list distinct names preorder giving allowable information flow 
define ary wrapper follows 
def pk pk fwd def hs xi getc putc close xm putc getc putc hc yi ym close close ym uses additional input tag process input child box binding name box part receives requests new window encapsulated components forwards os 
receives interface new window os forwarding component setting forwarders interface channels 
making security properties precise challenging problem 
extend adding interface allowing user dynamically add remove pairs 
covert channels noted semantic models box calculus commitment precise details scheduling processes 
properties expressed semantics address timing covert channels mentioned lampson 
certain covert channels particular involving system io disc access addressed expressing models io disc systems calculus enriching wrapper interfaces 
mobility original motivation involved downloadable mobile code mobile agents 
explicitly model dynamic configuration wrappers applications calculus extended mobility primitives keeping tractable semantics principle box controls interactions movements contents 
sewell supported epsrc gr calculi interactive systems theory experiment 
authors bryce comments 
coincidence semantics appendix contains proof equivalence labelled transition semantics reduction semantics 
divided parts giving basic properties labelled transition system second showing reduction matched transition third showing converse 
basic properties lts lemma fn fn 
proof routine induction derivation lemma 
fn 
fn fn 
fn fn 
fn fn 
mv fn 
fn fn 

fn 
proof induction derivation part immediate cases implicit condition 
parts trans condition fn 
trans part fn pgp fn fn fn fn fn 
parts fn fn 
parts apply 
trans repl part fn pgp fn fn fn fn fn fn 
part fn fn 
parts apply 
trans box 
part fn fn fn fng fn fn definition fn fn fng fn fn fn ind hyp part fn fn fn fn ind hyp part fn parts apply 
trans box part fn fn fn fn fn 
part note fn 
parts apply 
trans box part induction hypothesis fn fn fn fn 
parts apply 
trans par induction hypothesis 
trans comm part parts induction hypothesis 
parts apply 
trans res induction hypothesis 
trans res part part induction hypothesis fn fn fn 
fn fn fn fn 
part induction hypothesis fn fn fn fn 
part induction hypothesis fn fn side condition fn fn 
part mv induction hypothesis fn side condition fn 
parts apply 
trans struct right induction hypothesis lemma 
lemma strengthening fn proof induction derivations transitions 
repl box immediate 
box par struct right straightforward induction hypothesis 
comm rule instance form fn comm lemma fn fn assumption fn fn 
induction hypothesis comm fn fn fn fn required 
box similar comm 
detail rule instance form fn box lemma fn fn assumption fn fn 
induction hypothesis box fn fn fn fn required 
res rule instance form res fn 
formed fn implies fn 
induction hypothesis res 
res similar res noting predicate label 
lemma injective substitution fn injective fp proof induction derivations transitions 
box immediate 
box par struct right straightforward uses induction hypothesis 
consider pgp fn pgp defined 
take fn ran fn pg defined pg defined dom ran pg defined shape 
pgf fn fn dom pgf pg fv pg fv pgp fv pgp 
repl similar addition 
comm fn 
take fn injective 
induction hypothesis comm fp fq fn comm lemma fn dom fn ran fn ran 
dom ran fn 
box similar comm 
fn 
take fn injective 
induction hypothesis box fp fp fn 
follows res take ran define 
box fn 
induction hypothesis fp res fp 
res define fn respectively 
induction hypothesis fp res fp lemma weakening strengthening fn iff fn 
proof right left implication follows formedness lemma 
left right implication follows condition fn definition transition rules lemma inclusion identity fn lemma shifting 
fn iff fn fn 
zn fn iff fn fn proof part inductions derivations transitions 
box box box comm res vacuous 
par struct right straightforward uses induction hypothesis 
repl straightforward 
res consider res fn fn fn fn fn res left right implication note fn induction hypoth fn fn 
right left implication note formed fn fn induction hypothesis fn 
second part repl box box comm res vacuous 
par struct right straightforward uses induction hypothesis 
box straightforward 
res similar res case part 
working alpha conversion little care required analysing transitions 
need lemma input restriction cases interesting 
lemma 
iff fn 
iff exists fn pgp defined pgp 
iff exists fn fv pgp defined fv pgp 
iff hold 
exist fn 
exist fn 
exists 

iff exists fn 
exists fn 
symmetric cases 

iff exists fn fn xgp 
exists fn fn xgp yo fn mv 
exists fn fn xgp fn mv proof right left implications shown single transition rule trans struct right 
left right implications shown induction derivations transitions 
input replicated input restriction cases interesting give just restriction case 
case lemma fn xgp fn xgp trans res xgp fn xgp trans struct right case proposition fn xgp fn xgp trans res xgp yo fn xgp trans struct right case proposition fn xgp fn xgp trans res mv xgp fn xgp trans struct right case def 
show closed rules defining labelled transitions 
trans res instance trans res form fn trans res fn defined fn fn 
fn xgp xgp reflexivity clause holds 
trans res instance trans res form yo yo mv fn fn trans res fn fn xgp clause holds 
trans res mv instance trans res mv form yo yo mv fn fn trans res mv fn fn xgp clause holds 
trans struct right instance trans struct right form trans struct right fn case exists fn fn xgp equivalence clause holds 
case exists fn fn xgp fn mv equivalence clause holds 
case exists fn fn xgp fn mv equivalence clause holds 
cases rules vacuous 
reductions imply transitions take size derivation structural congruence number instances inference rules contained 
lemma pgp defined pgp defined pgp pgp derivation derivation size pgp pgp proof obvious 
proposition iff proof induction size derivation symmetric cases show right left direction 
struct cong refl reflexivity iff 
struct cong sym symmetry iff 
struct cong tran induction hypothesis transitivity iff 
struct cong input consider lemma exists fn fv pgp defined fv pgp lemma fn fn 
lemma fv pgp defined fv pgp fv pgp pgp lemma 
struct cong repl consider lemma exists fn fv pgp defined fv pgp lemma fn fn 
lemma fv pgp defined fv pgp pgp pgp lemma struct cong box consider hold lemma case exist fn 
inductive hypothesis lemma case exist fn 
lemma fn fn 
clearly 
lemma case exists 
inductive hypothesis lemma 
struct cong par consider lemma holds 
case exists fn lemma fn fn 
inductive hypothesis lemma clearly case exists fn 
induction hypothesis lemma symmetric cases 
struct cong res consider lemma holds 
case exists fn fn xgp lemma xgp xgp derivation size 
induction hypothesis xgp lemma case exists fn fn xgp fn mv lemma xgp xgp derivation size 
induction hypothesis xgp lemma fn fn fn fn 
lemma case exists fn fn xgp fn mv lemma xgp xgp derivation size 
induction hypothesis xgp lemma fn fn fn fn 
lemma 
struct par nil struct par comm struct par assoc struct res res straightforward 
check axioms detail 
struct res par fn 
fact xgp fn fact xgq fn proofs part yield results form xgq get application trans struct right 
consider holds lemma holds iff case trans res exists fn fn xg lemma transition holds iff holds case trans par left exists fn xgq xgp xgq 
follows lemma trans par get xgq xgq 
lemma fn 
trans struct right obtain xgq xgq 
case trans par right exists fn xgp xgq xgp trans res fact fn get xgq trans par right get xgq fact fn trans struct right get xgq 
case trans comm exists xgp xgq fn 
fn xgp lemma fn 
fn trans res xgq fact fn lemma get 
trans comm xgq fn 
lemma fn may calculate fn fn case trans comm exists xgq xgp fn 
cases consider case lemma fn 
case fn lemma res xgq comm xgq fn 
lemma fn fn fn 
case fn lemma res xgq comm xgq fn clearly fn fn 
case lemma fn 
case fn exactly fn case 
case fn lemma res xgq comm xgq fn clearly fn fn 
case trans res exists fn fn xg yo fn mv lemma holds case exists fn xgq xgp yo xgq 
leads contradiction lemma fn 
case exists fn xgp xgq yo xgp apply trans res get xgq yo fn apply trans par right obtain xgq yo case trans res mv exists fn fn xg yo fn mv lemma holds case exists fn xgq xgp yo xgq 
leads contradiction lemma fn 
case exists fn xgp xgq yo xgp trans res mv facts fn fn mv get xgq yo trans par right get xgq yo consider lemma transition holds iff holds 
case trans par left exists fn take fn fn 
fn lemma trans par xgq xgq 
trans res xgq xgq 
fn xgq case trans par right exists fn lemma transition holds iff holds 
case trans res exists fn fn xgq trans par right xgq fn trans res get xgq 
fn trans struct right obtain xgq case trans res exists fn fn xgq yo fn mv trans par right xgq mv fn fn trans res get xgq case trans res mv exists fn fn xgq yo fn mv trans par right xgq mv fn fn trans res mv get xgq case trans comm exists fn 
lemma exists fn fn xgq lemma fn get trans comm xgq fn 
tran res fn obtain xgq xgq fn 
fn case trans comm exists fn 
lemma transition holds iff holds 
case trans res exists fn fn xgq lemma fn trans comm xgq fn 
tran res fn obtain xgq fn 
case trans res exists fn fn xgq fn mv lemma 
trans comm xgq fn 
tran res obtain xgq fn fn xgq fn 
case trans res mv exists fn fn xgq fn mv mv lemma trans comm xgq fn 
tran res xgq fn fn xgq fn 
struct res box consider lemma holds iff holds 
case trans res exists fn fn xgp lemma transition exists iff hold case trans box exist xgp fn 
cases consider case fn trans res fact fn ob tain xgp 
trans box obtain xgp fn 
fn fn fn 
case fn trans res mv fn fn obtain xgp 
trans box obtain xgp fn 
fn get fn fn 
case trans box exist fn xgp xgp 
trans box xgp zn xgp 
fn xgp xgp 
case trans box exists xgp 
trans res xgp trans box trans struct right xgp 
case trans res exists fn fn yo fn mv leads contradiction term output transitions 
case trans res mv exists fn fn yo fn mv leads contradiction term output transitions 
consider lemma holds iff hold case trans box exist fn 
lemma transition holds iff holds case trans res exists fn fn xgp trans box xgp fn 
trans res xgp fn 
fn obtain fn fn 
case trans res exists fn fn xgp fn mv hold mv 
case trans res mv exists fn fn xgp fn mv trans box xgp fn 
tran res xgp fn 
fn obtain fn fn 
case trans box exist fn 
take fn tran box obtain xgp xgp 
trans res get xgp xgp 
trans struct right fn obtain xgp zn xgp 
case trans box exists 
lemma exists fn xgp trans box xgp 
trans res xgp 
trans struct right obtain xgp 
lemma fn proof induction derivations base cases construct derivations transitions red trans trans par fn trans box premise fn fn trans struct right right hand side exactly right hand side red 
red xn trans xn fn trans box trans comm premise fn fn trans struct right xn right hand side exactly right hand side red 
red comm trans pgp fn pgp trans trans comm side condition pgp defined trans ensured condition red comm 
premise fn fn trans struct right fv pgp right hand side exactly right hand side red comm 
red repl trans pgp fn pgp trans repl trans comm side condition pgp defined trans repl ensured condition red repl 
premise fn fn trans struct right fv pgp right hand side exactly right hand side red repl 
red par red res red box require straightforward uses induction hypothesis trans par trans res trans box 
red struct lemma fn inductive hypothesis proposition tran struct right transitions imply reductions lemma zo fn proof induction derivation zo 
trans obvious 
trans par induction hypothesis fn fn fn fn fn trans res induction hypothesis fn fn fn fn trans res induction hypothesis fn fn fn fn fn trans res mv induction hypothesis fn fn fn trans struct right induction hypothesis 
cases vacuous 
lemma exist fn fg 
proof induction derivation 
trans trans repl obvious 
trans par consider induction hypothesis exist fn fg 
consider disjunct second similar 
trans res consider fn 
induction hypothesis exist fn fg 
consider disjunct second similar 
trans struct right induction hypothesis 
cases vacuous 
lemma xn exist fn fg 
proof induction derivation xn 
trans box obvious 
trans par consider xn induction hypothesis exist fn fg 
take fn fn trans res consider xn fn 
induction hypothesis exist fn fg 
trans struct right induction hypothesis 
cases vacuous 
lemma proof induction derivations trans box lemma fn fn fn fn fn red trans box induction hypothesis red box 
trans par induction hypothesis red par 
trans comm lemma fn 
lemma fn 
case 
lemma exist fn fg 
consider disjunct 
fn fn fn fn fn fg fn red comm fn fn fg fn second disjunct similar 
case lemma exist fn fg 
fn fn fn fn fn fg fn red fn fn fg fn trans res induction hypothesis red res 
trans struct right induction hypothesis red struct 
cases vacuous 
proof theorem show fn iff immediate lemmas 
proofs give transition analysis lemma 
allows rename extruded names label source process term 
lemma pairwise disjoint finite sets names exists partition process injective fn fn proof induction take fn injective 
lemma ap consider pairwise disjoint 
lemma cases hold 
case exists fn fn xg take fn injective identity lemma induction hypothesis exists partition process injective fn fn fn fn res take case exists fn fn xg yo fn mv similarly take fn injective identity lemma induction hypothesis exists partition process injective fn fn fn fn res take fx xg explicit characterisation simple security properties proved explicit characterisation states labelled transitions 
finite set names name processes define def fag say tuple fag fin outg pairwise disjoint parallel composition outputs forms fout ag fn case process fn 
say process lemma fn 
proof straightforward 
define transition relation satisfying rules 
fn fag fn fn fn rule side condition 
rules tuple left hand side 
rules free names process left hand side contained lemma 
proof inspection transition axioms checking tuple right hand side case noting definition preserved structural congruence 
condition fn fin outg fin outg fn 
lemma fn lemma fn 
condition fn fin outg fin outg fn 
lemma fn lemma fn 
lemma fn 
cases straightforward 
lemma iff proof show implies induction derivations 
converse direction case analysis possible transition derivations 
purity proof proposition show induction holds 
case lemma 
inductive step uses lemmas 
proof proposition similar proposition omit details 
proof proposition similar proposition omit details 
honesty proof proposition check unary wrapper honest proof similar 
finite set names name processes define hha def fj jg fj jg fj jg fj jg def note fn hha 
take family relations 
ra hha fn check fn fn ra bisimulation 
follows lemma fact hha pii number cases check 
give interesting detail 
consider ra know exist hha fn loss generality suppose disjoint 
note proposition similarly transitions clause suppose hha lemma exists partition process injective fn hha fn cases 
due iii 
lemma lemmas lemma fn fn fn fn ra fn hha fn ii closed injective renamings preserve fin outg fn ra fn hha fn ii due match 
due match 
suppose hha due match 
due match 
clause suppose hha 
due match clause suppose matched directly 
suppose match zero steps 
rules 
lemma output particle transition matched zero steps 
similar 
match zero steps 
match step 
clause suppose 
matched zero steps second part clause definition bisimulation 
clause suppose label 
vacuous 
abadi 
secrecy typing security protocols 
open lecture lncs pages sept 
abadi fournet gonthier 
secure implementation channel abstractions 
indiana pages 
ieee computer society press july 
abadi gordon 
calculus cryptographic protocols spi calculus 
inproceedings fourth acm conference computer communications security rich pages 
acm press apr 
amadio 
asynchronous model locality failure process mobility 
inproc 
coor lncs 
amadio castellani sangiorgi 
bisimulations asynchronous calculus 
montanari sassone editors concur volume lecture notes computer science pages 
springer verlag 
amadio prasad 
localities failures 
thiagarajan editor proceedings th fst tcs conference fst tcs 
lncs pages 
springer verlag 
back stoller hsieh lepreau 
java operating systems design implementation 
technical report uucs university utah department computer science aug 
boudol 
asynchrony calculus note 
rapport de recherche inria sofia antipolis may 
cardelli gordon 
mobile ambients 
inproc 
foundations software science computation structures fossacs etaps lncs pages mar 
cardelli gordon 
types mobile ambients 
proceedings th acm symposium principles programming languages 
ford hibler lepreau back 
microkernels meet recursive virtual machines 
usenix editor nd symposium operating systems design implementation osdi october 
seattle wa pages berkeley ca usa oct 
usenix 
fournet gonthier 
vy 
calculus mobile agents 
proceedings concur 
lncs pages 
springer verlag aug 
goldberg wagner thomas brewer 
secure environment untrusted helper applications 
sixth usenix security symposium san jose california july 
gong 
java security architecture jdk 
technical report javasoft july 
revision 
heintze riecke :10.1.1.40.1122
slam calculus programming secrecy integrity 
proceedings th popl jan 
hennessy 
resource access control systems mobile agents 
high level concurrent languages 
full version university sussex technical report cstr 
hennessy 
type safe execution mobile agents anonymous networks 
workshop mobile object systems satellite ecoop 
full version university sussex technical report cstr 
honda tokoro 
object calculus asynchronous communication 
america editor proceedings ecoop lncs pages july 
islam anand jaeger rao 
flexible security system internet content 
ieee software sept oct 
jones 
interposition agents transparently interposing user code system interface 
vitek jensen editors secure internet programing security issues mobile distributed objects 
springer verlag 
lampson 
note confinement problem 
communications acm 
lowe roscoe 
csp detect errors tmn protocol 
ieee transactions software engineering 
mclean 
security models 
editor encyclopedia software engineering 
wiley sons 
milner parrow walker 
calculus mobile processes parts ii information computation 
myers 
jflow practical static information flow control 
inproceedings th acm symposium principles programming languages popl 
myers liskov 
complete safe information flow decentralized labels 
inproceedings ieee symposium security privacy oakland california pages 
necula lee 
safe untrusted agents proof carrying code 
vigna editor mobile agents security volume lncs pages 
sv 
hennessy 
typed language distributed mobile processes 
inproceedings th popl jan 
schneider 
enforceable security policies 
technical report tr computer science department cornell university ithaca new york jan 
sewell 
global local subtyping distributed calculus 
technical report university cambridge aug 
available fromhttp www cl cam ac uk users pes 
sewell 
global local subtyping capability inference distributed calculus 
proceedings icalp lncs pages 
sewell 
brief applied jan 
lecture notes instructional meeting advances semantics types concurrency theory practice july 
available fromhttp www cl cam ac uk users pes 
sewell pierce 
location independence mobile agents 
workshop internet programming languages chicago may 
sewell pierce 
location independent communication mobile agents level architecture 
submitted publication 
draft available www cl cam ac uk users pes 
vitek bryce 
secure mobile code experiment 
manuscript 
vitek castagna 
calculus mobile computations 
internet programming languages chicago may 
vitek castagna 
mobile agents hostile hosts 
journ es des france feb 
volpano irvine smith 
sound type system secure flow analysis 
journal computer security may 
volpano smith 
confinement properties programming languages 
sigact news sept 
winskel nielsen 
models concurrency 
abramsky gabbay maibaum editors handbook logic computer science volume iv pages 
oxford university press 
