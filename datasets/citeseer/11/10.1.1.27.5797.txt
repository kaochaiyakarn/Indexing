scheduling algorithms david karger massachusetts institute technology cliff stein dartmouth college joel wein polytechnic university scheduling theory concerned optimal allocation scarce resources activities time 
practice field dates time humans contended shared resource developed plan share 
theory design algorithms scheduling younger significant history earliest papers field published years ago 
scheduling problems arise variety settings illustrated examples example consider central processing unit computer process sequence jobs arrive time 
order jobs processed order minimize average time job system arrival completion 
example consider team preparing reentry space shuttle atmosphere 
set tasks accomplished team reentry 
task carried exactly astronaut certain tasks started tasks completed 
tasks performed astronaut order ensure entire set tasks accomplished quickly possible 
example consider factory produces different sorts widgets 
widget processed machine machine machine different widgets require different amounts processing time different machines 
factory orders batches widgets order date completed 
order machines different widgets order insure factory completes orders possible time 
generally scheduling problems involve jobs scheduled machines subject certain constraints optimize objective function 
goal specify schedule specifies machine job executed 
researchers studied literally thousands scheduling problems impossible enumerate known variants space chapter 
goal modest 
wish reader familiar assortment algorithmic techniques proved useful solving large variety scheduling problems 
demonstrate techniques drawing collection basic problems model important issues arising scheduling problems time remaining simple permit elegant useful analysis 
basic problems received attention centrality reinforced influential surveys 
examples fit basic problem framework 
survey focus exclusively algorithms provably run worst case time polynomial size input 
algorithm gives optimum solution call exact algorithm 
problems consider np hard polynomial time algorithms exist solve 
cases interested approximation algorithms define ae approximation algorithm algorithm runs polynomial time delivers solution value ae times optimum 
rest chapter organized follows 
complete laying standard framework covering basic scheduling problems notation describing 
explore various techniques solve 
section collection heuristics simple rule assign priority job schedule jobs priority order 
heuristics useful solving certain problems optimally polynomial time giving simple high quality approximations certain np hard scheduling problems 
scheduling problems require complex approach simple priority rule section study algorithms sophisticated greedy choices 
section discuss application basic tools combinatorial optimization network optimization linear programming design scheduling algorithms 
turn exclusively np hard problems 
section introduce notion relaxation problem show relaxations design approximation algorithms 
section discuss enumeration scaling techniques certain np hard scheduling problems approximated arbitrarily closely polynomial time 
framework basic problems scheduling problem defined separate elements machine environment optimality criterion set side constraints characteristics 
discuss simplest machine environment introduce variety optimality criteria side constraints 
introduce discuss complex machine environments 
machine environment scheduling problems set jobs numbered machine environment machine process job time 
job processing requirement requires processing total units time machine 
job processed uninterrupted fashion nonpreemptive scheduling environment job may processed period time interrupted continued point time preemptive environment 
schedule set specifies job units time machine uses process job schedule denote completion time job schedule goal scheduling algorithm produce schedule definition vary depending application 
example goal process entire batch jobs quickly possible words minimize completion time job finished schedule 
example care completion time job batch long average jobs receive service 
set jobs machine environment specify optimality criterion goal scheduling algorithm construct schedule optimizes criterion 
optimality criteria discussed examples basic optimality criteria average completion time schedule makespan 
define makespan max max schedule maximum completion time job average completion schedule note optimizing average completion time equivalent optimizing sum completion times turn side constraints characteristics modify machine environ ment 
number side constraints characteristics possible example specify preemption allowed 
possible constraints model arrival jobs time possibility logical dependence jobs 
scheduling environment release date constraints associate job release date job available processing time 
scheduling environment precedence constraints partial order oe set jobs oe may processing job job completed 
early discussion scheduling models information define number problems 
refer various scheduling problems standard notation defined graham lawler lenstra rinnooy kan 
problem denoted ff denotes machine environment ii fi denotes various side constraints characteristics iii fl denotes optimality criterion 
machine environment ff 
optimality criteria introduced far fl max point discussion fi subset prec denote respectively presence non trivial release date constraints precedence constraints ability schedule preemptively 
side constraints explicitly listed assumed default nonpreemptive model side constraints 
illustration jj denotes problem scheduling independent jobs machine minimize average completion time jr denotes variant problem jobs release dates 
example jr max denotes problem preemptively scheduling jobs release dates precedence constraints machine minimize makespan 
note example modeled jr preemption allowed jr possible elements scheduling application lead different objective functions machine environment 
possible jobs equal importance measuring average service provided job wish weight average give importance certain jobs 
model assigning weight job generalize criterion average weighted completion time schedule scheduling notation optimality criterion denoted possible job may associated due date completed 
gives rise different optimality criteria 
schedule define gamma lateness job interested constructing schedule minimizes max max maximum lateness job schedule 
alternatively concern constructing schedule maximizes number jobs complete due dates 
capture schedule define describe optimality criterion minimization generally illustrations jr jl max denotes problem scheduling machine jobs release dates due dates minimize maximum lateness job denotes problem scheduling precedence constrained jobs machine minimize total summed weight late jobs 
deadlines listed side constraints implicit objective function 
consider scheduling problem deals general optimality criterion 
job function nondecreasing completion time job respect schedule define max max specific problem consider section max scheduling jobs machine minimize maximum value complex machine environments parallel machines shop having introduced optimality criteria side characteristics conditions survey discuss complex machine environments 
discuss parallel machine environments 
environments machines 
job processing requirement processed machines preemption allowed started machine preempted potentially continued machine 
machine process job time job processed machine time 
identical parallel machine environment machines identical job requires units processing time processed machine 
uniformly related machines environment machine speed job processed entirely machine take total time process 
unrelated parallel machines environment model machines different capabilities relative performance job unrelated 
words speed machine job ij depends machine job job requires ij processing time machine define ij ij shop environment primarily models various sorts production environments machines 
setting job operations operation requiring processing specific machines 
different operations may take different amounts time possibly 
open shop environment operations job processed order long operations processed different machines simultaneously 
job shop environment total order operations job operation started predecessor total order completed 
special case job shop flow shop order operations job requires processing machines order different jobs may require different amounts processing machine 
typically flow shop open shop environment job processed exactly machine 
scheduling notation identical uniformly related unrelated machine environments denoted respectively open flow job shop environments denoted environment fixed number machines number included environment specification example denotes environment identical parallel machines 
note example modeled max example modeled jr priority rules obvious approach solving scheduling problem greedy machine available assign job 
sophisticated variant approach give job priority derived particular optimality criterion machine available assign available job highest priority 
section discuss scheduling strategies machine parallel machine shop problems 
algorithms priority job determined jobs 
typically gives simple scheduling algorithm runs log time bottleneck time needed sort jobs priority 
discuss limitations approaches giving examples 
machine focus algorithms single machine problems give job priority sort priorities schedule order 
establish correctness algorithms possible apply interchange argument 
suppose optimal schedule jobs processed non priority order 
follows adjacent pair jobs schedule inverted priorities 
show swap jobs scheduling objective function improved contradicting claim original schedule optimal 
average weighted completion time jj simplest scheduling problem objective minimize sum completion times intuitively sense schedule largest job schedule ensure contribute delay job 
formalize defining shortest processing time spt algorithm order jobs nondecreasing processing time breaking ties arbitrarily schedule order 
theorem spt exact algorithm jj proof establish optimality schedule constructed spt interchange argument 
suppose purpose contradiction jobs optimal schedule scheduled non decreasing order completion time 
pair jobs immediately precedes schedule suppose exchange jobs jobs start complete time swap 
changes completion times jobs suppose originally job started time ended time job started time finished time follows original contribution jobs sum completion times replaced new contribution gives net decrease gamma positive implying original ordering optimal contradiction 
algorithm proof optimality generalizes optimization average weighted completion time jj intuitively schedule weight possible unit processing time 
suggests scheduling jobs nonincreasing order optimality rule established simple generalization previous interchange argument 
theorem smi scheduling jobs nonincreasing order gives optimal schedule jj maximum lateness max simple greedy algorithm solves max seek minimize maximum job lateness 
natural strategy schedule job closest late suggests edd algorithm order jobs nondecreasing due dates breaking ties arbitrarily schedule order 
theorem jac edd exact algorithm max proof interchange argument prove schedule constructed edd optimal 
assume loss generality due dates distinct number jobs delta delta delta optimal schedules consider fewest inversions inversion pair jobs scheduled suppose optimal schedule edd schedule 
pair jobs immediately precedes schedule 
suppose exchange jobs change completion time lateness job claim decrease max increase maximum lateness 
furthermore swapping jobs decreases number inversions schedule 
follows new schedule better lateness original fewer inversions contradiction 
prove claim note schedule follows max gamma exchange job completion time lateness decreases 
job completion time rises gives lateness gamma gamma maximum decreased 
preemption release dates consider complex machine environment jobs may arrive time modeled release dates 
greedy heuristics previous sections immediately applicable jobs high priority released relatively late available processing jobs lower priority 
natural idea cope complication process available released job highest priority 
preemptive setting mean release job higher priority preempting currently running job switching better job 
show idea fact yields optimal scheduling algorithms 
define shortest remaining processing time algorithm point time schedule job shortest remaining processing time preempting jobs shorter processing time released 
generalize edd release jobs earlier dues dates job currently processed preempt current job process job earliest due date 
theorem bak hor exact algorithm jr edd exact algorithm jr jl max proof argue contradiction similar greedy exchange argument 
exchanging entire jobs exchange pieces jobs allowed preemptive environment 
focus jr consider schedule available job shortest remaining processing time processed time available job processed 
denote remaining processing times jobs time total time spent jobs perform exchange 
take units time devoted jobs time process job completion 
take remaining units time spent processing jobs schedule job exchange preserves feasibility jobs released time new schedule jobs completion times 
job finishes job originally finished 
job needed additional finishes job originally finished 
reduced increasing completion time meaning reduced contradiction 
argument edd solved jr jl max goes way 
time job earliest remaining due date processed job due date reallocate time spent processing job job job finish earlier job finish job originally 
increase objective function value 
considering edd function jobs available time conclude machine absence release dates ability preempt jobs yield schedules improved max optimality criteria 
case jobs release dates intuitively problem jr difficult simply preempt current job newly arrived better decide start worse job wait better 
intuition additional difficulty setting justified jr jr jl max fact np complete problems 
discuss approximation algorithms problems sections 
note ideas limitations generalize criterion jr np hard 
note edd line algorithms decisions job schedule currently require information jobs released 
see sga comprehensive survey line scheduling 
machine flow shop consider complex machine environment want minimize makespan flow shop 
general problem np hard case machines 
special case machine flow shop jjc max priority ordering approach due johnson joh yields exact algorithm 
denote operations job second machines pair intuitively want get jobs done machine quickly possible minimize idleness second machine due waiting jobs machine 
suggests spt rule machine 
hand useful process jobs large early possible second machine machine running create large tail processing machine machine finished 
suggests kind longest processing time lpt rule machine 
formalize intuition 
partition jobs sets 
set jobs set construct schedule ordering jobs nondecreasing value jobs nonincreasing values 
process jobs order machines 
called johnson rule 
may surprising reorder jobs process second machine 
turns machine flow shops reordering necessary 
schedule jobs processed order called permutation schedule 
lemma instance jjc max optimal schedule permutation schedule 
note machines necessarily optimal permutation schedule 
proof consider optimal schedule number jobs time complete machine 
suppose job immediately precedes job order jobs completed machine time job started machine 
follows job completed machine time numbering means processed earlier machine follows job completed machine time swap order jobs machine legal schedule job start time changes makespan 
continue performing swaps left done implying jobs machine processed order machine 
having limited search optimal schedules permutation schedules clever argument lawler establish optimality permutation schedule specified johnson rule 
jobs ordering johnson rule 
notice permutation schedule jjc max job started machine immediately completion machine example job starts immediately idle time machine 
makespan schedule determined processing times jobs machine gamma jobs machine just sum processing times 
reduce value sum processing times decreases makespan permutation schedule reduced note job scheduled optimal permutation schedule delays jobs machine buys time jobs processed machine 
similarly job scheduled optimal schedule 
construct optimal permutation schedule repeatedly finding minimum operation size values unscheduled jobs subtracting value operation sizes scheduling job new zero processing time rules 
observe schedule constructed exactly schedule orders jobs johnson rule 
proved 
theorem joh johnson rule yields optimal schedule jjc max parallel machines turn case parallel machines 
move parallel machines problems easily solvable machine np hard focus tends approximation algorithms 
cases simple priority rules machine generalize 
assign priority job machine available starts processing job highest remaining priority 
schedules created algorithms immediately give machine idle referred busy schedules 
section introduce new method analysis 
arguing correctness interchange arguments give lower bounds quality optimal schedule 
show algorithm produces schedule quality factor lower bound demonstrating fortiori factor optimal schedule 
general technique approximation pleasing feature able guarantee certain factor optimal value knowing optimal value show greedy algorithm achieves lower bound demonstrating algorithm optimal 
section devote attention problem minimizing makespan schedule length parallel machines study behavior greedy algorithm problem 
average completion time problem greedy spt algorithm turns yield optimal schedule 
discuss section 
mentioned section max trivial schedule idle time optimal 
machine things complicated 
preemption possible greedily construct optimal schedule polynomial time 
non preemptive setting polynomial time exact algorithm problem np complete simple reduction np complete partition problem gj 
focus finding approximately optimal solution 
show busy schedule gives approximation 
see improved slightly smarter algorithm longest processing time lpt algorithm approximation algorithm 
section show complicated algorithm guarantee better quality approximation 
analyses algorithms comparing performance certain lower bounds quality optimal schedule performance compared optimum better 
algorithms simple lower bounds makespan max optimal schedule max max jobs lower bound says schedule long average machine load second says schedule long size job 
demonstrate power lower bounds preemptive problem jc max case show find schedule matches maximum lower bounds 
lower bounds establish approximation guarantees nonpreemptive case 
minimizing max give simple algorithm called mcnaughton wrap rule mcn creates optimal schedule jc max gamma 
algorithm different scheduling algorithms creates schedule machine machine time 
observing lower bounds apply preemptive schedules give schedule length maxf max order jobs arbitrarily 
placing jobs machines order filling machine time starting machine 
job length may split assigned units time machine gamma units time machine easy verify md units processing job scheduled gamma gamma job scheduled machine time 
created optimal preemptive schedule 
theorem mcn mcnaughton wrap rule gives optimal schedule jc max list scheduling max contrast jc max max np hard 
consider performance list scheduling ls algorithm generic greedy algorithm machine available process unprocessed job 
theorem gra ls approximation algorithm max proof job finish schedule constructed ls time begins processing 
max machines busy time job started earlier 
maximum amount time machines busy obtain max max max max inequality comes lower bounds 
algorithm easily implemented time 
similar analysis algorithm guarantees approximation quality jobs release dates gus 
longest processing time max useful think analysis ls manner 
job starts processed time schedule length plus length longest job running time motivates natural idea run longer jobs early schedule shorter jobs 
formalized longest processing time lpt rule sort jobs nonincreasing order processing time list schedule order 
theorem gra lpt approximation algorithm max proof start simplifying problem 
suppose job finish schedule job start 
remove jobs start time affect makespan schedule jobs run machines 
furthermore decrease optimal makespan modified instance 
prove approximation bound new instance applies fortiori original instance 
assume job finish start smallest job 
case analysis theorem lpt returns schedule length max min consider cases case min max 
case max min max max max case min max 
case jobs max optimal schedule jobs machine 
number jobs order nonincreasing optimal schedule trivially puts job machine 
consider remaining case 
case claim optimal schedule pairs job job gamma gamma places job 
shown optimal simple interchange argument 
finish proof observing exactly schedule lpt construct 
algorithm needs sort jobs implemented log time 
willing spend substantially time obtain ffl approximation algorithm fixed ffl see section 
list scheduling max input contains precedence constraints list scheduling approximation algorithm 
precedence relation oe say job available time predecessors completed processing time recall list scheduling machine idle available job scheduled 
giving algorithm give additional lower bound relevant scheduling precedence constraints 
set jobs oe oe delta delta delta oe max words total processing time chain jobs lower bound makespan 
theorem gra ls approximation algorithm max proof job finish 
define latest finishing predecessor inductively define latest finishing predecessor continuing reaching job predecessors 
fj partition time sets points time job running remaining time 
observe times machines busy job predecessors completed ready run 
max jaj jbj max inequality follows applying lower bounds 
note jaj total length intervals case processing times exactly max solvable polynomial time machines law np complete arbitrary number machines ull 
complexity problem case fixed constant number machines famous open problems scheduling 
list scheduling max list scheduling applied max recall problem job processed disjoint intervals time different machines 
analysis similar max show algorithm constructs busy schedule max approximation algorithm 
max maximum total processing time summed machines job pi max maximum total processing time summed jobs machine 
clearly max pi max lower bounds makespan optimal schedule 
show natural list scheduling generalization processing available operation free machine constructs schedule makespan max pi max see consider machine finishes processing consider job finish machine time schedule processing job job processed true list scheduling require running contradiction 
total length time undergoes processing max remaining time schedule machine busy 
machine busy pi max time units 
total length schedule max pi max claimed 
max pi max max max max obtain theorem see bf list scheduling approximation algorithm max limitations priority rules problems simple scheduling rules yield schedules scheduling problem algorithm designer careful applying rules justification 
particular problems particularly precedence constraints release dates optimal schedule idle time 
constructing schedule time may time idle machine available job scheduling job machine time yield sub optimal schedule 
consider problem max recall max list scheduling approximation algorithm 
consider job machine instance 
ls spt lpt schedule job machine machine makespan 
schedule places jobs machine makespan 
making arbitrarily large see simple algorithms approximation ratio bounded approximation ratios 
problem simple heuristic comes factor optimal problems max max simple algorithm known comes close optimal 
note list scheduling approximation max max busy schedules makespan omega gamma times optimal gs 
sophisticated greedy approaches just argued problems priority algorithms consider jobs isolation section sufficient 
section consider algorithms sort jobs priority measure 
take jobs account making decision schedule job 
algorithms study incremental nature start empty solution grow job time optimal solution revealed 
step decision job add growing solution greedily current context jobs scheduled 
examples classic examples dynamic programming paradigm specialized 
algorithms share analysis idea optimal substructure 
consider optimal solution problem argue subparts prefixes optimal schedule optimal solutions subproblems problem scheduling set jobs prefix 
lets argue algorithms build solution incrementally building optimal solutions bigger bigger subproblems original problem reach optimal solution entire problem 
incremental greedy algorithm jjf max problem consider jjf max defined section 
problem job nondecreasing penalty function completion time goal find schedule minimizing maximum 
example max captured setting gamma greedy strategy applies suitably modified 
convenient talking scheduling penalizing earliest due date job talk scheduling penalizing latest due date job 
total time process schedule 
note job complete time 
find job minimizes schedule job 
recursively schedule remaining jobs minimize maximum penalty 
call algorithm cost 
observe difference previous scheduling rules 
new scheme determine best job schedule second know job scheduled need know processing time job order know processing time recursive subproblem 
simple log time sorting algorithm absolute priorities faced algorithm inspects jobs order identify job scheduled th giving total running time gamma delta delta delta 
change algorithm matched change analysis 
notion job worst change schedule constructed obvious fixed priority apply local exchange argument 
jc max section show algorithm greedy decisions agreement provable lower bound quality optimal schedule 
algorithm produces schedule matches lower bound optimal 
max denote optimal value objective function scheduling jobs consider facts max max min max max gamma fjg statements follows fact job scheduled 
second follows fact optimal schedule remove job schedule increase completion time job 
increasing functions increase penalty 
inequalities prove induction schedule optimal 
scheduling rule schedule job minimizing 
induction gives schedule objective max gamma fjg quantities equations lower bound optimal max see fact obtain schedule value lower bound max fact equal max 
extension max argument previous section continues apply introduce precedence constraints 
max problem partial order jobs build schedule start job jobs preceding partial order completed 
algorithm applies essentially unchanged case 
note job schedule job successors 
build optimal schedule scheduling job jobs successors minimizes 
recursively schedule jobs 
proof optimality goes exactly fact set jobs successors max min equation minimum taken jobs successors 
remainder proof proceeds unchanged 
theorem law cost exact algorithm max noted fact algorithm greedy preemption moot point 
job needs finish immediately follows better executing job 
greedy algorithm continues apply 
alternative approach moore moo gave different approach jjf max may faster cases 
scheme reduction maximum lateness problem solution edd rule 
see algorithm max applied jjf max suppose want know schedule max decide follows 
give job deadline equal maximum easy see schedule max precisely job finishes specified deadline max 
converted feasibility problem max instance lateness problem 
optimization problem may solved binary search correct value dynamic programming jj consider jj problem goal minimize total weight late jobs 
problem weakly np complete 
np complete integral weights possible solve problem exactly time polynomial bounded polynomial 
necessary algorithm classical dynamic program builds solution solutions smaller problems detailed dynamic programming algorithms textbooks see example clr 
dynamic programming algorithm implications 
immediately yields time algorithm jj problem just take weights 
furthermore show section algorithm derive fully polynomial approximation scheme general problem finds schedule ffl optimum time polynomial ffl observation objective schedule partitions jobs types completed due dates completed 
clearly process jobs meet due date processing 
furthermore processing order jobs determined earliest due date edd rule section jobs completed due date implying nonpositive maximum lateness edd minimizes maximum lateness clearly find schedule 
convenient discuss feasible subsets jobs scheduled complete due dates 
question finding minimum weight set late jobs equivalently restated finding maximum weight feasible subset jobs 
solve problem aim solve harder identify maximum weight feasible subset 
dynamic programming 
order jobs increasing due date 
denote minimum completion time weight greater feasible subset subset 
note tw 
give dynamic program compute values consider fastest completing weight greater feasible subset 

jg clearly fastest completing weight greater subset jg completes time schedule feasible subsets edd scheduled 
jobs preceding weight gamma clearly form time subset weight 
completion time feasible set tw gammaw follows tw min tw tw gammaw tw gammaw observe clearly feasible subset weight exceeding dynamic program reach value takes time 
values find maximum weight feasible subset identifying largest value finite 
gives standard time dynamic program computing relevant value maximum finite maximum total weight jobs completed due date 
theorem lm dynamic programming yields time algorithm exactly solving jj similar dynamic program solve problem time effective processing times polynomially bounded integers 
note quite simple greedy algorithm due moore moo solve unweighted jj problem log time 
dynamic programming max second example applicability dynamic programming return np hard problem max focus special case solvable polynomial time case number different job processing times bounded constant 
special case appear somewhat contrived section show form core polynomial approximation scheme max lemma instance max take distinct values exists algorithm finds optimal solution time proof assume target schedule length dynamic programming 
different processing times key observation set jobs machine described dimensional vector number jobs length vectors entry value set vectors total processing time optimal schedule machine assigned set jobs corresponding vector set 
define minimum number machines needed schedule job set consisting jobs size observe standard dynamic programming fashion min gamma gamma minimization possible vectors processed machine counted quantity recursive expression denotes best way process remaining 
need compute entry table entry depends entries computation takes time 
remains handle assumption know easiest way perform binary search possible values slightly sophisticated approach search makespans vectors describing sets jobs clearly determines makespan solution 
matching linear programming networks linear programs central themes combinatorial optimization useful tools solution problems 
surprising techniques applied profitably scheduling problems 
section discuss applications bipartite matching linear programming exact solution certain scheduling problems section revisit techniques design approximation algorithms np hard problems 
applications matching bipartite graph sets vertices edge set theta matching subset edges vertex endpoint edge natural matching useful scheduling problems matches jobs machines matching constraints force job scheduled machine machine processing job 
vertices call matching perfect vertex matching edge 
possible assign weights edges define weight matching sum weights matching edges 
key fact section minimum weight perfect matchings computed polynomial time see amo 
matching schedule positions section give polynomial time algorithm matches jobs positions schedule machine 
schedule ik th job run machine number jobs run machine observing completion time job equal sum processing times jobs run ik xi kp ki see th job run machine contributes exactly times processing time sum completion times 
observation horn hor bruno coffman sethi bcs proposed formulating problem minimum weight bipartite matching problem 
define bipartite graph follows 
contain vertices jobs contain nm nodes ik vertex ik represents kth position machine include edge ik node node define weights edges follows edge ik assigned weight kp ij argue minimum weight perfect matching graph corresponds optimal schedule 
note valid schedule perfect matching perfect matching corresponds schedule job assigned kth position jobs assigned machine perfect matching clearly minimal weight better matching obtained pushing jobs assigned machine slots 
schedule minimum total completion time corresponds minimum weight perfect matching bipartite graph 
theorem hor bcs polynomial time algorithm special case parallel identical machines remains true th job run machine contributes exactly times processing time sum completion times 
case processing time job machine algorithm clear schedule largest jobs machine schedule largest jobs schedule constructed exactly constructed spt algorithm 
corollary cmm spt exact algorithm matching jobs machines jc max second example utility matching give algorithm jc max due gonzales sahni gs 
algorithm find just matching sequence matchings correspond partial schedule concatenate partial schedules 
recall discussion max section lower bounds makespan nonpreemptive schedule maximum machine load pi max maximum job size max remain lower bounds preemption allowed 
nonpreemptive setting simple greedy algorithm gives schedule makespan bounded max pi max show preemption allowed matching achieve makespan equal max max pi max 
intuition algorithm 
consider schedule point time 
time machine processing job 
words schedule point time defines matching jobs machines 
aim find matching forms part optimal schedule process jobs time 
goal processing matched jobs matched machines amount time adjusting max pi max reflect decreased remaining processing requirements reduce max max pi max follows repeat process total amount time equal max max pi max reduce max max pi max implying remaining system 
properties matching jobs machines 
recall goal reduce lower bound 
call job tight total processing cost max call machine tight total load pi max clearly necessary tight job undergo processing matching fail subtract max similarly necessary tight machine matching order ensure reduce pi max lastly execute matching time job machine pair matching requires units processing 
words seeking matching tight machine job matched matching edge requires positive processing time 
matching referred decrementing set 
exists nontrivial fact stochastic matrices proof scope survey refer reader lawler presentation algorithm ll 
find decrementing set construct bipartite graph node representing job machine include edge machine node job node job requires non zero amount processing machine graph require matching matches tight machine job node easily variant traditional matching algorithms 
note include non tight nodes matching problem tight nodes matched 
decrementing set matching machines execute jobs matched matched jobs completes machine new job machine tight happen jobs machines processed matching 
happens find new decrementing set 
simplicity assume max pi max easily arranged adding dummy operations task harder 
decrementing set includes tight job machine follows executing time reduce max pi max follows max pi max time quantities reduced 
clearly means done time equal lower bound 
worry number decrementing set calculations perform non polynomially bounded making approximation algorithm slow 
turns happen 
compute new decrementing set job machine finishes new job machine tight 
job processor pair finish meaning occurs nm times schedule 
job machine stays tight forever tight new tight jobs machines occur times 
constructing schedule optimal length requires mn matching computations 
theorem gs polynomial time algorithm jc max finds optimal schedule makespan max max pi max 
linear programming discuss application linear programming design scheduling algorithms 
linear program vector variables set linear constraints form cost vector goal find satisfies constraints minimizes cx alternatively equivalently inequality constraints equalities may objective function desire simply find feasible solution set constraints 
optimization problems formulated linear programs solved efficiently linear program solved polynomial time 
section consider jc max model problem linear program nm variables ij variable ij denotes fraction job processed machine example interpret linear programming solution assigning job machine machine machine 
consider sorts linear constraints ij necessary ensure describe valid solution instance jc max clearly fraction job assigned machine non negative create nm constraints ij schedule fully process job 
capture requirement constraints ij note previous constraints constraints imply ij objective course minimize makespan schedule 
recall amount processing job require run entirely machine ij set fractional assignments ij determine amount time machine just ij ij model constraints ij ij ensure job processed time model constraints ij ij summarize formulate problem linear program min ij ij ij ij ij ij clear feasible schedule problem yields assignment values ij satisfies constraints linear program 
completely clear solving linear program yields solution scheduling problem linear program specify ordering jobs specific machine simply assigns jobs machines constraining maximum load machine 
fails explicitly require job processed simultaneously machine 
interestingly resolve difficulty application open shop scheduling 
define open shop problem creating operation ij positive variable ij define size ij ij ij find optimal preemptive schedule instance matching algorithm discussed section 
know maximum machine load maximum job size open shop instance bounded makespan resulting open shop schedule reinterpret operations job open shop schedule fragments original job unrelated machines instance see preemptive schedule length fragments job scheduled simultaneously 
established 
theorem ll exact algorithm jc max see applications linear programming development approximation algorithms np hard scheduling problems section 
relaxations design approximation algorithms turn exclusively design approximation algorithms np hard scheduling problems 
recall ae approximation algorithm guaranteed find solution value multiplicative factor ae optimum 
approximation algorithms area relaxation np hard problem 
relaxation problem version problem requirements constraints removed relaxed 
example consider jr relaxation jr preemption constraint relaxed 
second example relaxation version problem relax constraint machine processes job time solution relaxation may jobs scheduled time machine 
solution original problem solution relaxation solution relaxation necessarily solution original problem 
clearly illustrated nonpreemptive preemptive example nonpreemptive schedule legal solution preemptive problem optimal converse true 
follows case minimization problem value optimal solution relaxation necessarily tight lower bound optimal solution original problem 
idea proven quite useful define relaxation problem solved polynomial time give algorithm convert relaxation solution valid solution original problem degradation quality solution 
key making find relaxation preserves structure original problem optimal relaxed solution similar original optimum relaxed solution degrade converted valid solution 
section discuss sorts relaxations scheduling problems design approximation algorithms preemptive version nonpreemptive problem linear programming relaxation problem 
generally different ways infer valid schedule relaxed solution infer assignment jobs machines infer job ordering 
give examples methods going introduce notion relaxed decision procedure section section 
ae relaxed decision procedure rdp minimization problem accepts input target value returns asserting solution value exists returns solution value aet polynomialtime ae relaxed decision procedure easily converted ae approximation algorithm problem binary search optimum see hs hoc details 
simple idea quite useful essentially lets assume know value optimal solution problem 
note different word relax term relaxation rounding fractional assignment machines max section give relaxed decision procedure max recall linear program giving algorithm jc max constraints ij constrain ij solution constitute valid nonpreemptive schedule 
furthermore note integer constraints combined constraints constraints unnecessary job assigned machine constraint ensures fast machine satisfying constraint job 
words formulation feasible solution nonpreemptive schedule makespan ij ij ij ij example integer linear program variables constrained integers 
unfortunately contrast linear programming finding solution integer linear program np complete 
integer programming formulation useful 
common method obtaining relaxation optimization problem formulate integer linear program relax integrality constraints 
obtains fractional solution rounds fractions integers fashion hopefully degrade solution dramatically 
setting relax constraints ij 
add additional set constraints ensure fractional solutions linear program structure useful approximation 
specifically disallow part job processed machine complete time nonpreemptive schedule 
specifically include constraints ij ij fact adding constraints simply remove variables linear program 
argued constraint implicit integer program constraints longer guaranteed relaxed integer constraints 
new constraints seen replacement constraints need integer formulation 
note new constraints linear constraints fixed 
rdp obvious approach writing linear program minimize recap constraints ij constitute linear programming relaxation max relaxed decision procedure attempts solve relaxation obtaining solution ij feasible solution rdp output nonpreemptive schedule makespan 
linear program feasible give way derive integral assignment jobs machines fractional solution 
job easier fact cite theory linear programming find called basic solution linear program positive variables 
positive variables distributed jobs jobs assigned fractional fashion machine 
may state rounding procedure 
machine job pair ij assign job machine call schedule jobs remaining jobs simply construct matching jobs machines job matched machine partially assigned 
schedule job machine matched call schedule jobs defer momentarily question matching exists analyze makespan resulting schedule sum makespans ij form feasible solution relaxed linear program makespan schedules job machine assigns ij meaning ij makespan argument reason add constraint linear program 
schedule length 
argument matching exists somewhat complex sketched 
create graph node machine job edge machine node job node ij 
helped theory linear programming linear program solved generalized assignment problem 
result basic solution structure forest trees trees trees edge added details see amo 
need consider jobs assigned pair ij remove nodes representing machine job mutual edge note constraints imply machine job connected machine job 
forest remains leaves machine nodes remaining job node represents job fractionally assigned linear program edge machines 
straightforward find matching consider trees particular consider unique cycle tree 
nodes cycles alternate machine nodes job nodes equal number 
arbitrarily choose orientation cycle assign job machine follows oriented cycle 
remove matched nodes remains forest trees furthermore possible trees created new leaf job node 
root trees forest leaf job node arbitrary vertex 
assign job node children machine nodes rooted tree 
machine node parent assigned job 
successfully matched job nodes machine nodes required 
exists relaxed decision procedure max theorem 
theorem lst approximation algorithm max inferring ordering preemptive schedule jr section discuss techniques inferring ordering jobs relaxation 
section consider problem jr recall mentioned section problem np hard 
find relaxation simple expedient allowing preemption 
specifically jr relaxation jr jr solved linear programming simply rule 
relaxation extracting order completion jobs optimal preemptive schedule create nonpreemptive schedule order completion 
algorithm call convert preempt schedule follows 
obtain optimal preemptive schedule instance question 
order jobs order completion assume renumbering schedule jobs order 
point job order released wait release date schedule 
added idle time reason schedule may optimal 
theorem psw convert preempt schedule approximation algorithm jr proof non preemptive schedule constructed convert preempt schedule understood follows 
job consider point completion piece scheduled insert extra units time schedule completion point delaying additional time part schedule schedule newly inserted block length remove schedule time originally allocated processing job cut idle time resulting schedule removed changing scheduled order jobs violating release date constraint 
result exactly schedule computed convert preempt schedule 
note completion job delayed insertion blocks jobs finish earlier kj kj jobs completed theorem follows fact total completion time optimal preemptive schedule lower bound total completion time optimal nonpreemptive schedule 
ordering linear programming relaxation jr section generalize techniques previous section applying preemptive schedule linear programming relaxation jr relaxation describing linear programming relaxation problem 
previous relaxation arise relaxing integrality constraints integer linear program 
give classes inequalities satisfied feasible solutions jr constraints necessary sufficient describe valid solution problem 
linear programming formulation considered max assigned jobs machines captured information ordering jobs machine 
jr ordering jobs machine critical element high quality solution seek formulation model 
making time explicit formulation variables jobs represent completion time job schedule 
consider formulation variables solutions correspond optimal solutions jr minimize subject pair oe pair unfortunately set constraints linear constraints 
class valid inequalities introduced wolsey wol queyranne que 
recall denote entire set jobs ng subset define claim feasible machine schedule independent constraints objective 
show inequalities satisfied completion times valid schedule machine particular completion times valid schedule jr lemma completion times jobs feasible schedule machine 
satisfy inequalities proof assume jobs indexed delta delta delta consider case ng 
clearly job multiplying summing obtain holds ng 
general case follows fact set jobs jobs feasibly scheduled schedule ng just ignore jobs 
may view entire set jobs apply previous argument 
special case jj constraints give exact characterization problem wol que specifically set satisfy constraints describe completion times feasible schedule linear constraints effectively replace disjunctive constraints 
extend formulation include constraints longer exact formulation linear programming relaxation jr note formulation exponential number constraints solved polynomial time ellipsoid algorithm linear programming wol que 
note special case just release dates slightly strengthened version remarkably solved optimally log time goe 
constructing schedule solution relaxation show solution relaxation converted efficiently schedule 
simplicity ignore release dates consider approximation algorithm call schedule simple state 
solve linear programming relaxation call solution jobs schedule jobs order release dates idle time 
note ordering jobs respects precedence constraints satisfy oe implies analyze schedule understanding optimal algorithm 
unfortunately delta delta delta feasible solution guarantee schedule job designated complete time defining start time job scheduled point time 
formally intervals gamma constrained disjoint 
delta delta delta corresponded valid schedule see formulation guarantee property yield relaxation sufficient purposes approximation 
theorem schedule approximation algorithm proof optimized relaxation know lower bound true optimum 
suffices show algorithm gets factor lower bound 
denote completion times schedule schedule show jobs delta delta delta jg gives show 
feasible completion times actual schedule 
relaxed version property key approximation 
inequality jg 
dividing obtain 
see result follows 
polynomial approximation schemes enumeration rounding certain np hard scheduling problems limit ability approximate polynomial time example lenstra shmoys tardos proved ae approximation algorithm ae max np lst 
certain problems approximate optimal solutions arbitrarily closely polynomial time 
section polynomial approximation schemes polynomial time algorithms constant ae deliver solution objective value ae times optimal 
running time depend ae smaller ae slower algorithm 
approaches design algorithms 
approach rounding processing times weights small integers apply pseudopolynomial time algorithms jj second approach identifying important jobs greatest impact solution processing separately 
version illustrated max round large jobs constant number large job sizes schedule dynamic programming schedule small jobs arbitrarily 
second version illustrated jr jl max enumerate possible schedules large jobs fill small jobs 
pseudopolynomial ptas jj section gave time algorithm jj gives algorithm runs polynomial time weights polynomial natural idea try reduce instance special case 
scale weights optimal solution bounded polynomial allow apply dynamic programming algorithm weights polynomial size 
assume know value optimal schedule 
multiply weight optimal ffl 
clearly schedule multiplicative ffl factor optimum weights multiplicative ffl factor optimum original weights 
suffices find schedule ffl ffl ffl new weights 
increase weight job larger integer 
increases weight job schedule increases new weights original optimal schedule ffl optimal schedule integral weights ffl weights integers apply dynamic programming algorithm section find optimal schedule rounded instance 
rounded schedule original weights smaller find schedule weight ffl scaled original weights ffl times optimum schedule 
running time dynamic program proportional times sum new weights 
problem weights arbitrarily large 
job new weight exceeding ffl scheduled deadline 
identify jobs modify dynamic program minimum time needed complete jobs complete deadlines plus jobs total weight dynamic programming argument goes unchanged consider jobs weight ffl 
follows largest value consider ffl means total running time ffl 
remains deal assumption know approach rdp scheme performs binary search course expect arrive exactly note estimate suffice 
test value ff analysis go running time increased factor ff 
wait rdp binary search bring say constant factor solve problem 
course weights extremely large binary search go iterations finding value elegant trick lets avoid problem 
solve problem find schedule minimizes weight maximum weight late job 
value schedule clearly lower bound schedules minimize late job weight nw schedule returned late jobs weight value factor optimal 
log binary search steps suffice bring constant factor compute formulate jjf max problem 
job compute schedule minimizes weight maximum weight late job 
results section know compute exactly polynomial time 
theorem exists log ffl time ffl approximation algorithm jj rounding dynamic programming max return problem max recall lemma solved polynomial time special case constant number different job sizes 
general case focus mainly big jobs 
round scale jobs constant number sizes big jobs apply dynamic programming algorithm section rounded jobs 
finish scheduling small jobs greedily 
definition big small contribution small jobs makespan negligible 
give ffl rdp problem transformed ffl approximation algorithm 
assume target optimum schedule length assume rest section fflt ffl ffl gamma ffl gamma integers 
proofs easily modified handle case arbitrary rational numbers 
show handle large jobs 
lemma instance max target schedule length ffl 
assume fflt case ffl rdp max proof assume max immediately know problem infeasible 
form instance processing times rounding integer multiple ffl creates instance 
gamma ffl 
ffl ffl different job sizes 
feasible schedule machine fflt ffl jobs 
apply lemma instance obtain optimal solution scheduling problem makespan know schedule length job sizes greater case answer schedule length exists 
answer exists schedule length ffl show answer correct 
simply take schedule replace rounded jobs original jobs add ffl processing time job ffl jobs machine add fflt processing time machine 
create schedule makespan fflt ffl give complete algorithm 
idea remove small jobs lemma schedule remaining jobs add small jobs back greedily 
input target schedule length ae ffl execute algorithm 
set jobs fflt gamma apply lemma ae 
algorithm returns output schedule length exists 
job machine load add job machine return schedule length exists return schedule length aet exists theorem algorithm ae relaxed decision procedure max proof algorithm outputs schedule length aet exists constructed schedule clearly correct 
algorithm outputs schedule length exists line schedule length exists instance instance subset original jobs schedule exists schedule exists output correct 
algorithm outputs schedule length exists line point algorithm machine units processing 
mt means schedule length exists 
running time dominated dynamic programming lemma 
polynomial exponent polynomial ffl 
ae close running time prohibitively large larger fixed values ae modified algorithm yields schedules near linear running times see hs details 
exhaustive enumeration jr jl max turn problem minimizing maximum lateness presence release dates 
recall section release dates edd exact algorithm problem 
add release dates problem np hard 
think approximation algorithms come immediate obstacle objective function negative solution value aec max clearly impossible 
order get guarantee objective value positive 
simple way decrease uniformly value ffi 
decreases objective value exactly ffi change structure optimal solution 
particular pick ffi large negative guaranteed max positive 
forcing negative somewhat artificial concentrate interpretation note ffi arbitrarily large algorithm arbitrarily approximation algorithm 
equivalent natural delivery time formulation addition modeling number applications key subroutine computational approaches shop scheduling problems 
formulation job addition having release date processing time delivery time delivery time amount time elapse completion time job machine truly considered finished 
objective minimize max fc see connection original problem note setting gammad recall negative positive delivery time problem equivalent minimizing maximum lateness fact overload define jackson rule approximation delivery time model edd translates longest delivery time 
referred jackson rule 
jac 
max optimum maximum lateness 
lower bounds problem easily derived analogs max max lemma jackson rule approximation algorithm delivery time version jr jl max proof job max jackson rule creates schedule idle time know idle time time set jobs run max line follows applying lower bounds 
pas enumeration presentation section follows hall hal 
original approximation scheme problem due hall shmoys hs 
obtain better bounds need look carefully jackson rule go wrong 
starting time job min min min min recall clearly max min min consider job max latest time machine idle job runs immediately idle time 
set jobs run call critical section 
idle time immediately know words set jobs released time job achieves max claim max follows fact max min min right hand side lower bound max long critical section job shortest delivery time optimal schedule 
jackson rule optimal job critical section call latest schedule job critical section interference job 
lemma shows relationship interference job effect max lemma interference job schedule created jackson rule 
max max interference jobs small processing times jackson rule 
sure case handle large jobs separately ensure interference jobs jackson rule remaining jobs 
assume know optimal schedule instance starting time job optimal schedule ffi parameter chosen 
partition jobs small jobs fj ffi big jobs fj ffi create instance follows max gamma gamma instance easier instance decreased release dates delivery times 
optimal schedule remains optimal schedule construction 
large jobs release date equal optimal starting time delivery time equal schedule length minus completion time constrained large jobs run exactly run optimal schedule instance optimal schedule big jobs run exactly time max claim run jackson rule big jobs interference jobs 
lemma run jackson rule job interference job 
proof assume job interference job 
define critical section jobs interference job know know run optimal schedule applying set consisting jobs get max max contradiction 
run jackson rule get schedule length max ffi 
choosing ffi ffl recalling max get schedule length ffl max ffl ffl big jobs 
problem don know argue necessary know observe set big jobs purely function input ffl 
knew starting times big jobs optimal schedule know run jackson rule job inserting big jobs appropriate time 
implies numbering big jobs big job kth job schedule really need know starting time job just enumerate possible numberings big jobs 
ffl numberings 
numbering run jackson rule small jobs insert big jobs appropriate places log time get algorithm ffl log time finds schedule max ffl max research issues summary chapter surveyed basic techniques deterministic scheduling 
scheduling old mature field important opportunities research contributions remain 
addition outstanding open questions see survey lawler feeling meaningful research contributions new innovative techniques attacking old problems new problem definitions model realistic applications 
schools approach design algorithms scheduling relying techniques artificial intelligence computational optimization 
quite valuable forge stronger connections different approaches solving scheduling problems 
defining terms ffl number jobs 
ffl number machines 
ffl processing time job ffl completion time job schedule ffl weight job ffl release date job job unavailable processing time ffl due date job ffl gamma lateness job ffl job scheduled 
ffl denotes scheduling problem machine environment ff optimality criterion fl side characteristics constraints denoted fi 
ffl machine environments machine 
parallel identical machines 
parallel machines different speeds 
parallel unrelated machines 
open shop 
flow shop 
job shop 
ffl possible characteristics constraints job preemption allowed 
jobs nontrivial release dates 
prec jobs precedence constrained 
ffl optimality criteria average sum completion times 
weighted average sum completion times 
max makespan schedule length 
max maximum lateness jobs 
number time jobs 
weighted number time jobs 
jan karel lenstra david shmoys helpful comments 
amo ahuja thomas magnanti james orlin 
network flows theory algorithms applications 
prentice hall englewood cliffs nj 
bak baker 
sequencing scheduling 
wiley 
bcs bruno coffman sethi 
scheduling independent tasks reduce mean finishing time 
communications acm 
bf ar 
esi probl em ak optim asa 
mat agi 
clr thomas cormen charles leiserson ronald rivest 
algorithms 
mit press mcgraw hill 
cmm conway maxwell miller 
theory scheduling 
addisonwesley 
gj garey johnson 
computers intractability guide theory np completeness 
freeman new york 
graham lawler lenstra rinnooy kan optimization approximation deterministic sequencing scheduling survey 
annals discrete mathematics 
goe goemans 
supermodular relaxation scheduling release dates 
proceedings th conference integer programming combinatorial optimization pages june 
published lecture notes computer science springer verlag 
gra graham 
bounds certain multiprocessor anomalies 
bell system technical journal 
gra graham 
bounds multiprocessing anomalies 
siam journal applied mathematics 
gs gonzalez sahni 
open shop scheduling minimize finish time 
journal acm 
gs gonzalez sahni 
jobshop schedules complexity approximation 
operations research 
gus gusfield 
bounds naive multiple machine scheduling release times deadlines 
journal algorithms 
hal hall 
approximation algorithms np hard problems chapter 
pws publishing 
hochbaum editor 
lenstra van de velde 
sequencing scheduling 
dell martello editors annotated bibliographies combinatorial optimization 
wiley chichester 
appear 
hoc hochbaum editor 
approximation algorithms 
pws 
hor horn 
minimizing average flow time parallel machines 
operations research 
hor horn 
simple scheduling algorithms 
naval research logistics quarterly 
hs hochbaum shmoys 
dual approximation algorithms scheduling problems theoretical practical results 
journal acm 
hs hall shmoys 
approximation schemes constrained scheduling problems 
proceedings th annual symposium foundations computer science pages 
ieee october 
hall schulz shmoys wein 
scheduling minimize average completion time line line approximation algorithms 
mathematics operations research august 
jac jackson 
scheduling production line minimize maximum tardiness 
management science research project research report university california los angeles 
joh johnson 
optimal stage production schedules setup times included 
naval research logistics quarterly pages 
khachiyan 
polynomial algorithm linear programming russian 
doklady nauk sssr 
law lawler 
optimal sequencing single machine subject precedence constraints 
management science 
law lawler 
combinatorial optimization networks matroids 
holt rinehart winston 
ll lawler 
scheduling unrelated parallel processors linear programming 
journal acm 
lawler lenstra kan shmoys 
sequencing scheduling algorithms complexity 
graves rinnooy kan editors handbooks operations research management science vol logistics production inventory pages 
north holland 
lm lawler moore 
functional equation application resource allocation sequencing problems 
management science pages 
lst lenstra shmoys tardos 
approximation algorithms scheduling unrelated parallel machines 
mathematical programming 
mcn mcnaughton 
scheduling deadlines loss functions 
management science 
moo moore 
job machine sequencing algorithm minimizing number late jobs 
management science 
pin 
scheduling theory algorithms systems 
prentice hall 
psw phillips stein wein 
scheduling jobs arrive time 
akl editor algorithms data structures number lecture notes computer science pages berlin 
springer verlag 
journal version appear mathematical programming qs queyranne schulz 
polyhedral approaches machine scheduling 
technical report technical report technical university berlin 
que queyranne 
structure simple scheduling polyhedron 
mathematical programming 
sga sgall 
line scheduling survey 
fiat woeginger editors line algorithms lecture notes computer science 
springer verlag berlin 
appear 
smi smith 
various optimizers single stage production 
naval research logistics quarterly 
ull ullman 
np complete scheduling problems 
journal computer system sciences 
wol wolsey 
mixed integer programming formulations production planning scheduling problems 
invited talk th international symposium mathematical programming mit cambridge 
information conclude reminding reader chapter 
way chapter comprehensive survey basic classical results scheduling theory certainly date survey field 
essentially entirely ignores non traditional models touch stochastic scheduling approaches scheduling resource allocation 
reader interested comprehensive survey field consult textbook pin survey lawler 
sources provide pointers number 
addition recommend annotated bibliography contains information results scheduling theory surveys queyranne schulz polyhedral formulations qs hall approximation algorithms hal sgall online scheduling sga 
research deterministic scheduling theory published journals example see mathematics operations research operations research siam journal computing journal acm 

