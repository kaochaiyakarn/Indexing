categorical models fairness fully presheaf semantics sccs finite delay thomas hildebrandt university copenhagen denmark dk 
presheaf model observation infinite finite computations 
apply give denotational semantics sccs finite delay meanings recursion final coalgebras meanings finite delay initial algebras process equations delay 
viewed step representing fairness presheaf semantics 
give concrete representation presheaf model category generalised synchronisation trees show category generalised transition systems special case general transition systems hennessy stirling 
open map bisimulation shown coincide extended bisimulation hennessy stirling essentially fair ctl bisimulation 
formulate operational semantics sccs finite delay terms generalised transition systems prove presheaf semantics fully respect extended bisimulation 
reasoning describing behaviour concurrent agents case infinite computations considered unfair consequently ruled inadmissible 
economical way studying situation proposed milner showing express fair asynchronous parallel composition calculus sccs synchronous ccs adding finite unbounded delay operator 
syntactically finite delay agent written intended semantics perform unbounded number actions delays eventually perform action changing agent perform action change eventually perform actions 
words actions possibly infinite delay rec infinite unfolding recursion allowed 
deal agents infinite computations admissible issue represent behaviour agents agents behave equally denote process 
approach ccs sccs agents equivalent derivation trees strong bisimilar identify agents differ infinite computations full revised version appearing proceedings ctcs 
submitted journal 
supported project funded danish research councils 
initiated stay lfcs university edinburgh scotland 
admissible particular identified term solutions equation process equations anymore unique solutions case ccs sccs guarded recursion 
milner proposes behavioral preorder called designed induces equivalence distinguishes notions delay coincides strong bisimulation standard agents recursive processes fixed points associated process equations equivalence congruence respect operators language assuming guarded recursion approach works reasonably completely satisfactory 
pointed aczel equivalence non desirable identifications agents due fact infinite computations treated separately finite computations 
illustrate may consider extension strong bisimulation equivalence obtained requiring related states sets infinite action sequences labelling admissible infinite computations states identical 
resulting equivalence included equivalence 
agents agent actions derivation tree shape underlying agents black nodes original agent agent admissible infinite action sequence underlying agents white nodes agent action sequences 
consequently obvious isomorphism derivation trees agents bisimulation satisfying extra requirement agents equivalent 
agent delay infinitely remaining able perform time second agent reach state perform action 
alternative proposed final coalgebra semantics giving rise bisimulation distinguishes agents 
bisimulation closely related extended bisimulation introduced hennessy stirling general transition systems essentially fair ctl bisimulation formulated edge labelled structures 
revised version chapter authors phd thesis 
background presenting models concurrency categorically initiated winskel nielsen developed bisimulation open maps presheaf models concurrency :10.1.1.120.180
goal extend categorical approach issue infinite computations fairness absent far models infinite computations 
quality check want apply models give operational denotational semantics sccs finite delay capture true branching equivalence avoids non intuitive 
see goal met 
forces describing models concurrency language category theory different models suitable different purposes formally related 
category synchronisation trees suitable giving denotational semantics ccs process calculi shown subcategory category transition systems suited operational semantics 
force added notion bisimulation open maps introduced 
gets behavioural equivalence choosing path category bit general functor category path shapes model issue identifying observable computations assumed inclusion subcategory open maps approach gained ground development presheaf models concurrency proposed :10.1.1.120.180
starts path category non empty path shapes takes category presheaves model 
categorical justification doing fact :10.1.1.120.180

strict extension known yoneda embedding free connected colimit completion category 
obtained adding new intial object embedding 
presheaf model comes canonical notion bisimulation open maps 
shown presheaf models related category arrows connected colimit preserving functors functors fact preserve canonical bisimulation general techniques construction provided :10.1.1.120.180
simplest example presheaf model equivalent category act labelled synchronisation trees obtained path category finite non empty sequences actions ordered usual prefix ordering 
shown typical constructions ccs language expressed functors preserving canonical equivalence :10.1.1.120.180
suggested natural approach generalisation categorical models models infinite computations studying presheaves sheaves category prefix ordered finite infinite action sequences 
show help simple grothendieck topology gives suitable model infinite computations category sheaves category separated presheaves 
careful generalisation models synchronisation trees transition systems lifts relationship standard finitary models infinitary models gives concrete representation presheaf model infinite computations generalised synchronisation trees category generalised transition systems 
generalised transition systems defined instances general transition systems turns extended bisimulation defined coincides bisimulation obtained open maps 
showing express operational semantics sccs finite delay generalised transition systems give denotational semantics presheaf model prove fully respect extended bisimulation 
steps greatly benefit categorical presentation 
unbounded non determinism represented simply infinite coproducts 
utilizing general techniques get simple definitions denotations basic operators congruence properties follow free :10.1.1.120.180
meanings recursion take final coalgebras corresponding greatest fixed points denotation finite delay taken initial algebra corresponding fixed point process equation 
categorical relationships different models general theory bisimulation open maps reduce problem relating semantics proving full abstraction finding specific open map category generalised transition systems 
number papers proposed denotational semantics sccs finite delay doing models non deterministic processes infinite computations 
mentioned approach take closely related aczel hennessy stirling 
approach aims general notion fairness finite delay 
appears cost admissible infinite computations identified syntax dependent way opposed algebras final coalgebras 
semantics fully respect equivalence non intuitive identifications mentioned 
covers bounded non determinism obtained terms binary sum allowed 
semantics equivalence 
worth noting models approximation order elements defined meanings recursion fixed points 
requires reverse order infinite computations larger process fewer infinite computations 
structure follows 
sec 
give preliminary definitions recall categorical concepts 
sec 
recall calculus sccs finite delay operator derive fair parallel 
sec 
introduce respectively new presheaf model transition system models infinite computations 
section devoted bisimulation obtained open maps relationship extended bisimulation 
sec 
formulate milner operational semantics sccs finite delay terms generalised transition systems introduced sec 
sec 
give presheaf semantics full abstraction result 
comments sec 

contain details grothendieck topologies proof full abstraction 
preliminaries assume fixed set act actions 
act act refer sets respectively finite infinite sequences actions 
fin inf refer partial orders act act act standard prefix order 
partial orders play key role path categories presheaf models observation respectively finite possibly infinite computations 
roman letters range elements set greek letters range sequences elements set 
denote length sequence write composition sequences 
sequence actions write finite categories transition systems synchronisation trees repeat definition transition systems morphisms generalise infinite computations sec 

definition 
transition system label set act quadruple act set states initial state act transition relation 
usual write 
act say transition system reachable state reachable initial state 
synchronisation tree transition system transition relation acyclic state reachable initial state unique sequence transitions 
transition systems label set act form objects category ts arrows simulations 
simulation mapping states implies 
synchronisation trees label set act induces full subcategory st ts 
define set finite infinite computations transition system comp 
comp fin comp finite computations 
define set runs transition system run comp run fin run shown category st subcategory category ts transition systems inclusion st 
ts right adjoint unf ts st acts objects unfolding transition system 
precise transition system label set act unfolding defined unf run fin run fin act empty transition sequence 
morphisms unfolding takes morphism transition systems underlying map morphism unf unf underlying map run fin run fin defined bisimulation open maps presheaf models concurrency categorical presentation models concurrency comes general notion bisimulation open maps introduced 
model idea identify functor 
category path shapes model identifying observable computations assumed inclusion subcategory 
map defined open open just open embedding clear context morphism morphisms diagram pp pm pq commutes exists morphism pq indicated dotted line making triangles commute 
objects bisimilar related span open maps shown bran fin 
ts obvious embedding mapping action sequence corresponding single branch transition system bran bisimulation coincides usual hm bisimulation labelled transition systems 
subsequent range known bisimulations characterised open map bisimulations 
freedom choose path category unsatisfying 
presheaf categories suggested models concurrency equipped canonical notion bisimulation equivalence 
small category category presheaves objects functors op set set category sets functions arrows natural transformations 
briefly repeat categorical justification presheaf categories models concurrency :10.1.1.120.180
write 
category obtained adding new initial object free connected colimit completion category obtained equivalence freely adding colimits connected diagrams 
functor category having connected colimits extended freely left kan extension connected colimit preserving functor making diagram 
commute 
embedding 
strict extension known yoneda embedding 
empty presheaf 
embedding provides canonical choice path shapes presheaf model providing canonical notion bisimulation 
proposition important results open map bisimulation presheaf models :10.1.1.16.6295
proposition 
connected colimit preserving functor 
open map fm fx fy 
open map follows colimit preserving functors presheaf categories preserve canonical notion bisimulation 
shown category fin fact equivalent category synchronisation trees shown typical constructions ccs language expressed functors preserving canonical equivalence :10.1.1.21.5791:10.1.1.120.180
repeat briefly concrete representation presheaves systems 
guide sec 
help identify right presheaf model infinite computations 
notation partial order category denote unique arrow unique arrow op employ standard notation writing 
element restriction path presheaf fin corresponding synchronisation tree el sx act constructed category elements 
set states elements initial state added sx fin fi transition relation defined restriction action presheaf 
initial algebras final coalgebras recall categorical analogues pre post fixed points 
definition 
endofunctor category algebra pair object morphism 
dually algebra pair algebras form focus put rooted presheaves path categories initial object presheaves 
singleton set 
canonical bisimulation taken span surjective open maps 
easy verify category rooted presheaves 
equivalent category surjective open maps rooted presheaves 
corresponds equivalence open maps objects category coalg arrows 
arrows commutes 
dually algebras form objects category alg initial final objects alg coalg categorical analogues minimal maximal fixed points lemma 
endofunctor category initial algebra initial object category algebras isomorphism 
initial algebra isomorphic dual statement holds final algebras 
initial algebra denote unique upto isomorphism initial algebra 
similarly denote final algebra exists 
lemma standard technique proving existence final coalgebras 
lemma 
category terminal object endofunctor op chain limiting cone gn 
preserves limit 

ff gn 
limiting cone unique mediating iso morphism final coalgebra 
lemma dual lemma construction initial algebras 
lemma 
category initial object endofunctor chain 


colimit preserves colimit unique mediating iso morphism initial algebra 
limits computed pointwise presheaf category terminal object presheaf op set yields element set terminal object set object dually initial object op set empty presheaf yielding empty set objects synchronous ccs finite delay section recall calculus sccs synchronous ccs definition fair parallel composition finite delay operator 
assume element act act abelian monoid identity 
basic operators sccs action prefixing synchronous product non deterministic choice restriction 
formally terms act act index set 
basic operators build processes finite behaviour 
usual write empty sum omit summation sign unary sum write binary sum 
able define processes possibly infinite runs add recursion operator extending grammar rec process variable rec binds variable refer set closed terms calculus sccs 
rules fig 
defines operational semantics sccs get derivation transition system closed term defined 
definition 
term derivation transition system reachable transition system act states reachable relation defined rules fig 

act rec rec fig 
operational semantics sccs note synchronous product processes perform action resulting action monoid product individual actions 
recursion acts unfolding rec usual substitution rec free variable important derived operator introduced delay operator process define rec 
standard semantics unique bisimulation fixed point process equation economical way able express infinite runs inadmissible milner introduces finite unbounded delay operator expectation 
immediate actions derived delay operator described rules fig 

wait fulfill 
fig 
derivation rules finite delay infinite waiting ruled inadmissible 
words fulfillment delay expected 
idea finite delay operator giving rise inadmissible infinite runs 
recursion usual give rise admissible infinite runs 
sufficient derive fair asynchronous parallel composition 
processes fair asynchronous parallel composition defined 
composition asynchronous sense process delay progress fair sense process delay way forever 
sccs refer respectively calculus sccs extended finite delay operator set terms extended calculus 
section introduce closely related categorical models suitable giving respectively denotational operational semantics infinite computations expressed 
observing infinite computations approach categorical model infinite studying presheaves sheaves path category inf obtained adding infinite paths path category fin 
fits spirit experiments systems allowed consist infinite computations 
categorically seen completion path category directed colimits 
presheaf model infinite computations get better understanding presheaves inf op set inf try construct synchronisation tree described sec 
finite part restriction fin 
act element specify unique infinite path tree 
precise act say limit point infinite path elements 
restrictions finite observations 
wish represent infinite path admissible presence limit point inadmissible absence limit point 
interpretation model bit general allows infinite path limit points representing limit point 
take subcategory presheaves atmost limit point infinite sequence model 
category ad hoc 
comes category separated presheaves inf respect simple grothendieck topology inf referred sup topology 
standard terminology infinite paths limit points respectively matching families unique 
definition 
sp inf denote separated presheaves full subcategory inf induced presheaves satisfying act separated :10.1.1.16.4882

recover category fin synchronisation trees inf equivalent category sh inf sheaves inf topology 
case separated presheaf sheaf exactly limit point infinite path 
sheaf correspond synchronisation tree infinite path admissible limit closed synchronisation tree 
just standard interpretation explicit 
proposition 
category fin equivalent category sh inf sheaves inf respect sup topology 
sheaves separated presheaves presheaves known closely related rich structure 
especially fact related sequence reflections inclusions sh inf 
sp inf sp inf 
inf left adjoints reflectors 
case reflections simple 
reflector sp inf sp inf acts unifying limit points specify infinite path 
reflector sp inf sh inf acts completing limit points sequences 
objects inf strict extension yoneda embedding sheaves 
prop 
gives formal relationship path category inf presheaf model fin finite observations models sp inf inf summarized diagram 
fin sh inf sp inf inf inf inf inf 
fact grothendieck topology canonical topology inf simply means largest topology sheaves 
note implies general fact category sp inf limits colimits 
particular shows limits computed inf similarly colimits followed reflector identifying redundant limit points 
indicated diagram inf refer reflection fin sp inf obtained sh inf fin 
details grothendieck topologies sheaves separated presheaves see 
special simpler case grothendieck topology partially ordered set appendix definition grothendieck topology relevant 
generalised transition systems synchronisation trees generalised transition systems transition system admissible infinite computations represented explicitly 
precisely take generalised transition system transition system set comp comp set including composition comp pre suffix finite finite comp fin conditions ensure definition fits general transition systems 
condition restricts attention special case finite computation admissible 
definition 
generalised transition system synchronisation tree label set act tuple sg act sg act transition system synchronisation tree comp satisfies refer set admissible computations say standard comp 
sg act generalised transition system fin sg act underlying transition system 
generalised transition systems label set act forms objects category gts morphisms defined follows 
definition 
morphism generalised transition system generalised transition system map sg sg implies extension possibly infinite transition sequences defined standard case generalised synchronisation trees label set act induce full subcategory gst category gts 
lemma gives alternative definitions morphisms generalised transition systems 
particular shows morphisms gts restrict morphisms underlying transition systems map fin extends functor fin gts ts 
lemma 
sg sg map state sets generalised transition systems conditions equivalent 
morphism generalised transition systems 

fin fin morphism transition systems 
fin fact fin gts ts reflector inclusion ts gts maps plain transition system corresponding standard generalised transition system 
proposition 
functor fin gts ts left adjoint inclusion inf ts 
gts maps transition system act standard generalised transition system comp act leaves morphisms unchanged 
coreflection synchronisation trees transition systems sec 
generalises gst category gts 
proposition 
inclusion functor gst 
gts right adjoint gts gst diagram gst gts st ts unf fin fin commutes unf unfolding transition systems defined 
fact squares diagram gst gts st ts unf fin fin commutes 
generalise equivalence fin st direction category elements construction described sec 
gives concrete representation presheaves sp inf generalised synchronisation trees 
generalise category elements construction property stated lemma state generalised transition system reachable set admissible computations determined uniquely set admissible infinite runs 
lemma 
reachable transition system comp 
exists unique set run fin direction embedding inf 
gst maps non empty finite infinite sequence corresponding single branch standard generalised synchronisation tree 
implicitly inclusion gst gts gives canonical functor gts inf maps generalised transition system presheaf gts 
difficult check give separated presheaf 
lemma 
generalised transition system inf 
gts embedding described 
gts presheaf sp inf 
functor gives direction equivalence 
theorem 
categories gst sp inf equivalent 
direction equivalence canonical functor sps gst sp inf maps generalised synchronisation tree presheaf gst 
direction equivalence functor el sp inf gst generalising functor el fin st defined objects sec 

sp inf define el adm act act synchronisation tree corresponding finite part defined sec 
adm comp act 
note functors fin inf restricted synchronisation trees just concrete representations reflection fin sp inf diagram 
extended bisimulation open maps described sec 
get canonical notion bisimulation inf open maps presheaf category inf 
diagram follows inf bisimulation restricts subcategories sh inf sp inf sheaves presheaves 
category inf embeds category generalised transition systems functor inf 
gst simply strict extension inf 
gst 
gives notion inf bisimulation generalised transition systems show coincides extended bisimulation defined general transition systems 
worthwhile extended bisimulation essentially fair ctl bisimulation formulated edge labelled structures 
means particular extended bisimulation decidable finite generalised transition systems set infinite paths buchi 
give characterisation inf open maps gts generalises zig zag morphisms 
proposition 
adm act su act generalised transition systems fin open reachable states state inf open exists adm give definition extended bisimulation reformulated relation generalised transition systems condition 
definition 
generalised transition systems 
extended bisimilar exists relation 
exists computation adm exists computation adm act act 
exists computation adm exists computation adm act act note condition extended bisimulation specialises standard transition systems restricted sequences length 
note conditions equivalently formulated bisimulation considering sequences infinite length 
considerations prop 
follows extended bisimulation coincides inf bisimulation generalised transition systems 
proposition 
generalised transition systems 
inf bisimilar extended bisimilar 
easy fact inf bisimulation gst equivalence coincides canonical bisimulation sp inf get corollary 
corollary 
presheaves sp inf 
inf bisimilar el el extended bisimilar 
coreflection previous section lem 
follows generalised transition systems inf bisimilar unfoldings generalised synchronisation trees inf bisimilar 
operational semantics section express milner operational semantics sccs finite delay terms generalised transition system 
rules fig added rules fig 
inadmissible infinite computations identified notions waiting computations subcomputations 
put briefly computation agent waiting transition inferred solely wait rule finite delay 
agents rec computation agent inferred computations referred subcomputations 
computation defined admissible finite sequel suffix infinite waiting 
define derivation transition system distinguish admissible inadmissible infinite runs need record wait rule infer action 
consequently annotate terms form number written indicates long delaying 
generally refer set annotated closed terms sccs 
note function domain regarded function domain discarding annotations 
refer agent 
derivation rules fig replaced rules fig 
wait fulfill fig 
derivation rules annotated finite delay position formalised follows 
definition 
define os set positions nil os denote empty sequence top position 
term define partial function os inductively length position structure nil rec nil undef ip ip undef os annotated term say waiting term 
define infinite computation inadmissible 
definition 
infinite computation derivable rules fig fig inadmissible exist position waiting 
say computation admissible inadmissible 
difficult verify computation inadmissible definition suffix waiting continues wait forever definition admissibility coincides briefly gave section 
derivation transition systems terms generalised transition systems set admissible computations def 

definition 
term derivation transition system reachable generalised transition system adm act ft 
act relation defined rules fig fig restricted states adm comp act set admissible computations defined def 


need record exactly steps delay waited just waited zero step continuously 
means replace rule fig rule minfn allow numbers annotations 
set rules benefit giving rise infinite graphs just presence finite delay relevant model equivalence checking 
questions outside scope 
presheaf semantics section see category separated presheaves sp inf suited give denotational semantics sccs 
semantics basic operators denotation sum simply coproduct sp inf 
denotations remaining basic operators restriction action prefix synchronous product obtained underlying functions sequences free extension described sec 
case sp inf 
act restriction sequences inf inf maps sequence possible empty sequence longest prefix sequence act action prefix sequences inf 
inf maps possibly empty sequence synchronous product sequences inf inf inf extension monoid product sequences inf unique sequence jg easy see mappings monotone functors partial order categories 
implicitly composing embeddings inf inf 
sp inf inf inf 
sp inf get functors inf sp inf inf 
sp inf inf inf sp inf 
applying extension get denotations basic operators 
basic operators closed terms define sp sp inf :10.1.1.16.4882
sp inf obvious lifting functor bc inf 
inf inf inf sp inf connected colimit preserving functor inf inf inf inf defined objects 
semantic functions extended obvious way terms free variables set yielding functors sp inf sp inf functors build connected colimit preserving functors follows preserve connected colimits 
definitions give denotation isomorphism :10.1.1.16.4882
helpful showing correspondence operational semantics give explicit semantics 
just give action objects 
tags sum indicate clearly element came app 
fe sum choose represent bc inf 
inf explicitly xc inf semantics recursion recursion need take care 
standard semantics take fixed points initial algebras meanings recursion 
sp inf reflect admissible unfold recursion infinitely 
explicit example illustrates showing initial algebra functor corresponding delay equation sec 
proper denotation finite delay delay operator derived recursion 
solution take final algebras meanings recursion 
infinite recursion term free variable define rec 
object final algebra endofunctor sp inf sp inf 
defined show existence final algebras functors 
lem 
sec 
construct final algebras relevant endofunctors limits op chains 
definition extended processes variable usual way limit parameters 
explicit definitions eq 
show basic operators preserve op limits 
general fact limits commute limits get recursion preserves op limits rec free variables rec preserves op limits 
lemma 
possibly open term sccs free variables sp inf sp inf defined preserves op limits sp inf sp inf defined preserves op limits similarly sum prefix synchronous product recursion 
basic operators give explicit denotation recursion rec rec 
choose explicit representation final presheaf explicit definition limits category set define rec 
natural transformation projections rec universality get explicit isomorphism rec rec rec rec commutes 
note general free variables fxg natural transformations 
semantics operators sccs finite delay 
worth remarking stage clear semantics general correspond operational semantics sec 

simple example showing provided disastrous term rec operational semantics term denotes process actions process denoted empty sum 
compute appropriate limit finding rec 
final object inf sensible way equated denotation empty sum initial object inf 
note result constructs initial algebra 
see get desired correspondence restrict language allow guarded recursion 
semantics finite delay mentioned denotation finite delay comes initial algebra functor corresponding delay equation 
finite delay closed term define 
object initial algebra endofunctor sp inf sp inf 
initial algebra exists lem 
denotation prefixing preserves connected colimits denotation sum colimits 
definition extended open terms free colimit parameters 
explicit definition colimits set find take del explicit definition finite delay objects tag del indicate clearly element arise denotation finite delay 
define del del 
del guarantee denotation recursion defined need check denotations finite delay preserve op limits 
done explicit definition 
lemma 
possibly open term sccs free variables sp inf sp inf defined preserves op limits sp inf sp inf defined preserves op limits 
completes definition denotational semantics sccs category presheaves sp inf 
extended bisimulation congruence fact denotations inf basic operators built connected colimit preserving functors follows preserve open maps inf 
fact inclusion sp inf inf full proposition get holds sp inf 
easy show explicit definition denotations finite delay preserve open maps alternatively technique showing denotations recursions initial algebras preserve open maps 
proposition 
extended bisimulation congruence respect basic operators sccs finite delay 
comes recursion meet problem right notion bisimulation open maps denotations open terms functors presheaf categories 
notion open maps extended open natural transformations natural transformations components open maps 
shown sufficient open map bisimulation congruence respect denotations recursion initial algebras ccs calculus 
suggested slightly stronger notion open maps preserving functors presheaf categories regarded objects presheaf category comes canonical notion open maps 
apply notion bisimulation functors connected colimit preserving functors known case setting final algebras 
notion open natural transformations remains shown sufficient give desired congruence property 
full abstraction representation theorem sec 
express denotational semantics terms generalised synchronisation trees defining el 
allows relate denotational semantics directly operational semantics sec 
category gts 
restrict attention terms guarded recursion 
recall recursion rec guarded free occurences guarded subterm action act 
refer set closed possibly annotated terms sccs guarded recursion 
say term standard subterms holds 
show quotient open map bisimulation denotational semantics standard terms fact equationally fully respect extended bisimulation 
means standard terms presheaves bisimilar generalised transition systems arising operational semantics extended bisimilar 
remarked sec 
obtain result terms sccs 
proof see app 
detailed proof outline goes showing exists inf open morphism generalised transition systems term proposition 
standard term exists inf open morphism generalised transition systems 
proposition prop 
cor 
sec 
deduce desired result 
theorem 
terms open map bisimilar extended bisimilar 
main contributions 
generalisation categorical models concurrency developed providing generalised transition system presheaf model infinite computations suitable agents notion fairness inadmissible infinite computations 
generalised transition systems instances proposed extended bisimulation shown coincide bisimulation span open maps model 
second main contribution give operational semantics denotational semantics sccs finite delay representing notion inadmissible infinite computations precisely operational semantics allowing behaviours discriminated extended bisimulation 
notion bisimulation strictly finer argued intuitive equivalence obtained preorder basis previous denotational semantics sccs finite delay 
categorical presentation semantics appears give conceptually simpler treatment infinite computations 
restricts attention agents products restrictions disallowed recursions change operational semantics sec 
agents assigned finite generalised transition systems 
essentially ctl bisimulation gets decidability characterisation admissible infinite computations described muller condition difficult 
number questions remains explored 
obvious question generalise finite delay fair recursion 
progress notion open maps denotations open terms stronger open map bisimulation hopefully congruence respect recursion 
get characteristic hml path logic extended bisimulation open maps approach compared characteristic logic edge labelled version fair ctl logic 
interesting explore relationship approach traditional domain theoretical approach fairness countable non determinism 
hope able extend presheaf model finitary dataflow infinite computations lines giving model dataflow fairness particular fair merge expressed 
glynn winskel marcelo fiore prakash panangaden helpful encouraging discussions 

aczel 
semantic universe fairness 
preliminary draft 

aziz singhal 
equivalences fair kripke structures 
abiteboul shamir editors icalp international colloquium automata languages programming volume lncs pages 
springer verlag 

barr wells 
category theory computing science 
prentice hall 

cattani 
presheaf models concurrency 
phd thesis aarhus university 

cattani power winskel 
categorical axiomatics bisimulation 
proceedings th international conference concurrency theory concur volume lncs pages 
springer verlag 

cattani stark winskel 
presheaf models pi 
ctcs volume lncs pages 
springer 

cattani winskel 
presheaf models concurrency 
csl volume lncs pages 
springer 

cattani winskel 
presheaf models ccs languages 
submitted 

cheng nielsen 
open maps 
research series rs brics department computer science university aarhus apr 

emerson 
temporal modal logic 
van editor handbook theoretical computer science volume chapter pages 
elsevier science 

emerson halpern 
revisited branching versus linear time temporal logic 
journal association computing machinery january 

fiore cattani winskel 
weak bisimulation open maps 
proceedings fourteenth annual ieee symposium logic computer science 

hennessy 
modelling finite delay operators 
technical report university edinburgh 

hennessy stirling 
power perfect program logics 
information control pages 

hildebrandt 
categorical models concurrency independence fairness dataflow 
phd thesis department computer university aarhus denmark october 

hildebrandt panangaden winskel 
relational model non deterministic dataflow 
concur volume lncs pages 
springer verlag 

huth kwiatkowska 
semantics fair recursion divergence 
submitted 
technical report csr 

huth kwiatkowska 
finite unbounded delay synchronous ccs 
edalat jourdan mccusker editors advanced methods theory formal methods computing proceedings third imperial college workshop april pages 
imperial college press 

joyal nielsen winskel 
bisimulation open maps 
lics special issue information computation 
available brics report rs 

mac lane 
categories working mathematician 
springer 

mac lane moerdijk 
sheaves geometry logic topos theory 
springer 


mathematical logic 
undergraduate texts mathematics 
springer verlag 

milner 
calculus communicating systems 

milner 
finite delay operator synchronous ccs 
technical report university edinburgh dept computer science kings buildings 

milner 
calculi synchrony asynchrony 
theoretical computer science 

panangaden 
expressive power indeterminate primitives asynchronous computations 
technical report socs school cs mcgill 

plotkin 
powerdomain countable non determinism 
automata languages programming icalp ninth colloquium volume lncs pages 
springerverlag 

winskel 
generalised synchronisation trees 
handwritten notes 

winskel 
linear metalanguage concurrency 
amast volume lncs pages 
springer verlag 

winskel nielsen 
handbook logic computer science volume iv chapter models concurrency 
oup 

winskel nielsen 
presheaves transition systems 
peled pratt holzmann editors volume dimacs 
ams july 


lecture notes topoi 
world scientific 
grothendieck topology partial order give definitions grothendieck topology category sup topology specialised case partial order 
partial order define fp pg 
sieve set downwards closed set definition grothendieck topology partial order 
grothendieck topology partial order function assigns object set way maximal sieve stability transitivity sieve 
assume topology partial order describe presheaf op set sheaf respect assume element sieve covering matching family elements function assigns element element 
matching family element 
respectively separated presheaf sheaf respect object matching family sieve respectively unique 
definition separated presheaves sheaves 
partial order grothendieck topology sp sh full subcategories induced respectively separated presheaves sheaves respect topology clear context just write respectively sp sh 
sequence inf defined sec 
sieve simply prefix closed set sequences sup topology inf sequence assigns set fs sieve supremum 
easy check satisfy conditions def 
works partial order 
topology fact canonical topology inf largest topology inf sheaf definition sup topology inf 
partial order inf sup topology gg inf note finite contains just maximal sieve proof full abstraction give detailed proof outline prop 
sec 
repeated 
recall refer set closed terms sccs guarded recursion term standard subterms 
refer set possible open terms sccs guarded recursion 
proposition prop 
sec 

standard term exists inf open morphism generalised transition systems 
need preliminary definitions 
term sccs fv denote set free variables define gd guard depth gd gd gd ig gd gd gd rec gd gd gd 
convention successor 
defined ordinal necessarily finite number sums infinite 
key property gd inductive proofs guard depth terms guarded induction 
lemma 
guarded gd gd 
proof 
straightforward structural induction 
term define sd depth sd sd sd rec sd sd sd sd sd 
simply maximal depth finite 
gst adm act define gst adm act fs 
act adm adm term adm act 
recall inf unique element 
adm act 
note closed term term free variable say 
term define height 
note ready define underlying maps states morphisms 
definition 
define founded recursion follows writing sum rec rec el del del 
rec rec isomorphism defined sec founded order lexicographical order gd gd 
difficult check definitions sec 
applied states right hand side defining equations 
map get collection maps ff nicely related 
lemma 
ff collection maps 
exists collection isomorphisms generalised synchronisation trees proof 
sketch proceed induction height states define roots 
define define transfinite induction gd 
induction step assume 
exists unique define sn 
difficult verify defines isomorphism assuming get induction lemma follows maps just defined underlying maps fin open morphisms fin fin 
lemma 
ff collection maps def 

transition relation operational semantics fig 
fig 
proof 
show transfinite induction gd follows lem 

corollary 
maps defines map underlying map fin open morphism fin fin 
show maps define maps generalised transition systems show preserve admissible computations 
infinite admissible computation find non empty prefix image initially waiting 
lemma 
term adm infinite admissible computation 
assume exists os waiting 
proof 
easy induction sd lem 

follows simple mathematical induction preserves admissibility 
lemma 
term adm adm extension computations defined def 

conclude lem 
cor 
lem 
defines morphism generalised transition systems 
proposition 
term underlying map states morphism generalised transition systems refer 
show inf open morphism check zig zag conditions prop 
sec 

mentioned condition follows directly lem 

show second condition suffices show reflects admissible computations adm adm adm adm comp adm proof goes structural induction case rec add term calculus sccs 
operational semantics extended adding rule act denotation take explicit terminal element sp inf map isos extending def 
lem 
defined obvious way 
property maps connection substitution 
lemma 
term fv fxg 
morphism os el 
os el 
proof 
assume morphism os el 
founded induction prove fv fxg os el 
founded order def 
gd gd 
lemma special cases giving corollaries 
corollary 
term fv fxg unique morphism terminal presheaf 
comp el inadmissible inadmissible 
standard term fv fxg define 
corollary 
standard term fv fxg rec rec isomorphism sec 

comp rec rec el inadmissible rec inadmissible 
proof 
definition rec rec el standard term os rec get rec os rec el rec desired result follows lem 
def 
noting rec rec 
lemma 
term fv fxg 
adm adm adm adm implies adm adm adm adm proof 
easy induction proposition 
standard term fv fxg 
adm adm implies adm adm proof 
sketch structural induction lem 
lem 
lem case recursion 
take closed term proposition get reflects admissibility wanted show 
corollary 
standard term adm adm 
