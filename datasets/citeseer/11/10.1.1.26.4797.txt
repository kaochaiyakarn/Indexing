multispace evolutionary platform infrastructural services steven gribble matt welsh eric brewer david culler university california berkeley brewer cs berkeley edu presents architecture base clustered environment building executing highly available scalable exible adaptable infrastructure services 
architecture organizing principles addressing dicult service faulttolerance availability consistency problems carefully controlled environment building environment collection execution environments receptive mobile code dynamically generated code introduce run time generated levels indirection separating clients services 
prototype java implementation base called multispace talk applications written prototype ninja jukebox cluster music warehouse keiretsu instant messaging service supports heterogeneous clients 
show multispace implementation successfully reduces complexity implementing services platform conducive rapid service evolution 
performance utility personal computer defined faster intel processors new microsoft software increasingly internet services software 
news article excerpt disorganized collection data repositories web pages internet landscape populated rich industrial strength applications 
businesses organizations counterparts web banks restaurants stock trading services communities governments countries 
applications possess similar properties traditional utilities telephone network power grid support large potentially rapidly growing populations available complex engineering simple interfaces 
believe internet evolving infrastructure high quality utility applications commonplace 
traditional utilities internet services tend rapidly evolve typically customizable user may composable 
today internet services mature process modifying services quite immature 
authors complex new services forced engineer substantial amounts custom service speci code largely diversity requirements service dicult conceive general purpose reusable shrink wrapped adequately customizable extensible service construction product 
faced seemingly inevitable engineering task authors tend adopt strategies adding new services internet landscape exible highly tuned hand constructed services far dominant service construction strategy internet 
service authors carefully design system targeted speci application feature set operating system hardware platform 
examples systems large carrier class web search engines portals application speci web sites news stock trading shopping sites 
rationale approach sound leads robust high performance services 
software architectures systems restrictive result xed service performs single rigid function 
large amount carefully crafted hand tuned code means services dicult evolve consider example hard radically change behavior popular search engine service move service new environment sorts modi cations take massive engineering ort 
emergent services world distributed objects strategy just popularized architectures sun jini ongoing corba ort 
world complex exible services large numbers components objects available wide area services emerge composition components 
approach bene adding internet landscape simpler task granularity contributed components smaller 
explicit decomposition world smaller pieces simpler extend services dropping set components linking 
signi cant disadvantages approach 
side ect evolutionary nature services dicult manage state system state may arbitrarily replicated distributed wide area 
wide area network partitions commonplace meaning nearly impossible provide consistency guarantees maintaining reasonable amount system availability 
furthermore possible incremental localized changes system dicult large global changes system components may span administrative domains 
advocate third approach 
argue reap bene ts distributed objects approach avoiding dicult state management problems encapsulating services service state carefully controlled environment called base 
outside world base provides appearance guarantees non distributed robust highly available high performance service 
base services aren constructed brittle restrictive software architectures grown multiple smaller reusable components distributed workstation cluster 
components may replicated nodes cluster purposes fault tolerance high performance 
base provides glue binds components keeping state replicated objects consistent ensuring constituent components available distributing trac components cluster necessary 
rest discusses design principles advocate architecture base section presents preliminary base implementation called ninja multispace section uses techniques dynamic code generation code mobility mechanisms demon multispace implementation available ninja platform release see ninja cs berkeley edu 
service service client code node node node node node node node node client base stub stub service service architecture base base comprised cluster workstations connected high speed network 
node houses execution environment code pushed 
services instances cluster clients shielded service stub interact cluster 
evaluating hypotheses service exibility rapid evolution robustness change 
begun preliminary explorations scalability high availability aspects prototype explicit focus initial implementation remains subject 
example services running prototype base described section 
section discuss lessons learned building prototype 
section presents related section draw 
organizing principles section design principles guided service architecture development shown high level gure 
solve challenging service availability scalability problems carefully controlled environments bases 
gain service exibility decomposing bases number receptive execution environments 
introduce level indirection clients services dynamic code generation techniques 
discuss principles turn 
solve challenging problems base high availability scalability utility requirements internet services require di cult deliver rst principle attempt simplify problem meeting carefully choosing environment tackle issues 
argue clusters workstations provide best platform build internet services :10.1.1.1.2034
clusters allow incremental scalability addition extra nodes high availability replication failover commodity building blocks basis computing environment 
clusters backbone base 
physically base include necessary keep mission critical cluster running system administrators physically secure machine room redundant internal networks external network feeds ups systems 
logically cluster wide software layer provides data consistency availability fault tolerance mechanisms 
power locating services inside base arises assumptions service authors designing services 
communication fast local network partitions exceptionally rare 
individual nodes forced homogeneous necessary node dies identical replacement available 
storage local cheap plentiful 
single domain simplifying administration 
outside base try duplicate fault tolerance data consistency guarantees base 
example mail clients attempt keep local copies mail messages capacity cache messages permanently kept mail service base 
services promise highly available user rely able access email network connected 
receptive execution environments internet services generally built complex assortment resources including heterogeneous single cpu multiprocessor systems disk arrays networks 
cases services constructed rigidly placing functionality particular systems statically partitioning resources state 
approach represents view service design implementation ed carefully planned laid available hardware 
regime little tolerance failures disrupt balance structure service architecture 
alleviate problems associated approach base architecture employs principle receptive execution environments systems dynamically con gured host component service software 
collection receptive execution environments constructed set homogeneous workstations diverse resources required service 
distinguishing feature receptive execution environment service grown top fertile platform functionality pushed node appropriate application 
node base remotely dynamically con gured uploading service code components needed allowing delay decision details particular node specialization far possible service construction maintenance lifecycle 
see section approach single assumption homogeneity systems base java virtual machine available node 
doing raise bar service construction providing common instruction set nodes uni ed views threading models underlying system apis socket lesystem access usual strong typing safety features orded java environment 
provisions service component pushed node base expected execute subject local resource considerations particular node access disk array cd drive 
assuming node capable receiving java bytecodes means techniques generally applied mobile code systems employed internally base administrator deploy service components uploading java classes nodes needed service push resources redistributing code participating nodes :10.1.1.103.9804:10.1.1.40.1741
furthermore environment restricting code mobility deploying local code scope single trusted administrative domain security diculties mobile code reduced 
rely mechanisms mobile code security restrict mobile code inside base code originates trusted sources base java security manager mechanism sandbox mobile code 
research goals include solving mobile code security problem 
dynamic redirector stub generation challenge clustered servers single service interface outside world mask load balancing failover mechanisms cluster 
naive solution single frontend machine clients rst contact front dispatches incoming requests back machines 
failures hidden selection back machine load balancing directly controlled front dispatch algorithm 
unfortunately front performance bottleneck single point failure :10.1.1.1.2034
solution problems multiple front machines introduces new problems naming clients determine front consistency front ends mutually agree backend state cluster 
naming problem addressed number ways roundrobin dns static assignment front ends clients lightweight redirection style scalable web servers 
consistency problem solved distributed systems techniques ignored consistent state unimportant front nodes 
base architecture takes approach cluster access indirection redirector stubs 
stub clientside code provides access service common example stub code generated corba iiop java remote method invocation rmi systems 
stub code runs client converts client requests service functionality java method calls network messages marshalling request parameters unmarshalling results 
case java rmi clients download stubs demand server 
base services employ similar technique rpc stub generation redirector stub service dynamically generated run time contains embedded logic select set nodes cluster gure 
load balancing implemented redirector stub failover accomplished failed service calls alternative back machine 
redirection logic information state base built base advertised clients periodically clients obtain redirector stubs registry 
methodology number signi cant implications nature services idempotent maintain self consistency policy client server redirector stub embedded inside stub rpc stubs interface communicates di erent service instance inside base 
service instances di erent nodes base 
section discuss implementation cluster wide distributed data structure simpli es task satisfying implications 
client applications coded knowledge redirector stub logic moving failover load balancing functionality client front machines avoided altogether 
similar notion smart clients intelligence injected client run time compiled 
implementation prototype base implementation written java called multispace 
serves demonstrate ectiveness architecture terms facilitating construction exible services allow explorations issues platform scalability 
multispace implementation layers bottom layer set communications primitives middle layer single node execution environment ispace top layer set multiple node abstractions multispace layer 
describe turn bottom 
rich set high performance communications primitives necessary component clustered environment 
chose heavy java remote method invocation rmi facilities performing rpc calls nodes cluster clients services 
caller invokes rmi method stub code intercepts invocation arguments sends remote skeleton method handler unmarshalling execution 
rmi nest granularity communication data unit clustered environment useful properties 
cause method invocations completely encapsulated atomic semantics retransmissions communication failures easy reason correspond successful failed method invocations partial data transmissions 
point view clients remote method invocation successfully return impossible client know method successfully invoked server 
client choices method call risk calling method twice assume method invoked risking method fact invoked successfully unsuccessfully exception results returned client 
currently failure redirector stubs retry di erent randomly chosen service stub case successive failures redirector stub return exception caller 
semantics implied client side require services idempotent 
exploration different retry policies inside redirector stubs area research 
enhancements sun rmi ground reimplementation sun java remote method invocation components ninja system 
designed permit maximum exibility implementation options 
provides interesting transport level rmi enhancements 
provides unicast udp rmi allows clients call methods best ort semantics 
udp packet containing arguments successfully arrives service method invoked retransmissions attempted 
enforce requirement methods return values 
transport useful beacons log entries side ect oriented uses require reliability 
second enhancement multicast version unreliable transport 
rmi services associate multicast group rmi calls multicast group result method invocations listening services 
third enhancement provide exible certi cate authentication encryption support reliable unicast rmi 
endpoints rmi session associate digital certi cates issued certi cation authority 
tcp connection underlying rmi session established certi cates exchanged rmi layer veri ed endpoint 
certi cate veri cation succeeds remainder communication tcp connection encrypted triple des session key obtained die hellman key exchange 
security enhancements described 
packaged implementation interface compiler object exports rmi interface generates client side stub server side skeleton stubs object 
source code stubs skeletons generated dynamically run time allowing ninja system leverage intelligent code generation step constructing wrappers service components 
introduce level indirection needed implement redirector stubs stubs overloaded cause method invocations occur remote nodes method invocations fail auxiliary nodes case primary node failure 
measurements method local sun ninja method rmi rmi void ms ms int ms ms int int ms ms int int int int int ms ms byte ms ms byte ms ms byte ms ms byte int ms ms byte int ms ms byte int ms ms table microbenchmarks benchmarks gathered mhz pentium ii machines mb physical memory connected switched mb ethernet sun jdk just time compiler linux 
sake comparison udp round trip times programs measured ms java programs ms shown table performs better sun java rmi package 
null rmi invocation cost ms round trip network jvms cost ms conclude di erence roughly ms rmi marshalling pro tocol overhead 
pro ling code shows main contributor overhead object serialization speci cally methods java io read 
ispace base consists number workstations running suitable receptive execution environment single node service components 
prototype receptive execution environment ispace java virtual machine jvm runs component loading service java classes pushed needed 
ispace responsible managing component resources naming protection security 
ispace exports component loader interface interface allows remote client obtain list components running ispace obtain rmi stub particular component upload new service component kill component running ispace subject authentication 
service components running ispace protected surrounding execution environment ways 
component coded java class provides protection hard crashes null pointer dereferences 
components separated thread groups limits interaction component threads 
components subject ispace security manager traps certain java api calls determines component credentials perform operation question le network access 
assumptions order approach viable 
essence relying jvm behave perform miniature operating system designed 
example java virtual machine provide adequate protection threads multiple components running jvm component example consume entire cpu running inde nitely non blocking thread 
assume jvm employs preemptive thread scheduler true sun solaris java environment fairness guaranteed 
likewise ispace security manager utilize strategy resource management ensures fairness safety 
respect ispace similar goals systems provide multiple protection domains single jvm 
approach necessitate re engineering java runtime libraries particularly intra jvm thread communication high priority feature 
multispace highest layer implementation multispace layer collection gure 
primary function layer provide ispace replicated registry service instances running cluster 
multispace service inherits class constructor registers service instance running local ispace 
cluster cooperate maintain replicated registry periodically sends multicast beacon carries list local services nodes multispace listens multicast messages multispace nodes 
builds independent version registry beacons 
registries soft state similar nature cluster state maintained ispace node goes comes back simply listen multicast channel rebuild state :10.1.1.1.2034
registries di erent nodes may see temporary periods inconsistency services pushed multispace moved nodes multispace steady state nodes asymptotically approach consistency 
consistency model similar nature grapevine 
multicast beacons carry rmi stubs local service component implies service instance running node multispace identify contact service multispace 
means node information construct redirector stubs services multispace advertise redirector stubs cluster clients service discovery service 
rmi stub embedded currently ip multicast purpose multicast channel beacons sent de nes logical scope boundary individual multispace 
intend replace transport multicast 
service discovery service sds implementation consists xml search engine allows client programs locate services arbitrary xml predicates 
svc svc multicast beacon system area network service service security mgr 
java virtual machine ispace node ispace loader service security mgr 
java virtual machine svc ispace node multispace implementation multispace services instantiated top sandbox security manager run inside context java virtual machine jvm 
multicast beacon observations roughly bytes average length important tradeo beacon frequency freshness information number services stubs ultimately ect scalability multispace 
service instances elect receive multicast beacons multispace nodes service mechanism aware peers running cluster 
service overrides standard beacon class augment beacons additional information load currently experiencing 
services want call services coarse grained load balancing decisions requiring centralized load manager 
built multispace services included multispace implementation services enrich functionality available multispace services distributed hash table uptime monitoring service 
distributed hash table mentioned section due redirector stub mechanism multispace service instances maintain nodes cluster 
task simpler provided service authors distributed replicated fault tolerant hash table implemented sake ef ciency 
hash table designed consistent view data nodes cluster services may rendezvous style similar linda ibm spaces 
current implementation moderately fast handle insertions second byte entries node mb multispace cluster fault tolerant transparently mask multiple node failures 
provide consistency guarantees services ideally prefer line recovery crashed state transactions multiple operations 
currently implementation suitable internet style services level consistency essential 
uptime monitoring service service beaconing mechanism dicult detect failure individual nodes cluster 
partly lack clear failure model java java service just collection objects necessarily possessing thread execution 
service failure may just imply set objects entered mutually inconsistent state 
absence beacons doesn necessarily mean service instance failure occurred beacons may lost due congestion internal network beacons may generated service instance overloaded busy processing tasks 
reason provided uptime monitoring abstraction service authors 
service running multispace implements wellknown java interface infrastructure automatically detects begins periodically calling method interface 
implementing method service authors promise perform application level task demonstrates service accepting successfully processing requests 
application level uptime check infrastructure explicitly detect service instance failed 
currently log failure order generate uptime statistics rely redirector stub failover mechanisms mask failures 
applications section discuss applications demonstrate validity guiding principles ecacy multispace implementation 
rst application ninja jukebox abstracts independent compact disc players local berkeley network workstations cluster single pool available music 
second keiretsu tiered application provides instant messaging heterogeneous devices 
ninja jukebox gui users single jukebox interface songs jukebox scattered multiple workstations may mp les local lesystem audio cds cd rom drives 
ninja jukebox original goal ninja jukebox harness audio cd players berkeley node cluster sun ultrasparc workstations provide single giant virtual music jukebox berkeley cs graduate students 
interesting features ninja jukebox arise implementation top ispace new nodes dynamically harnessed pushing appropriate cd track ripper services features ninja jukebox simple evolve customize evidenced seamless transformation service batch conversion audio cds mp format authenticated transmission mp network 
ninja jukebox service decomposed components master directory cd ripper indexer gateway online service provides artist track title information cd serial number 
ability push code cluster grow service proved exceptionally useful didn decide priori nodes cluster house cds dynamically push ripper indexer component cds cds inserted nodes cluster 
new cd added node cluster master directory service pushes instance ripper service ispace resident node 
ripper scans cd determine music 
contacts local instance service gather detailed information cd artist track titles information put playlist periodically sent master directory service 
master directory incorporates playlists running cluster single global directory music directory available rmi song browsing selection simple audio streaming 
ninja jukebox running users expressed desire add mp audio les jukebox 
add new behavior subclass cd ripper indexer recognize mp audio les local lesystem create new jukebox components batch converted audio cds mp les 
protect copyright music system added access control lists mp repositories policy users listen music added jukebox 
began pushing new subclass nodes system system evolved running 
performance ninja jukebox completely dominated overhead authentication network bandwidth consumed streaming mp les 
rst factor authentication overhead currently benchmarked seconds certi cate exchange entirely due pure java implementation public key cryptosystem 
second factor network consumption quite signi cant mp consumes kb mp les streamed transmission characterized large burst mp pushed network quickly possible 
limitations remedied signi cant engineering scope research 
keiretsu ninja service keiretsu multispace service provides instant messaging heterogeneous devices web browsers way pagers pdas palm pilot see 
users able view list users connected keiretsu service send short text messages users 
service component keiretsu exploits multispace features keiretsu service instances soft state registry peer nodes order exchange client routing information cluster automatically generated redirector stubs handed clients communicating keiretsu nodes 
acl policy enforced authentication extensions described 
keiretsu japanese concept group related companies mutual success 
keiretsu service message sent multispace message routed destination active proxy active proxy converts outgoing msg rmi active proxy converts message pilot format receiving pilot displays message user enters message pilot multispace keiretsu service keiretsu tired application simple client devices pagers palm pilots run jvm connect active proxy thought simpli ed ispace node meant run soft state mobile code 
active proxy converts simple text messages devices calls keiretsu multispace service 
active proxies assumed sophistication run java mobile code protocol conversion routines speak rudimentary client devices need speak simple text protocol 
described section redirector stubs access back service components multispace pushing load balancing failover logic client case simple clients redirector stubs execute active proxy 
protocol message received active proxy user device send message user redirector stub invoked call multispace 
keiretsu proxy mobile java component runs ispace keiretsu proxy service pushed appropriate locations demand making easy bootstrap active proxy needed 
state management inside active proxy simpler state management inside base state active proxies maintain session state connected clients 
session state soft state need carefully guarded regenerated sucient intelligence base having users manually recover sessions 
rudimentary devices allowable members keiretsu 
complex clients run jvm speak directly keiretsu going active proxy 
example client mail agent attaches keiretsu acts gateway relaying keiretsu messages users internet mail 
keiretsu multispace service public void string public void string public void msg public string keiretsu service api multispace service performs message routing surprisingly simple 
shows api exported service clients 
method client periodically announces presence keiretsu hands keiretsu rmi stub service send messages 
client stops calling method keiretsu assumes client disconnected way participation keiretsu treated lease 
alternately client invalidate binding immediately calling method 
messages sent calling method clients obtain list connected clients calling method 
inside keiretsu nodes maintain table nodes listening multispace beacons discussed section 
client connects keiretsu node node sends client rmi stub nodes keiretsu nodes maintain individual tables client bindings 
means steady state node route messages client 
clients access keiretsu service redirector stubs keiretsu nodes replicate service state individual nodes keiretsu fail service continue uninterrupted cost capacity performance 
experiment node cluster demonstrated service continued uninterrupted nodes went 
keiretsu source code consists pages java code code deals managing soft state tables keiretsu nodes cluster client rmi stub bindings 
actual business routing messages clients consists half page java code rest service functionality building advertising redirector stubs tracking service implementations cluster load balancing failover nodes hidden inside multispace layer 
believe multispace implementation quite successful shielding service authors signi cant amount complexity 
keiretsu performance ran experiment measure performance scalability multispace implementation keiretsu service 
cluster mhz pentium ii machines mb physical memory connected mb switched ethernet 
implemented keiretsu clients open parameterizable number identities keiretsu waits receive messages driver grabs parameterizable number redirector stubs keiretsu downloads list clients keiretsu byte messages randomly selected clients fast 
started keiretsu service single node incrementally grew cluster nodes measuring maximum message throughput obtained receivers number nodes cluster 
achieve maximum throughput added incrementally driver connections message delivery saturated 
drivers located dedicated machines connected keiretsu cluster mb switched ethernet 
table shows results 
small number receivers node observed linear scaling message throughput 
node keiretsu essentially independent small amount state shared client stubs receivers node 
case cpu bottleneck due java overhead message processing argument marshalling unmarshalling 
larger number receivers observed clients max 
message nodes node throughput msgs table keiretsu performance benchmarks run mhz pentium ii machines mb physical memory connected mb switched ethernet sun jdk just time compiler linux sending byte keiretsu messages 
breakdown scaling total number receivers reached roughly nodes receivers node nodes receivers node 
cpu bottleneck cases cpu time spent processing client stubs exchanged keiretsu nodes processing clients messages 
due poor design keiretsu service need client stubs frequently simply exchanged timestamps previously distributed stubs repeatedly sending stub 
limitation removed modifying keiretsu service inject client stubs distributed hash table rely service instances pull stubs table needed 
similar state exchange happens multispace layer multicast exchange service instance stubs potentially scaling bottleneck large clusters 
discussion multispace service implementation efforts insights original design principles java internet service construction language 
section delve insights 
code mobility service construction primitive designing multispace knew code mobility powerful tool 
originally intended code mobility delivering code clients form redirector stubs clients upload customization code multispace implemented 
code mobility turned useful inside multispace mechanisms structuring services distributing service components cluster 
code mobility solved software distribution problem jukebox realizing software distribution problem 
updated ripper service needed distribute new functionality nodes cluster potentially cd inserted 
code mobility partially solved service location problem jukebox ripper services depend service gather detailed track album information ripper easy way know cluster service running 
code mobility push service node ripper enforced invariant service colocated ripper 
bases simplifying principle complete solution principle solving complex service problems base easier reason interactions services clients ensure dicult tasks state management dealt environment chance success 
organizational principle solve problem constructing highly available services 
controlled environment base service authors construct services ensure consistency availability 
believe base provide primitives simply service authors jobs redirector stub example primitive 
building ninja jukebox keiretsu observations achieved availability consistency 
code services dealt distributing maintaining tables shared state 
ninja jukebox state list available music 
keiretsu state list keiretsu nodes tables client stub bindings 
distributed hash table complete services implemented 
relied ad hoc peer state exchange mechanisms services source code eliminated 
services queues explicitly exposed service authors 
queues hidden inside thread scheduler spawns thread connected client 
design decision repercussions service structure service written handle multithreading service authors handle consistency single service instance instances cluster 
providing mechanism expose queues service authors may simplify structure services example services serialize requests avoid issues associated multithreading 
current multispace service instances explicitly keep track counterparts nodes spawn new services load availability demands 
useful primitive allow authors specify conditions dictate service instances spawned pushed speci node allow multispace infrastructure handle triggering conditions 
java internet service construction environment java proven invaluable tool development ninja infrastructure 
ability rapidly deploy cross platform code components simply assuming existence java virtual machine easy construct complex distributed services concerning oneself heterogeneity systems involved 
rmi strongly typed rpc tied closely java language semantics distributed programming comparably simple single node development 
protection modularization safety guarantees provided java runtime environment dynamic dissemination code components natural activity 
similarly java class re ection generate new code wrappers existing components redirector stubs provides automatic indirection object level 
java number drawbacks current form 
performance issue just time ahead time compilation addressing problems 
widely jvm sun microsystems exhibits large memory footprint observed mb hello world mb relatively simple application performs memory allocations crossing boundary java native code remains expensive operation 
addition java threading model permits threads nonpreemptive serious implications components run protected environment 
approach java virtual machines employ preemptive threads 
started ort improve performance java runtime environment 
initial prototype called jaguar permits direct java access hardware resources modi ed just time compiler 
going relatively expensive java native interface access devices jaguar generates machine code direct hardware access inlined compiled java bytecodes 
implemented jaguar interface enabled fast system area network obtaining performance equivalent access microseconds round trip time small messages megabits second peak bandwidth 
believe approach viable way tailor java environment highperformance clustered environment 
related directly related base architecture tacc platform provides environment scalable internet services :10.1.1.1.2034:10.1.1.1.2034
tacc service components workers written number languages controlled front machine dispatches incoming requests back cluster machines incorporating load balancing restart case node failure 
tacc workers may chained cluster composable tasks 
tacc designed support internet services perform data transformation aggregation tasks 
base services additionally implement long lived persistent services result ninja approach addresses wider set potential applications system support issues 
furthermore base services dynamically created destroyed ispace loader interface multispace node tacc functionality 
explicit java deallocation mean discarding object enabling garbage collected 
virtual interface architecture speci es industry standard architecture highbandwidth low latency communication clusters 
sun jini architecture similar base architecture proposes develop java lingua franca binding users devices services intelligent programmable internet wide infrastructure 
jini rmi basic communication substrate code mobility distributing service device interfaces great deal rapport approach 
believe addressing problems jini directly solve providing hardware software environment supporting scalable fault tolerant services jini problem domain dynamically generated code components act interfaces services 
jini touched issues service discovery naming dealt base architecture likewise jini javaspaces leases persistent storage model may interact base service model 
ants system enables dynamic deployment mobile code implements network protocols active routers 
coded java utilizing techniques similar ispace environment ants similar set goals mind base architecture 
ants uses mobile code processing packet passing router base service components executed granularity rmi call 
liquid software similar ants propose environment uses mobile code customize nodes network communications oriented tasks 
systems focused adapting systems level network protocol code base architecture uses code mobility distribution service components internally externally base 
sanfrancisco platform building distributed object oriented business applications 
primary goal simplify development applications providing developers set industrial strength foundation objects implement common functionality 
sanfrancisco similar sun enterprise java beans provides framework constructing applications reusable components sanfrancisco providing number generic components start 
multispace addresses di erent set goals enterprise java beans sanfrancisco de nes exible runtime environment services multispace intends provide scalability fault tolerance leveraging exibility component architecture 
multispace services built ejb sanfrancisco model extended expose multispace functionality issues appear orthogonal 
distributed computing environment dce software suite provides middleware platform operates operating systems environments 
dce abstracts away os network services threads security directory service rpc allows programmers implement dce middleware independent vagaries particular operating systems 
dce rich robust notoriously heavyweight focus providing interoperable widearea middleware 
multispace far mature focuses providing platform rapidly adaptable services housed single administrative domain base 
architecture base clustered hardware software platform building executing exible adaptable infrastructure services 
base architecture designed adhere organizing principles solve challenging service availability scalability problems carefully controlled environments allowing service authors assumptions valid uncontrolled wide area environment gain service exibility decomposing bases number receptive execution environments introduce level indirection clients services dynamic code generation techniques 
built prototype implementation multispace base architecture java foundation 
implementation took advantage code mobility dynamic compilation techniques help structuring deployment services inside cluster 
multispace abstracts away load balancing failover service instance detection naming service authors 
multispace platform implemented novel services ninja jukebox keiretsu 
ninja jukebox implementation demonstrated code mobility valuable inside cluster environment permits rapid evolution services run time binding service components available resources cluster 
keiretsu application demonstrated multispace layer successfully reduced complexity building new services core keiretsu service functionality implemented page code application demonstrably fault tolerant 
demonstrated keiretsu code limited scalability service inherent limitation multispace layer hypothesized multicast beacons ultimately limit scalability current multispace implementation 
authors ian goldberg david wagner contributions ispace jukebox application 
graduate undergraduate students ninja project agreeing guinea pigs platform brian keith help system multispace machines networks 
anonymous reviewers shepherd charles insight suggestions improvement 
elan amir steven mccanne randy katz 
active service framework application real time multimedia transcoding 
proceedings acm sigcomm volume pages october 
anderson shasha 
persistent linda linda transactions query processing 
springer verlag lecture notes computer science mont saint michel france june 
thomas anderson david culler david patterson 
case networks workstations ieee micro february 
ken birman andre schiper pat stephenson 
lightweight causal atomic group multicast 
acm transactions computer systems 
andrew birrell bruce jay nelson 
implementing remote procedure call 
acm transactions computing systems february 

rfc dns support load balancing april 
ibm 
ibm sanfrancisco product homepage 
www software ibm com ad sanfrancisco 
inktomi 
technology hotbot 
www inktomi com html may 
steven czerwinski ben zhao todd hodes anthony joseph randy katz 
architecture secure service discovery service 
proceedings mobicom seattle wa august 
acm 
birrell grapevine exercise distributed computing 
communications association computing machinery feb 
armando fox steven gribble chawathe eric brewer paul gauthier :10.1.1.1.2034
cluster scalable network services 
proceedings th acm symposium operating systems principles st malo france october 
ian goldberg steven gribble david wagner eric brewer 
ninja jukebox 
submitted nd usenix symposium internet technologies systems boulder colorado usa october 
robert gray 
agent tcl flexible secure mobile agent system 
proceedings fourth annual usenix tcl tk workshop 
usenix association 
open group 
compiler project 
www gr org java compiler index htm 
hartman peterson bridges proebsting spatscheck 
platform liquid software 
ieee network special edition active programmable networks july 
chris hawblitzel chi chao chang grzegorz czajkowski hu thorsten von eicken 
implementing multiple protection domains java 
proceedings usenix annual technical conference june 
open group research institute 
scalable highly available web server project 
www osf org ri htm 
dag johansen robbert van renesse fred schneider 
operating system support mobile agents 
proceedings th ieee workshop hot topics operating systems 
john hartman udi manber larry peterson todd proebsting 
liquid software new paradigm networked systems 
technical report department computer science university arizona june 
brad curtis johnson 
distributed computing environment framework osf perspective 
technical report dev dce tp open group june 
eric jul henry levy norman hutchinson andrew black 
fine grained mobility emerald system 
acm transactions computing systems 
ti kan steve 
speci 
www com ftp docs howto gz 
sun microsystems 
java remote method invocation distributed computing java 
java sun com 
sun microsystems 
solaris jit compiler 
www sun com solaris jit 
object management group omg 
common object request broker architecture speci cation february 
www omg 
org library indx html 
virtual interface architecture organization 
virtual interface architecture speci cation version december 
www org 
todd proebsting gregg townsend patrick bridges john hartman tim scott 
toba java applications way ahead time wat compiler 
proceedings third usenix conference object oriented technologies coots portland oregon usa june 
joseph luis valente 
mobile agent security telescript 
proceedings st international conference ieee computer society compcon february 
david tennenhouse jonathan smith david david wetherall gary 
survey active network research 
active networks home page mit networks systems group 
david tennenhouse david wetherall 
active network architecture 
acm sigcomm computer communications review acm 
jim waldo 
jini architecture overview 
available java sun com products jini whitepapers 
james white 
telescript technology foundation electronic marketplace 
www com 
lehman ford 
tspaces 
ibm systems journal april 
yoshikawa chun vahdat anderson culler 
smart clients build scalable services 
proceedings winter usenix technical conference january 
