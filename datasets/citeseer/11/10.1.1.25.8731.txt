bisimulation minimization automata theoretic verification framework moshe vardi department computer science rice university main ms houston tx cs rice edu www cs rice edu october bisimulation seemingly attractive state space minimization technique computed automatically yields smallest model preserving calculus formulas 
considered impractical symbolic model checking required bdds prohibitively large designs 
revisit bisimulation minimization time automata theoretic framework 
bisimulation potential framework intersecting design negation property minimization ignore atomic propositions 
compute bisimulation algorithm due lee yannakakis represents bisimulation relations equivalence classes explores reachable classes 
greatly improves time memory usage naive algorithms 
demonstrate bisimulation practical designs framework 
cases cost performing reduction outweighs conventional model checking 
symbolic model checking dramatic impact formal verification 
binary decision diagrams bdds provide efficient canonical symbolic representation digital systems enables complete analysis systems exceedingly large state spaces 
bdd model checkers enjoyed substantial growing industrial years discovering subtle flaws designs considerable complexity 
growing size current semiconductor designs seriously challenges current model checking technology 
despite technological advances increase design complexity known state explosion problem remains serious obstacle industrial scale verification 
research combating state explosion takes forms including alternate representations transition systems compositional reasoning various state space reduction techniques :10.1.1.26.9713:10.1.1.116.9247
techniques form abstraction 
abstraction suppresses information concrete state space mapping smaller state space 
set concrete states mapping single state forms equivalence class abstraction 
hopefully model amenable model checking 
abstraction safe verification model carry concrete model 
formally abstraction preserve truth shorter version appeared proceedings international conference formal methods computeraided design 
part nsf cda ccr ccr intel 
falsehood properties interest 
abstractions preserving truth falsehood provide strong preservation preserving truth provide weak preservation 
ideally want abstractions meet conditions 
yield smallest safe models 
second constructing require minimal manual involvement 
second crucial abstraction industrial environment 
current techniques generally fail satisfy criterion significantly limits applicability 
need means compare size models 
say abstraction coarser abstraction collapses subsets equivalence classes 
coarser abstraction smaller state space 
properties preserved generally dictate maximal coarseness safe abstractions 
bisimulation general abstraction satisfying conditions 
bisimulation collapses states local properties bisimilar successor states 
coarsest abstraction strongly preserves properties expressible propositional calculus expressively subsumes ctl extension linear temporal logic ltl branching temporal logic ctl 
furthermore computed completely automated fashion requiring understanding design consideration 
straightforward compute symbolically suggests approach state space reduction context symbolic model checking 
unfortunately reported clarke bdds compute bisimulation relation get overly large practice accordingly concluded computing bisimulations feasible approach algorithmic state space reduction 
revisits bisimulation reductions time automata theoretic framework 
change framework significant 
automata framework model checking involves intersecting design automaton automaton representing negation property checking fair path exists 
restricted single simple property bisimulation abstraction coarser bisimulation design atomic propositions design need considered 
performed naively approach suffers problem exploding bdds bisimulation relation binary relation state space states described terms boolean variables bisimulation relation boolean variables resulting large bdds 
overcome problem algorithm due lee yannakakis 
algorithm key ideas computes bisimulations reachable state space second computes equivalence classes bisimulation relation bisimulation relation 
combining automata theoretic approach lee yannakakis algorithm able larger designs bisimulation previously possible 
unfortunately computing abstraction result significant reduction size state space gain obtained reduction offset cost computing 
state space reduction bisimulation abstractions useful technique applicability universal 
outline follows 
section discusses experimental framework 
section reviews bisimulation algorithms computing 
section describes experiences lee yannakakis algorithm automata theoretic framework 
discuss variant algorithm section comparative results traditional model checking section 
section presents related 
concluding remarks directions appear section 
experimental framework conducted experiments framework built vis model checker 
chose vis reasons supports automata theoretic model checking second tool engineered extensions relatively easy third uses verilog input language examples easier find model checker input languages 
experiment suite contains designs taken vis distribution 
include bit counter traffic light controller arbiter mutual exclusion protocols cache coherence protocol railway controller elevator tree structured arbiter 
tested properties taken properties distributed examples 
possible test safety property liveness property design 
experiments include properties hold respective designs 
manually translate negated properties verilog state machines 
experiment described vis front get symbolic representation corresponding transition system 
algorithms symbolic representations operations provided vis reachability computations 
attempt control intermediate bdd sizes vis partitioned transition relation representation original transition system 
minimized transition system monolithic transition relation 
experiments run ultrasparc megabytes memory running solaris 
important note regarding memory statistics order 
vis somenzi package 
depending setting parameter may substantially memory needed computation factor experience attempt improve time efficiency 
set parameter low value runs memory statistics tight possible 
figures may imprecise report maximum number live bdd nodes computation 
provide approximated manually inserting checks code 
computing bisimulation bisimulation equivalence relation states transition system 
distinguishes states requirements agree values subset atomic propositions transitions state lead bisimilar states 
subset atomic propositions states agree depends application 
general bisimulation minimization consider variables state variables atomic propositions referenced properties 
verifying particular property state variables atomic propositions affecting property need considered 
experiments heed observation 
formally define transitions systems bisimulation follows 
transition system tuple hs ap set states theta transition relation ap set atomic propositions theta ap indicates atomic propositions true state ap captures fairness condition 
element indicates set states single fairness constraint holds 
buchi fairness constraints fair paths pass state element infinitely 
sets states comprising may specified user level formulas 
purposes discussion prefer state view 
assume unique atomic proposition ap fi corresponding set states ap fi iff contained atomic propositions ensure fairness condition preserved bisimulation 
transition relation hs ap subset ap ap binary relation theta bisimulation relation relative ap iff conditions hold pair states 
atomic proposition ap ap ap iff ap 
exists 
exists compute bisimulation symbolically computing complement pairs states fail meet conditions 
interested maximum bisimulation relation distinguishes states possible 
computing fixpoint equation yields complemented maximum relation ap ap ap ap experiments bisimulation computation completed smaller examples shown table 
results strongly indicate plain symbolic bisimulation computation infeasible state space reduction technique large designs support similar drawn clarke runs default value order save computation time 
eisenberg computations took full day complete 
state atomic equivalence max live memory variables propositions classes nodes mb counter tlc tlc elev eisenberg eisenberg table computing bisimulation symbolic algorithm 
numbers design names distinguish various properties consideration 
types property appear table 
atomic propositions column indicates variables appear respective property 

section shows bisimulation feasible large designs conditions represent bisimulation equivalence classes binary relation consider reachable equivalence classes performing bisimulation minimize intersecting automaton negation desired property 
making bisimulation tractable bisimulation previous section intractable largely computed relation defined variables number boolean state variables original design 
doubling yields extremely large bdds moderate size designs 
addition relation may distinguish large numbers states considering atomic propositions original design 
general large relations necessarily imply large bdds evidence shows bisimulation relations large practice 
reducing size relation reasonable approach try resulting bdds tractable 
experiments address problems 
algorithm due lee yannakakis represents bisimulation relation set equivalence classes defined variables monolithic binary relation variables 
section provides overview algorithm 
intersect negation property design minimization reducing number atomic propositions need considered 
remaining parts section show running algorithm intersected automaton render bisimulation tractable minimization technique 
lee yannakakis algorithm lee yannakakis bisimulation algorithm desirable features 
represents relation equivalence classes pairs related states 
second computes bisimulation reachable state space 
model checkers long ignored unreachable states sake efficiency 
traditional formalization bisimulation distinguish equivalence classes contain reachable states 
experiments show number equivalence classes containing reachable states substantial 
parallels large number unreachable states systems 
combination minimization reachability offers advantages 
algorithm minimize line 
augmenting algorithm fly model checker conceivable verify designs large straightforward model checking traditional minimization techniques 
second combination allows representatives selected edge blocks minimized system edge representatives original system 
useful reporting error traces model checking 
path minimized system corresponds legitimate path original design representatives 
stack iig initial state block containing queue partition contains block combination atomic propositions search stack hb pi pop stack foreach block hc qi containing state contains state successor enqueue hb pi defined select set add edge hb pi hc qi gamma enqueue hb pi split queue hb pi delete queue fq blocks blocks gamma add block partition foreach edge hc qi hb pi minimized system elements reach enqueue hc qi elements reach enqueue hc qi successor delete edge hc qi hb pi successor block marked select mark push block stack add edge hc qi hb stack goto search lee yannakakis combined bisimulation reachability algorithm 
transition relation system minimized 
term block refers equivalence class representative 
pseudocode enqueue operation checks block queue enqueuing 
state reachable reachable reach 
max live memory variables states classes saved nodes mb counter tlc tlc elev eisenberg eisenberg bakery arbiter table computing bisimulation plus reachability lee yannakakis algorithm 
properties new designs bakery arbiter referred atomic propositions 
figures bakery hold bakery properties atomic propositions 
reach 
saved column reflects ratio reachable classes reachable states 
algorithm starts partition states equivalence classes atomic propositions 
reachable equivalence class stores single reachable state acting representative class 
implementation represents bdd 
structures stack queue store equivalence classes need processing 
classes stack processed construct outgoing edges 
classes queue split multiple equivalence classes order preserve bisimulation relation 
algorithm terminates stack queue empty 
classes represented explicitly elements represented symbolically algorithm viewed converting symbolically represented transition system explicitly represented minimized transition system 
summary appears 
minimized bisimulation designs experiment lee yannakakis algorithm compute bisimulation designs intersecting negated property 
minimization considered atomic propositions appearing respective property fairness constraints 
shown table representing equivalence classes accounting reachable classes enable compute bisimulation efficiently larger collection designs 
comparing number reachable classes total number equivalence classes shown table see percentage classes reachable small larger examples 
figures representation reachability appear significant factors bisimulation tractability 
minimizing relative properties bisimulation computations previous section considered atomic propositions appearing properties required support fairness constraints 
possible reduce number atomic propositions consideration 
working automata theoretic framework negation property intersected original design automaton property checked reduces exist fair path ctl 
algorithmically customize bisimulation minimization property level atomic propositions 
consider atomic propositions property corresponding fairness constraints 
specializing property require change lee yannakakis algorithm additional machinery 
reach 
reach 
reach 
max live memory property states classes saved nodes mb counter gfp tlc gp tlc fq elev fq eisenberg gp eisenberg fq bakery fq bakery fq arbiter fq gp fq fp gfp coherence gp table computing bisimulation automaton 
variables properties may refer boolean combinations atomic propositions independent properties 
asterisks indicate properties fail hold respective designs 
newly handled design coherence state variables intersection property 
coherence property refers atomic propositions 
refer intersection design negated property automaton 
table shows reductions achieved computing bisimulation automata 
table shows able minimize design coherence amenable previous computations 
numbers reachable states reachable classes relative automaton original design table 
transition system additional state variables compared design 
number additional variables depends type property involved 
safety property contributes state variable liveness properties considered contribute 
extra variables account additional states increased numbers live nodes needed computation 
numbers live nodes generally higher computing bisimulation automaton roughly higher 
maximum number live nodes decreases 
attribute small number reachable classes case automaton 
handle designs minimizing automaton promising 
perspective lee yannakakis algorithm reduce number atomic propositions considered forming initial partition 
definition bisimulation section surprising reducing number atomic propositions greatly impact degree minimization achieved atomic propositions dictate initial partitioning equivalence classes 
accordingly reducing number required atomic propositions prove promising 
section discusses experiment requires atomic proposition design regardless number fairness constraints 
minimizing atomic proposition experiments reported previous section considered atomic proposition fairness constraint 
reducing number atomic propositions requires reducing number fairness constraints 
fairness constraints indicate sets states passed infinitely 
method satisfies constraints sufficient long requires set visited infinitely 
method checks fairness constraints linear order shown diagram 
num reach 
reach 
reach 
classes max memory fair states classes saved saved nodes mb tlc tlc elev eisenberg eisenberg bakery bakery arbiter table single fairness statistics 
num fair column indicates number constraints original design account fairness constraint added property automaton 
classes saved column reflects ratio reachable classes automaton reachable classes automaton table 
designs covered table fairness constraints 
produce automaton automaton yields reachable block 
fair sat fair sat fair sat diagram shows linearization fairness constraints automaton 
automaton state fairness constraint 
state transitions going state ordering associated fairness constraint satisfied looping back state constraint satisfied 
fairness constraint automaton state fair sat fairness constraint satisfied infinitely fair paths 
linearized automaton enforces fairness requirements requiring single fairness constraint 
linearization technique design containing fairness constraints 
design added automaton form original verilog description 
automaton state fairness constraint design plus state fairness constraint property property contributed exactly fairness constraint 
new automaton intersected minimization call automaton 
minimization considered fairness constraint new automaton 
result minimization began initial partition containing exactly equivalence classes states satisfied fairness constraint 
table summarizes results experiment 
order linearized fairness constraints non trivial impact amount reduction achieved 
arbiter fairness constraints number blocks ranged permutations 
bakery fairness constraints number blocks ranged permutations 
eisenberg fairness constraints number blocks ranged permutations 
leave question choose ordering research 
compare reductions achieved automata design table table table 
exception bakery example achieves slightly better reductions original design automaton property example yields substantial reductions fewer atomic propositions considered minimization 
conversely tables show increase live nodes memory minimize opposed automaton 
comparison tables attribute increase number live nodes additional state variables required new automaton 
increase table table substantial increase noted tables 
experiment bakery uses fewer live nodes minimizing opposed 
remaining experiments show average increase number live nodes 
contradictory figures unable say final reduction single fairness constraint worthwhile 
ideally find examples minimization tractable reduction 
examples require large numbers fairness constraints 
current examples meet requirement 
find evidence utility extra minimization questionable 
tuning original algorithm attempts run previous experiments larger designs failed runs ran memory finishing 
section discusses attempt reduce algorithm memory requirements 
lee yannakakis algorithm improves original symbolic computation described section processing equivalence classes containing reachable states 
algorithm maintains unreachable classes may reachable minimized graph constructed 
compared number reachable classes number classes maintained run algorithm result appear table 
average maintained classes reachable 
raises possible approach improving memory usage 
represent classes bdds 
practice bdds representing large numbers states may smaller bdds representing fewer states 
try maintaining single class containing states assigned reachable class 
merger create coarser partition lee yannakakis algorithm respect unreachable classes 
require fewer bdd nodes represent classes 
unfortunately approach computationally expensive 
recall unreachable class reachable contain reachable state 
original algorithm previously unreachable class converted reachable block placed stack processing 
algorithm requires states newly reachable class agree values atomic propositions interest 
maintaining single unreachable class violates requirement 
complicated procedure required extract new reachable class satisfied requirement 
fortunately requirement sufficient necessary 
maintain unreachable class combination atomic propositions 
number combinations smaller number unreachable classes save bdd nodes incurring high computational overhead 
experiments indicate number combinations substantially smaller number unreachable classes runs 
shows modified version lee yannakakis algorithm 
subset atomic propositions satisfied state new version maintains holding set states currently assigned reachable equivalence class 
algorithm views holding set single large equivalence class 
state holding set reachable holding set converted reachable block original algorithm 
main change pseudocode lies split section 
new equivalence class unreachable foreach loop new block created elements returned holding set 
comparing live node memory statistics obtained original algorithm new version yields interesting results shown table 
smaller examples algorithms similar live node memory figures 
eisenberg larger examples new algorithm performs substantially worse original automata terms memory usage worse average 
contrast new algorithm performs substantially better automata terms live nodes better average high examples 
results mixed design minimizations 
note single class necessarily contain unreachable states 
reachable classes contain unreachable states 
reachable initial maintained maintained classes classes classes reachable counter counter dp tlc tlc dp tlc tlc tlc dp tlc elev elev dp elev eisenberg eisenberg dp eisenberg eisenberg eisenberg dp eisenberg bakery bakery dp bakery bakery dp bakery arbiter arbiter dp arbiter dp dp dp dp coherence dp table unreachable classes statistics 
dp suffixes denote automata respectively 
stack iig initial state block containing queue partition contains initial block hb ii divide remaining states holding set combination atomic propositions search stack hb pi pop stack blocks partition holding set foreach block hc qi blocks contains state successor enqueue hb pi defined select set add edge hb pi hc qi gamma enqueue hb pi split queue hb pi delete queue fq blocks blocks gamma foreach edge hc qi hb pi minimized system elements reach enqueue hc qi elements reach enqueue hc qi successor delete edge hc qi hb pi successor block partition select add hb partition push stack add edge hc qi hb block partition add elements appropriate holding set stack goto search refinement lee yannakakis combined bisimulation reachability algorithm 
algorithm partition contains reachable blocks 
max live max live memory memory nodes ly nodes mb ly mb counter counter dp tlc tlc dp tlc tlc tlc dp tlc elev elev dp elev eisenberg eisenberg dp eisenberg eisenberg eisenberg dp eisenberg bakery bakery dp bakery bakery dp bakery arbiter arbiter dp arbiter dp dp dp dp coherence dp table merged algorithm statistics 
headings ly indicates lee yannakakis version indicates new merged class version 
figures provided computation ran memory completing machine megabytes 
design design min design mc mc design ly ly le ly le mem time mc time time time time time time counter tlc tlc elev eisenberg eisenberg bakery bakery arbiter coherence table model checking statistics vis 
design mc mem time columns indicate resources model check property vis monolithic transition relation 
numbers parentheses time column partitioned transition relations significant changes memory requirements partitioned transition relation 
min design mc time shows time taken model checking minimizing design respect atomic propositions respective property uses monolithic transition relation 
abbreviates 
memory figures performing minimizations appear tables 
language emptiness checks significantly increase memory usage required minimization 
maximum live node statistics unavailable model checking runs 
comparison model checking evaluate utility minimizations comparing model checking minimized systems model checking original designs 
vis ctl model checker test properties original designs minimized vis language emptiness checker test fair paths minimized systems 
implementation lee yannakakis algorithm produces monolithic partitioned transition relations 
generating partitioned minimized transition relations interesting research challenge 
order comparisons meaningful performed vis ctl model checking runs monolithic transition relations 
able run vis minimized designs replacing transition relation original design minimized transition relation vis internal data structures 
works minimization change states represented 
minimized transition relation merely restricted relate representatives reachable equivalence classes 
table provides sets figures 
columns give memory time needed model check ctl properties original designs table indicates type property 
third column shows time required model checking design minimized respect atomic propositions property fairness constraints 
columns give minimization time original lee yannakakis algorithm language emptiness test time corresponding automaton 
columns give similar figures automaton 
columns empty design fairness constraints automaton 
looking model checking language emptiness times results mixed 
eisenberg model checking original design faster checking language emptiness minimized automaton 
eisenberg design reachable states table corresponding automaton reachable classes table 
increase reachable states explains increased model checking time 
savings remaining cases vary little substantial best savings coherence example 
original coherence design reachable states minimization single reachable block table 
savings case surprising 
performing language emptiness test automata compared automata offers benefits 
cases eisenberg tests bakery results worse automaton 
cases number reachable states original design smaller number reachable classes corresponding automaton tables 
accounting minimization time performing model checking original design faster combination minimization language emptiness checking coherence examples 
examples large numbers reachable states respectively reduce single reachable block 
total cost automaton significantly worse automaton bakery example 
related researchers explored symbolic minimization techniques 
efforts computed reachability simultaneously difficult line minimization 
de simone provided symbolic bisimulation algorithm partitioned transition relations 
variant algorithm implemented verification environment supports vis input format 
aziz take compositional approach bisimulation minimization symbolic setting 
approach performs minimization relative property 
represents equivalence relations classes 
kick uses symbolic technique reduce models relative properties 
technique guaranteed produce transition systems coarse obtained bisimulation furthermore tested realistic examples 
bouajjani minimize state graphs programs combination bisimulation reachability 
lee yannakakis show bouajjani algorithm efficient theirs theory due order split classes 
practice alur bouajjani algorithm faster checking language emptiness timed automata 
dams proposes minimization technique strong preservation ctl properties 
technique resembles bisimulation produces potentially coarser relation preserves set properties 
split classes transitions splits class members disagree subproperties relevant verifying properties 
approach fully automatic requires intermediate model checking analyses appears computationally prohibitive 
dams gerth grumberg earlier version universal ctl formulas 
version implemented 
dams gerth grumberg suggest interpretations automatically generate abstractions program level descriptions transition systems 
aim strong preservation formulas consider minimization relative particular properties 
furthermore generation technique necessarily produce coarsest possible abstraction 
extends earlier clarke grumberg long considers weak preservation universal ctl ctl properties 
abstraction frameworks supported cospan require user manually construct models 
proposed approaches symmetry reductions require various degrees manual intervention 
furthermore sistla framework supports fairness constraints 
explored bisimulation minimization state space reduction technique automata theoretic verification framework 
bisimulation theoretically attractive requires user intervention produces coarsest model strongly preserves calculus properties 
practically considered unsuitable symbolic model checking bdds needed compute bisimulation relation grow large 
shows bisimulation viable symbolic framework 
algorithm due lee yannakakis combines reachability analysis bisimulation symbolically represented transition systems minimized designs far larger amenable conventional bisimulation computations 
success results automata theoretic framework 
intersecting negated property design minimization need consider atomic propositions corresponding fairness constraints minimization 
reducing number atomic propositions minimization increases amount reduction achieved size design amenable algorithmic minimization 
proposed techniques advance state model checking approach works designs 
particular appears useful verifying safety properties designs fairness constraints 
designs yield reachable equivalence class safety property holds 
small number reachable classes keeps memory requirements reduces time convergence algorithm 
approach fits general strategy providing model checking algorithms single framework allowing user choose algorithms chance succeeding nature design 
time memory requirements current approach motivate 
table shows minimization time substantial 
alur experienced similar time requirements lee yannakakis algorithm 
minimizing relative automata prohibits reuse results property yields separate machine minimized 
plan experiment reusable reductions 
example design properties relying atomic propositions design minimization performed relative propositions 
reduces number atomic propositions minimization yields reusable minimized transition system 
second memory requirements performing reductions significant larger designs 
particular costs minimization usually outweigh performing model checking original design 
bdd size bottleneck handling larger examples 
analyses discussed problem appears lie intermediate explosion reachability computations sizes bdds needed represent equivalence classes 
intend explore alternate symbolic representations conjunction lee yannakakis algorithm 
done preliminary experiments forms decision diagrams multi terminal bdds adds zero suppressed bdds 
offer little advantage application adds appear promising 
adds represent equivalence relation single structure relating state constant identifying equivalence class 
structure uses number state variables practice variables needed represent bisimulation relation single bdd 
preliminary experiments indicate number add nodes single structure substantially smaller sum total nodes represent classes separately 
furthermore monolithic representation allows explore purely symbolic versions lee yannakakis algorithm 
begun investigations area 
obvious extension involves integrating minimization fly model checking mentioned earlier 
fly model checking employed automata theoretic framework 
integration improve utility minimization technique respect failed properties 
plan explore coarser abstractions automata theoretic framework 
bisimulation preserves details lengths paths irrelevant checking fair path exists 
coarser abstractions sided simulation stuttering equivalence may better suited algorithmic state space reduction automata theoretic framework 
plan explore applying method part state space 
example data path abstraction collapsing space data values small set relevant values 
alur courcoubetis dill halbwachs wong toi 
implementation algorithms timing verification automata emptiness 
proceedings ieee real time systems symposium pages 
aziz singhal brayton 
minimizing interacting finite state machines compositional approach language containment 
proceedings international conference computer design iccd 
algebraic decision diagrams applications 
proc 
international conference computer aided design pages 
beer ben david geist 
methodology system practical formal verification reactive hardware 
proc 
th conference computer aided verification volume lecture notes computer science pages stanford june 
bouajjani 
fernandez halbwachs raymond 
minimal state graph generation 
science computer programming 

esterel verification environment 
proceedings international conference computer aided verification cav pages 
de simone 
symbolic bisimulation minimization 
proceedings international conference computer aided verification cav pages 
choueka 
theories automata tapes simplified approach 
journal computer system sciences 
clarke jha 
exploiting symmetry temporal logic model checking 
formal methods system design august 
clarke grumberg long 
model checking abstraction 
proceedings th acm symposium principles programming languages pages 
clarke kurshan 
computer aided verification 
ieee spectrum 
courcoubetis vardi wolper yannakakis 
memory efficient algorithms verification temporal properties 
formal methods system design 
package 
available vlsi colorado edu fabio 
dams 
interpretation partition refinement model checking 
phd thesis technische universiteit eindhoven 
dams grumberg gerth 
generation reduced models checking fragments ctl 
proc 
th int conference computer aided verification pages 
dams grumberg gerth 
interpretation reactive systems 
acm transactions programming languages systems toplas march 
vardi 
bisimulation minimization automata theoretic verification framework 
proc 
intl 
conference formal methods computer aided design fmcad 
groote vaandrager 
efficient algorithm branching bisimulation stuttering equivalence 
proceedings international conference automata languages programming pages 
vis group 
vis system verification synthesis 
alur henzinger editors proceedings th international conference computer aided verification pages 
springer verlag july 
lecture notes computer science 
grumberg long 
model checking modular verification 
acm trans 
programming languages systems 
sistla 
fly model checking fairness exploits symmetry 
proc 
international conference computer aided verification cav pages 
hardin kurshan shukla vardi 
new heuristic bad cycle detection bdds 
proc 
international conference computer aided verification 
hennessy milner 
algebraic laws nondeterminism concurrency 
journal acm 
henzinger kupferman rajamani 
fair simulation 
proc 
th conference concurrency theory volume lecture notes computer science pages warsaw july 
springer verlag 
ip dill 
better verification symmetry 
formal methods system design august 
kick 
formula dependent model reduction elimination invisible transitions checking fragments ctl 
technical report universitat karlsruhe 
kupferman vardi 
complexity branching modular model checking 
proc 
th conference concurrency theory volume lecture notes computer science pages philadelphia august 
springer verlag 
kurshan 
computer aided verification coordinating processes 
princeton univ press 
lee yannakakis 
online minimization transition systems 
proc 
th acm symposium theory computing pages victoria may 
david long 
model checking abstraction compositional verification 
phd thesis university 
milner 
calculus communicating systems volume lecture notes computer science 
springer verlag berlin 

binary decision diagrams applications vlsi cad 
kluwer academic publishers 
vardi wolper 
automata theoretic approach automatic program verification 
proc 
symposium logic computer science pages cambridge june 
wolper 
expressing interesting properties programs propositional temporal logic 
proc 
th acm symp 
principles programming pages st january 

