context sensitive interprocedural points analysis presence function pointers emami rakesh ghiya laurie hendren school computer science mcgill university montreal quebec canada ghiya cs mcgill ca reports design implementation empirical results new method dealing aliasing problem method approximating points relationships accessible stack locations generate alias pairs directly analyses transformations 
method provides context sensitive interprocedural information analysis invocation graphs capture calling contexts including recursive mutually recursive calling contexts 
furthermore method allows smooth integration handling general function pointers illustrate effectiveness method empirical results implementation mccat optimizing parallelizing compiler 
motivation alias dependence analysis fundamental components optimizing parallelizing compilers 
traditionally studied context fortran block structured languages increasing interest providing accurate alias side effect analysis programs 
solving problems fortran leads interesting difficult problems including treatment address operator create new pointer relationships program point multi level pointer enable called function modify alias relationships calling function integration pointer analysis stack allocated variables dynamically allocated variables proper interprocedural handling recursion function pointers 
reports design implementation results new method dealing aliasing problem method called points analysis estimates relationships stack locations 
method developed years framework mccat optimizing parallelizing compiler currently operational 
important facets approach include points abstraction compute sets alias pairs method computes different abstraction points relationships stack locations 
say stack location points stack location program point contains address addition providing compact abstraction compared alias pairs points information suited immediate analyses 
approaches compute may aliases analysis computes possible definite pointsto relationships 
points abstraction additional overhead providing definite information minimal time providing advantages 
advantage definite points information sharpen points analysis providing accurate killing information 
example statement information definitely points kill points relationships second major advantage definite relationships direct transformations pointer replacement 
example statement information definitely points replace statement transformation lead better results phases compiler reducing number loads stores 
points abstraction basic flow analysis rules section compare approach similar approaches section 
context sensitive interprocedural analysis conventional alias analysis notion pointsto captured alias pair 
points abstraction basic flow analysis rules implemented different analysis frameworks 
particular approach structured compositional analysis uses invocation graphs provide context sensitive analysis 
approach allows get accurate results correctly handle recursion 
function pointers provide big challenge interprocedural analysis programs 
give natural extension points analysis gracefully includes general problem single multi level pointers functions 
fact demonstrate problem instantiating function pointers done time points analysis order get reasonably general accurate solution 
discuss basic interprocedural strategy section show extend handle function pointers section 
related interprocedural approaches compared sections 
experimental results applications viewpoint alias analysis implemented tested order measure actual costs benefits analysis 
completely implemented analysis described section provide empirical evidence approach gives accurate useful results 
provide summary results points analysis building block analyses transformations 
separating stack aliasing array heap aliasing problem aliasing really comes varieties aliases variable stack aliases dynamically allocated storage heap aliases array 
accepted problem aliases array requires special dependence testing methods analyzing index expressions 
claim consider totally different analysis methods stack aliases heap aliases problems safely decoupled 
case stack aliases name exists stack location interest may compute approximation relationships locations 
case aliases natural names location 
fact know statically locations allocated 
completely different approach required 
example deutsch argues model appropriate heap problems 
discuss issue section 
setting mccat compiler points analysis implemented mccat mcgill compiler architecture testbed optimizing parallelizing compiler 
order provide correct intermediate language designed structured intermediate representation called simple 
hand need analyze real programs just programs written toy subset simple representation faithfully represents programs 
hand require compact clean representation possible new powerful analyses implemented straightforward compositional fashion 
designing simple intermediate representation major design criteria basing analysis framework structured compositional analyses structured intermediate representation retaining high level variable type casting information designing compact representation statements expressions includes basic statements plus explicit simplified representations switch break continue return statements 
typical simplifications include compiling complex statements series basic statements simplifying conditional expressions statements simple expressions side effects simplifying procedure arguments constants variable names moving variable initializations declarations statements body appropriate procedure 
simplification points analysis rules need developed basic statements compositional control statements 
design rules simplified fact basic statements level pointer indirection variable 
details 
stack locations basic analysis rules traditionally alias analysis methods approximated aliases sets alias pairs 
approximation variable said aliased refer location 
typical alias pairs form 
points abstraction chosen different abstraction approximates points relationships stack locations program point 
basic idea set accessible stack locations finite set named stack locations 
abstraction approximation interest consists set points relationships stack locations 
example statement say stack location points stack location key approach guarantee real stack location involved points relationship noted unrestricted goto compositional supported directly 
mccat compiler provides structuring phase converts programs unstructured control flow equivalent programs structured control flow 
properly abstracted stack location appropriate name 
specifically abstraction obey properties 
property real stack location source target pointer program point represented exactly named stack location 
property named stack location program point represents real stack locations 
important part abstraction fact guarantee provide points relationships names stack locations independent calling context 
stack location corresponds name local variable global variable parameter symbolic name corresponds locations indirectly accessible parameter global variable pointer type locations correspond variables scope procedure analysis symbolic name heap 
stack locations appropriate names define relationships definitely points possibly points follows 
definition stack location definitely points stack location respect particular invocation context represent exactly real stack location context real stack location corresponding contains address real stack location corresponding denoted triple 
definition stack location possibly points stack location respect particular invocation context possible real stack locations corresponding contains address real stack locations corresponding context 
denoted triple 
relationships define meant safe approximation 
definition points set program point safe approximation pairs real stack locations loc loc name associated loc loc 
loc points loc valid execution paths points set contains 

loc points loc execution paths points set contains 

contains loc point loc execution paths program point basic ways approximation may safe real points relationship included spurious definite points relationship included course easy find safe approximations precise 
example safe say stack location possibly points stack location 
goal find approximations precise possible 
abstraction imprecision introduced introducing spurious possible relationships possible relationship place definite relationship 
locations locations points set calculated program point define set locations referred kind variable statement locations locations referred variable left hand side assignment statement locations locations referred variable right hand side assignment statement 
locations locations represented pairs form location name indicate definite possible locations respectively 
table summarizes location location set type variable allowed simple intermediate representation 
note location refers stack location variable location refers stack locations pointed variable 
location set simply location set set locations points relationship 
points set 
location set set stack locations pointed location set level indirection 
location set includes locations points location points case location definite definitely points definitely points treatment structure similar field name appended location names 
array notation refer ordinary array refer array pointer 
source program appear case array type second case pointer type 
variety ways dealing arrays 
method associate entire array stack location 
method table uses stack locations array head location tail locations 
stack locations array allows determine array pointers aligned var ref loc set loc set ahead tail ahead tail sg sg ahead ahead sg tail tail sg ahead tail ahead tail sg sg sg sg sg ahead sg ahead sg tail sg tail sg ahead ahead tail tail sg sg malloc heap table location location sets relative points set array 
information useful array dependence testing 
basic analysis rules basic analysis rules 
note pointer assignment statements general rule uses locations lhs locations rhs compute returned flow information 
basic changes input flow information set relationships killed set relationships changed definite possible set relationships generated 
note assignment structures handled breaking assignment assignments corresponding fields applying basic rules 
defining basic assignment rule defined structured compositional rules loop conditional constructs 
give simple versions rules 
complete set compositional rules handle break continue return straightforward manner 
interprocedural analysis accurately estimate effects procedure calls points information perform context sensitive interprocedural points analysis 
measuring effect procedure call estimate specific calling context just summarize information calling contexts 
general calling context depends chain procedure invocations starting main particular procedure call analysis 
problem ensuring analysis procedure call specific particular calling context termed calling context problem horwitz landi ryder consider problem restricting propagation information realizable interprocedural execution paths 
traditional solution problem include context information abstraction calculated 
typical examples approach include memory components procedure strings assumed alias sets source alias sets call site 
embedding context abstraction estimated chosen follow different strategy explicitly represent invocation paths invocation graph 
case programs recursion invocation graph built simple depth traversal call structure program starting main 
consider example invocation graph program 
important characteristic invocation graph procedure invocation chain represented unique path vice versa 
invocation graph distinguish calls different call sites procedure calls distinguish different invocations procedure call site reached different invocation chains call 
presence recursion exact invocation structure program known statically approximate possible recursion 
illustrates program simple recursion set possible invocation program 
build graph case recursion terminates depth traversal time function name ancestors call chain main 
leaf node representing repeated function name labeled approximate node matching ancestor node treatment function pointers section 
stmt input points set invocation graph node ign return output points set fun process stmt input ign basic stmt return process basic stmt input case seq 
return process stmt process stmt input ign ign cond 
return process cond input ign cond 
return process cond input ign fun process basic stmt input 
pointer type pointer assignment return input assignment pointer variable kill set lhs kill relationships definite lhs change definite possible relationships possible lhs change set lhs generate possible relationships lhs rhs 
generated relationship definite definite gen set lhs rhs changed input input gamma change set change return changed input gamma kill set gen set fun process cond input ign process stmt input ign fg process stmt input ign input return merge fun process cond input ign fixed point calculation input output process stmt input ign input merge input output input return basic analysis rule points analysis labeled recursive node 
indicate pairings nodes special back edge approximate node recursive node 
noted back edges match approximate node appropriate recursive node quite different tree edges correspond procedure calls 
scheme completely general 
consider example invocation graph program simple mutual recursion displayed 
approach explicitly building invocation graph advantages cleanly separates abstraction interprocedural analysis abstraction required encode calling context allows deposit context sensitive information computed analysis useful analysis provides place store pairs previously computed summarize effect function call extra computation avoided analysis time provides simple framework implementing simple compositional fixed point computations recursion 
strategy interprocedural analysis depicted complete rules 
general idea pointsto information call site mapped prepare points input set called procedure 
take account association formal actual parameters global variables accessibility non local stack locations indirect 
body function analyzed input points set output obtained unmapped returned call site 
note strategy points information induced call site returned call site similarly points information arriving different call sites simultaneously generate new points information 
strategy main main main 
main main main 
main main invocation contexts clear explain strategies mapping points information invocation graph store context sensitive map information handling recursive calls fixed point computations guided invocation graph 
caller 
callee map process process function analysis interprocedural strategy mapping points information preparing input points set called procedure points information callsite formal parameters inherit points relationships corresponding actuals global variables retain points relationships local variables initialized point null important points considered ffl formal parameter global variable multi level pointer pointer variable accessed dereferencing 
points relationships indirectly accessible pointers need mapped called procedure 
ffl formals globals point variables scope procedure turn point variables outside scope procedure 
henceforth refer variables outside scope called procedure invisible variables 
problem resolved applying mapping process recursively levels pointer type 
second problem generate special symbolic names represent level indirection pointer variables 
example variable type int generate symbolic names types int int 
indirect say lead invisible variable say corresponding symbolic name represent points pairs 
points pair call site mapped pair 
points pair invisible variable mapped 
simultaneously association invisible variables symbolic names recorded invocation graph node currently investigation map information 
contextsensitive information interprocedural analyses 
note map information context sensitive symbolic names context free manner inside procedures analyses 
scheme map invisible variables symbolic names take account observations ffl invisible variable represented symbolic name 
example definitely point invisible variable mapped 
stack locations representing real stack location violate property 
mapped points pairs map information fg 
ffl symbolic name represent invisible variable 
example consider case possibly points invisible variables need mapped suppose global variable say definitely points mapped symbolic name mapped choice points pairs generate spurious points pair inaccurate pair 
mapping scheme minimize number invisible variables mapped symbolic name improve accuracy information 
experience shows mapping involved similar notion non visible variables 
note information provided safe precise 
fun process call input ign mapinfo map process input case ign ordinary 
ign computed return process input ign mapinfo compute output store input output process stmt ign ign ign return process input mapinfo approximate 
ign get partner recursive node inv 
graph input contained stored input stored ouput return process input mapinfo put input pending list return bottom return bottom recursive 
ign computed return input ign mapinfo initial input estimate initial output estimate ign ign bottom ign fg done false unresolved inputs pending process body process stmt ign ign unresolved inputs merge inputs restart ign fg ign merge ign ign fg ign bottom ign check new output included old output done true merge outputs try ign merge ign done ign reset stored input initial input memoization return process input ign mapinfo return fixed compositional interprocedural rules points analysis definite relationships ones involved possible relationships gives accurate mapping information 
function analyzed mapped input output points set function needs mapped back obtain output points information call site 
algorithm essentially consists mapping points information symbolic names invisible variables represented globals 
complete details map algorithms described 
recursive procedure calls cases approximate recursive procedure calls shown implement safe accurate fixed point computation recursion 
explained previously possible call chains involving recursion approximated introducing matched pairs recursive approximate nodes invocation graph 
recursive node marks place fixed point computation performed approximate node marks place current stored approximation function evaluating call stored output directly 
recursive node store input output list pending inputs 
input output pairs thought approximating effect call associated recursive function call 
fixed point computation generalizes stored input finds input summarizes invocations unrolled call tree starting recursive node similarly output general ized find summary output unrolling call tree starting recursive node generalizations input output may alternate new generalization output causing input change 
consider rule approximate node 
case current input compared stored input matching recursive node 
current input contained stored input stored output result 
result known input input put pending list bottom returned result 
note approximate node evaluates body function uses stored result returns bottom 
consider recursive rule 
case iteration terminates input sufficiently generalized pending list inputs empty output sufficiently generalized result evaluating call doesn add new information stored output 
handling function pointers presence function pointers invocation graph constructed simple textual pass program function pointer call site bound unique function compile time 
set functions invoked call site depending address contained function pointer program execution reaches point 
proper handling function pointer call requires precise estimate set 
simplest safe approximation set set functions program 
possible strategy collect set functions addresses taken set instantiate function pointer 
number types parameters passed safely refine set permits passing variable number arguments functions type casting 
methods overly conservative substantially reduce quality flow information collected indirect call program 
simple strategies incur considerable cost function analyzed context call 
precise estimate obtained observing fact set functions invocable function pointer call site identical set functions function pointer point program point 
compute points set function pointer need perform points analysis 
points analysis needs invocation graph program context sensitive interprocedural analysis 
get invocation graph points analysis 
solution lies constructing invocation graph performing points analysis described 
build invocation graph program strategy described section leaving incomplete points function pointer call encountered 
perform points analysis incomplete invocation graph 
encountering indirect call function pointer find functions point current points information 
invocation graph updated indicate indirect call lead invocation functions 
simultaneously pointed function analyzed context call 
analyzing invocable function say consider function pointer definitely pointing case execution reaches function indirect call site 
output points information indirect call obtained merging output points sets obtained analyzing invocable functions 
formal description algorithm provided 
detailed description 
fun process call indirect input ign get function pointer indirect call ign get set functions pointed current points information input initialize output indirect call fg foreach fn indicate function fn invocable indirect call ign fn get invocation graph node fn fn definitely point fn input fn get output invocable function process call fn fn merge outputs merge return algorithm handling function pointers noted algorithm add extra cost analysis phase compiler 
simply extends points analysis points information available indirect call sites appropriate time 
provide example demonstrate algorithm works 
consider program 
initial incomplete invocation graph shown 
points analysis function pointer call fp encountered program point points set int int pa pb pc int fp main foo bar pc pa pb cond cond point fp foo fp point fp bar point fp point fp foo fp bar pc fp foo fp bar pc pa pb fp foo pc pa fp bar pc pb example program function pointers fp fp foo fp bar invocation graph updated accordingly shown 
function foo analyzed input points set fp foo pc function bar input points set fp bar pc note set fp foo fp bar pc functions reasons mentioned paragraph 
analyzing function foo function pointer call fp encountered 
invocation graph updated current pointsto set fp fp foo consequently potential call foo main currently considered recursive call handled specially explained previous section 
points information program point obtained merging output points sets potential function calls 
final points sets important program points bottom 
final invocation graph shown 
experimental results applications points analysis section experimental results obtained analyzing set programs 
table summarizes characteristics benchmark source lines including comments number statements simple intermediate representation minimum maximum number variables stacks functions including symbolic variables fields structures relevant points analysis 
empirical results tables 
results implementation double lined edges just clarity presentation 
treated differently edges graph 
main fp main fp foo bar fp main fp foo bar fp foo invocation graph construction function pointers mccat compiler 
pointer arithmetic assume pointers arrays cross array boundaries 
non array pointer arithmetic analysis supports flag indicates pointer target stays presently pointed data structure pointer target memory location 
case warning message issued programmer determine safe assumption 
experiments done setting 
accuracy points information collected best reflected precisely helps resolving indirect programs 
data points characteristics indirect table 
columns give number indirect dereferenced pointer definitely pointing single stack location possibly pointing single stack location null stack locations 
columns give total number indirect program number indirect replaced direct definite points information 
columns give number points pairs indirect pointer target stack heap respectively 
tot column gives sum 
column gives average number points pairs resolving indirect program average number stack locations pointed dereferenced pointer 
multiple entry column entry provides statistics indirect form second indirect form pointer array 
note analysis initialize pointers null 
initialization necessarily done user points relationships contributed counted statistics 
note replacement done dereferenced pointer definitely points invisible variable 
benchmark lines min max description stmts simple var var genetic implementation genetic algorithm sorting 
dry dhrystone benchmark 
version linpack 
config checks features language 
toplev top level gnu compiler 
compress unix utility program 
unified version best algorithms way partitioning 
hash implementation hash table 
misr program creates misr 
values compared see introduced errors cancelled 
xref cross program build tree items 
stanford stanford baby benchmark 
simple translator 
sim finds local similarities affine weights 
travel implements traveling salesman problem greedy heuristics 
part test suite vectorizing compilers 
msc min spanning circle set points plane 
lws implements dynamic simulation flexible water molecule 
table characteristics benchmark programs bench ind scalar tot avg mark rel rel rel rel rel refs rep stack heap genetic dry config toplev compress hash misr xref stanford sim travel msc lws table points statistics indirect results table encouraging 
important observations ffl average number stack locations pointed dereferenced pointer indirect quite close programs indicates best possible case 
average equal maximum average program 
indicates information collected points analysis highly precise 
average quite close reported landi 
ffl indirect programs dereferenced pointer definitely pointing single stack location 
definite information indirect replaced direct dereferenced pointer point invisible variable 
replacement definite relationships applicable indirect useful 
important results support strategy collecting possible definite information 
ffl pointer pointing null dereferenced program execution 
assumption indirect dereferenced pointer definitely possibly pointing single stack location 
ffl certain benchmarks particular stanford sim lws majority definite relationships indirect form pointer array 
information useful array dependence analysis reduces number array pairs collected subscript analysis 
ffl points relationships heap locations pointer target 
underlines need powerful companion heap analysis identify disjoint accesses heap locations 
ffl cases pos sible points relationships indirect 
cases points relationships occurs array pointers initialized toplev 
table categorizes points relationships pointer target stack column stack table relationships arising directed stack locations representing local variables lo global variables gl formal parameters fp symbolic names sy 
statistics table show relationships arise formal parameters directed symbolic names global variables 
indicates procedure calls generate majority points relationships points analysis needs context sensitive interprocedural analysis collect precise information 
table contains statistics total number points pairs collected obtained summing number pairs valid statement simplified program 
columns give classification points pairs origin target memory organization 
columns give average maximum number pairs valid statement 
major observation table absence points relationships heap locations stack implying pointers heap objects point heap objects benchmark set 
supports strategy separating stack heap points analyses 
need analyze larger set benchmarks strengthen claim measure inaccuracy introduced approach benchmarks pointers heap stack 
bench mark lo gl fp sy lo gl fp sy genetic dry config toplev compress hash misr xref stanford sim travel msc lws table categorization points information indirect landi ryder empirical data total number program point specific alias pairs collected 
difficult meaningfully com bench stack stack heap heap max mark stack heap heap stack stmt genetic dry config toplev compress hash misr xref stanford sim travel msc lws table general points statistics bench ig call mark nodes sites fns genetic dry config toplev compress hash misr xref stanford sim travel msc lws table invocation graph statistics pare numbers greatly depend intermediate program representation 
provide simple examples section illustrate method superior 
table gives measurements invocation graphs nodes invocation graph call sites program functions called program recursive approximate nodes invocation graph average number nodes invocation graph call site called function 
average number invocation graph nodes call site 
call site appears average call chains benchmark set 
indicates approach explicitly call chains practical real programs moderate size theoretically exponential cost 
fully support claim need experimentation larger benchmarks 
size invocation graph unreasonable benchmarks plan reduce size sharing sub trees similar invocation contexts 
implemented caching input output points information function recognizing particular input occurred 
output computed sub trees shared stored output continue analysis 
estimate benefits technique handle function pointers studied benchmark collection livermore loops 
global arrays function pointers initialized set functions 
indirect callsites program inside loop involving function pointer array 
indirect call scalar local function pointer assigned appropriate function pointer array element 
algorithm constructs precise invocation graph instantiating function pointer call corresponding functions giving total nodes 
naive approach mentioned section instantiate indirect call functions program total functions leading invocation graph nodes 
approach considering functions address taken instantiate indirect call functions construct invocation graph nodes 
approximations yield imprecise invocation graphs compared algorithm 
applications points analysis measure success analysis pointsto alias analysis just measuring number pointed locations 
show results analysis building block interprocedural analyses optimizing parallelizing transformations 
compiler framework points analysis provides points information complete invocation graph mapping information encodes maps variables calling context called context 
point specific points information useful compute read write sets constructing alpha intermediate representation 
approaches directly compute read write sets names variables symbolic names 
pointsto results critical support analyses required dependence testing array 
context points results increase number admissible loop nests decrease number array pairs require testing allow analysis array subscripts involve pointer variables 
example optimizing transformation definite points information reduce number loads required low level program representation 
context fine grain parallelizing transformations currently studying points information providing accurate dependence information instruction scheduling 
complete invocation graph mapping information provides convenient basis implementing interprocedural analyses generalized constant propagation practical heap analysis 
important point pointsto analysis completed need worry function pointers correspondence invisible variables calling context 
information stored points analysis need recalculated 
related alias analysis closely related landi ryder choi 
paragraphs compare approach related different points importance alias representation points abstraction provides alias information compact informative manner exhaustive alias pairs landi ryder 
abstraction particularly suited calculating stack aliasing stack location compile time name 
eliminates generation extraneous alias pairs certain cases 
consider example 
gives points information gives alias pairs computed landi ryder may alias algorithm 
compare results calculating set alias pairs implied points set transitive closure 
example spurious alias pair program point generated method 
example transitive closure points pairs generate spurious alias pair won reported landi ryder 
transitive reduction scheme proposed similar points abstraction context 
main int original program alias information points pairs vs alias pairs aliases points abstraction enables simultaneous calculation possible def points relationships extra overhead 
empirical results section show existence substantial number definite pointsto relationships forms valuable information 
landi ryder give algorithm calculation may aliases 
algorithm calculating aliases 
handles single level pointers considers problem isolation may alias computation 
choi give example alias information improve precision alias analysis 
describe calculate aliases integrate calculation may alias calculation 
sagiv propose simultaneous collection universal existential properties programs logic formulation data flow analysis problems 
particular show universal assertions improve accuracy existential assertions pointer equality problem example 
similar approach definite points information gives precise killing information reduces number spurious possible points pairs 
main int original program alias information points pairs vs alias pairs interprocedural analysis landi ryder propose conditional approach context sensitive interprocedural alias analysis 
associate pair alias pair validity alias pair program point conditional validity assumed alias pair entry node procedure containing program point 
recover calling context determining call sites propagate assumed alias pair entry node procedure analysis 
scheme precise single level pointers 
presence multi level pointers simultaneously information arriving different call sites propagate information extraneous call sites 
contrast illustrated discussion mapping method imprecise single level pointers 
instances interprocedural scheme avoid combining information arriving different calls sites give accurate results multi level pointers 
choi associate call site encountered alias pair 
information recover context avoid simultaneously alias information arriving different call sites 
distinguish information propagated different invocations procedure callsite 
properly handle information propagated call chains size greater 
propose source alias set abstraction role clear 
introduce approximations explicitly propagate information invocation paths program invocation graph representation 
advantages invocation graphs mentioned section 
empirical results support feasibility approach theoretically exponential cost 
techniques handle function pointers occur programs 
gracefully integrate points analysis framework incurring extra overhead 
dynamically allocated objects landi ryder access paths names anonymous heap objects 
limit access paths finite set object names presence recursive structures 
choi name heap objects place program created 
procedure strings limiting recursive structures improve naming scheme 
names alias calculation 
differ approaches claim stack heap problems separated 
fact analyses separated substantiated empirical evidence pointers general point back stack real programs 
single location called heap stack points analysis 
heap directed pointers point location 
designed separate family abstractions capture meaningful relationships pointers path matrix model proposed 
original path matrix analysis heap method proposed chase assume pointer fields heap nodes point heap nodes point variables locations stack 
important note points method provides safe approximation presence pointers heap stack 
may loss precision due abstraction heap locations stack location 
date experiments show problem reasonable decouple stack heap analyses 
function pointers problem constructing call graph program presence procedure variables previously studied 
techniques handle function pointers considered different data pointers 
function pointers multiple level fields structures arrays 
type cast data pointers vice versa 
full power points analysis needed correctly precisely accommodate interprocedural analysis 
analogous problem control flow analysis studied domain higher order languages 
possibility creating functions dynamically example lambda scheme poses additional complexity 
different approaches solve problem proposed 
object oriented languages call graph analysis non trivial due inheritance function overloading 
method invoked call site depends type receiver static type determination estimate control flow 
type analysis techniques developed self 
new method computing points information data structures 
method uses concept stack locations capture possible definite relationships accessible stack locations 
method provides context sensitive interprocedural information handles general function pointers integrated fashion 
points information generate traditional alias pairs directly numerous optimizations transformations including pointer replacement array dependence testing 
provided substantial empirical results demonstrate method provides accurate useful approximations 
results show safe accurate separate stack pointsto analysis structure approximations heap allocated objects 
furthermore method foundation general purpose interprocedural analysis method 
steps add optimizations method measure effect accurate points analysis optimizations transformations 
working companion analyses approximate heap 
analyses series practical approximations relationships directly accessible heap allocated nodes 
approximations vary simple connection matrices approximate connectivity nodes complete path matrices give complete approximations connectivity paths nodes 
acknowledgments special bill landi numerous mail discussions willingness share output analysis benchmarks 
pldi program committee careful reviews helpful comments 
people participated developing mccat compiler 
banning 
efficient way find side effects procedure calls aliases variables 
conference record sixth annual acm symposium principles programming languages 
pages january 
barth 
interprocedural data flow analysis algorithm 
conference record fourth acm symposium principles programming languages pages january 
callahan carle hall kennedy 
constructing procedure call multigraph 
ieee transactions software engineering pages april 
chambers ungar 
customization optimizing compiler technology self object oriented programming language 
proceedings sigplan symposium programming language design implementation pages june 
chambers ungar 
iterative type analysis extended message splitting optimizing object oriented programs 
proceedings sigplan symposium programming language design implementation pages june 
chase wegman zadeck 
analysis pointers structures 
proceedings sigplan conference programming language design implementation pages june 
sigplan notices vol 
choi burke carini 
efficient flow sensitive interprocedural computation aliases side effects 
conference record twentieth annual acm symposium principles programming languages pages january 
cooper kennedy 
efficient computation flow insensitive interprocedural summary information 
proceedings sigplan symposium compiler construction pages june 
sigplan notices vol 
cooper kennedy 
fast interprocedural alias analysis 
conference record sixteenth annual acm symposium principles programming languages pages january 
deutsch 
determining lifetime aliasing dynamically allocated data higher order functional specifications 
conference record seventeenth annual acm symposium principles programming languages pages january 
deutsch 
model aliasing abstractions finite representations right regular equivalence relations 
proceedings ieee international conference computer languages pages april 

design implementation structured backend mccat compiler 
master thesis school computer science mcgill university expected july 
emami 
practical interprocedural alias analysis optimizing parallelizing compiler 
master thesis school computer science mcgill university august 
hendren 
taming control flow structured approach eliminating goto statements 
proceedings ieee international conference computer languages may 
ghiya 
interprocedural analysis presence function pointers 
acaps technical memo 
school computer science mcgill university december 
ghiya 
practical techniques heap analysis 
acaps technical note school computer science mcgill university may 
hall kennedy 
efficient call graph analysis 
acm letters programming languages systems pages september 
harrison iii 
interprocedural analysis automatic parallelization scheme programs 
lisp symbolic computation international journal 

harrison iii 
program eye view 
conference record fifth international workshop languages compilers parallel computing august 
volume lecture notes computer science pages 
springer verlag 
hendren emami ghiya 
practical context sensitive interprocedural analysis framework compilers 
acaps technical memo school computer science mcgill university july 
hendren gao sreedhar 
alpha family structured intermediate representations parallelizing compiler 
acaps technical memo school computer science mcgill university nov 
hendren emami gao sridharan 
designing mccat compiler family structured intermediate representations 
conference record fifth international workshop languages compilers parallel computing august 
volume lecture notes computer science pages 
springer verlag 
hendren nicolau 
parallelizing programs recursive data structures 
ieee transactions parallel distributed systems january 
horwitz pfeiffer reps dependence analysis pointer variables 
proceedings sigplan symposium programming language design implementation pages june 
horwitz reps binkley 
interprocedural slicing dependence graphs 
acm transactions programming languages systems january 
jones muchnick 
flow analysis optimization lisp structures 
program flow analysis theory applications pages 
prentice hall 
chapter 
jones muchnick 
flexible approach interprocedural data flow analysis programs recursive data structures 
conference record ninth annual acm symposium principles programming languages pages january 
hendren 
supporting array dependence testing optimizing parallelizing compiler 
proceedings international conference compiler construction april 
volume lecture notes computer science 
springer verlag 
lakhotia 
constructing call multigraphs dependence graphs 
conference record twentieth annual acm symposium principles programming languages pages january 
landi ryder 
safe approximate algorithm interprocedural pointer aliasing 
proceedings sigplan symposium programming language design implementation pages june 
landi ryder zhang 
interprocedural modification side effect analysis pointer aliasing 
proceedings sigplan symposium ng language design implementation pages june 
landi 
interprocedural aliasing presence pointers 
phd thesis rutgers university 
marlowe landi ryder choi burke carini 
pointer induced aliasing clarification 
acm sigplan notices pages september 
myers 
precise inter procedural data flow algorithm 
conference record eighth annual acm symposium principles programming languages 
pages january 
panangaden demers 
effect analysis higher order languages 
international journal parallel programming 
pande ryder 
static type determination 
proceedings sixth usenix technical conference april 
ryder 
constructing call graph program 
ieee transactions software engineering se may 
sagiv francez rodeh 
logic approach data flow analysis 
proceedings second international workshop programming language implementation logic programming volume lecture notes computer science pages 
springer verlag august 
sestoft 
replacing function parameters global variables 
conference functional programming languages computer architecture pages london september 
acm press 
shivers 
control flow analysis scheme 
proceedings sigplan symposium programming language design implementation pages june 
shivers 
control flow analysis higher order languages 
phd thesis school computer science carnegie mellon university 

exposing side effects pl optimizing compiler 
proceedings congress 
north holland publishing amsterdam pages 
sridharan 
analysis framework mccat compiler 
master thesis school computer science mcgill university september 
weihl 
interprocedural data flow analysis presence pointers procedure variables label variables 
conference record seventh annual acm symposium principles programming languages 
pages january 
