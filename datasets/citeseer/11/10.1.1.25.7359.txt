logical framework reasoning data access control policies elisa bertino dipartimento di scienze dell informazione universit degli studi di milano milano italy bertino dsi unimi elena ferrari dipartimento di scienze dell informazione universit degli studi di milano milano italy dsi unimi propose logic formalism naturally supports encoding complex security specifications 
formalism relies hierarchically structured domain subjects objects privileges 
authorizations expressed logic rules 
formalism supports negation failure possibly true negation 
express negative authorizations 
turns conflicts may result set authorization rules 
dealing conflicts requires knowledge domain structure grantor priorities object subject hierarchies deductive process determine authorization prevails 
conflicts unsolvable express intrinsic ambiguities 
devised semantics extension founded stable model semantics logic programming 
defined number access policies orthogonal choices related way cope multiplicity authorization sets case stable model semantics concerned open closed assumption 
comparative analysis proposed authorization policies degree shows form complete lattice 
date access control policies developed deal controlling accesses data users francesco dipartimento universit di reggio feo di reggio italy ns ing pasquale dipartimento di matematica universit della di italy si deis application programs 
policies authorization models formalized corresponding access control mechanisms built today data management systems research prototypes 
major problem current access control mechanisms mechanism specific authorization model single specific policy fact built mechanism 
applications environments distributed digital libraries heterogeneous information systems cooperative systems workflow applications groupware articulated access control policy requirements directly met just single access control policy 
applications need deal distributed objects different types image video data relational data object oriented data require administered different policies 
example complex objects may require fine granularity access control possible access authorizations specific components object 
requirement calls positive negative authorizations exception mechanisms 
contrast relational data may need fine granularity access control 
data requirement explicit denials 
different policies authorization administration may need coexist system 
example cscw application environment granting user access data may require joint authorization users 
applications authorization single administrator may suffice 
clear access control mechanism uses specific policy supporting requirements arising different protection policies may difficult possible 
possible solution develop access control mechanisms able support multiple policies different objects users system 
obvious mechanism complex authorization model 
reason cases deciding allowing access may complex knowledge information grantor priorities may require quite articulated reasoning processes 
important model characterized formal semantics ensuring access control decisions consistent accord application policies 
logic formalism naturally supports encoding complex security specifications 
formalism relies hierarchically structured domain subjects objects privileges 
authorizations expressed logic rules allows condition authorization presence absence authorizations system 
formalism supports negation failure possibly true negation express negative authorizations authorizations expressing explicit denial 
richness formalism implies conflicts may arise set authorization rules 
dealing conflicts requires representation complex knowledge considered domain information grantor priorities object privilege hierarchies 
knowledge deductive reasoning decide authorization prevails 
cases conflicts unsolvable express intrinsic conflicting requirements 
instance consider having access document suppose manager wishes read right modify vice versa 
case domain knowledge determine deal specification number possible solutions denying access bob corresponds feasible interpretation specification 
deal structural conflicts devised semantics extension founded stable model semantics logic programming ordered logic corresponds possible conflict interpretation 
defines conservative approach sure authorizations derived authorizations derived ambiguous sources goes ambiguities providing number authorization sets represents consistent set access authorizations 
case alternative approaches decide access authorized pessimistic called certainty reasoning access request verified intersection authorization sets optimistic called possibility reasoning union taken 
possibility reasoning adopted problem arises selecting set authorizations access control verified 
deal non deterministic situation provide innovative strategy enforce access control choice authorization set driven accesses currently execution system 
aspect taken account dealing access control policies authorization rules specify denials open assumption access rights closed assumption 
open assumption access granted authorization rules allow derivation denial access closed assumption access authorized authorization rules allow derivation positive authorization particular access 
combination open closed assumptions semantics previously described gives rise number authorization policies useful particular context 
deal multiplicity policies provide comparative analysis various access control policies basis degree basis number accesses allow 
analysis system security officer decide suitable semantics specific application environment forced adopt specific built policy 
proposal advanced authorization model logic formalism 
model supports positive negative authorizations derivation rules 
current extends previous introducing different semantics dealing structural conflicts previous proposal stable model semantics possibility reasoning closed assumption considered providing comparative analysis policies semantics able express 
major extension practical relevance supporting multiple access control policies related theoretical issues 
side logic formalisms security specifications jajodia propose logic language expressing authorization rules show language express access control policies proposed far 
programs written language subset stratified datalog programs able express limited set authorization specifications 
contrast propose general language express authorization specifications syntactic restrictions stratification 
restrict consideration programs having unique model allow multiplicity models associated program show different semantics deal multiplicity 
logic language modal logic proposed abadi 
logic mainly devoted express concepts roles delegation authorizations operation certain protocols 
general logic language expressing authorization rules proposed woo lam 
language expressive suffers drawbacks 
important mechanisms provided deal conflicting authorizations 
contrast proposed general language express authorization rules semantic framework deal conflicts may arise rule specifications 
remainder organized follows 
section introduces basic components logic framework relies 
sections introduce logic formalism section shows different semantics model different access control policies 
section provides comparative analysis proposed policies 
section deals access control 
section concludes outlines 
basic components model relies basic components 
component set subjects authorizations granted 
subjects users elements elements 
users partially ordered importance 
users called allowed specify authorizations 
group consists number users 
groups hierarchically organized relationship 
authorizations specified group apply subgroups users 
second basic component model set objects denoting resources protected 
objects considered depend underlying data model 
files directories examples objects operating system consider relational dbms resources protected relations views attributes 
keep authorization model general applicable protection information different data models assumption underlying data model accesses controlled privileges users exercise system 
similarly groups objects organized part hierarchy called object hierarchy 
basic component model set privileges denoting access modes subjects exercise objects system 
real situations interactions exist privileges 
instance reasonable assume write privilege stronger read privilege subsumes privilege 
reason set privileges organized hierarchy called privilege hierarchy 
basic components model formalized notion program domain 
definition program domain program domain consists components 
subjects 
countable set labels called subject identifiers 
set partitioned subsets groups users 
contains special elements super group super user 
hierarchies defined group hierarchy 
partial order relation defined forall 
implies represents hierarchy membership users groups 
groups say subgroup 
user group means belongs 
shall see super group define authorizations hold subjects 
user hierarchy 
set users partially ordered way 
denote reflexive reduction 
shall see super user define strong authorizations authorizations overridden 

objects 
countable set labels called object identifiers 
contains special label called super object 
partially ordered way forall 
partial order models part relation objects 
denote reflexive reduction 
objects say subobject 
define properties hold elements 

privileges 
countable set labels called privilege identifiers 
partially ordered denote reflexive reduction wesay privilege subsumes privilege 
authorization programs syntax assume domain fixed 
set authorization rules specified 
partial order reflexive reduction 
low derive authorizations depending validity conditions instance existence permissions denials 
authorizations positive negative 
positive authorization states subject authorized privilege object negative authorization states subject denied access object 
set specified authorization rules forms authorization program 
provide syntax authorization program 
domain constants taken assume sets 
set predicate symbols types built user defined 
unique built predicate symbol arity type term represents privilege second represents user grantor authorization 
user defined predicate symbols untyped fixed arity 

set variable symbols 
term constant 
pair denote element second 
bound self 
atom construct form predicate symbol arity terms 
built denote type constant holds 
simple literal positive literal negative literal atom true negation symbol 
literal form simple literal 
instance object group referential literal 
literal simple referential literal 
simple resp 
referential literals complementary form resp 

literal denote complementary literal 
literals conflicting form rule expression form literals negation failure symbol 

note head may negative literal 
denote head literal body rule head predicate symbol called authorization rule called support rule 
head authorization rule second term representing grantor constant 
definition authorization program component identifier identifier short bound element 
set identifiers partial order defined follows identifiers iff 
denote reflexive closure relation 
component pair possibly empty set rules simple head literals 
authorization program finite set components identifier 
induces partial order obvious way iff read specific 
informally authorization rule appearing component head form resp express positive resp negative authorization privilege object granted subject 
recall identifies user specifies rule 
example consider program consisting component informally states object subject holds rule authorized read object provided subject denied true negation write object note literal referential literal addressing component identifier rule denied grantor write 
note true negation head example consider program informal reading object subject holds authorized write authorization anybody write 
note user defined predicate symbol negation failure 
body expresses object 
reason depends mechanism rules inherited subject object hierarchy gets instantiated objects components rule inherited keeps constant inheritance see example 
program expresses grantor access object authorized grantor vice versa recall super object 
examples provided informal meaning authorization programs 
high logic paradigm general task easy complex programs 
formal definition semantics authorization program provided 
aim section 
explain meaning authorization program authorizations derivable 
illustrated sections access protected resources granted basis derivable authorizations 
point semantic aspects regarding semantics program access control policies play crucial role proposal model innovative respect existing approaches 
matter deeply analyzed sections 
crucial aspect introduce just informal fashion concerns high expressiveness model 
due negation failure explicit negation negative authorizations allow designer naturally encode complex security specifications expressible classical models 
instance specifications programs entailing alternative meaning modeled framework 
give example program expressing mutual exclusion specification 
intuitively expected meaning program consists alternative sets entailed authorizations 
example consider program expressing simultaneously authorized write object 
ann bob program access object derived ann provided bob authorized negation failure access object vice versa 
consequence sets authorizations derived case permission access permission 
authorization programs semantics seen previous section authorization program encodes explicit knowledge concerning authorizations domain 
section provide formal semantics authorization program permissions derived rules 
aspects taken account implicit knowledge coming hierarchical structure program domain second possible contradicting authorizations arising conflicting rules 
preliminary definitions 
base program set ground literals simple referential constructible predicate symbols constants domain 
set literals consistent conflicting literals occur 
interpretation consistent subset 
interpretation ground base referential literal true resp 
false resp complementary true 
literals true false 
ground rule form interpretation 
body true true true 
body false istrue 
rule propagation hierarchies said object resp 
group hierarchy represents part relationship 
object oriented approach rules defined object resp 
group automatically inherited subobjects resp 
subgroups 
means instance user belongs group receives authorizations specified groups belongs 
similarly user authorization read directory default authorized read files belong directory explicit denial specified 
note authorization rules propagate regardless possibility generating conflicts 
definition component closure follows 
call referential rule 
example consider objects group belongs holds 
consider program consisting empty components auth note components associated empty 
rule propagation object group hierarchies component enriched inherited authorization rules follows note hold observe referential rule appearing form say holds identifier component comes 
instance identifier rule expresses rule inherited component having identifier 
authorizations propagate privilege hierarchy rules positive authorization privilege object implies positive authorization privileges privilege hierarchy ii negative authorization implies negative authorization privileges preceding privilege hierarchy 
privilege propagation rules semantics assigned relation 
privileges lower levels hierarchy subsumed privileges higher levels 
rule states positive authorization privilege implies positive authorization privileges subsumed 
means instance subject authorization write object authorization read 
second rule states negative authorization privilege implies negative authorization privileges subsuming 
subject denied read object denied write 
account privilege propagation define notion closure component 
definition component closure illustrated 
intuitively complete set rules encoding knowledge associated 
conflict resolution priority model contradicting authorizations may arise due simultaneous presence conflicting rules 
consider presence inconsistency define conflict resolution policy determines authorization defeat 
basic idea authorization rules assigned different levels reliability hierarchical organization domain 
words hierarchies provide means implicitly assign priorities authorizations rules preferred ones chosen 
informally conflicts authorizations solved policy 
conflicting rules taken account 
user hierarchy see definition considered 
particular grantor prevails conflict solved favor rules signed stronger grantor prevail 
incomparable object subject hierarchies exploited 
rely principle specific component rule belongs reliable authorization defined reliable rule prevails 
may happen components incomparable case say conflicts intrinsic unsolvable conclude way solve alternative solutions exist preferable 
conflict resolution may entail sets possible authorizations 
example consider component program example 
inheritance component contains conflicting authorization rules see example 
user inherits authorization write object component write object see 
fortunately conflict easily solved 
authorizations provided grantor source component negative authorization specific hold negative authorization prevails positive 
say negative authorization defeats positive authorization notion defeating formally defined 
consider case hierarchies provide support solve conflicts 
consider instance domain consisting user objects suppose program inheritance privilege propagation note contains conflicting authorizations permission denial user read object granted grantor 
source components incomparable 
turns conflict solvable defeating program encodes intrinsic ambiguity 
model conflict resolution policy formalized concept defeating define 
need preliminary notation definitions 
notation component identifier 
defined follows 
rule component identifier denote rule obtained replacing simple literal referential literal referential literal 
instance 
closure component definition ground program denote set referential rules component identifier version set referential rules obtained pair replacing variable appearing constant appearing program 
example ground version program example 







example clear semantics self differs explicit object subject rule associated 
self instantiated object subject rule inherited bound keep constant inheritance process 
see point look rules 
definition conflicting rules referential rules conflicting support rules complementary literals authorization rules conflicting literals 
ready formally define conflict resolution policy 
definition defeating interpretation referential rule 
say defeated support rule exists support rule conflicting rules body true holds see definition authorization rule exists conflicting rules body true conditions holds appearing respectively thatis stronger incomparable strong authorizations 
seen definition play crucial role conflict resolution 
important grantor higher priority specified authorization 
order prevent possible complete loss control model allows possibility defining properties absolute validity 
mechanism strong authorizations 
conceptually see strong authorization authorization provided sort super user user important denoted model see definition 
stable authorization sets assigning meaning program simple task 
seen conflicts coming true negation solvable general single way number possible equivalent solutions exist 
addition traditional logic programming presence negation failure source complexity possible ambiguities may arise 
expect general sets entailed authorizations associated program 
novelty logic programming widely accepted semantics stable models assigns logic program number possibly zero alternative models representing possible solution 
define semantics authorization programs relies classical notion stable model 
need extend classical concepts take account peculiarities language 
definition rule satisfaction referential rule true interpretation head true body true 
referential rule satisfied interpretation true defeated 
definition authorization program model model interpretation referential rule satisfied 
definition reduction authorization program interpretation denoted set ground rules defeated true 
note regarded datalog program negation failure simply considering referential literal form say resp 
simple literal predicate symbol resp 

set rules immediate consequence operator defined usual way see 
definition stable authorization set model 
stable authorization set example consider program example domain consisting object subjects ann bob tom privilege write 
ann write tom interpretation 
reduction auth 
clearly authorization set 
easily shown bob write tom stable authorization set see comments example 
example multiplicity authorization sets determined negation failure 
conflicts true negation may cause multiple authorization sets 
example consider program example ground version shown example 
seen component inherits conflicting authorizations prevails components incomparable 
consequence possible ways solving conflict exist corresponding possible authorization set 
easy verify authorization sets program 
reason presence program intrinsically ambiguous conflicts solved defeating 
note positive negative authorizations may occur stable model 
founded authorization set traditional logic programming may happen program admit stable authorization set 
solve problem define notion founded authorization set defined programs 
definition giving extends proposed ordered logic take account negation failure 
definition unfounded set program interpretation 
subset unfounded set rule form conditions holds 
false 
exists belonging 
defeated easy recognize traditional logic programming ordered logic union unfounded sets unfounded set exists greatest unfounded set 
denote greatest unfounded set 
ready define operator founded authorization set 
definition operator consider sequence interpretations monotonic operators monotonic 
finite sequence finitely converges fixpoint easy see fixpoint 

operator definition founded authorization set founded authorization set clearly program unique founded authorization set 
example consider program consisting unique component incomparable interaction privileges exists 
founded authorization set stable authorization sets 
intuitively founded semantics allows infer sure authorizations authorizations true deriving portion program free negation failure conflicts true negation unsolvable defeating 
logic programming property holds 
proposition founded authorization set contained intersection stable authorization sets 
importance founded semantics authorization programs lies tractability 
operator computable polynomial time 
access control policies seen program interpreted differently different semantics wellfounded stable semantics 
fixed semantics problem granting access request remains solved 
suppose instance conflicting authorizations belong distinct authorization sets 
done case 
authorization occur authorization set positive negative 
answer questions open assumption access control policies founded stable closed assumption open assumption possibility reasoning program specify denials open assumption specify access rights closed assumption known 
instance assume founded semantics chosen 
deciding deny access request quite simple task case 
clearly result depends closed open assumption taken 
case user permitted access positive authorization founded model 
denied 
open assumption taken user denied negative authorization founded authorization set 
authorized 
case stable semantics problem deal multiplicity authorization sets 
authorization set consistent conflicting authorizations may belong different authorization sets 
access request problem arises accepted denied 
consider modalities certainty possibility reasoning 
pessimistic approach certainty optimistic approach possibility 
informally case authorizations authorization set taken account 
particular closed assumption access granted certain authorization exists authorization set 
symmetrically open assumption access request accepted certainty denied exist authorization set containing negative authorization access 
possibility semantics possible authorizations allowed 
case closed assumption access request granted exists positive authorization authorizing stable authorization set 
symmetrically open assumption access re closed assumption open assumption 
access control policies taxonomy certainty reasoning closed assumption quest accepted possibility denied exist authorization set containing explicit denial 
summarizes access control policies 
notation denote semantics possibility certainty founded respectively 

definition policy authorization policy simply policy pair 
definition access request access request triple 
access request states user requires exercise privilege object 
definition access request satisfaction access request authorization policy 
founded authorization set family stable authorization sets 
say satisfied 
grantor 
grantor 
grantor 
grantor 
grantor 
grantor case possibility reasoning say satisfied 
nondeterminism 
worth noting possibility semantics entails form don care nondeterminism authorization set satisfying request nondeterministically chosen meaning program 
open closed assumptions 
easy see authorization programs expressing explicit denials closed assumption coincides classical closed access control policy 
similarly programs expressing explicit positive authorizations open assumption coincides classical open policy 
classical open closed policies easily modeled framework simply imposing semantic restrictions types rules specified authorization program 
having defined different authorization policies interesting see compared point view level 
proposition denote set access requests satisfied policy 
holds 

complete lattice shown bottom element restrictive policy top element permissive policy 
example consider program simplicity assume relationships privileges exist 
incomparable 
founded model program authorization depending form conflict 
contrast program stable models sets satisfied requests 







consider instance access request satisfied consider policy 
founded model undefined true false 
absence information policy permission prevail denial 
policies behave likewise 
occur distinct stable authorization sets policies take positive authorization 
contrast reverse reasoning applies remaining policies denials prevailing permissions 
conflict resolution example outlines authorization policies behave conflict resolution 
particular entail permissions take precedence resolution policy entail denials take precedence resolution policy 
access control mechanism section describe access control mechanism enforces previous authorization policies 
implementing founded semantics problem access request just needs verified founded authorization set open closed assumption accepted denied 
similarly case certainty semantics just required verify satisfied set authorization sets 
task semantics possibility taken 
case choice stable authorization set access requests verified driven privileges subjects exercising objects system access request issued 
access request access control mechanism selects authorization set satisfies ii satisfies current accesses 
authorization set exists access authorized denied moment 
clearly enforcing policy requires system maintain information set accesses currently execution 
algorithm implementing access control policy illustrated 
validity access request checked selected semantics founded certainty possibility 
case possibility semantics algorithm checks satisfied current authorization set 
access request authorized 
algorithm looks authorization set submitted request current accesses satisfied 
case access request authorized 
cases added 
authorization set satisfying elements exist request rejected 
assume dbms automatically updates time subject finishes access object 
closed ass wf closed ass cert closed ass poss open ass cert open ass poss open ass wf 
access control policies lattice note founded semantics certainty semantics adopted access requests authorized system coincide set satisfied requests computed definition 
means access request authorized iff satisfied 
contrast semantics possibility chosen access request satisfaction necessary sufficient condition access granted 
case set satisfied requests represent set access requests potentially authorized 
ones authorized depend accesses currently execution 
example consider program example domain defined example 
suppose component ann enriched authorization 
easy verify program obtained admits authorization sets ann write tom ann auth execute tom bob auth write tom ann auth execute tom 
suppose closed assumption certainty reasoning fixed consider access request bob write 
bob authorized authorization set write object request rejected 
contrary access request authorized certain authorization occurring authorization set execute object 
consider case possibility reasoning 
assume ann execute 
access request 
clearly satisfied algorithm access control algorithm input access request authorization program output access request authorized return 
method 
return return endif 

set current accesses return endif 
satisfied 
return endif return authorization set satisfies current access 
access request authorized 
ann execute bob write 
new request submitted denied possibility find authorization set satisfying new request 
concluding remarks complexity proposed access control algorithm 
known logic programming data complexity computing founded semantics polynomial task certainty possibility reasoning conp complete np complete respectively 
shown results hold authorization model 
note principle complexity stable model semantics drawback means possible express np complete problems 
time number efficient techniques proposed drastically improve computation 
instance dlv system supports stable model semantics disjunctive logic programs able solve hard problems prime implicant efficiently 
example problem instance clauses variables prime implicants find prime implicants propositional cnf formula literals variables 
recall prime implicant consistent conjunction literals subformula 
access control algorithm solved seconds sun ultra solaris 
results believe proposed access control policies result practical interest concrete security applications exploiting expressive power negation 
plan investigate issues near 
final remarks proposed logic formalism naturally supports encoding complex security specifications 
formalism relies hierarchically structured domain subjects objects privileges supports negation failure possibly true negation 
devised semantics extension founded stable model semantics logic programming 
represents conservative approach sure authorizations derived authorizations depends negation conflicts solvable defeating 
stable model semantics goes step forward solving possible ambiguities coming negation failure true negation 
approach entails 
easily seen prime implicant exists satisfiable 
finding prime implicant np hard problem subsumes satisfiability problem form non determinism due multiplicity authorization sets access request checked 
proposed semantics number authorization policies defined combining open closed assumption 
comparative analysis policies carried point view 
comment characteristic proposal 
combining inheritance groups subgroups users object subobjects true negation model supports exceptions nonmonotonic reasoning 
allows designer capture semantics complex application domains 
point view authorization specification model clearly hybrid positive negative authorizations specified 
open closed assumption determines program interpreted defining denials access rights 
plan extend directions 
developing articulated conflict resolution policies account aspects considered domain presence roles 
plan investigate heuristics selecting current model access requests checked possibility reasoning adopted 
direction concerns implementation issues 
particular logic language intended enduser language express authorizations rules 
language system enforce authorization policy 
top language plan develop visual programming environment directly user 
abadi burrows lampson plotkin calculus access control distributed systems 
acm trans 
programming languages systems 
bertino bettini ferrari samarati temporal access control mechanism database systems 
ieee trans 
knowledge data engineering february 
bertino bettini ferrari samarati access control mechanism supporting periodicity constraints temporal reasoning 
acm trans 
database systems appear 
bertino ferrari authorization model formal semantics 
proc 
th european symposium research com puter security esorics pages lncs springer september 
bertino ferrari administration policies authorization system 
proc 
th ifip working conference database security lake tahoe ca august pp 
bertino jajodia samarati supporting multiple access control policies database systems 
proc 
ieee symposium research security privacy oakland ca 
leone stable models computation logic programming inheritance true negation 
journal logic programming april 
leone scarcello expressive power ordered logic 
ai communications 
chen warren 
computing stable models integration logical query processing 
ieee tkde 
eiter leone pfeifer scarcello deductive system nonmonotonic reasoning proc 
th int 
conf 
logic programming nonmonotonic reasoning lpnmr lnai berlin 
fernandez song 
model evaluation administration security object oriented databases 
ieee tkde 
gelfond lifschitz stable model semantics logic programming 
proc 
th int 
conf 
logic programming mit press pp 

jajodia samarati subrahmanian bertino unified framework enforcing multiple access control policies proc 
acm sigmod may 
jajodia samarati subrahmanian logical language expressing authorizations 
proc 
ieee symposium research security privacy oakland ca pp 

sacc vermeir extending logic programming 
proc 
acm sigmod may 
leone rossi founded semantics stratification ordered logic programs new generation computing vol 
springer verlag november pp 

leone ordered logic programming sets 
journal logic computation oxford university press december 
lifschitz declarative semantics logic programs negation 
foundation deductive database logic programming minker 
ed morgan kaufman pp 

lloyd foundations logic programming springer verlag 
lunt access control policies database systems 
database security ii status prospects pages north holland 
marek truszczy ski computing intersection autoepistemic expansions proc 
st int 
workshop logic programming non monotonic reasoning pp 

niemel simons efficient implementation founded stable model semantics 
proc 
joint int 
conf 
symposium logic programming pp 
bonn germany 
bertino kim woelk model authorization generation database systems 
acm trans 
database systems march 
subrahmanian nau wfs branch bound stable models 
ieee transactions knowledge data engineering 
ullman principles database knowledge base systems vol 
computer science press 
woo lam authorizations distributed systems new approach 
journal computer security 
