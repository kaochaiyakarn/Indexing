linearly continuations josh peter hearn queen mary university london dcs qmw ac uk 
continuations raw material control 
explain wide variety control behaviours including calling returning procedures raising handling exceptions labelled jumping goto statements process switching coroutines backtracking 
powerful form represented callcc cousins programmer manipulate continuations class values 
argued unrestricted continuations especially combined state give rise intractable higher order spaghetti code 
languages give user direct reified access continuations scenes implementing control behaviours highly stylised 
just stylised usage 
remarkably argue forms control continuations linearly 
true wide range effects including procedure call return exceptions goto statements coroutines 
formally number control behaviours continuation passing style cps transformations language intuitionistic linear function types 
combinations features break linearity 
interestingly presence named labels 
backward jumping different character backtracking 
essentially attempt formalise ideas continuation usage hinted literature 
part say known suspected continuation insiders linear typings give stated 
basic idea seen type interpret untyped call value cbv calculus 
just scott gave typed explanation untyped calculus domain equation understand linear continuations terms informal proceedings third acm sigplan workshop continuations cw january 
appear 
reddy thielecke university birmingham reddy thielecke cs bham ac uk domain equation type results 
change principal type accept callcc discuss callcc duplicates current continuation ruled typing 
claim linear usage continuations typing source language types target language analyse control behaviour 
essential point continuation transformers continuations linear 
reason say continuations linearly 
interpretations variations idea 
chief concern describe main conceptual aspects linearly continuations way keeps technical discussion simple possible 
concentrate soundness 
comprehensive analysis completeness properties transforms variants represents challenge stating transforms variety features hope clear challenges 
problems discussed 

target language need formulation linear type theory built connectives dill presentation linear typing allows pleasantly direct description rely decomposition 

ranges type variables builds recursive types ranges primitive types 
types pointed types necessarily 
pointed types recursion allowed 
particular primitive types treat atomic data type integers pointed cps language 
possible add type constructors sums need 
distinction pointed non pointed types especially vivid standard predomain model system pointed type denotes pointed cpo bottom type denotes possibly cpo 
type results denotes point lattice cartesian product strict function space lifting 
interpreted inverse limit construction 
especially accurate model language interpretation validates contraction abstractness result type accounted 
model certainly adequate reasonable operational semantics serves useful point 
predomain variant original coherence space model linear logic 
model type denotes family coherence spaces pointed type denotes singleton family 
usual linear function type ai product ai stable function space direct product coherence spaces gives singleton family pointed type 
system uses typing judgements form context consists intuitionistic zone linear zone 
intuitionistic linear zones sets associations pairing variables types 
sets exchange rules built 
pi frequently consider situations number continuations held single tuple linear zone 
introduce syntactic sugar evident ary form product binary form 

xn pn stands pn 
xn xn stands xn 
simplicity presenting transforms handle recursive types equality approach 
unfolding 
equal yielding typing rule omit details refer comprehensive treatment 

call return prominent historic explanation procedure call return terms continuations fischer continuation cps transform 
transform untyped cbv operator calculus linear target language 

see mentioned source language procedures interpreted continuation transformers terms accept continuation yield continuation argument continuation type 
abbreviated 
henceforth explicitly define types type abbreviations corresponding domains 
continuation transformer effectively difference delta continuations form abstractions 
proposition 

xn contains free variables 
xn notice source variables get sent intuitionistic zone duplicated discarded freely 
continuation arguments hand show linear zone course typing target term 
common area confusion relationship linearity recursion 
recursion defined self application source language continuation times target 
short answer continuations need recursive continuation transformers construct non recursive continuations continuation transformers times 
explain concentrating transform basic self application clear target language recursion effected sort self application continuation transformer passed continuation obtained 
uncurry type continuation transformers call directly pass arguments 
important point self application source breaks linearity continuations target continuation transformers entirely possible continuation non linear violating linearity typing derivation self application target language see shows recursive type unwound type operand occurrence essential note linearity arise linear source continuations reified wrapped closures 
similar hearn reynolds linearity polymorphism arise target translation algol prevents state treated semantically class 

exceptions typing derivation self application target language exceptions powerful useful jumping construct 
typing properties complex vary somewhat language language 
study jumping aspect exceptions focus untyped source language raise handle primitives 
proceed domain equation 
typed version derived direct semantics moggi 
start followed standard cps semantics gives manipulation isomorphism 
double cps continuations manipulated current handler 
raise handle proposition 

xn contains free variables 
xn note cases manipulate handler continuation just pass 
transform raise indicates evaluated resulting value thrown handler continuation evaluation results exception raised current handler continuation 
correspondingly transform handle evaluates return continuation installs new handler continuation evaluates handle continuations 
sight treatment handling looks duplication current continuation 
left indicates program uses current continuation handler continuation 
linear typing succinctly summarises important aspect jumping behaviour exceptions draws sharp distinction callcc non linear usage continuations 

duplicating continuations crucial reason propositions hold application intuitionistic function argument free linear variables 
effect precluding upward continuations continuation wrapped closure returned passed argument function 
concretely demonstrated term typecheck upward continuation wrapped closure thrown continuation case 
term corresponds callcc throw source language exhibits backtracking behaviour leading higher order spaghetti code associated callcc 
typed variant callcc untyped call cc require modification interpretation procedures 
cps transform callcc shows continuations duplicated breaking linearity 
callcc 
fails typecheck bound linear passed return continuation argument 
similar backtracking behaviour seen snobol prolog continuation semantics obey discipline linearly continuations 

reified continuations ward versus downward expected reason continuations linearly call return exceptions cases reified say directly named program variables callcc achieves 
source language variables may appear number times term 
reasoning partially valid 
explain consider language continuations reified linearly 
consider language arithmetic expressions means labelling subexpression 
goto goto statement sends value position indicated label resides 
example goto evaluates evaluation jumps past effectively sending hole 
labelling expression sending goto effectively order version naming continuation callcc throwing 
analogy labelling expression associates current continuation expression label name goto effects throw continuation associated crucial point continuations reified escape context originally defined 
escape hand analogous term language class continuations callcc escape example previous section demonstrated 
means continuations upward language forward jumps downward 
previous cases language higherorder interpret expressions non recursive types primitive type natural numbers 
continuation tuple current continuation represent labels free source expression 
ln ln goto li li list labels 
ln 
precision transform parameterised containing labels free clause occurrences tuple linearity violated 
proposition 

xm contains free variables 
ln contains free labels 
xm moral story attribute failure linearity treatment callcc ability name continuations presence contraction weakening source language variables 
features upward continuations arise higher order procedures suffice break linearity 

backward jumps think linear continuations previous section due absence backward jumps 
backward jumps jump continuation multiple times violating linearity 
answer backward jumping require duplication continuations 
fact point treatment untyped calculus involves self application helpful look setting jumping effected explicit manipulation reified continuations call return mechanism implicit manipulation non reified continuations 
order bring central issues minimum distraction informal discussion define single recursive label giving precise treatment full language 
suppose simple language commands command continuations type stores 
performing backward jumps necessary communicate information loop indefinitely 
reasonable consider state alternatively consider labels accept number arguments 
suppose command type argument current continuation represents effect executing rest program second denotation single label show interpret construct jumps go back construct effectively binds result continuation transformer type accepts toplevel current continuation 
standard fixed point combinator sight desired transform appears incompatible linearity 
restricting continuations interpret type define transform approach recursive continuation defined directly typically taken continuation semantics goto 
moving level types tie label recursion 
note term take fixed point type definition program recursive continuation transformer continuations recursive 
upshot different backward jumps correspond different continuations may viewed generated fixed point unwinding 
similar handling recursion untyped calculus continuation transformers self applied unwind fixed point continuations recursive 
difference explicitly take fixed point rely self application 
curious linearity forces fixed points taken higher types 
background move full language small continuation language strachey wadsworth 
emphasise treatment recursive labels identical strachey wadsworth go level types accommodate linearity curious entirety compatible linear continuation usage 
source language consists expressions commands dummy goto 
ln cn true false valof primitive statement variable label 
note include explicit loops redundant easily added 
extend target language primitive type booleans tt ff primitive commands mapped interpretations target language commands interpreted types argument tuple current command continuation 
current return continuation expression continuation command deliver value 
failure continuation constant command continuation invoked valof command falls performing command 
remaining command continuations denotations labels scope 
similarly expressions interpreted types argument tuple current expression continuation expression continuation value expression delivered 
remaining arguments failure continuation command continuations handled 
transforms divergent term diverge parameterised sequence labels 
ln contains labels free term transformed 
defining transforms notation shorthand 

strachey wadsworth semantics uses current continuation projects argument performing sort dynamic type checking 
specify happens check fails 
specify execution diverges choices possible failure continuation carried instance 
interpretation valof expression valof installs failure continuation current continuation installs current expression continuation return continuation executes interpretation command evaluates expression current return continuation expression continuation ignoring current continuation 
proposition 

xm contains free variables 
ln contains free labels 
xm am 

xm contains free variables 
ln contains free labels 
xm am 
coroutines view continuation state process known time combination state labels implement coroutines 
design continuation semantics coroutines need full power features encodings class control higher order store 
need simply continuations coroutine swap 
extra ingredient needed ability pass saved state coroutine coroutine swap back implemented recursive type 
simplicity concentrate case having coroutines language arithmetic expressions 
language consists arithmetic expressions enriched construct swapping coroutine programs set global coroutines 
swap execution begins left swap value sent bound right coroutine executed 
subsequent swap coroutine sends value place swap executed 
swapping continues left coroutine terminates 
example swap swap returns 
part right coroutine gets executed 
discuss options coroutine termination 
transform uses continuations current saved 
current continuation result delivered normal termination saved continuation records true false kff 
valof dummy 
goto diverge 
ln cn 
ti ti suspended state coroutine 
domain continuations type expressions coroutines transform expressions defined follows 
swap idea transform swap construct evaluated saved continuation invoked 
invocation case coroutine changed state swapping swapping back evaluation current continuation saved suspended state current coroutine 
proposition 

xn contains free variables 
xn comes interpreting toplevel programs number alternatives revolve choice coroutine terminates 
purest possibility simply toplevel continuations terminate passing answer continuations state ti ci ti ti cn ti transforms expressions commands coroutine 
program type transform 
alternative coroutines finishes proceed jumped back toplevel continuation 
proposition 

xn contains free variables 
xn second alternative coroutine termination impossible jump back toplevel continuation just type coroutines race finishes 
semantics coroutine finishes delivers result subtle points interpretation 
coroutine terminates discard saved continuation coroutine 
necessary toplevel continuation type point consider affine system 
achieved replacing typing rules variables extra components tantamount weakening 
technically need weakening seen fact continuation ignores second subtle point arguments type toplevel programs proposition 

xn contains free variables 
xn affine variant 
point come limitations linear affine typing 
intuitively able type programs coroutines finish toplevel continuation 
put way harmless contraction interpretation 
limitation completely unexpected linear typing approximation linear behaviour 
illustrates problem joining coroutines raises type theoretic subtleties apart treatment coroutines 

related main reasons restricted type systems cps interest 
pragmatic current cps compiler leverage types communicate information source intermediate back languages 
constrained type system naturally captures properties expected source programs restricted type systems 
second reason conceptual 
control constructs continuations stylised way may hope better understand constructs studying typing properties semantics 
example contained observation callcc breaks linear typing exceptions 
case pure simply typed calculus soundness result fact cps target adheres linear typing discipline known continuation experts 
surprisingly able find transform stated literature 
emphasised call return obeys linearity 
certainly hints literature especially treatment coroutines shot continuations 
focus linearity grew study expressiveness distinguishing power control constructs intimately related number times continuation 
important note approach different filinski linear continuations 
transforms continuation transformers continuations linear 
filinski linear target language certainly accounted linearly continuations cbv transform additional essentially turns principal 
different line pfenning investigated substructural properties range cps obtained excellent results 
approach quite different aims techniques generally speaking say take somewhat semantic tack focusing approach exact implementation oriented 
compared approach important point ordered contexts account 
difficult see analysis approach coroutines continuation tuple continuations linear zone 
hand typing rules treat different occurrences continuations differently linearly 
result obvious type system reconstructed explained starting domain equation 
obtained preliminary completeness results linearly continuations currently analysis incomplete 
example identified sublanguages procedure call exception cases syntactic completeness results effect term target equal terms come transform 
presently different carved sublanguages similar source language obtained restricting types target languages obviously embed larger question embeddings preserve completeness transforms preserve contextual equivalence relations reflection soundness problematic 
syntactic questions number challenges denotational models 
example model cbv calculus conjecture linear cps model equivalent equivalent ask isomorphism full faithful embedding just adequacy correspondence 
lower order source languages able obtain completeness results coherence space model analysis extend higher order 
place try proceed game models laird give exact models control linear usage continuations extend visible 
course ask similar questions classes models described categorically specific concrete models 
displayed simple control constructs continuations linearly 
important remaining conceptual question linearity keeps turning 
partial answer contained observation control constructs simple direct semantics 
example procedures functions coroutines resumptions 
answer incomplete 
research partially supported epsrc 

abadi fiore 
syntactic considerations recursive types 
proceedings th annual symposium logic computer science 
abramsky mccusker 
call value games 
nielsen thomas eds proceedings csl 
barber plotkin 
dual intuitionistic linear logic 
tech report univ edinburgh 
bruggeman waddell dybvig 
representing control presence shot continuations 
proceedings acm sigplan conference programming language design implementation 
filinski 
linear continuations 
proceedings th annual acm symposium principles programming languages 

girard 
linear logic 
theoretical computer science pages 
haynes 
logic continuations 
journal logic programming 
laird 
semantic analysis control 
phd thesis university edinburgh 
hearn reynolds 
algol polymorphic linear lambda calculus 
acm january 
pfenning 
properties terms continuation passing style ordered logical framework 
workshop logical frameworks meta languages 
reynolds 
simple typeless language principle completeness concept 
communications acm pages 
acm 
sabry felleisen 
reasoning programs continuation passing style 
lisp symbolic computation november 
strachey wadsworth 
continuations mathematical semantics handling full jumps 
technical monograph prg oxford university computing laboratory 
reprinted higher order symbolic computation pp april 
tennent 
mathematical semantics snobol 
conference record annual acm symposium principles programming languages pages 
acm 
thielecke 
continuation twice implications expressive power call cc 
higher order symbolic computation 
thielecke 
exceptions versus continuations presence state 
smolka editor programming languages systems th european symposium programming esop number lncs pages 
springer verlag 
thielecke 
comparing control constructs typing double cps transforms 
proceedings third acm sigplan workshop continuations 
