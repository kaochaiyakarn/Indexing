theory aspects david walker princeton university cs princeton edu steve zdancewic university pennsylvania cis upenn edu jay princeton university cs princeton edu de ne semantics minaml idealized aspect oriented programming language giving translation user friendly external language compact de ned core language 
argue framework ective way give semantics aspectoriented programming languages general translation eliminates shallow syntactic di erences related constructs permits de nition clean easy easy reason core language 
core language extends simply typed lambda calculus central new abstractions explicitly labeled program points rst class advice 
labels serve trigger advice mark continuations advice may return 
constructs de ned orthogonally features language show abstractions functional object oriented contexts 
labels scoped language typed 
consequently programmers lexical scoping standard way prevent aspects interfering local program invariants 
categories subject descriptors formal de nitions theory semantics language constructs features control structures semantics programming languages operational semantics general terms languages design theory keywords aspects aspect oriented programming operational semantics type theory research supported part national science foundation career 
ccr 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
icfp august uppsala sweden 
copyright acm 

aspect oriented programming languages aspectj hyper provide facility intercept ow control application insert new computation point 
approach certain control ow points called join points designated special typically join points include entry exit points functions 
computation control ow points may intercepted piece advice piece code manipulate surrounding local state cause global ects 
advice triggered run time context join point meets programmer speci ed conditions making advice useful way instrument programs debugging information performance monitors security checks 
aspect collection advice corresponding join points apply particular program 
research aspect oriented programming focused applying aspects various problem domains integration aspects full scale programming languages java 
aspects powerful complex language mechanism combining features dynamic scoping continuation manipulation 
research orts signi cant progress understanding semantic issues involved theoretical underpinnings novel paradigm lag practical implementation orts 
primary goal distill aspect oriented programming fundamental components means designating interesting control ow points way manipulating data computation points 
goal obtain clear reusable semantic framework signi cant diculties 
object oriented specify join points entry exit points method 
de nition join points breaks principle orthogonality suggests programming language construct understood independently programming language constructs 
tightly coupling join point de nition semantics methods objects impossible understand aspects rst understanding methods objects complicated isolation 

di erent relatively complex varieties advice give particular join point 
instance aspectj allows programmers specify advice various join points 
sort advice similar feel suciently di erent appear require independent semantic analysis 
resolve diculties adopt central ideas type theoretic semantic framework de ned harper stone standard ml 
give semantics directly large relatively complex di erent kinds advice join points translate unwieldy external language simpler core language provide precise elegant operational semantics core 
translation eliminates shallow syntactic di erences similar constructs shrinking number features core ectively semantics 
translation implementation strategy source language 
core language de nes central new abstractions 

explicit labeled join points de ned orthogonally constructs language 
single kind rst class advice labeled join points gives meaning advice nds aspectj 
main contributions include type theoretic interpretation idealized useful aspect oriented language called minaml includes advice functions objects 
minimalist core aspect language de ned operational interpretation sound type system 
evidence core language general expressive scalable 
gives number examples written aspect framework 
shows enriching point cut language context sensitive predicates adding features objects change central machinery needed aspects 
prototype implementation toy functional aspectoriented language aml includes advice point cut declarations 
implementation comes parts mirroring theoretical development 
core language implemented library sml nj aml translated sml simple rewriter inserts calls core library 
section introduces features core aspect calculus syntax largely examples 
examples motivate design operational semantics type system described sections 
section de nes external language minaml 
subsequent sections generalize core calculus minaml extending include objects section richer point cut designators section 
concludes description prototype implementation sml nj discussion related sections 

core aspect calculus labeled join points essential mechanism core aspect calculus 
labels drawn nite set identi ers serve purposes mark points advice may triggered provide appropriate contextual information trigger predicates mark points control may transferred advice decides abort part current computation 
example expression lhe evaluated value evaluation resulting subterm causes advice associated label triggered 
construct permits unambiguous marking control ow point relying priori designation interesting control ow points hard wired aspectoriented languages 
advice fundamental level computation exchanges data particular join point piece advice similar function 
subtleties involved de nition 
advice manipulate data point uence control ow skipping code run advice absence 
advice indicates triggered control ow reaches point labeled variable bound data point evaluation proceeds expression body advice 
assuming advice installed program dynamic environment example evaluates xg 
note advice computes value type argument case integer importantly advice composed advice 
label may tag distinct control ow points long points indicate computations type 
example program causes instances advice run instance passed passed multiple pieces advice may apply control ow point 
general advice may ects order run important 
natural ways install advice run time environment runs new advice prior runs 
imagine generalizations idea simple scheme suces interesting applications aspects 
accordingly core aspect language includes expression forms respectively install advice prior advice 
cases running advice delayed corresponding join point reached program continues expression examples show advice precedence works assuming advice associated label environment 
lh 
lh 
dicult reason behavior program advice associated label unknown useful introduce scoping mechanism labels 
expression new allocates fresh label bound variable expression labels considered rst class values example rewritten follows new int ensures advice explicitly declared scope new get triggered location 
operators left associative evaluation proceeds left right 
installs environment rst environment second proceeding evaluation variables bound new expression vary providing modular program design 
features described far easy see aspects powerful potentially dangerous tool 
consider example new bool program immediately goes nite loop underlying program advice applies true value 
wand observed aspects implement arbitrary xpoints functions technique 
example power aspects program shows encode somewhat inecient implementation cells state provided advice 
cell represented pair functions rst dereferences cell second updates cell contents 
data stored advice associated label ref advice run returns current contents 
def init new ref ref init get unit ref set ref get set examples show aspects radically alter semantics programming language 
part contribution provide framework studying issues straightforward 
desirable advice suppress execution piece code replace altogether 
feature core aspect calculus written return allows alterations control ow program 
operationally return similar throwing value continuation raising exception 
value directly passed nearest enclosing control ow point labeled bypassing intervening pending computation 
point label program halts error analogous uncaught exception 
example program evaluates value new int ph return second example shows instrument function bool type bool argument true proceeds usual alternative code run 
new pre bool 
new post bool 
pre return post bool post pre hxi ei strategy labels pre post get triggered function entry exit 
advice associated precondition checks value true simply returns control body function 
false advice runs returns result directly point labeled post function instrumented adding label pre trigger precondition advice inspect function argument adding label post entire function body speci es return point function 
operational semantics section describes operational semantics core language grammar summarized 
simplicity base language chosen lambda calculus booleans tuples 
labels en new return range boolean values true false range advice values 
syntactic categories language include labels control ow points values expressions 
vector expressions 
en creates tuple 
expression binds components tuple vector variables scope types bound variables omitted clear context 
point cut language reduced minimum core calculus 
language design semantics completely compatible expressive point cuts section investigates alternatives 
note point cuts advice labels rst class values values may passed functions just data structure 
operational semantics uses evaluation contexts de ned grammar return return contexts give core aspect calculus call value left right evaluation order choice orthogonal design language 
requirement evaluation allowed proceed labeled points evaluation context 
requirement ensures evaluation contexts accurately describe nesting labels appear call stack 
operational semantics keep track labels generated new construct advice installed run time environment program 
allocation style semantics keeps track set labels associated types 
similarly ordered list installed advice operators respectively add advice head left tail list 
machine states con gurations operational semantics triples hl ei 


hl ei return operation needs pass control nearest enclosing labeled point convenient de ne function stack takes evaluation context returns stack labels appearing context 
stacks grammar 
top stack left list 
stack concatenation written associative unit 
function stack inductively de ned structure interesting cases stack 
stack stack evaluation context forms stack simply returns recursive application stack unique subcontext stack stack example stack hei ii 
operational semantics core aspect calculus transition relation hl ei 
hl machine con gurations consisting set allocated labels list installed advice running program 
rules straightforward 
auxiliary relation 
de ned gives primitive reductions language 
hl vi 
hl hl true 
hl hl false 
hl hl ei 
hl ef hl new ei 
efl hl ei 
hl ei hl ei 
hl ei rst rules usual rules lambda calculus booleans tuples xg substitution value variable expression fth rule allocates fresh label substitutes variable scope new operator 
rules simply add advice appropriate list 
advice head list run advice tail 
reductions apply evaluation context expressed rule hl ei 
hl hl 
hl remaining constructs advice invocation return expression require complex evaluation semantics 
multiple pieces advice may triggered single point operational semantics compose order indicated list advice treated function combined advice standard function composition 
composition de ned advice accepts input type produce output type return point lower stack 
behavior captured auxiliary de nitions 
rst takes list advice returns function composition applicable advice state second judgment form valid point cut satis ed con guration general satisfaction relation may arbitrary predicate current state machine section details point cuts 
core language satisfaction relation simply de ned equality relation label current program point 
advice composition point cut satisfaction de ned rules 

hl hl de nitions evaluation rule simply applies function resulting interpreting advice list value hl hl 
hl expression return immediately hands value nearest enclosing program point labeled evaluation contexts stack function behavior expressed rule stack hl lhe return ii 
hl program consists return expression context labeled stack labels contain label point labeled closest point return expression 
program steps immediately point labeled discarding context semantics essentially exception handlers 
note point labeled context return rule apply program get stuck 
type system type system core aspect calculus simple extension type system base language case simply typed lambda calculus 
main consideration necessary pass data back forth join point interest advice advice control ow points agreement respect type data exchanged 
new types label type labels annotate program contexts type pc type point cuts matching program contexts type advice type advice 
types typing contexts grammar bool tn label pc advice 
contains typing rules new aspect expressions 
rules standard judgments form indicating term type context boolean tuple typing shown standard 
tuple expressions typed vector types 
empty tuple types unit inhabited tuple types concatenation 
simplicity type system parameterized map labels types expressions may mark 
concrete label value type label new expression simply introduces new variable type label 
expression type label may label expression type point label label new label label pc pc advice advice advice label return type system cuts simply labels type pc implemented label expression type label may considered type pc 
advice associated point cut type pc constructed code expects variable type body advice produce result suitable returning point advice triggered 
body advice type note advice associated point cut accept produce values type possible compose order soundness composition operational semantics follows constraint 
rules installing advice permit program executed presence advice type 
lastly value returned label marking context type type exception continuation invocation return expression may context 
rules lead straightforward soundness proof style wright felleisen 
nished con guration form hl vi form hl return stack 
con guration hl ei typed advice case 
advice 
label type map parameterizes type checking judgments 
de nitions standard lemmas easily proved 
theorem progress 
typed con guration nished exists con guration 
theorem preservation 
hl ei typed hl ei 
hl extends hl typed 

minaml section gives semantics concrete called minaml translating core aspect calculus 
displays minaml syntax 
base types booleans functions 
booleans usual 
function declarations de ne non recursive value implicitly declare program point referred advice 
functions treated normally 
minaml allows programmers de ne static advice general core language programs may manipulate advice run time significant way 
advice immediately appended advice types bool terms ds decls ds 
bool ds fun ds ad ds prog pts aspects ad proceed minaml syntax store declared 
respect minaml quite similar aspectj 
aspectj minaml sorts aspects give advice execution point cut limited function call give advice execution give advice rst third cases bound variable replaced argument advice triggered 
second case replaced result 
declaring advice programmer choose replace entirely perform pre computation proceed perform post computation 
case proceeding fresh variable bound result function 
aspectj allows programmers refer method appears program private methods classes functions referred minaml advice scope 
decision allows programmers retain control basic information hiding modularity principles presence aspects 
instance programmer declare nested utility function assured advice interferes execution 
programmer decide expose function declaration manipulation advice declaring outer scope 
decision external language scoped truly external language design decision believe core aspect calculus rich express aspectj style advice slightly di erent translation strategy 
minaml interpretation give semantics typed minaml programs de ning type directed translation core language 
translation de ned mutually recursive straightforward permit proceed command appear arbitrary expressions inside advice doing needlessly complicates presentation adding insight 
allowing programmers variables de ned inner scopes pose external language dif culties simple scheme incompatible basic principles alpha conversion 
dif culties overcome giving bindings internal external name harper lillibridge translucent sum calculus 
naming conventions external language overcome translation internal language straightforward 
term bool term bool term term term term ds decs ds term term term term minaml interpretation terms ments terms declarations advice 
term translation judgment form term computes type term formed produces core language term type 
type checking context split parts 
context mapping minaml variables types 
context mapping program points pairs input output types program point 
example function bool int extends context binding bool int extends typing context bool int 
term translation type checks external language terms translates analogous core language constructs 
interesting action happens translating declarations advice 
figures details 
main idea translation function declarations explained example 
new program points declared course translation function entry point pre exit point post 
points may advice de nitions declared scope 
translation maintains invariant binding appears translated term type check context extended pre label post label 
main ideas aspect translation explained informally previous sections 
advice de ned core language advice triggered pre join point 
advice triggered post join point 
advice proceed statement de nes pieces advice pre point post point 
advice proceed statement triggered pre returns post main property translation produces typed core language terms 
de ne context pre label post label point wise extension translation 
lemma translation type preservation 

term 
ds decs 
ad adv advice 
term 
decs bool term bool ds decs bool ds decs bool term ds decs fun ds decs new pre new post post pre hxi ad adv ds decs ad ds decs minaml interpretation declarations term adv pre term adv post term term proceed adv pre post term adv pre return post minaml interpretation aspects proof lemma induction translation derivation 
combining lemma type safety result core language yields important safety result minaml 
theorem minaml safety 
suppose 
term fails terminate nished con guration hl 

hl objects bulk focuses aspects context purely functional language 
tried design core language feature orthogonal 
particular labeled join points de ned independently constructs reused computational settings little change 
order justify claim lifted abadi cardelli rst order object calculus ac directly textbook 
section shows aspect language constructs interoperate 
main point naturally need add objects external core languages semantics join points remains unchanged 
additional syntax needed external language allow programmers refer new join points underlying semantics advice remains 
analysis provides evidence semantic framework general robust 
object oriented core language type system syntax ac object oriented language taken directly abadi cardelli 



ac classless language 
new objects may de ned point computation 
superscript indicates series method declarations object 
method invocation denoted method update override denoted ac typing rules straightforward 
modi ed permit labels slightly signi cantly dropped subtyping sake simplicity 
extend operational semantics de ne evaluation contexts corresponding new expression forms appropriate beta rules 
evaluation contexts 
beta rules hl 
hl gi hl ei 
hl mn xn en adapt progress preservation theorems stated previous section need ll inductive cases objects proof structure remains intact 
object oriented external language external language requires new type objects new declarations de ning objects new expression forms method invocation update 
addition add expression form control monitoring method updates 
declaration monitor speci es update method object type may intercepted modi ed advice 
declaration introduces new join point programmers declare advice triggered join point triggered associated method update occurs programmers declare advice triggered calls method object join point 


object ds monitor ds 
simple example consider code declares object elds 
eld holds integer holds function adds integer argument 
prevent integer eld updated ectively rendering const program declares eld monitored installs advice replaces attempted update identity function 
object plus fun monitor int plus int int interpreting object oriented source language core aspect calculus poses challenges 
monitor declaration translates pair expressions allocate new pre post labels mark method updates 
interpreting method update case update monitored object declarations follows similar strategy compilation function bodies 
translation marks control ow points just prior just operation question 
advice declarations scope manipulate program points just manipulate function entry exit points 
full details omitted due space considerations 

complex point cuts section investigates generalizations basic aspect framework 
rst generalization allows advice associated set labels just label permits code advice shared program points 
second generalization permit run time inspection labels appear call stack allows advice context sensitive decisions modify program 
label sets rst generalization associates set labels piece advice 
doing useful situations advice applied di erent locations 
example want instrument collection related functions type preprocessing argument allow possibility associating di erent advice function 
sets labels situation expressed new pre new pre 
pre pre runs point pre runs pre pre runs pre 
pre hxi 
pre hxi 
necessary change syntax language minimal shown grammar 
fe eng 
fv vng advice fl ng triggered point labeled labels reached 
change operational semantics advice invocation simply replace de nition satisfaction relation fl ng hl fl ng advice applied order de ned list advice triggered label set 
evaluation semantics set operators straightforward de ne 
type system altered rules type checking point cuts 
type pc implemented set labels type 
label fe eng pc pc pc pc pc pc pc imaging re nements lines 
instance re nement put structure labels introducing hierarchy labels 
piece advice triggered label label lower tree 
including top label hierarchy de ne advice triggered labeled point reached 
minaml extensions interpretation extending minaml point cut language include sets labels requires minor adjustments syntax pc fp png ad pc pc pc pc proceed interpretation requires adjustments 
problem advice called multiple di erent labeled points impossible determine statically label return 
circumvent diculty translation uses rst class labels advice passed continuation label return 
new translation function advice declarations appears 
set source level program points fp png meta level function pre generate corresponding set labels fp pre pn pre function post similar 
translation object expressions omitted dealt analogously 
stack patterns labeled program expressions suce capture interesting program points point interesting depends context 
example typical aspects debugging print arguments term ds decs fun ds decs new pre label new post def post pre post term adv pre term adv post term term proceed adv pre post term adv pre return minaml interpretation label sets function called inside body second function debugging advice invoked called third function enable application provide mechanisms allow programmer specify dynamic contexts advice triggered 
tie contextual information advice construct general provide orthogonal mechanism querying run time state program 
section proposes stack patterns way achieve desired expressiveness altering advice approach leads cleaner semantics 
course evaluation labeled program points naturally form stack useful model computation carried program 
return expression fact determine point control passed 
stack patterns allow programmers write queries label stack 
aspect oriented languages permit queries data stored run time stack 
facility useful writing point cut designators triggers depend context 
handle feature extend core language means storing data values stack adding new expression store semantics store ordinary substitution value bound variable performed explicitly evaluation proceeds body store 
evaluation contexts extended include store store additional rules model explicit substitutions function yields set variables store 
hl store 
hl store hl store 
hl allowing evaluation proceed store binding means stack embodied evaluation contexts includes stored data 
extend stacks include values val addition labels extend stack function extract data 
val stack store stack val stack store stack stack patterns expressions describe stack labels stored values dynamic evaluation context metavariable pat emphasize expression fact stack pattern 
stack pattern similar regular expression labels may bind stored values 
grammar summarizes additions base language needed stack patterns 
val match val pattern matches stack consisting label concatenation pattern expressions written union written kleene star operator written intersection operator matches patterns intersection matched binding data patterns 
negation pattern matches stack possible way parse stack successfully pattern val matches value type stored stack 
booleans true false patterns respectively match stacks stacks 
program form match pat attempts match pattern pat dynamic stack extracting data bound val patterns 
stack successfully matches pattern expression function applied extracted data 
expression evaluated 
consider instrumenting function pre translation minaml 
store ordinary bind argument gives post pre hxi ei new translation allows stack pattern extract argument passed example write piece advice takes action called directly body example argument bound variable expression pre match pre post val post true take action just continue stack matches pattern pre post val post true control inside precondition advice leaving scope 
tail stack matched true 
subtlety true 

val val pat pat pat pat pat pat pat pat pat pat pat pat pat pat 
pat pat 
pat pat pat pat 
stack pattern interpretation functions instrumented pre post labels calls arbitrarily unlabeled functions post pre hand regular expression permit labels appear post post stack 
allow situation regular expression pre post true val post true 
label desirable depends situation 
point framework exible express possible choices explored translation extended variant minaml discussed 
adding additional evaluation contexts handle evaluation stack patterns operational semantics de ne behavior match expression 
additional rules needed stack pat hl match pat hl stack pat hl match pat 
hl evaluation rules judgment pat determines stack matches pattern pat 
values matched pat returned vector reasonable implementation stack matching restrict regular expressions second class values permitting matches stack predicate values 
permit compiler generate ecient automaton pattern matching sake generality consider fully dynamic case 
easy specify implementation pat nondeterministic inference rules shown 
remaining issue assign types patterns 
simplest solution give stack patterns type pat type patterns binds data type booleans labels treated stack predicates full blown subtyping rules permit coercion directly 
additional type machinery straightforward stack patterns may built compositionally stack patterns match expression takes pattern function handle successful match expression return case match failure 
minaml extensions interpretation extending minaml richer point cut designators style aspectj requires change source syntax shown grammar 
bool 
pat label 
pat pat 
pat pat pat pat 
pat 
pat pat pat pat val pat pat pat pat 
pat 
pat pat match stack pattern typing pcd val post true pcd pcd pat cflow pcd pcd true pat true pat true pcd pcd pat pcd pcd true pat true pat true minaml interpretation point cut designators pcd pcd pcd pcd pcd pcd cflow pcd pcd ad pc pcd pc pcd pc pcd pc pcd proceed clauses specify advice triggered conditions point cut designator pcd 
designator says advice triggered control immediately inside body function intervening calls 
case variable bound argument passed cflow pcd designator says advice triggered part calling context matches pcd arguments bound pcd nearest call example cflow means advice may triggered arbitrarily deeply nested function calls reachable body bound arguments passed designator pcd similar cflow arguments bound earliest calls 
pcd pcd designator requires context match pcd pcd pcd pcd requires context pcd pcd pat term ctx pcd adv pre pat pcd pcd pat term ctx pcd adv post pat pcd pcd pat ctx term term pcd proceed adv pre pat post pat pcd pcd pat ctx term pcd adv return pat pre pat def pre pat return pat def pre pat return pat def match oneof pre pat args post pat def post match oneof post pat args oneof def ln args def minaml interpretation advice match pcd pcd negation pcd holds possible way parsing stack match pcd 
new translation assumes function arguments store bound bound 
slight change minaml translation stack top stack guaranteed look val post val post val post 
top stack pre post post depending execution just entering just leaving point cut designator translates stack pattern 
interesting cases shown remaining cases straightforward 
patterns assume stack form translation advice declarations take care rest pattern shown 
translation handles label sets clauses threads return label aspects 
pattern requires top stack form val post variable bound value matched pattern 
cflow pcd pcd clauses respectively compile patterns match closest farthest occurrence pat 
compilation point cut designators similar translation shown 
di erence clause pattern matched proceeding advice 
top stack advice corresponding pre label advice top stack post label 
di erence advice bodies bind tuple values extracted stack match 
gure notation stands tuple variable bindings evident typing context similarly notation ctx means tuple types context translation minaml type preserving 
context pre label label post label point wise extension 
lemma translation type preservation 

term 
ds decs 
ad adv advice 

pcd pcd pat ctx pat 
discussion prototype implementation order experiment language design developed prototype implementation features described omitting objects negation value patterns 
prototype call developed sml nj extension core ml 
core aspect calculus implemented set ml libraries explicitly manipulating labeled program points creating higher order rst class aspects querying calling context stack predicate language 
libraries main modules 
point manages creation comparison structured labels mark join points 
re supplies utilities building regular expression patterns points matching point lists 
implemented sml nj regular expression matching utilities 
aspect implements operational semantics core calculus 
library interfaces included appendix part implementation follows theory directly 
deviation limiting programmers set domain speci predicates specifying point cuts left language open experimentation 
programmers function label stacks booleans trigger predicates function evaluates true join point advice invoked 
programmers expose current label stack list points regular expression queries construct functions write functions point lists 
deviation sml type system quite strong encode heterogeneous list aspects aspect store 
passing data aspect need coerce universal data type need coerce back universal data type return 
external language implemented simple program rewriter converts aml les sml les 
programmers may explicitly call core calculus libraries wish manipulate labeled program points directly 
may new form function declaration afun implicitly allocates pre post join points monitoring function entry exit described earlier 
ordinary sml fun declarations monitored aspects 
consequently aspect oriented programming languages aware aml programmers choose protect sections code external interference retain standard ml reasoning principles 
related number aspect oriented language design implementation orts signi cant impact industry including aspectj hyper 
study semantics aspectoriented languages lags 
closely related tucker krishnamurthi encoding aspects scheme 
approach uses continuation marks construct introduced clements aid implementation program debugging tools 
continuation marks similar labeled program points dynamically nest outer continuation mark overrides inner 
notation behavior continuation marks modeled adding additional rule hl 
hvi 
di erence leads slightly complex encoding aspects 
signi cant di erence tucker krishnamurthi develops typed theory aspects opposed untyped theory aspects 
douence give de nition pointcuts encoding haskell provide implementation java 
speci cation advice integrated language 
programs parts event program point producer monitor consumes reacts program points 
kiczales specify semantics aspect oriented language scheme show partial evaluation compile optimize 
couple authors developed small untyped formal calculi reasoning aspects 
instance wand kiczales developed denotational semantics pointcuts advice small aspect calcu aspect store ideally list label elements 
unfortunately sml provide existential types primitives intensional type analysis need 
stephanie weirich suggested encoding universal data types currently 
lus 
je rey develop objectoriented aspect oriented language give speci cation correctness proof weaving 
case join points directly linked semantics method calls developed orthogonal programming construct 
believe elevating join points status rst class abstraction allows semantic framework broader collection situations including functional imperative object oriented languages 
feel staging aop semantics terms core external languages important development helps modularize theory possible simplify core language minimum 
bauer walker describe language constructing rst class higher order aspects 
provide system logical combinators composing advice type ect system ensure advice interfere advice 
unfortunately presence aspect combinators operational semantics language complex 
consequently semantics appropriate platform experimenting aspect oriented design general investigating generalpurpose reasoning principles presence aspects 
stack patterns provide mechanism similar stack inspection mechanism interesting explore connection 
able implement stack inspection security policies aspects 
avenues research fall main categories 
development semantics aspects 

program analysis type systems promote safe aspect oriented paradigms 

extension implementation cover standard ml including admitting implicit program points integration ml sophisticated module system 

analysis performance cost advanced features including rst class advice stack patterns 
directions appealing plan concentrate items near 
speci cally wish consider enriching simple calculus adding new primitives example explicitly delete advice 
addition desirable develop theory contextual equivalence aspect oriented programs 
conjecture theory tractable minimalist core calculus section 
respect item believe de ning typed core aspect calculus signi cant step developing aspect oriented language interoperate advanced ml style modules 
fact initial inspiration labeled control ow points derived part internal external labels harper lillibridge translucent sum calculus 

shown main features aspectoriented languages modeled relatively simple constructs core calculus 
key features labeled control ow points support manipulating data control points mechanism inspecting run time stack 
approach leads largely language independent semantically clean way studying aspects 
developed theory core aspect calculus demonstrated applicability type directed translations minaml fragment ml aspects object oriented language 
claim approach scalable general theoretically founded 
acknowledgments dan kathleen fisher stephanie weirich penn pl club helpful feedback earlier drafts 
shriram krishnamurthi john clements pointing aspects continuation marks scheme 
abadi cardelli 
theory objects 
monographs computer science 
springer verlag new york 
appel macqueen 
standard ml new jersey 
wirsing editor third international symposium programming language implementation logic programming pages new york aug 
springer verlag 
volume lecture notes computer science 
aspect oriented programming 
filman bader editors special issue communications acm volume 
oct 
bauer walker 
types ects non program monitors 
international symposium software security tokyo japan nov 
clements flatt felleisen 
modeling algebraic stepper 
european symposium programming pages 
douence 
formal de nition crosscuts 
third international conference metalevel architectures separation crosscutting concerns volume lecture notes computer science pages berlin sept 
springer verlag 
harper lillibridge 
type theoretic approach higher order modules sharing 
acm symposium principles programming languages pages portland january 
harper stone 
type theoretic interpretation standard ml 
proof language interaction essays honour robin milner 
mit press 
jagadeesan je rey 
calculus untyped aspect oriented programs 
european conference object oriented programming darmstadt germany july 
appear 
kiczales hilsdale hugunin kersten palm griswold 
overview aspectj 
european conference object oriented programming 
springer verlag 
kiczales 
compilation semantics aspect oriented programs 
leavens cytron editors foundations aspect oriented languages workshop pages apr 
morrisett felleisen harper 
models memory management 
acm conference functional programming computer architecture pages la jolla june 
ossher tarr 
hyper multi dimensional separation concerns java 
international conference software engineering pages limerick ireland june 
tucker krishnamurthi 
pointcuts advice higher order languages 
proceedings nd international conference aspect oriented software development pages 
wallach appel felten 
security architecture known stack inspection security mechanism language systems 
acm transactions software engineering methodology oct 
wand kiczales 
semantics advice dynamic join points aspect oriented programming 
leavens cytron editors foundations aspect oriented languages workshop pages apr 
iowa state university university technical report 
wright felleisen 
syntactic approach type soundness 
information computation 
appendix core language summary types bool tn label pc advice pat base calculus labels true false en aspects return new label sets fe eng stack patterns val match store minaml summary types bool expressions ds declarations ds 
bool ds fun ds object ds monitor ds ad ds program points point cuts pc fp png point cut designators pcd pcd pcd pcd pcd pcd cflow pcd pcd aspects ad pc pcd pc pcd pc pcd pc pcd proceed libraries implemented simple functional aspect oriented programming language called aml extension core sml nj 
simple rewriter translates aml les typed sml nj source compiled linked libraries signatures 
signature point sig type point val new string list point val point string list val unique point int val equals point point bool signature re sig type re functions create base res val primitive point point re val empty unit re functions create complex res val opt re re re val plus re re re val star re re re val concat re re re concatenation val alt re re re alternation attempts match re point stack val match re point point list bool signature aspect sig type aspect type stack val tolist stack point point list create new aspect val aspect stack bool stack aspect functions add initial final aspects val unit val aspect unit mark control flow point val mark point point unit return value aspect label val return point point 
