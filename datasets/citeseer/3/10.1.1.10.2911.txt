beltway getting garbage collection stephen blackburn dept computer science australian national university canberra act australia steve blackburn cs anu edu au richard jones computing laboratory university kent canterbury kent ct nf uk jones ac uk design implementation new garbage collection framework significantly generalizes existing copying collectors 
beltway framework exploits separates object age incrementality 
groups objects increments queues called belts collects belts independently collects increments belt order 
show beltway configurations selected command line options act perform semi space generational older collectors encompass previous copying collectors aware 
increasing reliance garbage collected languages java requires collector perform 
show generality beltway enables design implement new collectors robust variations heap size improve total execution time best generational copying collectors aware average small moderate heap sizes 
new garbage collection algorithms rare define just new family collectors subsumes previous 
generality enables explore larger design space build better collectors 
categories subject descriptors programming languages processors memory management garbage collection general terms design performance algorithms keywords beltway copying collection generational collection java 
garbage collection gc automates reclamation memory program longer access 
object oriented languages author university massachusetts 
supported nsf itr ccr nsf aci darpa epsrc gr ibm 
opinions findings recommendations expressed material authors necessarily reflect sponsors 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
pldi june berlin germany 
copyright acm 
kathryn mckinley dept computer sciences university texas austin austin tx usa mckinley cs utexas edu eliot moss dept computer science university massachusetts amherst ma usa moss cs umass edu gc improves programming productivity reducing errors result explicit memory deallocation underpins sound software engineering principles abstraction modularity 
current gc algorithms performance overhead 
plots fraction time spec java programs spend gc function heap size high performance generational copying collector jikes rvm 
heap space tight gc comprise execution time 
applications may reduce cost simply larger heap decreases load collector 
shown research best total execution time achieved gc time minimized large heap sizes 
application cache memory tlb locality may degrade large heaps 
example paging degrades pseudojbb performance large heap sizes 
achieving high performance remains challenge especially programs workloads large memory requirements 
years research key insights shaped copying garbage collection 
weak generational hypothesis objects die young underpins generational garbage collectors preferentially collect youngest objects 
corollary observation generational collectors avoid collecting old objects 
incrementality improve response time led small nursery generations incremental algorithms :10.1.1.19.6616
researchers small copying collectors improve data locality 
demonstrate giving youngest objects time die improve collector performance 
beltway collection framework combine exploit insights flexibly efficiently 
addition beltway generalizes previous configure beltway behave region copying collectors aware 
beltway collector uses increments belts shown 
increment unit collection 
belt groups increments fifo queue 
beltway collects increment belt independently fifo order collects belt independently 
promotion policy determines copy surviving objects belt 
increments belts general generations objects generation collected en masse collect increments independently may multiple increments belt 
demonstrate beltway configurations command line parameters behave semi space collectors traditional generational copying collectors older collectors 
knowledge beltway configurations match previous copying collector organizations 
show generality enables combine percentage time spent gc total time relative best result lower better jess raytrace db javac jack pseudo jbb heap size relative minimum heap size log percentage time spent gc 
jess raytrace db javac jack pseudo jbb heap size relative minimum heap size log total application performance 
impact heap size performance spec benchmarks appel style generational collector 
optimal performance attained largest heap size 
ideas single collector 
design implementation range copying collectors exploit high mortality young objects avoid collecting youngest objects avoid collecting previously copied objects perform collection incrementally 
generality increases pointer tracking costs develop novel mechanisms bound costs 
instance maintain fewest possible pointers trigger collections number cross increment pointers exceeds threshold 
show configurations reduce garbage collection costs reduced copying better heap utilization compared best generational copying collector aware 
reductions improve total execution time generational collectors average tight heaps java spec programs 
new collectors resources effectively generational collectors 
evidence framework enables explore tradeoff responsiveness throughput leave thorough investigation responsiveness 
remainder organized follows 
beltway framework exploring copying collection program characteristics exploits 
section shows configure beltway implement variety copying collectors 
new collectors designed reduce total execution time 
section introduces novel mechanisms survivors survivors survivors allocation allocation allocation beltway configuration belts showing successive collections top bottom 
light arrows show allocations going nursery darker arrows represent copying surviving objects target source increments 
darker objects younger 
collectors efficient 
section compares collectors generational collectors demonstrates reduce gc time total execution time java programs 
section offers sample responsiveness results 
find reduced total execution time combined improved responsiveness area needs exploration 
related conclude 

generalizing copying garbage collection novelty beltway framework generalizes copying collection combining key ideas copying gc single collector 
section outlines ideas 
describe beltway framework exploits ideas 
key ideas copying gc objects die young 
weak generational hypothesis basis generational garbage collection 
generational collector divides heap regions called generations contain progressively mature objects 
youngest generation called nursery contain large fraction dead objects frequently targeted collections 
collector promotes objects survive copying generation 
avoid collecting old objects 
corollary objects die young tend long lived suggesting older generations collected frequently 
give objects time die 
observation objects die young objects require time die 
older collector exploits observation avoiding collecting youngest objects 
incrementality improves responsiveness 
length frequency collection limits responsiveness garbage collected programs 
generational collectors reduce average pause time repeatedly collecting nursery occasionally collecting heap 
tend improve worst case pause time 
algorithms aggressively incremental 
example mature object space collector collects increment time collects heap 
copying gc improve locality 
programs access objects similar age 
copying collectors exploit pattern improve locality consequent benefits cache tlb behavior 
collectors copy older objects near heap 
clustering reduces incidence pointers span regions heap avoids retaining dead objects simply referenced dead object region 
nursery attains locality keeping youngest frequently accessed objects near 
previously collector exploited ideas 
simple semi space collectors improve locality copying exploit ideas 
generational collectors give youngest objects time die occasionally collect heap fully incremental 
older collector avoid frequent copying old objects collect heap complete guarantee collect garbage 
beltway collectors beltway collectors depend simple organizational principles 
increment independently region memory 
belt grouping increments collected strict fifo order analogous conveyor belts 
selecting different increment sizes belt organizations promotion policies collector beltway framework configured implement known copying collection algorithms 
shows beltway collector belts increments 
collector promotes survivors increment higher belt 
copies survivors highest belt belt 
new allocations go increment lowest nursery belt 
beltway collector exploit ideas outlined follows 
belts generalize generations decoupling incrementality generation size 
lowest belt analogous nursery generational collector 
preferentially collecting increments nursery belt exploit weak generational hypothesis avoid collecting old objects 
beltway decouples collection belts arbitrarily incremental 
oldest increment belt collected fifo order beltway give objects time die 
copying generational incremental aspects beltway improve locality surviving objects provide locality youngest objects allocating nursery 

concrete instances beltway collectors demonstrate generality beltway framework describe beltway configurations correspond exactly known copying collectors 
describe new collectors novel mechanisms key implementing new collectors efficiently 
modeling existing copying collectors factor common copying collectors hold reserve sufficient memory accommodate collection largest possible increment 
copy reserve space large accommodate worst case survival collection objects survive 
copy reserve fixed half heap semi space collector generational collector implementations heap utilization efficiency suffer 
remainder section term usable memory refer total heap space appropriate copy reserve collector 
semi space collectors simplest copying collectors 
correspond trivial beltway configuration single belt containing single increment large usable memory collected full shown 
call configuration bss beltway semi space 
bss copies survivors new increment belt 
appel style generational collectors generations 
efficient memory allowing nursery grow consume usable memory consumed higher generation 
consequently collect nursery generations consume usable memory 
appel corresponds beltway configured belts increment capable accommodating usable memory depicted 
call configuration ba beltway appel generations 
increments consume usable memory ba collects nursery increment copying survivors higher belt 
higher increment consumes usable memory ba collects copying survivors new increment belt 
practice nursery size drops small fixed threshold heap considered full 
older mix algorithms incremental variation semi space collector 
called older mix mix copies newly allocated objects memory 
beltway configuration shown belt multiple increments 
allocates copies survivors increment belt triggering collection increments consume usable memory 
older collectors organize heap object age 
collect fixed size window slides heap older younger objects 
heap full collects window returns free space nursery positions window collection objects just younger survived 
bumps allocation point resets window oldest heap 
beltway configuration illustrated allocation belt copy belt increments size collection window 
allocates back belt usable memory consumed collects increment belt copying survivors back belt usable space consumed empty flips belts collects increment new belt copies survivors increment new empty belt continues allocate back new belt new beltway configurations go existing copying collectors describe new collector configurations beltway beltway 
beltway collectors add incrementality appel style generational collection 
belts belt contains increments maximum size conventionally expressed percentage usable memory 
belts correspond generations reflects degree incrementality 
appel collector lower nursery belt grows consumes re fact copy reserve slightly generous copied data may pack original data artifact object alignment copying order 
survivors bss allocation survivors allocation survivors allocation survivors ba survivors beltway beltway beltway configurations described sections 
diagram shows configuration belts increments copying survivors 
arrow indicates allocation triggered collection 
usable space point beltway collects oldest increment nursery 
promotes survivors youngest increment higher belt 
higher belt full collects oldest increment higher belt copies survivors youngest increment belt 
similar generational collectors beltway collects higher belt higher belt full nursery belt empty 
collects fixed size increment entire belt 
beltway combines features appel generational collector older collector exploits ideas outlined section 
fact ba special case beltway set 
steady state differs ba follows 
nursery typically contains increment varies size size older belt contains increments 
occupy usable heap space 
example increments partially full completely full increments belt partially full increment belt 
framework implementation supports beltway collectors explore configurations 
unfortunately beltway lacks completeness guarantee eventual collection garbage fails collect garbage cycles span increment 
beltway collectors address failure beltway respect completeness retaining lower belts increments size adding third highest belt single increment may grow large usable memory 
objects beltway reclaim lower belts promotes third belt collect entirety grown consume usable memory 
guarantees eventual collection large dead structures 
configuration achieves completeness expense incrementality worst case collection increment classic semi space survivors allocation allocation allocation generational collectors 
note equal beltway implements generational appel style collector 
section shows beltway outperforms appel collector total benchmark running time 
alternative approach lack completeness beltway collector complete incremental collector mature object space collector place third belt investigation scope 
realizing efficient beltway collectors broad implementation issues key viability approach 
incrementality depends heavily write barriers efficiency write barriers associated data structures critical 
best time collect heap full 
beltway collectors collection triggers preempt identifiable performance problems collections 
exploit dynamically sized copy reserve increment size heap occupancy leads better heap utilization ultimately better performance 
frames write barriers order collect increments independently efficiently garbage collectors remember collected increments rest heap 
simple semi space collector avoids need mechanism collecting usable memory 
generational collectors cheaply notice remember creation nursery rest heap 
example place nursery high memory observe creation pointers cross boundary high low memory 
instrument mutator application write barrier remember relevant pointers 
beltway collectors implement increments frames 
frame aligned contiguous region virtual memory accommodate increment 
frames reduce cost incremental collection ways 
frames power aligned address space distinguish inter frame pointers intra frame pointers shift compare 
second maintain number associated frame indicates frame relative collection order 
encounter inter frame need remember collect target frame sooner source frame 
record inter frame 
increment spans multiple frames marked collection time store pointers constituent frames 
barrier address ordered uni directional respect frames 
example collector cross increment pointers right direction remembered 
shows basic implementation frame unidirectional write barrier 
partially inline write barrier 
public static final void address source address target int source frame size log int target frame size log pointer inter frame belt collect belt collect target collected source int shift insert source basic beltway frame write barrier 
remembered sets total number frames configuration limited increment size number belts total usable memory tightly bounded 
maintain distinct remembered sets remsets target source frame pair 
run time enter inter frame appropriate set 
advantage approach trivially delete remsets relating frame 
ignore remsets increments occasional case collect 
example sufficient copy reserve empty lower belt fill higher belt collect increment lower belt increment belt 
optimization performs single collection immediate succession 
high write barrier activity nursery limited beltway beltway single bounded nursery increment minimizes write barrier activity 
jikes rvm introduces substantial write barrier overhead due initializing object type tib pointer 
type object older usually older object 
eliminate overhead single nursery increment extend basic beltway barrier filter pointers source nursery 
optimization older behavior nursery 
systems overhead able benefit multiple nursery increments 
collection triggers variety reasons best collect heap completely full 
instance fixed size nursery collectors collect nursery full heap full 
section describe number collection triggers define range additional conditions initiate garbage collection 
explored mechanisms nursery time die triggers multiple nursery increments believe configurations beltway benefit 
beltway beltway configurations report nursery trigger limits nursery single increment proved useful 
nursery trigger 
size nursery belt may bounded ensure frequently collect young objects die quickly 
obvious example trigger classic nursery generational collector limits nursery increment size increment equal maximum nursery size 
beltway beltway trigger limit maximum size minimum size single nursery increment 
trigger 
remembered set entries collection roots number entries grows survival rate increment goes time scan 
simple effective solution problem trigger collection remembered sets grow threshold 
time die trigger 
may want collect nursery increment reaches maximum capacity 
example appel style nursery increment accommodate usable memory collect nursery partially full 
increments youngest belt avoid collecting youngest objects time die 
time die trigger ensures objects ttd time die collect time measured bytes allocation 
heap ttd bytes full time die trigger ensure new allocations go second frame 
system allocating increment starts allocating objects second frame 
subsequently heap fills collects frame may full 
trigger prevents collectors collecting objects allocated ttd bytes allocation young 
believe configurations beltway able exploit triggers improve collector performance nursery trigger results 
dynamic conservative copy reserve pointed section copying collectors need copy reserve space copy survivors 
order avoid failure worst case copy reserve slightly larger largest possible collection increment 
usable memory heap space copy reserve obviously advantageous minimize copy reserve 
finer grained incremental collectors mature object space mos collectors beltway distinct memory utilization advantage require small copy reserve 
classical generational semi space collectors reserve half heap 
beltway collectors dynamically calculate conservative minimal copy reserve accommodate survivors worst case collection sequence 
copy reserve largest increment size largest potential increment occupancy collection 
determine maximum potential occupancy increment adding current occupancy plus maximum occupancy increment collector copy 
dynamic conservative copy reserve particularly effective beltway collector third belt rarely full 
copy reserve usually determined smaller increment size 
third belt fills copy reserve grows half heap third belt occupancy copy reserve equal size 
collect third belt copy reserve automatically falls back smaller size continuously maximizing usable memory 
benchmark description min 
heap size total allocation gcs jess expert system shell mb mb raytrace ray tracing program mb mb db simulates database management system mb mb javac sun jdk java compiler compiling jess mb mb jack generates parser repeatedly mb mb pseudojbb emulates tier transaction processing system mb mb table benchmark characteristics minimum heap size total bytes allocated number gcs performed appel style collector large small heaps respectively 

results section describes experimental setting including garbage collector environment hardware benchmarks 
gc time total execution time beltway generational collectors variety configuration parameters 
show sample responsiveness results 
experimental setting jikes rvm 
jikes rvm version implementation study 
jikes rvm jalape high performance vm written java includes aggressive optimizing compiler 
jikes rvm adaptive compiler fast build time configuration omits assertion checking pre compiles possible jikes rvm boot image 
developed new gc toolkit jikes rvm called includes beltway implementations previous generational collectors 
efficient flexible platform gc experimentation exploits object orientation java vm java property jikes rvm 
prior developing beltway implemented number gc algorithms 
collectors include appel style fixed nursery generational collectors performance report 
performance similar existing jikes rvm gc implementations 
existing jikes rvm collectors statically partition heap small large object spaces unconditionally utilize large object space 
unfortunately currently implement large object space 
direct comparisons native jikes rvm collectors possible significant changes systems 
developing generational collectors tuned eighteen month period heavy contexts 
example fast address order write barrier 
compare beltway collectors 
collectors limited way generalizations employ beltway 
design object oriented techniques enables reuse key gc infrastructure 
classes beltway generational collectors common 
implemented beltway collectors single collector command line options specify configuration 
benchmarks 
spec benchmarks drawn spec jvm suite pseudojbb slightly modified variant spec jbb 
running fixed time measuring transaction throughput pseudojbb executes fixed number transactions 
modification possible compare running times reasonably 
lzle thorough analysis spec jvm 
table shows characteristics system minimum heap size appel style collector fail bytes allocated system number gcs large small heap sizes 
ran program times collector configuration picked best execution time disturbed effects system 
separately performed statistics gathering run configuration measure rate write barrier fast slow paths taken 
ran programs heap sizes ranging smallest program completes times size 
hardware 
experimental timing runs performed macintosh mhz processor kb onchip data instruction caches kb unified cache mb chip cache mb memory running ppc linux 
throughput section examines gc total application performance range generational beltway beltway collectors 
comparing beltway configurations match appel style generational collectors show perform similarly 
turn choice generational collector compare fixed nursery collectors range sizes appel generational collector 
experiments show appel improves performance typically regardless nursery size 
main comparison point 
explore effect increment sizes beltway find long size small beltway sensitive increment size 
compare beltway beltway increment size find performance comparable 
execution collection times beltway appel fixed size nursery collector show beltway generally performs better generational collectors 
beltway appel compares gc time compares total application time 
performance graphs left axis performance relative best right axis actual time bottom axis heap size relative minimum top axis actual heap size 
compares appel beltway appel configuration beltway beltway geometric mean benchmarks 
collectors adapt nursery size occupy available space consumed higher generation 
garbage collection time virtually appel beltway 
beltway logical generalization appel generations enjoys collection time advantage smallest heap size performance appel beltway heap sizes 
variation total time results programs db pseudojbb sensitive locality effects magnified small variations collectors 
example appel uses simple boundary crossing write barrier scan boot image collection 
beltway uses general write bar gc time relative best result lower better mb mb mb mb mb mb beltway beltway appel style generational heap size relative minimum heap size log gc time seconds gc time total time comparison appel style collector beltway generation appel configurations 
described section records needed pointers boot image 
importantly results show beltway obtain performance improvements appel simply adding third generation 
incrementality generational collectors incrementality key parameter generational beltway collectors 
section measures performance generational collectors range fixed nursery sizes flexible nursery 
explores impact incrementality beltway collector 
compares performance configurations fixed size nursery generational collector appel style collector respect gc time total time geometric mean performance benchmarks 
appel collector superior space utilization naturally trade offs frequency collection space utilization results total collector performance 
contrast small fixed size nursery increases frequency gcs limits time die nursery 
degrade performance 
large fixed size nursery reduces available space higher generation leads frequent full heap collections worse performance 
furthermore reservation fixed proportion heap nursery significantly impacts collector capacity perform tight heaps 
lack results small heap sizes illustrates failure generational collector perform small heap sizes 
results show appel style collector best performing generational configuration result knowledge previously appeared literature 
basis results appel style configuration best performing fixed size nursery collector nursery size subsequent comparisons 
incrementality beltway compares beltway different increment sizes 
see beltway fairly robust increment sizes small increment size degrades performance 
degradation attributed frequent nursery collections time die diminished capacity collect large cycles second generation 
increase load third generation lead reduction heap utilization increase total time relative best result lower better mb mb mb mb mb mb beltway beltway appel style generational heap size relative minimum heap size log copy reserve 
configuration remainder results section appears perform natural point comparison fixed size nursery generational collector 
beltway versus compares beltway beltway explore sacrificing completeness improves performance 
geometric means configurations 
programs improve slightly beltway javac performance degrades beltway reclaims large cyclic garbage structure 
garbage collection time shows geometric mean time spent gc beltway fixed size nursery generational collector appel style collector 
robustness beltway respect heap size clear 
appel configuration allows higher generation grow large possible performs better fixed nursery configuration beltway exploits small increment size dynamic copy reserve fifo behavior higher generations reduce gc overhead substantially small heaps 
total time presents geometric mean program execution times beltway appel style generational fixed size nursery generational collector 
shows results benchmark 
general beltway improves performance significantly small moderate heaps performs heap sizes 
interesting results 
appel performs poorly large heaps pseudojbb program nursery large spreads live data 
second db garbage collection dominant factor 
locality effects cause variations performance different heap sizes collectors 
exception db jbb appel outperforms fixed nursery collector heap sizes programs 
comparing appel beltway appel performance match beltway heap grows times minimum heap size db 
addition appel needs times minimum heap size total time seconds gc time relative best result lower better gc time relative best result lower better gc time relative best result lower better mb mb mb mb mb mb nursery generational nursery generational nursery generational nursery generational appel style generational heap size relative minimum heap size log gc time seconds gc time total time impact nursery size performance generation collector 
mb mb mb mb mb mb beltway beltway beltway beltway heap size relative minimum heap size log gc time seconds total time relative best result lower better mb mb mb mb mb mb nursery generational nursery generational nursery generational nursery generational appel style generational heap size relative minimum heap size log gc time total time impact increment size performance beltway 
mb mb mb mb mb mb beltway beltway appel style generational heap size relative minimum heap size log gc time seconds total time relative best result lower better mb mb mb mb mb mb beltway beltway beltway beltway heap size relative minimum heap size log gc time 
total time 
comparisons beltway beltway appel style generational relative best 
total time relative best result lower better mb mb mb mb mb mb beltway beltway appel style generational heap size relative minimum heap size log total time seconds total time seconds total time seconds gc time relative best result lower better mb mb mb mb mb mb beltway appel style generational nursery generational heap size relative minimum heap size log gc time seconds gc time 
total time 
performance beltway appel style fixed size nursery generational collectors relative best 
javac jack match beltway performance 
beltway uses small moderate heaps effectively appel fixed nursery collector achieving performance memory constrained 
jess raytrace javac jack beltway achieves best performance virtually configuration 
performs wide variety circumstances 
responsiveness design beltway provide hard real time performance 
expect configurations offer better responsiveness collectors appel 
simple measures length longest gc pause distribution pause times take account clustering gcs prevent mutator progress longer period 
knowledge issue considered lzle ungar respect pauses caused dynamic compilation 
follow methodology cheng blelloch 
incorporate possibilities measure mutator utilization mu 
define mu fraction time mutator runs interval clearly mu ranges higher mu means gc running 
graphs minimum mutator utilization mmu 
point lies mmu curve intervals windows length lie entirely program execution mutator utilization mmu curves monotonically increasing maximum gc pause run asymptotic value throughput fraction time spent mutator 
shows graphs mmu curves runs javac heap sizes 
graph groups curves 
left indicate better responsiveness higher mmu smaller intervals 
graphs beltway behave similarly offer better responsiveness throughput configurations 
second graph see larger heap sizes maximum pause time larger increment size larger usable heap beltway offer behavior intermediate appel 
clear configurations beltway offer better responsiveness including appel 
beltway adjusted provide better responsiveness explored configuration space fully related characteristics various benchmarks offer tuning strategy 
total time relative best result lower better mb mb mb mb mb mb 
related beltway appel style generational nursery generational heap size relative minimum heap size log beltway framework combines exploits key insights incremental garbage collection segregating objects different physical regions heap order improve collector mutator performance 
section compares beltway collectors respect object segregation pointer tracking promotion policies incrementality completeness hybrids 
common segregation policy age age regions common collectors 
generational age collectors exploit weak generational hypothesis 
older collection renewal older called older mix just allocated older copied renewal older objects stay reachable 
beltway configurations exploit characteristics multiple increments fifo belts 
beltway complete older 
importantly beltway generalizes previous collector organizations addition supports segregation object characteristics size type allocation site segregation longlived immortal immutable objects explore type segregation 
increment tracked increment collected independently 
pointer tracking may remembered sets card marking hardware support combination techniques 
card tables common alternative remsets beltway 
card tables trade fast write barrier typically machine instructions increased scanning collection time 
marked entry card table means pointers written address heap range card corresponding mark collector scan card find pointers test discover interesting 
beltway collectors card tables reasons 
jikes rvm lays array scalar objects different directions heap 
start object determined previous object 
second performance card tables remsets depends strongly application behavior particular relative frequency writes card table scanning 
earlier experience suggests remsets generally faster 
give objects time die generational collectors may vary size nursery allocation threshold capacity trigger collection move boundary generations reflect demographic changes 
beltway total time seconds total time relative best result lower better total time relative best result lower better total time relative best result lower better mb mb mb mb mb mb beltway appel style generational nursery generational heap size relative minimum heap size log jess mb mb mb mb mb mb beltway appel style generational nursery generational heap size relative minimum heap size log db mb mb mb mb mb mb beltway appel style generational nursery generational heap size relative minimum heap size log jack total time seconds total time seconds total time seconds total time relative best result lower better total time relative best result lower better total time relative best result lower better mb mb mb mb mb mb beltway appel style generational nursery generational heap size relative minimum heap size log raytrace mb mb mb mb mb mb beltway appel style generational nursery generational heap size relative minimum heap size log javac mb mb mb mb mb mb beltway appel style generational nursery generational heap size relative minimum heap size log pseudojbb execution times beltway appel style fixed nursery generational collectors relative best 
total time seconds total time seconds total time seconds minimum mutator utilization mmu minimum mutator utilization mmu beltway beltway beltway beltway appel style generational interval size microseconds javac heap size mb beltway beltway beltway beltway appel style generational interval size microseconds javac heap size mb mmu plots javac heap sizes 
techniques threatening boundary technique 
prevent frequently collected increments filling prematurely collectors segregate surviving objects age mitigate early promotion 
example collectors control promotion recording object ages organizing generations creation survivor spaces bucket 
collection time methods access object generation promote copy generation increment age 
beltway subsumes improves techniques multiple increments time die triggers belt 
prevent premature promotion touch objects prematurely 
collecting region time region collectors provide incrementality 
generational collectors offer improved expected pause times need occasional full heap collections prevents worst case guarantee 
beltway framework allows investigation throughput pause time tradeoffs 
beltway offers incrementality expense completeness beltway provides completeness cost occasional full heap collections 
possibility leave adding mature object space copying rules beltway obtain completeness full heap collections 
common region collectors manage different regions different policies different managers 
example large object areas oldest generation generational collector may managed non moving collector 
mature object space mos collector handles older generations specially bounding volume copied collection offering eventual completeness 
regions may managed collector remaining handled static analysis stack discipline 
combine beltway collectors exploration scope 

new collector design beltway subsumes previous copying collectors 
generality beltway framework enables implementation new copying collectors combine key ideas garbage collection literature 
illustrate beltway encompasses previous generational region copying collectors aware identify new collectors beltway beltway 
design implementation collectors introduces need number new mechanisms including frames minimize write barrier costs collection triggers preempt collection problems dynamic conservative copy reserve efficient heap space 
mechanisms results show beltway outperforms state art appel style collector fixed size nursery generational collector 
beltway framework provides novel general efficient design implementation results better collectors importantly opens exploration large design space copying region collectors 

acknowledgments acknowledge gratitude ibm research making jikes rvm system available especially generosity mark wegman vivek sarkar mike hind mark mergen research teams built jikes rvm worked 
darko modified spec jbb produce pseudojbb emery berger matthew hertz tony hosking wang contributions 

bowen alpern attanasio anthony cocchi derek lieber stephen smith ton ngo john barton susan flynn hummel janice mark mergen 
implementing jalape java 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla volume acm sigplan notices pages denver colorado usa october 
acm press 
bowen alpern dick attanasio john barton burke cheng 
choi anthony cocchi stephen fink david grove michael hind susan flynn hummel lieber litvinov mark mergen ton ngo russell vivek sarkar manuel serrano janice shepherd smith sreedhar srinivasan whaley 
jalape virtual machine 
ibm system journal february 
andrew appel 
simple generational garbage collection fast allocation 
software practice experience 
andrew appel john ellis kai li 
real time concurrent collection stock multiprocessors 
acm sigplan notices 
david barrett benjamin zorn 
garbage collection dynamic threatening boundary 
computer science technical report cu cs university colorado july 
peter bishop 
computer systems large address space garbage collection 
phd thesis mit laboratory computer science may 
technical report mit lcs tr 
stephen blackburn kathryn mckinley 

putting write barriers place 
proceedings third international symposium memory management ismm volume acm sigplan notices berlin germany june 
acm press 
stephen blackburn sharad matthew hertz kathryn mckinley eliot moss 
pretenuring java 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla volume acm sigplan notices pages tampa florida usa november 
acm press 
hans juergen boehm alan demers scott shenker 
parallel garbage collection 
acm sigplan notices 
tim chang li hang pham 
controlling garbage collection heap growth reduce execution time java applications 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla volume acm sigplan notices tampa florida usa november 
acm press 
michael ron cytron 
contaminated garbage collection 
proceedings acm sigplan conference programming language design implementation pldi volume acm sigplan notices vancouver canada may 
acm press 
cheney 
non recursive list compacting algorithm 
communications acm november 
perry cheng guy 
parallel real time garbage collector 
proceedings acm sigplan conference programming language design implementation pldi volume acm sigplan notices pages snowbird utah usa may 
acm press 
perry cheng robert harper peter lee 
generational stack collection profile driven pretenuring 
proceedings acm sigplan conference programming language design implementation pldi volume acm sigplan notices montreal canada may 
acm press 
william clinger lars hansen 
generational garbage collection radioactive decay model 
proceedings acm sigplan conference programming language design implementation pldi volume acm sigplan notices pages las vegas nevada usa may 
acm press 
robert courts 
improving locality garbage collecting memory management system 
communications acm 
sylvia urs lzle 
study allocation behaviour specjvm java benchmarks 
erik jul editor proceedings th european conference object oriented programming ecoop volume lecture notes computer science pages brussels belgium 
springer verlag 
david gay alex aiken 
memory management explicit regions 
proceedings acm sigplan conference programming language design implementation pldi volume acm sigplan notices pages montreal canada may 
acm press 
lars thomas hansen 
older garbage collection practice 
phd thesis north eastern university november 
barry hayes 
key object opportunism collect old objects 
andreas paepcke editor proceedings sixth annual conference object oriented programming systems languages applications oopsla volume acm sigplan notices pages phoenix arizona usa october 
acm press 
michael hicks luke hornof jonathan moore scott nettles 
study large object spaces 
richard jones editor proceedings international symposium memory management ismm volume acm sigplan notices pages vancouver canada march 
acm press 
urs lzle david ungar 
third generation self implementation reconciling responsiveness performance 
proceedings ninth annual conference object oriented programming systems languages applications oopsla volume acm sigplan notices pages portland oregon usa october 
acm press 
antony hosking eliot moss darko 
comparative performance evaluation write barrier implementations 
andreas paepcke editor proceedings seventh annual conference object oriented programming systems languages applications oopsla volume acm sigplan notices pages vancouver canada october 
acm press 
richard hudson eliot moss 
incremental garbage collection mature objects 
yves jacques cohen editors proceedings international workshop memory management volume lecture notes computer science st malo france september 
springer verlag 
richard jones 
garbage collection algorithms automatic dynamic memory management 
wiley july 
chapter distributed garbage collection lins 
david moon 
garbage collection large lisp system 
guy steele editor proceedings acm conference lisp functional programming austin texas usa august 
acm press 
john reppy 
high performance garbage collector standard ml 
technical memorandum bell laboratories murray hill nj december 
standard performance evaluation 
specjvm documentation release edition march 
standard performance evaluation 
specjbb java business benchmark documentation release edition 
bjarne steensgaard 
thread specific heaps multi threaded programs 
antony hosking editor proceedings second international symposium memory management ismm volume acm sigplan notices minneapolis minnesota usa january 
acm press 
darko 
properties age automatic memory reclamation algorithms 
phd thesis university massachusetts 
darko kathryn mckinley eliot moss 
age garbage collection 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla volume acm sigplan notices pages denver colorado usa october 
acm press 
mads tofte jean pierre talpin 
region memory management 
information computation february 
david ungar 
generation scavenging non disruptive high performance storage reclamation algorithm 
acm sigplan notices april 
published acm software engineering notes may proceedings acm sigsoft sigplan software engineering symposium practical software development environments april 
david ungar frank jackson 
adaptive policy generation 
acm transactions programming languages systems 
derek white alex 
gc interface evm 
technical report sml tr sun microsystems laboratories december 
paul wilson 
simple bucket brigade advancement mechanism generation garbage collection 
acm sigplan notices may 
paul wilson 
garbage collection memory hierarchy 
yves jacques cohen editors proceedings international workshop memory management volume lecture notes computer science st malo france september 
springer verlag 
paul wilson thomas moher 
card marking scheme controlling intergenerational generation garbage collection stock hardware 
acm sigplan notices 
benjamin zorn 
comparative performance evaluation garbage collection algorithms 
phd thesis university california berkeley march 
technical report ucb csd 
