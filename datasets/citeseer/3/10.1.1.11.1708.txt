system software safety critical systems jonathan bowen university reading department computer science po box reading rg ay uk december safety aspects computer systems increasingly important software convenience exibility 
complexity modestly sized programs elimination errors high degree con dence extremely di cult 
number approaches enhancing safety safety critical control systems 
surveyed compared particular emphasis systems software controlling system 
glossary terms extensive bibliography reading included 
decade elapsed leveson classic software safety published 
time computers safety critical systems increased order magnitude research undertaken try improve development process reduce number catastrophic failures 
relatively lucky number people killed attributable directly computer malfunction remarkably small 
reason software critical systems continues increase exponentially means need vigilance important 
reliance computers safety misplaced lack understanding concerning complexities software 
main purpose developments system software safety approaches especially decade 
various methods available enhancing safety safety critical systems introduced possible implications discussed 
background software increasingly control safety critical systems control functions required complex 
happens spite current software engineering methods guarantee expected level safety 
section gives de nition understood safety critical system goes argue safety distinct quality ofa system 
overview articles books safety critical area mentioned section 
section points advantages software particular problems associated software control safety critical systems 
section gives overview rest 
safety critical systems safety critical system system incorrect function failure may serious consequences loss human life severe injuries large scale environmental damage considerable economical penalties 
measure arbitrary value attribution de nition safety critical 
precise term life critical mission critical environmental critical cost critical precise nature severe consequences important discussion term 
areas safety critical computer system applied include military weapon delivery systems space programs 
industry manufacturing control toxic substances involved robots 
transport wire systems board aircraft air tra control interlocking systems trains automatic train control computer systems cars road side variable message tra signs see buckley 
communication ambulance dispatch systems emergency call part telephone system 
medicine radiation therapy machines medical monitoring medical robots see davies 
nuclear power plant control 
apparent example areas safety critical systems real time control systems 
type systems considered 
systems types exist 
example bowen viz 
ammunition storage system 
safety distinct quality safety considerations reliability considerations result overlapping requirements result distinct con icting requirements safest railway trains brought halt 
basic safety requirement freedom accidents qualitatively di erent reliability requirement concerning continuity required service 
safety safety critical systems great public concern re ected fact systems adhere government regulations industry standards certi ed licensing bodies 
regulations standards bodies concerned exclusively safety 
distinguishes safety security unauthorized disclosure modi cation withholding data severe consequences mentioned section 
generally safety concerned consequences threatening outside world security concerned data held computer system 
safety critical software clearly software cause accident 
software control potentially dangerous systems safety critical 
safety system property safety software assessed considered part system 
current state software engineering fact allow software safety critical systems debatable see example sommerville parnas leveson section 
generally di cult demonstrate computer program operates correctly demonstrate correct operation traditional engineering devices 
reasons discrete nature computer systems 
continuous systems studied rm theoretical basis di erential calculus study discrete systems established 
reason usually possible states considered computer system traditional engineering system 
traditional engineering hardware possible continuous analysis rely interpolation test results computer systems discrete nature means traditional testing methods smallest change system state bit may enormous consequences 
computer circuitry repetitive structure cf 
leveson column amenable analysis 
case software 
large number states software usually exhaustive testing impossible 
means potential hardware failure modes generally predictable limited number potential software failure modes unpredictable unlimited number 
analysis system potentially unsafe behaviour simpler system software system software 
fact software extensively safety critical applications new ones old ones relays analogue technology replaced digital computer systems 
reasons digital computer control safety critical system may possible way obtain required functionality case new application ers reduced costs increased functionality including checking hardware greater exibility design modi cations compared non computerized system see parnas koch reeves section 
versatility exibility inherently coupled complexity di cult ensure intended behaviour 
lower power consumption weight volume advantages absence software traditional wear failures 
technique system safety employ backup system backup di erent technology primary system order avoid common mode failure cf 
leveson 
emphasized done leveson computer system considered adequate diverse back computer system systems common mode failures di erent computer hardware version programming see leveson 
reason decided introduce computer control system wise keep hardware back interlock device ensures correct sequencing events fundamentally di erent failure modes di erent technology 
dangers computerization desirability retaining non computerized safety mechanisms illustrated injuries deaths caused radiation therapy machine see leveson turner 
safety may strongly dependent factors interaction interface human computer interaction hci 
subjects treated reader referred chapters mcdermid section leveson section 
overview literature safety critical systems subject system safety engineering branch engineering 
older eld related safety called reliability engineering dependability engineering 
eld increasingly concerned computers computers spreading 
comprehensive treatment book chapter devoted history dependability eld chapter explicitly deals software aspects 

comprehensive easily read traditional safety engineering terry 
system safety engineering techniques may relevant studying software safety proven techniques older eld repeatedly adapted software see leveson 
furthermore real world application safety assured considering system including software traditional engineering components 
research topic separate system safety computer reliability study safety critical digital computer systems fairly 
grown considerably years re ecting distinct increase computers safety critical systems 
entrance subject safety critical software written knight littlewood brief mentions issues involved 
contains bibliography mentions relevant journals conferences 
frequently cited overview article probably leveson contains comprehensive bibliography 
leveson provides slightly popular overview 
fairly excellent overview place kang contains extensive annotated bibliography 
awell written brief overview software safety critical applications sommerville book chapter 
parnas provides discussion reliability trustworthiness software low suggest ways improvement 
bowen provides overview industrial formal methods considerable number standards emerging safety critical eld 
leveson book collects expands previous safety particular computer systems gives comprehensive treatment system safety management aspects human factors 
new book neumann concerned computers risks primarily security safety contains extensive collection accounts dangerous incidents real life 
hand hoare considers software managed reliable considering development practices associated 
consideration commercial shelf cots equipment increasingly important competitive pressures 
overview section gives overview techniques general system safety techniques enhancement safety particular software subject section 
sections include extensive relevant literature 
system safety section concerns techniques aim enhancing system safety 
speci software techniques dealt section 
system safety implications software safety 
firstly safety analysis system surrounding software identi es safety critical failure modes software presence absence outputs may contribute accident 
secondly techniques system safety provided inspiration software safety techniques 
techniques enhancing safety construction project categorized phase technique applied 
done section 
management safety project phases essential safety technique 
subject section 
identifying evaluating potential hazards safety critical subsystems potential safety critical faults goals hazard analyzes described section 
hazard analyzes central element safety process see leveson chapter coordinating evaluating diverse orts various project phases 
design phase safety critical faults may eliminated occurrence minimized consequences fault may minimized reducing risk 
design philosophies addresses safety subject section 
section describes fault tolerance hardware proved successful technique enhancing safety reliability matter 
strategies faults appendix contains list de nitions terms relevant subject 
su ces state failure result error turn result fault failure subsystem seen fault higher level 
safety reliability dependability distinct qualities overlapping 
techniques successfully combat faults achieve dependability includes safety cf 
appendix system construction divided categories cf 
anderson section weinstock section johnson section burns wellings section fault avoidance 
pre operational phase include requirements analysis speci cation design maintenance bug xing functionality adjustment performance improvement aim engineering methodologies practice achieve system works expected contains minimum errors 
fault elimination detection removal 
pre operational phase maintenance techniques detect localize remove faults system extensively 
fault tolerance 
operational phase system executing fault tolerance built system preceding phases may employed cope run time failures 
system called fault tolerant respect certain class faults ability deliver expected service degraded version face faults class 
fault tolerance dealt sections 
fault evasion 
operational phase may occasionally possible observe system behaviour detect anomaly indicating component strain fail 
fault consequences avoided compensating action called fault evasion see weinstock section 
techniques techniques enhancing safety fault avoided removed tolerated contributed hazard de nition related terms see section appendix 
reliability analysis studied system deliver required service assume perfect execution environment adheres speci cation 
scope safety analysis di erent meaning sort faults avoided eliminated tolerated 
hand safety analysis concerned fault consequences safety mission deemed critical functional non functional requirements put forward system 
hand safety analysis necessary consider happens system environment changes extreme fashion happens parts system spite orts behave prescribed 
management procedures management procedures documentation essential order ensure safety safety critical project realistic size 
safety considerations development safety critical system starting preliminary hazard analysis compilation safety speci cation formulating safety requirements 
project phases safety continually evaluated demonstrated safety speci cation met 
experienced person involved development process appointed responsible ensuring safety system safety related activities systematically documented 
life cycle models support management de ning project phases deliverables 
bell reinert bell life cycle model originating international electrotechnical commission draft standard software systems safety critical applications je presents model health safety executive buckley presents originates proposal european standard development safe road transport rti systems produced drive safely project funded european community drive programme 
safety life cycle sommerville book section 
contents software safety plan described mcdermid 
template standard documentation safety terry 
central document concerning safety hazard log record hazards associated system 
hazard log initiated early system development typically part preliminary hazard analysis kept date lifetime system system development system assessment system operation system maintenance see mcdermid 
hazard log index safety case states reason system believed safe see mcdermid 
safety case contain assessment risks associated hazards account ofany steps taken reduce eliminate hazard risk 
hazard analysis hazard analysis iterative performed project phases 
purpose hazard analysis see leveson section identify hazards unsafe states system consideration evaluate risks hazards identify measures taken eliminate control hazard reduce risk 
addition reducing hazards posed system secondary bene hazard analysis tradeo involving safety explicit traceable 
early project phases hazard analysis inevitably quite resolution left vague unspeci ed 
system concrete hazards described concretely speci counter measures devised veri ed 
preliminary hazard analysis pha earliest form hazard analysis see chapter leveson appendix 
started early system development concept exploration preliminary design 
purpose pha assess risk identifying safety critical functions potential hazards assessing potential consequences hazards 
results pha evaluation design alternatives determination system safety requirements 
name indicates preliminary hazard risk analysis pha supplemented assessment risk 
nature safety critical systems hazardous states entered intentionally associated risk deemed acceptable view importance system risks feasibility alternative solutions 
example consider airplane 
hazardous states entered intentionally potential occurrence may calculated risk ought system properly analyzed 
leveson lists ways system enter unsafe state hardware component failure 
interfacing communication timing problems components system 
human error operation maintenance human error de ned human action producing unintended result 
environmental stress temperature variations radiation 
software control errors 
deliberate malicious interference humans added list clearly related security included hazard analysis intention safety violation immaterial 
anumber established techniques identifying hazards exists 
comparison various analysis techniques chapter 
established techniques include 
reviews walk throughs 

checklists sums past experience practice 

hazard operability study qualitative analysis aimed identifying hazards see terry section leveson 
representation system operating procedures reviewed procedure variations system parameters considered typical question substance 
review performed brainstorming team include domain experts 
assumption hazards arise system parameters deviate intended values represented model review see may true 
technique origin british chemical industry general applicability section regards speci adaptation see thermal hydraulic systems technique cause consequence type 
failure mode components system considered order assess ect system 
possible identify failure modes critical regard property safety 
really reliability technique safety technique considers failure modes just safety 
widely evaluation hardware reliability 
main steps listed de nition system function components 
identi cation component failure modes causes 
study failure mode ects system subsystem 
recommendations 
analysis results tables example chart terry 
results preliminary supplemented results analysis methods deals better combinations faults 

failure modes ects criticality analysis extended version failure mode attributed occurrence probability seriousness consequences rated see chapter terry 

probabilistic risk analysis pra called hazard analysis 
method determining quantitative form likelihood hazardous happen 

gathered fault combination method 
inductive method see chapter starts 
takes combinations faults component failures account suited systematic analyzes applied sets interacting elementary systems 

state space method ssm 
ssm described chapter 
distinguishing feature addresses systems 
ssm identify operating failed states system assess system availability reliability maintainability see section appendix 

fault trees analysis fta cause tree method ctm 
fta brie described leveson name ctm chapter 
starts single undesirable event 
purpose method identify event combinations lead undesirable event interaction logic 
analysis represented graphically tree undesirable event root lower level cause event nodes connected gates 
implied tree structure means set possible dependencies assumed form acyclic graph 
need necessarily case see weinstock section 
comments ctm cause tree method commonly technique analyze system reliability availability safety section implementation method di cult totally impossible studying interacting highly time dependent elementary systems section 
advantages fta system encompassing software hardware system control 
illustrated 

event trees analysis eta 
eta called incident sequence analysis see leveson consequence tree method see chapter 
purpose method identify event sequences potential consequences 
event tree analysis starts called initiating event tree potential consequences depending events 
path root tree initiating event leaf event sequence 
typically safety critical system layers defence order control limit damage due faults system 
sequence combination safety related systems failure typically constitute critical event sequence event tree analysis 

cause consequence diagram method described chapter combination fault tree analysis event tree analysis 

petri nets 
leveson petri nets safety analysis timing constraints 
valuable di erent safety analysis perspectives system stage system development techniques tend rely heavily human judgement foresight 
system safety design hazard identi ed associated risk acceptable task re design system hazard reduced 
leveson lists system design safety options order precedence decreasing desirability standard system safety hazard elimination successful respect hazards means system intrinsically safe 
hazard reduction means reducing frequency hazard expected occur 
hazard control means hazard occur reducing likelihood hazard leading 
examples measures physical barriers fail safe designs see 
damage reduction case occur 
design alternatives complementary exclusive 
standard designations qualitative safety design features see leveson section weinstock section inherently safe intrinsically safe means system capable doing signi cant damage case worst conceivable failure 
system designed way course possible systems safest option system safety critical 
fail safe behaviour means event certain class faults system automatically go safe state 
emphasis safety damage limitation 
continued functionality isnot priority 
technique extensively traditional engineering see terry train vacuum brake mentioned example pipe fails loss vacuum applies brakes 
railway signaling systems designed event failure trains 
example illustrates fail safe mechanisms increases safety reliability 
fail operational fail op behaviour means system designed spite speci ed class faults system able deliver full service 
fault tolerance see section requires form redundancy system 
fail soft behaviour called graceful degradation 
means system event certain faults continue provide service degraded performance reduced functionality order compensate fault cf 
leveson 
see neumann fail soft de ned degradation performance 
de nition fail soft fail op behaviour thing performance included requirements 
noted real systems seldom fail safe fail op 
distinction question scale fail op features tend dominate easily reachable safe state fault occurs ight 
simplicity important design objective promoting safety 
adding performance enhancing features redundancy give fault tolerance kept mind added complexity add failure potential possibly feature reduce 
commonly principle design safety critical systems see weinstock section single point failure criterion 
koch reeves report mandated standards nuclear power plants section railway interlocking 
single point failure criterion means extremely single component failure pose threat system safety 
hazard analysis discover single points failure 
controlling software constitutes single point failure ariane see lions 
pursuing idea single point failure arrive defence depth diversity see bologna taylor koch reeves 
term depth means independent layers protection built system 
addition diversity means di erent layers diverse possible technology development order provide highest level safety 
structure ine ective common mode failures layers 
defence depth diversity common useful design strategy traditional engineering see terry 
particular known nuclear industry 
fault tolerance purpose fault tolerance increase dependability providing system delivers required service degraded version face speci classes faults see appendix de nition dependability related terms 
types faults tolerated example hardware faults hardware design fault software design faults 
fault tolerance means achieving safety class faults tolerated lead safety critical failure 
introductions overviews fault tolerance design fault tolerant systems may randell anderson lee weinstock johnson kelly 
hardware fault tolerance order achieve increased reliability dates back early digital computers see avizienis section 
successful important years ago computer hardware unreliable usually nowadays 
safety critical applications hardware fault tolerance essential example description fault tolerance railway signaling 
fault tolerance achieved adding extra resources redundancy system addition needed non fault tolerant system 
added resources may johnson section hardware redundancy 
physical replication hardware components replicated processors redundant communications additional memory redundant energy supplies 
information redundancy 
examples error detection error correcting codes involving checksums parity 
time redundancy 
extra time allowed possible detect error retry failed computation rollback point 
execution may exactly failed case transient faults tolerated second time computations may done encoding function operands case permanent faults may detected cf 
johnson section 
note di erent executed software redundancy 
software redundancy 
johnson section major forms software redundancy consistency checks capability checks version programming 
information redundancy category commonly included see avizienis kelly 
various combinations redundancy time hardware software discussed avizienis kelly avizienis section ii 
fault tolerance demanding real time system non real time system time redundancy inde nite time fault tolerance required real time systems exactly achieve timing correctness 
watchdog mechanisms real time systems monitor critical processes satisfy timing requirements warn time launch recovery procedure appear case see holding 
distinguishes passive redundancy techniques faults masked called fault masking instance majority voting active techniques faults detected located system recover recon guring remove faulty component 
hybrid techniques combine elements see johnson sections 
words static dynamic passive active respectively see anderson lee burns wellings section 
pointed anderson lee classi cation system employing active passive redundancy depends level abstraction description system error detection compensating action encapsulated system boundary system employs passive static redundancy 
conceptually fault tolerant action consists phases anderson lee 
error detection 

damage con nement assessment 

error recovery 

fault treatment continued system service 
practice distinction phases clear results phases valuable input subsequent phases 
conventional error detection methods provide tolerance hardware degradation test speci anticipated errors 
consequences design faults hardware software easy anticipate 
error detection general criteria system consistency progress 
weinstock categorizes fault tolerance fault arises 
section distinguish hardware fault tolerance measures compensate hardware failure hardware redundancy 
software fault tolerance measures compensate faults software transient fault design fault implementation fault 
system fault tolerance measures compensate faults parts system computer sensor failure presumably faults environment user fault 
fault hardware may physical fault timing fault countered hardware fault tolerance 
contrast hardware design fault countered system fault tolerant measures cf 
weinstock section 
distinguishes random failures systematic failures 
failures occur due degradation hardware constitute rst category failures due faults system life cycle speci cation design implementation maintenance belong second category 
type failures may caused hardware software 
discussed parnas systematic errors particular software errors appear random manifestation failure triggered particular input sequences input sequences random entirely predictable 
faults system may independent assumption random hardware failures 
faults may dependent 
mentions categories reasons faults dependent 
common cause initiators dependencies intercomponent dependencies 
redundancy system provide fault tolerance fault fault cause common mode failure redundant components mechanisms cf 
weinstock section 
chapter deals common cause failures 
particular section contains discussion various analysis methods ctm fta take dependent failure account 
expert judgement needed employing fault tolerance means achieving increased dependability safety 
redundancy added give fault tolerance means manage add system complexity system error prone 
software safety categories techniques combat faults listed section apply equally software fault avoidance 
examples fault avoidance techniques speci cation design phases rigorous formal speci cation structured design methodologies including example structure charts data ow diagrams 
implementation phase structured programming techniques information hiding encapsulation project support tools fault preventing techniques available 
fault elimination detection removal 
examples fault elimination techniques speci cation design phases speci cation validation design review walk throughs 
implementation phase code inspection program analysis testing various levels veri cation may employed 
debugging redesign code correction follow discovery fault 
fault tolerance 
software fault tolerance dealt section 
fault evasion 
example software fault evasion deadlock detection recovery see silberschatz chapter achieved time constraints system 
empirical evaluation various techniques combat faults software leveson 
chapter look speci techniques avoidance elimination tolerance faults software 
mentioning avoidance elimination techniques structured development phase techniques applied software speci cation section design section implementation section 
structuring formalization tools enhances fault avoidance facilitate fault detection removal 
additional fault elimination may take place consequence veri cation see section testing see section 
software fault tolerance described section 
chapter concludes section touches problems demonstrating quantifying certain level software safety achieved employing techniques listed 
consider development process safety critical software section 
safety software development process outline safety process system safety hazard analysis process complete system trace system hazards back software hardware interface 
software hazards identi ed circumstances presence absence certain software outputs safety critical 
negation software hazards software safety requirements software safety constraints 
leveson distinction functionality requirements related safety calls software safety requirements limits operation arising safety considerations calls software safety constraints 
early phases software development shown software safety requirements constraints complete sense unambiguously distinguish desired undesired behaviour see leveson chapter consistent software requirements 
development phases nal software documented veri ed testing preferably formally software safety requirements satis ed 
paradigms disagreement computer science community feasibility separating program safety critical part non safety critical part 
leveson prominent proponent instance writes identify parts software control safety critical operations concentrate safety analysis test orts functions safety critical path leads execution 
parnas argue opposite view article di ers concerned software safety critical applications attempt identify safety separate reliability trustworthiness 
words attempt separate safety critical code code product safety critical application 
experience software exhibits weak link behaviour failures unimportant parts code unexpected repercussions 
discussion viewpoint suggest leveson 
favour keeping safety critical software small simple possible moving functions safety critical computers 
certainly overwhelming complexity large number states tight coupling software compared technologies elaborated section arguments favour point view harder distinguish safety reliability trustworthiness software systems technologies 
surely safer move non critical functions computers possible 
question possible move non critical functions computers bene ts perform speci safety analyzes safety veri cation identi ed safety critical parts code 
argument employing speci safety studies tried tested technique system safety focuses attention safety issues 
quote leveson item recommendation design control software general system safety principles 
disagreement extensive appear rst sight 
clearly need prescribe software reactions faults extreme environments outside scope normally called reliability analysis 
safety requirements concerning situations part requirements implemented code paradigm parnas documented veri ed requirements 
parnas give suggestions thorough software development process discipline standards replace traditional anarchy enjoyed software developers 
suggest series reviews speci stages software development focused speci aspects system development performed independent reviewers possessing specialized knowledge needed stage 
likewise leveson course acknowledge error non safety critical function ect critical functions 
example ariane failure occurred lift due software performing function meaningful lift see lions 
reasonably argued safety critical requirement exception code cause processor halt requirement implemented traced veri ed speci safety procedures recommended leveson 
disagreement safety requirements included veri ed 
need consistent high quality project management personnel methods products code documentation 
disagreement limited pays try identify safety critical parts software employ speci analysis development attention veri cation procedures targeted parts 
standards exist number standards draft standards development life cycle software safety critical systems 
sources bowen place kang chapter 
contributions relating international standards safety critical applications anderson particular devine gives critical commentary way standards written 
usa mil std standard place kang describes system safety requirements department defense dod areas management system design software 
area number required safety analyzes safety related activities listed 
place kang mil std requires contractor perform hazard analysis software levels software requirements top level design detailed design code level 
standard mandate single software development technique rationale standard lists may demonstrating required level safety achieved 
formal proofs requirement standard 
ministry defence mod published draft standard procurement safety critical software mod accompanying standard hazard analysis safety classi cation computer hardware mod identi es comprehensive list analyzes documentation delivered project management software engineering area 
standard requires software requirements speci cation formal software speci cation prepared employing approved formal method 
order demonstrate design conforms formal software speci cation mod requires formal arguments fully formal proofs cases occasionally rigorous argument su cient 
required formal arguments demonstrate code conforms formal design 
furthermore animation executable prototype derived software speci cation mandated 
requirements application formal methods sparked controversy 
mod standard recommends safety critical software decoupled software order minimize size minimizing ort required mod applies safety critical software 
information taken report place kang chapter amore comprehensive overview features standard 
software hazard analysis system hazard analysis see section software veri cation activities software hazard analysis take place software development process cf 
recommendations mil std standard mentioned section 
purpose software hazard analysis sure risk software failing hazardous manner small acceptable case erroneous input adverse environmental uence failure subsystems outside software software errors 
techniques software hazard analysis include code walk throughs cf 
place kang 
software fault tree analysis 
studied leveson workers 
results rst quoted see results analysis guide design software guide placement run time assertions software exception handling redundancy procedures determine runtime conditions fail soft fail safe procedures called facilitate thorough testing pinpointing critical functions test cases 
drawback timing requirements easily analyzed see leveson 
petri net analysis employed leveson 
technique best suited higher level abstractions code 
software failure modes ects analysis software studied 
applied software speci cation software design 
typically bene cial employ techniques di erent strengths weaknesses best suited di erent phases software development 
hazard analysis stages development process called safety veri cation 
speci cation speci cation concerned serve di erent purposes 
distinction requirements speci cation hand system speci cation software speci cation hand cf example sommerville 
formulate clients needs way intelligible client 
normally preclude formal methods 
basis requirements speci cation preliminary design drawn system speci cation formulated development process 
system speci cation may stated formally 
software speci cation part system speci cation concerns software 
stages software development relies correct requirements capture may enhanced prototyping simulation correct hazard enhanced hazard analysis cf 
sections success 
early discovery errors requirements speci cations potentially cost ective 
furthermore errors requirements speci cation safety requirements speci cation remain undiscovered potentially dangerous constitute possible cause common mode failure layers safety mechanisms employed 
notes thirds errors operational software stem incorrect speci cations 
bowen section quotes fraction source 
broad agreement high fraction software errors originating speci cation errors quotes speci project number fraction changes occurring test integration resulted undiscovered requirements design errors inadequacies plausible undiscovered requirements testing errors result software satisfying discovered requirements 
leveson ja section states majority software failures attributed software requirements speci cation 
exact proportion failure causes may disputed clear incorrect incomplete requirements speci cations major source errors 
analysis techniques software speci cations include hazard analysis described sections application formal methods cf 
section 
ja propose number criteria designed reveal inconsistency incompleteness lack robustness ambiguity software speci cations 

propose structuring requirements analysis mission requirements separate safety requirements analysis structured phase concerned external system features real world properties phase internal system components visible 

propose framework requirements analysis parallel safety analysis 
formal methods practical point view formal methods promising way giving increased con dence safety critical systems 
theoretical point view techniques shown provide level safety required applications formal methods cf example moser melliar smith 
potentially promise design implementation errors proving mathematically resulting code conforms software speci cation 
strong feature formal speci cations potential improving system software speci cations 
means communicating detailed information development groups formal speci cations supplemented natural language explain example reasoning chosen model superior natural language speci cations precise unambiguous 
process formulating formal speci cation enhances safety reliability 
process contributes requirements elucidation formality forces speci er assumptions de nitions constraints clear clarify inconsistencies resolve con icts remove ambiguities 
formal speci cation easier realize precise consequence change assumptions including safety critical assumptions regarding environment 
formal method speci cation may contribute safety reliability 
proven formally formal speci cation conforms completely covers informal requirements speci cation methods assessing formal speci cation informal requirements general informal safety requirements particular 
williams mentions groups techniques static analysis 
may involve syntactic analysis deadlock reachability analysis time petri nets safety analysis described leveson 
putative theorem proving 
means proving properties system requirements internal consistency system possess stated formal speci cation way detect example contradictions speci cation extra conditions added 
dynamic analysis executing speci cation way 
may simulation symbolic execution direct execution speci cation 
dynamic analysis provides opportunity client system speci cation 
example procedure hansen 
reviews 
product speci cation process tools speci cation results generated methods may reviewed 
review performed humans error prone proved valuable technique 
exception cases exhaustive dynamic analysis possible techniques prove correctness absence limited class faults 
resulting formal speci cation considerably improved techniques 
formal methods relatively immature quite anumber academics industrial users 
examples real industrial applications formal methods misconceptions formal methods guidance available 
su ciently mature widespread acceptance defensive techniques redundant formal methods guarantee absence speci cation errors hardware errors adverse environmental uence including malicious attacks operator errors furthermore tools supporting development process formal methods tools version management tools underlying software compilers operating systems supporting software databases formally developed ensure theoretical correctness 
naturally formal development error free 
done extensive tool support error free formal development proven di cult error free traditional code development 
kelly software faults particularly signi cant ina real time system timing error detection error recovery interaction concurrency control faults 
features important safety critical systems poorly handled formal methods di cult test cf 
section 
formal methods addressing areas development 
speci cation time timing properties may achieved employing instance duration calculus see ravn real time requirements language rtrl see dasarathy real time logic rtl see jahanian mok timed csp see schneider davies schneider time petri nets see leveson 
time added ways see mcdermid interval logic 
stated mcdermid safety critical systems environment represented explicitly alongside system requirements speci cation model concurrency explicitly 
problem widely speci cation languages vdm cf 
fraser 
problem basic situation better fact distributed implementation safety critical systems 
strengths csp ability specify concurrency 
possibility csp high level speci cation interaction sequential system components simpson provides example speci cation 
overviews discussions formal methods development systems bowen mcdermid 
overview various formal speci cation languages strategies fraser 
industrial formal methods formal methods outside academia interest real projects formal methods contribute safety 
examples industrial indicate chosen formal methods generally practical particular scale projects real life size opposed case studies 
formal methods slowly starting industry safety critical security critical areas documented bowen craigen see accompanying papers 
notable successful examples industrial formal methods formal development method france 
development method speci cation subsequent re nement modula ada code production automatic train protection atp system speed control system switch manager see 
software design design safety critical system brie discussed place kang section 
noted general approaches design formal re nement see section conventional design safety critical applications high quality ought followed formal representation result veri cation design meets speci cation 
structured methods modular design information hiding fairly commonly accepted industry cient safe development strategies see koch reeves section 
obvious bene problem divided smaller units easier design test maintain 
easier divide analysts programmers development teams 
question reuse problematic safety critical applications extent desirable promoted mentioned strategies 
issues identi cation isolation critical parts early design process addressed leveson 
noted previously section issue dispute 
object oriented design section booch distinguishes algorithmic decomposition emphasizes ordering events object oriented decomposition emphasizes objects operated cause actions occur 
naturally object oriented oo design object oriented decomposition 
object oriented design truly design method 
necessarily constrain implementation object oriented considerably easier produce oo implementation oo design direct mapping design entities implementation entities 
survey object oriented design wirfs brock johnson 
object oriented design claimed kinds virtues 
yau tsai states oo design characterized data abstraction program abstraction protection domains 
advantages conventional software design methods authors claim oo design 
productivity abstraction allow construction reusable components 
maintainability information hiding inside software component 
data integrity program security protection domains de ne access rights operations available speci user 
suitable control dominant real time applications implementation implementation safety critical system brie discussed place kang section 
important points importance management general con guration management particular 
obviously essential code analyzed identical code system 
standard compilers assemblers linkers considered correspond quality standard code 
real time facilities guarantee timing constraints real time program met may necessary subset programming language 
instance dynamic data structures linked lists trees graphs typically excluded access time data virtually impossible predict cf 
burns wellings 
reason recursion loops upper bound number iterations may excluded 
furthermore dynamic memory allocation may banned due uncertainty required memory obtainable 
facilities needed ensure real time constraints satis ed listed lin 
real time programming language allows programmers express timing constraints 

compiler checks feasibility timing constraints 

system support run time enforce satisfaction timing constraints suitable scheduler 
object oriented methods structured programming techniques languages include constructs 
counted loops 
probably nowadays universally accepted signi cantly cient certainly terms programmer ort modern compilers terms execution time portable safer way program unstructured programming 
order manage complexity inherent computer applications main techniques viz 
decomposition abstraction see example burns wellings 
techniques supported programming languages concept modules 
module compiled subsequently tested separately gives decomposition 
modula ada strong type checking enforced module ada package boundaries 
contrast example fortran provide type checking merely start address parameters linking subroutines functions 
module provide information hiding burns wellings section means possible permanent variables scopes limited certain modules 
abstracts away variables remaining modules reducing complexity coupling likelihood error 
module supports data types adts increasingly accepted cleanest safest reusable way implement subsystem 
adts programming language constructs support high level data abstraction data type speci ed interface encapsulated operations manipulate observe 
possible access objects data type means 
languages simula euclid clu modula ada support adts 
ers de nition object instance data type encapsulates object data provides user set operations manipulate access object data 
hinted quotation object oriented programming considered adt cf 
example parnas rosen 
commonly accepted terminology language object oriented inheritance 
languages ada modula encapsulation facilities inheritance called object cf 
gopinath 
burns wellings section list properties programming language top adts order object oriented programming language 
inheritance called type extensibility 
means classes types derived classes types 
derivation attributes operations superclass inherited 

automatic object initialization 
means initialization object done automatically constructor routine consequence object declaration adts initialization done explicitly code 

automatic object nalization 
object longer scope destructor routine automatically invoked adts explicit destruction 

polymorphism 
means name operation method lot names operations encapsulated data object refers operations type speci object processed determines operations invoked 
emphasized stroustrup sections example properties possible convenient safe meaning particularly error prone programmer create data abstractions types 
applying object oriented oo development method identify computation entities objects encapsulate data 
objects identi ed entities real imaginary world typically want distribute encapsulated data objects natural units distribution communication takes place de ned form messages cf 
booch 
oo methods suited safety critical realtime applications distributed increasingly 
host advantages oo approach claimed understandability improved global data component reusability fault containment real time systems physical devices modeled naturally objects object model may allow designers address timing performance issues object directly easier improve performance easier port real time oo software modular structure supports team programmers 
gopinath give reasons oo programming real time systems existing oo languages runtime systems unpredictable temporal oo systems perceived ine cient 
due dynamic binding dynamic memory management garbage collection procedures see lin gopinath necessarily part oo programming languages 
debatable oo system easier understand reuse maintain modify inheritance tends give increase coupling comparison function oriented system see lin 
opposite view see booch 
lines rosen raises strong arguments oo languages inheritance argues ada secure safety critical systems 
objections inheritance allow encapsulation order understand class principle understand implementation superclasses implementation class changed ect descendants 
related drawback project develops original inheritance graph distorted need reformulation inheritance structure arises 
course done ect done far 
related feature oo design done bottom cf 
coleman rosen 
inheritance essential obtain bene ts instance object chaos language see gopinath designed real time applications support inheritance 
advantages encapsulation industrial setting railway signaling noted barnard section 
noted need continual adaptation new markets new interfaces increased functionality see barnard section 
veri cation formal methods restricted system speci cation includes requirements elucidation validation veri cation documentation 
formal techniques speci cation veri cation 
convincing demonstration strength formal methods veri cation rushby henke 
formal veri cation recti ed precise series assumptions constraints results synchronization bounds 
automated theorem prover employed probably idea small projects human error veri cation process major problem 
re nement re nement software speci cation code step step veri cation consists series program steps proven satisfy preceding higher abstraction program 
way con dence needed systems 
re nement contain element invention choice automatic process 
construction calculation re nement method idea aiming 
reasons preferring possible re nement non functional requirements performance security 
may act driving force re nement process see mcdermid appendix 
contrast re nement drive re nement process 
raise method called invent verify see 
discussions re nement process mili mcdermid appendix 
re nement data re nement operation re nement called functional algorithmic 
data re nement treated morgan gardiner 
re nement programs real time constraints may special di culties addressed eld 
presents framework explicitly representing real time successive re nements 
re nement real time systems dealt kurki 
testing spite phrases provably correct programs provably correct systems jifeng project testing indispensable part software development project 
reason partly currently available formal method able handle interfacing problems timing aspects interfaces hardware partly necessary validate program conforms user requirements validate programmer understanding system speci cation 
testing reveal errors formal veri cation example see 
cases possible test paths industrial program koch reeves section refer examples nuclear power plant safety software 
generally feasible range testing techniques employed 
testing real time programs gives rise particular di culties cf 
levi agrawala see 
impossible test possible sequences timings input events inclusion interrupts asynchronous features system compounds problem cf 
leveson 
concurrency feature presents problems testing methodologies 
added bene diverse designs form recovery block software form version software see section kelly mentions back testing automated testing procedure comparison results diverse software 
method provide extensive test coverage require tester determine correct output test cases saves time means coincident failures discovered 
software fault tolerance history software fault tolerance long successful hardware fault tolerance 
primary purpose fault tolerant software compensate software design interfacing faults 
software redundancy techniques principal forms exist forward backward error recovery 
backward error recovery involves attempt return system state consistent previous error free state execution may proceed forward error recovery involves attempt construct new valid error free state see kelly liu joseph section leveson 
fail safe behaviour see section may seen forward error recovery technique 
common approaches software fault tolerance kelly recovery block 
backward error recovery technique 
recovery block block software 
execution recovery point established means current state saved 
recovery block executed 
resulting state subjected acceptance test 
error detected rollback saved state performed alternate version recovery block executed 
result subjected acceptance test acceptance test passed alternate versions exhausted 
possible version recovery block case transient errors tolerated 
multiversion software 
forward error recovery technique 
term programming probably commonly term multiversion software appropriate approach involves diverse implementations diversity speci cation design testing 
say developed codes supplied consistent input executed 
result determined majority vote safer consensus 
necessary common result fed back erroneous processes order adjust internal state calculation recon guration possibility 
system current input determines output fault judged transient multiversion software employ purely passive redundancy technique error detection recovery 
discussion various error recovery strategies see kelly 
comprehensive accounts recovery block software multiversion software kelly burns wellings chapter 
contains comparison version programming recovery blocks approaches software fault tolerance 
avizienis discusses problems implementation software recovery failed versions may necessary particularly safety critical applications 
added mcdermid states current speci cation languages de ned ways handling faults fault tolerance area research undertaken re nement rules deal adequately fault tolerance 
clearly success recovery block method depends crucially success error recovery processes 
development recovery processes safety critical real time systems challenging task addressed lutz wong 
bene ts multiversion software debated issue 
knight leveson gives summary discussions version programming safety critical applications provides useful 
successful experiments diverse software reported avizienis kelly 
article knight leveson response 
reports experiment casts doubt assumption underlying version programming programs developed independently fail independently 
obvious cause failure common points speci cations may common common origin erroneous ambiguous easily misunderstood particular points 
boundary points zero crossings candidates common failure independently developed programs course inherently di cult part problem 
reservations independent failure version programs supported butler 
littlewood miller argued forced diversity methodologies decrease probability simultaneous failure versions 
authors urge exercise great caution especially safety critical applications speci system reliability presently guaranteed basis forced diversity development methodologies 
exist real life application version programming swedish interlocking train control systems account lindeberg 
run time checking exception occurrence error de ned appendix execution program cf 
burns wellings section 
exception handling seen forward error recovery 
normal default exception handling action terminate application program 
appropriate error recovery point view underlying computer software may appropriate point surrounding system 
exceptions trapped handled appropriately agreement de ned error recovery strategy system level analysis 
exceptions raised consequence violations connection built operations programming language possible raise exceptions consequence explicit runtime checks inserted code see place kang section 
technique demanding programmer ort processing time considerably judgement selection placement run time assertions probably needed 
experiments leveson run time assertions prove successful detecting errors 
ada programming languages constructs exception handling see schonberg 
support exception handling application code tends cumbersome ad hoc see sommerville section 
exceptions inserted code possible provide run time checking higher module program level called monitor see place kang section 
quantitative evaluations safety achieving level safety software system problem 
problem demonstrating required level safety achieved 
notoriously di cult quantify reliability probably impossible quantify safety 
discussion see littlewood 
di culties quantifying safety reliability matter illustrated cited estimates safety railway signaling system di ers orders magnitude 
safety critical systems reliability targets common philosophy parnas cf 
section 
quoted gure federal aviation authority faa potentially catastrophic failure condition 
see leveson 
possible achieve con dence failure probability conventional testing methods amount testing required large feasible cf 
butler weinstock section 
con dence software safety critical systems built con dence software engineering methods con dence personnel con dence management assurance formal methods testing 
surveyed state art system safety respect inclusion software safety critical systems 
presentation part dissertation information safety supervisors may 
hoped survey bene considering software safety critical systems highlighting issues appropriate approaches considered development critical applications 
line information virtual library safety critical systems section www comlab ox ac uk archive safety html 
abrial 
book assigning programs meanings 
cambridge university press 
anderson barrett 
software fault tolerance evaluation 
ieee trans 
software engineering december 
anderson lee 
fault tolerance principles practice 
prentice hall international 
avizienis 
version approach fault tolerant software 
ieee trans 
software engineering december 
avizienis kelly 
fault tolerance design diversity concepts experiments 
computer august 
barnard 
tool support application speci language 
anderson editors directions safety critical systems pages 
springer verlag 
mcdermid 
formal methods relevance development safety critical systems 
computer journal 
bell 
iec draft international standard functional safety current position 
high integrity systems 
bell reinert 
risk system integrity concepts safety related control systems 
anderson editors safety critical systems current issues techniques standards pages 
chapman hall 
bennett 
real time computer control 
prentice hall international second edition 
dick woods 
quantitative analysis application formal methods 

gaudel woodcock editors fme bene advances formal methods volume lecture notes computer science pages 
springer verlag 
gopinath 
object oriented real time systems concepts examples 
ieee computer december 
bologna taylor 
software safety system safety 
editor th international conference computer safety reliability security pages anaheim california october 
instrument society america 
booch 
object oriented analysis design applications 
benjamin cummings publishing second edition 
bowen 
formal methods safety critical standards 
proc 
software engineering standards symposium sess brighton uk pages 
ieee computer society press august september 
bowen editor 
veri ed systems volume real time safety critical systems 
elsevier 
bowen 
formal speci cation documentation case study approach 
international thomson computer press 
international thomson publishing 
bowen butler dill glass gries hall hinchey holloway jackson jones lutz parnas rushby wing zave 
invitation formal methods 
ieee computer april 
bowen hinchey 
formal methods safety critical standards 
ieee computer august 
bowen hinchey 
myths formal methods 
ieee software 
bowen hinchey 
formal methods 
ieee computer april 
bowen hoare langmaack 
olderog ravn 
ii project nal report esprit basic research project 
bulletin european association theoretical computer science eatcs june 
bowen 
safety critical systems formal methods standards 
iee bcs software engineering journal july 
je control failures involving control systems 
high integrity systems 
goble 
extended beta model quantize ects common cause 
editor th international conference computer safety reliability security pages anaheim california october 
instrument society america 
burns wellings 
real time systems programming languages 
addison wesley 
butler 
infeasibility quantifying reliability life critical real time software 
ieee trans 
software engineering january 
coleman hayes bear 
introducing statecharts object oriented design 
ieee trans 
software engineering january 
mcdermid 
specifying temporal requirements distributed real time systems computer science report department computer science university york uk 
craigen gerhart ralston 
case study darlington nuclear generating station 
ieee software january 
craigen gerhart ralston 
case study tra alert system 
ieee software january 
craigen gerhart ralston 
formal methods reality check industrial usage 
ieee trans 
software engineering february 

solid state interlocking ssi integrated electronic signalling system 
iee proceedings pt 
may 
dasarathy 
timing constraints real time systems constructs expressing methods validating 
ieee trans 
software engineering january 
davies 
safety medical robots 
anderson editors safety critical systems current issues techniques standards pages 
chapman hall 
davies schneider 
real time csp 
rus rattray editors theories experiences real time system development pages 
world scienti publishing 
de anderson 
train set case study requirements analysis safety critical systems 
computer journal 
de anderson 
safety analysis requirements speci cations 
editor th international conference computer safety reliability security pages anaheim california october 
instrument society america 

formal methods signalling industry 
editors fme industrial bene formal methods volume lecture notes computer science pages 
springer verlag 
devine fenton page 
de ciencies existing software standards exposed 
anderson editors safety critical systems current issues techniques standards pages 
chapman hall 
dillon 
verifying general safety properties ada tasking programs 
ieee trans 
software engineering january 

application studies integrated requirements models control systems 
editor th international conference computer safety reliability security pages anaheim california october 
instrument society america 

adding real time formal program development 
editors fme industrial bene formal methods volume lecture notes computer science pages 
springer verlag 
higgins mcdermid 
sam tool support construction review evolution safety arguments 
anderson editors directions safety critical systems pages 
springer verlag 
fraser kumar 
strategies incorporating formal speci cations software development 
communications acm october 

risk assessment computer controlled systems 
ieee trans 
software engineering january 
gerhart craigen ralston 
case study multinet gateway system 
ieee software january 
gerhart craigen ralston 
case study paris metro signaling system 
ieee software january 
gerhart craigen ralston 
experience formal methods critical systems 
ieee software january 
hansen 
validation model 
editors fme industrial bene formal methods volume lecture notes computer science pages 
springer verlag 
pedersen 
raise overview 
technical report raise cri doc cri denmark august 
jifeng hoare muller 
olderog hansen ravn rischel 
provably correct systems 
langmaack 
editors formal techniques real time fault tolerant systems volume lecture notes computer science pages 
springer verlag 
weinstock 
conceptual framework system fault tolerance 
technical report cmu sei tr esc tr software engineering institute carnegie mellon university pittsburgh usa 

reliability engineering risk assessment 
prentice hall 
hinchey bowen editors 
applications formal methods 
prentice hall international series computer science 
hoare 
software get reliable proof 

gaudel woodcock editors fme industrial bene advances formal methods volume lecture notes computer science pages 
springer verlag 
holding 
software fault tolerance 
warwick tham editors failsafe control systems applications emergency management 
chapman hall 

concept time speci cation real time systems 
editor real time systems abstractions languages design methodologies pages 
ieee computer society press 

safety critical systems supervisors 
dissertation sc 
engineering information systems department computer science university reading po box reading rg ay uk 
ja leveson heimdahl 
software requirements analysis real time process control systems 
ieee trans 
software engineering march 
jahanian 
mok 
safety analysis timing properties real time systems 
ieee trans 
software engineering september 

functional re nement nested objects object oriented design 
ieee trans 
software engineering march 
buckley 
safe road transport systems 
anderson editors safety critical systems current issues techniques standards pages 
chapman hall 
johnson 
design analysis fault tolerant digital systems 
addison wesley publishing 
kelly yamamoto 
implementing design diversity achieve fault tolerance 
ieee software pages july 
knight littlewood 
critical task writing dependable software 
ieee software january 
knight leveson 
experimental evaluation assumption independence multiversion programming 
ieee trans 
software engineering january 
koch reeves 
software safety applications commercial nuclear power plants 
editor th international conference computer safety reliability security pages anaheim california october 
instrument society america 
kurki 
stepwise design real time systems 
ieee trans 
software engineering january 
leveson 
murphy expecting worst preparing 
proc 
ieee compcon washington pages new york september 
ieee 
leveson 
software safety 
computing surveys june 
leveson 
software safety embedded computer systems 
communications acm february 
leveson 
system safety computers 
addison wesley publishing 
leveson cha 
safety veri cation ada programs software fault trees 
ieee software pages july 
leveson harvey 
analyzing software safety 
ieee trans 
software engineering september 
leveson 
safety analysis petri nets 
ieee trans 
software engineering march 
leveson turner 
investigation accidents 
ieee computer july 
levi agrawala 
real time system design 
mcgraw hill 

lin 
issues real time systems programming language compiler object orientation 
son editor advances real time systems pages 
prentice hall 
lindeberg 
swedish state experience version programmed systems 
anderson editors directions safety critical systems pages 
springer verlag 
littlewood miller 
conceptual modeling coincident failures multiversion software 
ieee trans 
software engineering december 
littlewood 
risks software 
scienti american pages november 
liu joseph 
transformation programs fault tolerance 
formal aspects computing 
lutz wong 
detecting unsafe error recovery schedules 
ieee trans 
software engineering august 
lyons 
ariane failure 
www esa press press ariane rep html july 
manna pnueli 
models reactivity 
acta informatica 
mcdermid 
assurance high integrity software 
editor software pages 
pitman 
mcdermid 
issues development safety critical systems 
anderson editors safety critical systems current issues techniques standards pages 
chapman hall 
mcdermid 
dependability measurement management 
high integrity systems 

bridge 
high integrity systems 
mili desharnais 
formal models stepwise re nement programs 
acm computing surveys september 

tsai elliott 
retro tting software safety medical device 
ieee software january 
morgan gardiner 
data re calculation 
acta informatica 
moser melliar smith 
formal veri cation safety critical systems 
software practice experience august 

designing high integrity software fault tolerance approach 
editor high integrity software pages 
pitman 
neumann 
hierarchical design computer systems critical 
ieee trans 
software engineering september 
neumann 
computer related risks 
addison wesley publishing 

re nement realtime programming 
proc 
seventh euromicro workshop real time systems pages 
ieee computer society press 

realtime systems 
prentice hall international series computer science 
appear 
connor 
practical reliability engineering 
john wiley sons second edition 
parnas 
documentation computerised safety systems nuclear power stations 
technical report info atomic energy control board ottawa canada 
parnas madey 
assessment safety critical software nuclear power plants 
nuclear safety 
parnas van shu 
evaluation safety critical software 
communications acm 
place kang 
safety critical software status report annotated bibliography 
technical report cmu sei tr esc tr software engineering institute carnegie mellon university pittsburgh usa june 
iii johnson 
safety critical systems built cots 
ieee computer november 
randell 
system structure software fault tolerance 
ieee trans 
software engineering june 
ravn rischel hansen 
specifying verifying requirements real time systems 
ieee trans 
software engineering january 
anderson editors 
safety critical systems current issues techniques standards 
chapman hall 

software failure modes ects analysis 
ieee trans 
reliability august 
rosen 
orientation ada objects take 
communications acm november 
rushby von henke 
formal veri cation algorithms critical systems 
ieee trans 
software engineering january 
de anderson 
robust requirements speci cation safety critical systems 
editor th international conference computer safety reliability security pages poznan poland october 
springer verlag 
schneider davies jackson reed reed roscoe 
timed csp theory practice 
de bakker huizing rozenberg editors real time theory practice volume lecture notes computer science pages 
springer verlag 
eld jifeng 
speci cation oriented semantics re nement real time systems 
technical report department computer science university york uk 
schonberg hayden 
technical tour ada 
communications acm november 
shankar 
assertional reasoning concurrent systems 
acm computing surveys september 
leveson 
empirical comparison software fault tolerance fault elimination 
ieee trans 
software engineering february 
silberschatz peterson 
operating system concepts 
addison wesley publishing third edition 
simpson 
formal speci cation automatic train protection system 
editors fme industrial bene formal methods volume lecture notes computer science pages 
springer verlag 
sommerville editor 
software engineering 
addison wesley fourth edition 
stroustrup 
programming language 
addison wesley publishing second edition 
terry 
engineering system safety 
mechanical engineering publications london 

reliability availability maintainability safety assessment 
john wiley sons 
williams 
assessment safety critical speci cations 
ieee software january 
wirfs brock johnson 
surveying current research object oriented design 
communications acm september 
yau 
tsai 
survey software design techniques 
ieee trans 
software engineering 
appendix basic terminology systems various kind systems frequently encountered literature 
de nitions may summarized follows system collection components typically mechanical parts computer hardware computer software combined order deliver speci ed service 
aircraft example system 
system users provides service operators interacts concerning operational issues 
interaction may essential correct operation system operators may considered part system weinstock 
instances users operators may people 
di erent compatible description meaning word system section 
real time system system satisfy timing constraints deadlines 
real time computer systems necessarily fast point time timing properties predictable assert timing correctness addition logical correctness 
distinguishes hard real time systems non satisfaction timing requirement considered total system failure soft real time systems occasional acceptable 
burns wellings note distinction hard deadline 
bennett additional categorization real time systems said clock event interactive 
bennett adds real time systems contain mixture activities classi ed clock event interactive hard soft time constraints 
embedded system system computer software part larger system process controlled manufacturing plant missile medical apparatus transportation system ship aircraft train spacecraft parts sensors actuators computer interact rest system see section 
embedded system execute environment program development going 
safety critical system system malfunction may cause death serious injury extensive damage property environment 
authors include categories 
high integrity system system level guaranteed includes safety critical systems commercial systems banking systems see 
transformational system system input available start execution principle output provided execution 
ect system described relation input output 
reactive system responds external events 
contrast transformational system input output passed execution 
sequence absolute time event occurrences important 
manna pnueli term reactive system disagreement di erent emphasis 
description non transformational systems levels decreasing abstraction distinguished reactive systems temporal precedence captured 
real time systems metric aspect time time distance events duration captured 
hybrid systems continuous functions time represented 
abstraction layers manna pnueli presents computational model speci cation language temporal logic 
additionally system description languages proof rules examples provided 
real time systems usually reactive may non terminating intended continuous operation 
safety critical systems real time reactive systems 
properties de nitions system properties primarily johnson section section availability probability system perform correctly deliver required service speci ed environment speci ed instant time 
reliability probability system perform correctly deliver required service speci ed environment time interval assuming system performing correctly start interval 
reliability measure continuity service system 
trustworthiness probability serious design implementation considered low level design error exists system see parnas 
performability probability system performance speci ed level speci ed instant time 
exist failure modes ect system functions typical distributed system essential resources replicated performability di ers reliability reliability probability system functions performed correctly performability probability subset functions performed correctly 
maintainability probability maintenance system performed conditions stated procedures resources completed speci ed period time 
maintenance may preventive maintenance includes restoring failed system operational state 
testability measure ease tests system performed see johnson 
safety freedom accidents losses see leveson 
virtually completely safe possible de ne safety degree freedom accidents losses probability system cause accidents losses see discussion leveson book 
de nition safety depends probability system cause conditions lead accident hazards probability occurrence environmental conditions hazard lead accident 
security probability system preserves con dentiality allow malicious interference 
means probability unauthorized access intruders authorized users parts system user system data occurs 
guards user privacy system privacy protecting denial services cf 
neumann 
large selection security problems covered neumann book chapter 
safety integrity probability safety related system performs required safety functions necessarily functions stated environmental conditions speci ed period time cf 
je bell 
random systematic contribution safety integrity see bell reinert hardware integrity relates random hardware failures 
systematic integrity relates speci cation design errors software implementation errors software common cause faults 
general reliability availability properties listed functions time cf 
section 
obvious concepts distinct de nitions related dependent discussed place kang section 
example low security imply non authorized access system components may occur constitute threat safety 
system properties loosely de ned robustness de ned property system remains predictable environment deviates speci cation part system fails 
dependability broad term describing quality service provided system 
weinstock section section dependability encompasses availability reliability performability maintainability testability safety security 
leveson de nes dependability reliability safety security de ned correctness robustness permanent readiness 
integrity roughly dependability 
neumann de nes system integrity correctness consistency system data data integrity correctness consistency data including user data 
way dependability quanti ed obvious diverse properties safety availability combined 
mcdermid suggests way doing concepts loss risk 
noted parts computing literature see dillon manna pnueli term safety safety property meaning opposed progress liveness progress property 
citing shankar section informally safety assertion states bad happen variable exceeds progress assertion states eventually happen eventually progress assertions referred liveness assertions 
failures errors faults literature disagreement precise meaning words fault error failure 
avizienis kelly johnson section section weinstock section suggest de nitions 
characteristically entirely compatible capture degree common understanding concepts literature general see lutz wong 
failure 
event system subsystem component exhibit expected external behaviour 
expected system behaviour environmental conditions exhibited documented requirements speci cation 
explicit speci cation complete possible may consider implicit speci cation stating system behave aswell reasonable person expect experience similar systems world general weinstock 
error 
incorrect internal system state 
fault 
fault cause error 
fault may defect hardware aw software incorrect operator input 
presentation follows avizienis kelly johnson fault may may cause error error may may cause failure 
faults may classi ed origin 
possible categories see leveson harvey johnson section system speci cation faults hardware software occurring pre operationally maintenance 
system design faults hardware software occurring pre operationally maintenance 
environmental faults human mistake misunderstanding operation failure underlying supporting software electromagnetic interference radiation physical damage system extreme temperature power failure 
hardware computer sensor actuator faults software implementation coding faults 
interfacing problems 
includes problems interface separate software modules software controlled devices processes software computer hardware man machine includes timing problems synchronization problems deadlock 
security violation faults errors arise deliberate malicious attempts interfere system operation 
useful classi cations see weinstock section 
origin cause fault may determined ways discussed weinstock sections 
weinstock disputes need term error 
claim di cult give unambiguous criteria distinguishing faults errors errors failures arguments su ciently convincing 
furthermore weinstock consider fault failure component internal external 
consequence level abstraction boundary system environment determine particular incident characterized fault failure 
alternative de nition concepts merits extent de nitions relies particular level abstraction de nition system boundary 
sections gives set de nitions failure fault ones electrotechnical engineering community 
states failure termination ability perform required function fault inability entity perform required function appearance fault constitutes failure fault result failure 
safety concepts order obtain kind generic way deal safety helpful reasonably precise terminology accident 
traditionally safety engineers de ned accident unexpected release energy cf 
leveson 
book leveson de nes accident undesired unplanned necessarily unexpected event results speci ed level loss 

term introduced cover unplanned events results loss human life injuries damage environmental property 
includes accidents harmful exposures cf 
leveson 
hazard 
system state certain environmental conditions lead see leveson 
hazard potentially dangerous situation word danger everyday language roughly meaning see 
de nition hazard leveson states hazard certain environmental conditions lead inevitably 
appears subsequent discussion mixtures ignition sources inevitability may question de nition 
risk 
risk associated certain hazard depends probability hazard occurring duration hazard occur probability hazard leading severity worst result hazard see leveson 
loosely risk depends probability potential possible consequences 
dependent common cause failures 
chapter 
goble hardware common mode analysis techniques help minimize dependent failure modes cf 
leveson 
safety constraint 
hazard characterizes system state safety reasons occur 
negated safety margins included get safety constraint description property system possess order safe see section leveson column 
leveson argues safety de ned terms hazards risk terms catastrophic events factors system environment contribute 
similarly may due factors outside control system situation system proved unsafe 
de ne system safety terms hazards risks focus attention inside design space system 

