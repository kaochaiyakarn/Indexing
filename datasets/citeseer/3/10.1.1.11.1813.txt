integrating generations advanced counting garbage collectors erez petrank ibm haifa research labs haifa university campus mount carmel haifa israel cs technion ac il dept computer science technion israel institute technology haifa israel erez cs technion ac il 
study incorporation generations modern counting collector 
start collectors suggested levanoni petrank counting collector tracing mark sweep collector 
propose designs combining counting collector collects young generation old generation 
designs maintain properties levanoni petrank collector 
particular adequate multithreaded environment multiprocessor platform ecient write barrier synchronization operations 
best knowledge generations counting tried 
implemented algorithms jikes jvm compared concurrent counting collector supplied jikes package 
expected best combination lets tracing collector young generation objects die counting old generation objects survive 
matching expected survival rate nature collector yields large improvement throughput maintaining pause times couple milliseconds 
keywords runtime systems memory management garbage collection generational garbage collection 
automatic memory management acknowledged important tool fast development large reliable software 
turns garbage collection process important impact runtime performance 
clever design ecient memory management garbage collection important goal today technology 
counting counting intuitive method automatic storage management known sixties 
main idea keep object count number object 
number zero object know reclaimed 
counting promising garbage collected systems especially spread bit architectures increase usage large heaps 
tracing collectors traverse live objects bigger usage heap amount live objects heap collector perform 
counting di erent 
amount proportional amount done user program collections plus amount space reclaimed 
depend space consumed live objects heap 
historically study concurrent counting modern multithreaded environments multiprocessor platforms extensive thorough study concurrent parallel tracing collectors 
seen studies implementations modern counting algorithms modern platforms building improving previous 
bacon levanoni petrank detreville counting algorithms overcome concurrency problems counting 
levanoni petrank completely eliminated need synchronization operations write barrier 
addition algorithm levanoni petrank drastically reduces number counter updates common benchmarks 
automatic memory management multiprocessor concentrate garbage collection multiprocessor machines 
multiprocessor platforms quite standard server machines gain popularity high performance desktop machines 
studied garbage collection algorithms suitable multiprocessors 
particular collectors run single thread program threads stopped called world concept 
causes bad processor utilization hinders scalability 
order better multiprocessor concurrent collectors studied see example 
concurrent collector collector collection concurrently program stopping program threads 
concurrent collectors need program threads point collection order initiate nish collection time mutators halt short 
collectors program threads simultaneously 
thread cooperates collector pace mechanism called soft handshakes 
collectors especially useful systems stopping threads synchronization relatively long costly 
generational collection generational garbage collection introduced lieberman hewitt rst published implementation ungar 
generational garbage collectors rely assumption objects die young 
heap partitioned parts young generation old generation 
new objects allocated young generation collected frequently 
young objects survive collections promoted older generation 
generational assumption objects die young correct get advantages 
pauses collection young generation short collections ecient concentrate young part heap expect nd high percentage garbage nally working set size smaller program repeatedly reuses young area collector collections trace smaller portion heap 
discuss collector expect see reduction pause time extremely low 
goal keep low pauses original algorithm 
increased eciency better locality may give better collection time better throughput 
achieve 
study generational collection interacts counting 
furthermore employ modern counting algorithm adequate running modern environment multithreaded modern platform multiprocessor study alternative uses counting generations 
rst young old generations collected counting 
second young generation collected counting collector old generation mark sweep collector 
alternative explore counting collect old generation mark sweep collect young generation 
building blocks levanoni petrank sliding view collectors counting collector mark sweep collector 
new generational collectors employ write barrier uses synchronization operation original collectors 
note combination expected win race 
normally percent objects survive small young generation high old generation 
looking complexity involved algorithms counting complexity related number dead objects 
matches death rate old generation 
tracing collectors better objects die match death rate young generation 
combination employing tracing young generation counting old yields best results 
second combination uses counting collect young generation tracing full heap collection 
advantage combination important keep count accurate 
simple promotion policy surviving young object promoted know young collection young object count zero higher 
inaccuracy exact value counting ect collections object promoted handled tracing collector 
eliminate counting young objects hand hand spare tracing collector short lived objects collected counting collector 
addition new study generations counting interesting attempt run generations collector 
aware uses generations collector kolodner petrank generational collection moving objects usually garbage collectors move objects cost moving objects running concurrently program threads high 
demers generational collector move objects 
motivation adapt generations conservative garbage collection 
exploit ideas partitioning heap physically keeping young objects separate area partition heap logically 
object keep bit indicating young old 
implementation results implemented algorithm jikes research java virtual machine version linux red hat 
entire system including collector written java extended unsafe primitives access raw memory 
taken measurements way ibm net nity server mhz intel pentium iii xeon processor gb physical memory 
benchmarks specjvm benchmark suite specjbb benchmark 
benchmarks described detail spec web site 
section report measurements ran collectors 
tested new collectors jikes concurrent collector distributed jikes research java virtual machine package 
collector counting concurrent collector developed ibm reported bacon 
ecient collector uses counting old generation achieves excellent performance measures 
throughput improved specjbb benchmark 
pauses smaller 
results hold default heap size benchmarks 
running collectors tight heaps show generational collector suitable small heaps 
conditions original jikes algorithm performs better 
partial incorporation generations collector immutable objects doligez leroy gonthier 
scheme depends fact objects ml immutable 
true java imperative languages 
furthermore collection young generation concurrent 
thread private young generation immutable objects collected thread stopped 
cycle collection major disadvantage counting collect cycles 
case old generation collected mark sweep collector issue cycles collected 
counting old generation mark sweep collector seldom collect full heap reclaim garbage cycles 
organization section review counting developments years mention related 
section levanoni petrank collectors build 
section generational algorithms 
section discuss implementation section measurements 
conclude section 
overview counting algorithms traditional method counting rst developed lisp collins 
idea keep count eld object telling exist object 
pointer updated system invokes write barrier keeps counts updated 
particular pointer modi ed pointing pointing write barrier decrements count increments count counter object decreased zero reclaimed 
counts predecessors decremented reclamation may continue recursively 
simple method smalltalk awk perl programs 
improvements naive algorithm suggested subsequent papers 
studied delay introduced recursive deletion 
works single bit counter mechanism handle ows 
idea objects singly referenced duration short transitions 
deutsch bobrow noted overhead counter updates originates frequent updates local stack registers 
suggested write barrier pointers heap 
count decreases zero object reclaimed may reachable local 
collect objects collection invoked 
collection reclaim objects zero heap count accessible local 
method called deferred counting yields great saving write barrier overhead 
modern counting collectors 
particular method adapted modula 
study reducing local variables 
counting intrinsic problem multithreading 
updates counters done concurrently threads updates atomic 
synchronization operation write barrier costly 
problematic issue fact user program allows races collector may fail operate correctly 
example suppose thread executes concurrently executes suppose operations started concurrently pointed object naive write barrier threads start reading old value decrement count 
read referenced object 
perform assignment 
due race assignment prevails 
decrement counter old object increment counter new 
reduce count increment counts note counters wrong 
count decremented twice wrong pointer moved second counters incremented obtained new 
rst system counting multithreaded environment detreville 
described concurrent multiprocessor counting collector modula 
detreville algorithm adopted deutsch bobrow ideas deferred counting added idea local transaction log 
thread records modi cations local transaction log requires synchronization 
collection collector uses transaction logs update counters 
eliminates races counts collector modi es leaves problem program races 
solve detreville single central lock update operation heap 
implies single update occur simultaneously system placing hard bound scalability 
fischer proposed collection method counting architectures support explicit multi threading processor level 
bacon reduced need central lock suggested compare 
improvement naive approach require compare swap 
compare swap actual update locally log transaction local transaction log 
main idea decrements counters immediately executed delayed collection cycle correctness insured cost oating garbage 
concurrently bacon levanoni petrank counting collector completely eliminated need synchronization operation write barrier 
levanoni petrank build deutsch bobrow detreville deferred counting local transaction bu ers 
suggest carefully designed write barrier careful analysis showing program races overcome need synchronization 
write barrier program race result multiple copies transactions write barrier counts 
collector easily overcome multiple records transaction bu ers 
addition improvement synchronization levanoni petrank signi cant reduction overhead transaction logging counter updates 
consider pointer slot garbage collections assigned values previous counting collectors execute updates counts assignments rc rc rc rc 
rc 
required rc rc 
furthermore modern collectors program threads log updates transaction bu er transaction needs logged collectors log transactions 
measurements shown improvement reduces number logs counter updates factor standard java benchmarks 
levanoni petrank collectors section provide short overview levanoni petrank collectors 
adopt convention adding asterisk line code di ers original collector 
full algorithm described original 
sliding view counting algorithm levanoni petrank collectors computing di erences heap snapshots 
algorithms operate cycles 
cycle begins collection ends 
describe collector actions cycle write barrier mutators record heap objects pointer slots modi ed cycle recorded information address modi ed object values object pointer slots current modi cation 
dirty ag record kept modi ed object 
analysis shows seldom races may cause record created object records contain essentially information 
records written local bu er synchronization 
dirty ag implemented pointer null ag clear pointer logp logging location local bu er ag set 
pseudo code appears gure ignore lines asterisk numbers 
created objects marked dirty creation gure 
need record slots values null creation time previous collection 
objects referenced slots collection noted counts incremented 
collection begins sliding view heap gures 
essentially non atomic snapshot heap 
obtained incrementally mutators stopped simultaneously 
snooping mechanism ensure sliding view heap confuse collector reclaiming live objects view read heap write barrier mark object assigned new heap 
objects marked snooped ascribing threads local bu er snooped preventing collected collection cycle mistakenly 
getting details levanoni petrank collector employs handshakes see gures collection cycle 
collection starts collector raising snoop ag thread signaling mutators start computing sliding view gure 
rst handshake mutator local bu ers retrieved cleared 
objects listed bu ers exactly objects changed cycle 
dirty ags objects listed bu ers cleared mutators running gure 
step may clear dirty marks concurrently set running mutators 
logging threads local bu ers order keep dirty bits set second handshake gure 
third handshake carried assure reinforcement visible mutators 
fourth handshake threads local states scanned objects directly reachable roots marked roots gure 
fourth handshake collector proceeds adjust rc elds due differences sliding views previous current cycle gure 
object logged mutator local bu ers modi ed previous collection cycle need decrement rc slots values previous sliding view increment rc slots values current 
rc decrement operation modi ed object done objects replica retrieved local bu ers 
object replica contains object slots value time previous sliding view taken 
rc increment operation modi ed object complicated mutators change current sliding view values object slots collector tries increment rc eld 
race solved replica object adjusted committing 
check object dirty ag logp set 
set points committed replica taken mutator object slots time current sliding view taken 
take temporary replica object commit checking object dirty ag set 
committed replica contains object slots value time current sliding view taken increment rc object slots value 
dirty ag set replica pointed set dirty ag order adjust rc object slots 
collection cycle ends reclamation recursively free object zero rc eld marked local gure 
sliding view tracing algorithm snapshot mark sweep collectors exploit fact garbage object remains garbage collector 
garbage stable property 
levanoni petrank sliding view tracing collector takes idea snapshot logical step show possible trace sweep sliding view 
collector computes sliding view exactly previous counting algorithm see gures 
mark roots stage collector starts tracing sliding view associated cycle gures 
need trace object collector tries determine value sliding view done previous algorithm checking object logp dirty ag set 
set object slot sliding view value directly committed mutator replica pointed object logp 
set temporary replica object taken committed checking object dirty ag set 
replica committed collector continues tracing object replica 
collector proceeds reclaim garbage objects sweeping heap gure 
algorithm infer object garbage allocated prior fourth handshake 
thread local variable denoted holds color thread assign color eld newly allocated objects 
variable toggled colors black white 
sweeping collector considers object heap 
object black retained 
colored blue ignored 
object white 
case collector reclaims object coloring blue passing back allocator 
sweeping heap contains black blue objects object white turned blue mutators color newly allocated objects black 
starting tracing cycle collector toggles values black white variables objects allocated prior cycle fourth handshake considered unmarked reclaimed garbage 
generational collectors section describe collectors designed 
winning collector performance outweigh 
described section 
go discussing issues common algorithms 
generational mechanism simple 
young generation holds objects allocated previous collection object survives young full collection immediately promoted old generation 
naive promotion policy ts nicely algorithms 
generations segregated heap move objects heap 
order quickly determine object young old keep bitmap bit bytes telling objects old 
objects created young promotion modi es bit 
recall levanoni petrank sliding view collectors basis 
sliding view algorithm uses dirty ag object tell modi ed previous collection 
modi ed objects kept updates bu er rc elds objects referenced objects slots updated collector 
naive promotion policy may bu ers remembered set young generation contains objects created collection follows intergenerational pointers may located pointer slots modi ed collection 
write barrier remains original algorithm 
write barrier appears 
slight modi cation discussed subsection 
issue notice collecting possible address object reclaimed appears updates bu er 
may happen collector run concurrently mutators mutators stopped collection 
rare case happens decided invalidate logged object collection deal adjustments 
invalidating object log entry continue reclaim 
counting full collection describe algorithm worked best counting full collections tracing mark sweep minor collections 
provide overview algorithms designed uses counting minor collections uses counting minor full collections 
algorithm doing best algorithms generally outweigh original algorithm levanoni petrank collector bacon benchmarks 
simple promotion policy discussed section 
fully explain minor full collections 
minor mark sweep collection 
mark sweep minor collection marks reachable young objects current sliding view sweeps young unmarked objects 
young generation contains objects created previous collection cycle logged mutator local oung objects bu er 
local bu ers hold addresses newly created objects created previous collection viewed holding pointers objects young generation processed minor collection 
rst handshake collection bu ers retrieved collector union taken stored bu er called oung objects 
oung objects bu er young generation processed minor collection cycle collector 
recall levanoni petrank sliding view collectors basis 
sliding view algorithm uses dirty ag object tell modi ed previous collection 
modi ed objects kept updates bu er essentially union mutator updates local bu ers rc elds objects referenced objects slots updated collector 
naive promotion policy may bu ers remembered set young generation contains objects created collection follows inter generational pointers may located pointer slots modi ed collection 
clearly objects old generation point young objects modi ed collection cycle young objects exist previous collection 
addresses inter generational pointers appear updates bu er collector collection cycle 
rst glance may appear 
collection cycle atomic view program 
runs concurrently run program 
referring time collection cycle accurate 
discussion assume reader familiar levanoni petrank original collectors 
cases inter generational pointers created appear updates bu er read collector rst handshake 
case mutator creates new object responding rst handshake 
mutator seen rst handshake executes update operation assigning pointer old generation object case inter generational pointer created object reported collector rst handshake reclaimed promoted current collection 
reported young object collector collection update recorded current collection update executed rst handshake view mutator seen collection 
inter generational pointer missing view collection 
case mutator updates pointer slot object young object 
object currently dirty previous collection cycle rst handshake occurred clear dirty ags operation executed object 
case inter generational pointer created logged th mutator updates local bu er 
pointer slot appear updates bu er previous collection correctness original algorithm cycle updates bu er contain pointer inter generational pointer may missing view collection 
order correctly identify inter generational pointers created manners minor collection records special bu er called er addresses objects updates young objects uncertainty period rst handshake begun till clear dirty ags operation modi ed logged objects 
collection cycle igp bu er bu er appended previous collection cycle buffer bu er order scan potential inter generational pointers appeared updates bu er 
way sure inter generational pointers covered minor collection 
note sweep phase processes young objects 
scans object color oung buffer young generation processed minor collection 
objects marked white color reclaimed promoted setting old ag true 
full counting collection 
major oung objects major updates bu ers full collection bu ers correspond minor collection oung objects updates bu ers 
bu ers prepared minor collections serve full collection 
objects promoted minor collections logged major bu ers objects live till full collection 
minor collection avoids repetition bu ers additional bitmap called 
special care required bu ers major collection cycle similar original counting collector 
rc eld adjustments executed modi ed object 
modi ed objects essentially logged major updates bu er updates bu er 
rc object previous sliding view slots values decremented object current sliding view slots values rc incremented 
young objects procedure needs increment rc elds current sliding view slots values young object logged oung objects oung objects 
decrement operation taken rc eld oung objects objects slots object exist previous collection cycle created value null 
deferred counting employ zero count table denoted zct hold young object count decreases zero counter updates 
candidates checked updates done 
count zero referenced roots may reclaimed 
note newly created young objects checked created count zero referenced local variables 
objects young objects major new objects bu er appended zct reclaimed collector 
inability counters algorithms reclaim cyclic structures treated auxiliary mark sweep algorithm infrequently full collection 
procedure update obj object offset int new object 
obj logpointer null object dirty 
os os take temporary replica object 
foreach eld ptr obj null 
updates os ptr 
obj logpointer null commit replica 
updates os address obj 
os os set dirty ag 
obj logpointer address updates os 
write obj offset new 
snoop new null 
snooped snooped 
new old false 
igp buffer igp buffer fig 

mutator code update operation rc full counting young generation continue overview second generational algorithm 
counting minor collections mark sweep full collections 
algorithm doing 
di erent advantages respect previous algorithm 
counting young generation mark sweep tracing full generation gives interesting advantage 
multithreaded counting collectors particular levanoni petrank collector collector procedure new size integer object 
obtain object size size allocator 

color 
oung objects new os address 
logpointer address oung objects new os 
return fig 

mutator code allocation operation procedure collection cycle 
initiate collection cycle 
clear dirty marks 
reinforce clearing con ict set 
mark roots 

update counters 
reclaim garbage 

mark 
sweep fig 

collection cycle rc full procedure initiate collection cycle 
thread 
snoop true 
true 
thread 
suspend thread copy duplicates 

updates updates updates 
updates clear bu er 

oung objects oung objects oung objects 
oung objects clear bu er 

resume thread fig 

initiate collection cycle rc full procedure clear dirty marks 
object updates 
logpointer null 
object oung objects 
logpointer null fig 

clear dirty marks procedure reinforce clearing con ict set 

thread 
suspend thread 
false 
updates os 
resume thread 
object 
logpointer address replica updates fig 

reinforce clearing con ict set rc full procedure mark roots 
black black 
white white 
buffer buffer igp buffer 
igp buffer 
thread 
suspend thread 
black 
snoop false 
roots roots state copy thread local state 

igp buffer igp buffer igp buffer 
resume thread 
roots roots buffer 
buffer 
thread copy clear snooped objects set 
roots roots snooped 
snooped mark objects roots 
object roots 
trace fig 

mark roots rc full procedure trace object 
color white 
color black 
logpointer null dirty 
temp get replica 
dirty 

logpointer null 
slot temp 
read 
old 
trace 
return 
object dirty logged cycle 
slot replica logpointer 
read 
old 
trace fig 

trace rc full procedure sweep 
foreach object swept oung objects 
swept color white 
swept color blue 
swept logpointer null 
invalidate swept log entry cycle 
swept old false 
return swept allocator 

swept ers true 
major new objects major new objects log promoted old children addresses major updates bu er 
foreach object replica updates 
ers true 
major updates major updates address 
foreach slot replica updates 
major updates major updates fsg fig 

sweep rc full updates counts 
program threads provide collector list modi cations 
noted provide collector small fraction list rst modi cation object previous collection required 
collector execute operations object modi ed collection 
slot decrement count object referenced previous collection increment counts object pointed current collection 
young minor generational collection relevant objects collections objects exist previous collection surviving objects promoted 
need decrement counts objects referenced previous collection promoted reclaimed 
need increment counters half counter updates eliminated see gure 
important issue promotion procedure 
promotion major collections simple 
sweep gure clear unmarked objects reclaimed marked objects promoted 
reclamation promotion counting simple gure 
start going objects young generation oung objects bu er checking zero counts 
zero counts reclaimed 
object count positive promoted 
count nal may decrease zero ancestors may reclaimed 
order refrain traversing young generation counter updates just promotion procedure update counters 
updates updates major updates 
oung objects oung objects major new objects 
object replica updates decrement previous values object 
slot replica 
previous value read 
previous value rc increment current values object 
object updates oung objects 
object logged 
logpointer null 
new replica logpointer 
slot new replica 
curr read 
curr rc 

temp replica copy 
logpointer null taken replica temp replica valid 
slot temp replica 
curr read 
curr rc 

goto object logged fig 

update counters rc full procedure reclaim garbage 
zct zct oung objects 
oung objects 
object zct 
rc roots 
zct zct fog 
old true 
object zct 
old false 
collect fig 

reclaim garbage rc full procedure collect object 
object logged 
logpointer null 
invalidate log entry logpointer 
replica logpointer 
slot replica 
curr read 
curr rc 
curr rc 
curr roots 
collect curr 

curr old true 

temp replica copy 
logpointer null taken replica temp replica valid 
slot temp replica 
curr read 
curr rc 
curr rc 
curr roots 
collect curr 

curr old true 

goto object logged 
old false 
return general purpose allocator 
fig 

collect rc full promotion mechanism 
object positive rc marked candidate promotion ags old ag regular ag signifying object old designated ag 
second ag tells recursive reclamation procedure object young current collection reclaimed count decremented zero 
marking young objects candidates promotion takes place procedure 
reclaim garbage procedure zct table objects zero rc eld marked roots remain 
recursively collects young promotion candidate objects 
notice deleted candidate objects young objects marked old 
collection cycle ags cleared promoting young surviving objects see gure 
note case worry collecting cyclic structures 
structures collected tracing collector full collection algorithm gures 
full collections collector starts tracing sliding view associated cycle 
marking stage collector proceeds reclaim garbage objects sweeping heap 
see section explanation tracing sliding view algorithm 
procedure update obj object offset int new object 
obj logpointer null object dirty 
os os take temporary replica object 
foreach eld ptr obj null 
updates os ptr 
obj logpointer null commit replica 
updates os address obj 
os os set dirty ag 
obj logpointer address updates os 
write obj offset new 
snoop new null 
snooped snooped fig 

mutator code update operation rc minor rc counting generations go sketch generational algorithm 
mentioned earlier provide sketch design 
generational algorithm uses counting method minor collection full collection 
main problem young generation clear save procedure initiate collection cycle 
thread 
snoop true 
thread 
suspend thread copy duplicates 

updates updates updates 
updates clear bu er 

oung objects oung objects oung objects 
oung objects clear bu er 

resume thread fig 

initiate collection cycle rc minor rc procedure reinforce clearing con ict set 

thread 
suspend thread 
updates os 
resume thread 
object 
logpointer address replica updates fig 

reinforce clearing con ict set rc minor rc procedure mark roots 
black black 
white white 
thread 
suspend thread 
black 
snoop false 
roots roots state copy thread local state 

resume thread 
thread copy clear snooped objects set 
roots roots snooped 
snooped mark objects roots 
object roots 
trace fig 

mark roots rc minor rc procedure collection cycle 
initiate collection cycle 
clear dirty marks 
reinforce clearing con ict set 
mark roots 

mark 
sweep 

update counters 
reclaim garbage 
clear ags fig 

collection cycle rc minor procedure trace object 
color white 
color black 
logpointer null dirty 
temp get replica 
dirty 

logpointer null 
slot temp 
read 
trace 
return 
object dirty logged cycle 
slot replica logpointer 
read 
trace fig 

trace rc minor procedure sweep 
foreach object swept heap 
swept color white 
swept color blue 
swept logpointer null 
invalidate swept log entry cycle 
swept old false 
return swept allocator 
promote object 
swept old true fig 

sweep rc minor procedure update counters need decrement previous values increment current values object 
object updates oung objects 
object logged 
logpointer null 
new replica logpointer 
slot new replica 
curr read 
curr rc 

temp replica copy 
logpointer null taken replica temp replica valid 
slot temp replica 
curr read 
curr rc 

goto object logged fig 

update counters rc minor procedure reclaim garbage 
zct zct oung objects 
oung objects 
object zct 
rc roots 
zct zct fog 
true 
object zct 
old false 
collect fig 

reclaim garbage rc minor procedure collect object 
object logged 
logpointer null 
invalidate log entry logpointer 
replica logpointer 
slot replica 
curr read 
curr old false curr 
curr rc 
curr rc 
curr roots 
collect curr 

curr old true 

temp replica copy 
logpointer null taken replica temp replica valid 
slot temp replica 
curr read 
curr old false curr 
curr rc 
curr rc 
curr roots 
collect curr 

curr old true 

goto object logged 
old false 
return general purpose allocator 
fig 

collect rc minor rc counter updates minor collection 
go updates bu er counter updates copying irrelevant entries executing 
alternative heavier write barrier routes update ages objects lose gain 
decided option costly chose rst 
minor collection algorithm keeps updating counts objects reclaims young dead objects gures 
old dead objects reclaimed major collection gure 
algorithm lowest potential savings concern materializes measurements 
algorithm employ zero count tables order store potential dead young dead old objects respectively 
promotion policy naive policy problem determining object promoted solved manner rst algorithm 
inability counters algorithms reclaim cyclic structures treated auxiliary mark sweep algorithm infrequently full collection 
procedure collection cycle 
initiate collection cycle 
clear dirty marks 
reinforce clearing con ict set 
mark roots 
update counters 
reclaim garbage minor zct 

reclaim garbage major zct 

clear ags fig 

collection cycle rc implementation java implemented generational collectors jikes research java virtual machine version linux red hat 
entire system including collector written java extended unsafe primitives available java virtual machine implementation access raw memory 
jikes uses safe points interrupting threads asynchronous signals thread periodically checks bit condition register indicates runtime system wishes gain control 
design signi cantly simpli es garbage collection 
procedure update counters decrement previous values object 
slot replica 
previous value read 
previous value rc 
previous value rc 
previous value old false 
minor zct minor zct fog 

major zct major zct fog increment current values object 
object updates young objects 
object logged 
logpointer null 
new replica logpointer 
slot new replica 
curr read 
curr rc 

temp replica copy 
logpointer null taken replica temp replica valid 
slot temp replica 
curr read 
curr rc 

goto object logged fig 

update counters rc procedure reclaim garbage zct zero count table 
zct zct oung objects 
oung objects 
object zct 
rc roots 
zct zct fog 
true 
object zct 
old false 
collect fig 

reclaim garbage minor rc addition implementing java threads operating system threads jikes multiplexes java threads virtual processors implemented operating system threads 
jikes establishes virtual processor physical processor 
ll discuss attributes jalape uenced design collector platform 
jalape attributes jalape processors threads 
implement java threads operating system threads jalape multiplexes java threads virtual processors implemented operating system threads 
jalape locking mechanisms implemented operating system support 
decision map java threads operating system threads directly motivated need able support rapid thread switching garbage collection 
jalape establish virtual processor physical processor 
operating system service jalape periodic timer interrupt provided system call 
jalape locking mechanisms system calls implemented operating system services 
jalape compilers 
jalape interpret bytecodes 
compiled machine code execution 
jalape supports interoperable compilers address di erent trade development time compile time run time 
compilers integral jalape design enable thread scheduling synchronization type accurate garbage collection exception handling dynamic class loading 
generational garbage collection algorithms implementation uses baseline compiler optimizing compiler 
assumed underlying system conforms sequential consistency constraints memory model 
optimizations optimizing compiler violate assumption underlying system decided baseline compiler 
object model memory layout 
values java language primitive int double pointers objects 
objects arrays having components scalars having elds 
assuming object register object elds accessed xed displacement single instruction 
facilitate array access array points rst zeroth component array remaining components laid ascending order 
number components array length kept just rst component 
jalape arrays grow object array length xed negative set scalar objects grow object elds negative set 
eld access accomplished single instruction base displacement addressing 
object headers 
word object header associated object 
header supports virtual methods dispatch dynamic type checking memory management synchronization hashing 
located value object 
word header status word 
word object header ib object class 
tib array java object 
rst component describes object class including superclass interfaces implements sets object elds 
remaining components compiled method bodies executable code virtual methods class 
tib serves jalape virtual method table 
scalar object array object length status status tib tib object header object header object fields object fields raw address object address object address raw address fig 

jalape object model run time subsystem 
virtual machine implemented low level constructs exist java language 
jalape theses constructs low level services class called magic 
class implements types services needed virtual machine implementation general collector implementation particular 
services exception handling dynamic type checking raw addresses manipulation re ection provided class 
implementation bit maps 
implementation garbage collection algorithms calls mechanism fast relate objects sets object set objects eciently rst priority time second space support functions add set 
remove set 
find contained set 
clear objects set 
chosen implement mechanism bitmap tables bit bytes separated data objects headers 
enhanced locality consecutive accesses objects sets done smaller near set addresses mess data cache solution uses object header 
important attribute advantage bitmap table solution fourth function clear bitmap table implemented eciently terms time 
solution space ecient bitmap table quite wasteful terms space need allocate ag bitmap granule object alignment 
objects usually aligned bytes smaller granules typical object bytes long inlining ag indicator set relation inside object results substantial saving space mention cases unused bit object header waiting exploited 
algorithms bitmap tables object know rc count object 
mark object marked mark sweep part algorithm 
local object root set collection cycle 
zct object zero count table 
old object old object age old 
object logged bu ers major generation 
object temporarily promoted collection cycle 
object headers 
written previous section word object header associated object 
word header status word 
word object header ib object class 
implementation object word header 
word functions dirty indication object object logged garbage collector auxiliary bu ers 
locating indication interspersed data bene ts conservation space allocate space ags type basis conservatively word memory done bitmapped solution increased locality ags accessed mutators conjunction perspective slots counting part algorithms need collector implement clear operation 
method disadvantages mainly inability quickly clear dirty ags cleared time decreased locality mark sweep part algorithms sweep operation needs look pointer object want evacuate see logged bu er 
ll discuss technique overcome problem 
issue need raw address conversion 
jalape object model way objects headers located memory designed sets scalars arrays headers 
side ect object model way know object address raw address known advance scalar array 
mark sweep part algorithm thing need 
sweep procedure scans alive objects heap check marked sweep procedure reaches raw address object order nd scalar object array object length status status tib tib object header object header object fields object fields raw address object address object address raw address dirty dirty fig 

object model marked need nd address corresponds raw address object marked address raw address 
allocator 
jalape comes collectors implementations uses types allocators copying non copying generational copying generational non copying 
implementation decided non copying allocator 
allocator similar builds allocator boehm demers shenker 
allocator ts collectors move objects 
keeps fragmentation low allows ecient sporadic reclamation objects required counting ecient linear reclamation objects required sweep procedure 
chosen allocator partitions heap memory di erent heap spaces large object space small object space 
large heap 
manager uses non copying large object space managed sequence pages 
requests large objects satis ed rst basis 
garbage collection event adjacent free pages coalesced 
order support concurrent allocations small objects copying managers virtual processor maintains large chunk local space objects allocated requiring synchronization 
local chunks logically separate global heap object allocated virtual processor accessible virtual processor gets 
allocation performed incrementing space pointer required size comparing result limit local chunk 
comparison fails allocator atomically obtains new local chunk shared global space 
technique works locking new chunk required 
cost maintaining local chunks memory fragmentation increased slightly chunk may lled completely 
small heap 
non copying allocator divide small object heap xed size blocks kbytes 
block dynamically subdivided xed size slots 
number sizes values build time constants tuned observed distribution small object sizes 
allocator receives request object determines size smallest slot satisfy request obtains current block size 
avoid locking overhead virtual processor maintains local current block size 
current block full normal case block size available 
blocks full obtains block shared pool newly obtained block current 
block sizes number slot sizes relatively small space impact replicating current blocks virtual processor insigni cant 
mutation collection 
virtual processor collector thread associated 
garbage collection triggered explicitly mutator explicitly requests mutator request space allocator satisfy 
full heap collection triggered amount available memory drops prede ned threshold 
minor heap collection triggered new allocator block allocations 
kind triggering strategy emulates allocations young generation size limited 
mutation collector threads waiting state 
collection requested collector threads noti ed scheduled virtual processors time 
collector thread starts executing handshake disables threads switching virtual processor till 
note collector thread running performing handshake mutators virtual processor yield points 
number mutator threads large important performance consideration 
yield points jikes safe points collector thread may proceed handshake 
handshake completed collector threads re enable thread switching virtual processor wait collection 
mutator threads virtual processor start automatically collector thread release virtual processor 
results taken measurements way ibm net nity server mhz intel pentium iii xeon processor gb physical memory 
benchmarks specjvm benchmark suite specjbb benchmark 
benchmarks described detail spec web site 
tested new collectors jikes concurrent collector distributed jikes research java virtual machine package 
collector counting concurrent collector developed ibm reported bacon 
testing procedure 
benchmark suite test harness performing standard automated runs benchmarks suite 
standard automated run runs benchmark times jvm involved implementing di erent collector 
get additional multithreaded benchmark modi ed mtrt benchmark specjvm suite run varying max pauses ms specjvm specjbb threads collector jess javac db mtrt jack jbb jbb jbb generational rc full jikes concurrent fig 

max pause time measurements specjvm specjbb benchmarks multiprocessor 
specjbb measured warehouses 
number threads 
measured run threads 
understand better behavior collectors tight relaxed conditions tested varying heap sizes 
specjvm suite started mb heap size extended sizes mb increments nal large size mb 
specjbb larger heaps reported graphs 
results concentrate best collector collector uses full collection 
experience led choose allocator blocks amount block allocations needed order trigger minor collection block size kbytes size young generation 
best benchmarks 
best initiate full collection heap full 
collector may able free space program threads consume heap throughput latency deteriorate 
gures report collectors results varying heap size minor generation size 
gures concluded optimal minor generation size benchmarks benchmarks call small minor generation size trigger minor collection allocator blocks allocation see gures 
benchmarks call large minor generation size trigger minor collection allocator blocks allocation see gures 
collector 
chosen concurrent counting collector supplied jikes package bacon collector 
results compared collector 
collector advanced pure counting collector similar characteristics collector mutators loosely synchronized collector allowing low pause times 
server measurements 
specjvm benchmarks mtrt modi ed benchmark provide measure elapsed running time report 
report gure running time ratio collector collector 
higher number better collector performs 
particular value means collector outperforms collector 
ran specjvm benchmarks multiprocessor allowing designated processor run collector thread 
report results gure 
results demonstrate performance system busy collector may run concurrently idle processor 
practically measurements collector better collector improvement jess small heaps 
heap size mb specjvm multiprocessor jess javac db mpegaudio mtrt jack fig 

running time ratios jikes concurrent generational specjvm suite varying heap sizes 
results multiprocessor heap size mb specjvm uniprocessor jess db mpegaudio mtrt jack fig 

running time ratios jikes concurrent generational specjvm suite varying heap sizes 
results uniprocessor 
heap size mb specjbb throughput ratio threads threads threads threads fig 

spec jbb throughput ratios generational jikes concurrent multiprocessor heap size mb spec jbb memory consumption ratio threads threads threads threads fig 

spec jbb memory consumption generational vs jikes concurrent multiprocessor heap size mb mtrt multiprocessor mtrt threads mtrt threads mtrt threads mtrt threads fig 

running time ratio jikes concurrent generational mtrt benchmarks multiprocessor 
heap size mb specjvm multiprocessor jess javac db mpegaudio mtrt jack fig 

results second generational algorithm uses counting minor generation 
spec jvm running time ratios jikes concurrent generational multiprocessor heap size mb specjbb multiprocessor threads threads threads threads fig 

results second generational algorithm uses counting minor generation 
throughput ratio generational jikes concurrent spec jbb multiprocessor 
jess db javac heap size mb blocks blocks blocks fig 

rc full algorithm running time ratios jikes concurrent generational spec jvm multiprocessor varying minor generation size 
large minor generation blocks better 
mpegaudio mtrt jack heap size mb blocks blocks blocks fig 

rc full algorithm running time ratios jikes concurrent generational spec jvm multiprocessor varying minor generation size 
small minor generation better 
mtrt threads mtrt threads mtrt threads mtrt threads heap size mb blocks blocks blocks fig 

rc full algorithm running time ratios jikes concurrent generational mtrt multiprocessor varying minor generation size 
small minor generation better 
jess db javac heap size mb blocks blocks blocks fig 

rc minor algorithm running time ratios jikes concurrent generational spec jvm multiprocessor varying minor generation size 
large minor generation better mpegaudio mtrt jack heap size mb blocks blocks blocks fig 

rc minor algorithm running time ratios jikes concurrent generational spec jvm multiprocessor varying minor generation size 
small minor generation better mtrt threads mtrt threads mtrt threads mtrt threads heap size mb blocks blocks blocks fig 

rc minor algorithm running time ratios jikes concurrent generational mtrt multiprocessor varying minor generation size 
small minor generation better 
mpegaudio javac heap size mb blocks blocks blocks fig 

rc algorithm running time ratios jikes concurrent generational spec jvm multiprocessor varying minor generation size 
large minor generation better jess db mtrt jack heap size mb blocks blocks blocks fig 

rc running time ratios jikes concurrent generational spec jvm multiprocessor varying minor generation size 
small minor generation better mtrt threads mtrt threads mtrt threads mtrt threads heap size mb blocks blocks blocks fig 

rc algorithm running time ratios jikes concurrent generational mtrt multiprocessor varying minor generation size 
small minor generation better 
behavior collector busy system may tested number application threads exceeds number physical processors 
special case jvm run uniprocessor 
cases eciency collector important throughput may harmed collector spends cpu time 
modi ed mtrt benchmark varying number threads threads resulting throughput measures reported gure 
measurements show improved performance parameters typical large heaps highest improvement mtrt threads heap size mbytes 
small heaps collector better 
results specjbb measured bit di erently 
run specjbb requires multi phased run increasing number threads 
phase lasts minutes ramp period half minute phase 
report throughput ratio improvement 
result throughput 
clarity representation report inverse ratio higher ratios show better performance collector ratios larger imply collector outperforming collector 
measurements reported varying number threads varying heap sizes gure 
system idle processor collector warehouses collector clearly outperforms collector 
typical improvement highest improvement 
case warehouses run collector free run idle processor collector performs better heap tight tighter heaps collector wins 
maximum pause times specjvm benchmarks specjbb benchmark reported gure 
specjvm benchmarks run heap size mbytes specjbb threads heap size mbytes 
note number threads exceed number processors long pause times appear threads lose cpu mutators collector 
reported settings 
seen maximum pause times see gure low collector ms 
go couple graphs presenting measurements second best collector runs counting young generation mark sweep full collection 
gure report running time throughput ratio collector 
seen graphs collector perform signi cantly worse 
measurements better collector improvement jess small heaps specjbb benchmark number threads 
measurements appear technical report 
client measurements 
measured generational collector uniprocessor check handles client environment specjvm benchmark suite speci cations uniprocessor con guration appears section 
report uniprocessor tests gure 
turns generational algorithm better collector tests 
note large improvement jess benchmark 
specjbb reports heap consumption 
report measure 
seen heap consumption typically decreased 
explained frequent reuse young generation space 
designs integrating generations counting collector counting full collection mark sweep collecting young generation counting collecting young generation mark sweep collecting full collection counting generations collection 
tracing collector seldom collect cyclic garbage structures 
levanoni petrank sliding view collectors building blocks design 
collector implemented jikes run way ibm net nity server 
measurements jikes concurrent collector show large improvement throughput low pause times 
collector best possible incorporation generations counting collectors 

erez petrank 
integrating generations advanced counting garbage collectors 
technical report faculty computer science technion israel institute technology october 
available www cs technion ac il erez publications html 

alan demers mark weiser barry hayes hans boehm daniel bobrow scott shenker 
combining generational conservative garbage collection framework implementations 
conference record seventeenth annual acm symposium principles programming languages acm sigplan notices january 
acm press pages 

alfred aho brian kernighan peter weinberger 
awk programming language 
addison wesley 

andrew appel john ellis kai li 
real time concurrent collection stock multiprocessors 
acm sigplan notices 

bacon attanasio lee rajan smith 
java ee breaks nonintrusive multiprocessor garbage collector 
appear acm sigplan conference programming language design implementation pldi snowbird utah june 

bacon rajan 
concurrent cycle collection counted systems 
appear fifteenth european conference object oriented programming ecoop university os budapest hungary june 

henry baker 
list processing real time serial computer 
communications acm 

henry baker 
minimising count updating deferred anchored pointers functional data structures 
acm sigplan notices september 

hans juergen ohm alan demers scott shenker 
parallel garbage collection 
acm sigplan notices 

chikayama kimura 
multiple management flat ghc 
iclp pages 

george collins 
method overlapping erasure lists 
communications acm december 

john detreville 
experience concurrent garbage collectors modula 
technical report dec systems research center palo alto ca august 

john detreville 
experience garbage collection modula topaz environment 
oopsla ecoop workshop garbage collection object oriented systems october 

peter deutsch daniel bobrow 
ecient incremental automatic garbage collector 
communications acm september 

dijkstra leslie lamport martin scholten ste ens 
garbage collection exercise cooperation 
communications acm november 

damien doligez georges gonthier 
portable unobtrusive garbage collection multiprocessor systems 
popl 

damien doligez xavier leroy 
concurrent generational garbage collector multi threaded implementation ml 
popl 

elliot kolodner ethan lewis elliot katherine itai yossi levanoni erez petrank igor 
implementing garbage collector java 
international symposium memory management october 

elliot kolodner erez petrank 
generational garbage collector java 
acm sigplan conference programming language design implementation pldi 

satoshi matsuoka akinori yonezawa 
parallel conservative garbage collection fast allocation 
paul wilson barry hayes editors oopsla october 

adele goldberg robson 
smalltalk language implementation 
addison wesley 

richard jones rafael lins 
garbage collection algorithms automatic dynamic memory management 
wiley july 

yossi levanoni erez petrank 
counting garbage collector java proccedings acm conference object oriented programming systems languages applications oopsla 
see technical report cs dept computer science technion nov 

lieberman hewitt 
real time garbage collector lifetimes objects 
acm pages 

james toole scott nettles 
concurrent replicating garbage collection 
lfp oopsla workshop memory management garbage collection 

young park benjamin goldberg 
static analysis optimising counting 
ipl august 

charles fischer 
concurrent garbage collection program slices multithreaded processors 

tony david detlefs 
generational concurrent garbage collector 
ismm 

david roth david wise 
bit counts unique sticky 
acm sigplan notices pages october 
acm press 

guy steele 
multiprocessing garbage collection 
communications acm september 

standard performance evaluation www spec org 
stoye clarke arthur norman 
practical methods rapid combinator reduction 
lfp pages august 

ungar 
generation scavenging non disruptive high performance storage reclamation algorithm 
acm sigplan notices vol 
may pp 


larry wall randal schwartz 
programming perl 
reilly associates 

weizenbaum 
symmetric list processor 
communications acm september 

david wise 
bit counting 
ipl july 

david wise 
bit counting 
technical report indiana university computer science department march 
