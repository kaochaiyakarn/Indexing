generic type system pi calculus atsushi igarashi kyoto university email igarashi kyoto ac jp naoki kobayashi tokyo institute technology email cs titech ac jp february propose general powerful framework type systems calculus show obtain instances variety type systems guaranteeing non trivial properties deadlock freedom race freedom 
key idea express types type environments processes check various properties process checking corresponding properties type environment 
framework clarifies essence complex type systems enables sharing large amount proof type preservation making easy develop new type systems 
motivation static guarantee correctness concurrent programs important concurrent programs complex sequential programs due non determinism deadlock hard programmers debug concurrent programs reason behavior 
number advanced type systems proposed analyze various properties concurrent programs input output modes multiplicities channel race conditions deadlock livelock information flow :10.1.1.111.9953
unfortunately satisfactorily general framework type systems concurrent programming languages type systems designed ad hoc manner guaranteeing certain specific properties 
lack general framework kept di cult compare integrate extend existing type systems 
lot tasks proving type soundness repeated type system 
situation stands contrast type systems functional programming languages number useful analyses side ect analysis region inference exception analysis obtained instances ect analysis 
goal establish general framework type systems concurrent processes various advanced type systems derived instances 
type systems calculus target language simple expressive model modern concurrent distributed programming languages 
preliminary summary appeared proceedings th acm sigplan sigact symposium principles programming languages 
main ideas main idea express types type environments processes 
type judgment normally read process typed type environment means process correct abstraction process sense satisfies certain property race freedom deadlock freedom abstraction satisfies corresponding property 
sense type system may regarded kind interpretation 
define relation typing rules 
simpler process calculus express type environments calculus easier check properties check directly 
see type environments expressed processes review ideas previous type systems deadlock livelock freedom 


process sends tuple 
channel behaves 

process receives tuple 
binds 

behaves write parallel execution inaction 
previous type systems process 


roughly typed follows types form 
channel types part 
means channel communicating tuple values types 
part called usage expresses channels input output 
example part type means output denoted successive inputs denoted parallel 
focusing usage parts view type environment collection processes performs pair actions channel 
reduce type environment canceling usage obtain type environment process 

obtained reducing reducing type environment obtain indicates input may remain fully reduced 
idea developed type systems deadlock 
push type environments processes view express type environments ccs processes ccs operator hiding creating channels 
type environment process expressed 




represents channel order communications di erent channels fact output occurs output succeeds indicated part 

parts enclosed square brackets usage values transmitted channels 
generalization reason properties race conditions single framework 
new type system guarantee deadlock freedom processes concurrent objects non uniform service availability 
contributions contributions summarized follows develop general framework type systems call generic type system just generic function parameterized types instantiated functions various arguments changing types generic type system parameterized subtyping relation consistency condition types instantiated variety type systems changing subtyping relation consistency condition see section 
prove general type system satisfies important properties subject reduction independently choice subtyping relation consistency condition 
need prove type system 
properties prove general type soundness property soundness certain class instances generic type system immediately obtained see section 
show variety non trivial type systems ensuring deadlock freedom race freedom derived instances general type system prove soundness 
general properties mentioned proof instance generic type system quite short soundness instances follows immediate corollary general type soundness theorem see sections 
rest section introduces syntax operational semantics target process calculus 
section presents generic type system section discusses soundness generic type system 
section derives variety type systems instances generic type system 
demonstrate strength framework section shows deadlock race conditions concurrent objects analyzed generic type system 
section formalizes part type checking reconstruction algorithms common instances generic type system 
section discusses limitations extensions generic type system 
section discusses related section concludes 
target language section introduces syntax operational semantics target language 
syntax calculus basically subset polyadic calculus 
state properties process annotate input output operation label 
definition processes set processes defined syntax 
processes 
guarded processes 





range countably infinite set var variables 
ranges countably infinite set labels called events 
assume var 
notation write possibly empty sequence 
length sequence 
abbreviated usual 
called bound variables 
variables called free variables 
assume conversions implicitly applied bound variables di erent free variables 
expression 
abbreviated denotes process obtained replacing free occurrences 

omit sp zero sp sp assoc sp rep free sp new sp par sp cnew structural preorder inaction write 





respectively 
events important omit just write 





respectively 
abbreviate 





respectively 
give precedence prefixes 



order 
meanings 



explained 

input output processes denotes external choice behaves 
depending enabled communications 
creates fresh channels executes denotes infinitely copies running parallel 
operational semantics usual define reduction semantics structural relation reduction relation 
technical convenience require structural relation symmetric 
reduction relation annotated label call reduction label form reduction label records channels events involved reduction label means communication channel output input processes labeled respectively 
reduction label means communication occurs bound channel output input processes labeled respectively 
reduction labels state properties process section 
definition structural preorder reflexive transitive relation closed rules denotes 
definition reduction label set variables 
define operationally xn distinguish type system section 




com par new sp reduction relation definition reduction relation relation closed rules 
notation write notation binary relations set write reflexive transitive closure composition generic type system section introduces generic type system shows properties 
types define syntax types 
kinds types types tuples called tuple types processes called process types 
process types correspond type environments mentioned section express behavior processes 
assume countably infinite sets type variables size tuples 
write type variable ranging type tuples 
definition types sets tuple types process types defined syntax 
ary tuple types 
process types 




meta variable ranges type tuples 
omit important clear form context 
tuple type 
type tuple elements 

standard notation recursive types 
recursive types express channel infinitely channel repeatedly input channel carries 

examples example 
type inaction 

type process uses sending tuple type behaves 
output tagged similarly 

type process uses receiving tuple type behaves 
way express precise information usage channels previous type systems 
type process behaves action annotated input output action channel occurs 
type process behaves parallel 
type represents external choice process type behave 
depending communications provided environment 
hand type represents internal choice process type behave irrespectively communications provided environment 
type 
describes process uses channels 
type arity information exclude ill formed types 
notation write arity kinds binders channel variables type variables 
tuple type binds variables 
assume binds type variable 
assume conversions implicitly applied bound variables di erent free variables 
write capture avoiding substitution respectively 
write appear type infinitely copies process type 
omit write 





respectively 
abbreviate 





respectively 
write null contain process type form 



give precedence prefixes 



order 
definition tuple type process type closed contains free type variables 
tuple process type semi closed contains free type variables inside 
tuple type contractive contains free occurences inside 
example process type 
semi closed closed 
contractive 

notice process constructors introduced previous section corresponding constructors process types 
symbols clarify correspondence 
calculus processes section process types contain operators creating fresh channels passing channels channels 
check properties types processes easily calculus processes 
operators counterparts processes 
internal choice necessary express non deterministic behavior process 
example suppose process behaves process behaves process 

behaves process type form plays important role guaranteeing complex properties deadlock freedom 
example express type 

implies output performed action labeled succeeds 
succeeds know input kept waiting forever 
introduce process types distinguish input output actions 
simplicity 
example process type 
describes process uses input uses output 
process 
type 


type 
process type 
describes process uses output sequentially order 

type 
process 

type 
example type 
describes pair element sending value type second element receiving value type type 
describes channel receiving tuple type repeatedly 
type describes channel receiving channel type received channel receiving channel type 
define set free channel variables process type follows 
note fv di erent set variables appearing free syntactically example element fv 
intuitively fv denotes set free variables renaming changes meaning 
example set fv renaming di erent variable example changes meaning process type 
hand element fv essentially equivalent respect subtyping relation introduced renaming change meaning 
definition process type 
set fv variables defined fv fv 
fv fv fv 
fv fv fv fv fv fv fv fv fv fv fv fv fv fv fv fvi fv fv fv fv fv fvi fvi fv fvi fvi define operations types 
operation defined extracts information usage channels extracts information usage channels definition subset var nat 
unary operations semi closed tuple types process types defined similar intersection type di erence value type 









nat var example 




subtyping introduce subtyping relation meaning process type may behave type example hold 
subtyping relation depends property want guarantee example concerned arity mismatch errors may identify 


concerned complex properties deadlock freedom 
state necessary conditions satisfied subtyping relations instances type system 
definition subtyping preorder process types tuple types proper subtyping relation satisfies rules denotes 
rest assume denotes proper subtyping relation 
explanation rules recursive types required 
rule sub unfold allows occurences recursive type variable replaced definition 
rule sub rec contraction rule amadio cardelli definition 
standard rule unfolding recursive types obtained sub unfold sub rec 
rule sub rep degenerated case standard rule sequence assumptions form possible replace sub rep rule 
sub rep derivable rule follows addition rules axiom examples 
closed contains free type variables sub divide axiom required type soundness hold processes typed 
rule allows forget information dependencies channels 
example 



subtype 
note closedness required condition get 
notice expresses liberal usage means output input says output event necessarily input reduction process types want reason behavior process inspecting behavior abstraction process type 
define reduction process types reduction step process matched reduction step process type 
example reduction process 



matched 



case reductions processes annotate reduction information channel events involved reduction 
definition reduction relation process types var relation closed rules 
write rule ter com simulate communication inner channels 
example process reduction 
simulated 
rule ter ev allows process type form reduced 
model communication process unknown environment 
rule necessary reason behavior process compositional manner 
example consider process 

sub empty sub sub assoc sub unfold contractive sub rec sub beta sub abs sub app sub sub rep sub par 
sub choice sub restrict sub subst necessary conditions subtyping relation 



ter com ter com ter ev ter par ter sub reduction process types communicates environment channels check channel consistent manner looking environment drop information check behavior type int 
int 
reducing type int 
int 

int 
int 
find wrong communication consistency process types process type correct abstraction process verify property process verifying corresponding property process type 
write ok corresponding property process types call consistency condition 
consistency condition depends property require processes 
state necessary conditions consistency condition satisfy 
consistency conditions specific instances section 
formedness condition requires disagreement communication input output processes 
example process type string int ill formed specifies sub process waiting receive string sub process trying send integer channel 
definition formedness process type formed written wf exist satisfy conditions 





possible replace condition contains 

checked easily 
type systems flexible 
condition allow process types 



allows communicating value type communicating value type definition consistency predicate ok process types proper consistency predicate satisfies conditions 
ok wf 

ok ok 

ok null ok rest assume ok refers proper consistency predicate 
say process type consistent wf holds 
process types form simpler process calculus calculus expect predicate ok normally easier verify corresponding property process 
actual procedure verify ok depends definition subtyping relation interested linearity information introduce rule reductions process type reduced finite state machine 
take proper subtyping relation need complex system petri nets case previous type system deadlock freedom 
typing type judgment form closed containing free type variables process type 
means behaves specified 
typing rules 
rules par choice rep say abstraction process constructed process constructor obtained composing abstractions subprocesses corresponding constructor process types 
key rules new 
note channels dynamically created passed channels process calculus calculus process types corresponding mechanisms 
approximate behavior process rules 
rule express information passed type level 
put expresses channels receiver continuation output action 
rule lefthand assumption means uses free channels righthand assumption means information usage received channels information usage put tuple type information usage channels put tuple type usage channels taken account output process continuation usage channels taken account input process 
example consider process 

subprocess 
process type 
applying sub sub divide obtain type judgment 

zero par rep sub 
choice 



fv 



ok fv new typing rules applying obtain 



parameter type channel carries information input event occurs 
hand continuation part says event occurs input output 
alternatively obtain type judgment 


judgment means input output 
rule new check condition ok consistent manner forget information condition fv ensures longer visible outside 
rules asymmetric sense information continuation receiver process transfered sender process vice versa 
design choice motivated observation names channels transmitted communication statically known sender put information transmitted channels receiver type sender 
example consider process containing 
sub processes 
name may scope sub process 
put information output type 

extension treat input output processes symmetric manner discussed section 
example consider process 

receiving channel receives null tuple sends null tuple sends null tuple 
lock receiving value sending value interpreted acquiring lock releasing lock respectively see section 
parallel composition process 
typed follows 













derivation denotes implies communication lock acquired null tuple sent released 
example consider process 



expansion 

process typed follows 
















type soundness general type system parameterized subtyping relation consistency predicate ok determine exact properties instance type system 
proofs type soundness depend instance 
show important properties proved independently choice subtyping relation consistency predicate 
section show collection basic properties generic type system 
properties imply behavior process simulated type certain sense check properties process checking corresponding properties process type 
properties section low level necessary prove type soundness instance generic type system easier proving soundness type system scratch 
section show high level theorem type soundness 
theorem automatically obtain type soundness certain class instances generic type system 
basic properties generic type system type preservation theorem guarantees holds reduction corresponding reduction reduced process reduced process type 
sense behavior typed process modeled process type 
theorem subject reduction wf exists proof see appendix 
corollary follows process satisfies certain invariant condition type satisfies corresponding consistency condition 
theorem suppose holds ok 
ok holds proof mathematical induction length reduction sequence theorem fact ok preserved reduction process types 
normalization type derivation normal derivation theorem states type derivation possible obtain syntax directed type derivation 
useful studying relationship process process type developing type check reconstruction algorithms 
write derivable sub immediately 
theorem normal derivation proof follows fact application rule sub rule permuted downwards 
corollary follows process trying perform input action process type trying perform corresponding action 
similar property holds output 
corollary 

ok conditions hold 






conversely process type obtained normal derivation trying perform action process trying perform corresponding action 
theorem 











proof trivial definition general type soundness theorem section shown process satisfies certain property process type satisfies corresponding consistency condition ok left designer specific type system find consistency condition corresponds process property interest prove correspondence correct 
remains general question power generic type system kind type system obtained instance 
clearly properties verified type system example property process create channels verified process types carry information channel creation 
section gives partial answer questions certain class properties processes systematic way obtaining corresponding consistency condition ok process types instantiated type system sound 
introduce logical formulas formally state properties processes types 
definition set prop formulas syntax true 

ev 
meta variable ranges set ivar variables called integer variables disjoint var 
meta variables range union set ivar set nat non negative integers 
abbreviate formula describes property processes types 
intuitively 
means sub process ready output tuple channel output tagged similarly 
means sub process ready input tuple 
formula means process parallel composition process satisfying process satisfying formula means process reduced step process satisfying reduction labeled formula ev means process reduced process satisfying finite number steps 
example formula ev 
means processes try output value simultaneously 
define formal semantics formulas 
usual bind respectively 
write set free integer variables define substitutions variables events integer variables customary manner 
example denotes formula obtained substituting free occurrences 
write fv set free variables var set free integer variables ivar 
definition size formula written size defined size true size size size size size size size size ev size size size size size define semantics pr formula set processes satisfying define introduce auxiliary function pr denotes set processes satisfying provided channels invisible 
possible introduce general fixed point operator simplicity 
definition formula finite set variables 
sets pr pr processes defined proc set processes pr pr true pr proc pr 


pr 


pr pr pr pr pr ev pr pr pr proc pr pr pr pr pr var pr pr pr pr pr nat means inequalities hold 
write pr holds 
easy prove pr pr defined induction size show properties pr lemma exists proof follows straightforward induction derivation lemma pr pr proof lemma follows induction size lemma suppose proc prop var 
suppose 
pr holds pr holds 
proof proof proceeds induction size show main cases cases similar trivial 
case 
required property follows pr 





pr case required property follows pr pr pr pr pr pr case suppose pr exists pr lemma exists lemma pr pr induction hypothesis pr pr required 
hand suppose pr 
exists pr rule new applying induction hypothesis pr obtain pr pr required 
formula interpreted property process types type set process types definition formula set ty ty process types defined true ty type ty 

ty 

ty ty ty ty ty ev ty ty ty type ty ty ty ty ty var ty ty ty ty ty nat ty ty write ty holds 
formally define property process types corresponds property processes introduce binary relations formulas 




red ev ev ev par neg neg inference rules proving notation write gs set substitutions map free integer variables non negative integers 
definition binary relations formulas defined type proc var gs wf ty pr type proc var gs 
wf pr ty intuitively means process type satisfies property process type satisfies property conversely means process satisfies type satisfies obtain sound inference rules derive relations shown 
standard logical rules soundness inference rules proved follows 
lemma inference rules sound 
proof loss generality assume formulas contain free integer variables 
soundness rules follow immediately corollary 
show soundness red suppose pr pr exist pr theorem exists lemma appendix assumption ty ty ty ty required 
soundness ev follows similarly 
show soundness par suppose pr wf 
assumption pr exists 
pr pr lemma 
theorem xn xn wf 
note wf wf follows conditions wf 
assumptions ty ty implies xn ty xn ty xn xn ty required 
show soundness neg suppose pr su ces show ty suppose ty case pr contradicts assumption pr proc pr proof soundness neg similar 
lemma show negative formula defined process satisfies pr process type satisfies formula type system reasoning properties described negative formulas 
definition positive negative formulas set resp 
positive negative resp 
formulas set satisfying rules true 

ev intuitively formula positive negative resp 
sub formulas form ev 

appear positions negation applied odd resp 
number times 
theorem suppose wf 
var ty pr holds 
conversely var pr ty holds 
proof proof proceeds induction size cases 

ev follow immediately lemma 
suppose ty definition case assumption ty ty 
induction hypothesis obtain pr pr required 
cases similar 
lemma fv pr pr proof follows straightforward induction structure corollary type soundness closed process 
suppose ok implies ty type 
suppose ok 
pr proof applying theorem ok 
theorem ok 
assumption ty fv 

ty theorem obtain pr implies pr lemma 
lemma pr required 
intuitively sentence corollary means channels created reductions corollary implies order guarantee property su ces define consistency condition ok ok wf inv inv ev 
corollary obtain various type systems 
example obtain variant linear channel type system 
ev ev 
guaranteed channel 
examples section 
note generic type system reasoning properties described non negative formulas deadlock freedom property described non negative formula show section obtain type system deadlock freedom instance generic type system show soundness corollary basic theorems section 
applications show variety type systems arity mismatch check race detection static garbage channel collection deadlock detection obtained instances generic type system 
common properties shown section small amount extra necessary define instance prove correctness 
table shows invariant properties processes guaranteed type systems 
condition means arity mismatch error occurs immediately 
invariant condition arity mismatch error occurs reduction means race condition output actions annotated means case input process labeled reduced channel input output 
invariance property means channel input action annotated channel longer 
safe deallocate channel implies 
implies 
implies ev 
implies 
true true table properties processes ok wf ok wf ev 
ok wf ev ev 
ok wf ev 
true true 
table consistency conditions action annotated example process 

satisfies property 
means deadlocked actions annotated sense trying perform action annotated reduced 
table shows consistency condition type system 
ok means race occurs output actions annotated reduction process 
ok means reduced action involving channel event reduced process type longer performs input output action channel 
ok means reduced process type trying perform action annotated event equal reduced channel event assume founded relation events means added new formulas express properties process types semantics defined ty type ty type ty ty soundness type systems follows immediately corollary 
theorem ok ok 
ok holds proof case suppose ok ev 

show su cient show implies ok implies negative formula corollary implies su cient condition 
case ok invariant condition ok proper consistency predicate 
suppose ok ev 

show su cient show implies ok implies negative formula corollary implies su cient condition 
case similar case 
theorem proper subtyping relation 
choosing appropriate subtyping relation type system simplify type checking type reconstruction 
example identify rule case 
naive arity mismatch check ignore order communications introducing rules 



type system deadlock freedom ok ok need choose particular subtyping relation 
proper subtyping relation subtyping relation closed rules sub divide 
deadlock freedom holds relations theorem ok ok 
ok holds corollary prove theorem described nonnegative formula 
basic theorems shown section easily prove theorem 
theorem su ces show ok imply theorems see appendix proof 
examples indicate framework existing type systems instances express expressive type systems see section 
example process 

typed type system 
earlier type systems arity mismatch check channel communicating values di erent types 
example second type system guarantees process 
race free channel linear type system calculus type system guarantee lack race conditions channels 
example fourth type system deadlock freedom rejects process 

type sub process 



order welltyped constraints satisfied ok ok 
constraint requires input succeeds event succeeds requires contradiction 
yoshida type system allows channels 
flanagan abadi type system gives guarantee :10.1.1.111.9953:10.1.1.111.9953
target calculus locks primitives problem little simpler 
type environment usual type system corresponds equivalence class process type respect relation derived appropriate subtyping relation 
recall means example type environment section corresponds equivalence class process type 



respect satisfy rules 








rule removes information order communications di erent channels 
type environment linear calculus obtained removing information channel usage adding rules 






type environment input output channel type system obtained adding rule 
applications analysis race deadlock concurrent objects type systems race deadlock freedom section powerful guarantee useful properties concurrent objects 
essence concurrent object regarded set processes provides collection services methods just sequential object set functions 
clients refer object record channels represent locations services 
giving appropriate type record enforce certain protocol clients respect 
type system capture particular temporal dependency invoked services possible guarantee race freedom accesses methods studied abadi flanagan freund deadlock freedom objects non uniform service availability studied :10.1.1.111.9953
note far properties discussed languages primitive notion objects 
section demonstrates type system guarantee properties 
describe enforce race free accesses methods 
example process waits request receiving request creates object lock method print string hello appended string exports interface reply channel 



print 
hello 
print 

method invoked concurrently clients acquire release lock invocation respectively 
ok guaranteed simultaneous outputs exported interface clients access object type 
string want output hello hello 
abbreviates meaning tuple arbitrarily processes 
assume subtyping relation satisfies string unary tuple type notation string stands string 
process type 
string means lock acquired input method invoked output method argument pair string reply channel lock released output reply object sent note tuple type string refers lock free variable making possible express temporal dependency passed method body reply channel client atsushi 
naoki 
typed atsushi 
naoki 

type interface roughly corresponds object type string unit abadi flanagan type system means method invoked lock object acquired :10.1.1.111.9953:10.1.1.111.9953
unfortunately type system expressive theirs respects 
example shows channels representing lock method guarded lock created type system lose dependency channels 
see section possible remedy problem 
similarly express non uniform service availability type system 
example process creates place bu er 
put get 

put 
get 

put get methods put get provided available alternately 
ok guarantee invocations methods put get get deadlocked 
interface put get type put get put 
get 

says output put come parallel output get 
abbreviates 
set events occurring program 
means allowed wait arbitrary events value 
put 
get 


put 

get 


typed get deadlocked put 
get 
get 


put 


type checking reconstruction theorem formalize common part type check reconstruction algorithms reading typing rules bottom manner develop algorithm inputs process expression outputs process type set subtype constraints consistency conditions type 
pair process type set constraints principal sense process typeable set constraints output algorithm satisfiable 
algorithm essentially half existing type reconstruction algorithm 
complete type check reconstruction algorithm required develop algorithm solve constraints process types 
definitions subtype relation consistency condition vary algorithms developed instance 
prototype implementations literature 
section mainly discuss common part definition principal typings algorithm compute 
principal typings define notion principal typings type system 
principal typing defined pair process type including process type variables set constraints process type variables possible process types process expression typed obtained process type pair replacing process type variables constraint constraint satisfied 
define principal typings introduce countably infinite set process type variables ranged extend definition process types process type variables expressions definition extended process type set process types extended follows 
metavariable denotes set constraints form fv ok 
notation write substitution non extended process types tuple types process type variables tuple type variables respectively 
write ftv ftv sets process tuple type variables appearing free respectively 
principal typings defined follows 
definition principal typing pair extended process type set constraints principal typing process satisfies conditions 
chosen dom ftv ftv satisfied 
exists substitution hold 
pt pt pt pt pt pt pt pt pt 
pt pt 
pt 
fresh pt 
pt 
fv fresh pt pt ok fv algorithm pt algorithm compute principal typings theorem easy derive syntax directed typing rules combining sub original ones 
reading syntax directed typing rules bottom manner obtain principal typing algorithm takes process expression input outputs principal typing 
algorithm pt shown 
theorem pt principal typing proof structural induction discussions variety type systems obtained instances generic type system course general obtain kinds type systems 
major sources limitations type system way processes abstracted way consistency condition ok types formalized 
limitations caused abstraction information channel creation lost process types recall rule new obtain type systems guarantee properties channels created 
overcome limitation extent introducing process type new means process behaves creating channels 
limitations caused formalization ok obtain common properties useful proving type soundness section required consistency condition ok invariant condition recall definition 
requirement strong 
example suppose want guarantee property channel output input 
kind requirement arises example ensuring safe locking :10.1.1.10.9481
note property invariant condition input immediately 
way overcome limitation annotate channel creation history reductions parameterize ok history 
limitation comes side condition ok rule new operation causality simultaneously created channels directly controlled 
restriction abadi flanagan type system concurrent objects deal case object lock separately created 
way remove restrictions mentioned add type annotation form channel creation primitive 
specifies newly created channels combination channels 
example 


means new channel created output lock acquired released 
extension requires substantial amount change type system proof subject reduction 
need replace typing rule channel creation wf fv new rule allows specify causality new channels channels 
may change reductions need fix reduction semantics subject reduction property holds 
example rule new replaced rule show case case 
left formalize extensions elegantly 
symmetric treatment input output processes remarked section rules asymmetric sense information continuation receiver process transfered sender process vice versa 
useful propagate information reverse direction 
example consider process sync 
sync 
sync 
sub processes synchronize channel sync input output 
order obtain information need put type process sync 
information output synchronization process 
sync 
type form 
sync 

achieved represent input process types output process types form 



describes information continuation input process type system section describes information continuation output process 
new typing rules output input 



sym fv 



sym sub processes example typed follows 
sync 

sync 
sync sync 

extensions useful extensions 
combining type system polymorphism existential types useful 
expect polymorphism introduced similar manner pierce sangiorgi polymorphic calculus 
type soundness proofs type inference issues studied interesting formalize aspects type systems generic type system 
typed process equivalence especially important hard study specific type systems 
interesting extension generalization target language 
replace calculus process calculus milner action calculi type systems process calculi discussed uniformly 
related general framework type systems previous proposals general framework limited amount shared developing concrete type systems ii general account advanced type systems :10.1.1.111.9953
honda aims develop general theory type systems various process calculi focuses specific process calculus calculus aims develop general theory various type systems calculus 
viewed theory type systems calculus honda framework restrictive 
example framework deals call additive systems composability processes determined solely channel wise compatibility deal properties deadlock freedom inter channel dependency important 
honda developed type theory calculus viewpoint denotational semantics opposed study generic type system operational point view left study di erent approaches related 
konig framework type systems type environments change reduction process 
deal dynamically changing properties linearity 
target calculus expressive calculus express dynamic creation channels 
pottier proposes framework type systems join calculus :10.1.1.111.9953
main focus general study type inference join calculus presence ml style polymorphism 
type system guarantees basic type soundness property arity mismatch error 
type systems viewing types processes mentioned section idea expressing types processes inspired previous type systems calculus 
development generic type system motivated observation underlying ideas proofs type systems similar shared 
genericity technical novelty generic type system compared previous type systems express order communications di erent channels directly ccs processes previous type systems smaller process calculus outlined section 
extension observed section generic type system analyze properties concurrent objects 
inspired rehof proposed variant type system 
type system types represented fragment ccs type system includes hiding channel creation operator 
di cult extend types hiding operator type system 
main focus type system checking senders receivers channel agrees communication protocol order senders receivers communicated channels focus type system checking channel wise behavior processes process su ers race deadlock condition particular channel 
di erence resulted slightly di erent formalization type systems 
particular chooses open simulation relation specific subtyping relation shows model checker check subtyping relation 
previous type systems process structures express types 
yoshida type system guarantees certain deadlock freedom property successors uses graphs express order communications 
type system specialized particular property condition corresponding consistency condition strong guaranteeing deadlock freedom 
example graph type corresponding type environment 


type system 
nielson nielson ccs process terms express behavior cml programs 
analysis approximates set channels channel called region suitable analyses deadlock freedom see reason race detection linearity analysis identity channel important 
process terms types type systems deadlock freedom related properties concurrent objects 
briefly outlined section type system guarantee properties having concurrent objects primitives 
gordon je rey proposed type system checking correspondence assertions 
primitives asserting protocol asserting protocol introduced calculus type system checks execution preceded 
check property introduced channel types form ch 
expresses information receiver channel may perform actions 

type system subsumed generic type system extending syntax types express channel type ch 

alternatively assertion mentions single name assertion encoded ordinary output 
order automatically obtain soundness type system soundness generic type system need extend rules channel creation discussed section 
interpretation mentioned section generic type system viewed kind interpretation framework sense properties programs verified reasoning versions programs 
viewpoint contribution novel formalization specific subclass interpretation calculus satisfactory general interpretation framework developed authors knowledge type system 
novelty conventional interpretation uses denotational semantics claim soundness analysis type system uses operational semantics convenient analyses concurrent processes 
studies interpretation calculus quite di erent generic type system 
interpretation maps process process analyzes behavior generic type system maps process multiple process types introduced analyzes behavior analysis performed compositional manner 
non standard type systems sequential languages standard type systems functional languages type system keeps track shape value information order value communication channel case accessed 
nonstandard type systems analyzing properties studied guarantee safe usage resources memory files 
type systems resource usage analysis inspired generic type system 
proposed general type system concurrent processes types expressed processes 
shown variety non trivial type systems obtained instances correctness proved uniform manner 
includes study general version type soundness theorem section extensions generic type system discussed section give complete account existing type systems calculus 
applications type system programming languages verification systems 
generic type system useful theoretical framework design type system analyzing specific properties programs deadlock race conditions basis constructing general purpose program verification tool properties verified specified formula process logic introduced section 
generic type system suitable complete type inference non determinism choice rule need restrict type system allow programmer explicitly declare type information goal 
need study model checking algorithm type formula process logic checks type satisfies formula 
acknowledgments andrew gordon jakob rehof useful discussions comments 
anonymous referees useful comments suggestions 
amadio cardelli 
subtyping recursive types 
acm transactions programming languages systems september 
cardelli gordon 
anytime modal logics mobile ambients 
proceedings acm sigplan sigact symposium principles programming languages pages 
chaki rajamani rehof 
types models model checking message passing programs 
proceedings acm sigplan sigact symposium principles programming languages pages 
pottier :10.1.1.111.9953
join constraint type inference join calculus 
proceedings th european symposium programming esop volume lecture notes computer science pages 
springer verlag 
cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
proceedings acm sigplan sigact symposium principles programming languages pages 
deline fahndrich 
enforcing high level protocols low level software 
proceedings acm sigplan conference programming language design implementation pages 
deline fahndrich 
adoption focus practical linear types imperative programming 
proceedings acm sigplan conference programming language design implementation 
fahndrich aiken 
program analysis mixed term set constraints 
proceedings sas volume lecture notes computer science pages 
springerverlag 
feret 
occurrence counting analysis pi calculus 
electronic notes theoretical computer science volume pages 
elsevier science publishers 
flanagan abadi :10.1.1.111.9953
object types races 
concur volume lecture notes computer science pages 
springer verlag 
flanagan abadi :10.1.1.10.9481
types safe locking 
proceedings esop volume lecture notes computer science pages 
flanagan freund 
type race detection java 
proceedings acm sigplan conference programming language design implementation pages 
foster aiken 
flow sensitive type qualifiers 
proceedings acm sigplan conference programming language design implementation 
fournet gonthier 
reflexive cham join calculus 
proceedings acm sigplan sigact symposium principles programming languages pages 
freund mitchell 
type system object initialization java bytecode language 
acm transactions programming languages systems 
gay 
sort inference algorithm polyadic calculus 
proceedings acm sigplan sigact symposium principles programming languages pages 
gordon je rey 
typing correspondence assertions communication protocols 
theoretical computer science 
appear 
preliminary version appeared seventeenth conference mathematical foundations programming semantics mfps elsevier entcs 
gordon je rey 
authenticity typing security protocols 
proceedings th ieee computer security foundations workshop csfw pages 
ieee computer society press 
hennessy 
information flow vs resource access information asynchronous pi calculus 
proceedings icalp volume lecture notes computer science 
springer verlag july 
honda 
composing processes 
proceedings acm sigplan sigact symposium principles programming languages pages 
honda 
theory types calculus 
november 
available www dcs ac uk kohei 
honda vasconcelos yoshida 
secure information flow typed process behaviour 
proc 
european symposium programming esop volume lecture notes computer science pages 
springer verlag 
honda yoshida 
uniform type structure secure information flow 
proceedings acm sigplan sigact symposium principles programming languages pages 
igarashi kobayashi 
type reconstruction linear pi calculus subtyping 
information computation 
igarashi kobayashi 
resource usage analysis 
proceedings acm sigplan sigact symposium principles programming languages pages 
jones 
pi calculus semantics object design notation 
proceedings concur lecture notes computer science pages 
springer verlag 
kobayashi 
partially deadlock free typed process calculus 
acm transactions programming languages systems 
kobayashi 
type system lock free processes 
information computation 
kobayashi 
time regions ects resource usage analysis 
proceedings acm sigplan international workshop types languages design implementation pages 
kobayashi pierce turner 
linearity pi calculus 
acm transactions programming languages systems 
kobayashi saito 
implicitly typed deadlock free process calculus 
proceedings concur volume lecture notes computer science pages 
springer verlag august 
kobayashi yonezawa 
foundations concurrent object oriented programming types language design 
theory practice object systems 
konig 
generating type systems process graphs 
proceedings concur volume lecture notes computer science pages 
springer verlag 
konig 
analysing input output capabilities mobile processes generic type system 
proceedings icalp volume lecture notes computer science 
springer verlag 
milner 
communication concurrency 
prentice hall 
milner 
polyadic calculus tutorial 
bauer brauer schwichtenberg editors logic algebra specification 
springer verlag 
milner 
calculi interaction 
acta informatica 
nielson nielson 
higher order concurrent programs finite communication topology 
proceedings acm sigplan sigact symposium principles programming languages pages 
leroy 
type analysis uncaught exceptions 
proceedings acm sigplan sigact symposium principles programming languages pages 
pierce sangiorgi 
typing subtyping mobile processes 
mathematical structures computer science 
pierce sangiorgi 
behavioral equivalence polymorphic pi calculus 
journal association computing machinery jacm 
pierce turner 
concurrent objects process calculus 
theory practice parallel programming sendai japan nov volume lecture notes computer science pages 
springer verlag 
peter 
changeable interfaces promised messages concurrent components 
proceedings acm symposium applied computing pages 
vasconcelos 
typing non uniform concurrent objects 
proceedings concur volume lecture notes computer science pages 
stirling 
modal temporal logics processes 
logics concurrency volume lecture notes computer science pages 
kobayashi 
generalized deadlock free process calculus 
proc 
workshop high level concurrent language volume entcs pages 

talpin jouvelot 
polymorphic type region ect inference 
journal functional programming 

talpin jouvelot 
type ect discipline 
information computation 
tofte 
talpin 
implementation call value lambda calculus stack regions 
proceedings acm sigplan sigact symposium principles programming languages pages 
vasconcelos honda 
principal typing schemes polyadic calculus 
concur volume lecture notes computer science pages 
springer verlag 

automatic determination communication topologies mobile systems 
proceedings th international symposium static analysis sas volume lecture notes computer science pages 
springer verlag 
yoshida 
graph types monadic mobile processes 
fst tcs volume lecture notes computer science pages 
springer verlag 
yoshida berger honda 
strong normalization calculus 
proceedings ieee symposium logic computer science 
appendix proofs theorems proof subject reduction theorem theorem lemma proof induction structure 
lemma inversion suppose 
exist 
exist 




exist 





exist 

fv 

exists ok fv 

exists proof immediate fact type derivation application rule corresponding form followed zero applications rule sub 
lemma defined proof induction derivation case analysis rule 
show main base case cases easy 
case ter com 



subcases 
show subcase rule ter com finishing subcase 
subcase easy 
lemma wf wf wf 
proof suppose wf hold 
exist 



lemma repeatedly 







contradicting assumptions wf wf 
lemma substitution proof straightforward induction derivation lemma proof structural induction derivation case analysis rule 
show interesting cases cases easy 
case free lemma exist ok 
rule par loss generality assume free null 
third condition definition ok 
rule new 
easy show rule sub case lemma rule par rule sub proof theorem induction derivation case analysis rule 
case com 



lemma subtyping rules exist 



fv 
wf case show calculation fv lemma rule par finishing case 
case par lemma exist induction hypothesis show wf contradiction 
suppose wf hold 
wf hold means wf hold 
wf 
induction hypothesis exists rules ter skip ter par ter sub rule par finishing case 
case new show subcase cases similar 
lemma exists ok fv 
wf wf assumptions wf lemma 
induction hypothesis exists lemma ok 
easy show implies fv fv fv 
rule new finishing case 
case sp immediate lemma induction hypothesis 
proof theorem show properties lemma 
conditions hold 



true 




proof definition 


property follows straightforward induction derivation subtyping relation 
proofs properties similar 
check necessary condition theorem 
lemma ok ok ok holds 
proof proof proceeds founded induction suppose ok 

su ces show true true show case 
case 
similar 
lemma theorem 
ok exists set ok 
fv 

definition ok exist true true case 


theorem lemma required 
case theorem lemma 


induction hypothesis required 
proof theorem follows immediately lemma theorem 

