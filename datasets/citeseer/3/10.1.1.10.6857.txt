error free garbage collection traces cheat get caught matthew hertz stephen blackburn eliot moss kathryn darko dept computer science university massachusetts amherst ma cs umass edu hertz moss programmers writing large rapidly growing number programs object oriented languages java require garbage collection gc 
explore design evaluation gc algorithms quickly researchers simulation traces object allocation lifetime behavior 
brute force method generates perfect traces heap gc potential gc point program 
process prohibitively expensive researchers traces collecting periodically bytes allocation 
extend state art simulating gc algorithms ways 
systematic methodology results effects trace granularity variety copying gc algorithms 
show trace granularity distorts gc performance results compared perfect traces gc algorithms sensitive effect 
second introduce measure performance new precise algorithm generating gc traces times faster brute force method 
algorithm called merlin frequently timestamps objects uses timestamps dead objects reconstruct precisely died 
performs periodic garbage collections achieves high accuracy low cost eliminating reason traces 

languages lisp smalltalk garbage collection gc dramatic increase people writing programs java modern languages seen correspond supported nsf itr ccr nsf aci nsf eia darpa darpa ibm 
opinions findings recommendations expressed material authors necessarily reflect sponsors 
dept computer science university texas austin austin tx mckinley cs utexas edu dept computer science university new mexico albuquerque nm darko cs unm edu ing surge gc research 
number studies object lifetime traces simulations examine effectiveness new gc algorithms 
traces tune garbage collection profile feedback :10.1.1.43.9229
demand traces sufficient gc research community discussing standard file format enable sharing traces 
producing perfectly accurate traces currently time consuming process benchmarks spec jess spec javac spec jack brute force method producing traces require month trace performs heap collection allocation point 
reduce cost people traces generate collecting bytes allocation 
unfortunately researchers studied effects granularity garbage collection simulations 
research better methods approximating traces research study effects approximations 
show traces produce significantly different results 
past research simulation traces may problematic 
result suggests new requirement standard trace format include information recording accuracy granularity trace 
address efficiency problems brute force method accuracy problems traces propose merlin trace generation algorithm 
merlin algorithm frequently timestamps live objects uses timestamps reconstruct time object died 
uses timestamps collections identify time death new algorithm require frequent collections 
normal collections identify objects died uses timestamps identify died 
ordering dead objects latest timestamp earliest algorithm works current time backwards 
determines object alive saving trace generator having process object 
avoiding frequent collections merlin algorithm run faster brute force approach 
perfect tracing efficient obviates need tracing 
remainder analyzes effects trace granularity gc simulation fidelity number gc algorithms introduces merlin trace generation algorithm 
section gives background garbage collection gc traces trace granularity 
section describes experimental methodology analyze effects trace granularity 
section presents results granularity analysis section discusses results 
section introduces new trace generation algorithm describes improves existing algorithm 
section presents analyzes results new tracing algorithm 
section presents related studies section summarizes study 

background concepts central understanding research garbage collection garbage collection traces garbage collection trace granularity 
garbage collection garbage collection automates reclamation objects needed heap 
wide variety systems garbage collectors assume system uses implicit free environment explanations simpler command allocates objects free command 
object removed heap gc collector determines object longer reachable 
additional information gcs know objects program garbage collector conservatively collects objects determines program reach 
determine reachability gcs program roots 
roots contain pointers outside heap heap program stack static variables 
objects heap transitive closure pointers unreachable 
object unreachable remains unreachable updated objects safely removed heap 
heap collection collector determines reachability object removes unreachable objects 
collectors generational collectors collect part heap limiting collection 
collector reclaims unreachable objects conservatively assume regions heap examined contain live objects 
objects unexamined region point objects examined region target objects remain heap 
objects region examined collectors write barriers find pointers collected region 
write barriers instrumentation invoked pointer store operation 
write barrier typically tests pointer target region collected region containing pointer source records pointers data structure 
assume pointer store instrumented write barrier 
systems assumption true root pointers stack 
case enumerate root pointers potential gc point expensive heap collection optimized techniques cheng :10.1.1.43.9229
copying garbage collection algorithms copying garbage collection algorithms evaluation semi space collector fixed nursery generational collector variable sized nursery generational collector older collector 
briefly describe reader unfamiliar gc literature 
semi space collector ss allocates space bump pointer 
runs space collects entire region finding reachable objects copying second space 
collector reverses space continues allocating 
objects space may live reserve half total heap space generational collectors generalize collector 
fixed nursery fn generation collector divides space heap nursery older generation 
allocates nursery 
nursery full collects nursery copies live objects older generation 
repeats process older generation full 
collects nursery older generation copies survivors space older generation 
variable size nursery collector vn divides space nursery older generation fix boundary 
steady state nursery fraction space fills vn copies live objects older fraction 
new nursery size reduced size survivors 
nursery gets small vn collects space 
older collector organizes heap order object age 
collects fixed size window slides heap older younger objects 
steady state heap full collects window returns free space nursery compacts survivors positions window collection objects just younger survived 
window bumps allocation point resets window oldest heap 
need reserve space size window collection 
garbage collection traces garbage collection trace chronological recording object allocation heap pointer update object death object unreachable execution program 
events include information memory manager needs processing 
processing object allocation requires identifier new object memory needs pointer update records include object field updated new value object death records define object unreachable 
events comprise minimum amount information gc simulations need 
simulators single trace file analyze number different gc algorithms optimizations applied single program run 
trace contains information garbage collector access live execution events collector may required act independent specific gc implementation 
traces record aspects program execution 
researchers simulate single implementation garbage collector traces number different languages 
reasons gc simulators useful prototyping evaluating new ideas 
garbage collection deterministic simulations return exact results number metrics 
accurate trace files input results gc simulator relied making simulation attractive accurate traces critical 
garbage collection trace generators integrated memory manager interpreter virtual machine program runs 
program compiled stand executable compiler back generate code trace gen obvious generalization generations applies 
optimizations collectors may need additional information added trace file majority simulations need process 
gc algorithms information assume minimal information 
eration ordinary memory management code object allocation point pointer update 
trace log pointer updates instrumenting pointer store operations instrumentation particularly easy language gc implementation write barriers simply instruments write barriers 
reachability analysis heap program root set determines object deaths 
common brute force method trace generation determines reachability performing heap garbage collection 
garbage collector marks processes exactly reachable objects objects unmarked unprocessed collection unreachable trace generator produces object death records 
perfectly accurate trace analyze program point trace garbage collection invoked 
gc algorithms collection may needed memory may need reclaimed immediately allocating new object assuming object allocation triggers gc 
brute force trace generators expense collecting entire heap prior allocating object 
simulated gc algorithms allow frequent garbage collection invocations reachability analyses undertaken 
frequent reachability analyses difficult stress place system expose errors interpreter virtual machine 
garbage collection trace granularity common alternative generating perfect traces perform reachability analysis periodically 
limiting analysis bytes allocation trace generation process faster easier 
causes trace guaranteed accurate specific points rest time may estimate set live objects 
simulation assume objects unreachable accurate points 
granularity trace period moments accurate death knowledge 
trace granularity related time appropriate unit measurement depends gc triggered 
collectors perform garbage collection memory exhausted natural measure granularity number bytes allocated accurate points trace 

experimental design section describes methodology evaluating experimentally effect trace granularity simulating copying garbage collectors 
start describing simulator programs 
describe deal granularity simulation 
simulator suite trace granularity experiments gc sim gc simulator suite university massachusetts front ends smalltalk java traces 
simulator implemented different garbage collection algorithms ss fn vn described section 
collectors widespread 
collector simulated different space sizes times maximum size live objects heap increments 
fn vn simulated heap size different nursery sizes window sizes 
parameters ranged space increments 
granularity schemes designed implemented different schemes handle trace granularity 
schemes works independently simulated gc algorithm 
explore limits trace granularity affecting collections occur 
began research simulator naive approach handling trace granularity call method 
simulations allow gc occur time trace collections simulated natural collection points garbage collection algorithm heap nursery full 
scheme allows simulator run algorithm designed consider trace granularity determining collect 
simulations may treat objects reachable object death record reached trace object unreachable 
allow gc algorithm perform collections natural points unconstrained granularity input trace 
schemes call synchronized simulate garbage collection invocations trace points accurate knowledge unreachable objects 
schemes check garbage collection needed needed soon accurate points perform collection points 
shows schemes collection decisions 
figures solid line natural collection point algorithm 
triangles denote points perfect knowledge 
shaded region large granule trace 
scheme performs collection point trace perfect knowledge shaded region 
point shown arrow labeled scheme call 
shows decides collect 
point perfect knowledge simulator determines natural collection point reached period equal granule trace forces gc invocation 
performs collection natural point reached 
simulations may perform extra garbage collections natural collection point occurs trace point perfect knowledge 
ensures simulated heap grow bounds 
second scheme 
shows decides collect 
point perfect knowledge computes natural collection point occurred preceding time granule trace invokes garbage collection 
collects natural point reached 
simulations may gc times natural collection point occurs point perfect knowledge trace 
allows heap nursery grow nominal bounds points perfect knowledge enforces bounds collection completed 
scheme 
shows decides collect 
forces gc invocation point perfect knowledge natural collection point half trace granularity past 
requires collection point perfect knowledge closest natural collection point 
doing simulations try balance times invoke collections early late achieve results close average 
simulations may perform may perform fewer garbage collections 
points perfect knowledge simulations may require heap nursery grow nominal bounds 
heap bounds enforced immediately collection 
sync schemes decides collect 
triangles denote points trace perfect knowledge 
natural collection point shown solid line labeled shaded region large granule trace shows region garbage collection allowed 
gc forced point trace perfect knowledge shaded region shown arrow labeled 
trace granularity results section data analysis results 
gc simulation metrics garbage collection simulation measure number metrics number collections invoked mark cons ratio number interesting stores space time product 
metrics consider deterministic simulators quite accurately return results 
mark cons ratio number bytes collector copied divided number bytes allocated 
ratio serves measure amount done copying collector 
higher mark cons ratios suggest algorithm need time process copy objects 
metric report number interesting stores program run 
garbage collectors collect entire heap write barrier find pointers region currently collected mentioned section 
write barrier instruments pointer store operations determine pointer garbage collector needs knowledge 
number pointer stores cost instrument vary program run number pointer stores remembered varies gc algorithms run time affect performance 
measure space time product 
directly related time required algorithm measures important resource space 
metric sum number bytes objects heap allocation point multiplied size allocation integral number bytes objects heap respect time measured bytes allocation 
number bytes allocated vary different algorithms metric measures algorithm manages size heap program execution 
metrics necessarily sufficient determine algorithm performs 
algorithms perform better metrics expense 
importance considering totality data seen models developed combine data determine total time algorithm needs 
gc traces gc traces study 
traces jalape jvm know jikes rvm compiler run time system java implemented trace generator 
java traces bloat bloat bloat source code input different configurations olden health spec compress jess raytrace db javac jack 
gc traces university massachusetts smalltalk virtual machine 
smalltalk traces lambda fact lambda fact tomcatv tree tree replace binary 
information traces appears table 
implemented filter takes perfect traces target value outputs traces targeted level granularity 
generated perfectly accurate traces programs filter generated versions trace granularity ranging kb kb 
simulator perfect traces input 
analysis began simulating combinations program trace trace granularity granularity scheme gc algorithm space nursery window size 
record metrics combination 
table shows example simulator output 
large population data approximately simulations gc granularity scheme combination perform detailed statistical analysis results 
analysis remove simulation required fewer garbage collections 
simulations gcs addition removal single collection create dramatically different effects furthermore garbage collector rarely difference program total running time 
reasons results rarely included actual gc implementation study 
remove simulation trace granularity equaled simulated space size trace granularity obviously impact results 
prune cases data claims granularity important 
addition include simulations perfect trace trace completed 
occasionally simulations trace complete merely simulator expanded heap delayed collection accurate point 
simulations traces finish garbage collection invoked earlier normal causing objects promoted 
metrics generated simulations finish incomplete include analysis 
number experiments remaining kb granularity ss vn fn 
number valid simulations vary kb granularity 
kb granularity fewer simula program description max 
live total alloc bloat bloat bytecode level optimization analysis tool source code input olden health health market simulator olden benchmark suite recoded java spec compress compresses decompresses mb data lempel ziv method 
specjvm spec jess expert shell system nasa clips 
specjvm 
spec raytrace scene memory buffer 
specjvm 
spec db performs series database functions memory resident database 
specjvm 
spec javac sun jdk compiler 
specjvm 
spec jack generates parser java programs 
specjvm 
lambda fact untyped lambda calculus interpreter evaluating 
standard church numerals encoding lambda fact untyped lambda calculus interpreter evaluating 
standard church numerals encoding tomcatv vectorized mesh generator garbage collected heap simulator tree replace random builds binary tree replaces random subtrees fixed height newly built subtrees tree replace binary builds binary tree replaces random subtrees newly built subtrees table traces experiment 
sizes expressed bytes 
gc num alloc alloc copy copy mark con xcp cp mut 
gc perfect trace gc num alloc alloc copy copy mark con xcp cp mut 
gc kb granularity table simulator output fixed sized nursery simulation health 
top lines metrics collections differences obvious bottom lines final results simulation 
tions 
numbers continue drop granularity increases kb granularity fewer half number usable simulations lowest granularity 
goal experiment determine trace granularity affects gc simulations 
aggregate remaining data normalize trace simulation results results simulation perfect trace identical configuration 
order results low high balance logarithm ratio 
metric combination garbage collector granularity scheme performed tailed tests aggregated results 
convention considered differences confidence level higher statistically significant result random fluctuations 
test finds results significantly higher confidence level expect experiment repeated similarly traces time means repeated experiments larger results generated perfect traces 
similar argument exists results test determine significantly lower 
table shows smallest granularity kilobytes observe statistically significant difference combination collector metric simulation method 
programs smaller space nursery window sizes obviously sensitive trace granularity 
just removed simulations granularity half space size re ran analysis traces point live objects equal largest trace granularity 
excluded programs small brute force algorithm generate perfect traces hours 
traces remaining analysis brute force tracing need generate traces 
number remaining simulations ranged ss kb granularity vary kb granularity counts decrease simulations 
results analysis shown table 
trace granularity discussion data table quite revealing effects trace granularity usefulness different schemes handling traces 
data clear traces distorts gc performance results compared perfect traces 
majority metrics granularity kilobyte cause distortion 
clearly trace granularity significantly affects simulator results 
results collections dramatically distort simulation results 
table collectors ss statistically significant differences metric kb granularity 
cases traces copied bytes needed gcs space 
collectors differences significant confidence level higher meaning expect similar results experiments 
generational collectors fare better 
collectors saw traces producing significantly higher mark cons ratios perfect traces 
expect distortions grew trace granularity 
simulations collections may come inaccurate points trace garbage collector process copy objects reachable trace reached set death records 
copied objects increase space time prod ss fn vn ss fn vn ss fn vn ss fn vn mark cons space time num 
gcs int 
stores table earliest granularity kb metric significantly different simulation method collector 
differences tested tailed test confidence level 
ss fn vn ss fn vn ss fn vn ss fn vn mark cons space time num 
gcs int 
stores table earliest granularity kb metric significantly different simulation method collector 
differences tested tailed test confidence level 
table considers data traces maximum live size mb uct cause heap full sooner require frequent gcs 
process small granularities quickly produce significant differences 
number interesting stores generational collectors number collections required vn immediately affected 
significantly pointers older generation nursery collections tend promote objects truly unreachable pointer updates 
expect simulations larger heaps affected issues 
results table show true 
spacetime product mark cons results ss show objects staying heap longer 
vn simulations see significant increase number collections extra objects require collector perform heap collections just nursery collections 
collection number collections remains similar results perfect traces producing significantly higher mark cons ratio 
matter collection algorithm simulations clearly distort results 
result suggests new requirement trace file format clearly label points trace perfect knowledge 
results simulations tend require slightly higher granularities producing significant distortions 
scheme significantly distorts results metric collector 
examining results table table reveals patterns 
considering traces produce differences simulations perfect traces slightly larger trace granularities may required differences statistically significant 
cases significant distortions appear result collector metric dependent 
addition statistically significant distortions traces granularities small kb 
table considering traces larger maximum live sizes simulations provide better estimates results simulating perfect traces 
exist significant differences fairly small granularities 
simulations affect collections occur copy unreachable objects merely object deletion record reached 
adjusting collection point causes problems 
objects allocated death records occur natural collection point collection point initially affected 
depending scheme objects may removed heap processed copied earlier simulation perfect traces 
heap error containing objects possible differences compounded simulation may collect points away different collection decisions simulation perfect traces 
just simulations small initial differences snowball 
simulations tend decrease space time products increase number gcs interesting stores mark cons ratios versus simulations perfect traces 
smaller granularities fn produces higher space time products 
normally fn copies objects nursery time die collection 
exacerbates situation collecting earlier copying objects older generation similar simulations perfect traces 
trace granularity grows result disappears simulations show significant distortions expected direction number points trace perfect knowledge limits number possible gcs 
similar opposite manner simulations tend decrease mark cons ratio number collections 
trace granularity increases distortions pronounced number potential collection points begins limit collectors 
collector produces distortion metric 
fn produces significantly higher mark cons ratios garbage collections small granularities 
simulations allow copy fewer objects early copying fewer objects causes collector delay collections 
heap collections remove unreachable objects older generation prevent forcing copying unreachable objects nursery 
collector eventually promotes unreachable objects perform heap collections soon ery collection boosting mark cons ratio number gcs 
best results 
table larger space sizes produce similar results sync mid simulations simulations perfect traces large granularities 
design tries balance times collects early times collects late 
result tends balance collections distorting results direction collections distorting results 
benefit effects trace granularity hard predict 
showed collector dependent behavior 
showed sound base new unknown collector results assumption effect metrics 
simulations comparison produced biases dependent metric collector 
significant differences occur clear way metric skewed 
results single metric collector returned results statistically significant distortions 
trace granularity clear trace granularity significant impact simulated results garbage collection algorithms 
traces compare measure new gc algorithms optimizations clear way traces confidence results valid 

merlin trace generation life understood backwards lived forwards 
ren section new merlin trace generation algorithm generates perfect traces times faster dominant brute force method trace generation 
speed generate perfect traces merlin algorithm removes need traces avoids issues cause 
merlin algorithm advantages brute force trace generation 
discussed section implementing algorithm difficult 
brute force gc code completely error free system support heap garbage collection 
new trace generator garbage collection algorithm stresses system 
legend wizard merlin began life old man lived backwards time dying time birth 
merlin knowledge experienced 
merlin tracing algorithm works similar manner 
computes object died backwards time time merlin trace generation algorithm encounters object calculation time object death possible death times earlier running program merlin processing need considered 
merlin mythical character trace generator works reverse chronological order decision revisited 
remainder section overviews merlin computes objects transition reachable unreachable gives detailed explanation merlin works discusses implementation issues 
method finding object allocations pointer updates similar description describe works merlin algorithm 
merlin algorithm overview merlin algorithm improves brute force trace generation computing objects reachable objects unreachable 
knowing moment object reachable death time object easily determined time advances discrete steps death time object time interval immediately object reachable 
computing time objects reachable merlin needs perform occasional garbage collections saving substantial 
find objects reachable stamp objects current time may transition reachable unreachable objects may lose incoming 
object loses incoming earlier update leave unreachable merlin simply overwrite previous timestamp current time 
suppose system runs performing occasional garbage collections 
consider situation immediately gcs 
collector determines objects unreachable may live 
tracing purposes need compute exactly unreachable objects reachable 
timestamps compute times 
consider dead object latest timestamp 
object reachable time reachable pointed object timestamp latest time 
consider pointers dead object latest death time 
objects target pointers reachable time stamped original object 
propagate reachable time object objects points 
fact propagate reachable time dead object objects points propagate 
prevent infinite propagation cycles algorithm simply stops object reachable time equal reachable time source object 
processing completed object latest timestamp objects reachable time 
remove set dead objects consider latest timestamp remaining objects 
reachable time arguments apply iteratively determine time object gc unreachable 
merlin details implementation previous section provides overview merlin section presents detailed discussion merlin algorithm works discusses implementation issues 
discussed section finding objects dead requires reachability analysis 
new algorithm change requirement improves previous brute force method computing instant object reachable 
compute objects reachable merlin algorithm small amount program runs trace accurate performs frequent gcs trace generation 
system invokes gc merlin algorithm works backward time find exactly object garbage collector unreachable reachable 
brute force trace generation death record appended trace ob objects reachable incoming removed 
object reachable incoming removed 
objects reachable action affect incoming 
ject unreachable 
objects dead trace generator find objects unreachable 
separating computing objects reachable objects unreachable saves merlin substantial amounts requires time trace generation 
trace add death records specified object reachable time 
time related trace granularity time advance object death records may occur points trace perfect knowledge 
objects unreachable understand merlin algorithm works backward time compute object reachable important understand objects unreachable 
table series generalizations objects heap transition reachable unreachable 
scenarios table describe object reachable action involves object scenario describes object reachable directly involved action 
clearly pointer stores time object reachable object unreachable pointer store transitive closure set object lost incoming 
finding potential reachable times knowing objects transition reachable unreachable concept time possible find objects reachable time 
clear pointer store time object reachable pointer update leaves object incoming clear pointer update time object reachable update leaves object remaining incoming clear object continues reachable just counting number incoming counting sufficient determine reachable times 
paragraphs consider different methods objects transition reachable unreachable merlin pseudo code compute reachable times 
instrumented pointer stores pointer stores instrumented write barrier 
objects may reachable pointer store caught write barrier removes incoming 
merlin trace generator stamps object losing incoming old target pointer current time 
time increases monotonically object ultimately stamped final time loses incoming 

object transitions zero incoming pointer update 
objects examples case 

object transitions incoming pointer update unreachable objects 
example case object 
object number incoming change reachable objects pointing unreachable 
objects labeled examples case 
table objects unreachable coming removed instrumented pointer store merlin code shown stamps object time reachable 
uninstrumented pointer stores root pointers may pointer stores instrumented 
object reachable root pointer update may time transitions reachable unreachable detected instrumentation 
just normal gc begins root scan trace generator performs modified root scan trace accurate 
modified root scan enumerates root pointers merely stamps objects current time 
root referenced objects stamped current time object reachable root pointer update timestamp hold time object reachable 
shows merlin pseudocode executed root scan enumerates pointer 
referring objects unreachable compute time object reachable objects unreachable object pointing unreachable scenario table 
chains objects updating reachable time object requires recomputing reachable times objects points 
simplify process noting object reachable time latest reachable time object containing transitive closure set 
computing objects unreachable merlin algorithm concerned object reachable determine object unreachable issue find single method computes object reachable time 
methods figures timestamp correct reachable time objects reachable described scenarios table 
combining timestamping methods computing reachable times membership transitive closure sets merlin determine reachable time object 
demonstrate combined method works consider scenario table 
object continues point object reachable described scenario table reachable object member transitive closure set 
reachable time merlin computes object timestamp 
reachable time computed object reachable scenario table time stamped 
object reachable timestamp updated 
objects point unreachable pointing objects reachable times 
transitive closure computation determine object reachable time stamped 
show combined method computes reachable times objects reachable scenario table merlin compute reachable times combining timestamping computing transitive closures need know object transitioned reachable unreachable 
computing death times efficiently computing full transitive closure sets time consuming process requiring time 
finding object reachable time requires knowing latest object containing object transitive closure set 
formally computing transitive closure sets merlin performs depth search object propagating reachable time forward objects visited search 
save time merlin begins ordering objects earliest timestamp latest pushing search stack latest object popped 
shows initialization 
removing object stack merlin algorithm analyzes fields find pointers objects 
pointed object unreachable stamped earlier time referring object pointed object stamped time 
object definitely unreachable pushed stack timestamp updated 
pointed object time equal referring object cycle pointed object stack propagate time 
way pointed object need pushed stack 
pointed object time object remained reachable time propagated possible reachable time unimportant 
pushing objects stack earliest stamped time latest means object processed 
search proceeds latest stamped time earliest examinations object computing earlier reachable times 
method finding reachable times requires nlog time sorting objects limiting factor 
shows code merlin algorithm uses modified depth search 
merlin trace generator described far merlin able reconstruct objects reachable 
unable determine objects longer reachable needs reachability analysis 
merlin algorithm uses simple solutions overcome 
possible delays computation immediately garbage collection 
memory cleared trace generation algorithm access objects heap garbage collector reachability analysis 
piggy backing saves lot analysis 
times program terminates garbage collection may invoked algorithm needs reachability analysis 
stamp root referenced objects current time compute reachable times object heap 
objects reachable time equal current time reachable program roots alive 
objects unreachable death records added trace 
method finding unreachable objects enables merlin algorithm garbage collector 
garbage collector guarantee collect unreachable objects program terminates merlin performs combined object reachability reachable time analysis find unreachable objects reachable times 
stated section rely couple assumptions host gc 
unreachable object gc treating live objects points treated live required gc algorithms 
object removed heap objects pointing removed 
second merlin algorithm assumes pointer stores involving unreachable object 
assume object unreachable incoming outgoing constant 
preconditions important transitive closure computation languages java smalltalk satisfy 
order merlin trace generator adds information trace issue 
discussed section trace generator needs concept time determine trace object death record placed 
object death records added trace chronological order writing trace disk appended trace postprocessing step placing trace proper order 
holding trace records memory object deaths difficult challenge larger traces holding records require significant amounts memory 
implementation merlin algorithm uses external post processing step sorts integrates object death records 
way handling issue advantages disadvantages adds little time trace generation 
object allocations pointer updates trace generation efficient finding reporting object allocations pointer updates 
discussed section brute force method trace generation find record actions linear time 
new algorithm instruments host system memory manager determine memory allocated new objects 
times merlin records ongoing object allocation 
finding reporting pointer updates change 
brute force trace generation merlin algorithm instruments heap pointer store operations preferably augmenting existing write barriers 
new trace generation algorithm add additional requirement reasons explained section 
brute force trace generator requires access object updated new value pointer old value pointer 
write barriers implemented access values write barrier capable counting additional requirement 
allowing trace generator garbage collector requiring semi space collector instrumentation record pointer updates easier add 
semispace collector require write barrier algorithms generational collectors 
specific languages systems require write barrier reasons 
combining trace generator algorithms allows existing write barriers enabling merlin trace generator leverage code 

evaluation merlin implemented merlin brute force trace algorithm jikes virtual machine 
performed initial timing runs macintosh power mac mhz processors kb chip data instruction caches kb stack object object object object processing object processing object stack object object object object processing object stack object object object object computing object death times ti ti 
object doesn incoming merlin computation change timestamp 
object reachable timestamp care needed reachable time change processing incoming 
object processed finding pointer object object timestamp earlier object added stack reachable time set 
process object find pointer object 
object earlier timestamp added stack timestamp updated 
object processed 
object pointed earlier timestamp added stack 
cycle finished processed 
remaining objects stack examined processing needed 
void address source address address source null timestamp currenttime source code merlin pointer store instrumentation void address address null timestamp currenttime code merlin root pointer processing void time sort unreachable objects earliest timestamp latest push unreachable object stack earliest timestamp latest stack empty object obj stack pop time obj timestamp field obj field obj field null object target obj field time target timestamp target target timestamp stack push target code merlin trace generation reachable time computation speedup perfect merlin tracing log speedup perfect merlin tracing brute force tracing perfect granularity brute force trace log spec compress mb spec javac mb spec jack mb health speedup merlin versus brute force trace generation 
note log log scale 
unified cache mb chip cache mb memory running ppc linux 
processor experiments run single user mode network card disabled 
built versions vm algorithms 
possible identical code jvms merlin implemented semi space collector 
merlin running time spent largely performing modified root scan required accurate point trace 
improved merlin running time including number optimizations minimize number root pointers enumerated locations 
optimization instrument pointer store operations involving static global pointers 
instrumentation merlin need enumerate static pointers accurate point instrumentation marks objects lose incoming static fields 
java allows functions access stack frame repeated scanning method enumerates objects pointers method frame 
implemented stack barrier called frames popped stack enabling merlin scan stack deep reduce time needed merlin tracing :10.1.1.43.9229
improve brute force tracing optimizations merlin tracing 
generated traces different granularities small range programs 
time required brute force trace generation limited traces initial megabytes data allocation 
working common benchmarks generating traces identical granularity merlin achieved speedup factors 
time brute force needed generate traces kb granularity merlin generated perfect traces 
shows speedup merlin generating perfect traces achieves brute force algorithm generating traces different levels granularity 
clearly merlin greatly reduce time needed generate trace 
seen speedup granularity increases 
time required depends time needed generate object death records trace granularity 
brute force limits object death time processing trace accurate granularity increases time needed greatly diminishes 
merlin needs perform periodic collections perform small set actions pointer update location trace perfect knowledge 
brute force performing frequent gcs cost merlin frequent root enumerations updating timestamps great 
results promising speed performance merlin tracing algorithm 
program memory footprint grows accurate points needed merlin algorithm far affected brute force 

related know previous research effects trace granularity different methods generating garbage collection traces 
section discuss research study draws roots 
knowledge belady optimal virtual memory page replacement policy min decided blocks paged disk analyzing events 
decision point min algorithm considers memory accesses stored available file determines single block evict 
algorithm cache results decision point min algorithm begins new analysis 
belady algorithm knowledge events perform optimally processes events chronological order 
time invoked min algorithm looks far necessary current decision 
cyclic counting earliest methods garbage collection counts object count incoming count reaches object freed 
appreciate approach collect cycles objects counts reach zero 
different schemes developed deal cycles 
trial deletions collects cycles objects removing pointer thought cycle 
removing pointer trial deletion updates counts 
updating counts source object removed pointer unreachable cycle exists objects dead 
dead cycle may exist deleted pointer reestablished original counts restored 
method handle detect cycles may incorrectly guess objects cycle take advantage object reachability analyses 
merlin perform explicit counting marks objects lose incoming 
generally counting methods properly determine cycles objects unreachable 
methods trial deletion developed avoid problem methods guarantee determine object unreachable addition processing object 
merlin opposed counting allows requirements met 
lifetime approximation cope cost producing gc traces previous research approximating lifetimes objects 
approximations model object allocation object death behavior actual programs 
described mathematical functions model object lifetime characteristics actual lifetime characteristics smalltalk java programs 
zorn grunwald compare different models approximate object allocation object death records actual programs 
study attempted generate actual traces study consider effects pointer updates studies attempted find ways trace generation produce input memory management simulations 

summary traces garbage collection simulation raises number issues 
develop method variable affects garbage collection simulations statistically tested 
method show wide range variables traces produce results significantly different produced perfect traces 
additionally show ways simulating traces better minimizing issues 
results propose changing trace format standard include additional information 
introduce describe merlin trace generation algorithm 
show merlin algorithm produce traces times fast common brute force method trace generation 
generating traces merlin generate perfect traces time previously required traces 
merlin algorithm trace generation quick easy eliminates need traces 
acknowledgments john developing gc sim aaron cass help processing data 

alpern attanasio barton burke cheng choi cocchi fink grove hind hummel lieber litvinov ngo mergen sarkar serrano shepherd smith sreedhar srinivasan whaley virtual machine 
ibm systems journal feb 
alpern attanasio barton cocchi hummel lieber mergen ngo shepherd smith implementing java 
proceedings sigplan conference object oriented programming languages applications denver oct vol 
acm sigplan notices acm press pp 

appel simple generational garbage collection fast allocation 
software practice experience 
belady study replacement algorithms virtual storage computer 
ibm systems journal 
blackburn hertz mckinley moss pretenuring java 
proceedings sigplan conference object oriented programming languages applications tampa fl oct vol 
acm sigplan notices acm press pp 

cheng harper lee generational stack collection profile driven pretenuring :10.1.1.43.9229
proceedings sigplan conference programming language design implementation montreal canada june vol 
acm sigplan notices acm press pp 

chilimbi jones zorn designing trace format heap allocation events 
ismm proceedings second international symposium memory management minneapolis mn oct vol 
acm sigplan notices acm press pp 

collins method overlapping erasure lists 
communications acm dec 
counter method 
communications acm sept 
experimental statistics 
department commerce washington dc 
nystrom bytecode level analysis optimization java classfiles 
master thesis purdue university west lafayette may 
kolodner sagiv effectiveness gc java 
ismm proceedings second international symposium memory management minneapolis mn oct vol 
acm sigplan notices acm press pp 

mckinley moss age garbage collection 
proceedings sigplan conference object oriented programming languages applications denver oct vol 
acm sigplan notices acm press pp 

mckinley moss models object lifetimes 
ismm proceedings second international symposium memory management minneapolis mn oct vol 
acm sigplan notices acm press pp 

ungar generation scavenging non disruptive high performance storage reclamation algorithm 
proceedings acm sigsoft sigplan software engineering symposium practical software development environments pittsburgh pa apr vol 
acm sigplan notices acm press pp 

ungar jackson adaptive policy generational 
acm transaction programming languages systems jan 
garbage collection exercise distributed fault tolerant programming 
phd thesis university washington seattle wa jan 
zorn grunwald evaluating models memory allocation 
tech 
rep cu cs university colorado boulder boulder july 
zorn comparative performance evaluation garbage collection algorithms 
phd thesis university california berkeley berkeley ca mar 
