low bandwidth network file system muthitacharoen lcs mit edu chen lcs mit edu mit laboratory computer science technology square cambridge ma usa david mazi res dm cs nyu edu department computer science new york university broadway room new york ny usa 
wireless devices connected low bandwidth low capacity networks 
mobile users rarely consider running network file systems wireless devices performance may unacceptable efficient remote file access desirable situations 
presents lbfs network file system designed low bandwidth networks 
lbfs exploits similarities files versions file save bandwidth 
avoids sending data network data server file system client cache 
technique lbfs achieves orders magnitude reduction bandwidth utilization common workloads compared traditional network file systems 
lbfs provides close open consistency afs howard 
files reside safely server closed clients see server latest version open file 
consequently lbfs reasonably place network file systems breaking software disturbing users 

design save communication lbfs uses large persistent file cache client 
designed lbfs assumption clients cache contain user entire working set files reasonable assumption today storage technology 
aggressive caching client server communication purpose maintaining consistency 
lbfs reduces bandwidth requirements considerably exploiting cross file similarities 
takes advantage fact chunks data appear multiple files multiple versions file 
examples range auto save files generated editors small modifications large files users object files output compilers small source changes 
lbfs server indexes file system including deleted files able find chunks data hash values 
lbfs client similarly indexes large persistent file cache 
lbfs transfer file client server recognizes chunks data recipient files avoids sending chunks network 
target file recreated chunks file system client cache 
remainder section describe lbfs protocol indexes 
indexing order chunks multiple files recipient lbfs considers non overlapping chunks files avoids sensitivity shifting file offsets chunks 
lbfs bases chunk boundaries file contents position file 
insertions deletions affect surrounding chunks 
similar techniques successfully past segment files purposes detecting unauthorized copying brin 
lbfs uses rabin fingerprints rabin determine chunk boundaries file 
rabin fingerprint data chunk computed performing polynomial modulo chunk predetermined irreducible polynomial 
lbfs computes rabin fingerprint overlapping bytes file 
low order bits fingerprint equal constant value bytes producing fingerprint constitute chunk called breakpoint 
rabin fingerprints efficient compute moving window file making easy lbfs incrementally scan divide files 
breakpoints set value bit fingerprints assuming random data expected chunk size bytes plus size break point window bytes 
avoid pathological cases lbfs imposes minimum maximum chunk size respectively 
artificial suppression creation breakpoints disrupt synchronization file chunks versions file 
risk occurs lbfs perform better ordinary file system 
fortunately synchronization problems typically result stylized files instance repeated sequences breakpoint files conventional compression 
lbfs rpc traffic gets conventionally compressed pathological cases necessarily translate slow file access 
lbfs client indexes chunks files cache 
indexes chunks bit rabin fingerprints 
tree stores mappings fingerprint cache file offset chunk size 
similarly server maintains tree mapping fingerprints files file system offsets chunk sizes 
client server set polynomials create chunk indexes 
rabin fingerprints low non negligible probability collision 
cryptographic hash sha verify validity data chunk fingerprint matches 
chose index fingerprints sha hashes reasons 
rabin fingerprints cheaper compute smaller store 
second recomputing sha time chunk anyway lbfs allows file system chunk database sync 
permits file system served lbfs updated locally server back 
saves server performing expensive synchronous disk operations concern database crash recovery 
protocol lbfs protocol built top nfs version 
new rpcs introduced cond write 
lbfs client currently performs file caching 
user opens file file local cache cached version date client issues rpc request vector triples 
client look fingerprints chunk index verify corresponding chunks sha hash match avoid transferring data 
requests issued cover large file 
transferring dirty file server client issues rpc 
server replies temporary file handle 
step essential reasons 
guarantee reconstruction dirty file server side atomic 
atomic updates limit potential damage simultaneous writes 
second importantly previous version file chunks common current version 
temporary file allows lbfs utilize chunks 
write content temp file handle client issues cond write rpcs similar nfs write rpcs rpcs arguments contain fingerprint sha hash actual data written 
server find chunk returns special error code 
client issue normal write rpc actual data 
rpc commits temporary file copying contents original file 

implementation client server implemented user level 
lbfs client implemented xfs device driver bundled danielsson file system 
server side lbfs server implemented nfs 
nfs client effectively translating lbfs requests nfs 
client server communicate tcp connection sun rpc 
extended existing rpc library compress authenticate encrypt stream rpc traffic client server 

evaluation ran experiments lbfs 
common operations editing documents compiling software lbfs consume orders magnitude bandwidth popular nfs file system 
measuring application performance nfs runs slower mbit sec wavelan compared mbit sec mode 
lbfs performance identical low high bandwidth links 
brin davis garcia molina 

copy detection mechanisms digital documents 
proceedings acm sigmod international conference management data pp 

howard kazar menees nichols satyanarayanan sidebotham west 

scale performance distributed file system 
acm transactions computer systems 
rabin 

fingerprinting random polynomials technical report tr 
center research computing technology harvard university 
danielsson 

free afs client 
proceedings usenix freenix track 
new orleans la 
