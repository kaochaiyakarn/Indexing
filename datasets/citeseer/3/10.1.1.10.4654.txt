vol 
verification object oriented programs invariants mike barnett robert deline manuel hndrich rustan leino wolfram schulte microsoft research redmond wa usa object invariant defines means object data consistent state 
object invariants central design correctness objectoriented programs 
defines programming methodology object invariants 
methodology enriches program state space express object invariant holds deals owned object components ownership transfer subclassing expressive allow interesting object oriented programs specified verified 
lending sound modular verification methodology provides solution problem determining state method allowed modify 
writing maintaining software difficult error prone part requires coping details 
mechanical programming tools relieve burden 
example important pervasive tool type checker allows programmer describe broad brush terms set values program variable take 
descriptions type checker mechanically checks reads writes program variables ensure variable takes forbidden value 
type checker usually built compiler checks details 
example compiler may check variable preceded assignment read variable changed initial assignment variables declared certain scopes certain access modifiers referenced inappropriate places 
successful detail management techniques common programmer formulates condition supposed hold leaves details enforcing condition mechanical tool 
consider object oriented programs focus object invariants 
object invariant specifies relation object data programmer intends hold 
object invariants detect prevent data corruption errors misuse data 
ultimately interested leaving detail management object invariants mechanical tool doing requires determine methodology object invariants 
idea objects steady states satisfy certain data invariants goes back cite article follows mike barnett robert deline manuel hndrich rustan leino wolfram schulte verification object oriented programs invariants journal object technology vol 
pages www fm issues issues verification object oriented programs invariants hoare data representation correctness 
putting idea practice eiffel language constructs specifying object invariants familiar design contract design methodology decades 
seminal systems limits 
example hoare considered object model include useful modern object oriented languages 
eiffel checks object invariants dynamically run time typically exit public methods 
test suite dynamic checks catch errors shall see approach permit programmer assume object data consistent entry public method 
fact know previous methodology modern object oriented language provides useful guarantees object invariants hold peter ller phd thesis 
ller methodology builds top special type system universe type system captures hierarchy layered abstractions commonly employed designed programs 
object level hierarchy said objects level 
methodology invariant object holds modeled boolean function object data 
develop methodology reasoning object invariants 
ultimately re interested static verification programs methodology dynamic checking 
methodology leverages program hierarchy abstractions type system purpose 
methodology tracks ownership relations precisely permits ownership transfer 
variable function object data models object invariant holds ller methodology esc modula methodology uses independent variable indicates object invariant known hold 
opens possibility precisely formulating program invariants methodology guarantees conditions hold program reachable state 
recognizing declarations object data divided subclass hierarchy methodology allows separate reasoning level subclass 
section motivate central design decision methodology 
subsequent sections build full methodology section explains basic idea methodology considering individual objects section adapts basic idea accommodate aggregate objects section model detailed support subclasses 
section considers specification methods methodology provide new solution notorious problem specify pieces program state method may modify 
give additional examples section describing related giving 
object invariants information hiding tension object invariants information hiding led important design decision methodology explicitly represent object journal object technology vol object invariants information hiding class private int invariant public public method modifies assert class private int public ensures public method requires modifies ensures assert simple program object invariant routine specifications 
program object invariant changed various pre postconditions 
invariant known hold expose information specifications 
explain rationale design start considering popular shall see problematic view object invariants 
shows simple program consisting class data fields constructor method program declares object invariant routine method constructor specification spells contract callers implementation 
routine specification consists parts precondition describes states caller allowed call routine postcondition describes states implementation allowed terminate modifies clause lists variables implementation allowed change 
see modifies clause states method allowed modify omitted pre postconditions default true omitted modifies clause defaults empty list variables 
addition listed modifies clause routine implicitly allowed modify fields newly allocated objects objects allocated start routine 
treat object constructed newly allocated constructor constructor allowed modify assert statement gives condition expected hold execution reaches statement 
program erroneous reach assert statement condition evaluates false implementation method assert statement represent condition programmer may want rely rest implementation fact rely condition 
vol journal object technology verification object oriented programs invariants popular view object invariant simply shorthand postcondition constructor pre postcondition public method 
idea view object invariant hold object publicly visible 
view appropriate combined faulty regime callers methods need concerned establishing implicit precondition associated invariant 
invariant class hold entries public methods sufficient restrict modifications invariant methods method establish invariant postcondition 
regime permits method violate object invariant duration call long reestablished returning caller 
method body atomic problem 
illustrate problem consider scenario slight variation assignments separated call routine 
assume calls note time called object invariant object certain hold 
calls assert statement break 
prevents situation regime lets callers ignore object invariant induced preconditions regime lets implementations rely preconditions hold entry 
reasoning faulty callers implementations held pre postcondition contracts 
particular implicit precondition induced invariant considered caller 
pre postconditions explicit mistake apparent 
shows previous example program object invariant shorthands expanded 
larch notation pre postconditions introduced keywords requires ensures respectively 
expressing invariants explicit pre postconditions raises new problem object invariant class condition internal representation objects details concern client party responsible establishing precondition 
making clients responsible establishing consistency internal representation breach information hiding practices 
short prudent object invariants completely hidden information hiding boundaries representation details object invariants completely exposed 
want clients aware object invariant holds implementation having reveal details invariant 
achieve potentially conflicting goals methodology introducing publicly available abstraction invariants hold 
note analogous problem exists modifies clauses modifies checking 
want clients aware method may change internal state journal object technology vol validity implementation having reveal details internal state return issue section 
validity section introduce basic concepts methodology explicit representation object invariants known hold 
ignore subclassing 
object introduce special public object field st state type invalid valid st invalid say object invalid st valid say valid 
intent st object invariant hold object valid 
field special allowed appear routine specifications invariant declarations implementations 
implementation modify value st new statements pack unpack object allocated invalid state 
class object type define predicate holds state object invariant declared holds state 
example program define precise meaning pack unpack expression type pack assert null st invalid assert st valid unpack assert null st valid st invalid pack statement checks object invariant changes st invalid valid unpack statement changes st valid invalid st field public mentioned explicitly routine specifications particular preconditions public methods 
shows program written st denote method constructor implicit receiver parameter 
constructor postcondition says constructed object valid exit 
method precondition states clients expected call valid objects 
modifies clause include st follows st valid return method 
validity precondition applies callers scenario considered earlier assignments separated call mutually recursive routine longer problematic call object vol journal object technology class private int invariant public ensures st valid pack verification object oriented programs invariants public method requires st valid modifies assert unpack pack simple class object invariant 
special field st routine specifications detail object expected valid 
pack unpack statements arranged fields updated invalid objects 
really valid 
known object valid case error manifests failure establish precondition requires precondition object valid case error manifests failure establish precondition 
note asserted condition mentions follow literally precondition mentions st remember intent st valid object invariant hold need impose restrictions sure case 
restrict field updates change field cause object invariant longer hold 
simplest restriction think ban field updates valid objects 
impose restriction field update statement permitted states st invalid holds 
field updates restricted methodology imposes restrictions reading fields 
second need restrict pieces program state object invariant allowed depend 
restrict object invariant part state depend fields object invariant described 
restriction liberal 
said prove induction structure program statements program invariant condition holds reachable program state proposition system section class st invalid ranges non null objects type journal object technology vol components consequently method infer st valid object invariant holds know asserted condition holds 
way consequence assert statement comes unpack statement fact object valid unpack means object invariant holds unpack change object invariant holds just unpack summary introduced special field st statements pack unpack update st prescribed new objects invalid restricted field updates invalid objects restricted contents object invariants 
return rely program invariant reachable program state 
components object oriented systems usually built hierarchy layered abstractions object layer implemented terms component objects lower layer 
example buffered input stream may implemented terms cache file reader cache may implemented array indices file reader may implemented file handle set configuration values 
layered designs lend better separation concerns promote reuse 
program correctness may depend just relations fields object relations fields object fields component objects 
stating object invariants possible restrictions imposed previous section 
allow object invariant mention indirect access expressions need tackle problems shall discuss context declarations class private invariant public method requires st valid unpack class public int public method requires st valid consider update invalid object type valid object update may cause invariant broken invalid 
arrange invalid prevent unpacked regard state packing put committed state changed back unpacking committed state indicates object invariant holds object unique owning object case 
vol journal object technology 
verification object oriented programs invariants second consider call method call precondition st valid establish 
way establish condition add condition precondition fact uses field type internal implementation detail mentioning precondition breach information hiding practices 
note said previous paragraph validity object imply committal ll arrange unpacking take committed valid 
establish validity simply unpacking design decisions previous paragraphs appropriate holds component object 
committal fits nicely idea owns chains committed objects form hierarchy corresponds hierarchy layered abstractions 
component object methodology allow fields mentioned class object invariant 
entirely unreasonable fields non component object may change regard object object invariant mention 
encode presence components provide way identify object components 
simplicity restrict components ones accessible field object introduce field modifier rep representation identifies fields 
object invariants allowed depend field 
fi field declared modifier rep example object invariant depends allowed declared rep field rep fields need private 
private rep change type special field st invalid valid committed redefine pack unpack statements compt denote set expressions rep field expression type pack assert null st invalid assert foreach compt assert null st valid foreach compt null st committed st valid unpack assert null st valid st invalid foreach compt null st valid example class rep fields type journal object technology vol components pack defined assert null st invalid assert assert null st valid null st valid null st committed null st committed st valid previous section prescribe new objects allocated invalid state restrict field updates invalid objects 
prove program invariant proposition system section class st invalid compt null st committed ranges non null objects type proof induction structure program statements induction hypothesis includes condition says committed objects unique owners compt compt type type st committed st invalid st invalid range non null objects range types type denotes dynamic type object 
note impose restrictions copying object allowing multiple component object 
restriction time pack components values rep fields valid committed 
note methodology allows ownership transfer 
object owned different owners time 
example rep fields classes respectively distinct object types respectively code snippet starting state valid legal effect transferring component initially stored unpack unpack pack null pack code snippet shows program point immediately packing contain object legal invalid time 
vol journal object technology verification object oriented programs invariants summary introduced field modifier rep identifies components changed special field st valued type previous section valued type redefined pack unpack statements update st object components prescribe new objects invalid restrict field updates invalid objects 
return re able loosen restriction object invariants object invariant depend fields components transitively fields components 
rely program invariant reachable program state 
subclasses section extend methodology previous section handle subclasses 
idea think fields object divided class frames class root class hierarchy object object dynamic type 
illustration consider class declarations class object pre declared language various declarations 
class extends object invariant 


routine declarations 
class extends invariant 




routine declarations 
object dynamic type class frames class frame corresponding class object programmer defined fields trivial object invariant true class frame corresponding class fields object invariant may depend fields class frame corresponding class fields object invariant may depend fields 
object entirely invalid entirely valid previous sections object invalid valid class frame 
keep track subset class frames object valid 
principle consider possible subsets object class frames consider subsets correspond nonempty prefixes sequences class frames 
object dynamic type example classes subset class frames object valid subsets object object object encode values abandon journal object technology vol subclasses st field previous sections replace special fields inv committed represent subset valid class frames introduce special field inv value derived class class frame valid object 
example classes inv field object dynamic type values object representing respective subsets shown 
special field committed boolean indicates object committed 
ensure committed true inv equals dynamic type object 
division object fields class frames causes corresponding division pack unpack statements 
class immediate superclass expression type subclass define pack assert null inv assert foreach compt assert null inv type committed foreach compt null committed true inv unpack assert null inv committed inv foreach compt null committed false new encoding new objects return constructor class object state inv object committed generally constructor class typically declares postcondition inv committed methodology insist 
condition field update statement permitted slightly different presence subclasses 
updated field declared class statement permitted states sufficiently unpacked inv strict superclass allow fields declared rep modifier 
object invariant class allowed depend field declared superclasses 
fields rep field object invariant allowed depend fields transitively 
said section final version methodology prove program invariants vol journal object technology verification object oriented programs invariants theorem system section conditions program invariants committed inv type inv inv compt null committed compt compt inv inv committed quantifications ranges non null objects re denote reflexive transitive subclass relation 
proof sketch 
sketch proof full proof appendix proof shows conditions maintained program statements extend ranges quantifications allocating objects change values object fields object constructor pack statement unpack statement field update 
proof relies fact static type checking guarantees object valued expression type yields null object dynamic type subclass cases simple cases slightly involved 
proof case uses fact invariants mention access expressions form 
fn fi rep fields uses applications 
second proof case uses 
third proof case uses 
proof sketch 
summary methodology introduces field modifier rep identifies components restricts contents object invariant class depend object fields superclasses transitively fields rep fields keeps track class frames object invariant valid object committed provides statements pack unpack changing validity committal states objects prescribes new objects return object constructor uncommitted object class frame valid permits field update statements sufficiently unpacked objects guarantees program invariants hold reachable program state 
journal object technology vol routine specifications routine specifications routine specification contract callers implementations 
describes expected caller time call expected implementation time return 
describing contracts easy 
section describe innovations writing interpreting routine specifications 
innovation uses notion committed objects provide solution problem specifying state routine may modify 
second innovation provides way specification dynamically dispatched method talk object forcing implementations reason possible subclasses 
writing modifies clauses useful caller routine specification determine pieces program state may modified routine may 
tricky variables accessible declaration routine 
example variables scope eventual caller may known scope gives routine specification 
conversely variables routine implementation may private implementation details interest information hiding mentioned explicitly public routine specification 
fact layered program design implementation details contained layers abstractions may routine 
accomplish goal specifying modifications model heap objectoriented program global variable heap type dimensional array values indexed object identities field names 
example program access expression denotes particular location heap 
model location heap expression heap consequently quantify field names 
example rewrite quantification heap null heap heap committed set names rep fields seen modifies clauses specify modifications 
modifies clause gives list access expressions evaluated routine pre state gives set heap locations routine allowed modify precisely net effect routine allowed modify heap location temporarily restores original value returning 
common allow routine allocate new objects modify state cf 

special boolean field alloc denote objects allocated modifies clause said far interpreted postcondition heap old heap old old heap alloc says contents heap location unchanged heap location explicitly mentioned modifies clause object vol journal object technology verification object oriented programs invariants allocated entry routine 
account modification layers private state 
innovation allow routine modify fields committed objects 
policy lets routine modify layers private state explicitly mentioning state modifies clause 
formalize policy postcondition modifies clause heap old heap old old heap alloc old heap committed note policy lets routine modify just layers private state state object happens committed time routine called may quite liberal 
intuition policy fact liberal object committed rely object invariants say object state details state 
course order modify field object object unpacked 
routine seeks modify fields committed object arrange transitive owners unpacked owner unpacked unpack 
routine allowed net effect inv committed fields modified unpacking process routine see objects cause methodology enforce invariants objects hold 
final extension allow modifies clause mention special expressions form class name expression form type object valued expression expression denotes fields object declared class superclasses 
writing preconditions methods overrides methodology divides object state class frames allows object invariants stated maintained independently class 
flexibility comes price unpack statement needs state type unpacking 
obligation easily met giving appropriate precondition routine performs unpack example sure routine implementation execute statement unpack routine declare precondition inv having state precondition exact value desired object inv field incompatible dynamically dispatched methods 
innovation introduce special expression specification dynamically dispatched methods 
idea caller dynamically dispatched method means type implementation method class means method precondition inv caller invokes method object entirely valid having know dynamic type object 
entirely valid state example state component object journal object technology vol examples immediately owner unpacked 
implementation method class assumes entry inv allows perform unpack statement 
reasoning routine specifications sound routine specifications interpreted way callers implementations 
ostensibly idea may untenable sound reasoning 
precise scheme treating dynamically dispatched methods declaration dynamically dispatched method introduces procedure named specification method replaced type implementation class introduces procedure named specification method replaced body procedure supplied run time system looks dynamic type call calls corresponding procedure note precondition procedure follows precondition procedure type body procedure implementation modulo superclass calls immediate superclass call super 
superclass implementation replaced call procedure invocation dynamically dispatched method replaced call procedure scheme relies existence certain procedures impose restriction programs class supply implementation dynamically dispatched method declared class superclass 
implementations course consist just call super 
code sequence unpack super 
pack scheme treating dynamically dispatched methods really quite close actual implementations methods note specification procedure interpreted way callers body achieve sound reasoning 
having introduced specification dynamically dispatched methods stand type particular class name allow expressions form modifies clauses 
section show specifications 
examples readers shows reader input stream produces characters 
different subclasses reader draw characters different sources example file reader draws characters file file system array reader draws characters character array memory cf 

getchar method returns reader characters encoded integers 
reader supply characters exhausted vol journal object technology verification object oriented programs invariants class reader public reader ensures inv reader committed public method getchar int requires inv committed modifies ensures result 
example class reader getchar method produces characters 
getchar returns 
reader class shows typical specifications methodology constructor dynamically dispatched method postcondition getchar specific method 
constructor postcondition says constructed object valid class reader caller constructor subclass constructor gets know state object perform pack statement 
caller client invokes new reader client gets know state object invoke method requires inv equal dynamic type object 
state required order pack object uses reader component 
method precondition allows implementation method subclass unpack object unpack operation fields object declared modified method implementation superclass called 
modifies clause allows method implementation class modify programmer defined fields object declared superclasses example method implementation invokes implementation method declared direct superclass modifies clause ensures fields calling class affected superclass call 
special fields inv committed programmer defined modifies clause implies said reader invariants call said call 
array readers shows declaration reader subclass 
array reader initialized array characters getchar method returns characters 
object invariant constraint guarantees precondition inv absence array bounds errors implementation 
important decision design constructor constructor may capture array copy array cf 

journal object technology vol examples class extends reader private rep src char private int invariant src length public source char requires source null source inv type source source committed ensures inv committed 
impl getchar int var ch int unpack src length ch ch int src pack return ch reader subclass produces characters array 
methodology decision explicit 
specification effectively forces constructor implementation copy array 
see consider attempted implementation captures array super src source pack code meet constructor specification modifies special field source committed false true allowed empty modifies clause 
implementation allowed specification changed include modifies source committed case caller alerted retain ownership array 
note caller may retain array contrast linear type systems alias example long owned 
lexers lexer reader example lexer produces stream tokens stream characters see 
vol journal object technology verification object oriented programs invariants class lexer private rep rd reader invariant rd null public lexer reader reader requires reader null reader inv type reader reader committed modifies reader committed ensures inv lexer committed super rd reader pack lexer public method token requires inv committed modifies var token unpack lexer 
var ch int rd getchar 
pack lexer return lexer consumes characters produces tokens 
constructor specified allow implementation capture reader 
detlefs methodology allows field rd private need exposed public interface 
methodology allows lexer client retain reader passes lexer constructor harmless reader committed caller rely reader fields unchanged routine invocations 
modifies clause allows fields lexer modified explicitly list modifications causes fields underlying reader 
modifications allowed rd committed entry point lexer class include method relinquishes underlying reader 
useful client method relinquish reader uncommitted state effectively means lexer needs give ownership reader 
possible method declaration lexer left inconsistent state relinquishing reader putting lexer state invoked 
note necessary implementation set rd null journal object technology vol examples class names string selection int invariant selection length names public method bool 
class extends bool invariant length length names impl bool 
class subclass invariant depends field superclass 
doing may idea achieve garbage collector performance 
public method reader requires inv committed modifies inv ensures result null result inv type result result committed unpack lexer return rd final methods final example consider tricky issue related methods dynamically dispatched called final methods 
discuss final methods supported methodology 
consider classes 
objects class nonempty list files file system index list denote currently selected file 
class provides method determining current selection directory 
subclass additional list keeps track files directories order provide efficient implementation 
note invariant subclass depends field declared subclass field declared superclass names 
consider method designer designated final public final method requires inv committed unpack selection pack vol journal object technology verification object oriented programs invariants code verify precondition inv method particularly useful callers 
typical situation caller variable type knows inv type dynamic type strict subclass caller unknown amount unpacking invoking method 
alternatively precondition inv type burden unpacking rest method implementation 
number required unpack operations change inv type unknown 
situation easier may consider new statements pack unpack follows public final method requires inv type committed unpack selection pack idea unpack statement object entirely valid state inv type immediate superclass pack statement reverse packing object back entirely valid state 
unpack statement unproblematic pack statement needs check invariants declared classes dynamic type object 
checking invariants requires having information invariants poses problem modular verification possible dynamic types object known 
restricting invariants depend necessary know exact details invariants 
example need know invariants strict subclasses depend selection field 
restrict fields modified unpack statement pack statement just needs check invariant class 
example private fields class modified risk breaking invariants strict subclasses subclasses access private fields mention private fields invariants 
allow non private fields modified long fields marked special declaration says depended invariants strict subclasses cf 

problem illustrated subsection may just technical difficulty methodology 
reflection bringing important issue design object oriented software final methods give subclasses chance augment method behavior accommodate subclass invariants prudent final method modify fields subclass known depend modifications occur invocations methods 
existing programming languages eiffel includes invariants restrictions final methods modify application methodology points problem 
general inv field specify kinds conditions preconditions example 
precondition inv appropriate dynamically dispatched journal object technology vol related methods call superclass implementations method tool fugue methods kind behavior called sliding methods 
doing course means able unpack order update fields 
second precondition inv type appropriate methods implementations unpack object call methods second kind 
third precondition inv particular class appropriate private protected subclasses subroutines class methods may may call subroutines superclasses invoke dynamically dispatched methods second kind 
modifies clauses kinds methods type respectively 
having programming language provide labels methods kinds uses programmer intends may idea actual verification object invariants interest 
related methodology draws main lines research 
draws methodology developed extended static checker modula esc modula 
esc modula methodology encodes object invariants invariant condition represented programmer declared boolean field valid meaning defined function object state representation declaration 
routine specifications mention object valid field explicitly 
main difference methodology field valid changes implicitly sync update state representation valid fact program updates field valid fields transitive owners change 
contrast methodology uses auxiliary variable inv permits distinguish object states particular invariant hold object states invariant allowed violated 
allow field updates unpacked objects arrange owning objects unpacked owned objects unpacked change field occur times possibly affected object invariants allowed violated 
difference methodology easily allows subclass extend invariant declared superclass 
similar comparison methodology ller methodology draws inspiration esc modula methodology improves example providing proof soundness 
second line research methodology draws vault fugue building research alias types separation logic 
components methodology correspond closely existentially bound store fragments systems 
pack unpack operations correspond existential elimination 
approaches state invariants explicit pre postconditions 
typestates fugue extend invariants handle subclasses include notion sliding methods 
invariants fugue simpler span vol journal object technology verification object oriented programs invariants multiple class frames 
modifies clauses fugue contain implicit permissions granted components generally expressive 
advantage methodology article requires special separation logic 
result currently amenable mechanical theorem provers order logic 
desire avoid representation exposure unwanted aliasing led line research systems control aliasing 
uniquely owned components seen variation systems 
systems control aliasing static type system ownership transfer harder achieve 
important difference systems combined methodology guarantee properties detailed object invariants 
universe types associated methodology proving object invariants ller thesis prevent problems drastic restrictions methodology 
ller system allowed read pointers object invariant guarantees see 
formulation modifies clauses takes advantage component structure needed invariants 
needs flexibility specifying heap locations may modified routine explicit data groups conjunction approach 
considered various effect systems object oriented programs 
huizing kuiper consider proof system object oriented programs object invariants 
relying ownership confine access expressions may mentioned invariants system uses declared invariants classes determine method may violate invariants 
limits verified modularly 
system invariants objects hold method boundaries consider strong restriction 
java modeling language jml specification language java programs includes object invariants 
jml combines design contract approach eiffel model specification approach larch 
eiffel compiler jml compiler turns jml specifications run time checks 
tool jml family extended static checker java esc java checks jml specifications statically 
esc java uses heuristics determine object invariants check method invocations 
described detail esc java user manual heuristics compromise flexibility likelihood errors guarantee soundness 
banerjee naumann consider means formally exported interface class independent implementation class may rely object invariants 
semantic results sound presence call backs just goes establishing antecedents theorems left unaddressed 
object language clu uses types distinguish external view object internal representation view 
program convert views operations correspond pack unpack statements 
clu journal object technology vol methodology formalized leaves absence certain errors rep exposure refers unwanted sharing underlying data structure responsibility programmer 
wills outlines object oriented programming system type invariant holds 
formalization allows distinction type possibility object invariants violated course method 
thesis identifies problems aliasing modifies clauses leaves full solutions 
previous version slightly general treatment components current presentation rep chosen simplicity :10.1.1.10.4654:10.1.1.14.7406
leino ller extended methodology allow invariants kinds data structures including cyclic data structures 
barnett naumann provide extension lends specifying verifying programs including common subject view pattern 
update guard allows programmable level abstraction conditions object invariant depend 
unpack pack operations object invariants ways similar acquire release operations monitor invariants concurrent program 
monitor invariant known hold thread executing monitor acquire release operations 
provided monitors thread reentrant java net monitor invariant known hold entry monitor checked hold exit monitor 
interesting investigate adaptation methodology concurrent programming example methodology provides support reasoning object see methodology concurrent programming ownership 
object oriented programming untenable treat object invariants implicit pre postconditions completely hide preconditions callers 
order useful clear programmer program points object invariant relied 
enriching program state space auxiliary variables say object invariants relied object invariants allowed violated methodology provides programmers flexible precise way specify intentions object invariants 
methodology organizes objects hierarchy owned components surprising liberal confining object aliases 
object components protected aliased freely copied 
restriction object valid owner time enforced time pack operations 
methodology restricts field updates restrictions reading fields object 
knowledge state object invariants values read vol journal object technology verification object oriented programs invariants object fields may meaningless reasoning program correctness 
methodology programs look verbose pack unpack statements routine specifications mention inv committed explore syntactic sugar useful defaults making programs concise 
defaults may instance take advantage fact public dynamically dispatched methods tend precondition inv type committed implementations tend consist block code bracketed unpack pack statements 
explicit primitives accommodate exploration variations extensions methodology 
short provided modular verification methodology object oriented programs sound sufficiently expressive deal object invariants sacrificing proper data encapsulation 
currently implementing checker supports methodology look forward putting methodology test checking invariants existing microsoft code 
participants formal techniques java programs workshop comments discussion 
ernie cohen listening ears bus helped improve presentation material 
dave naumann sriram rajamani referees provided useful comments previous versions 
soundness appendix give full proof soundness theorem 
proof theorem 
proof shows conditions maintained program statements extend ranges quantifications allocating objects change values object fields object constructor pack statement unpack statement field update 
case object constructor 
object constructor sets committed false newly allocated object establishing 
sets inv object establishes just true class object object invariant 
similarly class object rep fields empty set constructor establishes 
case pack statement 
committed pack statement sets true corresponding precondition entirely valid 
precondition inv condition type follows fact static type checking ensures dynamic type type subclass static type checks static type subclass invariant pre state imply committed pack statement maintains program invariant 
journal object technology vol soundness statement precondition guarantees changing inv immediate superclass maintains 
statement sets committed true non null component class maintained 
prove maintenance consider instantiation consider cases 
suppose committed false pre state pack statement 
inv compt holds pre state 
antecedent holds post state refer object pack statement object inv field changed consequent holds post state 
second suppose committed true pre state 
antecedent precondition pack statement conclude refers object pack statement invoked 
antecedent change maintained 
case unpack statement 
program invariant maintained unpack statement changes committed true false changes inv uncommitted object 
program invariants maintained statement weakening effect predicates 
maintenance note statement changes committed true false compt arguments unpack statement 
statement changes inv falsify antecedent remains proved satisfying compt committed changed statement 
program invariant pre state concludes proof 
case field update 
field update statement change special fields inv committed maintains 
field declared class consider field update statement suppose statement effect means object invariant declared class mentions access expression denotes consider access expression going non null objects 
access expression object invariant form 
gn rep fields 
gn declared classes 
mn 
gj convenience mn synonym precondition update statement implies inv mn applications inv detail applications goes follows 
gj inv mj static type checking 
gj committed fact 
gj null instantiated 
gj get 
gj inv mj shows holds post state update statement proving program invariant maintained update statement 
vol journal object technology verification object oriented programs invariants field update statement change value expression compt rep field declared class precondition update statement implies inv antecedent false invariance maintained 
proof 
paulo almeida 
balloon types controlling sharing state data types 
mehmet aksit satoshi matsuoka editors ecoop object oriented programming th european conference volume lecture notes computer science pages 
springer 
anindya banerjee david naumann 
ownership confinement ensures representation independence object oriented programs 
manuscript available cs edu naumann publications december 
mike barnett robert deline manuel hndrich rustan leino wolfram schulte :10.1.1.14.7406
verification object oriented programs invariants 
susan eisenbach gary leavens peter ller arnd poetzsch heffter erik poll editors formal techniques java programs proceedings pages 
technical report department computer science eth zurich july 
mike barnett david naumann 
friends need bit maintaining invariants shared state 
mathematics program construction lecture notes computer science 
springer july 
appear 
boris jan vitek 
confined types 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla volume number sigplan notices pages 
acm october 
chandrasekhar boyapati robert lee martin rinard 
ownership types safe programming preventing data races deadlocks 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla volume number sigplan notices pages 
acm november 
john boyland 
alias unique variables destructive reads 
software practice experience may 
lilian burdy cheon david cok michael ernst joe gary leavens rustan leino erik poll 
overview jml tools applications 
thomas arts wan fokkink editors eighth international workshop journal object technology vol soundness formal methods industrial critical systems volume electronic notes theoretical computer science 
elsevier 
dave clarke tobias 
external uniqueness unique 
luca cardelli editor ecoop object oriented programming th european conference volume lecture notes computer science pages 
springer 
david clarke john potter james noble 
ownership types flexible alias protection 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla volume number sigplan notices pages 
acm october 
robert deline manuel hndrich 
enforcing high level protocols low level software 
proceedings acm sigplan conference programming language design implementation pldi volume number sigplan notices pages 
acm may 
robert deline manuel hndrich 
fugue protocol checker software baroque 
technical report msr tr microsoft research january 
robert deline manuel hndrich 
typestates objects 
ecoop object oriented programming th european conference june 
appear 
david detlefs rustan leino greg nelson 
rep exposure 
research report digital equipment systems research center july 
david detlefs rustan leino greg nelson james saxe 
extended static checking 
research report compaq systems research center december 
manuel hndrich robert deline 
adoption focus practical linear types imperative programming 
proceedings acm sigplan conference programming language design implementation pldi volume number sigplan notices pages 
acm may 
cormac flanagan rustan leino mark lillibridge greg nelson james saxe raymie stata 
extended static checking java 
proceedings acm sigplan conference programming language design implementation pldi volume number sigplan notices pages 
acm may 
aaron greenhouse john boyland 
object oriented effects system 
rachid guerraoui editor ecoop object oriented programming th european conference volume lecture notes computer science pages 
springer june 
vol journal object technology verification object oriented programs invariants john guttag james horning editors 
larch languages tools formal specification 
texts monographs computer science 
springer verlag 
stephen garland kevin jones andr jeannette wing 
hoare 
proof correctness data representations 
acta informatica 
hoare 
monitors operating system structuring concept 
communications acm october 
john hogg 
islands aliasing protection object oriented languages 
proceedings sixth acm sigplan conference object oriented programming systems languages applications oopsla 
kees huizing kuiper 
verification object oriented programs class invariants 
tom maibaum editor fundamental approaches software engineering third international conference fase volume lecture notes computer science pages 
springer 
peter hearn 
bi assertion language mutable data structures 
symposium principles programming languages pages 
gary leavens albert baker clyde ruby 
jml notation detailed design 
haim kilov bernhard rumpe ian simmonds editors behavioral specifications businesses systems pages 
kluwer academic publishers 
rustan leino 
reliable modular programs 
phd thesis california institute technology 
technical report caltech cs tr 
rustan leino 
data groups specifying modification extended state 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla volume number sigplan notices pages 
acm october 
rustan leino peter ller 
object invariants dynamic contexts 
ecoop object oriented programming th european conference june 
appear 
rustan leino greg nelson 
data abstraction information hiding 
acm transactions programming languages systems september 
rustan leino greg nelson james saxe 
esc java user manual 
technical note compaq systems research center october 
journal object technology vol soundness rustan leino arnd poetzsch heffter zhou 
data groups specify check side effects 
proceedings acm sigplan conference programming language design implementation pldi pages 
rustan leino raymie stata 
checking object invariants 
technical note digital equipment systems research center january 
barbara liskov john guttag 
abstraction specification program development 
mit electrical engineering computer science series 
mit press 
bertrand meyer 
object oriented software construction 
series computer science 
prentice hall international 
minsky 
alias free pointers 
pierre cointe editor ecoop object oriented programming th european conference volume lecture notes computer science pages 
springer july 
peter ller 
modular specification verification object oriented programs volume lecture notes computer science 
springer verlag 
phd thesis hagen 
peter ller arnd poetzsch heffter 
universes type system alias dependency control 
technical report hagen 
peter ller arnd poetzsch heffter gary leavens 
modular invariants object structures 
technical report eth zurich october 
james noble jan vitek john potter 
flexible alias protection 
eric jul editor ecoop object oriented programming th european conference volume lecture notes computer science pages 
springer july 
arnd poetzsch heffter 
specification verification object oriented programs 
technische universit nchen 
david walker greg morrisett 
alias types recursive data structures 
proceedings th workshop types compilation september 
alan cameron wills 
formal methods applied object oriented programming 
phd thesis university manchester department computer science 
vol journal object technology authors verification object oriented programs invariants mike barnett strong supporter esoteric radio stations 
learns latest hip music teenagers 
robert deline carpenter 
known carefully constructed multi level 
manuel hndrich architect dwellings minors 
combining fun safety creations stand weather 
rustan leino starving musician 
order support wife working children 
wolfram schulte 
day rides destination uphill home 
journal object technology vol 
