free bits non approximability tight results th version mihir bellare oded goldreich madhu sudan december honor shimon th birthday 
department computer science engineering university california san diego la jolla ca usa 
mail mihir cs ucsd edu 
department applied mathematics weizmann institute sciences rehovot israel 
mail oded wisdom weizmann ac il 
partially supported israel binational science foundation bsf jerusalem israel 
ibm watson research center box yorktown heights ny usa 
mail madhu watson ibm com 
continues investigation connection proof systems approximation 
emphasis proving tight non approximability results consideration measures free bit complexity amortized free bit complexity proof systems 
part presents collection new proof systems new errorcorrecting code called long code means test 
provide proof system amortized free bit complexity ffl implying approximating max clique gammaffl approximating chromatic number gammaffl hard assuming np ffl 
derive explicit reasonable constant hardness factors min vertex cover max sat max cut improve hardness factor max sat 
note non approximability factors max snp problems appreciably close values known achievable polynomial time algorithms 
note general approach derivation strong non approximability results problem reduces construction certain gadgets 
increasing strength non approximability results proof checking connection motivates ask far go proofs inherent way 
addressed second part 
recall fglss showed translate proof systems np np hardness approximation results max clique 
result novel nature essentially reverses connection showing np hardness approximation result yields proof system np 
roughly result says constant max clique nphard approximate np class fpcp log languages possessing proofs logarithmic randomness amortized free bit complexity indicates proofs inherent obtaining non approximability results 
provides tight relation indicating get large hardness factors minimize amortized free bit complexity 
third part initiates systematic investigation properties pcp fpcp function various parameters randomness query complexity free bit complexity amortized free bit complexity proof size particularly interested triviality results indicate combinations parameters powerful capture np 
distill role randomized reductions area provide variety useful transformations proof checking complexity classes 
table contents overview main results new proof systems non approximability results proofs approximation potential limitations pcp fpcp properties transforms conceptual contributions previous version current version versions background definitions new proof systems non approximability results new proof systems new non approximability results techniques proofs approximation potential limits reversing connection making proofs gaps lower bounds amortized free bits properties transforms pcp fpcp triviality results results transformations proof systems history related subsequent directions research acknowledgments notation definitions general notation definitions proof systems bellare goldreich sudan randomized reductions history new proof systems non approximability results overview preliminaries evaluation operators long code recursive verification proofs outer verifiers inner verifiers composition verifiers constant prover proofs pcp perspective atomic tests atomic linearity test atomic respect monomial basis test atomic projection test atomic circuit test max snp verifier inner verifier main application verifier application minimizing soundness error query pcp satisfiability problems max sat max sat definitions previous new results gadgets hardness maxsat maximum satisfiable linear constraints parity clauses max cut definitions previous new result gadgets hardness max cut free bits vertex cover minimizing error achievable free bits hardness vertex cover verifier establish min vc hardness minimizing number queries pcp inner verifier new proof system iterated tests linearity randomness iterated projection test free bits pcp technical claim iterated linearity test iterated rmb test putting things amortized free bits max clique coloring definitions sources improvements construction results previous coding theory bound optimality choices analysis proofs approximation potential limitations reverse connection consequences clique gap verifier main consequences consequences limitations common approaches tasks lower bound codeword test lower bound projection test lower bound combined test pcp properties transformations complexity pcp fpcp mip versus pcp query complexity amortized query complexity free bit complexity query complexity versus free bit complexity transformations fpcp systems gap maintaining amortized free bit complexity trading gap location free bit complexity effects acceptance probabilities free bit complexity list figures new pcp systems np logarithmic randomness 
approximation factors attainable polynomial time algorithms approx versus factors show hard achieve non approx 
constant prover achieving error fixed arbitrarily small constant ffl 
indicate number provers randomness answer sizes system canonical 
notation 
means don know don care stronger things available 
cases randomness answer sizes hide factors depend ffl 
atomic tests passing probabilities 
max snp inner verifier snpinner non approximability results max sat indicating factor shown hard assumption done 
max sat gadgets max sat gadgets enhanced rmb test passing probability 
free bit inner verifier inner worst case average av number queries needed get soundness logarithmic randomness results form eq 

pcp inner verifier iterated tests passing probabilities 
free inner verifier milestones project proving non approximability clique number approximation factor terms graph size infeasible achieve indicated assumption 
stating results ignore ffl terms ffl arbitrary small 
max clique problem graph find value maxclique maxf jsj clique example np optimization problem find chromatic number graph find size smallest vertex cover problems arise large varied number settings efficient solutions desired 
unfortunately important np optimization problems mentioned particular np hard solve 
algorithm designers seek efficient polynomial time approximation algorithms 
approximation algorithm delivers number supposed close optimal 
quality algorithm measured terms factor optimal delivered number 
example factor ff delta approximation max clique outputs value satisfying maxclique ff maxclique number nodes search efficient approximation algorithms achieving factors met varied success 
cases approximation algorithms 
important problems including max clique chromatic number min vertex cover escaped efforts approximated case problems reasonably case 
algorithm designers want know due inherent intractability lack cleverness algorithm design 
early non approximability results able indicate cases approximation 
achieving factors close optimal np hard 
real breakthrough came connection established proof checking approximation yielding strong non approximability result max clique 
connection years broadened deepened problems fallen approach factors indicate hard approximate increase 
cases tight results sight 
provide high level overview main contributions 
provide definitions state precise theorems 
discussion omitted explanatory simplicity historical story accompanies technical advances 
section provide history main flow works ideas area 
detailed credits historical discussions specific topics text relating topic question pointers discussions section 
bellare goldreich sudan overview main results continues expands research non approximability proof systems focus obtaining tight results 
briefly summarize contributions 
state results precisely 
new proof systems non approximability results set results continues previous building new efficient proof systems improving increasing factors shown non approximable wide variety optimization problems 
obtain improved non approximability results max clique chromatic number max sat 
obtain reasonable explicit constant factor non approximability result min vertex cover problem max cut max sat 
results strong indicate gap factors attainable polynomial time algorithms indicate quite narrow 
see 
technical foundation results new code call long code collection associated tests 
tests construct proof systems np 
key improvements non approximability factors problems focus certain measures proof checking complexity free bits amortized free bits 
domain main result proof system np amortized free bits directly yielding non approximability factor max clique 
emphasize general framework derivation strong non approximability results max snp problems results tests proof systems obtaining non approximability result particular problem reduced construction appropriate gadgets represent simple functions boolean xor boolean 
proofs approximation potential limitations indicates non approximability results getting steadily stronger especially max clique 
far go 
minimizing amortized free bits right track 
ways 
set results provides answers kinds questions 
reverse connection focus max clique problem 
result indicates proof checking necessary getting non approximability results 
furthermore indicates just proof checking minimization amortized free bit complexity necessary 
roughly show max clique np hard approximate np proof systems logarithmic randomness amortized free bit complexity result viewed inverting strong way fglss connection 
current efforts recall amortized free bit complexity yielding hardness max clique right direction 
prove say max clique hard approximate reverse connection says construct proof systems amortized free bit complexity 
free bits pcp lower bound amortized free bits know minimize amortized free bits ask low take 
approach look current techniques assess limitations 
stress approach various assumptions methods intended show significantly novel techniques required go 
suggest inherent limitation 
retrospect lower bounds justify hastad deviations techniques specifically codeword test projection test 
pcp fpcp properties transforms probabilistic proofs involve vast arena complexity parameters query complexity free bit complexity amortized free bit complexity randomness proof sizes name 
glance natural important applications 
better understanding basic properties relations parameters help move forward 
initiate accordingly systematic investigation properties pcp complexity classes function parameter values 
providing new results take opportunity state prove folklore ones 
focus particular triviality results 
results say certain parameter combinations yield classes probably capable capturing np 
example class languages recognizable error logarithmic randomness non amortized 
free bit don expect prove np just free bit 
rules amortization considered 
investigate transformations reduce randomness error complexities various costs 
conceptual contributions reverse connection guide choice parameters 
provides new conceptual tool enables reflect language proof systems theorems properties transformations graphs vice versa 
turns useful revealing 
leads cases new results derived turning graphs proof systems connection back graphs fglss connection process gaining property 
example show known hardness results chromatic number viewed loss efficiency reductions max clique essentially hardness results proof checking 
examples demonstrating usefulness equivalence may section 
believe exploring exploiting duality fruitful avenue pursue 
second related conceptual contribution distill formalize role randomized reductions 
transforms provide elegant concise way stating connections proofs approximability just different kinds proof systems easier manipulate connections exist derive new results 
previous version current version versions fourth version 
previous versions dated may august december respectively available eccc electronic colloquium computational complexity www eccc uni trier de eccc 
bellare goldreich sudan second version improves analysis max snp verifier consequently hardness factors achieved verifier max sat max sat max cut 
addition new transformation pcp systems proposition resolving open problem mentioned version showing pcp system np perfect completeness logarithmic randomness soundness error free bit complexity log 
minor flaws original expositions removed see definition double folding 
third version presents improvements results chapter 
particular get hardness factors max sat max sat maxcut respectively 
addition obtain np pcp log fpcp log np pcp log fpcp log 
key ingredient obtaining improvements new adaptive 
rmb test replacing previous rmb test 
current version corrects error previous statement proposition 
current version slightly weaker effects maxcut result theorem weaker claimed third version 
background definitions sections state precisely results theorems corresponding discussion 
order recall minimal number definitions background 
informal brief possible formal definitions chapter 
proof systems parameters 
probabilistic proof system described probabilistic polynomial time verifier takes input length tosses coins oracle access poly length string oe describing proof access bit writes log bit address returned corresponding bit proof 
computation accept reject input accepting probability denoted acc maximum oe probability accepts coins proof string oe 
task typically language recognition generally consider promise problems consisting set positive instances set negative instances 
languages special case promise problems language represented promise problem 
interest applications various parameters system 
completeness probability soundness probability defined usual ways 
case say system perfect completeness 
gap query complexity maximum coin tosses proof strings number bits proof examined verifier 
free bit complexity roughly speaking logarithm number possible accepting configurations coins input 
example verifier queries accepts iff parity answers odd accepting configuration free bit complexity 
query free bit complexity may considered amortized form amortized free bit complexity free bit complexity proof system perfect completeness divided logarithm gap 
number free bits needed factor increase gap 
query free bit complexity may considered average average random string verifier 
corresponding factors version 
improving np pcp log fpcp log np pcp log fpcp log respectively obtained version 
free bits pcp notation pcp denote class promise problems recognized verifiers tossing coins having query complexity achieving completeness probability soundness probability fpcp defined analogously free bit complexity 
pcp defined analogously amortized query complexity fpcp defined analogously amortized free bit complexity 
max clique approximation 
look optimization problems particular focus max clique 
recall best known polynomial time approximation algorithm max clique achieves factor gammao scarcely better trivial factor 
discussing max clique problem denotes number vertices graph 
heuristic algorithm conjectured better 
lov asz theta function conjectured approximate max clique size conjecture disproved feige fei 
question slightly better interest 
gammaffl factor approximation algorithm max clique ffl 
additional motivation searching weak approximation algorithms suggested blum 
showed polynomial time gammaffl factor approximation algorithm max clique implies polynomial time algorithm color colorable graph log colors bl better currently known kms 
gammao best possible 
resolving approximation complexity basic problem case worth effort 
gaps clique size 
hardness approximation say max clique typically shown construction promise problems gaps max clique size 
specifically gap clique promise problem defined follows set graphs maxclique set graphs maxclique 
gap defined hardness result typically specify value gap gap clique np hard randomized karp reduction 
means polynomial time algorithm approximate max clique size node graph np randomized polynomial time algorithms 
gap problems similarly defined optimization problems consider 
discuss approximation terms gap problems 
connection making gaps proofs 
need recall manner proof systems translated np hard gap problems 
refer recall reduction promise problem pcp system maps input graph maxclique reflects acc 
best results typically uses randomized form reduction due zu assume henceforth 
np hard gap problem obtained roughly follows 
exhibits appropriate proof system np 
applies fglss reduction 
factor indicated hard depends proof system parameters 
key factor getting better results distilling appropriate pcp parameters 
sequence works fglss besu lead sequence parameters query complexity free bit complexity best known results amortized free bit complexity 
connection terms amortized free bits stated follows np reduces fpcp log np reduces gap clique gap 
cases reduction randomized karp reductions terms ffl arbitrarily small ignored 
particular np fpcp log approximating max clique size vertex graph polynomial time bellare goldreich sudan possible np efficient randomized polynomial time algorithms 
new proof systems non approximability results section describes proof systems construct non approximability results derive 
proof systems long code checking machinery 
non approximability results introduce new reductions improve currently known reductions 
new proof systems theorem summarizes new proof systems obtain 
motivated applications purely interesting items proof theory 
theorem discussion motivation 
theorem provide new proof systems np ffl case np fpcp log ffl 
np pcp log 
np fpcp log 
np pcp log 
search proof systems low amortized free bit complexity motivated course fglss reduction 
bellare sudan besu shown np fpcp log ffl ffl 
result improves presenting new proof system amortized free bit complexity ffl 
question low get worst case average query complexity required attain soundness error investigated lot earlier works applying result obtain max clique hardness results 
know better amortized free bit complexity 
original question curious know answer 
minimizing soundness error obtainable non amortized 
free bits important pragmatic reason 
enables get explicit reasonably strong constant non approximability result min vertex cover problem 
application discussed 
soundness achieve query bits natural question max sat gap results 
np hard max sat gap problem certain focus error queries free bits previous related result queries error maxsat besu free bits error queries average amortized free bits gammam free bits besu new pcp systems np logarithmic randomness 
free bits pcp gap easily get query proof system gap 
fact better indicated 
table depicts parameters new proof systems compares previous related result 
row table corresponds proof system establish part theorem 
new non approximability results state theorem discuss 
best thing look 
theorem indicate factors achievable polynomial time indicated problems assumption result shown 
ffl arbitrary constant results number vertices graph factor gammaffl max clique assuming np 
factor gammaffl chromatic number assuming np 
factor min vertex cover assuming np 
factor max sat max exact sat assuming np 
factor gamma ffl max cut assuming np 
factor max sat assuming np 
factor gamma ffl max phi sat assuming np 
clauses input max phi sat parity clauses disjunctions 
max clique follows course fglss reduction part theorem 
chromatic number follows reduction furer fu turn builds reductions kls besu 
improvements max snp problems significant max clique time see hardness results max snp problems comparable factors achieved known polynomial time approximation algorithms 
obtaining explicit reasonable non approximability factor max sat max cut minimum vertex cover 
recall approximable 
results max cut max sat show possible find solution value away optimal 
may contrasted results shows solutions respectively optimum obtainable polynomial time 
know pcp approach allows get best possible non approximability results problems feel current results far known upper bounds 
consider example ratio gamma gamma currently known upper lower bounds respectively 
ratios mentioned max snp problems max exact sat max sat max sat max cut minimum vertex cover 
table depicts problem considered best known factor achievable polynomial time algorithm lower bound best previous lower bound 
ignore usual terms ffl ffl arbitrary positive constant 
techniques constructions efficient pcp construction relies recursive construction verifiers introduced arora safra 
advantage able outer level verifier raz raz appeared bellare goldreich sudan problem approx non approx factor due new factor previous factor assumption max sat ya besu np max sat folklore unspecified np max sat implied besu np max phi sat folklore np max cut unspecified np min vc gamma unspecified np max clique gammao besu np cor np besu np chromatic gammao besu np cor number fu np besu np approximation factors attainable polynomial time algorithms approx versus factors show hard achieve non approx 
available previous works 
inner level verifier relies encoding scheme 
constructions verifier hadamard code purpose 
change aspect protocol redundant code call long code 
code encodes bit string bit string consists value boolean function bit string 
easy see codes large hamming distance 
important code easily testable correctable 
shown section show code translates theorem described 
second aspect improved hardness result fact direct reductions verifiers problems interest 
follows extends prior results generic reductions take advantage nature tests performed verifier 
particular case turns verifier performs kinds tests verify oe mod verify oe answer bits obtained oracle oe fixed bits 
constructing local gadgets gadget random coin toss sequence verify verifier tests achieve better non approximability results general reductions 
particular suggest optimizing gadgets check conditions listed lead reasonably lower bounds max snp problems 
free bits pcp proofs approximation potential limits describe results concerned exploring limitations proof theoretic techniques approximation 
reversing connection making proofs gaps fglss reduction lemma indicates route non approximability results max clique show np fpcp log values small possible 
reverse connection says fact way proceed 
invert fglss reduction 
states equivalence just fglss reduction reversed connection 
statement ignores terms ffl arbitrarily small 
proof precise statement section 
theorem constant 
statements equivalent np reduces gap clique gap 
np reduces fpcp log 
cases reduction randomized 
furthermore statement holds karp cook reductions 
holds deterministic karp reduction np fpcp log fpcp defined amortized free bit complexity proof systems completeness gamma 
words method proving np hardness max clique approximation factor implies np proof systems amortized free bit complexity stress qualitative quantitative aspects result 
qualitatively provides answer kind question proofs approximating clique size prove non approximability results proof checking 
result indicates proofs inherent explains hardness results avoiding proof connection appeared 
stage quantitative aspect interests 
says get tighter results max clique hardness construct proof systems minimize amortized free bit complexity 
long code right direction 
question amortized free bit bound improved 
lower bounds amortized free bits text appeared previous version bgs show framework previous papers subject amortized free bit complexity natural barrier proof system framework gamma ffl amortized free bits ffl usual arbitrarily small :10.1.1.10.6494
result including definition mean framework section 
loosely speaking considers proof systems things probe oracles order check oracle close codeword codeword test second oracle encodes projection information encoded oracle projection test 
prove lower bound gamma ffl amortized free bit complexity performing codeword test resp projection test 
lower bound refers codeword test required reject oracles distance code bellare goldreich sudan distance code 
lower bounds tight proof systems 
relaxed definition codeword test requires test reject oracles distance gamma ffl delta code 
know lower bound amortized free bit complexity holds relaxed codeword test 
known constructions reasonably efficient pcp systems fall framework discussed perform codeword test projection test 
furthermore pcp system amortized free bit complexity ffl cf 
theorem part constructed relaxed non relaxed forms codeword test 
improving amortized free bit count ffl requires departure abovementioned framework construction relaxed codeword test amortized free bit complexity significantly lower 
case remaining framework construction necessary sufficient order obtain pcp system np free bit complexity lower needs perform projection test case oracles close equal codewords 
furthermore case lower bound free bit complexity projection test holds 
hastad constructed pcp system amortized free bit complexity ffl ffl 
done stages papers 
hastad builds framework current introduces different type relaxed codeword test conducted amortized free bit complexity ffl 
second hastad current framework utilizes relaxed projection test conducted amortized free bit complexity ffl 
retrospect lower bounds justify hastad deviation intuitive stringent forms codeword projection tests 
properties transforms pcp fpcp results mentioned subsections section results subsection section 
triviality results investigation roles various parameters triviality results 
results directed seeing kinds parameter combinations expect weak recognize np 
thing ask amortized free bit complexity simpler measures 
fpcp log contains classes pcp log pcp log fpcp log 
suffice minimize query complexity get error amortized query complexity free bit complexity get error 
turns complexities enable reach target reducing complexity zero proving clique hard approximate gammaffl factor ffl 
result folklore included completeness 
theorem classes contained contrast original definition passing relaxed codeword test guarantee unique decoding 
see section matter 
free bits pcp pcp log pcp log fpcp log 
expect construct pcp systems np query complexity amortized query complexity free bit complexity 
feature amortized free bit complexity far entirely possible np reduces fpcp log arbitrarily small constant 
believe conjecture max clique hard approximate gammaffl ffl proof systems exist virtue theorem 
fact believe max clique hard approximate gammaffl ffl turns amortized free bit parameter weak capture hardness clique function 
fact max clique hard approximate ff best hardness result obtainable amortized query bit parameter form ff gammaff shown invoking corollary shows amortized query complexity parameter larger amortized average free bit parameter know amortized free bit parameter captures hardness max clique tightly 
results mentioned cf theorem strict limitations various query parameters pcp weak 
pcp log fpcp log collapse means pcp systems perfect completeness weak restricted queries free bit complexity 
pcp systems completeness error query resp free bit bounds weak 
particular known np pcp log np hardness approximating max sat 
show np fpcp log specifically delta 
furthermore smaller holds np fpcp log specifically delta 
find assertion quite intriguing 
indicate needs careful making conjectures regarding free bit complexity 
furthermore careful making conjectures regarding amortized complexity example result pcp log holds allows non perfect completeness definition pcp delta delta long gap greater queries analogous result hold sided error amortized free bit complexity fpcp delta delta 
trying understand power pcp systems low free bit complexity bound randomness complexity 
recall case pcp systems able recognize non deterministic exponential time pcp poly poly bfl 
may interest indicate fpcp poly conp fpcp poly pspace fpcp log contained bpp quadratic non residuosity graph non isomorphism belong class 
specifically interactive proofs gmr gmw viewed pcp system polynomial randomness query complexity free bit complexity 
obvious observation pcp poly am am stands round arthur merlin games hard improve 
bellare goldreich sudan transformations proof systems provide various useful transformation pcp systems 
transformations analogous transformations applied graphs respect max clique problem 
view relation mentioned fpcp clique promise problem analogy hardly surprising 
type transformations amplify gap ratio completeness soundness bounds proof system preserving amortized free bit complexity incurring relatively small additional cost randomness complexity 
specifically randomized reduction transform fpcp log fpcp gammak log delta 
transformation analogous known transformation berman schnitger 
alternatively known deterministic amplification method aks lps transform fpcp log fpcp gammak log delta ignoring multiplicative factors ffl arbitrarily small ffl 
best knowledge transformation appeared full proof 
alternatives important ingredients transforming pcp results clique approximability results fglss method 
second type transformations ones move location gap equivalently completeness parameter 
gap preserved transformation moving related changing free bit complexity amortized free bit complexity preserved 
moving gap requires increasing free bit complexity moving gap allows decrease free bit complexity 
example randomly reduce fpcp log fpcp log log log log 
hand deterministically reduce fpcp log fpcp log gamma provided original system accepting configurations possible sequence coin tosses 
condition satisfied natural pcp systems history early non approximability includes garey johnson gj showing np hard approximate chromatic factor factor 
indication higher factors results problems wait interactive proof approach 
interactive proofs introduced goldwasser micali rackoff gmr babai bab 
ben goldwasser kilian wigderson extended ideas define notion multi prover interactive proofs 
fortnow sipser frs showed class mip languages possessing multi prover interactive proofs equals class languages todays terms probabilistically checkable proofs unrestricted polynomial randomness query complexity 
indication power interactive proof systems gmw shown interactive proofs exist graph non isomorphism language known np 
real breakthrough came result lund fortnow karloff nisan algebraic methods showing conp languages languages interactive proof systems 
techniques shamir sh show ip pspace 
central result enabled approximation connection babai fortnow lund bfl showed class mip equals class nexp languages recognizable non deterministic exponential time 
result scaled np level independent groups researchers 
babai fortnow lund szegedy showed input encoded special error correcting code encoding decoding free bits pcp performed polynomial time np transparent proof systems possible verify correctness proof poly logarithmic time 
feige goldwasser lov asz safra szegedy fglss showed np probabilistically checkable proofs poly logarithmic randomness query complexity np pcp log delta log log 
breakthrough connection approximation feige goldwasser lov asz safra szegedy fglss 
shown np pcp implies approximating maximum clique vertices graph factor infeasible doable polynomial time provided np dtime 
length input pcp verifier 
combined mentioned results obtained sequence strong non approximability results max clique non approximability factor log gammaffl ffl assuming np quasi polynomial time algorithms 
fglss field took major directions 
extend interactive proof approach apply optimization problems 
direct reductions proofs show hardness quadratic programming max sat set cover problems 
reductions max clique lead hardness results chromatic number problems zu previous reductions max sat lead hardness results max snp 
direction increase factors reduce assumptions problems shown hard factor assumption improving efficiency underlying proof systems efficiency reductions 
stage enterprise started arora safra showing np pcp log log provided strong np hardness result max clique specifically hardness factor log 
introduced idea recursive proof checking turned play fundamental role subsequent developments 
interestingly idea encoding inputs error correcting form suggested essential recursion 
arora lund motwani sudan szegedy reduced query complexity pcp systems np constant preserving logarithmic randomness complexity shown np pcp log 
immediately implied np hardness approximating max clique ffl ffl 
furthermore implied max sat np hard approximate constant factor entire class max snp 
attempts improve constant exponent max clique hardness factor improve constant values hardness factors max snp hardness results bellare goldwasser lund russell 
new proof systems minimizing query complexity exploited slightly improved version fglss reduction due zu get hardness approximation factor max clique 
feige kilian observed free bits noted free bit complexity system yielding hardness factor 
bellare sudan suggested notion amortized free bits built new proof systems achieving amortized free bit complexity particular hardness max clique assuming np cor detailed histories specific topics sections addressing topic 
particular see section history pcp growing list parameters section perspective role constant prover proofs section previous query complexity minimization section previous approximation algorithms hardness results max sat max sat section previous max clique history various chromatic number reductions 
bellare goldreich sudan related presentation results arora investigated limitations proof checking techniques proving non approximability results ar 
free bit lower bound result tries assess limitations current techniques making assumptions techniques showing lower bound 
focus reductions assumes code 
setting show expect prove non approximability max clique 
assumptions arora comparable implies 
retrospect sets assumptions passed done hastad 
subsequent directions research important issue neglected treatment problems issue weights 
example maxsat problems allowed clause appear times formula considered allowing small weights 
certainly may want results unweighted case say allow multiple occurences clause 
issue treated subsequent crescenzi cst 
essentially show unweighted cases problems considered hard weighted cases 
intriguing problem left open resolved hastad proved conjecture ffl case np fpcp log ffl 
lead non approximability result max clique ffl assuming np polynomial time algorithm approximate max clique factor gammaffl 
challenge dare state achieved hastad announced optimal non approximability results problems max sat 
furthermore improved non approximability results problems obtaining non approximability factors max sat max cut respectively 
direction reseach taken trevisan systematic study construction gadgets 
particular showed gadgets reductions maxsat problems optimal constructed better optimal gadgets reduction maxcut 
regarding non amortized free bits show np fpcp log obtain non approximability bound min vertex cover 
hastad showed np fpcp gammaffl ffl log ffl sets non approximability bound gamma ffl 
general np fpcp log implies approximating min vertex cover gammas gammac factor np hard 
motivates ask np fpcp gammaffl ffl log np fpcp ffl log ffl 
imply hardness factor gamma ffl ffl 
np fpcp ffl log log ffl imply hardness factor gamma ffl ffl 
np fpcp gammaffl ffl log ffl imply hardness factor gamma ffl ffl 
recall fpcp log 
questions de randomization flavor follow 
stated know fpcp log randomly reducible fpcp gammak log delta 
hand class contained deterministically reduced class fpcp gammak log ffl ffl delta arbitrarily small ffl 
obtain best worlds deterministic reduction fpcp log say fpcp gammak log ffl ffl delta arbitrarily small ffl 
affirmative free bits pcp answer allow infer np fpcp log approximating max clique ffl factor np hard infeasible assumption np contained bpp 
ingredient method reversing fglss reduction randomized reduction class fpcp log class fpcp log deltas log log log log 
statement follows exposition section 
alternative exposition making randomized graph layering process section randomness plays essential role obtaining pcp system perfect completeness 
question class fpcp log contained class fpcp log deltas log log log log randomly reducible 
acknowledgments johan hastad kann marcos kiwi luca trevisan carefully reading previous version pointing flaws improvements 
wish uri feige helpful discussions 
results elegant indicated section settled perfect completeness suffices presenting inverse fglss reduction 
notation definitions general notation definitions integer ng 
graph means undirected graph self loops indicated 
kgk denote number vertices graph 
probabilistic machine inputs tosses random coins usually length delta function lengths inputs 
denote output uses particular sequence coin tosses typically interested probability space associated random choice function admissible polynomially bounded polynomial time computable 
ask functions measuring complexity query complexity admissible 
defining complexity classes consider promise problems languages 
promise problem pair disjoint sets set positive instances second set negative instances 
language identified 
refer reader issues promise problems 
proof systems verifier probabilistic machine inputs allowed access oracles 
denote sequence inputs denote length 
course computation coins input queries oracles 
final decision accept reject function dec sequence bits obtained oracle computation 
contrary standard terminology acceptance correspond outputting rejection outputting 
oracles formally functions context specifying domain range may write strings interpreted functions natural way 
denote sequence tuple proof oracles supplied verifier verifier examining proofs having input acc prr convention adopted approximation problems easily casted promise problems 
free bits pcp denote probability accepts particular case 
acc max acc denote maximum accepting probability possible choices proof sequences domain proofs chosen depending mentioned context 
pattern set sequences dec 
sequences oracle answers leading acceptance 
generator poly time computable function pattern 
efficiently generate set accepted patterns 
interested host parameters capture various complexity measures proof checking process 
functions length input verifier oe denotes concatenation proof strings verifier 
recall interested proof systems promise problems just languages 
coins number coins tossed verifier 
typically denoted length proof provided verifier 
typically denoted completeness probability 
minf acc jxj soundness probability 
maxf acc jxj gap 
move various measures information conveyed oracle verifier 
simplicity consider oracles return single bit correspond written proofs 
query query complexity input maximum possible coin tosses number bits oe accessed input query complexity system maximum inputs length query av average query bit complexity input average number bits proof oe accessed input coins average query complexity system maximum length typically denoted av query said amortized query bit complexity lg query bit complexity gap furthermore logarithmic free free bit complexity generator jg length free av average free bit complexity av generator er jg fav length free said amortized free bit complexity lg free bit complexity gap 
notice amortized query complexity restricted logarithmic 
don need explicitly restriction amortized free bit complexity consequence efficient generation condition 
bellare goldreich sudan case completeness parameter equals say system perfect completeness 
case completeness parameter satisfies gamma say system perfect completeness 
consideration parameters give rise potentially vast number different complexity classes 
generic notation parameter values specified name optionally completeness soundness appear subscripts 
example things pcp coins query free ll abbreviations pcp def pcp coins query pcp def pcp delta coins query fpcp def pcp coins free fpcp def pcp coins free fpcp def pcp delta coins free stress definitions amortized classes pcp fpcp refer completeness parameter soundness parameter 
case may omit parameter shorthand amortized classes perfect completeness pcp fpcp respectively 
pcp def pcp fpcp def fpcp randomized reductions consider reductions promise problems 
randomized karp reduction probabilistic polynomial time function takes arguments input security parameter written unary 
transformation required property pr theta def gamma gammak pr theta def gamma gammak probability coin tosses say reduction perfect completeness perfect soundness 
special case deterministic transformations 
write randomized karp reduction 
reduction deterministic omit subscript emphasis replace subscript example randomized fglss transformation fglss zu 
typically np complete language gap clique determined transformation 
transformation perfect soundness hand possible get gamma gamma poly free bits pcp similarly define randomized cook reductions 
notation reductions complexity class np 
say reduces case reduces 
example say np reduces gap clique say reduces complexity classes reduces 
example say np reduces fpcp log 
notation extends cases 
notice definition reducibility ensures relation transitive 
simplicity view reduction function write 
case understood security parameters set convenient value 
history model underlying known probabilistically checkable proofs oracle model fortnow sipser frs introduced equivalent respect language recognition power version multi prover model ben goldwasser kilian wigderson 
interestingly shown fglss framework applied meaningful manner languages np 
works provide verifier written proof modeled oracle provides address bit position proof string returned corresponding bit proof 
babai suggested model instances encoded special polynomial time computable decodable error correcting code verifier works polylogarithmic time 
follow model feige fglss verifier probabilistic polynomial time usual considers finer complexity measures query randomness complexity 
reduction fglss identified parameters query complexity number binary queries randomness complexity error 
class pcp explicit 
parameterization expanded explicitly consider answer size oracle allowed return bit time query size notation included parameters randomness number queries size query size answer error probability 
similarly parameterized single round multi prover proofs drawing attention analogue pcp 
served focus attention roles various parameters reductions constructions 
introduced consideration average query complexity sequence parameter changes doing better clique 
free bits implicit formalized besu 
amortized free bits introduced besu formalized little better 
proof sizes considered 
consider different reason play important role randomized fglss reduction zu depends randomness 
deal huge array parameters generalized notation allow specification parameters name 
followed common tradition regarding names polynomial time reductions reductions called karp reductions polynomial time turing reductions called cook reductions 
terminology somewhat unfair levin npcompleteness lev independent cook karp ka 
reductions considered levin restricted efficiently transform corresponding artifact levin desire treat search problems decision problem 
fact reductions surprisingly termed levin reductions essential results bellare goldreich sudan corollary 
example current 
new proof systems non approximability results chapter presents new proof systems minimizing complexity various measures 
proof systems derive best known approximability results max sat max sat max exact sat max sat max cut min vertex cover min vc max clique chromatic number 
long chapter help indication doing 
overview starting point proof systems prover proof system achieving arbitrarily small fixed constant error logarithmic randomness constant answer size provided raz raz 
proof system property answer second prover supposed predetermined function answer prover 
verification amounts checking answer satisfies predicate second answer equals value obtained answer 
proof composition paradigm arora safra encode answers provers suitable code recursively check encodings 
usual check encodings valid correspond answer accepted original verifier 
main technical contribution new code called long code means check 
long code bit information word sequence bits consisting values possible boolean functions long code certainly disaster terms coding theory big advantages context proof verification arising fact carries enormous amounts data difficulty check prover claiming write long code string really doing 
long code described section 
section provide call atomic tests code 
tests analysis instrumental follows 
section instrumental follows 
section sets framework recursive proof checking proof systems 
atomic tests exploited section introducing verifier queries proof locations performs simple checks answers obtained 
simple checks bellare goldreich sudan implemented gadgets problem hand yielding non approximability results 
section presents gadgets cnf formulae corresponding type section presents max cut gadgets 
non approximability results max sat max sat max sat max cut follow 
verifier section benefits novel idea referred folding see section 
stress folding contributes improved results max sat max sat max sat max cut results regarding max clique chromatic number 
reasonable non approximability result min vc minimum vertex cover obtained procedure better result obtained constructing different verifier uses exactly free bits 
computation verifier reduced vertex cover problem means fglss reduction 
approach section try minimizing soundness error attainable exactly free bits 
section minimize number bits queried pcp attain soundness error result direct applicability know low number go 
turn max clique chromatic number 
section provide iterated tests atomic tests sequentially invoked times 
iterations related pairwise independent specific leading proof system number amortized free bits 
draw implications max clique chromatic number 
reader interested amortized free bit max clique results proceed directly section section section 
improvement complexities proof systems main source improved non approximability results 
addition max sat max cut problems improvement analysis linearity testing introduce special problem specific gadgets represent various tests 
credits histories pertaining topic discussed alongside topic 
subsection contains historical material relevant 
preliminaries chapter sigma identified finite field elements field operations addition multiplication modulo 
sets map denotes set maps regard sigma vector space sigma strings vectors identified 
linearity 
groups 
map linear lin denote set linear maps distance 
distance functions defined common finite domain dist pr functions ffl close dist ffl 
maps group group denote dist lin minimum lin dist 
note notation specify evident context 
concerned case vector space sigma sigma 
notice case dist lin sigma 
boolean functions 
integer 
def map sigma sigma set maps sigma sigma 
regard vector space dimension sigma 
addition multiplication free bits pcp functions defined natural way 
lm fm set lin sigma sigma linear functions sigma sigma lm gamma non zero linear functions 
fm ffi denotes function assigns value sigma sigma denotes th bit 
similarly function range sigma denotes th bit output 
monomial basis 
monomial corresponding defined sigma empty monomial defined constant function sigma 
functions form basis vector space call monomial basis 
means exists unique vector sigma delta expression equation called monomial series members called coefficients respect monomial basis 
note sigma bijection 
folding 
fix oe canonical polynomial time computable total order reflexive antisymmetric transitive set functions sigma constant function bit sigma folding function sigma oe gamma 
notice defined 
sake technical simplicity see definition define folding shown folding function forced satisfy may necessarily satisfy equalities 
proving generalize notion folding folding specifically functions bits sigma 
definition folding span denoted span defined set ff oe oe oe oe sigmag 
sigma sigma 
folding denoted defined oe oe gamma oe gamma oe oe oe sigma function oe oe smallest function oe span 
definition extends naturally case 
case folding identical pairs defined folding pair 
case folding defined folding 
note folding pairs invariant order pairs observe function sigma folded functions folded 
bellare goldreich sudan proposition folding forces equalities sigma sigma case 
proof definition oe oe gamma oe gamma oe function oe oe smallest function span 
span span oe oe gamma oe gamma gamma oe claim follows 
may instructive hint verifiers constructed virtual access folded functions function 
virtual access folding implemented actual accessing definition folding say wants access determines oe accesses accordingly 
benefit folding context illustrated proposition case folded function close codeword long code infer codeword encodes string satisfying see folding long code allows get rid standard ingredient proof verification called circuit test 
sequel folding pairs arbitrary function typically identically zero constant function 
folding allows simplify codeword test long code 
evaluation operators long code sigma define map sigma say map sigma evaluation operator exists sigma provide useful characterization evaluation operators 
need definition 
definition respecting monomial basis map sigma said respect monomial basis delta proposition characterization evaluation operator map sigma evaluation operator linear respects monomial basis 
proof sigma easy see linear 
easy see respects monomial basis 
firstly 
delta delta delta sigma delta turn converse 
sigma linear respecting monomial basis 
def fig def claim proof follows 
claim free bits pcp respects monomial basis turn equals proving eq 

establish eq 
fi write gamma fi delta delta delta fi delta fi second equality due fact respects monomial basis 
establishes eq 

linearity see delta delta delta long code sigma map sigma defined sigma formally codeword map sigma 
intuitively think codeword bit string position stores bit 
extremely redundant code encoding bit string values functions sense longest possible code longest code repetitive positions identical codewords 
dist eval min sigma dist distance closest codeword convenient define gamma sigma lexicographically sigma dist dist eval 
notice dist eval exactly sigma dist dist eval gamma useful relating folding long code 
proposition folding evaluation operator sigma sigma sigma suppose case dist implies consequently dist provided 
proof hypothesis suppose dist 
noting linear applying corollary get definition evaluator operator consequence follows proposition long code certainly disaster terms coding theory big advantage context proof verification 
consider example called circuit test testing answer prover satisfies predetermined predicate circuit 
context needs check codeword corresponds string satisfies predetermined predicate codeword encodes satisfies predetermined predicate 
point value predicate appears explicitly codeword furthermore easily self corrected probing codeword values functions uniformly selected function values appear explicitly codeword 
process verifying self correction value zero incorporated task checking validity codeword done notion folding see 
fact avoid testing codeword encodes string satisfies function testing cost key complexity improvements proof systems previous proof systems circuit test place 
bellare goldreich sudan recursive verification proofs section specifies basic structure proof construction particular provides definitions notions inner outer verifiers 
useful understand things proceeding tests 
overview 
constructions efficient proofs follow exploit notion recursive verifier construction due arora safra 
just level recursion 
define notion canonical outer verifier intent capture prover round proof systems having certain special properties verifiers starting point 
define canonical inner verifier 
recursion captured appropriate definition composed verifier attributes relate original verifiers theorem 
specific outer verifier obtained raz raz 
construct various inner verifiers long code tests section section 
theorem ubiquitously combine 
better understanding role constant prover proof systems context explanation raz buys opposed systems provided subsection explanatory history 
outer verifiers mentioned outer verifiers model certain special kinds prover round proof systems 
think verifier provided pair proof oracles allowed query 
desired properties concern complexity system certain behavior checking proof describe 
positive integers 
canonical outer verifier outer takes input sigma oracle access pair proofs sigma sigma 
picks random string length 
computes function queries circuit computing function oe sigma sigma determined 
determines function sigma sigma computes appropriate representation 
stress depend 
lets 
rejects 
oe rejects 
accepts 
call proof sizes outer randomness outer recall conventions section acc outer denotes probability choice outer accepts acc outer denotes maximum acc outer possible proofs definition soundness outer verifier outer verifier outer ffl language acc outer 
acc outer ffl 
free bits pcp employing frs method frs pcp log system np gets canonical verifier ffi ffi 
parallel repetition theorem raz obtain starting point lemma construction outer verifiers raz np 
ffl exist positive integers exists canonical outer verifier ffl uses randomness log raz theorem raz enables assert log ffl gamma need fact 
function oe determined verifier projection don fact 
inner verifiers describe form typical inner verifier 
may illustrative remember inner verifier perform combination atomic linear test atomic respect monomial basis test atomic projection test 
turns inner verifiers need perform circuit test test 
achieved folding mechanism introduced section refer reader notation 
canonical inner verifier inner takes inputs functions oe sigma sigma 
may take additional inputs depending context 
oracle access pair functions sigma sigma uses random bits 
parameters ffi ffi thought extremely small constructions essentially see comment 
definition soundness inner verifier inner verifier inner ae ffi ffi oe suppose sigma 
oe sigma acc ea ea inner oe 
suppose acc inner oe ae 
exists sigma dist gamma ffi 
dist oe gamma ffi stress inner verifier access oracle hypothesis condition definition refers computations oracle condition refers folded constant function 
typically necessarily verifier satisfying definition accesses virtual oracle actual access definition folding 
furthermore proposition condition implies 
need explicitly require order theorem 
comment upper bounds conditions chosen largest ones allow prove theorem 
clearly complexity inner verifier decreases bounds increase 
reason setting ffi ffi extremely small 
stress optimization important results max clique result 
case ffi greater simplifies little analysis composition verifiers 
tedious definition allows identically zero case occurs constructions reasonable application 
reason define folding 
alternative approach require assert case respect outer verifier lemma 
bellare goldreich sudan composition verifiers describe canonical composition canonical outer verifier canonical inner verifier 
outer canonical outer verifier randomness proof sizes inner canonical inner verifier randomness composed verifier hv outer inner takes input sigma oracle access proofs theta sigma theta sigma 
ask picks random strings outer inner picks random string length random string length 
computes queries functions oe outer compute outputs inner oe delta delta delta delta 
randomness complexity composed verifier query free bit complexities equal inner show composite verifier hv outer inner inherits goodness outer inner need lemma 
counterpart claim lemma way 
lemma derived coding theory bound slight extension bounds ch 
provided section 
lemma suppose ffi sigma 
fi fi sigma dist gamma ffi fi fi ffi furthermore ffi set contains string 
proof know linear cf 
proposition 
suffices upper bound size set lin sigma dist gamma ffi set size gamma lin sigma dist gamma ffi identify map sigma sigma natural way 
delta denote hamming weight 
note gamma implies dist gamma ffi furthermore gamma gamma dist dist linear 
apply lemma ff ffi fi upper bound size desired 
ffi triangle inequality implies dist gamma ffi 
applications theorem ffi ffi chosen small may effectively thought 
done order lower complexities inner verifiers 
ffi fixed ffl chosen smaller ffi ffl ffi ffi may thought effectively 
explains interested outer verifiers achieve constant arbitrarily small error ffl 
completeness provide proof ideas 
theorem composition theorem outer canonical outer verifier 
suppose ffl inner canonical inner verifier ae ffi ffi 
hv outer inner composed verifier sigma free bits pcp acc acc ae ffl ffi ffi ffi ffi upper bound improved ae ffl 
case ffi ffi suffices max clique results 
proof jxj denote proof sizes outer suppose definition exist proofs sigma sigma acc outer 
theta sigma defined 
words replace bit string bit encoding long code new proof provide access bits encoding 
similarly theta sigma defined 
check item properties definitions outer inner verifier respectively imply acc 
suppose theta sigma theta sigma proof strings show acc ae ffl ffi ffi 
arbitrary complete proof 
set ffi ffi ffi ffi 
idea show acc ae delta ffl follows 
define collection proofs collection proofs pair pair oracles outer verifier 
partition random strings outer verifier categories depending performance inner verifier inputs functions oe oracles induced bad random strings outer verifier inner verifier accept probability ae ones soundness inner verifier infer outer verifier accepts oracle pair 
soundness outer verifier bound probability acceptances 
proceed actual proof 
turn actual analysis 
define proofs sigma follows 
fix delta 
fa sigma dist gamma ffi 
notice set defined fact defined 
note jb lemma 
order elements canonical way adding dummy elements bring number exactly written 
set similar fashion define satisfies dist delta gamma ffi random string outer say acc delta delta inner oe ae oe queries functions specified say bad claim follows says choice defined proofs leads outer verifier accept coins claim 
suppose 
outer 
proof 
oe queries functions specified delta delta oracles accessed inner verifier 
acc inner oe ae 
item definition exists sigma dist gamma ffi dist oe gamma ffi oe 
dist gamma ffi case exists 
similarly dist oe gamma ffi bellare goldreich sudan implies 
proposition oe definition 
definition execution canonical outer verifier outer holds 
conditioning acc ff fi ff prr fi prr bad definition badness implies fi ae 
hand claim see ff prr outer prr outer delta ffl soundness outer item definition 
bound proof concluded 
constant prover proofs pcp perspective constant prover proofs instrumental derivation non approximability results ways 
starting point reductions examples reductions prover proofs quadratic programming set cover 
different aspect constant prover proofs direct concern 
aspect constant prover proof systems penultimate step recursion begins 
instrumental getting pcp systems constant number queries 
construction requires proof systems low complexity error constant randomness answer sizes preferably logarithmic 
number provers randomness query complexity determine quality results poly logarithmic logarithmic complexities translate non approximability results assumptions quasi polynomial time classes polynomial time ones 
available constant prover proof systems appear discussed 
prover proofs shamir feige lov asz poly logarithmic randomness answer sizes modification process increasing number provers constant larger 
constructions prover proofs ta lead better non approximability results 
bellare sudan besu identified extra features constant prover proofs presence showed exploited increase non approximability factors 
features captured definition canonical verifiers 
proof systems worked longer sufficed canonical 
besu slight modification proofs incurring poly logarithmic randomness answer sizes assumptions non approximability results pertain quasi polynomial time classes 
alternatively modify system canonical prover incur decrease non approximability factors due having provers 
free bits pcp due provers coins answer size canonical 
canonical 
polylog polylog besu poly ffl gamma log polylog 
log 
ta log 
log cost prover besu raz log na constant prover achieving error fixed arbitrarily small constant ffl 
indicate number provers randomness answer sizes system canonical 
notation 
means don know don care stronger things available 
cases randomness answer sizes hide factors depend ffl 
outer verifiers ask canonicity properties 
difference required oe projection function deal arbitrary function 
don take advantage fact 
addition need answer sizes log log opposed log previous methods reasons explained 
means modified type proofs won suffice 
prover modification cost wipe gain 
luckily discussion moot result raz raz provide canonical prover proof having logarithmic randomness constant answer size constant error 
ideal starting point 
simplify definitions insisted constant answer size provers start 
inner verifiers previous works hadamard code constructions 
improvements mentioned obtained checking code efficient ways 
new code long code basis inner verifiers 
note codewords long code length double exponential message explaining need log log answer sizes outer verifier 
incorporate definitions new idea folding see means don need circuit test hint fact definition inner verifier 
atomic tests motivation 
constructions proofs systems outer verifier lemma composed theorem inner verifiers constructed 
constructions construction appropriate inner verifiers 
inner verifier oracle access function sigma function sigma 
applications supposed folding encoding answer prover prover proof system supposed encoding answer second prover 
verifier perform various tests determine claims true 
subject subsection design tests 
atomic tests provide directly proof systems showing non bellare goldreich sudan atomic tests 
sigma sigma objects tested 
tests take additional inputs parameters oe sigma sigma linearity test output output 
respecting monomial basis test check delta check delta output relevant check succeeded output 
oe projection test ffi oe gamma output output 
passing probabilities 
probabilities interested pr pr oe pr oe atomic tests passing probabilities 
approximability max sat max sat max cut 
furthermore basis iterated tests lead proof systems amortized free bit complexity turn max clique chromatic number results 
applications mentioned max snp problems important best possible analysis atomic tests follows strives 
stress exposition analysis tests subsection independent usage codes proof systems 
testing codeword 
task concerns design test high probability passes close evaluation operator valid codeword 
idea exploit characterization proposition 
perform linearity test respect monomial basis test 
linearity testing understood test blr analyses blr 
main novelty respect monomial basis test 
circuit projection 
having established close evaluation operator want test things 
predetermined function test normally implemented self correction evaluating uniformly selecting computing gamma needed applications free bits pcp folding left test oracles consistent sense far evaluation operator corresponds oe predetermined function oe 
self correction 
self correction lemma due blr 
lemma self correction lemma blr sigma linear dist 
pr gamma gamma proof pr gamma pr gamma pr pr ij gamma corollary sigma linear suppose def dist 
suppose oe oe sigma oe 
proof hypothesis gamma oe 
write pr gamma pr oe right hand side left 
lemma left hand side bounded gamma corollary follows 
convention 
tests output bit standing accept reject 
atomic linearity test atomic linearity test shown blum luby rubinfeld blr 
want lower bound probability gamma test rejects inputs chosen random function dist lin 
lemma due bellare gives best known lower bound today 
detailed description history developments area follows 
lemma sigma dist lin 
gamma gamma lin function gamma lin defined follows gamma lin def gamma bellare goldreich sudan lower bound composed different bounds phase transitions shown see combined lower bound close best possible 
history 
general problem linearity testing introduced studied blum blr stated follows function groups obtain lower bound ffi function xa ffi pr xa dist lin blum showed ffi xa analysis proof system max sat non approximability result 
interest tightness analysis point view improving max sat non approximability began 
showed ffi xa gamma establishes segment lower bound quoted function gamma lin 
possible blr show ffi xa 
putting implies segment lower bound phase transition largest root equation gamma 
lower bound max sat analyses besu 
applications linearity testing lemma case interest underlying groups gf gf may identified gf 
focused case improved bound ffi case xa gf gf 
specifically showed ffi xa establishes second segment gamma lin showed ffi xa gf gf 
combining lower bounds derived segment lower bound stated lemma 
optimality analysis demonstrated 
essentially functions gf gf witnessing ffi gamma lin xa particular function xa ffi gamma lin 
interval tight results known 
reports computer constructed examples functions gf gf xa interval ffi gamma lin furthermore showed exist functions xa ffi arbitrarily close atomic respect monomial basis test having determined close linear atomic respect monomial basis test sure linear function close respects monomial basis 
denote function linear function closest recalling definition need establish things delta 
recall access self correction lemma provides obvious avenue bypass difficulty provided dist 
yielded solution quite wasteful alas sufficient max clique chromatic number results 
adopt efficient procedure 
firstly considering oracles folded need check 
follows combining corollary fact folded oracle satisfies secondly test delta statement holds integral multiple gamman free bits pcp random linear combinations tested 
linear combinations uniformly selected functions wish test delta delta uniformly selected close inspect resp resp little harm 
delta uniformly distributed uniformly selected self correction applied 
resulting test delta delta gamma test analyzed previous version bgs specifically test shown reject folded oracle linear function closest respect monomial basis probability gamma delta gamma gamma gamma dist :10.1.1.10.6494
adaptive version test performs better 
observe need fetch eq 
zero regardless 
merely test delta gamma 
done 
case may replace yielding test delta gamma 
resulting test depicted 
analyze performance test need technical lemmas 
reader may skip proofs reading proceed usage lemma 
technical lemmas 
recall lemma provides improved analysis freivalds matrix multiplication test special case matrices symmetric common diagonal 
lemma symmetric matrix multiplication test symmetric matrices sigma agree diagonals 
suppose pr sigma xm xm furthermore pr sigma xm xm proof def gamma probability uniformly selected combination rows yields zero vector gammar rank symmetric identically zero zero diagonal rank 
pr sigma xm lemma follows 
suppose linear 
case lemma provides condition respects monomial basis 
start definition 
definition rmb detector sigma say detector pr delta 
number detectors clearly related rejection probability rmb test 
suppose linear 
clearly respects monomial basis detectors 
hand lemma asserts respect monomial basis detectors 
bellare goldreich sudan lemma rmb test linear functions suppose sigma linear respect monomial basis 
fraction functions detectors proof define pair matrices rows columns indexed subsets 
specifically set delta clearly symmetric agree diagonal 
delta delta hypothesis respects monomial basis follows aim relate inequality matrices existence detectors express condition fg delta terms matrices 
recall sigma transformation associates vector entries coefficients monomial series 
linearity note delta delta delta delta delta delta delta delta delta delta step need 
fact 

fg delta 
fact linearity fg fg delta fg delta delta delta delta delta linear rephrase condition delta delta delta 
setting conclude delta delta key observation identical entries possibly entry corresponding 
hand eq 
delta delta 
delta delta free bits pcp note bijection uniformly distributed uniformly distributed sigma fixing setting pr delta pr pr sigma xm xm probability xm xm zero 
invoking lemma conclude case coincides detector holds fraction lemma follows 
lemma suggests knew linear test respects monomial basis picking random testing 
lemma asserts case linear respect monomial basis pr delta lower bound probability detector pr detector definition 
know close linear 
perform approximation test self correction value 
test indicated 
rmb test 
interested lower bounding probability gamma test rejects chosen random function distance linear function respect monomial basis 
assume satisfies case applications verifiers access folded function 
item lemma spirit previous analysis analogous tests 
second item somewhat unusual construction verifiers free bit complexity cf section 
lemma rmb test final analysis sigma linear respecting monomial basis dist 
suppose function satisfies 
gamma gamma rmb def delta gamma 

pr delta gamma rmb 
particular lemma holds sigma arbitrary consider linear function closest denoted case respect monomial basis 
case dist dist lin proof preparation lemma show 
justified corollary hypothesis 
case claimed lower bound delta gamma holds vacuously 
lemma lemma lower bound rejection probability test follows gamma pr detector delta min detector pr bellare goldreich sudan delta min detector pr delta min detector pr gamma io delta delta min pr delta delta gamma io delta gamma second inequality uses lemma fourth inequality follows definition detector pr inequality follows lemma 
concludes proof part 
part proven analogously exception don lose factor fourth inequality selected random set existentially 
rmb test arbitrary ones satisfying derived augmenting test test uniformly chosen analysis augmented part circuit test 
atomic projection test final test checks second function far evaluation operator oe function string evaluation operator close previous works instance besu oe may arbitrary mapping sigma sigma projection satisfying oe sequence delta delta delta sigma 
name projection test adopted historical reasons 
lemma sigma oe sigma sigma function 
sigma dist 
oe sigma gamma oe dist delta gamma 
proof lower bound rejection probability follows pr ffi oe gamma pr ffi oe ffi oe gamma ffi oe pr ffi oe delta gamma lemma step 
note ffi oe 
term product just pr dist concludes proof 
free bits pcp atomic circuit test sake circuit test denoted 
test consists checking outputs equality holds 
assuming close evaluation operator atomic circuit test uses self correction blr test function value explained test needed proof systems folding impose 
analysis lower bounds rejection probability function distance linear 
lemma sigma sigma dist 
gamma gamma def pr max snp verifier section simple verifier performs simple checks depending queries 
verifier basis non approximability results regarding max sat max sat maxcut section section respectively 
inner verifier describes inner verifier 
verifier adaptive queries determine function answers previous queries 
adaptivity obvious hidden rmb test see section 
time takes advantage adaptivity construction verifiers 
inner verifier takes usual length parameters additional probability parameters 
performs just test probability linearity test probability respect monomial basis test probability projection test 
formally achieved picking random making cases value 
improve results perform tests folding 
stress virtual oracle implemented verifier accesses actual oracle points determined definition folding 
examine goodness snpinner recall definitions gamma lin specifically note gamma lin gamma rmb gamma informally lemma considers possible strategies dishonest prover indicates probability denoted gamma ae verifier detects error run strategies 
cases correspond events function may far linear function close linear gamma ffi close valid codeword linear function respect monomial basis simplicity depicted chosen random real number 
course quite 
see values final verifiers appropriate constants 
fact appropriate choice randomness implicitly assume 
bellare goldreich sudan function close linear encoding oe gamma far function lemma soundness snpinner suppose ffi ffi suppose satisfy 
canonical inner verifier snpinner ae ffi ffi gamma ae min def delta gamma ffi def min gammaffi delta gamma lin delta gamma rmb def min gammaffi delta gamma lin delta gamma ffi gamma 
proof consider arbitrary pair oracles behavior snpinner access pair oracles 
analysis broken cases depending specifically case partition depends distance folding linear functions 
show case verifier rejects probability bounded quantities oracle pair rejection required 
dist lin 
case gamma ffi max snp inner verifier 
functions oe sigma sigma verifier access oracles sigma sigma 
addition takes valued parameters 
pick 
case pick 
case pick 
case pick oe 
access implemented accessing 
max snp inner verifier snpinner free bits pcp lemma implies gamma gamma lin gamma ffi 
second inequality follows fact gamma lin 
snpinner performs atomic linearity test probability gamma acc snpinner oe delta gamma ffi gamma ae case gamma ffi lemma implies gamma gamma lin probability snpinner performs linearity test rejects delta gamma lin 
linear function dist consider sub cases 
case respect monomial basis case part lemma implies gamma gamma rmb 
probability snpinner performs atomic respect monomial basis test rejects delta gamma rmb 
event verifier performs linearity test event performs respect monomial basis test mutually exclusive add probabilities rejection get gamma acc snpinner oe delta gamma lin delta gamma rmb gamma ae case respects monomial basis proposition evaluation operator 
exists sigma dist oe 
proof splits sub cases 
case def dist gamma ffi lemma gamma oe delta gamma gamma ffi delta gamma 
probability snpinner performs projection test rejects delta ffi gamma 
adding probabilities case get gamma acc snpinner oe delta gamma lin delta gamma ffi gamma gamma ae case case dist gamma ffi dist gamma ffi functions satisfy conditions definition 
observe case yield gamma acc oe gamma ae case 
case satisfies conditions definition 
satisfies condition definition 
clearly satisfies condition definition lemma follows 
upper bound soundness error snpinner provided lemma somewhat complicated grasp 
fortunately gamma rmb gamma gamma lin simplify expression follows 
claim lemma ffi max ffi ffi satisfy 
minf minf gamma ffi minft minf gamma ffi bellare goldreich sudan interestingly lower bound tight see claim 
proof clearly gamma ffi gamma ffi 
analyze def delta gamma lin delta gamma rmb 
fact min fh minf proof considering cases gamma lin gamma case gamma gamma delta case gamma gamma delta gamma fact follows observing min gammaffi minf term analyzed similarly re defining def delta gamma lin delta gamma fact 
fact min fh minf proof considering cases gamma lin case gamma gamma delta case gamma gamma delta gamma fact follows observing min gammaffi gamma ffi minf gamma ffi claim follows 
main application verifier ready state main result section 
simple verifier np achieves soundness error approaching performing simple tests 
proposition verifier fl language np exists verifier snp ffl snp uses logarithmic randomness perfectly complete ffl snp soundness error fl ffl access oracle outcome verifier coin tosses verifier snp performs actions parity check snp determines bit queries rejects phi phi free bits pcp rmb check snp determines bits determined queries rejects phi phi 
verifier inspects consequently checks 
furthermore probability coin tosses snp performs parity check probability snp performs rmb check 
proof set ffi ffi fl ffl fl delta ffi ffi fl 
integers outer verifier outer guaranteed lemma canonical ffl consider canonical inner verifier snpinner working parameters set minimize error 
obviously calls setting yields snp verifier obtained composing outer snpinner start analyzing soundness error snp lemma claim know inner verifier snpinner eq 
ae ffi ffi ae gamma delta ffi gamma delta fl invoking theorem upper bound soundness error snp gamma delta fl ffl ffi ffi setting ffl yields claimed bound 
clearly snp uses logarithmic randomness perfect completeness computation answers oracles determined snpinner left observe tests monomial basis projection performed snpinner parity check rmb check occurs probability 
observe probability snpinner performs recall query translates query set ff answered answer possibly complemented adding mod 
linearity test translates checking exclusive values predetermined bit bit determined number times shifted potential query 
similarly translates rmb check ordering second third function determined folding 
observe projection test performed snpinner amounts parity check time answers taken different oracles viewed oracle 
tedious probability verifier snp proposition identical queries negligible 
specifically smaller fl mentioned proposition 
ignore case sections assume loss generality queries distinct 
formally suppose occurs verifier performs standard check fixed different queries 
modification increases soundness error fl tends zero 
bellare goldreich sudan sections verifier proposition obtain hardness results various variants maxsat max cut 
hardness results obtained constructing instance problem represent verifier computation input primary aspect reduction construction gadgets reflect result verifier computation accept reject performing types checks parity check rmb check 
define performance measure gadget relate final hardness result achieved performance measure obtained gadgets 
performance various gadgets different different checks suspect better idea construct gadgets optimize soundness snp keeping mind relative performance measures kinds gadgets employed 
surprisingly turns see claim optimization function performance gadgets choice parameters equation optimal reductions 
sources improvements 
explicit statement generic verifier deriving max snp hardness results novelty 
quantitative comparison previous works readily available 
certainly improve works new long code inner verifier atomic tests analysis section new idea folding improved analysis linearity testing due 
application minimizing soundness error query pcp direct corollary proposition obtain theorem np pcp log 
furthermore free bit complexity verifier 
satisfiability problems max sat max sat section mainly deal dnf formulae subsection deals formulae consisting conjunction parity clauses 
definitions formula set clauses clauses set literals 
consider various classes formulae 
particular sat formulae literals clause sat formulae exactly different literals clause sat formulae literals clause 
generic notation sat stand unspecified class correspond 
formula 
denote number clauses 
maxsat denote maximum number clauses simultaneously satisfiable 
maximum assignments variables number clauses satisfied 
maxsat maxsat denote maximum fraction simultaneously satisfiable clauses 
max sat problem sat instance finding maxsat 
approximation algorithm max sat achieves ratio factor ff ff delta maxsat maxsat sat instances 

definition indicates adopt convention approximation factor number 
max snp approximation discussed terms factors obviously equivalent inversion factor 
free bits pcp interested promise versions max sat exhibit gap maxsat delta value instances 
definition maxsat promise problems promise problem gap sat pair set sat instances satisfying maxsat set sat instances satisfying maxsat gap problem defined goal find promise problems having gap large possible np hard 
imply max sat problem hard approximate factor equal reciprocal gap np 
previous approximation algorithms 
max sat canonical max snp complete problem 
polynomial time algorithm due yannakakis ya approximates factor see goemans williamson alternate algorithm 
currently best known polynomial time algorithm max sat achieves factor due trevisan turn build goemans williamson 
max sat max snp complete simple algorithm achieves approximation expected fraction clauses satisfied uniformly chosen assignment 
max sat max snp complete gjs 
problem particularly interesting focus improvements approximation factor attainable polynomial time 
specifically goemans williamson exhibited polynomial time algorithm achieving approximation factor consequently feige goemans exhibited algorithm achieving 
non approximability 
non approximability results max snp problems proved exists constant ffl gap sat gammaffl np hard 
providing reduction np language promise problem question constructed encoding sat instance computation pcp log verifier np complete language variables instance corresponding bits proof string 
basic paradigm reduction maintained improvements 
depicts progress 
improvements constant value non approximability factor 
hadamard code inner verifiers 
introduced framework better analysis improved previous analyses exploit particular better analyses linearity testing cf 
section freivalds matrix multiplication test cf 
lemma 
improvement feige kilian obtained new proof systems besu canonicity property constant prover proofs optimizations 
see section discussion role constant prover proofs context 
garey johnson stockmeyer gjs provided early reduction max sat max sat showed non approximable non approximable 
best previous non approximability factor max sat get factor non approximability max sat 
fact new max sat result get hardness factor 
bellare goldreich sudan due assuming factor technique np constant np pcp log reduction max sat 
framework better analyses uses proof systems 
np new prover proof systems 
np new prover proof systems 
besu canonicity optimizations 
besu np canonicity optimizations 
np long code new proof systems 
non approximability results max sat indicating factor shown hard assumption done 
new results consequence theorem assuming np polynomial time algorithm approximate max sat factor max sat factor max sat factor 
theorem maxsat non approximability results promise problems nphard gap sat 
gap sat 
gap sat satisfying 
items hold gamma item holds long item implied item prove 
value item determined proof 
sources improvements 
principal part improvement max sat comes max snp verifier previous section 
verifier benefits new long code inner verifiers atomic tests analysis section 
gain new idea folding improved analysis due linearity test 
max sat result new reduction directly encodes computation verifier sat instances 
max sat max sat important feature optimization explicit sat sat expressions different tests clauses possible 
expressions max sat fact sat form yielding result max sat 
gadgets hardness maxsat context maxsat problems may easily replace condition form negation variable task designing gadgets simplified need implement simplified types checks parity check free bits pcp checking obtained oracle rmb check checking obtained oracle 
accordingly parity check pc gadget pc set clauses distinguished variables auxiliary variables ff fi pc gadget true maxsat pc ff ff gamma fi 
similarly respect check rmbc gadget rmbc set clauses distinguished variables auxiliary variables ff fi rmbc gadget true maxsat rmbc ff ff gamma fi 
stress cases maximum number clauses simultaneously satisfied ff 
gadget said sat gadget formula sat formula 
lemma describes gadget form obtain hardness maxsat 
lemma maxsat implementation verifier verifier logarithmic randomness perfect completeness soundness performs single parity check probability single rmb check probability gamma 
furthermore suppose case verifier identical queries 
exists ff fi parity check sat gadget containing clauses ff fi rmbc sat gadget containing clauses reduces gap sat ff ff gamma gamma ff ff gamma gamma gamma fi gamma particular gammas fi ff ff gammaq gamma gammas fi lemma assumed pc rmbc gadgets second parameter fi 
assumption really restriction transform pair ff fi pc gadget ff fi rmbc gadget pair ff fi fi fi pc gadget ff fi fi fi rmbc gadget achieving feature 
really matters fractions ff fi 
proof pc parity check gadget rmbc rmbc gadget 
encode computation input cnf formula corresponding bit proof oracle accessed verifier create variable 
addition create auxiliary variables aux random string verifier going max 
construct formula encodes computation verifier coins union formulae random string verifier performs parity check bits consists clauses pc aux aux 
hand verifier performs rmb check bits consists clauses rmbc aux aux 
denote number possible random strings observe number clauses equals delta qn delta gamma analyze value maxsat 
exists oracle accepts 
consider assignment true iff 
exists assignment variables aux number clauses satisfied assignment bellare goldreich sudan ff corresponds parity check ff corresponds rmb check 
qn gadgets pc gadgets gamma gadgets rmbc gadgets maxsat qn ff gamma ff expression follows 
consider case claim exists assignment satisfies qn ff gamma ff gamma gamma fi clauses exists oracle accepts probability know happen conclude maxsat qn ff gamma ff gamma gamma fi prove claim convert assignment variables oracle natural way iff true 
property gadgets pc gadget pc aux ff gamma fi clauses satisfied phi 
turn implies verifier accepts random string similar argument random strings correspond rmb checks 
property pc resp rmb gadget ff resp ff satisfied clauses claim checks hold 
assignment satisfies qn delta ff gamma fi gamma delta ff gamma fi sn fi clauses exist sn random strings accepts 
proves claim lemma follows 
describes gadgets max sat construction notice exact sat gadgets 
pc gadget pc consisting clauses rmb gadget rmbc consisting clauses clauses exactly variables 
gadgets auxiliary variables 
pc gadget merely canonical cnf expression 
clauses rmbc gadget canonical cnf expression clauses canonical cnf expression 
similarly describes sat gadgets max sat construction 
pc gadget pc consisting clauses rmb gadget rmbc consisting clauses 
gadget auxiliary variables 
auxiliary variable oe pc gadget supposed indicator event oe 
allows satisfy clauses appropriately setting indicator variables setting oe satisfies clauses 
rmbc gadget composed parts clauses handle expression clauses expression 
lemma sat gadgets gadgets exist sat gadgets pc gadget clauses rmb gadget clauses 
max sat gadgets 
pc rmbc max sat gadgets free bits pcp sat gadgets pc gadget clauses rmb gadget clauses 
ratio number clauses second parameter fi minimal sat gadgets 
generally claim sat ff fi gadget clauses test holds probability random assignment distinguished variables satisfy fi 
note parity test rmb test satisfy condition claim 
claim proven considering expected number clauses satisfied random assignment variables gadget 
may assume loss generality clause tautology clause may contain different literals variable 
clause contains literals belonging different variables satisfied probability 
follows expected number unsatisfied clauses random assignment satisfy test 
exists assignment distinguished variables satisfy test auxiliary variables set satisfy clauses gadget 
fi wants derive results gap sat ff fi follows 
questions arise 
particular get ff fi ratio sat sat giving away requirement ff equals number clauses 
sat 
general interesting find best possible gadgets terms lowest ff fi ratio tests formula classes prove gadgets really best possible 
proof lemma gadgets 
claim regarding sat follows motivating discussion gadgets merely canonical cnf expressions corresponding conditions 
sat gadgets satisfiable corresponding condition parity rmb holds part lemma follows 
turn sat gadgets starting pc gadget pc 
max sat gadgets 
pc rmbc max sat gadgets bellare goldreich sudan claim satisfy clauses 
done setting oe oe clearly assignment satisfies clauses variable ab appears ba 
clauses auxiliary variable appears negated satisfied assignment auxiliary variables auxiliary variable appears unnegated satisfied variable claim assignment satisfy clauses 
oe oe arbitrary partial assignment consider clauses variable oe appears 
satisfy clauses oe satisfy third clause oe contradiction hypothesis 
show assignment satisfy clauses 
oe oe arbitrary partial assignment consider clauses variable oe appears 
satisfy clause oe satisfy third clause oe contradiction hypothesis 
applying analysis clauses variable oe appears claim follows 
consider rmb gadget rmb 
gadget conjunction analogous cnf formulae consisting clauses 
consider clauses expression 
suppose 
regardless values satisfy clauses setting 
suppose oe oe 
satisfy clauses setting oeoe oe oe 
hand possible satisfy clauses requires setting satisfy rd th clauses turn requires setting 
suppose case claim truth assignment satisfy clauses 
claim proven contradiction 
know truth assignment satisfy clauses 
suppose truth assignment satisfies clauses 
oe satisfy clauses variable oeoe appears 
requires setting oeoe satisfy rd th clause turn forces set oe satisfy clauses contradiction case hypothesis 
clauses analyzed analogously 
conclude rmb condition holds satisfy clauses satisfy clauses 
furthermore case rmb condition hold satisfy clauses 
lemma follows 
proof theorem theorem follows applying lemma verifier proposition gadgets lemma 
details follows 
recall proof proposition may assume verifier identical queries 
applying lemma verifier proposition obtain reduction language np gap sat values determined function gadget parameters probability parameter soundness verifier proposition 
specifically observe sat ff sat ff 
cases fi free bits pcp expression gamma qff gamma ff gamma gamma determined proposition fl gamma fl substituting eq 
eq 
letting fl get ff ff gamma bounds sat sat follow ff values lemma 
particular sat get sat get conclude subsection presenting variant lemma 
variant refers sat restrictions verifier pcp system 
lemma max sat implementation generic verifier pcp gammaffi log ffi 
reduces gap sat gamma ffi proof verifier guaranteed hypothesis 
building lemma suffices show computation possible random tape captured cnf formula clauses 
warm consider special case non adaptive 
case canonical cnf clauses done 
variable consider possible assignments variables 
formula may case introduce single clause identically false resp true case introduce single clause resp clause 
general case adaptive handled analogously 
consider depth branching program describes acceptance specific random tape 
case tree rejecting leaves marked false writing corresponding cnf clauses state paths followed done 
consider depth subtrees 
subtree 
case leaves marked false write cnf clause states subtree reached 
case single leaf marked false write cnf clause leaf marked false write 
maximum satisfiable linear constraints parity clauses analogously maxsat problems considered consider parity linear clauses disjunctive clauses 
words system linear equations gf need determine maximum number equations may simultaneously satisfied 
maximization problem known max snp complete see brna pet 
provide stronger bound direct reduction verifier 
continuing problem maximizing number satisfiable equations confused bellare goldreich sudan complementary problem minimizing number violated constraints investigated arora 
case maximum satisfiable linear constraints larger fields size considered kann show problem hard approximate factor ffl universal ffl 
theorem defined analogously 
np hard 
proof theorem follows constructing appropriate gadgets 
pc gadget straightforward pc gadget 
conclude presenting rmb gadget consisting equations 
specifically rmb equations 
claim equations gadget observe resp resp equations hold 
hand resp resp equations violated 
resp regardless values exactly resp equations hold 
claim holds 
observe think rmb gadget gadget clauses equivalently think parity gadget gadget clauses 
proceeding proof theorem obtain hardness ff ff gamma gamma ff ff max cut definitions cut graph partition vertex set sets assignment weights weight cut sum weights edges endpoint maxcut denote maximum weight cut weight assignment maxcut denote quantity maxcut 
max cut problem instances pairs graph weight assignment find maxcut 
approximation algorithm max cut achieves ratio ff maxcut ff maxcut instances 
usual capture approximation problem promise problem definition maxcut promise problem promise problem gap cut pair set max cut instances satisfying maxcut 
set max cut instances satisfying maxcut gap problem defined free bits pcp previous sahni gonzales gave simple approximation algorithm problem 
breakthrough result goemans williamson gave new algorithm achieves ratio problem 
hand give approximation preserving reduction max sat max cut 
combined shows exists constant ff approximating max cut factor ff np hard 
explicit bounds best known hardness results max sat suspects bound max cut large reduction uses constructions constant degree expanders new result get explicit lower bounds constant upto approximating max cut problem np hard 
show theorem max cut problem np hard approximate factor 
theorem presents non approximability result weighted graph 
stress holds weights unary 
theorem max cut non approximability result gap cut np hard satisfying 
weaker result obtained simple graphs weights parallel edges 
particular may reduce max cut problem graphs parallel edges max cut simple graphs replacing edge path edges 
causes loss factor hardness factor get hardness factor max cut problem restricted simple graphs 
better reduction preserves non approximation ratio suggested crescenzi cst 
gadgets hardness max cut maxsat problem negate variables zero cost 
define gadgets parity rmb checking necessary adaptations inside lemma 
gadgets express verifier computation terms cuts graphs 
parity check gadget pc cut weighted graph vertices 
vertices correspond oracle queries verifier 
vertex special vertex mapping cuts truth values vertex corresponding oracle query considered set resides side cut considered set cut iff 
gadget ff fi pc gadget maxcut pc cut exactly ff restricted cuts induce vertices fa cg lie side cut ff gamma fi restricted cuts cut gadget check defined similarly 
similarly weighted graph rmbc cut ff fi rmbc gadget satisfies property maxcut rmbc cut exactly ff restricted cuts satisfying ff gamma fi 
cut gadgets generalized rmb checks checking defined similarly 
lemma similar lemma shows forms gadgets derive reduction np gap cut 
bellare goldreich sudan lemma maxcut implementation verifier verifier logarithmic randomness perfect completeness soundness performs single parity check probability single rmb check probability gamma 
refer generalized checks defined proposition 
furthermore suppose case verifier identical queries 
exists ff gamma fi fi pc gadget consisting edges total weight ff gamma fi fi rmbc gadget consisting edges total weight reduces gap cut ff ff gammaq gammaq ff ff gammaq gamma gammas fi gammaq particular gammas fi ff ff gammaq gamma gammas fi lemma holds provided generalized parity check resp rmb check functions ff fi gadgets resp ff fi gadgets 
proof pc cut denote parity check gadget rmbc cut denote rmbc gadget 
simplified gadgets defined 
increasing ff value fi easily obtain general gadgets defined proposition 
example check introduce gadget addition auxiliary vertex denoted new gadget consists edge having weight fi weighted graph pc cut 
clearly result ff fi gadget 
likewise check condition fixed bits follows 
case introduce auxiliary vertex connect edge weight fi graph rmbc cut 
case introduce auxiliary vertex connect edge weight fi graph rmbc cut 
case analogous obtained simplified 
ff fi gadgets cases rmb check 
point pc cut rmbc cut denote generalized gadgets 
create graph weight function encodes actions verifier input vertices follows bit proof queried verifier graph vertex 
random string tossed verifier create vertices going 
special vertex edges defined various gadgets 
stress edge may appear different gadgets weight gadgets may different 
graph defined edges graph multi graph parallel edges weights 
natural conversion graph parallel edges replaces parallel edges vertices single edge weight sum weights original edges 
alternatively weights constants depend transform unweighted graph parallel edges 
suppose random string verifier queries oracle bits parity check bits 
corresponding random string add weighted edges graph gr graph gr pc cut 
alternatively verifier performs respect monomial basis test bits add weighted edges graph gr rmbc cut 
denote number possible random strings observe total weight free bits pcp edges qn gamma analyze value maxcut 
exists oracle accepts 
define cut way place query place iff 
exists placement vertices size cut induced gr ff corresponds performing parity check ff corresponds performing rmb check 
weight obtained cut ff qn ff gamma consider claim exists cut weight cut greater qn ff gamma ff gamma gamma fi exists oracle accepts probability know happen conclude maxcut qn ff gamma ff gamma gamma fi 
prove claim convert cut oracle iff lie side cut 
property gadgets graph gr pc cut contributes weight ff gamma fi cut accepts random string 
similarly graph gr rmbc gadget contributes ff gamma fi cut accepts random string 
recall gadget contribute corresponding ff cut 
total weight cut ff gamma fi qn ff gamma fi gamma sn delta fi accepts sn random strings 
proves claim lemma follows 
turn construction cut gadgets 
gadget denoted pc cut aux complete graph defined vertices fa 
weight function assign edge fu vg weight delta 
claim shows pc cut aux functions parity check gadget 
claim maxcut pc gadget pc cut aux parity check gadget consisting edges total weight 
proof recall edges graph types edges aux having weight edges having weight 
total weight edges delta delta 
weight function decomposed product vertices weights express weight cut corresponding product delta 
turns weight cut maximized weight vertices sides equal specifically equal 
maximum cut weight 
furthermore max cut aux exactly vertices side 
hand cuts vertex weights split evenly weight 
characterization max cut conclude max cut may forms aux resides side side induced assignment satisfies parity condition 
aux resides side fa cg induces assignment variables parity condition satisfied 
max cut corresponds assignment satisfies parity condition assignment extended corresponds max cut 
claim follows 
second gadget denoted rmbc cut aux aux aux composed graphs denoted respectively 
motivate construction observe condition equivalent conjuction 
graph aux take care implication 
consists vertex set fb aux unit weight edges fb aux bellare goldreich sudan fb aux weight edge fc aux graph aux aux care second implication consists subgraphs pc cut aux pc cut aux supposed check 
specifically pc cut aux consists graph pc cut aux unit weight edge fa claim shows exactly gadget verifying claim maxcut rmb gadget rmbc cut aux aux aux rmbc gadget consisting edges total weight 
proof clearly total edge weight 
analyze performance sub gadgets considering cases 
recall sub gadgets corresponds condition form linear conditions variables 
case corresponds satisfied case second case called neutral corresponds satisfied third case called bad corresponds satisfied violated 
start fact consider set cuts aux 
case side cut place aux cut weight 
hand cut weight 
neutral case opposite sides cut place aux weight cut 
hand maximum cut weight cuts 
bad case side cut opposite side matter aux placed cut weight 
proof lower bounds items proven placing aux opposite side upper bounds items obvious total edge weight placing opposite sides allow placing aux opposite 
item obvious cases get cut weight 
fact consider set cuts aux aux 
case opposite sides place aux aux cut weight 
hand cut weight 
neutral case side cut place aux aux weight cut 
hand maximum cut weight cuts 
bad case opposite sides maximum cut weight cuts 
proof recall aux aux consists subgraphs pc cut aux pc cut aux edge fa item follows claim lower bound place opposite 
upper bound item follows claim observing case 
obtain maximum weight pc gadgets lose edge fa obtain weight pc gadgets way bound follows 
free bits pcp lower bound item follows observing place opposite holds 
extending argument claim observe parity condition satisfied place auxiliary vertex obtain cut weight 
obtain cut weight claimed 
item follows claim observing 
pc cut aux contributes weight cut claim pc cut aux contributes 
case edge fa cut 
cases maximum cut weight obtained delta 
concludes proof fact 
claim follows combining facts 
recall rmb condition equivalent conjunction 
rmb condition holds obtain case weight sub gadget say neutral case weight gammai 
value depends 
total weight equals obtained 
rmb condition hold obtain bad case weight sub gadget neutral case weight 
total weight equals obtained 
claim follows 
proof theorem theorem follows combining proposition lemma claim claim regarding rmb gadget gadget gadget 
details follows 
proof theorem applying lemma verifier proposition obtain expression gap np gap cut gamma fi delta ff gamma delta ff gamma gamma fi ff ff gamma recall ff gamma ff gamma ff ff see lemma 
simplifies bound follows 
equals ff ff 
free bits vertex cover known approximating minimum vertex cover graph ffl factor hard ffl 
know previous attempt provide lower bound ffl 
initial attempt may vc gadgets implement various tests snpinner analogously way done previous sections max sat versions max cut 
yields lower bound ffl 
stronger result obtained free bit complexity 
specifically apply fglss reduction proof system np free bit complexity lowest possible results section free bits 
consequently clique size case original input language fourth size graph means translating clique approximation factors factors yields loss third 
fglss transformation translates bellare goldreich sudan enhanced rmb test 
sigma object tested test take additional inputs parameters enhanced monomial basis test invoke 
output invocations answered output 
passing probability pr enhanced rmb test passing probability 
completeness soundness ratio gap factor approximating clique goal construct np proof system uses free bits soundness error low possible 
proof system subsection uses free bits achieves soundness error 
reader may observe approach worthwhile proof system subsection proof systems achieves soundness error cost free bits 
minimizing error achievable free bits pcp system proposition free bit complexity query complexity 
smaller soundness error achieved queries 
starting point part lemma suggests rmb test twice bigger detection probability free bits alas queries 
specifically consider enhanced rmb test input goes invoking atomic rmb test input functions enhanced rmb test denoted depicted 
improvement obtained packing linearity test enhanced rmb test contrast snpinner tests performed exclusively 
tests queries common answers queries determine answer third query different tests 
resulting inner verifier denoted inner depicted 
snpinner verifier inner works functions oracles folded twice 
corollary immediate part lemma 
corollary analysis enhanced monomial basis test sigma satisfying linear respecting monomial basis 
dist 
gamma delta gamma lemma analogous lemma 
loosely speaking considers possible free bits pcp strategies dishonest prover indicates probability verifier detects error 
lemma soundness inner ffi ffi canonical inner verifier inner parameter ae ffi ffi gamma ae min def gamma ffi delta def delta min gammaffi max gamma lin delta gamma def min gammaffi delta gamma lin gamma delta gamma ffi gamma 
proof analysis broken cases proof lemma 
dist lin 
case gamma ffi lemma implies gamma gamma lin gamma ffi inner performs atomic linearity test probability case gamma acc inner oe delta gamma ffi case gamma ffi lemma implies gamma gamma lin gamma acc inner oe delta gamma lin free bit inner verifier 
functions oe sigma sigma verifier access oracles sigma sigma 
addition takes parameter 
pick 
case pick 

case pick oe 
access implemented accessing 
free bit inner verifier inner bellare goldreich sudan follows 
linear function dist consider sub cases 
case respect monomial basis case implies gamma gamma 
probability inner rejects delta gamma 
combining lower bounds gamma acc inner oe get gamma acc inner oe delta max gamma lin gamma case respects monomial basis proposition evaluation operator 
exists sigma dist oe 
proof splits sub cases 
case def dist gamma ffi lemma gamma oe delta gamma gamma ffi delta gamma 
probability inner performs projection test rejects gamma delta gamma ffi gamma 
add probability exclusively disjoint event verifier performs linearity test rejects obtaining gamma acc inner oe delta gamma lin gamma delta gamma ffi gamma case case dist gamma ffi dist gamma ffi functions satisfy conditions definition 
similarly proof lemma infer lower bound gamma ae claimed lemma follows 
simplify soundness bound lemma 
proof item uses fact gamma lin 
second item uses fact gamma lin 
claim min gammaffi max gamma lin gamma 
min gammaffi delta gamma lin gamma delta gamma delta min gamma 
lemma 
min min ae delta delta gamma oe gamma max ffi ffi interestingly lower bound provided item tight see claim 
optimization calls setting delta delta gamma yields soundness bound gamma max ffi ffi gamma max ffi ffi 
proof proving part consider cases 
case 
case definition gamma lin max gamma lin gamma gamma lin free bits pcp case 
case max gamma lin gamma gamma establishes part 
proving part consider different cases 
case gamma 
case delta gamma lin gamma delta gamma delta delta gamma case gamma 
case delta gamma lin gamma delta gamma gamma delta gamma delta gamma gamma establishes part 
prove part parts lower bound respectively get min min ae gamma ffi delta delta delta min gamma gamma ffi oe min ae delta delta gamma oe gamma max ffi ffi claim follows 
composing inner verifier adequate outer verifier get theorem np fpcp log 
furthermore verifier constant query complexity 
proof ffi gamma ffi ffi ffi ffl ffi delta ffi ffi ffi integers outer verifier outer guaranteed lemma canonical ffl np 
consider canonical inner verifier inner working parameter 
lemma claim conclude inner ae ffi ffi ae gamma max ffi ffi 
composing outer inner obtain verifier free theorem soundness error bounded max ffi ffi ffl ffi ffi required 
furthermore free uses logarithmically coins 
claim free query complexity free bit complexity 
claim obvious case inner performs projection test 
inner performs linearity test parameters enhanced rmb tests parameters 
clearly answers determine acceptable linearity test answer key observation answers determine acceptable answers enhanced rmb test answer delta equal answer answer zero 
repeating proof system times obtain corollary np fpcp log 
furthermore verifier constant query complexity 
proof exists ffl gamma ffl delta bellare goldreich sudan hardness vertex cover preliminaries 
vertex cover graph set fu vg fu vg denote size smallest vertex cover jv min vc problem instances graphs find 
approximation algorithm min vc achieves ratio factor ff ff delta graphs 
adopted convention minimization problems approximation factor 
capture approximation problem promise problem time parameter referring instances lower parameter referring instances 
definition promise problem gap vc pair set graphs satisfying set graphs satisfying gap problem defined known upper lower bounds 
simple polynomial time algorithm approximate min vc unweighted graphs factor 
algorithm due cf 
gj consists vertices appear maximal matching graph 
weighted graphs bar yehuda hochbaum hoc gave algorithms achieving approximation factor 
best known algorithm today achieves factor slightly better gamma log log jv log jv 
evidence hardness approximating min vc bar yehuda moran showed ffl gamma ffl approximator finding minimum vertex cover yield algorithm coloring colorable graphs logarithmically colors 
version min vc restricts attention graphs degree bounded constant max snp complete suitably large 
particular provide reduction max sat 
combined implies existence constant ffi approximating min vc factor ffi hard np 
explicit value ffi stated 
value derived best existing non approximability results max sat small cost reduction reduces max sat bounded version expanders reduces min vc 
going free bits vc 
reducing max sat theorem get gaps clique size 
apply standard reduction 
proposition fpcp log gap vc gamma gammaf gammas gammac proof fglss reduction says fpcp log gap clique gammaf delta gammaf delta 
see section definition gap clique 
apply standard karp reduction maxclique min vc maps graph complement noting gamma maxclique 
gap clique gap vc gammac gammas gamma gamma gammaf gamma gamma gamma gammaf gamma gammaf gamma gamma completes proof 
free bits pcp results 
obtain explicit reasonable constant factor non approximability result min vc 
consequence theorem assuming np polynomial time algorithm approximate min vc factor 
theorem gap vc np complete satisfying 

proof follows immediately proposition theorem 
np fpcp log gap vc gamma gamma gammas gamma gammas gamma ffl gamma ffl ffl def gamma special case proposition statement restricted suffices proving theorem 
reason applied proposition theorem obtain np fpcp log special case proposition reducible gap vc gamma gamma gamma gammas 
interestingly special case proposition reversed gap vc reducible fpcp log gamma gamma gammas gammac reverses gammas gammac gammas gammac 
key fact proving reverse reduction corollary asserts gap clique fpcp log 
know possible reverse step alternative proof fpcp log reducible fpcp log reverse transformation weaker see proposition 
verifier establish min vc hardness current vc gadgets yield hardness result inferior may case improved results obtained better implementation verifier 
sections define problem specific gadgets establish reduction pcp systems promised problem hand 
gadgets graphs distinguished vertices corresponding literals variable appearing test check 
covers induce truth assignments standard manner literal set iff corresponding vertex cover 
covers contain literals variable defined set variable special symbol satisfy equality 
specifically parity check gadget pc vc graph vertices correspond oracle queries verifier 
gadget ff fi pc gadget pc vc exactly ff restricted covers induce vertices fa cg cover ff fi restricted covers similarly graph rmbc vc ff fi rmbc gadget satisfies property rmbc vc exactly ff restricted covers satisfying ff fi 
stress covers minimal size contain exactly vertices corresponding distinguished pair literals 
lemma similar lemmas shows forms gadgets derive reduction np gap vc 
lemma implementation verifier verifier logarithmic randomness perfect completeness soundness performs single parity check probability single rmb check probability gamma 
furthermore suppose case verifier identical queries 
exists ff fi pc gadget consisting vertices ff fi rmbc gadget consisting vertices reduces gap vc ff ff gammaq gammaq ff ff gammaq gammas fi gammaq particular gammas fi ff ff gammaq bellare goldreich sudan proof reduction analogous reductions 
possible random string introduce graph gr copy corresponding gadget 
vertices edges copies distinct 
addition variable corresponding oracle location join edges occurrence occurrence query random strings join edge vertex labeled gr vertex labeled gr letting denote number possible random strings observe number vertices resulting graph delta qn delta gamma resulting graph cover ff delta qn ff delta gamma vertices just cover corresponding oracle prover accept 
hand claim resulting graph denoted cover size smaller ff qn ff gamma gamma fi 
claim proven bound follows 
fixing arbitrary cover define oracle setting copies cover 
edges joining occurrences conclude case copies cover 
copy pc gadget resp rmb gadget having ff resp ff vertices cover corresponds random string verifier accept oracle soundness verifier conclude gamma gadgets correspond random strings verifier rejects claim follows 
hardness results derived combining proposition lemma 
existence ff pc gadget vertices ff rmb gadget vertices implies np hardness gap vc ff ff ff ff know construct pc gadget vertices rmb gadget vertices 
yields gap order beat current hardness gap established reduction free bit pcp need construct gadgets ff weighted average ff ff 
approach verifier establish hardness offers little hope progress 
minimizing number queries problem consider minimize values av construct np queries worst case av average achieve soundness error 
allow logarithmic randomness 
words want results form np pcp coins log query query av av return question looking lower bounds 
previous 
shown constants av achieved 
reductions values numbers obtained depicted 
contrast maxcut implementation non auxiliary vertices gadgets 
free bits pcp due av constant constant worst case average av number queries needed get soundness logarithmic randomness results form eq 

interest numbers improve non approximability factors max clique 
know free bits better measure besu 
remain interested query bits sake 
number bits queried remains natural measure question bits proof need look detect error probability 
sources improvements 
principal part improvement comes new long code inner verifier atomic tests analysis section new idea folding 
repeating proof system theorem times obtain eq 
holds 
repetitions yielding suffice 
straightforward implementation recycling technique yields av eq 
achieved 
careful implementation technique reduce query complexity additional bit 
pcp inner verifier result construction canonical inner verifier depicted 
addition standard inputs oe takes parameters 
inner verifier combines atomic tests different ways 
tests performed independently main steps tests performed re queries tests step re tests performed mutual exclusive manner tests step previous sections tests executed function verifier effective oracle access access inspection clear total number accesses oracles free bit complexity 
examine goodness recall definitions functions gamma lin lemma gamma rmb gamma lemma 
lemma soundness ffi ffi satisfy canonical inner verifier ae ffi ffi gamma ae minimum quantities gamma ffi gamma min gammaq gammap def gammap min gamma ffi gamma ffi delta gamma bellare goldreich sudan furthermore ffi ffi gamma ae proof split analysis cases value dist lin 
case gamma ffi lemma implies gamma gamma lin gamma ffi case acc oe ae def gamma delta ffi delta ffi ffi gamma inequality due ffi ffi get ae 
case gamma ffi sigma linear function dist proof splits subcases 
case respect monomial basis case lemmas acc oe gamma gamma lin delta gamma gamma rmb delta gamma gamma lin gamma gamma rmb pcp inner verifier 
canonical inner verifier functions oe sigma sigma access oracles sigma sigma 
addition takes non negative parameters sum 
pick functions step linearity test 
step combined rmb projection test 
oe 
step invoking snpinner parameters pick 
case 
case 
case oe 
accept iff tests accept 
access implemented accessing 
pcp inner verifier free bits pcp 
gamma gamma lin delta gamma gamma rmb delta gamma delta gamma lin gamma delta gamma rmb gamma ff delta fi delta qff gamma fi gamma def ff gamma gamma lin fi gamma gamma rmb 
delta gamma delta delta gammap show ff delta fi delta qff gamma fi ff gammaq fi specifically ff gamma fi delta ff fi delta qff gamma fi ff fi delta delta qff gamma fi delta delta ff delta fi delta qff gamma fi ff delta fi delta qff gamma fi combining claim bound obtain acc oe gamma delta gamma lin gamma gamma delta gamma rmb gamma gamma min gamma gamma observe min gammaq maximized value 
value consistent delta case get acc oe ae def gamma gamma get ae 
case respects monomial basis proposition evaluation operator 
exists sigma dist oe 
proof splits sub cases 
case def dist gamma ffi lemma oe gamma delta gamma ffi letting gamma prj def gamma gamma ffi get case acc oe ae def gamma gamma lin delta gamma gamma prj delta gamma gamma lin gamma gamma prj upper bound ae considering sub cases corresponding segments gamma lin 
case 
case gamma lin gamma obtain ae 
gamma gamma lin delta gamma gamma prj delta gamma gamma prj bellare goldreich sudan 
gamma gamma delta ffi delta gamma delta theta gamma delta gamma ffi delta gamma ffi inequality uses fact function gamma non negative interval 
ffi obtain ae 
case 
case gamma lin gamma lin gamma prj gamma prj obtain ae 
gamma gamma lin delta gamma gamma prj delta gamma gamma lin gamma gamma lin delta gamma gamma prj delta gamma gamma lin delta ffi delta gamma 
ffi delta gamma ffi delta obtain ae delta 
case 
case gamma lin obtain ae 
gamma gamma lin delta gamma gamma prj delta gamma gamma lin 
gamma delta ffi delta gamma expression decreases interval maximized 
obtain expression case bound ae follows identically 
conclude case ae max gamma ffi ffi delta gamma case gamma ffi case dist gamma ffi dist gamma ffi functions satisfy properties required conditions definition 
ae def ae ae conclude case allows acc oe ae case satisfies conditions definition 
satisfies condition definition 
clearly satisfies condition definition lemma follows 
free bits pcp new proof system combining inner verifier adequate outer verifier obtain pcp system np query complexity 
theorem np pcp coins log query query av 
furthermore free bit complexity proof system 
proof consider canonical inner verifier parameters delta delta 
lemma ae ffi ffi ffi ffi ae max gamma ffi 
choose appropriate outer verifier 
ffl delta gamma ae ffi ffi lemma provides ffl canonical outer verifier outer randomness log exists 
hv outer composition outer definitions section 
verifier randomness log 
apply theorem see completeness parameter soundness parameter ae ffl ffi ffi 
query free bit complexity respectively 
obtain bound average query complexity observe afford perform rmb test small probability 
specifically case proof lemma case rmb test yields error gammap modify rmb test invoked performed probability get case detects violation probability gamma gamma delta 
consequently modified inner verifier errs probability bounded away composed verifier 
modification decreases average query complexity gamma delta delta delta 
reduction step second case step 
theorem follows 
iterated tests iterated tests free bits proof system 
running atomic tests times keep free bit count low independent repetitions 
besu run copies test way pairwise pairwise independent lower error probability gammam 
done free bits 
specifically select uniformly functions functions invoke atomic tests functions resulting possible linear combinations selected functions 
linearity randomness observations relating probabilistic linear independence 
note lm sub vector space fm particular vector space sigma right 
discuss linear independence functions lm say linearly independent linearly independent 
furthermore say mutually linearly independent functions linearly independent 
lemma defined ffi ffi 
fix consider probability space defined having bellare goldreich sudan uniformly independently distributed regard random variables probability space 
linearly independent uniformly distributed 
mutually linearly independent independently distributed 
analysis iterated projection test see done relatively straightforwardly invoked projection test uses single linear combination combinations iterated tests 
iterated projection tests 
analysis iterated tests atomic tests invoked linear combinations require slightly care 
corresponding lemmas proven notion weak pairwise independence introduced besu 
alternative approach 
iterated projection test iterated projection test described takes input vector linear function lm note ffi test just atomic projection test input 
lemma says passing probability representing invocations atomic projection test slightly significant close close encoding projection lemma constant true 
oe sigma sigma function 
sigma dist oe sigma oe delta gammam dist 
proof proof similar besu lemma 
ffl dist assume 
show constant delta gammam jl gamma 
theta sigma defined def oe oe ffi ffi regard random variable uniform distribution theta suffices show pr 
lemma implies fx pairwise independent identically distributed random variables 

lemma pr oe ffi ffi pr oe lemma ffl gamma ffl ffl def dist 
conclude applying chebyshev inequality 
pr pr jx gamma np np np desired 
free bits pcp technical claim analyzing tests simple claim 
claim contains subset cardinality mutually linearly independent 
proof linearly independent 
probability chosen uniformly lm linearly independent gamma probability uniformly chosen mutually linearly independent greater gamma gamma gamma consider graph vertex set edges connecting pairs mutually linearly independent sequences connected mutually linearly independent 
graph vertices vertex linearly independent degree greater gamma delta clearly graph clique size consider greedy algorithm pick vertex maximal degree vertices connected previously selected vertices 
noting clique corresponds set mutually linear independent sequences done 
iterated linearity test iterated linearity test described takes input vector linear functions lm note ffi ffi test just atomic linearity test inputs 
lemma says passing probability slightly significant linear 
lemma constant delta gammam dist lin 
proof assume ffl def dist lin 
show constant delta gammam sigma defined def ffi ffi regard random variable uniform distribution ae set guaranteed claim suffices show pr 
analysis small fraction possible invocations iterated linear test small fraction corresponds sufficiently large number invocations 
lemma follows random variables fx pairwise independent def pr pr lemma gamma lin ffl ffl gamma ffl ffl 
case get 
chebyshev inequality pr pr jx gamma pj def jsj 
lemma follows 
bellare goldreich sudan iterated tests 
sigma sigma objects tested 
tests take additional inputs parameters lm oe sigma sigma tests specified terms atomic tests 
ffi ffi 
ffi ffi ffi 
oe oe ffi ffi 
passing probabilities 
probabilities interested pr lm pr lm oe pr lm oe iterated tests passing probabilities 
iterated rmb test iterated respect monomial basis test takes input linear functions lm simplicity exposition assume folded 
assumption justified usage test see subsection 
probability significant conclude linear function close respects monomial basis 
lemma constant true 
sigma ffl ffl close linear function suppose delta gammam respects monomial basis 
proof assume linear respect monomial basis 
show constant delta gammam sigma defined def ffi ffi ffi regard random variable uniform distribution ae set guaranteed claim suffices show pr 
free bits pcp lemma follows random variables fx pairwise independent def pr pr lemma gamma ffl ffl gamma ffl ffl follows 
chebyshev inequality done 

general folded similar result proven augmenting iterated rmb test input checks ffi ffi 
putting things lemmas allow conclude passes tests significant probability close evaluation operator 
need circuit test 
corollary constant true 
sigma suppose delta gammam delta gammam string sigma dist 
proof larger constants lemmas 
lemma linear dist 
second lemma implies respects monomial basis fact 
proposition says evaluation function 
proposition 
amortized free bits max clique coloring definitions clique graph subset vertices pair vertices connected edge 
maxclique maxf jsj clique gg denote maximum clique size maxclique maxclique ratio max clique size number nodes kgk graph 
max clique problem instance graph find maxclique 
approximation algorithm max clique achieves ratio ff maxclique ff maxclique graphs ff function number nodes chromatic number smallest number colors nodes colored adjacent vertices color 
denoted usual coloring problem finding 
approximation algorithm coloring achieves ratio ff ff delta graphs promise problems gap clique gap corresponding approximation defined analogously previous definitions problems 
functions 
bellare goldreich sudan sources improvements adopt basic framework construction proof systems low free bit complexity besu 
improvement comes new long code hadamard code basis construction inner verifiers 
allows save bit amortized free bit complexity 
reason long code contains explicitly functions encoded string hadamard code contains linear combinations bits string 
typically need check verifier accepts string condition expressed linear combination bits string 
needs keep linear combinations bit products extra combinations self correcting increases amortized free bit 
seen long code allows directly handle function 
fact take linear combinations functions confuse reader linear combinations random functions linear combinations random linear functions besu 
construction results construction proof systems amortized free bit complexity bits obtained composing canonical outer verifier lemma canonical inner verifier denoted free depicted 
inner verifier free consists invoking iterated tests 
addition free applies linearity test oracle done order improve rejection probability free case oracles far fine order decrease number accepting configurations consequently free bit complexity 
free invokes iterated tests providing access double folding 
eliminates need checking encodes string evaluates zero simplifies iterated rmb test see subsection 
previous subsections simplifications buy significant free inner verifier 
functions oe sigma sigma verifier access oracles sigma sigma 
takes integer parameter random choices lm lm lm oe lm access implemented accessing 
free inner verifier free free bits pcp additional testing done additional cost free bits 
lemma exists constant true 
integers 
canonical inner verifier free parameter ae ffi ffi ae delta gammam ffi 
proof analysis careful analogous statements lemmas 
corollary respect oracle conclude passed iterated linearity rmb tests probability delta gammam exists string sigma dist gammaffi 
lemma conclude passed iterated projection test probability delta gammam dist oe gamma ffi setting ae delta gammam maxfc conclude free satisfies condition definition 
clearly free satisfies condition lemma follows 
proposition integers 
canonical inner verifier free parameter uses free bits 
proof consider accepting computations free start observing oracle values obtained iterated linearity test determined values locations likewise oracle values obtained iterated rmb test determined values locations oracle values obtained iterated projection test determined values locations ffi values locations fact free applies iterated linearity test oracle follows oracle values obtained accepting computations free determined values locations conclude accepting computations free values obtained oracles determined bits 
composing canonical outer verifier lemma canonical inner verifier free get theorem constant true 
np integer 
pcp coins log free delta gammam proof np language integer lemma construct gammam outer verifier denoted outer recall outer verifier uses logarithmic randomness randomness depends linearity constant 
compose outer inner verifier free free uses integer parameter 
composed verifier free bit complexity inherited free proposition 
theorem soundness error composed verifier delta gammam delta gammam soundness error free due lemma 
theorem follows 
selecting sufficiently large ffl log ffl constant get theorem ffl case np fpcp log ffl 
bellare goldreich sudan fglss transformation get theorem ffl np gap clique ffl 
np gap clique ffl proof part corollary log ffl get np randomly reducible pcp system randomness free bit complexity ffl error probability gammak fglss graph corresponding resulting pcp system size ffl gap clique size factor rewritten ffl clique size case input language rewritten ffl substituting ffl ffl claim part follows 
part corollary get pcp system np randomness ffl free bit complexity ffl error probability gammak fglss construction system claim part follows 
combining reduction furer fu turn improved reductions kls besu get theorem ffl np gap gammaffl 
gap np complete gammaffl previous max clique 
prior non approximability results max clique known 
connection proofs feige fglss 
fglss reduction says pcp coins query karp reduces gap clique reduction running time poly gap function error applying works pcp classes containing np 
obtains result saying max clique polynomial time approximation algorithm achieving certain factor assumption deterministic time complexity np time complexity depends factor importantly error 
particular authors able scale proof system bfl indicate strong non approximability factors log ffl ffl assuming np quasi polynomial deterministic time 
initiated improving factors assumptions better proof systems 
best result indicated 
arora safra reduced randomness complexity pcp verifier np logarithmic showed np pcp coins log query log 
observed random bits recycled error reduction standard techniques aks cw 
consequence np hardness result max clique approximation 
corresponding factor log arora showed np pcp coins log query implied exists ffl approximating max clique ffl np complete 
number queries unspecified indicated ffl gamma focused reducing constant value ffl exponent 
slightly tighter form fglss reduction due zu 
says pcp coins query av av reduces randomized karp reduction value ffl gamma means size graph number particles universe factor ffl exceeds 
free bits pcp due factor assumption fglss log gammaffl ffl np log np ffl ffl np np cor np np besu np cor besu np np np milestones project proving non approximability clique number approximation factor terms graph size infeasible achieve indicated assumption 
stating results ignore ffl terms ffl arbitrary small 
gap clique satisfying running time reduction poly 
assume av simplicity 
omit factors ffl ffl arbitrarily small 
hardness factor tied average number queries required get soundness error 
assumption involved probabilistic deterministic time complexity np np cor polylog np log 
new proof systems able obtain significantly smaller query complexity showed np pcp coins polylog query np pcp coins log query 
leads hardness results shown 
significantly reducing average number bits queried hard 
observed feige kilian performance fglss reduction depends free bit complexity may significantly smaller query complexity 
factor mentioned reduction free bit complexity 
observed proof system free bit complexity yielding hardness approximation factor 
notion amortized free bits introduced besu 
observed performance reduction depended fact quantity factor amortized free bit complexity 
showed np fpcp polylog 
lead hardness factor assuming np cor chromatic number 
hardness result chromatic number due garey johnson gj 
showed np polynomial time algorithm achieve factor 
remained best result connection proofs mentioned results emerged 
hardness results chromatic number obtained reduction max clique 
bellare goldreich sudan ffl factor hardness max clique translates ffi factor hardness chromatic number ffi function ffl 
discuss quality reductions besu define reduction achieves ffi gammab ffl ffl gammab ffl reduction lund yannakakis reduction 
max clique hardness results implies chromatic number hard approximate ffi ffi 
ffi small 
improvements ffi function improvements ffl values reductions available 
subsequent reduction khanna linial safra kls simpler fact slightly efficient reduction 
efficient reduction besu reduction 
hardness clique yield hardness chromatic number 
efficient reduction available furer fu 
reduction get hardness 
randomized de randomized error reduction 
mentioned randomized derandomized error reduction techniques play important role obtaining best clique hardness results fglss method 
typically reduces error logarithm relates query free bit complexity initial randomness cost ignored long logarithmic 
needed construct proof systems minimize parameter constant factor logarithmic randomness complexity 
randomized error reduction method originates berman schnitger applied clique gap promise problem 
alternative description zuckerman zu 
alternative description carried proof system section 
de randomized error reduction method consists applying general de randomized techniques proof system setting 
best method knows expander walk technique due ajtai aks see cw 
easy see applies pcp context 
usage methods pcp context begins 
turns constant parameters expander specifically ratio ae def log log degree expander second eigenvalue adjacency matrix play important role 
particular ae gamma determines lose respect randomized error reduction np fpcp log translates hardness factor np bpp hardness factor ae np 
ramanujan expander lubotzky phillips lps play important role yielding ae cf 
proposition best possible 
coding theory bound provide coding theory bound proof lemma 
slight extension bounds ch 
consider vectors weight exactly sake completeness include proof bound 
discussing binary vectors weight number ones vector distance vectors number places disagree 
reductions assumptions regarding structure graph directly yield hardness results stated 
consequence results able remove assumptions earlier papers results simpler form 
see section details 
free bits pcp lemma maximum number binary vectors length weight distance apart 
gamma fi ff gamma fi provided ff fi ff gamma fi gamma 
proof consider arbitrary sequence vectors mutual distance 
denote th entry th vector weight th vector average value 
define def hand jm jm gamma mw gamma delta gamma inequality follows observing jfk gj jfk gj hand jfi gj allows lower bound minimum subject mw 
minimum obtained equal yields delta mw confronting bounds get delta delta gamma gamma delta yields gamma letting ff gamma ff ff fi get gamma fi ff gamma fi lemma follows observing bound maximizes ff ff 
optimality choices analysis section demonstrate optimality choices analysis previous sections 
bellare goldreich sudan choice probability parameters snpinner start proving choice probabilities snpinner requiring satisfy eq 
optimal minimizing soundness upper bound provided lemma 
show matter selects probabilities expression lemma upper bound provided claim 
claim choice parameters expressions delta min delta gamma lin delta gamma rmb min delta gamma lin delta gamma 
furthermore minimum expressions bounded min delta delta delta proof furthermore clause follows setting 
expression maximized delta delta delta yields eq 

optimum value 
setting represents plausible existence oracles proof lemma provides soundness bounds appearing claim 
specifically case corresponds having oracle far away distance linear 
case corresponds having linear respecting monomial basis distance long code 
case corresponds having codeword distance oe evaluating snpinner independently gadgets 
lemmas lemma provide hardness results factor gammas ff deltaq ff delta gammaq depend verifier ff ff depend gadgets 
specifically soundness error verifier snpinner performs parity check probability rmb check probability gamma approach select probabilities snpinner minimize turn determines gamma natural question better allow greater error obtain smaller value gamma natural ff smaller ff sat gadgets parity check obtained special case rmb check setting 
claim ff 
def min soundness upper bound provided lemma claim 
gammas ff delta gammap ff deltap maximized satisfying eq 

proof eq 
factor hardness factor obtained implementing snpinner corresponding gadgets factor def gamma ff ff gamma ff delta consider cases 
free bits pcp case case loss generality assume claims equality claim inequality get factor delta ff ff gamma ff delta factor delta ff ff gamma ff delta factor factor follows easily 
case claim factor delta ff ff gamma ff delta ff ff gamma ff hand claim get factor delta ff ff gamma ff delta ff ff gamma ff observing ff ff gamma ff 
ff ff gamma ff obtain factor factor 
analysis inner show choice probability parameter inner setting optimal minimizing soundness upper bound provided lemma 
show matter selects parameter expression lemma upper bound provided theorem 
claim choice parameter expressions delta delta min gammaffi max gamma lin gamma min gammaffi delta gamma lin gamma delta gamma 
furthermore minimum expressions bounded min delta delta gamma proof observe def min gammaffi max gamma lin gamma max gamma lin gamma delta bellare goldreich sudan def min gammaffi delta gamma lin gamma delta gamma min gammaffi delta gamma lin gamma delta gamma min gammaffi delta gamma delta gamma delta gamma furthermore clause follows observing min delta min delta delta gamma 
expression maximized delta delta gamma yields proof theorem 
optimum value delta proofs approximation potential limitations seen chapter non approximability results getting steadily stronger particularly max clique 
far go 
chapter answering kind question 
section describes reverse connection indicating necessity proof checking techniques derivation non approximability results max clique pointing amortized free bits crucial parameter 
second section focuses lower bounds amortized free bits indicate free bit result section tight light current techniques 
indicate needs new techniques prove better hardness max clique 
reverse connection consequences feige fglss describe procedure takes verifier input constructs graph denote vertices correspond possible accepting transcripts computation edges corresponding consistent non conflicting computations 
show connection maximum possible oracles acceptance probability verifier clique size graph 
recall acc max prr maximum accepting probability 
recall maxclique maximum clique size 
theorem fglss input verifier tosses coins relationship holds acc maxclique section essentially show inverse construction 
clique gap verifier stress term graph mean undirected simple graph self loops parallel edges 
bellare goldreich sudan theorem clique verifier ordinary graphs exists verifier denoted logarithmic randomness complexity logarithmic query length zero free bit complexity input node graph satisfies acc maxclique furthermore gw isomorphic isomorphism easily computable 
lastly proof oracle construct polynomial time clique size pn probability accepts oracle access proof input graph nodes verifier works proofs length gamma delta gamma je proof indexed edges non edges 
clarity proof assume binary value fu vg merely matter encoding consider mapping standard set binary values set fu vg 
input access oracle verifier acts follows picks uniformly vertex vertex set fu vg verifier queries oracle fu vg rejects fu vg verifier reject queries answered accepts 
properties clearly tosses log coins 
picks vertex pattern may accepts 
free bit complexity 
analyze probability accepts input best oracle access prove claim 
graphs gw isomorphic 
proof 
proof straightforward 
needs choose encoding accepting transcripts computation input choose full transcript random coins entire sequence queries answers specified 
generic accepting transcript form def fu fu random vertex selected verifier fv set non neighbors stress accepting transcript verifier selected vertex vertex transcript accepting 
may consider mapping oe maps claim oe isomorphism gw suppose adjacent gg 
definition fglss graph transcripts consistent 
follows query appear accepting transcripts conflicting answers 
definition conclude non edge oe oe 
suppose hand 
follows query fu vg appear query may appear transcript conclude transcripts consistent adjacent gg 
theorem follows probability accepts input best oracle maxclique equals maxclique furthermore proof accept probability accepting random strings constitute clique size pn gw 
accepting random strings polynomial time encode vertices form clique 
free bits pcp generalize construction get verifiers indicate existence large cliques layered graphs 
layered graph vertex graph vertices arranged layers edges vertices layer vertices layer 
convention layered graph algorithm partition layers implicit encoding graph 
theorem clique verifier layered graphs exists verifier denoted logarithmic randomness complexity logarithmic query length input layered graph free bit complexity log average free bit complexity log satisfies acc maxclique furthermore gw isomorphic isomorphism easily computable 
lastly proof oracle construct polynomial time clique size pl probability accepts oracle access proof input layered graph verifier works proofs consisting parts 
part assigns layer integer vertex layer redundant encoding answers vertex names index number vertices layer 
second part assigns pairs non adjacent vertices binary value represented vertices 
input access oracle verifier acts follows picks uniformly layer lg 
queries obtaining answer vertex th layer verifier rejects 
continues follows 
fu vg verifier queries oracle fu vg rejects fu vg 
needed query oracle pairs vertices belonging layer 
verifier reject queries answered accepts 
properties tosses log coins 
query answered specifying vertex pattern may accept remaining queries 
complexity log accounting query may answered arbitrarily mg number vertices chosen layer 
average free bit complexity log average number vertices layer graph 
prove gw theorem follows 
proof 
accepting transcripts input correspond choice layer vertex th layer vertex specified answer accepting way answer queries 
generic accepting transcript form def fu fu layer selected verifier vertex th layer fv set non neighbors accepting transcript verifier selected vertex vertex transcript accepting 
consider mapping oe maps show isomorphism gw suppose adjacent gg 
definition fglss graph transcripts consistent 
note appear layer bellare goldreich sudan query transcript yield conflicting answers 
vertex query appear accepting transcripts conclude oe oe 
suppose hand 
clearly belong different layers query appear vertex query may appear transcripts conclude transcripts consistent adjacent gg 
theorem follows 

clique verifier adaptive answer query determines queries 
wonder possible construct non adaptive clique verifier properties claimed theorem 
main consequences interested problems exhibiting gap max clique size positive negative instances 
recall maxclique maxclique fraction nodes maximum clique node graph recall gap clique promise problem definition delta delta promise problem gap clique pair set graphs maxclique set graphs maxclique 
gap problem defined direct consequence theorem get corollary functions gap clique fpcp log poly 
corollary transforms gap promise problem gap pcp system 
accepting probabilities pcp system low instances 
theorem obtain pcp systems perfect resp perfect completeness promise problem 
start presenting randomized reductions promise problem layer version 
alternative methods section cf theorem 
proposition layering clique promise problem obtaining perfect layering exists polynomial time randomized transformation graphs layered graphs input graph integers outputs subgraph layers maxclique pr maxclique delta gamma furthermore probability gamma delta gamman layer contains delta nodes 
logarithmic randomness exists polynomial time randomized transformation graphs layered graphs input graph integers outputs subgraph layers maxclique pr maxclique gamma ffl delta ffl 
furthermore transformation uses logarithmically coins 
probability gamma ffln layers contains delta nodes 
free bits pcp proof transformation consists assigning vertex randomly chosen layer construct graph subgraph uniformly selecting vertex layer copying edges connect vertices placed different layers 
construction carried random polynomial time show original graph clique size high probability resulting graph clique size provided log claim 
suppose clique size denoted probability vertices placed layers delta gamma proof 
start bounding probability vertex placed th layer 
introduce random variable placed th layer 
def multiplicative chernoff bound mora get pr pr gamma call th layer bad vertex placed 
probability exists bad layer smaller delta gammat claim follows 
left bound probability particular layer contains twice expected number vertices 
multiplicative chernoff bound probability gamman part proposition follows 
second transformation consists selecting randomly universal hashing function pairwise independent hash function mapping vertices graph layer set 
suppose function chosen construct graph subgraph placing vertex layer copying edges connect vertices placed different layers 
construction carried polynomial time logarithmic randomness selection hashing function 
show original graph clique size high probability resulting graph clique size provided claim 
suppose clique size denoted probability vertices placed gamma ffl delta layers proof 
bound probability vertex placed th layer 
introduce random variable 
def def greater claim holds vacuously 
pairwise independence chebyshev inequality get pr pr var call th layer bad vertex placed 
expected number bad layers smaller delta markov inequality probability layers bad fflt 
claim follows 
bellare goldreich sudan left bound probability particular layer contains def chebyshev inequality probability expected number layers having vertices follows probability layers contain vertices ffln second part proposition follows 
combining theorem proposition obtain proposition polynomial time computable functions ffl randomized reduction pcp perfect completeness gap clique fpcp log def log log log def log delta 
pcp perfect completeness gap clique fpcp gamma ffl log def log log ffl def ffl delta proof second part construct verifier promise problem proceeds follows 
input vertex graph verifier computes def delta ffl def ffl def ffl invokes second transformation proposition obtaining layered graph 
stress transformation requires logarithmically coin tosses 
verifier modifies omitting minimum number vertices layer vertices 
verifier invokes clique verifier theorem input free bit complexity verifier constructed log log log ffl 
suppose instance promise problem 
maxclique maxclique theorem follows constructed verifier accepts probability maxclique ffl deltac suppose hand instance promise problem 
probability gamma gamma ffl maxclique gamma ffl delta probability gamma ffln gamma ffl maxclique maxclique gamma 
probability gamma ffl maxclique gamma ffl delta follows constructed verifier oracle access appropriate proof accepts probability gamma ffl 
part define promise problem refers gaps cliques layered graphs 
specifically definition 
function define promise problem gap pair set layered graphs maxclique set layered graphs maxclique delta 
gap problem defined transformation proposition obtain gap clique gap deltan log deltan log delta hand theorem asserts free bits pcp gap fpcp log def log 
observing log log equals log log log proposition follows 
parts proposition shows known method obtaining results efficient pcp systems cf fglss zu besu complete sense clique approximation shown np hard done method 
precise version theorem role ffl explicit 
restriction constant notational simplicity 
issue case measured function jxj case function kgk 
theorem constant 
statements equivalent ffl case np reduces gap clique gap ffl 
ffl case np reduces fpcp log ffl 
items reduction randomized 
furthermore equivalence holds karp cook reductions 
proof direction follows amplifying gap verifier np cf corollary applying fglss reduction fglss amplified gap verifier 
specifically obtain np fpcp gammat ffl delta delta fl log constant fl determined constant ffl 
fglss reduction yields graph size def ffl deltat gap gammat written ffl 
reverse direction part proposition show resulting verifier small amortized free bit complexity 
gap clique np hard functions satisfying ffl ffl ffl ffl ff def log def log log ff def ff delta invoking proposition part find gap clique fpcp log gap clique fpcp log log follows 
remains argue ffi ffl ffi lower bounds obtain ffl ffl log log ff log ffl delta log gamma log ff 
selecting sufficiently small ffi log ff ffi delta log get ffl ffl log log ff ffl log gamma log ff ffl ffl ffi ffl gamma ffi ffl ffi gamma ffi delta ffl theorem follows 
alternative statement provided theorem 
second item existence pcp systems certain parameters weaker previous theorem allows direction proven deterministic reduction randomized reduction bellare goldreich sudan analogous proof 
interestingly fglss reduction establish direction insensitive gap location particular fact longer proof systems perfect completeness 
recall fpcp gammao delta class problems having proof system perfect completeness gamma amortized free bit complexity theorem constant 
statements equivalent ffl case np reduces gap clique gap ffl 
ffl case np reduces fpcp gammao log ffl 
items reduction randomized equivalence holds karp cook reductions 
furthermore item holds respect deterministic reductions item 
follows case item holds deterministic karp reduction np fpcp gammao log ffl 
proof direction follows essentially proof previous theorem 
specifically item asserts function np fpcp gammam deltac log delta gamma going bound 
proposition proposition part obtain np fpcp gammat deltac ffl delta delta fl log constant fl determined constant ffl 
fglss reduction yields graph size def ffl deltat gap gammat analogous proof 
gap different location matter 
reverse direction second part proposition show resulting verifier small amortized free bit complexity 
gap clique np hard functions satisfying ffl analogous proof implies ffl ffl ff slowly decreasing function ff log ff log 
def log log ff def ff delta invoking proposition part get gap clique fpcp gammaff log 
ff conclude gap clique fpcp gammao log log remains argue ffi ffl ffi lower bound obtain ffl ffl log gamma log ff log log ff ffl log selecting sufficiently small ffi log ff ffi delta log get ffl ffl log log ff ffl log gamma log ff ffl ffl ffi ffl gamma ffi ffl ffi gamma ffi delta ffl theorem follows 
free bits pcp consequences equivalence clique fpcp described turns useful tool study hardness clique chromatic number problems 
describe applications 
application non technical simply allows rephrase known reductions max clique problem chromatic number problem simpler convenient way 
remaining applications fact equivalence fpcp max clique allows easily shift gaps max clique problem place 
loosely speaking applications fact complexity promise problem gap clique remains unchanged changing parameters log log remains invariant 
stress ratio remain invariant 
rephrasing known reductions max clique chromatic number starting lund yannakakis works showing hardness approximating chromatic number reduce max clique problem chromatic number problem 
results stated cleanly terms reduction max clique chromatic number loss efficiency theorems stated saying approximating max clique factor ff np hard approximating chromatic number factor ff np hard 
reason lack statement reductions structure graph produced applying fpcp result really reductions fpcp chromatic number reductions max clique chromatic number 
know fpcp max clique equivalent go back rephrase old statements 
results kls besu summarized fl approximating max clique ff np hard approximating chromatic number ff gammafl np hard ff minf ff gamma ff 
ff minf ff ff kls 
ff minf ff gamma ff besu 
ff minf ff gammaff fu 
discussion furer results fu reflects best current understanding going 
note open problem get reduction ff ff 
note furer reduction randomized rest deterministic 
reductions max clique problems invariance gap clique problem respect shifting gaps 
result independently observed feige fei uses randomized graph product show result 
description uses properties fpcp equivalence clique approximation 
theorem ffl ffl real numbers ffl ffl 
hold gap clique gammaffl gap clique gammaffl 
deterministic reduction 
gap clique gammaffl gap clique deltan gammaffl deltan bellare goldreich sudan proof part proved known graph theoretic trick 
instance gap clique gammaffl nodes 
take graph product complete graph nodes get graph mn nodes 
graph product graphs mean graph vertex set theta vertices connected iff 
choose clique size gammaffl clique size gammaffl specifically setting ffl gammaffl ffl requirement satisfied clique size gammaffl yields clique size delta gammaffl ffl gammaffl ffl gammaffl ffl ffl delta ffl gammaffl ffl 
choice show cliques size cliques size complete proof part 
suppose clique size gammaffl construction clique size gammaffl gammaffl ffl gammaffl gamma ffl gammaffl ffl claim follows 
part equivalence fpcp gaps maxclique apply amplification properties fpcp 
gammaffl corollary line proposition line part proposition line get gap clique gammaffl fpcp log fpcp delta log integer constant 
fpcp deltac deltas log choice integer determined 
go back clique gap promised problem 
applying fglss reduction pcp class fpcp deltac deltas log obtain instance gap clique gammaffl vertex graph clarify assertion rest proof introduce notation gap clique ff fi explicit size parameter promise problem refers 
letting fl def obtained gap clique gammaffl gap clique gammak polynomial 
part follows setting fl ffl ffl ffl ffl 
get gap clique gammaffl gap clique gammaffl ffl ffl corrected invoking item 
theorem shown blum bl technique randomized graph products 
essentially uses gap shifting idea show seemingly weak approximator clique say gammaffl approximation algorithm ffl obtain approximator clique number graphs guaranteed large cliques 
particular algorithm graph clique size clique size ffl graph polynomial time 
observed blum translated significantly better algorithms approximate coloring colorable graph known currently see item corollary 
derive theorem fpcp free bits pcp gap shifting techniques 
parameters generalized able conclude say log approximation max clique obtain non trivially algorithms coloring see item corollary 
theorem ff fi 
define ffl ffl ff log fi log log fi log ff gammafi log fi gammafi randomized poly log time reduction instances gap clique vertex instances gap clique gammaffl gamma ffl observe fi ffl ff ff theorem states gamma ff approximator clique solve gap clique polynomial time ff proof usual reduce gap clique fpcp amplify 
gap clique fpcp log fpcp log function fpcp log show setting log fglss reduction reduces poly time gap clique gammaffl gammaffl vertex graph case graph instance size clique delta case graph instance clique size delta suffices show ffl ffl respectively 
logs cases suffices show log ffl log log ffl log lower bound right hand side equations 
ffl log ff log gammafi ff log gammafi fft gammafi log gammafi ff delta log gammafi delta fi log ff log fi log log inequality follows fact log 
inequality follows fact log bellare goldreich sudan result derived corollary blum bl shows application theorem coloring graphs low chromatic number relatively small number colors 
warn reader corollary follow directly theorem uses levin reduction search version chromatic number search version clique problem 
possible define search versions gap problems appropriately verify reductions search problems fact levin reductions 
derived corollary 
corollary 
ffl gammaffl approximator clique color colorable graph nodes ffl log colors polynomial time 
ffl log gamma gammaffl approximator clique color colorable graph nodes colors time log limitations common approaches section provide lower bounds free bit complexity tasks central existing low complexity probabilistically checkable proofs 
specifically consider task checking string oracle access close valid codeword task checking oracle encoding projection string encoded second oracle 
string considered close code distance codeword half distance code 
loosely speaking show tasks amortized free bit complexity tight codes tests section 
furthermore show amortized free bit complexity performing tasks respect oracles tight section 
original motivation proving lower bounds indicate paradigm shift required order improve pcp systems amortized free bit complexity np 
retrospect paradigm shifts amounted codeword test projection test 
lower bounds may considered justification somewhat unnatural 
particular lower bound complexity codeword test relies particular interpretation closeness distance half distance code 
requirement essential seen section show relaxed codeword tests closeness means approximately distance code suffice 
hastad codeword test different suffices purpose constructing pcp systems amortized free bit complexity np 
lower bound complexity projection test robust 
shown hastad projection requirements relaxed yielding pcp systems amortized free bit complexity tending 
tasks definitions various tasks tests quite minimal suffice applications 
proving lower bounds results stronger 
loosely speaking task consists testing oracle encodes valid codeword close valid codeword respect error correcting code non trivial distance levin reduction polynomial time reduction augmented corresponding polynomialtime witness transformations 
free bits pcp distance greater 
condition regarding distance code essential task easy respect identity map code distance 
testing closeness codewords respect codes large distance essential known pcp constructions fglss besu 
absolute distance words denoted delta number bits disagree 
say code 
absolute distance absolute distance 
absolute distance word code denoted delta defined minimum absolute distance codeword definition codeword test code absolute distance 
codeword test respect oracle machine accepts error probability defined maximum accepting probability oracles absolute distance bd code max delta bd phi prr theta accepts psi required respect non codewords close code 
know lower bounds apply relaxed definition codeword test required reject strings distance code error probability defined max delta phi prr theta accepts psi propose determination amortized free bit complexity relaxed codeword test open problem 
relevance problem discussed 
second task defined respect projection function pair codes loosely speaking task consists checking string encoded oracle mapped string encoded second oracle 
definition projection test codes function 
projection test respect oracle machine accepts error probability defined maximum accepting probability oracles pairs max 
prr accepts io required respect non codewords 
consider test combines tests takes oracles performs codeword test projection test pair 
definition combined test code absolute distance codes function 
combined test oracle machine accepts error probability defined maximum accepting probability oracles pairs delta bd max phi prr theta accepts psi def delta bd bellare goldreich sudan required respect non codeword pairs close pair 
conventions notations pattern test access oracle resp oracles coin sequence consists sequence queries answers pattern denoted pattern resp pattern defined sequence th query coin sequence receiving answers gamma include queries pattern sake clarity easily reconstructed coin sequence answers 
case uses oracles may assume queries specify oracle addressed 
simplicity assume rest subsection test access oracle denoted set acc defined set accepting patterns coin sequence clearly acc recall said free bit complexity possible coin sequence holds say average free bit complexity av er fav expectation taken uniformly possible coin sequences 
amortized free bit complexity test defined fav log ffl av average free bit complexity test ffl error probability 
lower bound codeword test proposition code absolute distance greater codeword test amortized free bit complexity gamma 
amortization proposition understood place fixed number free bits length oracle grows 
allow oracle length free bit count grow provided logarithm number codewords grows faster free bit complexity 
alternatively consider fixed oracle length fix bound number free bits 
done technical lemma proposition follows 
lemma 
code absolute distance codeword test respect having average free bit complexity av error probability gamma fav furthermore error probability gamma fav proof fix arbitrary coin sequence fr denote cardinality set acc 
selected independently uniformly consider codewords 
probability delta construct oracle follows 
construct agrees value bits distance dd 
done follows set positions disagree subset cardinality dd 
equals positions equals positions 
free bits pcp claim oracle def distance bd code delta bd 
proved follows consider observe triangle inequality delta delta gamma delta gamma dd bd claim pr accepts fr probability taken uniformly possible choices key observation pattern equals pattern pattern equal pattern query falls set defined 
accepts accept 
suggests lower bound probability accepts probability pattern pattern 
consider enumeration ff ff fr patterns acc denote probability pattern equals th pattern enumeration uniformly selected def pr pattern ff 
picked random probability pattern pattern fr subject condition quantity fr lower bounded fr equality occurring equal 
observations bound error pr accepts pr accepts gamma pr fr gamma holds coin sequence uniformly chosen get pr accepts er fr gamma gamma inequality follows jensen inequality 
exist oracles prr accepts gamma oracle satisfies delta bd implying error gamma furthermore part observe fr coin sequence pattern pattern follows access oracle coin sequence test accepts wrong doing 
prr accepts prr furthermore claim follows markov inequality prr er gamma 
bellare goldreich sudan proof proposition test code maps bit strings bit strings 
suppose average free bit complexity error ffl function length strings encoded oracle 
assume 
lemma letting ae def gammam lower bound amortized free bit complexity follows log ffl gamma log gamma gamma log gamma ae ae gamma ae inequality assumed 
case proposition follows convention number codewords denoted grows faster exponential free bit complexity ae 
need address case hold 
consider sub cases 
sub case assume subsequence 
furthermore part lemma guarantees ffl gamma setting def gamma lower bound amortized free bit complexity log ffl log gamma log gamma sub case constant 
applying times get test average free bit complexity delta error ffl ffl maintains amortized free bit complexity gamma log ffl deltaf gamma log ffl 
applying analysis proposition follows 
lower bound projection test projection function function 
having property exists maps proposition pair codes oracles projection function projection test amortized free bit complexity gamma 
proposition proved technical lemma 
lemma refers function 
depends cardinality range case projection function equals 
abusing notations def sg 
lemma 


definition projection test respect having average free bit complexity av error probability gamma fav furthermore error probability gamma fav free bits pcp proof fixing arbitrary coin sequence fr def gj 
consider behavior test oracle access pair randomly independently selected codewords 
specifically ae set strings exists satisfying consider behavior access oracles independently uniformly selected probability 
hand claim access pair random oracles accepts probability fr claim proven lemma follows proof previous lemma 
consider set fr possible accepting patterns access oracles pattern consists pair ff fi ff resp fi denotes transcript test interaction resp 
enumerating possible fr patterns denote probability th pattern occurs access oracle pair uniformly selected def pr pattern ff fi ff fi th accepting pattern 
clearly pr pattern pattern ff fi claim probability pair independently chosen random oracles selected uniformly selecting setting leads th pattern pr pattern ff fi eq 
proven cut paste argument suppose def pattern equals def pattern consider computation 
proceeding induction assuming queries answered conclude st query mixed computation identical st query query directed fist oracle answered answered 
cases answer matches st answer conclude computation encounters pattern 
probability computation encounters th pattern lower bounded expression eq 
eq 
follows 
non adaptive tests probability th pattern encountered equals fr resp sum satisfying ff ff resp fi fi 
holds test selects queries oracle independently answers obtained oracle 
eq 
get pr pattern acc fr fr main part lemma follows 
furthermore part follows observing fr pattern pattern implies access oracle pair coin sequence test wrongly accepts 
bellare goldreich sudan lower bound combined test proposition pair codes oracles code absolute distance greater projection function combined test amortized free bit complexity gamma 
proposition proved technical lemma 
loosely speaking lemma asserts combined test free bit complexity error probability delta gammaf lower bound extends case bound average free bit complexity error probability case lower bounded delta gammaf see details 
follows amortized free bit complexity test large 
restriction large really weaken result 
suppose contrary exists test amortized free bit complexity am sufficient large obtain test free bit complexity def delta am error gammat deltaf am large 
lemma 
code absolute distance greater 

projection function 
suppose combined codeword projection test respect having free bit complexity error probability gamma gamma minimum number projected def min 
furthermore kg error probability 
proof furthermore part follows immediately furthermore parts lemma lemma integer implies 
proof main part lemma uses strategies employed proofs lemmas 
consider cases 
case half possible coin sequences accepting patterns respect coin sequence second oracle 
case employ strategy proof lemma restricted oracles constructed combining uniformly selected codewords satisfying second case half possible coin sequences number accepting patterns respect coin sequence second oracle case show possible fit fewer accepting patterns may employ strategy proof lemma 
details follow 
sequel ffi constant determined 
motivating discussion ffi better bound follows letting ffi larger 
case exists gamma ffi fraction possible coin sequences called number accepting patterns respect coin sequence second oracle fixed fixing consider possible satisfying employing argument lemma get random oracle constructed uniformly chosen wrongly accepted probability gamma averaging argument follows exists pair oracles errs probability gamma ffi delta gamma free bits pcp case ffi fraction possible coin sequences number accepting patterns respect coin sequence second oracle fl ffi parameter determined 
counting argument ffi gammafl gammafl fraction possible called exists set denoted pi fl delta possible accepting patterns consistent second oracle fixed 
denote fraction 
gamma delta fl ffi ffi gammafl gammafl follows 
ae set strings defined proof lemma maps fixing coin sequence adapt strategy proof lemma follows 
consider set sr pi strings maps sr pi enumerate accepting patterns occur test coins access oracle pair uniformly chosen sr claim patterns 
claim sr gj proof definition pi pi accepting patterns consistent coin sequence second oracle fits oracle sr 
cut paste argument ff fi ff fi accepting patterns second oracle ff fi accepting pattern second oracle ff fi accepting pattern second oracle 
follows accepting patterns collide intersect 
number accepting patterns various sr claim follows 
consider happens selects independently uniformly proof lemma probability 
hand access pair random oracles test accepts probability fl delta 
fl factor due probability sr factor corresponds analysis supposes uniformly selected sr 
analysis holds coin sequence lower bound fraction follows ffi gammafl gammafl fraction probability test errs access random pair oracles selected fl gamma averaging argument exists pair oracles test errs probability ffi gamma fl gamma fl delta fl gamma left select ffi fl maximize minimum expressions equations 
bother 
setting ffi fl lower bound expressions gamma gamma respectively current statement lemma follows 
prove bound case average free bit complexity apply markov inequality conclude ffl fraction coin sequences def ffl accepting patterns fixed coin sequence appears 

ffl consider coin sequences apply argument 
averaging argument proof yields exists oracle pair errs gamma gamma fraction coin sequences 
follows oracle err bellare goldreich sudan probability gamma ffl delta gamma gamma equals gamma ffl delta ffl gamma gamma 
ffl get lower bound gamma gamma pcp properties transformations complexity pcp fpcp section results regarding complexity languages acceptable probabilistically checkable proofs having respectively small query complexity small complexity small free bit complexity 
current section notations pcp stand classes languages 
results extended classes promise problems having probabilistically checkable proofs 
section mip denotes class languages accepted round prover interactive proof system randomness complexity lower bound probability accepting instances upper bound probability accepting instances 
corresponding class probabilistically checkable proofs pcp denotes number queries 
classes binary queries allowed standard mip 
mip versus pcp part lemma folklore stated sake completeness 
lemma admissible functions 
mip pcp 
mip mip gamma 
proof part follows definition pcp mip 
part shown follows 
restricted mip verifier 
define gamma restricted verifier input behaves follows ffl tosses coins ffl refers gamma queries corresponding gamma provers obtaining answers bits gamma respectively 
ffl accepts exists accept answers input random string bellare goldreich sudan suppose provers convince accept probability ffi provers gamma convince accept probability ffi accepts transcript accept transcript gamma 
justifies bound completeness probability suppose hand provers gamma cause accept probability ffi consider uniformly selected strategy prover denoted choose random response question 
probability provers cause accept input delta ffi accepts transcript gamma exists value accept transcript probability half answer equals 
justifies bound soundness probability containments pcp systems mip systems problematic 
reader referred ta 
contains proof result due bellare goldreich safra pcp log mip deltas log consider non adaptive case obtain different bound soundness parameter proposition suppose pcp non adaptive verifier 
mip log delta gamma delta gamma bq bq 

proof start non adaptive pcp verifier queries construct prover system follows 
uniformly select coin tosses pcp verifier defines queries non adaptivity 
ffl probability select query uniformly queries forward provers 
accept iff provers answer manner 
ffl probability gamma simulate pcp system follows 
uniformly select refer th query verifier th prover 
accept iff pcp verifier accepted clearly setting mip provers equal oracle pcp system inputs language accepted probability delta gamma delta delta gamma 
bound acceptance probability mip system input language 
fix arbitrary sequence mip provers 
ffi denote probability taken queries selected pcp verifier mip provers differ random query 
define oracle query equals majority prover answers ties case broken arbitrarily 
probability mip system accepts bounded delta gamma ffi gamma delta bq delta ffi justify second term consider simulation pcp system takes place probability gamma 
case answers mip provers equal corresponding answers pcp oracle defined bound acceptance probability soundness pcp system 
query relevant mip prover differs 
query happens probability bq definition minority free bits pcp provers differ oracle 
union bound eq 
follows 
definition delta gamma ffi gamma delta bq delta ffi gamma delta gamma ffi delta gamma gamma delta bq delta gamma proposition follows 
query complexity amortized query complexity proposition explores limitations probabilistically checkable proof systems logarithmic randomness upto queries 
qualitative assertions wellknown example considering perfect completeness queries minimum needed sufficient get proposition pcp systems logarithmic randomness queries pcp query weak admissible functions strictly smaller pcp log 
sided error pcp queries weak admissible functions strictly pcp log 
sided error pcp queries weak exists pcp log np 
furthermore holds 
sided error pcp queries weak pcp gammaffl log np ffl 
sided error pcp queries strong pcp log furthermore log restriction pcp verifier required non adaptive 
pcp log np non adaptive verifier see earlier version bgs :10.1.1.10.6494
proposition mip log np 
proof proposition part part obvious oracle maximizing acceptance probability constructed scanning possible random pads setting satisfies majority random pads verifier query proof proposition part folklore proof commonly deals nonadaptive case 
general verifier demonstrating pcp log may adaptive 
assume loss generality query 
making query decides accept reject additional query accept specific answer 
computation input random pad access generic oracle captured horn clauses corresponding different answer value query 
specifically suppose queries oracle location receiving value oe accepts iff location value write horn clause oe 
case accepts resp rejects obtaining value oe oracle location write clause oe resp oe 
addition write horn clauses 
computation input access generic oracle captured horn formula denoted oe horn clauses correspond various polynomially possible random pad answer pairs 
furthermore oe constructed polynomial time 
polynomial time decision procedure satisfiability horn formulae bellare goldreich sudan done 
alternatively linear time decision procedure sat due eis 
proof proposition part see pcp log poly np consider non deterministic machine tries guess oracle verifier system accept 
direction part shown theorem 
proof proposition part see pcp log poly np consider non deterministic machine tries guess oracle verifier accept probability np pcp log result follows hardness approximating max sat 
specifically suppose promise problem np hard karp reductions cnf formula decide exists truth assignment satisfies fraction clauses truth assignment satisfies fraction clauses fixed constants 
pcp log system np 
input verifier system performs reduction promise problem obtaining cnf formula oe uniformly selects clause oe queries oracle values variables clause accepting accordingly 
result section set delta may possible increase ratio part implementing inner verifier establish np hardness max sat arbitrary literal clauses cnf clauses 
proof proposition part result general verifiers follows lemma fact maxsat approximated factor polynomialtime cf 
tedious proof non adaptive case earlier versions bgs :10.1.1.10.6494
trevisan contains stronger result holds verifiers pcp log stronger bound obtained lemma restricted non adaptive case weaker proven mip proof systems see corollary 
contrast may provide testing ground separate pcp mip question raised 
corollary obtained combining lemma proposition 
corollary mip coins log provers proof mip log mip log pcp log general result relates query complexity probabilistically checkable proof system ratio acceptance probabilities instances instances follows lemma admissible functions pcp poly gamma furthermore pcp pspace logarithmically bounded pcp proof pcp verifier demonstrating fact 
observe probability accepts access random oracle hand free bits pcp probability accepts access oracle decide simulating execution access random oracle estimating acceptance probability random choices possible oracles 
particular estimate probability upto ffl def gamma additive term high probability poly ffl samples 
alternatively compute probability polynomial space 
case logarithmically bounded exactly compute probability accepts access random oracle 
loop possible random pads pad consider possibilities setting oracle bits examined get deterministic polynomial time decision procedure 
assertion lemma pcp log strengthen omitting logarithmic bound np pcp poly 
hand recalling definition pcp immediately get corollary ffl admissible function strictly greater 
admissible function pcp log gamma ffl particular holds 
proof pcp log gamma ffl implies logarithmically bounded function pcp gammam deltac log gamma ffl delta corollary follows 
results focused pcp systems logarithmic randomness 
proof systems unrestricted randomness considered proposition may provide indication effect low query complexity 
results obtain somewhat analogous proposition 
recall pcp poly poly equals non deterministic exponential time bfl 
power pcp systems polynomial randomness compared 
proposition general pcp systems queries pcp query relatively weak admissible functions gamma non negligible pcp poly am am class languages having round arthur merlin proof systems cf bab 
sided error pcp queries relatively weak admissible functions strictly pcp poly pspace 
sided error pcp queries weak hand exists pcp poly 
sided error pcp queries weak pcp gammaffl poly ffl 
sided error pcp queries strong pcp poly pspace 
furthermore poly pspace 
function called non negligible exists positive polynomial bellare goldreich sudan part proposition may hard improve indicated proposition part graph non isomorphism pcp poly 
proof proposition part observe query pcp system round interactive proof system cf gmr 
completeness soundness bounds pcp system 
known transformations obtain claimed result 
specifically reduce error interactive proof parallel repetition transform arthur merlin interactive proof gs transform arthur merlin interactive proof perfect completeness 
stress transformations maintain number rounds upto constant constant round arthur merlin hierarchy collapses bab 
proof proposition parts parts observe proof systems corresponding items proof proposition scale 
specifically easy see outer verifier proof systems scale yielding canonical outer verifier randomness complexity log fo language provided poly furthermore inner verifiers operate constant sized oracles composed verifier maintains time randomness complexities outer verifier 
particular verifier establishing theorem scaled yield part 
holds verifier establishing part proposition 
note exposition proof proposition terms reducing np max sat happens verifier establish np hardness max sat cf section implemented verifier queries constant number possibilities 
proof proposition part strategy proof analogous part proposition obtain polynomial space reduction pcp poly set satisfiable horn formulae horn formulae clause literals 
input reduction uses space poly jxj produces horn formula oe size exponential jxj iff oe satisfiable 
poly logarithmic decision procedure satisfiability horn formulae decide oe satisfiable poly jxj space 
proof proposition part result non adaptive verifiers follows part strategy analogous proof proposition 
result general verifiers follows furthermore part lemma pcp poly pspace 
free bit complexity class fpcp defined analogously class pcp consider free bit complexity denoted query complexity denoted 
proposition demonstrates limitations probabilistically checkable proof systems free bit example consider procedure 
horn formula construct directed graph vertices literals formula directed edge literal literal formula contains clause easily verify formula satisfied iff exists variable truth assignment yields contradiction forcing paths contradicting values cf eis 
non deterministic logspace machine guess variable check possible truth assignments yield contradictions 
checking reduces guessing variable conflicting assignment implied verifying conflict directed connectivity 
task nl done 
sat complete see 
free bits pcp complexity bounded 
believe similar limitations hold amortized complexity 
items refer proof systems logarithmic randomness 
item shows proof systems sided error non perfect completeness having amortized free bit complexity zero logarithmic randomness suffice np third item asserts second item strengthened respect increasing complexity respect referring sided error 
proof systems unrestricted randomness considered items may provide indication effect low free bit complexity 
item viewed weak evidence result fourth item drastically improved yield fpcp poly bpp 
proposition pcp systems low free bit complexity admissible function strictly smaller 
pcp logarithmic randomness free bit exists np fpcp log 
np fpcp log 
ffl np fpcp gammaffl gamma log 
ffl fpcp gammaffl gamma log 
limitations pcp logarithmic randomness free bit fpcp log fpcp gamma poly coins poly free poly bpp 
tightness item exists np fpcp log np fpcp log log np fpcp log 
general pcp free bit fpcp poly conp 
general pcp free bit fpcp poly pspace 
examples pcp free bit graph non isomorphism pcp system perfect completeness soundness bound verifier single query query free 
fpcp coins poly free query holds quadratic non residuosity cf gmr set integer pairs non residue modulo proof proposition part claim part justified theorem 
applying proposition verifier satisfies condition proposition yields second claim part 
applying proposition verifier third claim part follows 
proof proposition part applying proposition verifier theorem claim part follows 
prove second claim apply proposition claim obtain np fpcp gammaffi delta gamma gammaffi delta gamma log 
substituting ffl ffi second claim follows 
conjecture stated systems perfect completeness proven correct hastad proved np fpcp log ffl ffl 
systems sided error probability knew recognize np languages zero free bits see 
fact holds free bit complexity zero see item 
bellare goldreich sudan claim follow relationship minimum vertex cover problem class fpcp log see proof proposition 
specifically consider fglss reduction graph proof system witnessing fpcp gammaffl gamma ffl log consider complement graph asks size independent set 
graph vertex cover density ffl graph vertex cover density ffl 
known approximation algorithms cases distinguishable polynomial time third claim follows 
proof proposition part consider proofs zero free bits 
pcp poly verifier demonstrating fact 
definition possible sequence coin tosses exists accepting configuration oracle answers queries 
furthermore definition accepting configuration exists generated polynomial time coin sequence 
non deterministic procedure accepts starts guessing sequences coin tosses generating corresponding accepting configurations checking consistent 
input accepted non procedure iff coin sequences guessed yield conflicting configurations 
clearly possible pairs coin sequences accepting configurations exist consistent oracle accept exist 
accepted non deterministic procedure 
hand pairs coin sequences yield accepting mutually consistent configurations oracle accept emerges 
exists guess non deterministic procedure accept proof proposition parts consider proofs free bit complexity 
possible sequence coin tosses exist accepting configurations efficiently coin sequence 
refer possible accepting configuration configuration configuration coin sequence 
case specific coin sequence accepting configurations introduce dummy configurations coin sequence associated configurations 
input pcp system consider cnf formula representing possible computations verifier generic oracle 
possible sequence coin tosses introduce pair boolean variables representing associated configurations encountered means configuration encountered 
enforce single accepting configuration encountered introduce clauses 
addition case oe configuration accepting dummy configuration introduce clause oe disallowing computation encountered 
pair coin sequences introduce clauses disallowing inconsistencies 
suppose oe configuration inconsistent configuration introduce clause oe logically equivalent oe 
resulting cnf formula oe satisfiable exists oracle causes accept probability 
need test oe satisfiable 
consider cases 
case uses logarithmically coins cnf formula oe generated polynomial time 
polynomial time decision procedure satisfiability cnf formulae conclude fpcp log proposition randomly reduce fpcp gamma poly poly free poly fpcp gamma poly log free fpcp gamma poly poly free poly bpp follows 
establishes part 
free bits pcp general may polynomially coin tosses cnf formula oe may exponential jxj length 
generated polynomial space 
poly logarithmic space decision procedure satisfiability cnf formulae decide oe satisfiable poly jxj space 
part fpcp poly pspace follows 
proof proposition part merely note interactive proof gmw graph non isomorphism constitute query pcp system perfect completeness soundness bound furthermore query verify unique acceptable answer free bit complexity system zero 
holds interactive proof gmr quadratic non residuosity inspiration proof gmw 
query complexity versus free bit complexity proposition quantifies intuition queries undetermined free bit complexity lower query complexity 
furthermore corollary obtain amortized average free bit complexity unit amortized query complexity 
proposition admissible functions log 
pcp pcp coins free av gamma log furthermore admissible function pcp fpcp deltas gamma proof pcp verifier demonstrating 
fix input sigma 
random string denote number accepting patterns claim er delta true random oracle accepted probability er delta gammaq case claim hold reach contradiction soundness condition accepted probability strictly larger 
construct verifier denoted witnessing fpcp av gamma log input verifier computes er scanning possible generating accepting patterns 
er delta accepts querying oracle 
er delta simulates accepts accepts 
follows average free bit complexity input equals corresponding quantify provided gamma log equals zero 
part proposition follows 
establish second part construct verifier input proceeds follows 
computes def er accepts just 
case new verifier proceeds differently randomly selects computes gammat accepts invokes input coins clearly guarantees free bit complexity gamma analyze soundness example note cnf formulae written horn form procedure described proof proposition part 
input pair graphs verifier uniformly selects generates random isomorphic copy denoted graph single query verifier accepts answer equals bellare goldreich sudan note er follows prr gammat delta markov inequality 
soundness error second part follows 
computing amortized average free bit complexity class languages right hand side eq 
obtain consequence 
corollary admissible functions log pcp fpcp av gamma fpcp av delta delta denotes class analogous fpcp delta delta average free bit complexity measured worst case free bit complexity 
proof function pcp pcp delta gammam qm fpcp av delta gammam qm gamma fpcp av gamma second inclusion due eq 

corollary argument amortized query complexity incapable capturing approximability clique function 
previously argued assumption clique number may hard approximate establishing clique np hardness require showing np pcp log gamma ffl ffl impossible shown pcp log gamma ffl 
remove assumption 
suppose maxclique np hard approximate factor approximated gammaffi factor polynomial time ffi handle ffi 
furthermore supposed hardness result demonstrated showing np pcp log gamma ffl ffl 
corollary get np fpcp av log gamma gamma ffl ffl np hardness result clique approximation upto gamma gammaffl ffl follows contradiction hypothesis approximations achieved polynomial time 
summarize attempts establish factor np hard approximate maxclique amortized query complexity fall unit away truth amortized free bit complexity yield right answer 
transformations fpcp systems useful transformations applied pcp systems 
fall categories transformations amplifies completeness versus soundness gap proof system preserving preserving amortized free bit complexity 
transformations move gap location equivalently completeness parameter 
gap preserved moving changes free bit complexity amortized free bit complexity preserved 
specifically moving gap requires increasing free bit complexity moving gap allows decrease free bit complexity 
entire discussion assumes np 
discussion mute 
retrospect reason remove assumption proven hold 
known time current done 
observation fglss reduction works amortized average free bit complexity 
free bits pcp transformations analogous transformations applied graphs respect max clique problem 
view relation fpcp clique promise problem shown section analogy hardly surprising 
section extensive fpcp notation refers promise problems languages introduce additional parameter proof length 
specifically fpcp refers randomness complexity free bit complexity proof length gap maintaining amortized free bit complexity start stating simple fact ratio completeness soundness bounds referred gap amplified raise power repeats pcp system times 
note original system perfectly complete completeness bound resulting system gets decreased 
proposition simple gap amplification fpcp fpcp kr kf proof fpcp verifier witnessing query complexity define verifier follows input 
ffl picks random strings uniformly independently ffl verifier simulates actions input random string verifier accepts accepts instances 
clearly tosses kr coins examines bit long oracle kq bits kf free 
probability accepts access oracle probability accepts access exactly fpcp kr kf oracles transformed identity pcp system 
show sense randomness complexity proof system need higher logarithmic length proofs oracles employed 
specifically show randomly reduce languages proven kind systems languages proven second kind 
interested computational complexity languages proven pcp systems may assume system second type 
recall denotes randomized karp reduction 
proposition reducing randomness exists constant fl perfect completeness admissible functions ffl fpcp fpcp ffl delta fl log ffl 
sided error admissible functions ffl ffl fpcp fpcp gamma ffl delta gamma gamma ffl ffl delta fl maxf gamma log ffl gamma log gamma log ffl bellare goldreich sudan proof proof reminiscent adleman proof rp poly ad 
suppose pcp system want reduce randomness complexity 
idea suffices choose random pad verifier relatively small set possibilities possibilities 
furthermore small sets sets size linear purpose 
suggest randomly mapping input original pcp system input new system random set possible random pads original system 
new verifier select random pad uniformly log jrj random coins run original verifier random pad 
details follow 
start simpler case stated part 
fpcp verifier demonstrating fact 
random reduction maps uniformly chosen multi subset def def def ffl def ffl def fll ffl 
constant fl chosen chernoff bound hold 
input new verifier uniformly selects invokes input random pad clearly complexities claimed 
assuming accepts access oracle possible pair mapped accepts access oracle remains upper bound probability accepts access arbitrary oracle 
fixing oracle bound probability give access accepts 
set called bad respect fraction verifier accepts access random pad uniformly selected multi set 
possible random choice define random variable iff random pad access oracle accepts input clearly mutually independent equals probability ffi multiplicative chernoff bound cf 
mora theorem probability random bad bounded pr ffl delta ms gamma omega gamma ffl choice probability random bad respect fixed oracle smaller delta gammal relevant oracles part proposition follows 
second part proposition repeat argument need take care completeness bound resulting pcp system 
done similarly way dealt soundness bound need consider possible oracles suffices consider best oracle applying multiplicative chernoff bound important note interested rejection event relevant expectation delta gamma delta 
long fl ffl gammac possible sets cause accept probability gamma ffl delta gamma gamma gamma ffl second part proposition follows 
combining propositions obtain randomized reduction pcp systems yields effect proposition lower fact minimal cost randomness complexity resulting pcp system 
reduction analogous known transformation berman schnitger 
reduction forms plays central role deriving clique approximation results fglss method applying fglss reduction proof systems obtained second item derives graphs size def ffl deltat clique gap rewritten ffl 
free bits pcp corollary probabilistic gap amplification minimal randomness cost combining propositions admissible fpcp fpcp gammak log kf query complexity proof system 
amortized free bit complexity ffl exists constant fpcp log fpcp gammat ffl delta delta log proof suppose fpcp 
clearly delta poly query complexity verifier 
applying proposition get fpcp kr kf delta 
applying part proposition obtain fpcp gamma kf log gammak log part corollary follows 
suppose language proof system hypothesis second part 
exists logarithmically bounded function fpcp mf ff delta log fi constants ff fi 
invoking similar argument get fpcp km gamma delta mf km ff fi delta log setting delta ff fi ffl delta log corollary follows 
alternative gap amplification procedure employ randomized reductions 
transformation increases randomness complexity pcp system randomized reduction item corollary 
transformation obtain approximability results assumption np np bpp 
stated sided error case proposition deterministic gap amplification low randomness cost ffl admissible function fpcp fpcp ffl delta delta log ffl delta kf constant notation minf ffl log random walks expander graphs error reduction suggested ajtai aks cf cw 
random walks expander graphs gap amplification context pcp originates 
discussion see subsection value constant multiplier randomness complexity resulting pcp system depends expander graph 
specifically degree expander graph second eigenvalue yields factor log log essential ramanujan graphs lps order obtain claimed constant ffl 
proof proposition simplicity assume 
idea pseudorandom sequence generated random walk expander graph order get error reduction moderate randomness cost 
specifically ramanujan expander graph constant degree second eigenvalue cf lps 
constant determined ffl ffl 
known random walk length expander bellare goldreich sudan avoids set density ae probability ae cf aks kah 
preparation step reduce error probability pcp system def done trivial reduction proposition 
derive proof system error probability randomness complexity def delta log delta log free bit complexity def delta log delta log case start soundness error multiplier log log 
ready apply expander walk technique 
expander walk length transform proof system randomness complexity gamma delta log free bit complexity tf tf delta log error probability gammak def delta log 
log ffl bound randomness complexity log log delta log gamma delta ffl delta free bit complexity tf delta log delta log gamma delta log gamma delta kf 
ffl delta kf proposition follows 
proposition obtain corollary deriving clique inapproximability results np assumption fglss method applying fglss reduction proof systems obtained corollary derives graphs size def ffl deltat clique gap rewritten ffl 
corollary ffl exists constant fpcp log fpcp gammat ffl delta ffl delta log trading gap location free bit complexity transformation analogous randomized layering procedure clique promise problem proposition 
transformation increases acceptance probability bounds expense increasing free bit complexity 
proposition increasing acceptance probabilities free bit complexity free bits pcp randomized reduction preserves randomness proof system admissible functions fpcp fpcp log gamma gamma delta note gamma gammar 
inclusion moderately increases randomness proof system admissible functions fpcp fpcp log ffl delta log mg delta delta ffl log mg mc gamma gamma theta mc delta proof suppose pcp system want increase acceptance probability bound completeness condition 
idea allow new verifier select original verifier query oracle pad 
straightforward implementation idea increase randomness complexity verifier factor alternative implementations yield parts proposition 
implementations free bit complexity increases log soundness bound increases factor implementation employs technique introduced context bpp lau 
randomized reduction supply new verifier sequence possible shifts may effect 
new verifier selects random pad original verifier generates shifts pad 
new verifier queries oracle shifts random pad original verifier 
details follow 
random reduction mapping uniformly chosen multi subset def 
input new verifier uniformly selects queries oracle receiving answer 
intuitively asks shift random pad 
invokes input random pad phi th string clearly complexities claimed 
assuming accepts probability ffi get verifier accepts probability delta ffi 
hand suppose access oracle verifier accepts probability ffi 
follows exists set ffi random pads uses queries oracle accepts fixing ask probability uniformly chosen fs mg exists phi clearly answer gamma gamma ffi uniformly chosen pr phi gamma gamma ffi markov inequality probability uniformly chosen fs property gamma delta gamma ffi exists phi part proposition follows 
prove part proposition alternative implementation idea consists letting new verifier generate pseudorandom sequence possible random pads 
query oracle random pad simulation bellare goldreich sudan complete computation invoking specified random pad 
generate pseudorandom sequence sampling procedure 
specifically merely amounts generating pairwise independent sequence uniformly distributed strings done randomness maxf log mg 
construction amounts generating theta cm related sequences sequences related random walk constant degree expander 
part follows 
corollary exemplifies usage proposition 
case gammaff log gap preserved upto logarithmic factor free bit complexity increases log additive term 
corollary provides alternative way deriving reverse fglss transformation say proposition simple clique verifier theorem 
specifically may apply corollary simple clique verifier theorem combining layered graph verifier theorem graph layering process proposition 
corollary admissible fpcp fpcp deltas log log compare item proposition conclude transformation reminiscent assertion section 
transformation opposite effect previous reducing free bit complexity expense lowering bounds acceptance probability 
proposition decreasing acceptance probabilities free bit complexity admissible functions fpcp fpcp gamma 
furthermore case random pad original pcp system accepting configurations average free bit complexity resulting system av gamma av average free bit complexity original system 
proof verifier satisfying condition proposition 
construct new verifier input setting acts follows 
verifier uniformly selects random pad generates possible accepting configurations respect random pad case accepting configurations add dummy configurations reach count 
partition set resulting configurations accepting possibly dummy parts size parts may configuration 
care average free bit complexity partition accepting configurations non empty parts 
new verifier uniformly selects specifying parts denoted invokes random pad accepts oracle answers form accepting configuration resides selected portion accepting configurations 
stress case accepting configurations selected contain accepting configuration rejects coins 
clearly randomness complexity new verifier analyze parameters fix sake simplicity assume number accepting configurations random pad power 
number accepting configurations random pad theta gammak generalizes simple clique verifier free bits pcp number accepting configurations random pad free bit complexity gamma relate acceptance probability done reformulating execution oracle consisting steps 
invokes access reaches rejecting configuration rejects reaches accepting configuration accepts probability gammak corresponding uniformly selecting 
follows input access oracle verifier accepts probability ffi ffi denotes probability accepts input access oracle general simplifying assumption number accepting configurations power may hold analysis slightly cumbersome 
firstly number accepting configurations random pad dm bm number accepting configurations random pad worse case number accepting configurations random pad dm follows complexity log gamma furthermore expected number accepting configurations fixed uniformly chosen exactly 
extra condition holds free bit complexity equals av gamma observe argument regarding acceptance probabilities remains unchanged depend partition accepting configurations non empty parts 
proposition follows 
effects acceptance probabilities free bit complexity alternative transformation reduces free bit complexity 
proposition decrease acceptance parameters 
furthermore transformation increases soundness parameter preserve gap completeness soundness parameters 
proposition decreasing free bit complexity decreasing acceptance probabilities admissible functions suppose fpcp verifier oracle answers random pad allow gammak accepting configurations 
fpcp gamma gammac gamma gammas log gammak gamma 
generalized current utilizes special case specifically proof part proposition obtaining log 
proof proof similar proof proposition 
consider verifier guaranteed hypothesis set gammak accepting configurations consistent th possibility oracle answers queries 
denote th possibility ff configurations start ff 
construct new verifier uniformly selects random pad specifying part 
verifier queries answers differ ff halts accepts 
continues emulation accepts iff accepts 
clearly uses coin tosses 
accepting configurations random pad truncated configurations ff gammak gamma accepting configurations 
suppose accepts probability accepts input oracle access probability gamma gammak gammak delta gamma gammap proposition follows 
bellare goldreich sudan simplified version transformation 
acceptance probabilities increased affecting free bit complexity way 
proposition increasing acceptance probabilities preserving free bit complexity ffi admissible functions fpcp fpcp log ffi gamma ffi delta gamma gamma ffi delta gamma 
proof verifier fpcp 
construct new verifier probability ffi invokes accepts regardless input 
proposition follows 
bibliography ad adleman 
theorems random polynomial time 
proceedings nineteenth annual symposium foundations computer science ieee 
aks ajtai 
deterministic simulation logspace 
proceedings nineteenth annual symposium theory computing acm 
ase alon spencer erdos 
probabilistic method 
john wiley sons 
kann 
complexity approximability finding maximum feasible subsystems linear relations 
theoretical computer science vol 
pages 
ar arora 
reductions codes inapproximability 
manuscript may 
arora babai stern 
hardness approximate optima lattices codes linear equations 
focs 
arora lund motwani sudan szegedy 
proof verification intractability approximation problems 
proceedings third annual symposium foundations computer science ieee 
arora safra 
probabilistic checking proofs new characterization np 
proceedings third annual symposium foundations computer science ieee 
bab babai 
trading group theory randomness 
proceedings seventeenth annual symposium theory computing acm 
bfl babai fortnow lund 
non deterministic exponential time interactive protocols 
proceedings annual symposium foundations computer science ieee 
bellare goldreich sudan babai fortnow levin szegedy 
checking computations polylogarithmic time 
proceedings third annual symposium theory computing acm 
bar yehuda 
linear time approximation algorithm weighted vertex cover problem 
jour 
algorithms vol 
pages 
bar yehuda 
local ratio theorem approximating weighted vertex cover problem 
analysis design algorithms combinatorial problems vol 
annals discrete math elsevier 
bar yehuda moran 
approximation problems related independent set vertex cover problems 
discrete applied mathematics vol 
pages 
bellare 
interactive proofs approximation reductions provers round 
proceedings second israel symposium theory computing systems 
bellare coppersmith astad kiwi sudan 
linearity testing characteristic 
manuscript november 
bellare goldreich goldwasser 
randomness interactive proofs 
proceedings annual symposium foundations computer science ieee 
bgs bellare goldreich sudan :10.1.1.10.6494
free bits tight results version 
august 
tr eccc electronic colloquium computational complexity 
www eccc uni trier de eccc 
bellare goldwasser lund russell 
efficient probabilistically checkable proofs applications approximation 
proceedings fifth annual symposium theory computing acm 
see errata sheet proceedings sixth annual symposium theory computing acm 
bellare rogaway 
complexity approximating quadratic program 
complexity numerical optimization ed 
pardalos world scientific 
besu bellare sudan 
improved non approximability results 
proceedings sixth annual symposium theory computing acm 
ben goldwasser kilian wigderson 
multi prover interactive proofs remove intractability assumptions 
proceedings twentieth annual symposium theory computing acm 
berman schnitger 
complexity approximating independent set problem 
information computation 
bl blum 
algorithms approximate graph coloring 
ph 
thesis dept computer science mit 
free bits pcp blr blum luby rubinfeld 
self testing correcting applications numerical problems 
journal computer system sciences vol 
pp 

brna naor 
hardness decoding preprocessing 
ieee transactions information theory vol 
pp 

boppana 
approximating maximum independent sets excluding subgraphs 
bit vol 

crescenzi kann compendium np optimization problems 
technical report dipartimento di scienze dell informazione universit di roma la sapienza si rr 
list updated continuously 
latest version available anonymous ftp nada kth se theory kann compendium ps cst crescenzi trevisan 
weight weight question 
manuscript october 
cw cohen wigderson 
deterministic amplification weak random sources 
proceedings thirtieth annual symposium foundations computer science ieee 
cook 
complexity theorem proving procedures 
proceedings third annual symposium theory computing acm 
eis itai shamir 
complexity timetable multicommodity flow problems 
siam computing vol 

selman yacobi 
complexity promise problems applications public key cryptography 
information control vol 

fei feige 
randomized graph products chromatic numbers lov asz theta function 
proceedings seventh annual symposium theory computing acm 
feige goemans 
approximating value prover proof systems application max sat max 
proceedings third israel symposium theory computing systems ieee 
fglss feige goldwasser lov asz safra szegedy 
approximating clique np complete 
proceedings second annual symposium foundations computer science ieee 
feige kilian 
prover protocols low error affordable rates 
proceedings sixth annual symposium theory computing acm 
feige lov asz 
prover round proof systems power problems 
proceedings fourth annual symposium theory computing acm 
frs fortnow sipser 
power interactive protocols 
proceedings rd structures ieee 
bellare goldreich sudan fu furer 
improved hardness results approximating chromatic number 
manuscript 
furer goldreich mansour sipser 
completeness soundness interactive proof systems 
advances computing research research annual vol 
randomness computation micali ed pp 

gj garey johnson 
complexity near optimal graph coloring 
journal acm vol 

gj garey johnson 
computers intractability guide theory np completeness 
freeman 
gjs garey johnson stockmeyer 
simplified np complete graph problems 
theoretical computer science pp 

goemans williamson 
new approximation algorithm max sat 
proceedings rd mathematical programming society conference integer programming combinatorial optimization 
goemans williamson 
approximation algorithms max cut max sat 
proceedings sixth annual symposium theory computing acm 
gmw goldreich micali wigderson 
proofs yield validity methodology cryptographic protocol design 
proceedings seventh annual symposium foundations computer science ieee 
gmr goldwasser micali rackoff 
knowledge complexity interactive proofs 
siam computing vol 
gs goldwasser sipser 
private coins versus public coins interactive proof systems 
proceedings eighteenth annual symposium theory computing acm 
astad 
testing long code hardness clique 
proceedings eighth annual symposium theory computing acm 
astad 
clique hard approximate gammaffl proceedings seventh annual symposium foundations computer science ieee 
astad 
getting optimal approximability results 
manuscript june 
revised october 
hoc hochbaum 
efficient algorithms stable set vertex cover set packing problems 
discrete applied mathematics vol pages 
impagliazzo zuckerman 
recycle random bits 
proceedings thirtieth annual symposium foundations computer science ieee 
jones lien 
new problems complete nondeterministic log space 
math 
systems theory vol 
pages 
free bits pcp kah 
second eigenvalue linear expansion regular graphs 
proceedings third annual symposium foundations computer science ieee 
kann khanna 
hardness approximating max cut dual 
technical report department numerical analysis computing science royal institute technology stockholm 
kms karger motwani sudan 
approximate graph coloring semidefinite programming 
proceedings fifth annual symposium foundations computer science ieee 
ka karp 
reducibility combinatorial problems 
complexity computer computations miller thatcher eds plenum press new york 
kls khanna linial safra 
hardness approximating chromatic number 
proceedings second israel symposium theory computing systems 
shamir 
fully parallelized multi prover protocols nexp time 
proceedings second annual symposium foundations computer science ieee 
lau 
bpp polynomial hierarchy 
information processing letters vol 
pages 
lev levin 
universal universal search problems russian 
pages 
lps lubotzky phillips 
explicit expanders ramanujan conjectures 
proceedings eighteenth annual symposium theory computing acm 
lund yannakakis 
hardness approximating minimization problems 
journal acm vol 
pages 
lund fortnow karloff nisan 
algebraic methods interactive proof systems 
proceedings annual symposium foundations computer science ieee 
sloane 
theory error correcting codes 
northholland 
mora motwani raghavan 
randomized algorithms 
cambridge university press 
monien 
approximation algorithms vertex cover problem 
proceedings caap notes computer science vol 
springer verlag 
papadimitriou yannakakis 
optimization approximation complexity classes 
journal computer system sciences pp 

bellare goldreich sudan pet petrank 
hardness approximations gap location 
tr department computer science technion israel institute technology 
spielman 
nearly linear size holographic proofs 
proceedings sixth annual symposium theory computing acm 
raz raz 
parallel repetition theorem 
proceedings seventh annual symposium theory computing acm 
sahni gonzales 
complete approximation problems 
acm 
ta tardos 
multi prover encoding schemes prover proof systems 
proceedings ninth annual conference structure complexity theory ieee 
sh shamir 
ip pspace 
proceedings annual symposium foundations computer science ieee 
ta 
note pcp vs mip 
technical report institute computer science hebrew university israel 
appear ipl 
trevisan sorkin sudan williamson 
gadgets approximation linear programming 
proceedings seventh annual symposium foundations computer science ieee 
ya yannakakis approximation maximum satisfiability 
journal algorithms vol 
pages 
zu zuckerman 
np complete problems version hard approximate 
proceedings eighth annual conference structure complexity theory ieee 
