precise identification side effect free methods java knowing methods side effects necessary variety software tools program understanding restructuring optimization verification 
general approach identifying side effect free methods java software 
technique parameterized class analysis designed incomplete programs 
empirical results instantiations approach rapid type analysis points analysis 
experiments components average investigated methods identified free side effects 
precision evaluation shows approach achieves perfect precision misses methods reality side effects 
results indicate precise identification side effect free methods possible simple inexpensive analysis techniques easily incorporated software tools 
side effects method state changes observed code invokes method 
presence absence side effects important property variety uses software tools 
side effects negative effect program comprehension valuable programmer time saved program understanding tool automatically identifies labels side methods 
tool simplify method eliminating need investigate manually actions performed method body method transitive callees 
absence side effects desirable property defined design time 
example uml defines attribute operations 
attribute specifies operation leaves state system unchanged true side effects may occur false default value false 
real rountev department computer science engineering ohio state university rountev cis ohio state edu ity design code diverge 
example modern iterative incremental development necessary reverse engineer design existing code 
typical scenario perform design recovery reverse engineering iteration code current iteration results serve starting point subsequent design 
case identification side effect free methods code ensure consistency properties design 
optimizing compilers program transformation tools absence side effects allows number semantics preserving transformations 
similarly correctness refactorings depends ensuring methods side effects 
investigating differences sets side effect free methods code modifications provide simple form change impact analysis 
information side effect free methods useful situations 
example query debugging object oriented programs necessary know query expression side effects 
similarly expressions assertions jml free side effects 
approaches software security secureuml permissions restricted allow invocations side methods 
cases necessary able determine precisely methods side effects 
side effect analysis determines memory locations may modified execution program statement 
unfortunately existing side effect analysis directly identify side effect free methods 
procedural languages goal analyze java code requires handling virtual calls 
second side effect analyses typically designed analyze complete programs 
context software tools essential able perform separate analysis software components 
example typical analyze component having access clients component 
program side effect analysis solve problem 
problem existing side effect analysis provide information degree imprecision analysis results analysis false claims 
critical issue program analysis software tools imprecision may lead waste human time effort possibly render analysis useless 
goal develop analysis techniques identifying side effect free methods incomplete java programs evaluate imprecision techniques 
describe static analysis identifies methods free side effects respect clients analyzed component 
approach parameterized class analysis determines classes objects variable field may point 
class analysis identify calling relationships methods characterize heap objects modified state 
approach shows large body class analysis discover side methods incomplete programs 
implemented instances approach rapid type analysis rta context sensitive points analysis 
techniques belong opposite ends cost precision spectrum investigation provides insights applicable large portion design space problem 
subject components approach achieves perfect precision discovers side effect free methods 
furthermore approach achieves perfect precision 
cases large number methods average identified having side effects 
results indicate side effect free methods occur methods identified precisely inexpensive analysis techniques 
contributions propose parameterized analysis identifying side effect free methods incomplete java programs 
experimental results evaluate large segment analysis design space 
problem definition goal design static analysis answers question set java classes component analyzed methods classes may produce side effects invoked unknown client code written top component 
analysis output set component methods guaranteed free side effects invoked arbitrary client code 
analysis results useful various users component included component documentation example javadoc comments added automatically source code component 
information programmers writing modifying code built top component software tools analyze client code 
having information especially important reusable components class libraries developed independently clients component functionality 
furthermore developer component results ensure design goals attributes fact satisfied actual implementation 
input analysis contains set cls interacting java classes 
classes refer java classes interfaces distinction irrelevant 
subset cls designated set accessible classes classes may accessed unknown client code outside cls 
assume client code access fields methods cls declared accessible class 
side effect free methods define notion side effect free method consider run time execution client code built top cls 
suppose call site client code invokes method defined cls 
refer methods boundary methods 
invocation boundary method free side effects observable state immediately completion invocation exactly observable state immediately invocation 
observable state execution point consists static fields heap objects transitively reachable static fields locals formals methods currently run time call stack 
invocation changes value static field potentially affect client code executed similarly invocation modifies object structure reachable static fields currently active locals formals may affect subsequent execution 
change object structure due modifications non fields integer fields boolean fields 
change due fields example new object may created may assigned field existing object 
note side effect analyses typically consider changes heap object structure side effects 
hand definition takes account changes observable caller follows notion pure methods 
boundary method cls side effect free possible client invocations possible run time executions arbitrary clients cls free side effects subject constraints described section 
package iter public class public static return new simpleboundary public void ci public void string public public int public int public int string public int public int final class simpleboundary extends private text private int pos public void ci text ci pos text public void string new stringchariter public return text public int pos text return pos public int return text public int string stringchariter tmp new stringchariter return tmp public int pos pos return pos public int return pos private int int offset text 
public interface public int public char 
public class stringchariter implements private string txt private int curr public stringchariter string txt public int return public char curr 

sample package iter 
example 
consider package 
example classes standard java library package java text modifications introduced illustrate aspects approach 
allows iteration different boundaries text boundaries words boundaries sentences internally iteration implemented simpleboundary 
text accessed defines protocol iteration characters 
stringchariter implements protocol string objects 
cls contains classes plus string 
class simpleboundary package visibility accessed directly client code remaining classes designated accessible classes 
boundary methods trivially free side effects 
method side effect free 
method string free side effects creates temporary object escape caller method caller observable state change 
boundary methods potentially side effects 
constraints considering effects method invocation useful define certain constraints allow precise discrimination sources side effects 
definition side effects employ constraints 
consider executions invocation boundary method cls leave cls transitive callees cls 
constraint assume unknown called methods side effects modify static fields 
particular consider possibility unknown subclasses override methods cls instance calls inside cls potentially redirected unknown external code may side effects 
vast majority methods cls reported having side effects 
example call potentially side effects client code creates uses unknown class implements interface stringchariter 
analysis scope restricted set cls set include relevant classes code available 
example experiments section included cls classes transitively referenced classes cls 
approach user analysis information valid currently known set classes may invalidated addition new subclasses classes cls 
alternative approach change analysis worst case assumptions calls may leave cls enter unknown overriding methods 
believe overly conservative approach useful restrict scope analysis known world 
analysis produce results valid particular set classes currently available analysis user 
course user aware definition side effect free may valid context larger set classes contains new subclasses classes cls analysis rerun subclasses available 
second constraint related order method invocations 
consider executions invocation boundary method cls subsequent invocations callees executed single threaded fashion interleaving invocations due threads 
approach traditionally employed side effect analyses 
possibility arbitrary method side effects executed point time execution method considered side effect free 
class analysis class analysis determines classes objects variable field may point 
information variety uses software tools optimizing compilers 
class analysis approximate calling relationships methods set objects constitute observable state respect client code 
goal define general theoretical framework analyses identify side effect free methods design space class analysis algorithms 
categories class analysis large body class analyses different cost precision trade offs 
dimension precision flow sensitivity 
flow insensitive analyses take account flow control method expensive precise flow sensitive analyses 
dimension context sensitivity context sensitive analyses employ abstraction calling context method order achieve higher precision 
important analysis aspect naming scheme distinguish instances class 
traditional class analyses distinction 
class analyses referred points analyses create separate name allocation site 
case instances class modeled differently created different new expressions code 
allow uniform treatment approaches assume analysis uses set object names represent heap objects 
traditional class analysis single object name instantiated class instantiated array type 
points analysis separate object name new expression 
output class analysis output class analysis usually thought set relationships form local formal may refer instances field may refer instances 
assume output different form represents exactly kinds relationships convenient subsequent analyses 
consider output set points pairs set call edges 
points pairs represent relationships 
call edges represent possible calling relationships methods 
definition allows general uniform treatment wide range analyses different degrees context sensitivity :10.1.1.25.4206:10.1.1.32.1100:10.1.1.25.1069
denote set call edges 
call edge pair call site method potentially invoked polymorphic call site multiple call edges mi 
class analyses construct fly analysis case constructed analysis completes 
set locals formals static fields types class interface array types 
set denotes set object names analysis described 
set contains set contexts 
context sensitive analysis elements represent abstractions calling context 
assume contains special element denotes empty context 
context insensitive analyses define 
call edge analysis computes set possible contexts ce may introduced entry called method examples common context abstractions top call sites call stack representing receiver object 
analysis solution represents categories may refer relationships consider ce context introduced entry method call edge 
analysis solution contains points pair means run time invoked calling context invocation may refer object represented suppose instance field objects represented example represents objects class instance field declared inherited superclasses 
pair shows run time field object represented may refer object represented 
represents array objects shows element array represented may refer run time object represented 
fragment class analysis class analysis usually designed program analysis takes input complete program produces information relationships entire program 
problem considering requires analysis partial programs 
input set void main break iter char iter stringchariter string char iter string string string literal break iter break iter char iter break iter string char iter break iter break iter break iter break iter string break iter break iter char iter char iter string char iter new stringchariter string char iter string char iter 
placeholder main method iter 
classes cls analysis take account possible effects client code may built top cls 
address issue adaptation earlier fragment class analysis 
analysis works program fragment complete program fragment set classes cls 
approach produces artificial main method simulates possible flow object cls client code may written top cls 
intuitively main serves placeholder possible client code 
fragment analysis attaches method cls invokes engine program class analysis 
technique applicable flow insensitive program class analyses :10.1.1.25.4206:10.1.1.32.1100:10.1.1.25.1069
wide spectrum fragment analyses defined manner simple inexpensive analyses rapid type analysis rta relatively complicated context sensitive analyses 
placeholder main method classes shown 
method contains variables correspond different types cls may accessed client code 
statements represent different possible interactions involving cls 
order statements irrelevant subsequent program class analysis flow insensitive 
method main invokes public methods classes cls designated accessible classes 
variables calls types method signatures 
statement takes account possibility assignment conversions stringchariter 
fragment analysis solution discuss details approach creating placeholder main method additional informa tion available 
important define precisely properties information produced fragment analysis information subsequently identify side effect free methods 
call graph 
consider arbitrary client program built top cls execution program satisfies constraints described section 
relationship form execution call site method invokes method fragment analysis solution contains call edge represents relationship 
methods cls solution contains call edge 
cls call graph contains call edge call site inside placeholder main method 
essentially call graph computed fragment analysis thought projection possible calling relationships cls cls client code 
object reachability 
consider client program built top cls execution program satisfies constraints section 
suppose declared cls point execution start chain object leads heap object 
fragment analysis solution chain points pairs starts leads object name represents run time object 
context represents run time call stack execution point 
similar property holds declared outside cls 
case fragment analysis solution starting point chain variable main type rapid type analysis illustrate properties fragment analyses 
rapid type analysis rta 
rta simple program analysis computes set methods reachable main set classes instantiated reachable methods 
distinguish allocation sites object name instantiated type context insensitive 
suppose main method added classes result analyzed rta complete program 
called main added set reachable methods 
inside method simpleboundary instantiated 
calls break iter may invoke corresponding methods simpleboundary 
analysis main shows stringchariter may instantiated 
final solution methods determined reachable instantiated classes simpleboundary stringchariter 
break iter simpleboundary char iter stringchariter string char iter stringchariter ci stringchariter tmp stringchariter string string string string string simpleboundary text stringchariter stringchariter txt string 
points pairs computed rta 
computed points pairs shown object names instantiated class 
brevity show pairs involving implicit parameters 
solution provides conservative information object reachability 
example pairs break iter simpleboundary simpleboundary text stringchariter imply variable declared client code type may start chain object leads instance stringchariter 
context sensitive points analysis example analysis cost precision spectrum consider fragment class analysis context sensitive program points analysis java 
analysis contextsensitive version flow context insensitive points analysis java 
rta analysis creates separate object name new expression uses set contexts approximate state run time call stack 
set contexts exactly set object names context represents invocation instance method receiver object invocation analysis propagates may refer relationships analyzing individual program statements 
example analysis encounters context infers may refer object may refer 
theoretically approach substantially precise rta 
consider example figures 
case object names 
denoted simpleboundary stringchariter string correspond allocation sites main method 
name stringchariter corresponds allocation string stringchariter corresponds allocation string 
points pairs shown simplicity show pairs involving 
variables main calling context empty context 
locals formals inside simpleboundary context simpleboundary represents receiver methods class 
break iter simpleboundary char iter stringchariter char iter stringchariter string char iter stringchariter string string ci simpleboundary stringchariter ci simpleboundary stringchariter simpleboundary string simpleboundary string tmp simpleboundary stringchariter implicit formal constructor stringchariter stringchariter stringchariter stringchariter stringchariter stringchariter stringchariter stringchariter string stringchariter string stringchariter string implicit formal stringchariter stringchariter stringchariter stringchariter simpleboundary text stringchariter simpleboundary text stringchariter stringchariter txt string stringchariter txt string stringchariter txt string 
points pairs computed points analysis 
methods stringchariter contexts corresponding names instances class 
results infer precise object reachability relationships possible rta 
example chains lead stringchariter variables declared main 
variables client code start chains lead objects created string 
information allows approach identify method string side effect free possible solution 
side effect free methods program side effect analysis compute information behavior complete program 
order analyze partial programs define form fragment side effect analysis output fragment class analysis 
furthermore traditional side effect analysis approach takes account changes observable callers method 
analysis identifies objects approximate observable state respect client code 
determines methods may modify fields objects 
performs backward propagation call graph identify methods indirect side effects invoke methods side effects 
contexts rta contexts points analysis immediate side effects transitive side effects immediate side effects transitive side effects simpleboundary simpleboundary string simpleboundary simpleboundary simpleboundary simpleboundary string simpleboundary simpleboundary simpleboundary simpleboundary stringchariter stringchariter stringchariter stringchariter stringchariter table 
contexts methods immediate transitive side effects 
observable state invocations side effect free method affect state observable callers 
observable state program point consists static variables heap objects transitively reachable static variables locals formals methods currently run time call stack 
identify object names represent objects part observable state callers boundary methods 
done traversing points pairs produced fragment class analysis 
starting point traversal variables declared placeholder method main 
object name transitively reachable variables included observable state refer object names observable object names 
consider solutions figures 
solution observable state contains object names simpleboundary stringchariter string 
second contains simpleboundary stringchariter stringchariter string 
observable state contains kinds objects objects exist call objects created call escape caller 
existing escape analysis identify escaping objects :10.1.1.12.2189
chose identify escaping objects fragment class analysis 
general approach easy implement allows cost precision trade offs underlying class analysis 
experiments indicate simple inexpensive analyses rta achieve high precision expensive escape analyses may unnecessary problem considered 
immediate side effects second step analysis identifies method invocations immediate side effects 
invocations modify value static variable modify observable objects 
call edge ce calling context pair represents invocation context invocation immediate side effects assigns value static field contains object allocation site corresponds observable object name assigns value refers observable object name instance field assigns value refers observable object name represents array object table show contexts pair immediate side effects 
consider rta solution case analysis uses single context 
creates objects represented observable object name simpleboundary method immediate side effects 
method contains assignments fields text pos 
implicit formal refers observable object name simpleboundary method immediate side effects 
methods class modify instance field observable object methods contain allocation sites correspond observable object names string string 
class stringchariter constructor method immediate side effects 
alternatively constructor considered free side effects modifies fields newly created object 
consider solution computed contextsensitive analysis 
immediate side effects creates objects represented observable object name simpleboundary 
static method receiver object analysis uses invocation context 
component functionality classes boundary side effect free methods methods rta perfect gzip gzip io streams zip zip io streams checked io streams checksums text date date formatting number number formatting boundary iteration boundaries text table 
java components side effect free methods 
methods modify instance fields observable object name simpleboundary 
method string creates objects represented observable name stringchariter 
string allocation corresponds stringchariter part observable state 
method immediate side effects 
methods stringchariter immediate side effects calling contexts stringchariter stringchariter 
name stringchariter valid context constructor context modifications observable objects 
transitive side effects final step analysis considers indirect side effects due called methods 
consider invocation represented pair method calling context 
invocation transitive side effects holds immediate side effects contains call site invoked site invokes method context invocation transitive side effects 
table shows pairs transitive side effects 
side effects 
invokes transitive side effects 
transitive side effects invoke 
context sensitive solution constructor invocation string creates calling context stringchariter context constructor immediate side effects caller transitive side effects 
analysis computes pairs transitive side effects considers call sites inside main method 
call site invokes boundary method cls context transitive side effects method reported potentially having side effects may observed client code 
remaining method guaranteed free side effects invoked client code 
rta approach identifies side effect free methods 
contextsensitive analysis method string identified having side effects 
experimental study goal study address questions 
different analyses discover side effect free boundary methods 
second significant imprecision analyses methods fact free side effects 
answers questions provide essential insights analysis designers tool builders 
question performed experiments class analyses opposite ends cost precision spectrum rta context sensitive points analysis described section 
experiments java components standard library packages java text java util zip 
components described briefly columns table 
component contains set classes provide certain functionality discussed section set cls contains classes plus classes directly transitively referenced 
column shows size cls 
considered boundary methods particular component functionality number methods column 
number side effect free methods order determine boundary methods side effect free applied approach earlier basis rta points analysis 
columns show methods column identified free side effects 
average analyses reported side effect free methods 
results indicate large number methods free side effects analyses compute useful information various software tools 
somewhat surprisingly versions analysis achieve essentially precision 
difference zip theoretically precise analysis identifies additional method 
difference analyses covers large portion analysis design space results indicate precise identification side effect free methods possible simple inexpensive analysis techniques low cost precision spectrum 
observations promising suggest functionality easily incorporated software tool 
analysis imprecision issue analysis imprecision critical importance software tools 
analysis imprecise may report methods side effects reality 
information little confusing tool users 
example user attempts ensure consistency code properties uml design imprecision mean code method transitive callees inspected manually identify source discrepancy 
negative effects imprecision evaluated carefully precisely 
unfortunately traditional approach precision evaluation static analysis research provide sufficient information evaluate imprecision 
usually precision evaluations compare results static analyses 
indicate far away analyses perfect solution contain imprecision 
experiments carefully examined boundary methods reported having side effects attempted prove possible write client code observed side effects 
precisely attempted prove exists run time execution client code method invocation side effects definition section 
essentially proofs existence 
results shown column table 
cases able prove methods reported points analysis having side effects side effect free reality 
analysis achieves perfect precision 
rta analysis achieves perfect precision missing method side effect free 
results promising indicate presence large number side effect free methods 
analysis provide useful information variety software tools 
furthermore strong indication highly precise information obtained techniques inexpensive simple implement 
course results need components 
point draw 
investigations focus initially analyses low cost precision spectrum 
second precision analysis results evaluated comparing analyses directly perfect solution 
related large body interprocedural sideeffect analysis 
languages general purpose pointers analysis preceded pointer analysis disambiguates memory accesses 
ryder general framework side effect analysis programs parameterized pointer analysis 
pointer analysis context sensitive propagation side effects done context sensitive fashion 
approach similar idea context sensitive class analysis take account different calling contexts considering method immediate transitive side effects 
approach designed partial programs consider observable state respect client code schema program analysis 
furthermore directly evaluate degree imprecision analysis solution 
presents algorithms side effect analysis java context insensitive class analyses 
milanova propose side effect analysis java particular form context sensitive class analysis described section 
cases side effect analysis designed program analysis 
approach general allows analysis partial programs parameterized wide range class analyses context sensitive contextinsensitive 
evaluation analysis imprecision essential information designers software tools 
rinard presents static analysis identifies pure methods java code 
analysis produces additional information example regular expressions describing heap objects modified method side effects 
technique pointer escape analysis 
takes different approach specialized pointer escape analysis points relationships calling relationships computed fragment class analysis identify observable objects may modified 
allows variety existing class analyses :10.1.1.25.4206:10.1.1.32.1100:10.1.1.25.1069
defines approach performing analysis side effect free methods java components 
study indicates large number methods identified having side effects typically side effect free methods successfully identified 
clearly premature draw far reaching experiments 
step investigating problem results promising 
furthermore provide clear direction investigations 
additional experiments researchers may possible conclude precise identification side effect free methods done easily efficiently 
plan perform investigations 
agesen 
cartesian product algorithm 
european conference object oriented programming lncs pages 
bacon sweeney 
fast static analysis virtual function calls 
conf 
object oriented programming systems languages applications pages 
blanchet 
escape analysis object oriented languages 
conf 
object oriented programming systems languages applications pages 
lzle 
removing unnecessary synchronization java 
conf 
object oriented programming systems languages applications pages 
choi gupta serrano sreedhar midkiff 
escape analysis java 
conf 
object oriented programming systems languages applications pages 
defouw grove chambers 
fast interprocedural class analysis 
symposium principles programming languages pages 
harman 
empirical investigation influence type side effects program comprehension 
ieee trans 
software engineering july 
fowler 
refactoring improving design existing code 
addison wesley 
gosling joy steele bracha 
java language specification 
addison wesley edition 
grove chambers 
framework call graph construction algorithms 
acm trans 
programming languages systems nov 
grove defouw dean chambers 
call graph construction object oriented languages 
conf 
object oriented programming systems languages applications pages 

applying uml patterns 
prentice hall nd edition 
leavens baker ruby 
jml notation detailed design 
behavioral specifications businesses systems pages 
kluwer academic publishers 
lzle singh 
query debugging object oriented programs 
conf 
object oriented programming systems languages applications pages 
hendren 
scaling java points analysis spark 
international conference compiler construction lncs pages 
liang harrold 
extending evaluating flow insensitive context insensitive points analyses java 
workshop program analysis software tools engineering pages 
basin 
secureuml uml modeling language model driven security 
international conference unified modeling language lncs pages 
milanova rountev ryder 
parameterized object sensitivity points side effect analyses java 
international symposium software testing analysis pages 
omg 
uml infrastructure specification 
object management group www omg org aug 

study side effect analyses java 
master thesis mcgill university dec 
rountev 
evaluating imprecision static analysis 
workshop program analysis software tools engineering june 
rountev milanova ryder 
points analysis java annotated constraints 
conf 
object oriented programming systems languages applications pages oct 
rountev milanova ryder 
fragment class analysis testing polymorphism java software 
ieee trans 
software engineering june 
ryder landi stocks zhang 
schema interprocedural modification side effect analysis pointer aliasing 
acm trans 
programming languages systems mar 
snelting 
points java general framework empirical comparison 
technical report passau sept 
rinard 
combined pointer purity analysis java programs 
technical report mit csail tr mit may 
sundaresan hendren rai lam gagnon godin 
practical virtual method call resolution java 
conf 
object oriented programming systems languages applications pages 
tip palsberg 
scalable propagation call graph construction algorithms 
conf 
object oriented programming systems languages applications pages 
whaley rinard 
compositional pointer escape analysis java programs 
conf 
object oriented programming systems languages applications pages 
