practical type system language immutability adrian michael ernst mit computer science artificial intelligence lab cambridge ma usa csail mit edu describes type system capable expressing enforcing immutability constraints 
specific constraint expressed state object immutable refers modified 
state part transitively reachable state state object state reachable 
type system permits explicitly excluding fields objects state object 
statically type safe language type system guarantees immutability 
language extended immutability downcasts run time checks enforce immutability constraints 
order better understand usability efficacy type system implemented extension java called javari includes features type system 
javari interoperable java existing jvms 
viewed proposal semantics java const keyword javari syntax uses readonly 
describes design implementation javari including type checking rules language 
discusses experience lines javari code 
javari easy provided number benefits including detecting errors tested code 
categories subject descriptors programming languages language constructs features data types logics meanings programs specifying verifying reasoning programs pro gramming techniques object oriented programming general terms languages theory experimentation keywords type system verification immutability readonly mutable javari const permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
oopsla oct vancouver british columbia canada 
copyright acm 

presents type system specifying immutability transitively reachable state object refers modified 
transitively reachable state object state reachable 
type system enforcing immutability number benefits increase expressiveness enhance program understanding reasoning providing explicit machine checked documentation save time preventing detecting errors difficult track enable analyses transformations depend compiler verified properties 
type system differs previous proposals java languages number ways 
offers object immutability immutability flexible provides useful guarantees code manipulates mutable objects 
example objects modified construction phase interface specify method receives immutable parameter modify parameter caller modify return value 
furthermore subsequent analysis strengthen immutability stronger guarantees object immutability desired 
system offers guarantees entire transitively reachable state object 
programmer may type system support reasoning representation state object state order support parts class marked part state 
state part transitively reachable state state object state reachable 
type system permits excluding specific fields state 
system combines static dynamic checking safe expressive way 
dynamic checking necessary programs immutability downcasts downcasts convenient interoperation legacy code express facts proved type system 
system offers parameterization immutability 
type system limited interest programmers effectively 
absence experience implementation practicality previous proposals speculative 
designed implemented javari stands java immutability extension java language permits specification enforcement immutability constraints 
javari specifies immutability constraints keyword readonly 
language backward compatible java 
addition javari code interoperable legacy java code runs unmodified java virtual machine 
javari compiler publicly available pag csail mit edu javari 
obtained experience javari writing code annotating java code readonly convert javari 
class represents set integers 
public class intset integers set duplications 
private int ints removes elements set modifying set 
public void intersect intset set 
intset initialized int 
throws duplicate elements argument ints 
public intset int ints ints throw new ints ints number distinct elements 
public int size return ints length public int return ints partial implementation set integers 
total lines javari code including javari compiler 
experience helped design language features javari useful easier 
addition experience helped clarify benefits javari 
organized follows 
section gives examples immutability constraints 
section describes javari language section presents type checking rules context javari 
section relates experience javari 
section surveys related section concludes 

examples immutability provides variety benefits different situations 
section gives simple examples immutability constraints 
examples show enforcement interface contracts granting clients read access internal data prevention certain representation exposures 
section discusses analyses provide guarantees building immutability possibly assistance limited escape alias analysis 
class representing set integers illustrate problems solutions 
method contract may state method modify arguments case intset intersect 
compiler enforcement contract guarantees implementers inadvertently violate contract permits clients depend property 
javari allows designer intset write public void intersect readonly intset set compiler verifies method specification modifying set 
accessor methods return data exists part representation module 
example consider method intset class 
simple efficient exposes intset representation 
java solution return copy array ints 
system permits better solution public readonly int readonly keyword ensures caller intset modify returned array permitting simple efficient implementation method remain place exposing representation undesired changes 
representation exposure occurs implementation details accessible clients 
java access control mechanisms example private keyword partly address problem javari prevents additional problems 
system immutability address serious problem mutational representation exposure permits modification values violation data structure invariants relevant observational representation exposure may innocuous desirable 
example intset example accessor method exists provide external access object state 
intset example content private data member ints externally accessible passed constructor intset int 
client code directly change state intset object undesirable 
worse client code violate representation invariant put intset object inconsistent state 
example client code put duplicate integer array ints cause method intset size return incorrect value 
javari catch representation exposure compile time 
constructor intset intended change argument ints intset programmer write public intset readonly int ints compiler issue error attempt assign ints ints preventing intset programmer forgetting deep copy constructor 

javari language javari language extends java explicit mechanisms specifying immutability constraints compile time type checking guarantee constraints run time checking programs potentially unsafe casts 
javari adds new keywords java readonly mutable 
readonly keyword specifies immutability constraints 
mutable keyword indicates field part state object downcasts read types non readonly types 
keywords follows readonly ways 
type modifier java type readonly valid type javari supertype variable type known read 
returned array aliased ints field intset code change external code 
unspecified semantics may permit 
method specification note returned reflects changes intset alternately method specification external analysis require result modification intset 
java reserves currently keyword const new keyword strictly necessary 
chosen introduce new keyword readonly reusing const reasons 
believe readonly better describes concept immutability 
second wish avoid confusion keyword const see section 
read change state object array refer 
read type declaration variable field parameter method return type 
read type appear type cast 
see section 
method constructor modifier readonly parameter list non static method declaration likewise inner class constructor making method read method 
read methods change state receiver object 
read methods called read 
see section 
class modifier readonly modifier class interface declaration 
specifies instances class interface immutable 
see section 
mutable ways 
non static field declaration mutable specifies field part state object 
mutable fields modified read methods read non mutable fields 
see section 
type cast mutable converts read non read 
run time checks inserted maintain soundness enforce immutability run time 
see section 
javari supports type parameterization principled way create related versions code section 
javari backward compatible java java program uses javari keywords valid javari program semantics 
javari interoperable java java javari code call recompilation section 
postpass analysis build javari guarantee immutability order stronger guarantees program behavior section 
read read modify object refers 
read object type type readonly example suppose variable declared readonly stringbuffer read stringbuffer object perform actions stringbuffer object modify 
example valid reverse causes compile time error 
return type method read code calls method return value modify object value refers 
note final readonly orthogonal notions variable declaration final variable assignable object mutable readonly referenced object immutable variable remains assignable 
keywords gives variables transitively reachable state changed non readonly aliasing 
rules usage read detailed section ensure code access read object modify object 
read copied assignment parameter passing non read 
example statement stringbuffer buf cause compile time error 
read field object referred assigned read 
read methods section called readonly 
javari allows declarations arrays read 
example readonly stringbuffer means array read stringbuffer objects 
array assignments array allowed modifications objects stored array 
contrast readonly stringbuffer specifies read array disallows array element assignment modification objects stored array 
non read implicitly converted readonly assignment including implicit assignment parameters method constructor invocations 
non read explicitly cast read type form readonly 
example readonly stringbuffer new stringbuffer stringbuffer buf new stringbuffer buf ok readonly stringbuffer buf ok buf error buf stringbuffer error see section details type casts 
read methods constructors read methods methods called readonly 
declared keyword readonly immediately parameter list method 
compile time error read method change state receiver object 
example appropriate declaration stringbuffer method javari public char int index readonly read constructors constructors called enclosing instance read 
java language specification requires constructor non static inner class called instance outer class instance called enclosing instance 
read constructors declared keyword readonly immediately parameter list constructor 
compile time error readonly constructor change state enclosing instance 
read constructors enclosing instance supplied read promise modify enclosing object 
read constructors constrain constructor effects object constructed invoker uses returned object 
method constructor read part signature possible methods name parameters read 
similarly read method declared subclass overloads overrides non read name parameters declared superclass vice versa 
immutable classes class interface declared immutable readonly modifier declaration 
means term read type mean readonly immutable type mean class interface definition marked readonly immutable 
non mutable non static fields implicitly read final non static methods implicitly read 
addition class inner class constructors implicitly read 
immutable class interface read non readonly objects type equivalent 
particular read copied non read normally disallowed 
subclasses immutable classes interfaces declared immutable 
instance field inherited immutable class interface final read type mutable 
instance method inherited class interface read 
mutable fields mutable fields declared mutable modifier considered part state object 
mutable field object changed read mutable fields enable creation read containers hold non read elements 
mutable fields cache results read methods 
example situation arises javari compiler name resolution method resolve needs cache result computation 
solution looks somewhat class private mutable resolution res null public resolution resolve readonly res null res ok res mutable return res mutable fields objects unable cache results read methods consequently javari force programmer label methods read take significant performance penalty 
readonly mutable final keywords capture distinct concepts 
field declared mutable readonly transitive state object refers field readonly field assignable mutable 
field declared mutable final assignable final state object refers changeable field field accessed read mutable 
field declared keywords mutable effect 
type parameterization javari adopts type class interface method parameterization mechanisms java known generics 
benefits feature reduces code duplication 
example eases definition container classes permitting definition vector instantiated container objects readonly objects container state includes elements excludes elements 
importantly parameterization permits single method definition expand multiple definitions differ immutability parameters method 
javari augments generics java permit type qualifier readonly empty type qualifier type parameter 
enables parameterization method read section 
eases writing definitions different java types qualifier example class daikon section public ro list get ro ppt ro java compiles generics erasure type checking complete bytecodes instantiations class method 
prototype compiler uses different compilation strategy immutability generics duplicates parameterized declaration 
care taken dealing different kinds parameters essentially splitting possibly overlapping parts processing parts separately 
duplicate code necessary eliminate immutability parameterization process remaining parameters usual way 
likewise cast changes java type type read section cast converted casts java type readonly processed separately 
type casts non trivial type system rejects programs safe perform erroneous operation run time safety proof capabilities type system 
java javari allows programs requires specific programmer annotations downcasts annotations trigger javari insert run time checks modification points guarantee unsafe operation executed 
benefits programmers need code type system constraints know code correct interoperation legacy libraries eased 
alternatives prohibiting programs proved safe including uses arrays running programs safety guarantee unsatisfactory spirit java 
program written typesafe subset javari static type checking suffices 
purposes unsafe operation downcast converts superclass subclass 
appear explicitly certain uses arrays java covariant array types prevent sound static type checking 
example subtype defines method arr new arr new arr arr arr arr method statically ok java inserts checks cast array store throws exception cast fails 
javari syntax read type type mutable expression 
regular java style casts convert read non read types 
special downcast syntax highlights cast ordinary java easy find casts 
see section read non read type potentially storing read non read array triggers insertion run time checks modification assignment may applied readonly cast away 
run time checks guarantee read flows non read impossible modifications occur non read 
javari soundly maintains guarantee read directly indirectly modify referent 
run time checking conceptually javari checking works way 
system associates single readonly boolean ro object regardless static type 
array treated similarly need boolean array boolean element 
readonly boolean true non read derived readonly result downcast 
readonly boolean set readonly cast away propagated assignments checked modification field update performed non read 
instanceof operator checks boolean determine instanceof mutable non read static type 
key rules checking follows 
type expressions field name 
operation yields modified produce readonly boolean 
rules ro ro mutable ro true read static type second field update modified check readonly boolean updated 
statement ro throw exception ro ro method calls modeled assignments actuals formals plus assignment return statement call result 
remainder rules straightforward example array elements treated analogously fields omitted brevity 
optimizations rules possible 
example analysis cha rta determine classes unsafe operation may applied classes reachable 
checks need inserted reachable classes 
furthermore checks need inserted immutable classes classes reached immutable 
words instances readonly program overhead run time checking 
checks hoisted loops eliminated static analysis indicates unnecessary 
explicit readonly booleans need created intermediate results 
implemented prototype implementation runtime checking 
inserted source source postpass invoked program compiled contains unsafe casts array uses 
resulting code runs unmodified jvm 
implementation highly tuned instance includes optimizations partial hoisting optimization 
furthermore source source transformation incurs substantial overhead introducing wrapper classes hold readonly boolean value indicates immutable 
despite inefficiencies prototype introduces slowdowns averaging suite real benchmark programs containing readonly annotations 
ran experiments sun jdk pentium running red hat linux cases boolean added new variable field example field exists boolean field ro added manipulated checked 
cases libraries source available arrays class objects return values wrapping inevitable introducing space especially time costs 
main focus type system usability important run time efficiency hindered relatively small slowdowns 
believe optimizations listed substantially reduce overhead 
approach modify jvm directly operating source level 
instance place readonly boolean unused bit java 
approach eliminate need new slots objects wrapper objects 
updating code necessary assignments copying automatically copy immutability boolean 
checking code required bit need masked pointers dereferenced 
seriously modified jvm required order run javari programs 
hope investigate optimizations 
interoperability java javari interoperable java existing jvms 
language treats java method javari method immutability specification parameters return type method similarly constructors fields classes 
javari type system know java method modify assumes method may modify 
approach allows javari call java code safely immutability guarantees violated 
cases analysis conservative 
example object tostring safely assumed read method 
javari permits user specify alternative signatures methods constructors fields java libraries native code 
compiler trusts annotations checking 
java methods called javari java code call javari methods contain readonly signatures 
javari compiler achieves standard java names non read types methods classes names read types methods classes ones referenced legal java code 
javari program uses downcasts trigger insertion run time checks section called java code recompiled javari compiler run time checks inserted call site call proved pass checks inserted jvm 
javari compiler guarantees javari code maintains immutability constraints 
malicious client subvert type system writing classes directly jvm bytecode 
order prevent loopholes bytecode verifier extended verify immutability constraints just verifies type constraints initially checked source code level 
classfile checking suggests alternative syntax express information immutability source code classfiles metadata new feature java 
approach eliminate need new keywords proposal 
type analyses section describes type analyses run javari type checking order provide stronger guarantees 
type analysis assumes program type checks type checking independent subsequent analysis 
javari enforces immutability read side effect object reachable 
immutability benefits section 
guarantees may desirable certain situations 
guarantees object immutability thread non interference parameter non mutation return value non mutation 
advantage immutability subsequent analysis establish properties outlined converse true 
extending immutability stronger guarantees requires escape analysis partial information aliasing 
determining complete accurate alias information remains state art fortunately analyses require full alias analysis 
obtaining alias information particular easier precise general problem 
programs pointers disciplined limited ways may correspond may motivated places programmers desire reason immutability 
new alias analyses available applied analyses preferable embedding assumptions particular alias analysis type system 
programmers mechanisms controlling analyzing aliasing ownership types alias types linear types checkers pointer properties :10.1.1.14.663
absence automated analysis programmer application knowledge aliasing 
object immutability 
object modified object read 
example guaranteed instantiation object assigned read exists 
side condition required constructor leak non read object parts 
circumstance rare trivial analysis reveals classes jdk leak read 
object immutability analysis accommodates logging tracing mechanisms retain leak read 
example data structures treated differently different phases program 
example natural graph doubly linked list mutable built may 
simple analysis indicate immutable remain construction 
thread non interference 
threads modify object thread non read object 
escape analysis multithreaded programs indicate escape threads 
cases guarantee may necessary synchronization points critical region may easier program wide analysis 
parameter non mutation 
object passed readonly parameter modified control exits callee long non read aliases object procedure scope thread see 
effectively means object aliased non read parameter global variable 
variation escape analysis indicate object may placed non read global variable 
parameter aliasing simpler general alias problem especially parameters may incompatible types may readonly 
return value non mutation 
object returned readonly result modified outside callee module long object escapes direct application escape analysis 
extension new properties languages presents type system immutability develops context java 
intuition enforced constraints simple type rules implementation cover entire java language 
permits explore type system interacts real world constructs including subtyping inner types exceptions covariant arrays 
experience leads believe approach easy extend languages especially imperative object oriented languages 
primary difficulty language lack type safety loopholes prevent making guarantees type checking 
believe approach combines static type checking dynamic checking necessary appropriate order keep static rules simple understandable programmer extensible properties 
example interesting annotation permits specific clients set variable prohibiting reading value instance seeing written 
common paradigm javari supports particularly augmented type analysis initialization phase followed read phase explicit annotation readonly permitted unlimited reading 
analysis similar typestate analysis 
required validate intuitions indicate limits approach success date encouraging 

type checking rules javari run time behavior java possible run time checks described section 
compile time javari ensures modification objects read similar violations language occur 
section introduces definitions 
section presents type checking rules style java language specification 
technical report contains complete type checking rules 
section gives intuitive explanations treatment inner classes exceptions 
definitions javari types javari type hierarchy extends java including java type new type readonly type readonly just type modify object refer 
formally types javari 
null type null 

java primitive types 

instance 
class interface type representing instance 
arrays 
non null type type representing array elements type 
read types 
non null type readonly type 
convenience exposition define depth base type 
informally depth just nesting depth array type base array type type array dimensions removed 
formally type define depth depth depth depth readonly depth depth null primitive instance base base base base readonly base base read type base readonly readonly base base non read type base null primitive instance readonly object object readonly stringbuffer stringbuffer portion javari type hierarchy includes read non read versions java type 
arrows connect subtypes supertypes 
type equality subtyping equality relation types defined follows 
primitive types null type instances classes interfaces types equal iff java type 

readonly readonly equal iff depth depth base readonly base readonly 

equal iff equal 

non read type readonly equal iff equal primitive instance immutable class interface section 
item implies readonly int readonly readonly int equivalent 
words read array int arrays read array read int arrays 
read transitive property level array marked read lower levels read 
equal types considered type 
interchangeable javari program 
subtyping relationship subtype written defined types 
transitive reflexive closure 
byte char byte short char int short int int long long float float double 

null non primitive type 
classes extends interfaces extends interface class implementing 
non null types 

non read non null type readonly 
non read non null types readonly readonly 
non null type java io serializable object 

non read non null type readonly readonly 
shows example subtype hierarchy 
definitions relating method invocations definitions java presence third clause definition specificity 
definitions rules consider constructors methods specify mean 
compatibility method constructor list arguments 
say arguments compatible declared take parameters type subtype declared type ith parameter specificity methods name constructors class say specific conditions hold 
take number parameters say types 
pn 
qn subtype 
class respectively interface declared subclass declared declared class interface 

read read 
type checking rules programs program type checks top level class interface declaration program type checks 
class interface declarations class interface declaration type checks hold 
conditions holds class interface immutable method inherited superclass static read inherited fields inherited static mutable final read type 
class interface immutable direct superclass direct superinterfaces 

fields name declared body class interface 

methods name signature declared body class interface 
signature includes number declared types parameters method read 

constructors signature declared body class interface 

field method constructor member type instance initializer static initializer declared class interface type checks 
variable declarations field local variable declaration type initializer type checks 
initializer form expression type checks iff assignment expression left hand side type type check 
initializer form 
ik initializers type checks iff readonly type declaration readonly respectively type check method declarations method constructor instance initializer static initializer type checks expression local variable declaration local type declaration body type checks 
expressions expression type boolean property called 
expression type checked recursively subexpressions type checked 
subexpressions type check types type check expression deduce type 
expression type check 
brevity gives type checking rules expressions substantially different java technical report contains complete type checking rules 
assignment rules type checking assignments java assignment expression type check lvalue assignable 
type assignment expression type checks type lvalue expression assignable 
addition java rules type cast cast read type non read type 
type cast expression expression assignable 
mutability mutable type checks 
type non read expression type 
type readonly type expression readonly 
type readonly depth type expression expression assignable 
expression triggers run time checks see section 
receiver static context type check 
non static context type class appears inside non read method non read constructor initializer inside read method readonly constructor type readonly assignable 
containing object name type checks occurs non static context method constructor initializer class name names class inner class 
type expression appears inside read method read constructor case type readonly expression assignable 
instance creation new creation inner class enclosing read read constructors eligible 
enclosing enclosing read constructors eligible 
expression type checks specific accessible eligible constructor compatible arguments class instance creation expression 
type expression readonly enclosing read 
expression assignable 
array dereference type checks integral type type readonly type type expression respectively readonly expression assignable case assignable second 
field access declared type field accessed 
read type field accessed non read field mutable static field type expression type expression readonly expression assignable field mutable static field accessed read 
exceptional case inside read constructor field access expressions fields class constructed assignable 
method invocation 
invoking readonly static read methods eligible 
invoking static methods eligible 
methods eligible 
expression type checks specific accessible eligible method compatible arguments method invocation 
type expression declared return type method 
method invocation expression assignable 
exception throw javari prohibits read exceptions thrown 
technical report describes approaches rejected introduced loopholes type system require complicated analysis provide little benefit 
special rule instance immutable class inside body non immutable superclass type readonly inner classes exceptions previous language level immutability addressed inner classes exceptions 
section explains handle 
provides intuitive explanation javari type checking rules 
inner classes type checking rules guarantee read methods change non static non mutable fields 
inner class feature java adds complexity guarantee 
javari ensure code inside inner class violate immutability constraint 
places inner class immutability violations occur constructor field instance initializer method 
javari type checking rules section prevent violation 
section explains rules way example 
class outer int foo readonly foo change public void foo readonly class local local readonly error changes ok int error changes void bar readonly error changes erroneous local bar declared readonly 
new local bar constructors read constructors see section prevent change 
possibilities change constructor local 
change happen inside readonly constructor inside non read 
constructor local read assignment type check read constructor bodies type check read method bodies field class constructed accessed simple name assignable non read 
hand constructor local read invoked javari allows read constructors invoked read enclosing instance enclosing instance implicitly read inside foo 
initializers read constructor exists class anonymous class constructed read enclosing instance compiler treats instance initializers instance field initializers body read constructor 
second case necessary anonymous constructors implicit constructor considered readonly constructor enclosing instance read 
rule prevents modifications state read enclosing instance initializers inner classes 
methods rule new local type readonly local enclosing instance read prevents modification enclosing instance 
bar declared read assignment inside fail type check 
bar declared read call bar example type check new local type readonly local 
exceptions desire interoperability java jvm complicates javari handling exceptions 
exception thrown throw statement argument read catch statement parameter declared readonly catch statement able change exception state 
javari prohibits read exceptions thrown 
type checker rejects safe uses read exceptions 
restriction far caused difficulty practice see section 
technical report describes approaches rejected introduced loopholes type system require complicated analysis provide little benefit 
key idea underlying approaches wrap exceptions run time special wrapper objects non readonly catch statements catch read exceptions 
javari runs unmodified java virtual machine legacy bytecode files wrapper class subtype throwable java treats specially 
javari readonly throwable supertype throwable see 
reconciling problems possible complicated introduces possibilities error type system implementation provides little practical benefit 

experience section presents experience javari 
primary goal gain qualitative experience key result type system language practical usable effective 
section expands observations 
remainder section provides supporting details experience 
section describes javari programs 
section discusses annotation process 
section categorizes type checking error occurred annotating examples errors category 
section discusses experience generics 
qualitative results type system easy understand 
language design overly constrain programmers fit way 
practicality goals evaluated type system language implementation writing code javari annotating existing java code readonly 
writing code javari provides experience language way programmers 
addition permits greater flexibility working typechecking errors working existing code beneficial annotation existing code provides earlier indication errors 
hand annotation existing code quantifiable possible track time spent annotating problems discovered original code 
permits evaluation javari fits existing practice code written programmers immutability mind coding 
benefits immutability included improving documentation making consistent implementation enhancing understanding programs eliminating errors convoluted code efficiency improvements eliminating copying 
writing code scratch faster easier natural annotating existing code 
effort adding readonly annotations subsumed writing types felt ability specify immutability caused think formally interfaces fewer design implementation mistakes 
annotating existing code difficult particularly code annotated module module relying primarily local reasoning 
bulk annotation effort consumed reverse engineering determining code ought debugging 
minimize disruptive code changes problems worked entirely type system 
javari problems section number rarer java casts worked downcasts unsafe uses required rewriting 
experience led add language features parameterization downcasts 
parameterization feature strictly necessary prevent significant code duplication 
adding parameterization easy task especially parameterized immutability receiver object added identically subclasses class happened class hierarchies 
see section details 
downcast mechanism necessary legacy libraries pre existing design software facts type system 
conclude fully statically enforced immutability type system limited applicability practice 
explicit keyword mutable immutability downcasts critical preventing accidentally leaving java cast place forgetting add readonly type 
cast permitted affect immutability cause javari silently insert run time checks error discovered run time 
feature analysis indicate casts immutability downcasts estimate third annotation errors caught run time 
experience javari convinced immutability sufficient 
rarely able immutable types object immutability possible redesigning programs ground may increased applicability object immutability doing severe performance cost 
contrast immutability enabled reason interfaces program phases 
human reasoning effective implemented type analyses section suspect helped 
experience revealed weaknesses type system 
complex systems transitive immutability may strong constraint 
example swing containers child parent transitive immutability implies container 
swing containers annotated read 
similarly legacy libraries may need access portion transitive state read example see section 
type system support reflection 
problems solved run time checks reduce javari ability help programmers detecting errors compile time 
new code annotated java code java java util javari util ball daikon code size classes methods lines ncnb lines opportunities readonly annotations readonly mutable generics downcast readonly uses local field parameter cast return type method class generics arg code errors documentation implementation bad style javari problems inflexibility reflection annotation errors signature implementation library time hh mm signature implementation type check fix errors programs written javari converted java javari 
number classes includes classes interfaces 
number methods includes constructors 
ncnb lines number non comment non blank lines 
opportunities counts number places readonly appear including primitive types common immutable classes string subclasses number counting multi dimensional array opportunity 
section explains error categories 
section explains time categories 
errors time recorded programs 
javari programs wrote container classes java util package scratch javari gain experience javari javari requires parameterized container classes 
annotated existing java 
javari compiler major annotation experience 
annotation intermixed changes language bug fixes compiler 
sun container classes 
complemented parameterized container classes written scratch annotating additional classes sun jdk implementation 
instance bad coding style see section 
extensible game final project software engineering class mit laboratory software engineering 
designed written months group people included author wrote third code 
daikon tool dynamic detection invariants programs 
annotation performed help programmer previous experience daikon user 
annotation time included time understand large complex system annotate 
annotation process methodology annotating java programs readonly proceeded stages 
stage annotation signature bottom section read documentation signatures public protected methods program marked parameters return types methods readonly 
example documentation method specified method modify parameter marked readonly 
second stage annotation implementation annotate signatures private methods implementations methods 
third stage type check fix errors involved running compiler resulting program considering correcting type checking failures 
annotation experience represents pessimistic upper bound time cost reasons 

programmer familiar code time includes program understanding error diagnosing 

completed code annotated experience indicates effort significantly smaller writing new code programmers design decisions immutability catching errors part cost 

javari system development contained limitations bugs 

recording type checking error message time consuming distracting 

code contained generic types eased process 

mechanical assistance type inference 
despite problems annotation process quick represented small fraction original development time considerably daikon lines hour respectively 
error classifications javari compiler issues error general reasons 
code may erroneous documentation may incorrectly describe 
second javari type system may restrictive issuing error code type check safe run 
third user may error annotation compiler discovered 
classifies type checking error encountered annotating daikon systems lines code non comment non blank lines 
final annotated code passed javari type checker errors 
section describes categorization gives examples errors category 
technical report describes code errors javari problems 
code errors code errors problems original java program discovered annotation type checking process 
errors remained code despite extensive testing example daikon worldwide user base hour long regression test runs nightly 
subdivided code errors subcategories 
documentation subcategory represents errors documentation class public protected method causing incorrect annotation 
example documentation daikon process sample method document second parameter vt mutated side effect 
updated documentation indicate fact 
implementation subcategory represents bugs original code type checking annotated code 
error representation exposure caused method improperly returning private data 
fixed adding readonly return type misbehaving method 
example daikon error method sorted input array computing statistics array 
fixed error rewriting method array copy 
obvious errors lead user visible failures verify error 
bad style subcategory represents type checking failures caused bad coding style 
code causes errors knowledge cause run time failures easily written better style allow code type check program easier maintain debug 
example recalculates size displayed screen paint call 
better alternative type check javari rules recalculate window size changes 
daikon method readonly file file tests file created calling file file delete 
calls fail type check modify file file system 
cleaner adequate purpose test directory containing file writable 
example bad coding style caught type system java util treemap 
class private method takes iterator parameter iterator iterates keys entries map depending value different parameter 
preferable separate code paths different iterators 
javari correct typing iterator parameter 
problem remains java early release java libraries raw parameterized type iterator 
javari problems order guarantee safety type systems tend conservatively reject programs behave proved behave safely 
inflexibility language subcategory represents safe code rejected type system conservative analysis 
omitting readonly annotations adding downcasts rewriting code 
half type system inflexibility problems instances daikon due code form readonly new foo new error array created new typed contain readonly problem fixed rewriting code readonly new readonly foo way prevent problem change language introduce new syntax array constructors foo new readonly example consider code snippet public class private jf private void readonly final jd new jf true dialog box jd get filename constructor shown declared take mutable returns caller needs modify result 
new expression code type check 
method calls jg jd escape method facts type checker static analysis compiler rejects safe code 
fixed problem adding downcasts similarly adding cast java type system 
reflection subcategory represents uses reflection original program 
analysis reflection type system java type systems aware 
reflection permits java code violate accessibility modifiers modify contents string 
dynamic checks section ensure safety presence reflection 
annotation errors category represents mistakes committed annotation process 
usually due code poor documentation 
signature subcategory represents errors due incorrect annotation signature public protected method stage annotation 
implementation subcategory represents errors caused incorrect annotation type private field signature private method type local variable type cast expression 
library subcategory represents errors caused incorrect annotation library method example awt method 
noted section javari provides annotated java libraries 
library annotation time included discovered errors library annotations annotating client code 
generics annotation introduced fairly large amount genericity generics 
uses genericity daikon parameterized types parameterized methods 
parameterization appears external libraries included daikon distribution caused additional genericity uses libraries 
method parameterization type parameters ways return type formal types method type type parameter natural flexible declare immutability variable declaration immutable type javari supports 
furthermore adding type parameter required change client code mentioned type name 
minor point method parameterization resulted code duplication 
genericity converted method type generics reduce number annotations required 

related researchers noticed need mechanism specifying checking immutability 
section discusses proposals differs 
similarly javari jac readonly keyword indicating transitive immutability implicit type readonly class interface defined program mutable keyword 
aspects languages syntax semantics quite different 
example jac provides number additional features larger access right hierarchy readonly writeable additional keywords address concerns immutability 
jac authors propose implementing jac source rewriting creating new type readonly methods methods declared keyword readonly parameter list compiling result ordinary java compiler 
return type method readonly 
example class person method public address readonly readonly person method public readonly address readonly 
words return type method call depends type receiver expression may supertype declared type violates java typing rules 
additionally jac unsound address arrays readonly objects casts exceptions inner classes subtyping 
jac readonly methods may change static field class 
suggests supplying readonly types supplied type variables generic classes change gj proposal 
contrast jac javari return type method depend called readonly non read 
javari obeys java type rules uses type checker preprocessor integrates immutability type parameterization 
additionally implemented javari evaluated usability 
comments explain read interfaces java satisfactory enforcing immutability 
programmer define class interface ro declares readonly methods achieves transitivity changing methods returned say return ro ro replace uses javari readonly similar jac approach shares similar problems 
instance permit casting need implement ro method return argument types incompatible 
furthermore approach allow readonly versions arrays object ro object need implemented object 
forces information class maintained separate files address perform run time checking potentially unsafe operations various java constructs 
take different attitude immutability point view read method protect enclosing object transitive state invoked read necessarily invoked write 
read read method may behave write non read method invoked write construct permits run time checking arbitrary code may appear branches 
suggests proved read modified possible prove method may modify argument 
addition read write system provides context behave differently depending method invoked read write context 
compared jac javari type parameterization adopted java gives ad hoc disciplined way specify families declarations 
functional methods universes pure methods allowed modify opposed merely allowed modify receiver object 
sarkar provide framework immutability specification dimensions lifetime reachability context 
lifetime full scope complete dynamic lifetime object parameter annotations duration method call 
reachability shallow deep 
context immutability applies just method methods 
authors provide instantiations framework show immutability constraints enable optimizations speed benchmarks 
javari permits lifetimes supplies deep reachability complements shallow reachability provided java final keyword 
capabilities sharing intended generalize various proposals immutability uniqueness 
new object allocated initial pointer access rights read write identity permitting address comparisons exclusive read exclusive write exclusive identity ownership giving capability assert rights 
pointer variable subset rights 
capabilities give approximation simplification annotation approaches 
provide type inference determines deep immutability fields classes 
foster provide type inference non transitive const :10.1.1.24.8366
field defined immutable value changes initialization object refers immutable 
object defined immutable fields immutable 
class immutable instances 
analysis context insensitive type mutable objects contain elements type mutable 
libraries annotated analyzed virtual method invocation equals assumed able modify field 
discusses class static variables member variables 
technique apply method parameters local variables focuses object immutability javari 
experiment static fields java jdk runtime library immutable 
implemented tool immutability java tool publicly available comparison 
effect systems specify state terms regions individual variables read modified procedure viewed labeling procedure types additional information type rules manipulate :10.1.1.54.5309
type systems immutability viewed form effect system 
system finer grained typical effect systems operates values considers state reachable 
focus imperative object oriented languages 
languages fields mutable default 
type system type read default field immutable user explicitly marks mutable 
functional languages ml policy default fields immutable 
ocaml combines mutable annotation fields example implemented field mutable record 
notion read types users forced hide mutability interfaces subtyping flexible expressive proposal 
programming language automatically provides sort immutability constraint parameters passed results returned value 
value copied procedure call return original copy modified implementation client respectively 
pass return typically values small 
programming languages pascal ada permit variables explicitly annotated parameters early primitive form compiler enforced immutability annotation 
const const keyword intended aid interfaces symbolic constants :10.1.1.26.9545
motivation similar notion immutability type system differ avoiding pitfalls led java designers omit const 
numerous loopholes const notation provides guarantee immutability accesses const 
unchecked cast remove const variable mis type system weaknesses unions unchecked variable length procedure arguments 
permits contents read pointer modified read methods protect local state enclosing object 
guarantee transitive non mutability object held directly variable pointer 
precludes sharing serious disadvantage 
additionally permits specification const level pointer dereference permit doing level multi dimensional array 
permit parameterization code immutability variable 
contrast javari safe type system contains loopholes downcast dynamically checked 
furthermore differs providing guarantees transitive immutability distinguishing objects differences javari type system uniform usable 
javari permits mutability level array specified permits parameterization mutability variable 
javari supports java features appear nested classes 
experts advocate const example meyers advises const possible 
type systems including java programmers feel need specify types outweighs benefits type checking 
studies static type checking reduces development time errors 
aware empirical evaluations regarding costs benefits immutability annotations 
java programmers eager compiler checked immutability constraints may support const fourth popular java request enhancement 
common criticism const transforming large existing codebase achieve const correctness difficult const pervades code typically codebase annotated 
propagation effect unavoidable types externally visible representations changed 
inference const annotations implemented foster see developer java sun com developer top html :10.1.1.24.8366
third popular requests generics covariant return types addressed java language second popular request provide documentation chinese eliminates manual effort 
type inference annotation greatly eased fully annotating part code turn thinking contract specification inserting partial annotations attempting address type checker errors time 
proper solution course write const annotations code takes little extra 
criticism const occasionally lead code duplication versions standard library 
immutability parameters section need duplication rare javari 
type casts section permits programmer soundly problems annotating large codebase code duplication 

type system capable expression compile time verification run time checking immutability constraints 
immutability guarantees perform modification transitively referred object 
type system generally applicable object oriented languages concreteness context javari extension full java language 
implemented language experience non trivial javari programs 
evidence suggests language designer budget terms new language features limited immutability worthy serious consideration investigation 
goal produce complicated subtle new type system solution important problem unsuccessfully 
components approach previously appeared literature 
synthesized pieces novel way resulting simple effective approach 
contributions include 
chose practical effective combination language features 
instance describe type system object immutability 
immutability useful circumstances specifying interfaces objects immutable 
proposed set type analyses run type checking order stronger guarantees enable verification transformation 
example show guarantee object immutability 
type analyses require limited aliasing information usually simple escape alias analysis suffices arbitrary alias analysis may 
combined compile time run time checking create effective practical safe system 
system detects violations immutability constraints compile time absence immutability downcasts 
programmer chooses downcasts essential interoperability legacy code express application invariants efficient runtime checking modification points catches unsafe uses permitting safe ones 
provided safe type system transitive immutability context full real object oriented language java model subset 
simple see ideas apply idealized toy language nontrivial support real language wrinkles 
success indicates system comprehensible usable practice 
syntax semantics javari backward compatible java java virtual machine 
java javari code call safe manner 
compatibility interoperability java eases transition languages developers continue existing libraries adopt pay go strategy annotating code immutability constraints 
javari faithful spirit java feels java introduces run time checks result constructs result java run time checks 
provided implementation evaluation transitive deep immutability context safe language 
experience lines javari code demonstrates syntax rules checking workable practice 
user unfamiliar line program able annotate quickly discover errors 
study provides insight errors users absence javari features 
javari revealed dozen real errors tested code 
benefits especially reducing wasted time clarifying specifications potentially greater javari development cycle fact 
guarantee immutability improve documentation find errors expose problems 
acknowledgments implemented prototype run time checking system 
grateful adam chandra boyapati craig chambers walter tichy anonymous referees helpful comments draft 
supported part nsf ccr gift tibco software 
aiken foster 
checking inferring local non aliasing 
proceedings acm sigplan conference programming language design implementation pages san diego ca june 
aldrich chambers 
alias annotations program understanding 
object oriented programming systems languages applications oopsla pages seattle wa usa oct 
bacon sweeney 
fast static analysis virtual function calls 
conference object oriented programming systems languages applications pages san jose ca usa oct 

compiler enforced immutability java language 
technical report mit lcs tr mit laboratory computer science cambridge ma june 
revision master thesis 
bloch 
effective java programming language guide 
addison wesley boston ma 
boyapati liskov shrira 
ownership types object encapsulation 
proceedings th annual acm sigplan sigact symposium principles programming languages pages new orleans la jan 
boyland noble 
capabilities sharing generalisation uniqueness read 
ecoop object oriented programming th european conference pages budapest hungary june 
bracha odersky stoutamire wadler 
making safe past adding genericity java programming language 
object oriented programming systems languages applications oopsla pages vancouver bc canada oct 

choi gupta serrano sreedhar midkiff 
escape analysis java 
object oriented programming systems languages applications oopsla pages denver colorado nov 
dean grove chambers 
optimization object oriented programs static class hierarchy analysis 
ecoop th european conference object oriented programming pages aarhus denmark aug 
ernst cockrell griswold notkin 
dynamically discovering program invariants support program evolution 
ieee transactions software engineering feb 
previous version appeared icse proceedings st international conference software engineering pages los angeles ca usa may 
evans 
static detection dynamic memory errors 
proceedings sigplan conference programming language design implementation pages philadelphia pa may 
fahndrich deline 
adoption focus practical linear types imperative programming 
proceedings acm sigplan conference programming language design implementation pages berlin germany june 
foster fahndrich aiken :10.1.1.24.8366
theory type qualifiers 
proceedings acm sigplan conference programming language design implementation pages atlanta ga may 
foster aiken 
flow sensitive type qualifiers 
proceedings acm sigplan conference programming language design implementation pages berlin germany june 
gannon 
experimental evaluation data type conventions 
commun 
acm aug 
gosling joy steele bracha 
java language specification 
addison wesley boston ma second edition 

jac access right encapsulation java 
software practice experience 
leroy 
objective caml system release sept 
damien doligez jacques didier remy jerome vouillon 
lucassen gifford 
polymorphic effect systems 
proceedings fifteenth annual acm symposium principles programming languages pages san diego ca jan 
meyers 
effective 
addison wesley second edition 
milner tofte harper 
definition standard ml 
mit press 
morris 
type checker experiment 
experiment xerox parc 
personal communication may 
muller poetzsch heffter 
universes type system alias dependency control 
technical report hagen 
nielson nielson 
type effect systems 
olderog steffen editors correct system design number lecture notes computer science pages 
springer verlag 
palsberg 
type analysis applications 
acm sigplan sigsoft workshop program analysis software tools engineering paste snowbird utah usa june 
park goldberg 
escape analysis lists 
proceedings sigplan conference programming language design implementation pages san francisco ca june 
sarkar 
immutability specification applications 
joint acm java grande conference pages seattle wa nov 
mendelson 
automatic detection immutable fields java 
cascon ontario canada nov 
prechelt tichy 
controlled experiment assess benefits procedure argument type checking 
ieee transactions software engineering apr 
rinard 
pointer escape analysis multithreaded programs 
proceedings th acm sigplan symposium principles practice parallel programming pages snowbird utah june 

mode system read java 
rd workshop formal techniques java programs budapest hungary june 
revised 
strom yemini 
typestate programming language concept enhancing software reliability 
ieee transactions software engineering se jan 
stroustrup :10.1.1.26.9545
programming language 
addison wesley boston ma special edition 

talpin jouvelot 
type effect discipline 
proceedings seventh annual ieee symposium logic computer science pages santa cruz ca june 
wadler 
linear types change world 
ifip tc working conference programming concepts methods pages sea israel apr 
