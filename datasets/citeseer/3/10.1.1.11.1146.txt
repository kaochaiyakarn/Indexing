low level linear memory management chris hawblitzel edward wei heng huang eric lea efficient low level systems need control memory safe high level languages usually provide 
result run time systems typically written unsafe languages extends previous linear types alias types regions typed garbage collection give type safe code control memory 
approach truly low level memory consists single linear array words load store operations built notion object 
constructs lists arrays basic linear memory primitives introduces type sequences building regions nonlinear data 
describes cheney queue typed garbage collector implemented safely regions 

modern computers rely correctness security low level systems garbage collectors device drivers embedded system code 
small amount lowlevel code say firewall network interface device driver secure coprocessor stands computer system hacker trying break system 
absence malicious outsiders buggy device drivers cause annoying system crashes 
role foundation higher level services expect low level systems benefit static run time checks provided type safe languages 
systems programmers usually lean assembly language java ml haskell need efficient low level control memory 
java array bounds checking example prevents buffer overflow attacks programs susceptible imposes extra run time overhead 
automatic garbage collection prevents dangling pointers implementing garbage collector requires ability explicitly free heap objects privilege usually granted safe language programs 
extends previous linear types alias permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
copyright acm xxxxx xx xx xx 
department computer science dartmouth college types regions typed garbage collection give typesafe code control memory 
models memory linear array words indexed integer memory addresses 
linearity prevents aliasing store operations change type memory word danger subsequent load operation reading word wrong type 
support integer addressing type system includes arithmetic singleton types style xi :10.1.1.36.3970
extends basic tools coercion functions essentially proofs modify types values type sequences introduce nonlinearity system imposing specific memory management strategy nonlinear data 
sufficient implement region memory management garbage collection :10.1.1.23.5498:10.1.1.1.3704
demonstrate practicality ideas developed safe language called clay implements type system type inference static detection possible bit integer overflow 
clay type checker uses omega test software modified support arbitrary precision arithmetic check arithmetic constraints :10.1.1.36.9420
type checked code compiled 
examples including garbage collectors run time system code included clay distribution focusing specifics clay presents type system part machine called low standard call value higher order polymorphic lambda calculus may strange describe low level operations highlevel lambda calculus framework generality lambda calculus allows apply ideas low settings 
example closure converted subset low mimics languages clay cps closure converted subset low mimics register transfer languages assembly languages 
believe low type system contribute development systems proof carrying code pcc typed assembly language tal :10.1.1.24.6526:10.1.1.142.6054
systems run untrusted code directly trusted computer particularly sensitive bugs vulnerabilities run time system considerable focused moving memory management trusted computing base tcb pcc tal 
ambitious effort reduce tcb foundational pcc attempts build entire pcc tal system small number axioms 
linear memory types simple available www cs dartmouth edu low level model memory may suitable foundational pcc systems 

background draws previous research typed memory management including linear types alias types regions typed garbage collection 
section provides brief background techniques 
primary obstacle type safe memory management dangling pointers pointers deallocated memory 
presence aliasing multiple pointers object difficult prevent dangling pointers 
simplest strategy safe deallocation disallow aliasing completely data structures trees arbitrary graphs object pointer type system ensure safety invalidating pointer object program deallocates object 
terminology linear types pointer object consumed dies 
example variable contains pointer expression deallocate removes scope rest program subsequent fails type check 
pure linear data structures implemented lisp designed typed assembly language tend clumsy practice 
useful data structures circular doubly linked lists aren linear 
linear data structures useful operations data violate linearity 
example purely linear program traverse list simultaneously holding pointer head list result pointers list 
result programs extra copies data structures copy pointer data structure 
alias types allow limited forms aliasing prohibiting aliasing completely program express nonlinear data structures :10.1.1.1.5638:10.1.1.1.3318
alias types describe current state set objects constraint 
example constraint int int int int int indicates distinct objects memory locations pair integers triplet integers 
allocation deallocation loads stores alter state current constraint 
example storing floating point number second element produces new constraint int int int float int 
constraints treated linearly old constraint consumed new constraint produced prevents program trying second field integer changed float 
contrast pure linear types program may keep pointers simultaneously type nonlinear may freely copied 
linearity constraint ensures pointer value respects current state 
alias types flexible pure linear data types linear constraint disallows nonlinear data structures nonlinear operations data 
practice allowed data structures linear look linear data augmented carefully specified extra pointers 
example walker express circular list singly linked list plus special pointer tail head :10.1.1.1.5638:10.1.1.1.5638
authors standard operations circular lists traversing list circle head tail back head 
extend power linear alias types adding sophisticated ways control aliasing see shape types example programming languages allow unrestricted pointer aliasing heap compiler standard source programming language typed assembly language proof carrying code deal unrestricted aliasing 
strategy allow arbitrary nonlinear data inside region lifetime controlled linearly linearly :10.1.1.23.5498:10.1.1.23.5498:10.1.1.1.3704:10.1.1.1.3704
pointer object inside region assigned type describes data inside loads stores value type correct alive 
destroyed objects deallocated 
deallocation individual objects inside live region usually disallowed arbitrary aliasing possible inside region means individual object deallocation leave dangling pointers 
program trivially rewritten take advantage regions simply create big region allocate objects region keep region alive program finishes 
usually efficient strategy automated inference manual region management necessary break data smaller regions program deallocate soon possible minimize memory consumption :10.1.1.23.5498
wang appel observed program copy live data region second region deallocate region effectively constructing copying garbage collector written entirely type safe language features 
typed type preserving collector offers generality traditional garbage collection requiring collector trusted 
unfortunately details copying process troublesome collector needs way traverse data needs maintain forwarding pointers old region new region 
solutions problems proposed new proposal changes typing rules regions ad hoc complex ways 
furthermore resulting collectors unable low level techniques common collectors written goal develop regions ground starting combination linear alias types order provide stable flexible safe lowlevel platform constructing typed garbage collectors 
rest follows section introduces core language manipulating linear memory 
includes basic function tuple polymorphic recursive types plus linear memory types integer arithmetic types 
types sufficient implement basic recursive linear data structures 
section extends language coercion functions add flexibility data types section 
stack type section array type example 
section describes combine nonlinear functions linear memory types implement primitive regions nonlinear data 
language extensions required technique allow regions grow dynamically region data allocated region allocated 
section introduces new language feature called type sequences regions section grow new data allocated 
type sequences somewhat ad hoc section describes encode type sequences elegant language extension called delayed types 
section shows build simple cheney queue copying garbage collector regions section 
linear memory section describes syntax semantics low core language clearer delay couple features coercion functions type sequences sections 
type checking rules expressions appear complete syntax semantics low 
portion language described subsection type environments needed typecheck expression maps variables types maps integer memory word addresses types 
convenience write combined context defined subsection 
notation indicates share nonlinear assumptions linear assumptions appears 
notation denotes context linear assumptions 
state running program consists memory maps integer memory word addresses word values expression evaluation rules describe machine state steps new state 
load store expressions expressions read modify region garbage collection examples built entirely top simple loads stores 
expressions values types defined follows kinds integers booleans defined section types mem int bool expressions op pack unpack roll unroll fix load store ev fact values pack roll fact types borrowed languages discussed 
new type linear memory type mem loosely alias types 
discussed previous section alias types maintain linear context maps locations types 
alias types deliberately away details objects allocated memory memory objects reside context locations opaque abstractions integers 
linear memory types hand designed implement object allocation ground expose details underlying memory 
mapping opaque locations types linear memory types map integer word addresses types individual memory words 
objects reside memory locations distinct mappings describe state objects examples require advanced features alias types explicit store polymorphism nonlinear constraints 
easiest express type memory word individual firstclass linear value member constraint set 
traditional linear data structuring mechanisms suffice hold types multiple memory words 
example memory location described object linear type mem state pair integers locations stored linear tuple type mem mem walker type system includes non linear linear functions nonlinear lin ear tuples indicate linear data indicate nonlinear data 
linear functions called exactly nonlinear function called arbitrarily 
linear tuples consumed fields extracted 
linear data structures may hold nonlinear data linear tuple type containing empty nonlinear tuples legal nonlinear data structures contain linear data nonlinear tuple type containing empty linear tuples illegal ensures linear data aliased 
enforce restriction assign kinds types distinguish linear nonlinear types 
kind describes linear types size words describes nonlinear types size words 
example nonlinear empty tuple type kind 
kind restrict operations memory values stored memory exactly word long 
type singleton booleans bool kind example boolean value fits word memory 
triplet booleans type bool bool bool kind large fit single memory word 
kinding rules tuple types linear memory types illustrate size linearity rules data environment explained nj nj nj nj int mem type mem kind linear occupies space 
operations memory consume values type mem produce new values type mem times exactly value type mem memory location example function swaps words memory consuming pair values type mem mem producing pair values type mem mem mem mem load load store store type mem expression load consumes longer scope remainder function produces pair element contains contents memory word second element type mem 
typing rule expression load requires argument singleton integer type int second argument type mem 
int mem load mem usual type int set integers singleton type int set containing integer integer constant type int int load expression int mem match load type checks example load type check 
expression store consumes produces value type mem documenting change type value memory word mem ev int store ev mem notice store expression overwrites value previously memory location load expression copy value memory 
nonlinear values may discarded copied type mem legal nonlinear 
examples show manipulate values type mem leave question unanswered exactly value type mem 
syntax machine defines special value fact sort universal unit value types mem 
fact value carries run time information represented real machine 
type checking rule states fact typed current context contains exactly linear assumption saying memory location holds value type fact mem integer boolean polymorphism swap function described earlier works fixed types particular memory addresses 
type system allows polymorphism base types kind integers kind int booleans kind bool type operators kind swap function rewritten type int int int int mem mem mem mem approach xi singleton integers type int int word run time representations integer types :10.1.1.36.3970
avoids need full blown dependent types type system needs deal subset integer arithmetic solved easily standard constraint solver universally quantified variables addition subtraction comparison multiplication constants 
symbol refer integer types symbol refer boolean types legal boolean type int legal singleton integer type run time representation integer type 
arithmetic true false iop bop cmp iop bop cmp op iop bop cmp addition universal polymorphic type type system supports existential polymorphic types 
example type int int type singleton integer unknown integer type imitates traditional type int type integers 
example type int 
int mem mem says unknown integer address words type stored provides singleton integer int needed load store memory addresses type imitates pointer pair 
universal existential polymorphic types may contain constraints satisfied types substituted type variables 
example swap type int int 
swap 
legal swap 
illegal 
type checking body swap function fact kept inside environment kinds type variables kept environment combined type checking context type equivalence xi approach define integer types equivalent constraint solver show substitutions integer constants integer variables types simplify equal integer constants 
example type system considers equivalent 
language contains types interact gracefully xi approach type operator application polymorphic data types conditional type create unions conceivably types kind int may substituted integer variable inside integer type typechecking type checking rule type application performs sort substitution instance 
happens constraint solver may faced integer type int difficult deal 
valued convenience xi approach implementation examples resort hack kind system kinds int bool appearing return type type operator int integer boolean types contain operator applications type system disallows conditional types having kind int bool kinds int bool ka jb ka ka jb ka jb ka jb bool type kind restrictions place type equivalence rules type application conditional types longer interfere type equivalence rules integers booleans true false typed assembly language proof carrying code system sense require program provide proofs arithmetic equivalence fundamental arithmetic axioms rely constraint solver case wouldn need hack kind system 
technical report uses different type unions requires explicit programmer annotation order simplify implementation type inference algorithm 
conditional type elegant essential section delayed types 
recursive types lists stacks described earlier existential type int 
int mem mem imitate pointer data memory 
idea combined recursive types type system powerful express pointer data structures style recursive alias types :10.1.1.1.5638
example type defines simple linked list terminated containing data elements type list int int int 
mem int mem clarity ll symbol define data types machine official cryptic recursive type list int int 
mem int mem list type equivalent true false list type contains empty tuple word tuple non zero 
words tuple assert memory locations contain values type int pointer element data current element 
int just arbitrary integer mem type list may load fields list element 
approach language easily supports tree data structures 
example free lists lists free lists various size objects provide simple memory management strategy linear data 
allowing simple integer arithmetic type system expresses just traditional link structures 
example slight modification linked list example produces stack type held contiguous sequence memory locations 
stack int int mem stack 
coercion functions previous section stack type fine simple pushes pops support constant time random access middle stack 
getting middle stack hard program unroll data type times get nth element performing tuple extractions unroll 
machine operations required obvious way perform constant time access inner element 
unroll operations tuple extractions size zero data aren supposed impose run time cost purely compiletime coercions 
needed way combine coercions single time operation 
suppose expression satisfies constraints effect memory evaluates value value type size guaranteed terminate evaluating value finite time reason execute real machine compiler simply erase way erases pack unpack roll unroll coercions compiling typed code untyped machine language code 
expression perform coercion operations traversing stack data structure retrieve mem value deep inside stack run time cost expression erased compiler 
example consider data type arrays int int int type similar stack type extra flexibility polymorphic operator array element data different type 
coercion function splits array adjacent arrays left containing elements 
right containing elements 
fix split split int int int int 
arr roll arr head tail unroll arr left right split tail roll head left right split int int int 
int case left array empty right array array 
function pops head array recurses pushes head back left array returned recursive call 
compiler omit call coercion function run time know satisfies conditions stores memory return type size definite termination 
language supports integer arithmetic easy heavy handed way ensure termination annotate type coercion function limit nonnegative integer limit limit int limit limit type system allows coercion functions call functions lower limits limit 
recursive call legal caller limit indicated annotation called function split limit smaller 
current limit stored context definition extended limit limit integer type coercion functions symbol normal functions usually omit annotation function types 
context integer limit expressions allowed store memory loads allowed 
split function performs unrealistic operation tests see type variables equal 
intentional type analysis problematic compiler implement ordinary functions types erased run time won available run time equality test 
coercion functions won executed runtime language lets boolean type test expression 
extensions low coercion functions limit types 
expressions limit 
limit coerce values 
limit easy define coercions type combining adjacent arrays single array constructing deconstructing empty arrays constructing deconstructing single element arrays 
coercions suffice implement familiar operations get set array elements 
example expression type int mem describing array elements type stored memory words element array accessed splitting array arrays retrieving mem fact single element array performing load store memory word recombining arrays original array 
viewed perspective courtesy curry howard isomorphism split function takes proof argument say proof memory words contain values type returns proofs result 
language coercion functions strongly normalizing proof language happens look similar original programming language 
machine clay differences proof programming languages treatment stores disallowed proof language intentional type analysis disallowed programming language function calls restricted proof language 
similarity advantage programmers need learn second language implement proofs programming proof languages interact seamlessly 
hand specialized dedicated proof language elegant powerful amenable automated proof generation tools easier connect existing libraries proofs 
ltt system example embeds lf proofs separate programming language :10.1.1.21.5854
tl system embeds proofs programs 

nonlinear data structures previous sections described types linear data structures linear lists linear arrays 
sections describe extensions type system building regions nonlinear data structures 
interestingly extending type system linear memory types express nonlinear data structures 
consider code creates circular list elements calls function get th list element splices list struct list struct list struct list nth int struct list return return nth struct list struct list struct list nth code creates unpredictable aliases thwart direct representation list alias types linear memory types 
making list linear type encode list nonlinear function fetches data linear area memory represented type 
linear area memory acts region nonlinear type list acts nonlinear pointer region type list standard region terminology 
long stays list value load store region list int 
int mem list mem list list value contains singleton integer int address list element 
get data list element program calls nonlinear function type mem list function consumes linear region returns linear memory type describing list element data example element contains word field 
linear memory type program free load store element data 
finished loading storing calls linear mem list function relinquish linear memory type reconstruct region 
mem list function list manipulates linear data linear merely middleman passes linear data back forth region program 
list type nonlinear program freely copy discard lists 
example implementation function nth nth fix int int list list 
int int list getnext nth function low similar implementation takes third argument type returns desired list element tuple function terminates 
value needed load field list implemented helper function getnext list unpack unroll yf mem zf yf mem load mem zf mem getnext function extracts list address list function yf called yields linear memory value mem type mem list 
address linear memory value getnext loads field memory returns linear value 
easy define function way store load list unpack unroll yf mem zf yf zf store mem list functions code nth implemented function fifth list nth remains allocate initialize circular list 
need concrete type choose type describes words memory addresses containing list 
call type hree hree mem list hree mem list hree mem list hree create list type list hree need build pair address function 
start address corresponding object code roll list hree pack fb int 
int hree function fb extract mem list hree value hree value return value function reconstructs original hree value fb hree mem list hree similar way construct value address value address 
implement code initialization store operations assuming memory words initialized arbitrary junk types overwrite mem mem mem store store store fifth hree chose example single minimal list type simplicity 
techniques extend complex data types mixtures data types 
consider type struct ltree struct list list struct ltree left struct ltree right represented lt ree int 
int mem mem list mem lt ree mem lt ree mem mem 
type sequences regions previous section encoding nonlinear data structures regions suffers serious limitation regions grow dynamically 
suppose wanted add fourth list region defined hree 
need change region type hree hree mem list hree mem list hree mem list hree mem list mem list mem list mem list unfortunately type hree embedded types existing lists 
clear coerce list type list hree type list 
section combines intuition previous section encoding new language mechanism called type sequences encode regions grow dynamically 
type sequences allow program refine existing type run time list type list stays valid refined program add new data region needing coerce old data different type 
need careful notion type refinement changing existing type arbitrarily certainly unsafe 
start leaving hole type mem list mem list mem list specify hole particular type mem list long don try specify different conflicting ways 
linearity ensure hole filled 
encoding regions obvious start extending type system support just individual holes infinite vectors holes 
show simplify type system encoding vectors holes individual holes 
define type sequence infinite vector holes filled time order 
example type sequence specified followed 
key properties type sequences large dynamic namespace supplies unbounded number names types grows run time new elements added sequence 
type assigned name refer type 
properties define region mapping memory words elements type sequence int mem filled region array grows include linear memory types mem 
extensions low type sequences types 
gen eq indomain expressions 
eq apply eq new seq discard seq define seq domain extensions low handling type sequences shown 
define equality type eq value type eq evidence equivalent 
eq expression creates new equality value type eq type expression apply eq ef uses equality value type eq substitute selected locations inside type ef effectively coercing ef different equivalent type eq eq eq ef apply eq ef new seq expression creates new type sequence kind int non integer non boolean kind new seq int gen allocation new types sequence controlled size zero linear generator type gen 
expression define seq type gen adds new type sequence 
consumes old generator returns values size zero new generator type gen nonlinear proof type eq nonlinear proof domain sequences grow don shrink type indomain 
gen int define seq gen eq indomain eq type substitute vice versa apply eq ef expression described 
indomain type combined current generator type gen produces evidence useful index array length int int indomain gen domain know gen know abbreviation bool program finished adding elements sequence may discard seq expression discard linear generator gen discard seq nonlinearity eq indomain values basis building nonlinear data structures 
suppose region consists single block memory starting address base containing size words clarity ll italicized capitalized letters words type variables greek letters 
nonlinear pointer type region triplet type int base eq indomain region contains array linear facts type mem base region int base int alloc int size int gen alloc alloc int mem base alloc size int free free mem base element region tuple sequence generator second array allocated memory grows time third array free memory shrinks time 
region pointer loading pointed word consists steps indomain value pointer gen alloc value region conclude alloc 
known bounds alloc 
array element array type mem base load value type 
call loaded value eq value pointer says coerce type type 
storing word follows similar sequence steps 
notice middle step array element perform load similar operation performed getnext function previous section approaches temporarily borrow linear memory type region load return linear memory type region 
new allocation region grows region allocation array shrinks region free array 
program done region merges allocation array back free array connection memory types lost 
pointer types int base eq indomain legal types mem base facts allocation array longer useful 
point program free array allocate objects 
particular free array create new region place old region 
possible continue old generator appending new types old sequence easier discard old generator create new sequence new generator 
machine environment tracks state set type sequences grows new sequences allocated 
sequence assigned identifier acts type operator kind int ki 
little slippery exactly sequence machine point state precisely sequence identifier type operator type variables region example may bound sequence identifiers 
new final machine environment defined limit 
tricky point ki suffice type check gen expressions linear expressions containing type operator may nonlinear 
gen expression valid context 
proofs theorems preservation steps progress true limit value steps strong normalization true steps value finite number steps erasure true limit steps erase steps erase zero steps ii erase value steps erase erase zero steps iii erase steps erase erase steps steps erases erase erase 
definition erase erases types calls coercion functions just real clay compiler 
delayed types type sequences sufficient implement regions complicated ad hoc 
section shows type sequences implemented simpler constructs 
adding types eq gen indomain type system directly section builds types single new type delayed 
encodings section reimplemented regions clay relying built eq gen indomain types 
easy emulate eq type coercion functions 
encoding eq functions swierstra write apply eq eq eq apply eq eq eq drawback encoding coercion function returns size zero values apply eq act arguments type kind 
practice minor inconvenience 
example apply eq modify type word value loaded region previous section new region implementation uses apply eq modify type mem base value mem base performing load 
implement gen indomain types introduce delayed types implement individual holes infinite vectors holes 
new expressions needed create delayed type creating new hole named fill hole specifying fact equal new type extensions low delayed types types 
delayed expressions 
delay type specify type ef kinding delayed typing delay type delayed delayed ef specify type ef delay type expression similar new seq specify type similar define seq 
note specify type consumes delayed argument separate expression needed discard delayed values 
furthermore specify type substitutes directly relying eq apply eq 
consider type sequence grows include types 
delayed types emulate series functions defined 
function fi fills element type sequence defers rest sequence function fi 
result function fulfills obligations type sequence don specify specification function fi delayed known 
implementation idea implements gen call int int fn int delayed fn int eq fn particular describes state fn specified 
fn specified know 
fn fn fn invariant maintained coercion function returns eq fn suppose exists want add sequence producing value eq value 
allocate new delayed type delayed fn consume old value delayed fn specifying fn int fn definition immediately implies eq fn 
invariant eq fn implies eq fn combine eq values conclude eq 
definition fn implies eq fn fn 
know eq fn combine eq values conclude eq fn 
delayed fn value gives value type 
gen supports feature lacks sequence extension expression returns gen eq values indomain value essential region encoding 
implement define gen type uses values handle type sequence dedicated producing indomain values 
functions defined indomain int int int int int value evidence types specified types unspecified 
indomain value evidence specified way construct value unspecified type 
logically conclude value indomain value range specified unspecified 
conclude type system program derives expression 
known true 
known true leads contradiction lets specify way wants making defines eq holds 
lets change type indomain value suddenly holds contradiction value type prove including prove note contradiction mean type system unsafe simply means evaluated expression form true derive contradiction assumes true false harmless run time executed 

simple copying collection low type system implement typed garbage collectors including incremental marksweep collector polymorphic copying collectors 
collectors follow ideas wang adds new improvements copying collectors genuine cheney queues collection state stored space 
contrast previously described typed garbage collectors collectors need auxiliary stack implement recursive descent live data 
approach wang requires heap monomorphic type imposes inefficiencies compiled code 
approach uses intentional type analysis handle polymorphism leaves subtle inefficiency collector collector perform run time analysis processing pack unpack roll unroll expressions 
addition sort run time tag bits tag words identify existentials rolled types 
low hide operations inside coercion functions impose run time space time cost 
collectors supports cyclic data structures correctly handling mixtures pointers may null pointer types don allow null 
collectors data layout tag information explicit bit 
demonstrates possible implement efficient representations header words forwarding pointers typed collector 
information collectors including complete implementations clay available wei url www cs dartmouth edu 
technical report contains translation cps closure converted intermediate language developed typed assembly language morrisett low copying collectors memory management :10.1.1.24.6526
provides translation variant girard system polymorphic lambda calculus forms complete translation high level polymorphic language low details collectors scope brevity sake section describes simple monomorphic cheney queue typed garbage collector regions previous section 
cheney queue collector starts root pointer region memory space breadth traverse data reachable root 
collector blindly copies traversed object tospace region object contains pointers point space goes back fix pointers space objects points space objects 
live data traversed collector deallocates space region collection allocates new space region usually just old space region recycled 
ideally type pointer space say points object space type pointer space say points object space case object need concern region 
unfortunately blind copy leaves temporary objects space cheney queue pointing back space 
furthermore collector tags copied space object forwarding pointer space won attempt copy object 
pointers space space vice versa type object aware region previous regions 
equip objects information multiple regions build type sequence type sequences outer type sequence contains type sequence region number supposed stand epoch describes ith word memory region number region space space object name type ith word space type 
add flexibility word descriptor type operator takes region number argument type word stored region word configured extra information extra information describes types pointers contained object object lives region point different region captures state objects cheney queue copied region point region 
type region contains arrays finished objects point region cheney queue objects point region free space 
kr int scan int alloc int gen alloc scan int mem addr scan alloc int 
mem addr alloc size int 
mem addr kr int int int types get complicated introduce simplifying assumption regions size size numbered regions memory words base base size odd numbered regions memory words base size 
base size 
base previous definition regions changed addr base size mod type language doesn contain mod operator real clay implementation collector uses variables elo form region number elo elo 
add clutter little illumination presentation uses just single variable simple collector section supports object type defined contain forwarding pointer floating point data field possibly null pointers 
type describes nonlinear type words object kr int int ord gcf wd ord gcp rim float ord gcp tr ord gcp tr ord kr int int int eq indomain abbreviation ord describes type single word region type type operator int takes region number argument 
non pointer data types float argument irrelevant operator returns type gcp rim int pointer types hand identify region containing pointed object gcp tr kr int int 
int addr addr non null pointer pair singleton integer containing real memory address target object describing state target object 
null pointer just singleton integer int 
forwarding pointers just ordinary pointers point region gcf wd kr int gcp tr garbage collection starts space entirely free 
suppose space region number space region number root space pointer points words 
region 
root pointer type gcp tr space linear facts mem addr gcf wd 
mem addr gcp tr collector copies root object space load store expressions root object goes front cheney queue words 
region mem addr gcf wd 
mem addr gcp tr types words space initially exactly types space collector really perform blind copy space 
mem fact mixture region number region number space linear array takes care mismatch scan alloc int 
mem addr point scan alloc type sequence defined gcf wd 
gcp tr collector constructs sequence turn form space pointer type gcp tr 
space root object forwarding pointer type gcf wd equivalent gcp tr allowing forwarding pointer point space object 
collector starts scan cheney queue shifting words cheney queue linear array finished object linear array 
finished object linear array uses facts form mem addr mem addr collector way convert value type value type collector sets forwarding pointer null store operation easy build null pointer region number 
float value collector merely observes mem addr gcp rim float equivalent mem addr gcp rim float gcp rim ignores region number argument 
loads stores necessary 
pointers collector convert gcp tr gcp tr 
exactly problem collector solved copied root object 
collector just blind copy space objects gcp tr pointers point 
collector continues scanning copying cheney queue empty 
progresses keep track types objects cheney queue repeatedly pop front object queue process 
fact queue full objects size words stored nonlinear array type scan alloc int exactly nonlinear holds nonlinear size elements 
case mod machine doesn division operation simplifies presentation 
real clay implementation changes definitions scan alloc object indices word offsets multiplies compute word offset dividing compute object index 

related previous section compared collectors typed garbage collectors 
particularly close low level second region calculus collector 
region calculus extends ordinary regions type operator program updates linearly run time types object filtered type operator 
linear control type operator similar way linear arrays control types words region 
linear tal shares goal building memory management system low level linear memory primitives 
approach uses copying transform nonlinear data linear data eliminating aliasing approach maintains aliasing nonlinear data 
purely linear data doesn need tracing garbage collector type system need complicated implement type safe collection 
hand data copying imposes steep run time cost 
separation logics share goal techniques derived linear logic describe data structures 
add expression low deduces value type mem value type mem exist simultaneously similar axiom develop usable linear circular list type 
birkedal separation logic prove correctness simple cheney queue copying collector 
approach describe intermediate state collector linear invariant partitioned scan scan alloc alloc size portions space 
approach track changing state space 
integrated verified collector richly typed programming language may require separate proof typed expression type maintained collector reorganizes heap 
walker explores variant separation logic describes memory location adjacency treating locations integers 
interesting see low clay code rewritten adjacency rules integer arithmetic rules 
igarashi kobayashi developed hybrid memory management strategy combining garbage collection linear data 
collector written safe language focus making sure linear data deallocation traditional garbage collection interfere 
petersen assume existing garbage collector ordered variation linearity expose memory allocation process high level programs safe way 

demonstrated linear types augmented support simple arithmetic types coercion functions type sequences delayed types sufficient express variety type safe data structures ranging simple lists cheney queues nonlinear objects 
issues remain 
low forces programs contain explicit coercions pack unpack split combine type equality coercions set simple loads stores making programming tedious 
second proof language hack isn clear replace 
particular re concerned recursive types type sequences invalidate strong normalization property typical proof language curry howard correspondence 
hand nonlinear data structures section rewritten recursive types achieve regions recursive types type sequences 
acknowledgments authors fred smith anonymous reviewers comments various drafts 

amal ahmed david walker 
logical approach stack typing 
acm sigplan workshop types language design implementation 
andrew appel 
foundational proof carrying code 
logic computer science 
arthur doaitse swierstra 
typing dynamic typing 
international conference functional programming 
henry baker 
lively linear lisp look ma garbage 
acm sigplan notices 
birkedal smith reynolds 
local reasoning copying garbage collector 
symposium principles programming languages popl 
james cheney greg morrisett 
linearly typed assembly language 
technical report department computer science cornell university 
karl crary joseph 
expressive scalable type theory certified code 
proceedings seventh acm sigplan international conference functional programming pages 
acm press 
karl crary david walker greg morrisett :10.1.1.1.3704
typed memory management calculus capabilities 
proceedings th acm sigplan sigact symposium principles programming languages pages 
acm press 
pascal fradet daniel le metayer 
shape types 
proceedings th acm sigplan sigact symposium principles programming languages pages 
acm press 
hamid shao trifonov ni 
syntactic approach foundational proof carrying code 
proc 
seventeenth annual ieee symposium logic computer science lics 
robert harper furio honsell gordon plotkin :10.1.1.21.5854
framework defining logics 
journal acm jacm 
heng huang lea chris hawblitzel 
formal properties linear memory types 
technical report tr dartmouth college 
igarashi kobayashi 
garbage collection linear type system 
peter hearn 
bi assertion language mutable data structures 
symposium principles programming languages pages 
stefan saha zhong shao 
principled scavenging 
proceedings acm sigplan conference programming language design implementation pages 
acm press 
stefan zhong shao 
typed regions 
technical report yaleu dcs tr department computer science yale university 
greg morrisett david walker karl crary neal glew 
system typed assembly language 
acm transactions programming languages systems toplas volume pages 
acm press 
george necula peter lee 
safe kernel extensions run time checking 
nd symposium operating systems design implementation osdi october 
seattle wa pages 
petersen harper crary pfenning 
type theory memory allocation data layout 
symposium principles programming languages 
william pugh :10.1.1.36.9420
omega test fast practical integer programming algorithm dependence analysis 
proceedings acm ieee conference supercomputing pages 
acm press 
reynolds 
separation logic logic shared mutable data structures 
shao saha trifonov 
type system certified binaries 
acm symposium principles programming languages 
frederick smith david walker greg morrisett :10.1.1.1.3318
alias types 
european symposium programming 
smith 
building high performance programmable secure coprocessor 
computer networks special issue computer network security volume pages 
david teller zhong shao 
algorithm independent framework verifying integer constraints 
technical report yaleu dcs tr department computer science yale university 
mads tofte jean pierre talpin :10.1.1.23.5498
region memory management 
information computation 
wadler 
linear types change world 
broy jones editors ifip tc working conference programming concepts methods sea israel pages 
north holland 
david walker greg morrisett :10.1.1.1.5638
alias types recursive data structures 
lecture notes computer science volume 
david walker kevin watkins 
regions linear types extended 
proceedings sixth acm sigplan international conference functional programming pages 
acm press 
daniel wang andrew appel 
type preserving garbage collectors 
proceedings th acm sigplan sigact symposium principles programming languages pages 
acm press 
ed wei 
low level linear memory management type preserving mark sweep garbage collector undergraduate thesis 
technical report tr dartmouth college 
hongwei xi frank pfenning :10.1.1.36.3970
eliminating array bound checking dependent types 
proceedings acm sigplan conference programming language design implementation pages 
acm press 
appendix formal definition low save space congruence rules omitted included type erasure rules 
proofs type sequences delayed types type sequences omit delayed types 
rules follow notational conventions wadler walker :10.1.1.36.3970
abbreviations true true know bool linearity kinds int bool arithmetic true false iop bop cmp iop bop cmp op iop bop cmp types limit limit int bool mem gen eq indomain expressions limit op pack unpack roll unroll fix load store ev coerce eq apply eq new seq discard seq define seq domain fact values pack roll limit fact environments vn limit kn kn xn judgments evaluation rules load fact fact store fact fact coerce coerce op simplify op simplify true false true false unroll roll fix fix eq fact apply eq fact discard seq fact define seq fact fact fact fact xn vn xn vn unpack pack domain fact fact know fact new seq pack fact int fresh kinding rules int bool int int iop int int int cmp bool bool bool bop bool bool bool ka jb ka ka jb ka jb ka jb bool bool limit int limit limit nj nj nj nj int int bool bool bool type equivalence rules int mem int int gen int int indomain eq int fun fun eq eq true false type checking rules spare spare dom true limit limit limit limit limit coerce cn ci ei limit limit limit int limit limit limit limit ca ea cb eb ca cb ea eb fix pack unpack roll unroll fact mem fun fact gen fact eq dom fact indomain int mem load mem mem ev int store ev mem gen int define seq gen eq indomain int int indomain gen domain know gen eq eq eq ef apply eq ef new seq int gen gen discard seq int bool int int iop int iop int int cmp bool cmp bool bool bop bool bop bool bool ca bool cb cb ca cb bc bool 
