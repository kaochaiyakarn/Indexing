explicit substitutions higher order syntax extended neil ghani dept math 
comp 
sci 
university leicester university road leicester le rh uk ng mcs le ac uk uustalu institute cybernetics technical university tee ee estonia cs ee great deal interest higherorder syntax seeks extend standard initial algebra semantics cover languages variable binding functor categories 
canonical example studied literature untyped calculus handled instance general theory binding algebras cf 
fiore plotkin turi 
important syntactic construction explicit substitutions 
syntax language explicit substitutions form binding algebra explicit substitution may bind arbitrary number variables 
show language standard signature explicit substitutions naturally modelled initial algebra endofunctor id functor category 
comment apparent lack modularity syntax variable binding compared order languages 
categories subject descriptors programming languages formal definitions theory semantics syntax logics meanings programs semantics programming languages mathematical logic formal languages mathematical logic lambda calculus related systems general terms theory keywords syntax variable binding explicit substitutions algebras monads 
initial algebra semantics long regarded cornerstones semantics programming digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
merlin aug uppsala sweden copyright acm 
guages 
paradigm syntax language modelled initial algebra consisting terms language semantics language typically unique homomorphism initial algebra algebra 
similar situation arises theory datatypes initial algebra consists terms built constructors datatype initiality allows functions defined datatype structural recursion 
success program motivated development final coalgebra semantics non wellfounded syntax 
categorically regards initial algebra initial algebra endofunctor specifying language datatype 
order incorporate variables substitution considers single initial algebra object initial algebra free algebra mapping sending object thought object variables carrier initial algebra underlying functor free monad multiplication monad provides representation substitution unit models variables freeness monad models inductive nature initial algebra 
applications base categories set proved fruitful situations study sorted algebraic theories monads set study categories structure monads graph cat study rewriting monads pre cat 
long goal theoreticians language designers incorporate datatypes involving variable binding framework 
classic example untyped calculus plays foundational role computer science theory computability paradigmatic functional programming language 
intuitively problem define inductive family types just family individually inductive types 
observing family types just object functor category fiore plotkin turi showed binding algebras defined deploying initial algebra semantics functor categories 
computational point view reduction calculus usually modelled reduction 
defects implementational point view 
strikingly reduction may duplicate redexes 
attempts overcome problem research optimal reduction term graph rewriting 
option introduce explicit substitutions syntax language computation split finer local reductions gives implementer flexibility redexes contracted 
asks question understand explicit substitutions initial algebra semantics 
positive answer question important prove correct implementation languages explicit substitutions 
provides right setting ideas suggesting functor categories actual functor interested binding algebra explicit substitution operator bind number free variables 
solves problem follows 
argue syntax language standard signature explicit substitutions initial algebra certain simple endofunctor functor category 
gives associated soundness completeness results inference rules explicit substitutions 
show endofunctor initial algebra show explicit substitutions functor monad described 
show canonical evaluation map arises naturally 
suggest order languages higherorder syntax modular sense decompose monad capturing syntax large language coproduct monads corresponding components language 
proof explicit substitutions functor monad uses theorem 
goes proving explicit substitutions functor really correspond explicit substitutions appear literature achieve coend construction sec 

best regarded providing general theorem initial algebras higher order endofunctors form monads shows example really correspond explicit substitutions 
section review necessary preliminaries lfp categories kan extensions 
section review categorical approach initial algebra semantics order syntax 
section look untyped calculus paradigmatic example language variable binding switch initial algebras functor categories 
solution explicit substitutions section constitutes main section 
problem modularity higher order syntax discussed section 
section list ideas regarding 

preliminaries assume reader familiar standard category theory 
order ensure results combinator easier implement away category set locally finitely presentable categories passing coends kan extensions 
give short summary important results concerning concepts referring reader literature details 
alternatively provide significant intuition constructions allow reader follow thrust argument category set 
locally presentable categories important feature explicit substitutions similar syntactic constructs role finite sets contexts consist finite sets variables terms contain finite numbers variables 
fact set directed join finite subsets 
properties locally finitely presentable categories 
diagram filtered finite subcategory cocone functor finitary preserves filtered colimits 
object category said finitely presentable hom functor preserves filtered colimits 
category locally finitely presentable abbreviated lfp cocomplete set finitely presentable objects object filtered colimit objects full subcategory finitely presentable objects denoted inclusion functor denoted category finitary functors denoted set finitely presentable sets precisely finite sets taken finite cardinals denote set filtered colimit diagram finite subsets isomorphic finite cardinal ordered inclusion 
kan extensions functor category defines functor 
problem left right kan extensions problem finding left right adjoints concretely functor left right kan extensions characterized natural isomorphisms view left right kan extension functor canonical extensions domain kan extensions pointwise colimits limits elegantly ends coends 
classic coend formula left kan extensions see details ia fa tensor coends reduce certain colimits reduce quotients 
mentioned earlier give intuitions formulae readers knowledge area follow argument 
importantly lfp functor finitary isomorphic 

free algebras free monads general program wish follow specifying declaring syntax means functor actual terms associated language arising initial algebra construction 
furthermore terms parameterised variables built terms natural notion substitution axiomatised concept monad 
notions algebra monad central program definition 
algebras endofunctor functor 
algebra pair fx category alg objects algebras map algebra algebra map ff simplest cases practical interest polynomial endofunctors arising signature 
signature functor set object ary operators signature defines polynomial endofunctor concretely jn elegantly set inclusion 
way computes terms depth built set variables 
algebra standard notion model set interpretation operator signature operation monads monad category endofunctor natural transformations idc called unit called multiplication monad satisfying monad laws idc category mon objects monads map monad natural transformation satisfying 
monad said finitary underlying endofunctor finitary 
mon full subcategory finitary monads 
term algebra signature term algebra language set variables generated rules 
tn 
tn observations immediate 
set set carrier algebra 
second set endofunctor underlying functor monad 
unit maps variable associated term multiplication describes process substitution 
monad laws ensure substitution behaves correctly substitution associative variables left right units 
demonstrates monads form calculus equational reasoning variables substitution term algebra represented unit multiplication underlying functor monad 
observations weak fail capture inductive nature crucial understanding behaviour 
resolving problem crucial extending understanding syntax variable binding 
reformulate set theoretic definition 
note term variable term constructor applied variable solves equation solution 
initial algebra 
lemma 
cocomplete category functor 
initial algebra carrier computable colimit chain jn lemma 
category finite coproducts endofunctor initial algebras tx exist properties 
tx free algebra functor tx alg left adjoint forgetful functor alg 
underlying functor free monad carries monad structure natural transformation monad natural transformation unique monad map satisfying 
initial id algebra 
applying lemma functors set arising signature need establish guarantee existence initial algebras 
set required colimits 
set cocomplete 

polynomial endofunctor built ccc set left adjoint preserve colimits 
applying lemma see carrier free algebra underlying functor free monad practice tend require lfp finitary 
clearly monad underlying functor just shown finitary functor lfp category construct free monad 
constructions adjoint 
lemma 
lfp category 
forgetful functor mon left adjoint sending functor free monad 
left adjoints preserve colimits mon sign stands coproduct monads functors means decompose large syntactic structures components 
comment intriguing hold higher order syntax 
various generalisations worth pointing 
operations larger arity handled moving locally presentable categories 
non wellfounded syntax treated replacing various initial algebra constructions final coalgebra constructions 
forms syntax term graphs rational terms generalised universal constructions involving algebras lfp categories 

untyped calculus extend analysis languages variable binding 
proposals best cf 
elegance relies fact uses exactly general program order languages instantiated functor categories 
example lx set untyped terms equivalence free variables typically finite set ought lx lx lx right hand side summand represents variables second summand represents applications third represents abstractions 
note part expression means extra variable exactly bound variable 
furthermore sets lx solution equation permit definition functions structural recursion 
obtained initial algebra construction 
problem 
order languages code right hand side equation functor construct term algebra proving existence initial algebra functor 
abstraction introduces extra variable construct set lx separately 
construct sets lx simultaneously achieved moving functor category set set abstractly lfp 
want construct finitary endofunctor lx possibly set defined fx fx colimits functor categories computed pointwise equivalent lx id id techniques previous section 
define functor id arise carrier initial algebra 
order ensure existence initial algebra lemma su ces check finite coproducts colimits 
holds inherited assume lfp 
functor preserves colimits 
reduces showing preserve colimits routine verification 
recall apart expecting syntax language initial algebra construction want monad ensure comes behaved operation substitution able formulate requirement semantic functions respect substitution 
constructed carrier initial algebra functor show monad time proving syntax order language extended explicit substitutions forms monad section 
note free monad endofunctor 
conclude initial algebra semantics functor category define inductive families types untyped terms 
fact new mathematics required theory really compelling argument favour categorical formulation initial algebra semantics 
handling syntax simply typed calculus possible 
explicit substitutions core asks treatment extends explicit substitutions 
certainly reasonable idea explicit substitutions involve variable binding seen elegantly variable binding modelled functor categories 
note potential pitfall calculi explicit substitution operation binds unknown number variables 
priori clear write explicit substitutions equation terms previous section knew abstraction binds exactly variable 
explicit substitutions operator flexible binding power 
elegant way tackling problem allows bring play standard initial algebra techniques described 
assume interested adding explicit substitutions order language argument clearly scales adding explicit substitutions calculus 
start signature generate terms rules 
tn 
tn sub inclusion set 
generated exactly order terms additional inference rule says term built variables mapping variables terms possibly containing explicit substitutions set form explicit substitution binding variables associated terms 
set depends problem faced untyped calculus dealing family inductive types inductive family types 
intuitively may try writing account equivalence 
ask explicit substitution equal explicit substitution 
approach taken stipulate rule sub sub expressing quotient equivalence relation elegantly done coend 
away signatures functors lfp finitary endofunctor want ef finitary endofunctor efx ef efx ef recall inclusion set tensor just product expected 
notice taken coend full subcategory finitely presentable objects corresponds observation dealing finite contexts explicit substitutions operator binds finite number bound variables 
try construct ef defining higherorder functor capture right hand side proving preserves colimits 
possible presence coend delicate task 
simpler idea category theory rearrange formula simpler form 
note coend computing left kan extension ef ef 
addition certainly ef finitary ef ef may proceed efx ef ef ef switching functor category obtain ef id ef ef ef look initial algebra fx id initial algebra exist 
know finite coproducts colimits inherited ask 
boils asking functor follows direct calculation 
clearly argument works want add explicit substitutions untyped calculus just firstorder language 
know functor categories get initial algebra semantics languages explicit substitutions 
turn question get monad 
theorem 
cited gives considerably general theorem applies non wellfounded syntax need special case 
theorem 
category finite coproducts exists pointed 
functor natural transformation functors satisfying id id carrier initial id algebra exists monad 
see monad set idx zx inl id inr id note follows employed coend just coend viz 
efx ef computed lan id ef ef lan id ef course just ef 
smaller coend intuitively right thing priori adequacy bigger coend posteriori fact 
ef set may rely idf remarkably monad structure resp 
ef explicated theorem intended sense substitution operation get theorem coincides normal capture avoiding substitution terms resp 
terms explicit substitutions 
evaluation explicit substitutions important feature explicit substitutions term explicit substitutions normalised reduced explicit substitutions respects variables substitution 
framework corresponds defining natural transformation eval ef tf verifying monad map 
simply described initial algebra setting 
firstly note ef carrier initial algebra evaluation map structural recursion takes tf algebra structure 
means need natural transformation id tf tf tf tf id initial algebra structure tf multiplication tf checking eval monad map easy 
pure terms qualify model terms explicit substitutions syntax evaluation qualifies semantic function 

non modularity higherorder syntax mentioned section finitary endofunctors lfp category tf tg associated free monads tf tf tg result means representing monad composite order signature decomposed representing monads component signatures 
concretely semantic function map respecting variables substitution large language tf model set carrying variables substitution completely determined restrictions smaller languages tf tg intuitively reason term constructible wellfounded fashion terms terms substitution fact needs variables depth terms depth terms 
applications coproducts monads modularity tool discussed 
similar decomposition theorems higher order syntax fail coproducts monads higher order syntax modular 
specifically expect ef tf id say extending order language explicit substitutions amounts coproduct language pure explicit substitution terms 
nice result regard explicit substitutions kind computational monad combine forms syntax coproducts 
false general 
untrue lapp abs lapp id abs id languages pure application terms pure abstraction terms 
see invoke theorem 
theorem 
endofunctor monad free monads exist coproduct tf exists tf tf id theorem see tf id unwinding get tf id id id id 
elements tf usual terms padded layers explicit substitutions may pure explicit substitution terms stem terms 
possible explicitly substitute term involving operations subterm form sub illegal involves operations 
contrast ef allows arbitrary mixes explicit substitutions operations elements 
see tf contain terms interesting ef clearly real object study 
similarly obtain lapp abs abs id unwinding distribution give lapp abs abs id abs 
abs abs id id id 
id id id 
elements lapp abs pure applicative terms terms built variables application padded layers abstractions choice new old variables wrong place 
body abstraction abstraction decided new variable old ones 
result body abstraction application application merely uses old variables subterms st occurs free forbidden 
interpret 
ef coproduct tf monad map ef uniquely specified restrictions tf elements ef constructed elements tf substitution proper substitution ef substitutes stem term explicit substitution free variables bound explicit substitution terms form sub involves operations 
knowing restrictions tf fact respects substitution impossible decide value terms 
similarly coproduct lapp abs term constructed pure application pure abstraction terms proper substitution terms form st occurs free constructible way 
possibility st st violates freeness substitution proviso 
restrictions monad map lapp abs known absolutely inferred value xy 
coproduct combination languages terms combined language constructible terms language proper substitution combined language obeys substitution laws 
combinations calculus syntax order language extended explicit substitutions combined language generated ones means naive substitution 

research higher order syntax potential produce really exciting developments language design 
number key problems need solved potential benefits realised 
interest currently working 
modularity syntax important 
want metatheory language time change component 
discussed sec 
simple approach modularity coproducts monads fails higher order setting 
clearly modularity obtain mathematical analysis 
want understand model theory higherorder datatypes 
order setting know bijection monad maps tf natural transformations generate representing monads higher order functors theorem classify monad maps representing monad monad 
similar intimately related questions arise algebras functor representing monad 
ghani research partially supported epsrc 
gr 
visit feb financed estonian ministry education research center dependable computing 
uustalu received support estonian science foundation 
visit leicester march paid estonian foundation 
authors acknowledge support royal society 

aczel 
infinite trees completely iterative theories coalgebraic view 
theor 
comp 
sci 

free iterative theories coalgebraic view 
math 
struct 
comp 
sci 

rational monads free iterative theories 
blute selinger eds proc 
th conf 
category theory comp 
sci ctcs electr 
notes theor 
comp 
sci 
elsevier 

locally presentable accessible categories london math 
soc 
lecture note series 
cambridge univ press 
altenkirch reus 
monadic presentations lambda terms generalized inductive types 
flum rodrguez artalejo eds proc 
th int 

comp 
sci 
logic csl lect 
notes comp 
sci pp 

springer verlag 
kelly 
presentation topoi algebraic relative categories graphs 
algebra 
fiore 
semantic analysis normalisation evaluation typed lambda calculus 
proc 
th int 
acm sigplan conf 
principles practice declarative programming ppdp pp 

acm press 
fiore plotkin turi 
syntax variable binding extended 
proc 
th ann 
ieee symp 
logic comp 
sci lics pp 

ieee cs press 
fiore turi 
semantics name value passing 
proc 
th ann 
ieee symp 
logic comp 
sci lics pp 

ieee cs press 
ghani luth de 
coalgebraic monads 
moss ed proc 
th 
coalgebraic methods comp 
sci cmcs electr 
notes theor 
comp 
sci 
elsevier 
ghani luth de power 
initial algebras 
math 
struct 
comp 
sci 
hofmann 
semantical analysis higher order syntax 
proc 
th ann 
ieee symp 
logic comp 
sci lics pp 

ieee cs press 
hyland plotkin power 
combining computational ects commutativity sum 
baeza yates montanari santoro eds proc 
ifip th world computer congress tc stream nd ifip int 
conf 
theor 
comp 
sci tcs ifip conf 
proc pp 

kluwer acad 
publishers 
luth ghani 
monads modular term rewriting 
moggi rosolini eds proc 
th int 
conf 
category theory comp 
sci ctcs lect 
notes comp 
sci pp 

springer verlag 
luth ghani 
composing monads coproducts 
proc 
th acm sigplan int 
conf 
functional programming icfp sigplan notices pp 

acm press new york 
luth ghani 
monads modularity 
armando ed proc 
th int 

frontiers combining systems lect 
notes artif 
intell pp 

springer verlag 
mac lane 
categories working mathematician graduate texts math 
springer verlag nd ed 
st ed 
matthes uustalu 
substitution non wellfounded syntax variable binding 
ed proc 
th int 

coalg 
methods comp 
sci cmcs electr 
notes theor 
comp 
sci 
elsevier 
miculan 
framework typed hoas semantics 
appear proc 
ppdp acm press 

endofunctors 
blute selinger eds proc 
th conf 
category theory comp 
sci ctcs electr 
notes theor 
comp 
sci 
elsevier 
moss 
parametric corecursion 
theor 
comp 
sci 
