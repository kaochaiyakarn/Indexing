points analysis linear time bjarne steensgaard microsoft research microsoft way redmond wa usa research microsoft 
com interprocedural flow insensitive points analysis type inference methods linear time cost complexity 
knowledge asymptotically fastest non trivial interprocedural points analysis algorithm described 
algorithm non standard type system 
type inferred variable represents set locations includes type turn represents set locations possibly pointed variable 
type inferred function variable represents set functions may point includes type signature functions 
results equivalent alias analysis control flow analysis assumes alias relations reflexive transitive 
contributions 
type system describing universally valid storage shape graph program linear space 
second constraint system leads better results obvious constraint system type system 
third linear time algorithm points analysis solving constraint system 
modern optimizing compilers program understanding browsing tools pointer languages kr dependent semantic information obtained alias analysis points analysis 
alias analyses compute pairs expressions access paths may aliased lr 
pointsto analyses compute store model locations cwz egh wl ruf 
current compilers programming tools intraprocedural analyses polynomial time space complexity common data flow analyses prevents interprocedural analyses large programs 
interprocedural analysis increasingly important necessary support program optimization various program understanding tools 
previously published interprocedural analysis algorithms reported successfully applied programs lines code published results practically lines code 
copyright association computing machinery permission digital hard copies par personal classroom granted fee provided copies distributed profit commercial advantage new copies bear notice full citation page 
components owned acm honored 
abstracting credit permitted 
copy republish post servers redistribute requires prior specific permission fee 
request permissions publications dept acm fax flow insensitive interprocedural points analysis algorithm desirable linear space linear time complexity fast practice 
algorithm easily applicable programs hundreds thousands lines code 
analysis results accurate obtained flow sensitive analyses 
results roughly comparable cubic time complexity flow insensitive analysis wei 
algorithm inspired henglein binding time analysis type inference hen uses non standard type system describe store usage runtime types construct storage shape graph cwz 
describe principles algorithm terms types typing rules provide detailed description algorithm directly implement algorithm compiler 
section state source language describe algorithm 
language captures essential parts language section define non standard set types model storage section state set typing rules programs 
typing rules impose constraints relationships types program variables 
finding typing program obeys constraints amounts performing points analysis 
section show efficiently infer minimal typing obeys constraints 
section report practical experience algorithm programming en vironment 
section describe related section point directions 
source language describe points analysis small imperative pointer language captures important properties languages kr 
language includes pointers locations pointers functions dynamic allocation computing addresses variables 
analysis flow insensitive control structures language irrelevant 
syntax relevant statements language shown 
syntax computing addresses variables pointer indirection borrowed programming language kr 
variables assumed unique names 
op 
expression form describe primitive computations arithmetic operations computing offsets aggregate objects 
allocate expression dynamically allocates block memory size functions constant values described fun 
expression form fi variables formal parameters generalized function definitions allow functions multiple return values feature op allocate fun syntax relevant statements source language 
range unbounded set variable names constants 
op ranges set primitive operator names 
denotes sequence statements 
control structures language irrelevant purposes 
fact fun lessthan subtract fact multiply fi result fact program source language computes factorial 
times called parameters ri variables return parameters called parameters 
function calls call value semantics asu 
formal return parameter variables may appear left hand side position statements function body 
formal return parameter variables local variables may occur body function true programs allowed contain nested function definitions 
shows implementation factorial function call syntax source language 
assume programs behaved portable programs 
analysis tracks flow pointer values analysis algorithm may produce wrong results programs pointers scratch bitwise duplication pointers non portable programs programs rely specific compiler allocates variables relative 
analysis algorithm deal exclusive operations pointer values real flow values 
modelled type system letting types type components 
storage shape graph may cyclic programs types may recursive 
set types inferred variables program represents storage shape graph valid program points 
storage shape graph conservatively models points relations may hold runtime 
alias relations extracted storage shape graph egh 
goal points analysis linear time cost complexity 
size storage shape graph represented types linear size input program 
consequently maximum number graph nodes linear size input program 
additionally graph node may fixed number going edges meaning type may fixed number component types 
describe locations pointed pointer variable single type 
composite objects struct objects describe elements object single type 
describing element composite object separate types imperative languages imply size storage shape graph potentially exponential size input program extreme type de st ru ct 
describing elements composite objects separate types may desirable sum sizes variables exponential size input program 
extending type system addressed 
source language allows pointers functions 
function pointer values described signature types describing types argument result values 
values may include pointers locations pointers functions 
type value accommodate types pointers 
type system value type pair including location type function signature type 
non standard set types points analysis described productions oz types describe values types describe locations pointers locations types describe functions pointers functions 
types may recursive may impossible write types directly 
types written type variables 
types equal described type variable 
note different usual structural equality criterion types 
structural equality criterion added tag types 
types purposes performing points analysis define non standard set types describing store 
types types normally typed imperative languages integer float pointer struct 
types model storage program runtime storage model 
locations variables locations created dynamic allocation described types 
type describes set locations possible runtime contents locations 
type viewed node storage shape graph cwz 
node may edges nodes typing rules section define set typing rules set non standard types defined previous section 
typing rules specify program typed 
typed program static storage shape graph indicated types safe conservative description possible dynamic runtime storage configurations 
stating typing rules argue inequalities equalities typing rules argue way defined typing rule statements primitive operations 
location program described single type 
pointer location described type location pointed 
locations may contain pointer location types locations location type component 
requirement reflected typing rules 
consider simple assignment statement assume type meaning location allocated hold value type type location pointer value may assigned executing statement location component type describing pointer value assigned function pointer value may assigned function signature component 
obvious typing rule simple assignment statements ref ref oz welltyped rule states part program typed type environment contents variables described type 
previous typing rule simple assignment ste 
typing rule strict 
illustrated sequence statements rule content components types 
strictly necessary pointer value assigned 
parts program hold pointers disjoint locations statements unnecessarily force pointed locations described type 
furthermore part program hold pointer value analysis results indicate may hold pointer value assigned integer values program 
assignment statement content component types need may contain pointer 
order state requirement typing rule introduce partial order types defined follows non pointers represented type requirement expressed typing rule ref ref welltyped rule states component type equal corresponding component type statements form op 
op operation may comparison bit wise operation addition consider subtraction pointer values 
result pointer value operand pointer values result pointer value 
result described type input pointer values 
operations argument pointer values result comparisons 
operations result required described type input pointer values 
purposes treat primitive operations identically 
state typing rules relevant parts source language 
program typed typing environment statements program typed typing environment associates variables type 
typing rule dynamic allocation implies location type required describe value stored variable assigned 
type describe allocated location need type variable program 
type allocated location indirectly available type variable assigned 
locations allocated statement type locations allocated different allocation statements may different types 
contains example program typing variables occurring program obeys typing rules 
variables described type variable single type variable represent locations pointed pointers possible stored location variable efficient type inference task performing points analysis reduced task inferring typing environment program typed 
precisely typing environment seek minimal solution typedness problem location type variable typing environment describes locations possible 
section state compute minimal solution linear time complexity 
basic principle algorithm start assumption variables described different types type variables proceed merge types necessary ensure typedness different parts program 
merging types means replacing type variables single type variable typing environment 
joining fast fast union find data structures 
describe initialization assumptions program represented 
describe deal equalities inequalities typing rules manner ensuring process statement program exactly 
argue algorithm linear space complexity linear time complexity 
algorithm stages stage algorithm provide typing environment variables described different type variables 
type variable consists fast union find structure equivalence class representative ecr associated type information 
type type variables typing environment initially ref 
assume program represented program representation name resolution occurred encode typing environment program representation get constant time access type variable associated variable name 
stage algorithm process statement exactly 
type variables joined necessary ensure statement described 
joining type variables associated type information unified computing upper bound types joining component type variables necessary 
joining types statement typed longer typed 
program statements typed program typed 
ref hy ref ref welltyped ref hy er ref yi ref vi hi welltyped op hx welltyped allocate ref ref lam 

fi ref ref vs welltyped fun ref vi vj 
type rules relevant statement types source language 
variables assumed associated type type environment 
distinct variables assumed distinct names type environment describe variables scopes simultaneously 
wild card value rules imposing restrictions type component represents 
ref ref rs rs tel rs ref fi ref example program typing obeys typing rules graphical representation corresponding storage shape graph 
note variables described type 
types rs structurally equivalent considered types 
type variables joined necessary ensure final solution minimal solution seeking 
processing constraints typing rules statement impose constraint types identical corresponding type variables joined obey constraint 
inequality constraint difficult may possible determine time processing statement types joined 
left hand side type variable associated type type variables joined meet constraint 
assume left hand side type variable associated type time statement processed 
point need join type variables 
typing rule statement may subsequently force change type associated type variable implying type variable joined type variable right hand side current constraint 
deal associate type variable type set type variables join type inequality relation hold type variables perform conditional join 
left hand side type variable type add right hand side type variable set associated left hand side type variable 
left hand side type variable type real join type variables performed 
type associated type variable changes typing rule unification type variable joined type variables associated set 
precise rules processing statement program 
details join unification operations 
complexity argue algorithm linear space linear time complexity size input program 
space cost algorithm determined total number created number join operations performed 
initial number proportional number variables program 
number created processing single statement bounded small constant case procedure call worst proportional number ref type ecr ref type ecr ifr ref type ecr ecr ifr ref type ecr ref type ecr settype ref ref rs type ifr rs rs op ref type ecr ref type ecr yi ifr allocate ref type ecr type settype ref ref type ecr ref type ecr type settype tel tel rs type ifr rs rs fun rr ref type ecr type settype lam ref ci type ecr fi ref type ecr lam type ci tel type ecr fi ifr join join fori tel type ecr ri join join 
xr ref type ecr type settype lam cr lam type ci tel type ecr yi ifr fori tel type ecr xi ifr inference rules corresponding typing rules 
ecr ecr representing type variable type type associated ecr performs conditional join settype associates ecr type forces conditional joins constructs list ofz new associated bottom type 
settype type pending join el type pending join el unify ref rl ref rl unify lam 

lam 
fori 
xl rx ifr rx rb ifl ix join el tl type el tx type ex ecr union el ex type pending pending pending el join type pending join unify rules unification types represented 
assume ecr union performs fast union find join operation ecr arguments returns value subsequent find operation 
variables occuring statement 
number consequently proportional size input program 
number join operations bounded total number 
space cost join operation amounts constant cost ecr union operation 
cost unifying joining component type attributed joins 
cost performing conditional join join type variables type constant binary tree structure represent pending sets 
time cost algorithm determined cost traversing statements program cost creating types cost performing join operations cost fast union find find operations 
cost traversal creation types clearly proportional size input program 
cost performing join operations constant plus cost ecr find operations 
average cost ofn ecr find operations slowly increasing inverse ackermann function tar 
time cost complexity algorithm consequently size input program linear size input program 
experience implemented slightly improved version algorithm prototype programming system value dependence graph implemented programming language scheme cr 
implementation uses weaker typing rule primitive operations returning boolean values uses predetermined transfer functions direct calls library functions algorithm contextsensitive calls library functions 
analysis algorithm routinely applied programs processed system 
implementations earlier type inference pointsto analysis algorithm ste performed university california san diego mor scheme gri 
implementations augmented model slots structured objects independently 
earlier algorithm non standard type system algorithm stricter typing rules implying results conservative need 
implementation demonstrates running time algorithm roughly linear size input program test suite programs 
implementation performed points analysis programs lines code internal microsoft tool 
running time algorithm line program approximately seconds seconds process time sgi indigo workstation roughly times cost traversing nodes program representation 
line program available xerox parc running time approximately seconds seconds process time 
analysis performed separate stage program representation built 
implementation previous algorithm performs processing statements parsing program 
parse time increase approximately adding points analysis parser 
counting extra time performing analysis emacs non empty lines code analyzed approximately seconds felt non empty lines code analyzed approximately seconds sparcstation mor 
algorithm easily implemented process statements parsing 
running times previous algorithm roughly minor fluctuations 
table table table illustrate distribution program variables type variable number benchmark programs 
programs bill landi todd austin benchmark suites analyses abs spec benchmark suite 
large program available xerox parc version 
table gives raw distribution total analysis solution performed unoptimized version program representation 
type variables describe location time writing largest program represented vdg program representation 
variables addresses taken 
type variables describing zero program variables represent non types describing user functions locations allocated runtime system locations argv argc arguments main 
table gives distribution type variables occur location components types solution analysis performed unoptimized version program representation 
type variables represent program variables pointed variables 
necessarily represent program variables pointed program minor optimizations performed vdg program representation built optimizations eliminate storing values variables trivial avoid described 
number type variables describing program location reduced relative table 
reduction caused eliminating type variables values passed functions pointed pointer 
values grouped place polymorphic analysis 
table gives distribution location component type variables solution analysis performed optimized version program representation 
optimizations performed program representation include local transformation eliminating local variables address taken 
type variables describe program variables hardest get analysis results 
program variables pointed program variables eliminated local transformations 
program variables described type variable representing program variables candidates global optimizations represented register memory location 
distributions shown tables demonstrate considerable number type variables describing single program variable type variables describing pointed program variables 
type variables describe small number program variables 
couple major exceptions type variables describing program locations 
programs locations described exceptional type variables global constant strings 
example program program locations described largest single type variable strings passed argument user defined logging tracing procedures 
context insensitive analysis bound show similar number possible pointer values formal parameters logging tracing procedures 
subjective evaluation quality analysis results pretty contents slots structured variables represented single value type 
programs data structures trees lists central data structures 
programs inability distinguish structure elements serious loss 
related henglein type inference perform binding time analysis linear time hen 
types represent binding time values 
presents set typing rules extract constraints typing rules solve constraints fast union find data structures 
points analysis algorithm inspired henglein type inference algorithm 
points analysis closest resembles analysis weihl wei 
analysis flow insensitive interprocedural deals pointers functions 
algorithm assume alias relations reflexive transitive table number type variables describing number program variables unoptimized program representation 
example landi allroots type variables describing location single program variable 
table number type variables describing number pointed program variables unoptimized program repre sentation 
table number type variables describing number pointed program variables optimized program representa tion 
cases produce better results algorithm 
hand algorithm distinguish levels pointer indirection 
additionally algorithm works best call graph available deal elegantly recursive functions 
algorithm time cost complexity cubic size input program algorithm linear time cost complexity 
precise points analysis exist cwz egh wl ruf 
analyses flow sensitive interprocedural data flow analyses 
chase algorithm cwz ruf algorithm ruf context insensitive polynomial time complexity 
algorithms context sensitive meaning algorithm distinguishes effects different calls function computing just effect valid calls function 
algorithm emami egh exponential time complexity performs virtual unfolding non recursive calls 
algorithm wilson lam wl exponential time complexity exhibit polynomial time complexity practice uses partial transfer functions summarize behavior analyzed functions procedures 
points analysis builds maintains model store analysis alias analysis builds maintains list access path expressions may evaluate location words aliased 
relevant alias analysis algorithms lr 
length access paths limited relatively simple truncation mechanism eliminate extra path elements 
deutsch presents alias analysis imperative subset ml deu 
access paths defined terms monomial relations kind multi variable polynomial expression structure accessors variables 
analysis relevant strongly typed languages ml strongly typable programs written weakly typed languages shown deu 
access paths combined unification 
higher order context sensitive points analysis type inference developed tofte talpin purposes creating ml interpreter garbage collector tt 
analysis polymorphic type inference nonstandard set types 
assume runtime model allocation regions explicit allocation regions resemble storage shape graph nodes algorithm 
algorithm deal objects may updated assigned initial value normal imperative programs 
generalized general imperative programs open question 
andersen defines context sensitive context insensitive anal flow insensitive points analysis terms con straints constraint solving 
context sensitive algorithm distinguishes immediate calling contexts limited version static program call graph effectively layers context consideration 
values constrained sets locations 
andersen algorithm allows location member non identical sets 
algorithm allows location described type representing set locations 
size solution context insensitive algorithm size solution context sensitive algorithm number locations turn exp analysis context insensitive type system monomorphic 
polymorphic type system polymorphic type inference algorithm context sensitive 
andersen uses term intra procedural mean context insensitive term inter procedural mean context sensitive 
size program contrast size solution algorithm 
choi flow sensitive flow insensitive analyses cbc 
flow insensitive analysis algorithm described detail 
algorithm computes alias information points information uses representation shares properties storage shape graph 
rep resentation allows locations members non identical sets 
algorithm iterated processing program statements slower similar constraint algorithm andersen context sensitive algorithm considering level calling context 
algorithm extension linear points analysis algorithm ste 
bill landi independently arrived earlier algorithm lan 
barbara ryder sean zhang working version earlier algorithm extension elements composite objects represented separate type components zha 
flow insensitive interprocedural contextinsensitive points analysis type inference methods linear time complexity 
algorithm implemented shown efficient practice results better results intraprocedural analyses 
problem analysis disambiguate information different elements structured objects 
type system extended resulting analysis algorithm linear time complexity 
algorithm asymptotically faster existing algorithms distinguish different elements structured objects 
main interest developing efficient interprocedural points analysis algorithms large programs 
develop efficient algorithms yielding greater precision algorithm 
algorithm possible directions investigate 
way obtain improved results develop efficient flow sensitive algorithm 
results algorithm prime data flow analysis algorithm reduce amount done algorithm 
possible method splitting functional stores suggested ste :10.1.1.33.1354
way obtain improved results develop efficient flow insensitive context sensitive algorithm 
done types represent sets locations linear time algorithm polymorphic monomorphic type inference methods 
currently pursuing directions research 
roger crew michael ernst erik ruf ellen spertus daniel weise analysts group microsoft research developed vdg programming environment come existence 
members analysts group commented versions 
author enjoyed interesting discussions david william griswold barbara ryder sean zhang bill landi sto fair probably proportional practice 
various points analysis algorithms linear time complexity 
bill landi todd austin sharing benchmark suites 
abs todd austin scott breach sohi 
efficient detection pointer array access errors 
conference programming language design implementation pages june 
lars ole andersen 
program analysis specialization programming language 
phd thesis department computer science university copenhagen may 
asu alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley 
michael burke paul carini jong deok choi michael hind 
flow insensitive interprocedural alias analysis presence pointers 
proceedings th international workshop languages compilers parallel computing volume lecture notes computer science pages 
springer verlag 
extended version published research report rc ibm watson research center september 
cbc jong deok choi michael burke paul carini 
efficient flow sensitive interprocedural computation pointer induced aliases side effects 
proceedings twentieth annual acm symposium principles programming languages pages charleston south carolina january 
cr william clinger jonathan rees editors 
revised report algorithmic language scheme november 
cwz david chase mark wegman kenneth zadeck 
analysis pointers structures 
proceedings conference programming language design implementation pages june 
deu alain deutsch 
model aliasing abstractions finite representations fight regular equivalence relations 
international conference computer languages pages 
ieee april 
deu alain deutsch 
interprocedural may alias analysis pointers limiting 
conference programming language design implementation pages june 
egh emami rakesh ghiya laurie hendren 
context sensitive interprocedural points analysis presence function pointers 
conference programming language design implementation pages june 
gri william griswold 
algorithm ste program restructuring tool 
personal communication pldi june 
hen kr lan lr mor ruf ste ste tar tt wei wl zha fritz henglein :10.1.1.33.1354
efficient type inference higher order binding time analysis 
functional programming computer architecture pages 
brian kernighan dennis ritchie 
programming language second edition 
prentice hall 
william landi 
linear time points analyses 
personal communication popl january 
william landi barbara ryder 
safe approximate algorithm interprocedural pointer aliasing 
proceedings conference programming language design implementation pages june 
william landi barbara ryder sean zhang 
interprocedural modification side effect analysis pointer aliasing 
proceedings conference programming language design implementation pages june 
david 
poster presentation pldi june 
erik ruf 
context insensitive alias analysis reconsidered 
conference programming language design implementation pages june 
bjarne steensgaard 
points analysis linear time 
technical report msr tr microsoft research march 
bjarne steensgaard 
sparse functional stores imperative programs 
cm workshop intermediate representations pages san francisco ca january 
proceedings appear march issue sigplan notices 
robert tarjan 
data structures network flow algorithms 
regional conference series applied mathematics volume regional conference series applied mathematics 
siam 
mads tofte jean pierre talpin 
implementation typed call value calculus stack regions 
proceedings st ga ct symposium principles programming languages pages january 
daniel weise roger crew michael ernst bjarne steensgaard 
value dependence graphs representation taxation 
proceedings st symposium principles programming languages pages january 
william weihl 
interprocedural data flow analysis presence pointers procedure variables label variables 
conference record seventh annual acm symposium principles programming languages pages january 
robert wilson monica lam 
efficient context sensitive pointer analysis programs 
conference programming language design pages june 
sean zhang 
poster presentation pldi june 
