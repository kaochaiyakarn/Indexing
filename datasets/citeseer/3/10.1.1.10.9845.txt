reengineering class hierarchies concept analysis gregor snelting universit passau frank tip ibm watson research center new method analyzing reengineering class hierarchies 
approach class hierarchy processed set applications ne grained analysis access subtype relationships objects variables class members performed 
result analysis class hierarchy guaranteed behaviorally equivalent original hierarchy object contains members required 
method semantically founded concept analysis new class hierarchy minimal maximally factorized concept lattice re ects access subtype relationships variables objects class members 
method primarily intended tool nding imperfections design class hierarchies basis tools largely automate process reengineering hierarchies 
method space optimizing source source transformation removes redundant elds objects 
prototype implementation java constructed conduct case studies 
results demonstrate method provide valuable insights usage class hierarchy speci context lead useful restructuring proposals 
designing class hierarchy hard possible anticipate hierarchy application 
especially case class hierarchy preliminary version parts article appeared proceedings acm sigsoft symposium foundations software engineering 
authors addresses gregor snelting fakult ur mathematik und informatik universit passau 
passau germany frank tip ibm watson research center box yorktown heights ny usa class string details omitted class address details omitted enum faculty mathematics class professor forward declaration class person public string name address address long class student public person public student string sn address sa int si name sn address sa si void professor advisor long professor advisor class professor public person public professor string faculty address wa name faculty wa assistant default assistant void student assistant faculty faculty address student assistant assistants int main string name name address addr addr student student new student name addr professor professor new professor name mathematics addr return int main string name name address addr addr student student new student name addr professor professor new professor name addr return example relationships students professors 
class hierarchy expressing associations students professors 
example program class hierarchy 
example program class hierarchy 
developed library designed independently applications 
ongoing maintenance particular ad hoc extensions hierarchy increase system entropy 
typical examples inconsistencies may arise think class may contain member accessed instance indication may removed moved derived class 
di erent instances class may access di erent subsets members indication appropriate split multiple classes 
method analyzing usage class hierarchy concept analysis 
approach comprises steps 
table constructed precisely re ects usage class hierarchy 
particular table explicit relationships types variables class members type base class type member occur base class type variable encoded table 
table concept lattice derived factors information variables members common 
show concept lattice provide valuable insight design class hierarchy serve basis automated interactive restructuring tools class hierarchies 
examples written java approach applicable object oriented languages 
method analyze class hierarchy number programs provide user combined view re ecting usage hierarchy entire set programs individual views clarify application uses hierarchy 
analyzing class hierarchy accompanying applications class library possible useful study internal dependences inside class de nitions 
motivating example consider example concerned relationships students professors 
shows class hierarchy class person de ned contains person name address 
classes student professor derived person 
students identi cation number thesis advisor graduate students 
constructor provided initializing students method designating professor advisor 
professors faculty professor may hire student teaching assistant 
constructor provided initialization method hiring student assistant 
details classes address string provided subsequent analysis classes treated atomic types attempt analyze 
show programs class hierarchy 
rst program student professor created professor student advisor person name professor assistant student advisor student student student student person address professor professor professor professor faculty professor professor assistant person professor student professor student lattice student professor example 
student advisor 
second program creates student professor student professor assistant 
example certainly perfect code looks reasonable rst glance 
shows lattice computed method class hierarchy example programs 
ignoring number details lattice may interpreted follows lattice elements concepts may viewed classes restructured class hierarchy precisely re ects usage original class hierarchy client programs 
ordering lattice elements may viewed inheritance relationships restructured class hierarchy 
variable type restructured class hierarchy occurs immediately concept lattice 
member occurs class appears directly concept lattice 
examining lattice interpretation reveals interesting facts data member person accessed variable appears 
illustrates situations subclassing inherit functionality class functionality 
labels student professor student professor appear lattice represent types heap objects created example programs various program points indicated figures comments 
data member person address students professors professors data member professor home address con information 
illustrates situation member base class derived classes 
members accessed parameters data members advisor assistant 
due fact operations performed student advisor professor assistant 
situations typical redundant incomplete erroneous code examined closely 
analyzed programs create professors hire assistants professor professors hire assistants professor 
seen fact method professor appears concept labeled professor concept labeled professor 
students advisors student students advisors student 
seen fact student appears concept labeled student concept labeled student 
class student constructor initialize advisor data member 
seen fact data member student advisor appear method student student lattice easily imagine information basis restructuring class hierarchy 
possibility tool automatically generate restructured source code information provided lattice similar approach taken 
redesign perspective believe interactive approach appropriate 
example programmer doing restructuring job may decide data member retained class hierarchy may needed 
interactive tool envision indicate moving lattice attribute consideration 
reengineer may decide certain ne distinctions lattice unnecessary 
example may decide necessary distinguish professors hire assistants professors don 
interactive tool distinction removed merging concepts professor professor 
useful capability interactive tool associate names lattice elements 
programmer done manipulating lattice names class names restructured hierarchy restructured source code generated 
example information provided lattice programmer may determine student objects method invoked graduate students student objects method called undergraduates 
consequently may decide associate names student concepts labeled student student respectively 
student student represents pointer method 
organization remainder organized follows 
section brie reviews relevant parts theory concept analysis 
section de ne objects attributes domain correspond rows columns tables 
process constructing tables section section discusses important properties lattice particular behavioral equivalence 
section presents extensions constructs type casts 
section discuss information provided lattice reveal problems design class hierarchies lattice basis interactive restructuring tools 
section describes prototype implementation java detail 
section discusses case studies 
section discusses related 
directions section 
concept analysis concept analysis provides way identify groupings objects common attributes 
mathematical foundation laid birkho 
birkho proved binary relation certain objects attributes lattice constructed provides remarkable insight structure original relation 
lattice transformed back original relation concept analysis similar spirit fourier analysis 
wille ganter elaborated birkho result transformed data analysis method 
variety applications including analysis software structures :10.1.1.54.4371
relations lattices concept analysis starts relation boolean table set objects set attributes set objects set common attributes de ned fa tg set attributes set common objects fo tg pair called concept informally concept corresponds maximal rectangle table attributes attributes objects important small medium large near far moon moon mercury venus earth mars jupiter neptune saturn mercury venus earth mars jupiter saturn neptune near moon small moon far large medium example table associated concept lattice 
note concepts invariant row column permutations table 
set concepts table forms partial order birkho proved set concepts constitutes complete lattice concept lattice 
elements concept lattice mum meet de ned supremum join concept extent ext intent int gures lattice element concept labeled attribute largest concept intent labeled object smallest concept extent 
unique lattice element labeled denoted unique lattice element labeled denoted 
fc int fc ext fundamental property establishes connection table lattice shows reconstructed attributes object appear objects appear attribute consequently join points suprema lattice indicate certain objects attributes common meet points ma show certain attributes common objects 
words join points factor common attributes meet points factor common objects 
lattice uncovers hierarchy clusters implicit original table 
shows table lattice taken 
element labeled far corresponds maximal rectangle indicated table 
element supremum elements far intent jupiter saturn neptune far lattice table con rms planets far away 
implications table lattice alternate views information serving di erent purposes providing di erent insights 
view set implications 
sets attributes 
say implies object attributes attributes fb holds implications show lattice follows holds ag 
informally implications attributes upward paths lattice 
example far moon read far moon planet far away moon 
examples implication near small near far large implication true premise contradictory 
minimal set implications valid implications derived implication base 
example consists implications including far moon moon near small non base implications far small moon small moon near derived propositional logic 
implications known hold priori 
background knowledge easily integrated table 
implication enforced copying entries column column cause 
general implication enforced copying intersection columns columns 
lattice construction table lattice implication basis represent di erent views information transformed furthermore background knowledge set implications may added 
section usually write fa fb note analogy fourier analysis function fourier transform di erent representations information transformed 
short description important transformation computation concept lattice table 
ganter algorithm lattice construction utilizes fact closure operator extensive idempotent monotone 
determines largest object set common attributes turns lattice elements extents precisely closed sets computed extents computed closure system fc og corresponding intents determined lattice partial order de ned complete 
ganter algorithm requires totally ordered numbering objects lexicographical order object sets 
algorithm enumerates object sets lexicographical order applies process starts determines extent bottom element 
extent lexicographical successors enumerated applied extent lexicographic order 
construction concept lattices implication bases typical time complexity table exponential worst case 
empirical studies show large tables exponential behavior extremely rare 
fact shown number attributes object bounded true applications lattice size linear number table entries 
practice ganter algorithm needs second element lattices standard workstation 
row column added table lattice original table sublattice lattice extended table new lattice constructed incrementally old 
minimal implication base constructed incremental manner 
algebraic decomposition structure theory concept lattices allows deeper insight original relation 
going details just mention important decomposition techniques horizontal decomposition possible lattice consists independent sublattices connected top bottom element 
called interferences ma sublattices horizontal decomposition possible interference removal 
congruences group lattice elements classes classes form lattice grouping related elements congruence class 
concept lattices allow particular elegant characterization congruences 
notion weak congruences called block relations congruences congruence class corresponds rectangle shape table 
subdirect decomposition tries construct lattice sublattice cartesian product smaller lattices 
ective algorithms subdirect decomposition exist 
say concept lattices related algorithms methodology 
davey priestley book contains chapter elementary concept analysis 
ganter wille treat topic depth 
objects attributes roughly speaking objects attributes domain variables class members respectively table constructed section identi es variable members included type 
de ne objects attributes precisely need introduce terminology 
follows denotes program containing class hierarchy collection programs share class hierarchy 
denote variables type class variables type pointer class treated similarly omit formalization 
expressions denoted 
henceforth variables refer variables parameters 
de nitions follow typeof denotes type expression objects domain program variables class hierarchy accessed 
variables type pointer built ignored class hierarchy accessed variables type class related variables type class pointer class 
de nition de nes sets variables type class pointer class respectively 
section discuss model heap allocated objects 
note includes implicitly declared pointers methods 
order distinguish pointers di erent methods henceforth refer pointer method fully quali ed name method de nition program 
set class typed variables set pointer class typed variables de ned follows variable typeof class variable typeof class attributes domain class members 
de nitions distinguish de nitions declarations members 
de ne terms follows de nition member comprises member signature interface executable code body declaration member represents signature 
distinction needed accurately modeling virtual method calls 
class public virtual int return virtual int return int class public public virtual int return int class public public virtual int return int int main ap 
ap 
ap ap ap return example program consider call virtual method pointer case declaration needs contained type order able invoke body need statically visible naturally de nition visible object points run time dynamic dispatch executed correctly 
de nition shown de nes sets member declarations member de nitions distinguish declarations de nitions virtual methods reasons stated 
methods making distinction necessary full de nition method statically visible caller 
methods modeled de nitions 
data members modeled declarations pointer members accessed 
de nition program 
de ne set member declarations member de nitions follows dcl jm data member virtual method class def jm virtual method class example shows program running example 
ap dcl dcl dcl dcl dcl dcl dcl def def def def objective identify smallest possible set member declarations de nitions included type variable 
including de nition type may lead incorporation members needed particular members accessed pointer 
section discuss class typed data members behave variables members accessed modeled 
table construction section describes tables lattices constructed 
recall purpose table record variable set members 
auxiliary de nitions rst section 
auxiliary de nitions variable need conservative approximation variables variables may point 
existing algorithms compute information assumptions particular algorithm compute points information :10.1.1.11.3368
de nition expresses information supplied points analysis algorithm set pointsto contains pair hp vi pointer may point class typed variable de nition program 
points information de ned follows pointsto hp vi may point example points information program recall denotes pointer method 
pointsto hap ai hap bi hap ci ha ai ha bi hc ci ha ai hb bi hb ci note simple algorithm suces compute information example pointer type assume may point object type class transitively derived ii pointer virtual method overriding de nitions visible class terminology function method calls 
direct call call function method invocation virtual method variable 
indirect call invocation virtual method variable requiring dynamic dispatch 
table entries member access operations table row element column element 
informally entry dcl appears declaration contained type entry def appears de nition contained type 
adding entries re ect member access operations program 
de nition de nes set pairs hm yi member accessed variable indirect call include element hf yi hp yi pointsto 
de nition program 
set member access operations de ned follows hm vi occurs class member hm pi occurs class member hm yi occurs hp yi pointsto virtual method example program hx gi hy gi hz fi hg fi hg fi hf api hf ai hf bi hf ci hg ai hg bi hg ci accessing class member entirely trivial operation di erent classes class hierarchy may contain members name signature 
furthermore presence multiple inheritance object may contain multiple subobjects type multiple members implies member accessed needs determine selected 
selection process de ned informally draft standard set rules determine member hides dominates member name 
friedman provided formalization member lookup function subobject graphs 
framework subsequently tip formal basis operations class hierarchies slicing specialization 
ramalingam srinivasan ecient algorithm member lookup 
purposes assume availability function static lookup class member determines base class transitive base class selected member located details function static lookup reader referred 
position state appropriate relations variables declarations de nitions added table static lookup de ned function subobject subobjects 
concerned classes members located simply ignore subobject information 
de nition program associated table entries added table due member access operations occur program 
hm yi static lookup typeof dcl hm yi static lookup typeof def hm yi static lookup typeof dcl hm yi static lookup typeof def table entries pointers table construction rule concerned pointers methods 
consider fact method column table labeled def row labeled express fact method may called objects 
necessary re ect members accessed method pointer 
precautions taken attribute def object may appear di erent points lattice def hold cases method ectively infers type pointer base class type method occurs constrained 
reality type method pointer determined class associated method de nition appears 
table entries added de nition force method attribute method pointer appear lattice element ensuring def 
allow remove rows pointers table constructing lattice 
de nition program 
entries added table def def see appendix 
dcl dcl def dcl dcl def ap table initial table program 
arrows indicate implications due assignments see section 
example table shows table program adding entries de nitions 
purpose arrows side table explained section 
table entries assignments consider assignment class typed variables 
assignment valid type base class type consequently member declaration de nition occurs type occur type 
enforce constraint implication row row formalizing notion assignment 
de nition de nes set assignments contains pair objects hv wi assignment class typed 
addition assignments contains entries cases type left hand side right hand side assignment pointer class 
parameter passing direct calls functions methods modeled way assignments corresponding formal actual parameters 
indirect call assignments contains additional elements model parameter passing direct call hp xi pointsto 
conservatively approximate potential targets dynamically dispatched calls 
set assignments contain elements implicit parameters pointers methods function method return values type class related 
de nition program 
set assignments variables type pointer class de ned follows assignments hv wi occurs wi occurs qi occurs wi occurs hv qi occurs qi occurs example program assignments ap ai ap bi ap ci ai bi ci ai bi ci position express elements added table due assignments 
de nition states implication tells elements copied row 
de nition program associated table implications encoded table due assignments occur hx yi assignments note assignment implications implications objects sense concept analysis assignment implication causes appear 
lattice 
cyclic assignments generate cyclic implications collapse corresponding lattice elements point involved variables type 
example program assignment implications generated ap ap ap implications indicated left side table 
table obtained copying elements source row target row implications 
table entries preserving dominance hiding table far encodes variable members contained type directly member accessed variable indirectly due assignments variables 
original class hierarchy object type may contain dcl dcl dcl dcl def ap table table application assignment implications 
arrows indicate implications preserving hiding dominance members name see section 
member name 
cases member lookup rules determine member accessed 
expressed set rules determine member hides dominates member name 
cases variable contains members hiding relationship original class hierarchy hiding relationship preserved interested generating restructured hierarchy table member access operations program ambiguous 
de nition incorporates appropriate hiding dominance relations table implications attributes de nition program associated table implications incorporated order preserve hiding dominance dcl dcl transitive base class dcl dcl dcl def transitive base class def dcl def def transitive base class def def class class ect dominance rules def def dcl ap dcl def dcl dcl ap dcl def dcl def dcl def final table lattice program removing rows labeled 
def dcl transitive base class dcl def dominance implications implications attributes sense concept analysis dominance implication cause appear lattice 
due condition transitive base class dominance implications connect subclass members superclass members contain cycles point cycle generated 
note symmetry dominance implications assignment implications implications columns attributes serve preserve behavior member lookup implications rows objects serve preserve behavior subobject selection 
demonstrates ect dominance rules subclass class rede nes method table implication due assignment forces row added row member access ambiguous row contains entries dominance rules implication generated adds entry table 
corresponding lattice element chain reproduces original hierarchy dominance example program dominance implications generated def dcl def dcl def dcl dcl dcl def dcl def dcl implications shown bottom table 
incorporating implications table results 
observe implication def dcl necessary propagating table elements implications 
new hierarchy lattice construction assignment implications generate new dominance implications vice versa xpoint iteration necessary order compute nal table 
algorithm described section 
table converged lattice constructed ganter algorithm see section 
explained directly new class hierarchy 
issue concerning pointers deserves mentioning 
recall section table entries added ensure method de nitions pointers show lattice element 
order avoid presenting redundant information user henceforth omit pointers lattice 
easiest way accomplish remove rows pointer variables table prior generating lattice 
note rows pointers left table construction needed model member accesses pointers elements rows may involved implications due assignments dominance 
example shows lattice program generated nal table removing rows labeled lattice interpreted directly new class hierarchy 
demonstrates access access access similarly lattice shows ne grained di erences method access example need def def 
receive new types 
program statements unchanged new hierarchy smaller 
note space optimization viewpoint lattice simpli ed example topmost elements merged contain method declarations edge def merged parallel edge 
tip sweeney discuss peephole optimizations detail 
properties lattice lattice concept lattice enjoys important properties 
lattice smallest lattice compatible table lattice compatible table 
fact table represents partial order lattice dedekind mcneill completion partial order 
lattice minimal 
attribute labels lattice elements occur far upward lattice possible see section 
attribute labels correspond members classes new hierarchy common members factored possible 
applies common variables factored downwards possible 
lattice maximally factorized 
important minimality maximal factorization semantic properties lattice 
proved assignment constraints dominance constraints guarantee preservation assignment behavior assignment select subobject right hand side object original program preservation lookup behavior method call select method de nition dynamic lookup original program 
lattice interpreted new class hierarchy respects assignment dominance constraints construction 
statements program unchanged guarantee new hierarchy operationally equivalent old 
lattice may contain elements labelled attribute object center element gure 
elements called empty serve merely group members classes 
application empty element corresponds class members variable type new hierarchy 
section explain get rid empty elements 
remember rows pointer removed nal table semantic ect 
similar simpli cation applied pointers general 
lattice may ne grained due access patterns pointers basically type access di erent members 
pointer appear object may point see proof appendix rows pointers safely removed nal table 
pointers type objects point guarantees operational equivalence pointer may access members needs course pointer rows essential table generation explained special case pointers 
nal lattice depend precision points analysis 
points analysis computes conservative approximation di erent analyses di er respect row entries generate pointer variables precise points analysis entries pointer row 
table precisely pointer supremum type object types may point supremum exists reduced lattice pointer type full lattice 
class public student elem address lookup long sid elem sid return elem address return lookup sid dcl person address dcl student sid elem def lookup dcl dcl elem elem sid lookup analyzing linked list students generated precise points analysis table fundamental property order embedded 
possible pointer row superset minimal row pointer corresponds undecidable limit case precise points analysis 
embedding lattice limit case substructure actual lattice 
language details basic process constructing tables lattices described previous section address number language features core issues practice 
section addresses number issues 
heap allocation handle heap allocated objects straightforward way simply treating allocation site program class typed variable element set program allocation sites refer student student professor professor 
principle sophisticated context sensitive analyses distinguish heap allocated objects di erent calling contexts expect bene ts additional precision limited 
modeling nested objects treatment class related data members data members type class related student advisor important issue 
data members builtin types class related data members accessed variables modeled attributes 
members may accessed class related data member data members play alternate role objects 
order clarify issues involved reengineering nested structures consider class contains data member type class information explicit concept lattice set variables contained 
modeled treating attribute object occurs lattice contains set members contained type modeled treating type object set members contained correspond attributes occur lattice 
set members subset members original class hierarchy 
note attribute view corresponds exactly way previously modeled data members built type object view corresponds exactly way previously modeled variables 
de nitions concerned variables apply class related data members convenience henceforth assume term variable include class related data members 
shows example program illustrates issues related class related data members 
example extended linked list students 
observe data members address accessed elem member student list lookup method class accessed data member 
data members elem accessed method lookup pointer note usual table entry added associated method definition lookup 
furthermore assignment implication lookup due recursive call 
shows table applying implication shows associated lattice 
call left element student right element suggested labels 
resp 
elem show twice lattice 
student shows type elem student shows member elem located class similar observations valid located type expected 
example illustrates dual role class typed data members lattice display type position class hierarchy 
modeling constructors constructors require special attention 
constructor generally initializes data members contained object 
constructor provided user called default constructor generated compiler performs necessary initializations 
compiler may generate call constructor certain cases 
modeling compiler generated actions member access operations lead believe member class needed instances cases access class class extends class extends class example public static void main string args new instanceof reached instanceof succeeds class boolean isa return false boolean isb return false toa throw new tob throw new class extends boolean isa return true toa return class extends boolean isb return true tob return class example public static void main string args new isa reached isb toa succeeds tob example java program uses type cast instanceof operations 
equivalent java program transforming away instanceof cast operations 
consists default initialization 
compiler generated constructors compiler generated initializations compiler generated calls constructors excluded set member access operations 
destructors handled similarly 
type casts instanceof operations modern object oriented languages java provide language features testing run time type object casting object derived type 
operations heavily realistic implementation need deal 
approach dealing type cast instance operations transform semantically equivalent piece code consisting virtual method calls exception handling constructs 
outline transformations cast instanceof operations java 
java operations semantics expression instanceof evaluates true run time type object pointed subclass expression evaluates false 
cast expression evaluates expression static type run time type subclass exception type thrown 
strategy transforming instanceof expressions follows type introduce method isc root class hierarchy 
method return type boolean default de nition isc class returns false 
class provides overriding de nition isc returns true 
expression form instanceof transformed isc 
see easily expressions instanceof isc return true exactly conditions 
cast expressions transformed similar manner 
type introduce method toc root class hierarchy 
method return type default de nition isc class throws exception type 
class provides overriding de nition toc returns 
expression form transformed toc 
easily seen expressions toc succeed exactly conditions 
shows example program containing various instanceof cast expressions 
shows program transforming away expressions 
eliminating cast instanceof expressions resulting program processed techniques previous section 
generating lattice arti cial isc toc methods easily transformed back cast instanceof operations reengineer desires 
example outline toc methods transformed back cast operations transformed class hierarchy 
lattice element labeled def toc suppose class name associated lattice element 
toc transformed exceptions exception handling constructs give rise additional control ow uence member access patterns 
exceptions require special treatment 
note abundance implicit explicit exceptions java complicates pointsto analysis think adopting factored control ow graphs analysis 
arrays arrays treated monolithic variables distinguish di erent array elements 
think integrating ne grained array analysis omega test 
ne grained array analysis may reduce analysis precision case mixed contravariance 
java arrays covariant implies 
java allow fully contravariant method overriding transformation proposed 
cases target type interface overriding de nition placed classes implement dom fa dom fb method rede ned kaba translates array accesses prede ned method calls store access 
contravariance store second argument obtain dom store dom store suddenly collapsing lattice elements hiding ne grained access patterns 
dynamic class loading java ers mechanism dynamic loading classes re ective devices 
example compute name class runtime create object class 
naturally analysis handle features worst case assumptions 
order avoid massive loss analysis precision option rely additional user input reengineer supply background knowledge expected outcome dynamic constructs 
course reengineer assumptions false operational equivalence lost 
multiple subobjects object contains multiple subobjects type due multiple inheritance tables distinction various copies members leads problems objective generate new hierarchy lattice distinct copies members preserved 
consider minor problem situations inheritance member replicating ect quite rare practice restructuring tool inform user cases problem occurs 
clean solution problem involve encoding subobject information table adaptation approach 
restructuring class hierarchies students professors reconsidered table shows nal table example obtained analyzing class hierarchy example programs 
lattice corresponding table shown previously note replaced member de nitions corresponding method names convenience 
learned lattice data members accessed program person appear bottom element lattice 
transformation similar transformations instanceof expressions described 
professor professor dcl person address student dcl person name dcl person dcl student dcl student advisor dcl professor faculty professor professor advisor assistant student student student student professor table final table student professor example 
data members base class instances derived classes revealed 
data members person address appear variables derived classes example person address appears instances student instances professor 
variables members accessed appear top element lattice 
data members properly initialized appear constructor method supposed initialize 
case data member may initialized 
example know student student initialize student advisor data member appear student student lattice 
situations instances type access di erent subsets members revealed fact variables type appear di erent points lattice 
example contains examples phenomenon 
instances professor professor type professor instances student student type student 
mentioned earlier class hierarchy may analyzed number programs program 
case may provide insights internal structure class library 
shows lattice obtained analyzing class hierarchy programs code method bodies analyzed 
clearly resulting lattice interpreted restructuring proposal re ect usage class hierarchy 
interesting things note 
example accessed 
know addition private accessed methods class inform user ectively dead 
observe members accessed method parameters scope variables local library know analyzing additional code change situation 
restructuring transformations lattice computed displayed help understanding actual behaviour class hierarchy serve basis restructuring tasks see section 
addition global restructuring transformations possible unlabeled empty lattice elements correspond classes members variables 
lattice simpli ed pruning elements directly connecting subordinate superordinate neighbors 
resulting structure lattice anymore partial order important class hierarchy need partial order lookup behavior student professor assistant student advisor professor assistant person name professor student student person person address person professor professor professor professor faculty student advisor lattice obtained analyzing class hierarchy accompanying programs 
subobjects ected 
case studies show percent lattice elements empty 
reduced lattice shown contains real objects pointers 
lattice obtained deleting pointer rows just pointers nal table 
reengineering purposes lattice appropriate ne grained ultimately objects access members determine optimal class structure ne grained behavior pointers helpful picture 
resulting lattice theory concept lattices sublattice original operationally equivalent 
case studies show percent lattice elements disappear removing pointer rows 
user decide merge adjacent lattice elements distinction concepts irrelevant possibly lattice re ects speci hierarchy 
example may decide distinction professors hire assistants professors hire assistants irrelevant merge concepts professor professor 
issues tool take account want preserve member lookup behavior 
example merging concepts di erent de nitions virtual method associated possible occur class 
general merging respect dominance constraints members 
certain limitations user may move attributes upwards lattice object downwards 
example user may decide retained restructured class hierarchy move corresponding attribute concept labeled attribute person name 
dominance constraints respected 
remember construction pointers appear objects point 
background knowledge re ected lattice type base class type integrated background implications 
technically background implications treated way dominance implications 
color display relevant substructures lattice display variables type members class 
associations sense omt recovered occurrences members corresponding arcs added lattice 
large class hierarchies tool allow user focus selected subhierarchy specifying minimal maximal elements lattice selecting speci rows columns table belonging speci class 
structure theory concept lattices ers algebraic decompositions horizontal decomposition interference analysis block relations see section 
measure quality factors cohesion coupling 
eventually user may associate names lattice elements 
reengineer done manipulating lattice names class names restructured hierarchy 
example examining lattice programmer may determine student objects method invoked graduate students student objects method called undergraduates 
consequently may decide associate names student concepts labeled respectively 
source code generated new hierarchy utilizing reduced object memory requirements improved structure new hierarchy 
dealing multiple inheritance analysis results form lattice naturally contain multiple inheritance interpreted class hierarchy 
java support multiple inheritance generated hierarchies may representable java source code 
note meet point superclasses fact interface classes representation problem 
note multiple inheritance problem method program transformation lattice serves program understanding 
introducing certain loss precision multiple inheritance removed follows 
occurence multiple inheritance leads diamond structure lattice diamond assistant 
moving members variables explained diamond simple chain maintaining behavioral equivalence 
moved moved assistant 
lattice element labeled removed empty 
implementation prototype implementation method completed 
tool named kaba written java analyzes java class les 
approach advantage front needed 
furthermore java easier analyze 
cfg points analysis tool rst reads required class les builds control ow graph cfg 
java byte code stack oriented analysis needs full variable anonymous stack entries simple backwards analysis reconstructs stack contents necessary 
certain point cfg need know type example third entry top stack explore cfg paths backwards push operations encountered backward path collect items pushed stack third push operations 
usually resulting sets unique 
points analysis andersen method described 
method quite precise expensive worst case time complexity space intensive practice 
fact points analysis turns bottleneck analysis 
points analysis originally designed imperative languages extend object oriented languages 
particular treatment virtual dispatch requires special attention 
details andersen steensgaard method described 
roughly dynamic dispatch modeled follows 
method call encountered interprocedural iteration steps performed 

fo 
fx xm points information obtained far encoded points graph 
static lookup resolve calls 
note real objects considered java correspond call sites constructor functions see 

methods identi ed static lookup 
add edges required assignments points graph 
furthermore add edges required implicit assignment pointer kaba mit class analysis concept analysis 
kaba popular chocolate drink germany 

case type class variables representing return values inside method 
assignment similar return value add edges required assignment points graph 

continue propagation points information 
generation table entries implication propagation table implemented list bit strings points analysis converged entering member access entries table straightforward 
assignment dominance implications extracted 
extracting dominance rules quite expensive classes columns row checked double entry 
assignment implications dominance implications arranged directed graphs 
assignment graph may contain cycles dominance graph dominance edges go members lower classes members upper classes original class hierarchy course cycle free 
note set assignment implications changes new dominance implications generated applying assignment implications 
dominance graph grow implication propagation 
reason method applying implications table point iteration 
assignment dominance implications applied alternatively 
local iteration applies assignment resp 
dominance implications converged 
global iteration alternates local assignment dominance iterations 
implication propagation proceeds topological order propagates cycle cycle converges 
dominance graph cycle free corresponding local iteration converges immediately 
iteration special instance set analysis implication corresponds set constraint resp 
cycles collapsed described 
application speci assignment implication implemented eciently bitstring operation 
interactive back nal table lattice computed algorithm 
theshelf graph compute initial layout lattice 
lattice displayed interactive back 
lattice layout may modi ed manually system maintains lattice integrity 
options display lattice elements labels labels individual labels request labels user de ned entities 
kaba prototype ers reengineering transformations section removal empty lattice elements reduced lattices pointers highlighting professor professor faculty professor assistant def professor 
samples example person name student def student 
person address samples example dcl professor samples example def student student advisor samples example def professor samples example person dcl student samples example java version student professor example variables original type recovery associations 
interactive lattice manipulation code generation supported 
case studies students professors nally kaba applied small medium sized java programs 
reconsideration student professor example see order illustrate di erences java 
presents screenshot 
data members appear fully quali ed name method de nitions distinguished method declarations 
names names real objects heap allocation sites constructor methods named 
methods displayed full name signature signatures shown overloaded methods 
top bottom element enlarged layout reasons 
rst observation lattice di erent 
bug screenshot displays analysis java version 
java methods virtual non virtual 
table construction rules receivers virtual methods need see method declaration de nition professor needs visible 
consequently data member professor assistant need visible 
corresponding table entry created distinction rightmost lattice elements disappears 
lattice graph editor program gnu regexp retoken gnu regexp gnu regexp original class hierarchy jedit program argument applies student advisor original lattice contain distinction anyway due missing initialization student advisor constructor see section 
result subtle phenomenon java version lattice completely symmetrical indicating lower semantic complexity java vs 
easy case example graph editor program loc comments completely class structure 
purpose experiment see kaba proposes introduce inheritance specialized subclasses 
lattice horizontally decomposable small sublattices sublattice corresponds original class 
internal structure sublattices comes ne grained pointer access patterns interpreted option split classes particular substructure lattice local bottom element indicator potential introducing inheritance splitting classes low 
reduced lattice pointers replicates original hierarchy 
kaba demonstrates original class design 
example shows approach useful reengineering ongoing quality assurance development con rm class design ok org gjt sp jedit jedit gnu regexp retoken gnu regexp org gjt sp jedit buffer org gjt sp jedit gui gnu regexp org gjt sp jedit syntax org gjt sp jedit gnu regexp gnu regexp org gjt sp jedit mode gnu regexp gnu regexp gnu regexp re org gjt sp jedit gui org gjt sp jedit org gjt sp jedit view gnu regexp org gjt sp jedit gnu regexp org gjt sp jedit gnu regexp org gjt sp jedit view gnu regexp gnu regexp org gjt sp jedit gui options org gjt sp jedit marker org gjt sp jedit gnu regexp org gjt sp jedit syntax org gjt sp jedit server gnu regexp gnu regexp gnu regexp org gjt sp jedit gui org gjt sp jedit syntax token org gjt sp jedit syntax org gjt sp jedit syntax gnu regexp gnu regexp subhierarchy regular expression library def gnu regexp get dcl gnu regexp get gnu regexp bits dcl gnu regexp retoken def gnu regexp retoken dcl gnu regexp retoken dcl gnu regexp retoken match gnu regexp retoken uncle gnu regexp retoken gnu regexp retoken dcl gnu regexp retoken def gnu regexp retoken dcl gnu regexp retoken dcl gnu regexp retoken dump def gnu regexp retoken 
dcl gnu regexp move dcl gnu regexp dcl gnu regexp lattice jedit gnu regular expression library example jedit text editor useful features syntax coloring regular expression search jedit heavy java adaption gnu regular expression library seen instance scenario hierarchy di erent applications 
shows original hierarchy classes shipped jedit 
separate subsystems visible concerned input modes editor commands editor modes regular expressions syntax highlighting 
singleton classes inheritance relationship provide basic auxiliary functionality 
original 
jedit contains classes loc 
shows classes original hierarchy constitute regular expression library classes containing loc 
superclass retoken subclass regular expression construct 
programming interface class re subclass retoken 
reduced lattice computed kaba consists independent substructures correspond subsystems original hierarchy 
original singleton classes input mode subsystem recur exactly right hand part lattice showing reengineering potential 
interesting leftmost part lattice represents regular version nal available www gjt org sp jedit html example reduced lattice show ne grained access patterns pointers just real objects 
explained section ne grained pointer access patterns really relevant reengineering reduced lattice guaranteed operationally equivalent 
full lattices example twice size reduced lattices 
dcl gnu regexp retoken def gnu regexp retoken dcl gnu regexp retoken dcl gnu regexp retoken match gnu regexp retoken uncle gnu regexp retoken gnu regexp retoken dcl gnu regexp retoken def gnu regexp retoken dcl gnu regexp retoken dcl gnu regexp retoken dump def gnu regexp retoken 
def gnu regexp re tostring def gnu regexp re def gnu regexp re match dcl gnu regexp re match gnu regexp re gnu regexp re def gnu regexp re gnu regexp re def gnu regexp re dump dcl gnu regexp re dump def gnu regexp re dcl gnu regexp re def gnu regexp re dcl gnu regexp re def gnu regexp re java lang object int gnu regexp int int def gnu regexp re dcl gnu regexp re def gnu regexp re chain dcl gnu regexp re chain def gnu regexp retoken def gnu regexp re dcl gnu regexp re def gnu regexp re java lang object gnu regexp dcl gnu regexp re java lang object gnu regexp def gnu regexp re java lang object int int gnu regexp dcl gnu regexp re java lang object int int gnu regexp def gnu regexp re java lang object int int java lang stringbuffer gnu regexp dcl gnu regexp re java lang object int int java lang stringbuffer gnu regexp def gnu regexp re java lang object int gnu regexp org gjt sp jedit gui 
def gnu regexp retoken chain dcl gnu regexp retoken chain def gnu regexp re dcl gnu regexp re def gnu regexp re substitute java lang object java lang string java lang string dcl gnu regexp re substitute java lang object java lang string java lang string def gnu regexp re substitute java lang object java lang string int int java lang string dcl gnu regexp re substitute java lang object java lang string int int java lang string org gjt sp jedit jedit gnu regexp re 
def gnu regexp retoken def gnu regexp re gnu regexp retoken gnu regexp retoken int int details jedit regular expression classes expressions library subclasses retoken 
complex structure 
right part structure labels shown represents classes di erent regular expression constructs ne grained di erent constructs need di erent parts retoken functionality 
subclasses original base class retoken just reproduced kaba 
original subclass re distributed di erent nodes left part 
look source code reveals class labeled gui api search substitution class api search including substitution 
note lattice displays nest possible splittings refactorings classes possible program behaviour 
reengineering purposes lattice simpli ed merging lattice elements order re ect software design principles 
lattice demonstrates original re class split say re substitution re substitution 
element labeled gnu regexp re dump reveals composite design pattern class re stands complex regular expression ers method accessing subexpressions subclasses retoken right part represent elementary regular expressions 
original class hierarchy jas example 
lattice jas jas example jas java bytecode assembler including scheme scripting language loc original class hierarchy shown 
various single classes small inheritance trees shows huge structure classes 
classes part scripting language implementation 
top class called obj subclasses additionally implement interface procedure 
subclasses represents function add sub scripting language 
kaba lattice huge structure reproduced basically unmodi ed con rming original design 
base class insn interesting 
subclasses insn just rede ne constructor method subclasses reproduced unchanged 
rightmost chain gure contains members original subclass label di ers subclasses methods insn size insn write 
closer look reveals subclasses dealing implementation certain bytecode instructions label concerned bytecode addressing 
implementations size write label empty methods considered 
closer look reveals method execute useful code called label object 
demonstrates original subhierarchy restructured label share code subclasses need common base class 
sublattice subclasses class show similar phenomenon 
classes left hand side separated rest just label 
implementations method subclasses share implementation 
look source code reveals subclasses dummy implementation functionality separated classes left version available www org jas html 
dcl jas insn write dcl jas insn size def jas insn resolve jas insn operand jas insn opc def jas insn write def jas insn size 
def jas insn 
def jas insn 
def jas label def jas label write def jas label tostring def jas label size jas label id def jas label 
def jas label 
def jas label 
details jas substructure insn code 
demonstrates removed put new class base class separated classes 
additional remarks additional experiments described master thesis 
preliminary experience experiments summarized follows kaba prototype may need hours loc pc 
plan switch native code compiler better garbage collector expect able analyse loc reasonable time standard workstation 
bottleneck initial points analysis consumes total analysis time 
implementation supposedly faster precise steensgaard algorithm adapted java faster practice due necessary conservative approximation dynamic binding 
java programs explicated reasonable structure high reengineering potential probably due fact programs quite young 
cases lattice serve quality metrics demonstrating architecture 

dcl jas dcl jas write dcl jas size dcl jas resolve def jas 
def jas def jas write jas vindex def jas size def jas resolve jas def jas 
jas 
def jas def jas write jas val def jas size def jas resolve def jas 
jas insn int int 
details jas substructure java examples possibilities split refactor classes 
proposals guaranteed alter program behavior possible unique combination points analysis type constraints concept lattices 
kaba experimental option member accesses dead code entered table 
greatly reduces size lattices examples 
reengineering viewpoint questionable exclude dead code just questionable delete dead members 
exploit structure theory concept lattices particular congruences weak congruences 
weak congruence classes serve proposals group classes packages measure coupling cohesion resulting substantial restructuring proposals 
full set reengineering transformations section available prototype incomplete 
course real market method big old programs 
complexity language method prohibit application right 
hope situation change years 
related applications concept analysis godin mili concept analysis class hierarchy re design 
starting point approach set interfaces collection classes 
table constructed speci es interface set supported methods 
lattice derived table suggests design class hierarchy implementing interfaces organized way optimizes distribution methods hierarchy 
godin mili formal basis domains consideration di erent 
relations members classes studied order improve distribution members class hierarchy 
contrast study members class hierarchy executable code set applications examining relationships variables class members relationships class members 
application concept analysis domain software engineering analysis software con gurations 
snelting uses concept analysis analyze systems preprocessor cpp con guration management 
relation code pieces governing expressions extracted source le corresponding lattice visualizes interferences con gurations 
lindig proved con guration space isomorphic lattice inverted relation 
concept analysis modularization old software 
si reps investigated relation procedures features usage global variables types :10.1.1.54.4371
modularization achieved nding elements lattice intent partitions feature space 
lindig snelting analyzed relation procedures global variables legacy fortran programs 
showed presence module candidates corresponds certain decomposition properties lattice si reps criterion special case 
class hierarchy specialization application extraction closely related class hierarchy specialization tip sweeney 
class hierarchy specialization space optimization technique class hierarchy client program transformed way client space requirements reduced run time 
method shares basic information gathering steps method subsequent steps method quite di erent 
determining member access assignment operations program set type constraints computed capture subtype relationships variables members retained 
type constraints roughly correspond information encoded tables contrary current approach correctly distinguish multiple subobjects type 
type constraints new class hierarchy generated de nitions taken 
automatically 
separate step resulting class hierarchy simpli ed repeatedly applying set simple graph rewriting rules 
addition di erences underlying algorithms method di ers reengineering framework number ways 
class hierarchy specialization optimization technique require intervention user 
contrast current presents interactive approach analyzing usage class hierarchy order nd design problems 
reducing object size elimination members possible necessarily objective 
purpose restructuring may case unused member retained restructured class hierarchy 
framework allows analysis class hierarchy number programs including 
class hierarchy specialization customizes class hierarchy single client application 
application extraction techniques eliminating unused components hierarchies objects literature 
primarily intended optimizations may value program understanding 
describe algorithm dynamically typed language self eliminates unused slots objects slot corresponds data member method inheritance relation 
self dynamically typed language eliminating members objects involve transforming class hierarchies 
algorithm slicing class hierarchies eliminates members inheritance relations hierarchy 
class slicing powerful specialization remove member class instance 
tip sweeney developed jax incorporates rapid type analysis additional simpli cations 
jax reduce size class les 
techniques restructuring class hierarchies category related techniques restructuring class hierarchies sake improving design improving code reuse enabling reuse 
overview article presents di erent methods process centered dynamic analyses 
probably known method static restructuring introduced opdyke johnson 
number behavior preserving transformations class hierarchies refer refactorings 
goal refactoring improve design enable reuse factoring common abstractions 
involves steps creation new superclasses moving methods classes hierarchy number similar steps 
techniques analyzing usage class hierarchy nd design problems opinion complimentary techniques 
moore presents tool automatically restructures inheritance hierarchies methods self programs 
goal restructuring maximize sharing expressions methods sharing methods objects order obtain smaller programs improved code reuse 
moore studying dynamically typed language explicit class de nitions number complex issues related preserving appropriate subtype relationships types variables arise setting 
interesting approach 
argues evolutionary viewpoint subclasses may add rede ne members loose members 
approach violates fundamental type theoretic properties object oriented programming advantage known algorithms reconstruction biological taxonomies 
argues hierarchies natural stick principles type conformance contravariance 
method nding design problems class hierarchy analyzing usage hierarchy set applications 
method constructs concept lattice relationships variables class members explicit information members variables common factored 
shown technique capable nding design anomalies class members redundant moved derived class 
addition situations appropriate split class detected 
suggested techniques incorporated interactive tools maintaining restructuring class hierarchies 
analysis expensive analysis object oriented programs available moment 
powerful methods due unique combination points analysis type constraints concept lattices 
method includes classic analyses dead members useless variables special cases 
preliminary case studies indicated usefulness analysis basis reengineering method quality initial development 
turned java examples analysed reasonably structured method discovered possibilities refactoring time guaranteeing program behavior unchanged 
article focused foundational aspects preliminary case studies 
concentrate questions scale apply method large programs better interactive support restructuring particular moving members variables merge lattice elements integrate background knowledge utilizing structure theory concept lattices eventually develop version 
course big old programs real market method 
remains seen ecient implementation full achieved 

andreas great job prototype implementation help experiments improving prototype 
supported deutsche forschungsgemeinschaft sn 
information processing systems accredited standards committee 
working draft proposed international standard information systems programming language 
doc 

draft november 
ole agesen david ungar 
sifting gold delivering compact applications exploratory object oriented programming environment 
proceedings ninth annual conference object oriented programming systems languages applications oopsla pages portland 
acm sigplan notices 

maximizing object reuse biological metaphor 
theory practice object systems 
david bacon peter sweeney 
fast static analysis virtual function calls 
proceedings eleventh annual conference object oriented programming systems languages applications oopsla pages san jose ca 
acm sigplan notices 
gary birkho lattice theory 
american mathematical society 
andreas 
kaba reengineering class hierarchies concept lattices 
master thesis technische universit braunschweig germany may 
eduardo 
reengineering object oriented legacy systems 
journal objectoriented programming pages january 

choi burke carini 
ecient ow sensitive interprocedural computation pointer induced aliases side ects 
conference record twentieth acm symposium principles programming languages pages 
acm 
choi grove hind sarkar 
ecient precise modelling exceptions analysis java programs 
proc 
paste 
acm 
appear 
davey priestley 
lattices order 
cambridge university press 
manuel ahndrich je rey foster su alexander aiken 
partial online cycle elimination inclusion constraint graphs 
proceedings acm sigplan conference programming language design implementation pages montreal canada june 
acm sigplan notices 
funk gregor snelting 
algorithms concept lattice decomposition applications 
technical report tu braunschweig fb informatik 
bernhard ganter rudolf wille 
formal concept analysis mathematical foundations 
springer verlag 
robert godin mili 
building maintaining analysis level class hierarchies galois lattices 
proceedings eighth annual conference object oriented programming systems languages applications oopsla pages washington dc 
acm sigplan notices 
robert godin mili guy mineau missaoui ar chau 
design class hierarchies concept galois lattices 
theory practice object systems 
krone gregor snelting 
inference con guration structures source code 
proceedings international conference software engineering icse pages sorrento italy may 
christian lindig 
analyse von 
technical report tu braunschweig fb informatik 
christian lindig gregor snelting 
assessing modular structure legacy code mathematical concept analysis 
proceedings international conference software engineering icse pages boston ma may 
ivan moore 
automatic inheritance hierarchy restructuring method refactoring 
proceedings eleventh annual conference object oriented programming systems languages applications oopsla pages san jose ca 
acm sigplan notices 
opdyke johnson 
creating superclasses refactoring 
acm computer science conference 
william opdyke 
refactoring object oriented frameworks 
phd thesis university illinois urbana champaign 
pande barbara ryder 
data ow virtual function resolution 
proceedings third international symposium static analysis sas pages september 
springer verlag lncs 
william pugh david 
constraint array dependence analysis 
acm transactions programming languages systems may 
ramalingam srinivasan 
member lookup algorithm 
proceedings acm sigplan conference programming language design implementation pages las vegas nv 
jonathan jr daniel friedman 
algebraic semantics subobjects 
proceedings tenth annual conference object oriented programming systems languages applications oopsla pages austin tx 
acm sigplan notices 
marc shapiro susan horwitz 
fast accurate ow insensitive points analysis 
conference record fourth acm symposium principles programming languages pages paris france 
si reps identifying modules concept analysis 
proc 
international conference software maintenance pages bari italy 
gregor snelting 
reengineering con gurations mathematical concept analysis 
acm transactions software engineering methodology april 
gregor snelting 
concept analysis new framework program understanding 
proc 
acm sigplan sigsoft workshop program analysis software tools engineering paste pages montreal canada june 
acm sigplan notices 
gregor snelting frank tip 
reengineering class hierarchies concept analysis 
proc 
acm sigsoft symposium foundations software engineering pages orlando fl november 
bjarne steensgaard 
points analysis linear time 
proceedings third acm symposium principles programming languages pages st petersburg fl january 
gregor snelting 
points analysis object oriented languages 
technical report universit passau fakult ur informatik 
preparation 
frank tip jong deok choi john field ramalingam 
slicing class hierarchies 
proceedings eleventh annual conference object oriented programming systems languages applications oopsla pages san jose ca 
acm sigplan notices 
frank tip chris la ra peter sweeney david streeter 
practical experience application extractor java 
proc 
oopsla denver november 
appear 
frank tip peter sweeney 
class hierarchy specialization 
proceedings twelfth annual conference object oriented programming systems languages applications oopsla pages atlanta ga 
acm sigplan notices 
frank tip peter sweeney 
class hierarchy specialization 
technical report rc ibm watson research center february 
submitted publication 
rudolf wille 
restructuring lattice theory approach hierarchies concepts 
ordered sets pages 
appendix appendix demonstrates method pointer appear lattice arbitrary pointers appear object point 
lemma 
proof 
true concept lattice construction 
lemma 
def def proof 
preceding lemma def def furthermore def method call table entry exist 
method call causes implicit assignment pointer generating assignment dominance enforces 
true calling true supremum def combining statements obtain def 
lemma shows method appears pointer rule appear di erent elements lattice method access non recursive 
rule enforces def lemma may conclude 
proposition 
def def methods pointers appear lattice 
pointers general weaker result established pointer appears object may point 
proposition 
hp vi pointsto proof 
proof member shorthand def dcl 
basic properties concept lattices show implication force 
de nition implies hm pi occur hp vi pointsto de nition case hm vi 
