characterizing memory requirements queries continuous data streams arvind arasu brian babcock babu jon jennifer widom stanford university deals continuous conjunctive queries arithmetic comparisons optional aggregation multiple data streams 
algorithm determining query evaluated bounded amount memory possible instances data streams 
queries evaluated bounded memory execution strategy constant sized synopses data streams proposed 
queries evaluated bounded memory data stream scenarios identified evaluating queries requires memory linear size unbounded streams 
categories subject descriptors database management systems query processing general terms algorithms performance theory additional key words phrases continuous queries memory requirement streams 
applications data takes form continuous unbounded data streams finite stored data sets gehrke ozsu babcock 
examples data streams include stock ticks financial applications performance measurements network monitoring traffic management log records click streams web tracking personalization data feeds sensor applications network packets messages firewall security call detail records telecommunications 
due continuous nature data streams typically queried longrunning continuous queries traditional time queries 
continuous query query logically issued run forever 
point time answer continuous query reflects elements input data streams seen far answer updated new stream elements arrive 
example continuous queries network packet streams monitor network behavior detect anomalies link congestion cause author address arasu stanford university room gates building serra mall stanford ca 
supported national science foundation iis iis foundation research 
permission digital hard copy part material fee personal classroom provided copies distributed profit commercial advantage acm copyright server notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
yy acm yy acm transactions database systems vol 

month yy pages app 
arvind arasu 
hardware failure intrusion denial service attack cranor 
financial applications continuous queries stock tick data news feeds historical data monitor trends detect opportunities 
continuous query processing introduces interesting new challenges seen traditional time query processing 
article addresses fundamental challenges stems unbounded nature input streams characterizing worst case memory requirements continuous queries 
query deals continuous queries omit term continuous rest typically store state input stream elements seen far 
example query computes join streams remember elements streams seen far new stream element join previous elements stream window joins discussed section 
hand simple filter query need maintain historical state 
note term memory mean sort storage results apply equally systems resident main memory secondary storage 
proves interesting results memory requirements queries 
proves queries consider conjunctive queries optional aggregation fall just classes asymptotic memory requirements queries evaluated bounded memory finite amount memory require memory grows linearly input data 
focused distinguishing class queries evaluated bounded memory 
note concerned exact evaluation queries exist queries aggregates involving quantiles example approximately evaluated memory grows logarithmically input data greenwald khanna 
thought simple filter queries evaluated bounded memory 
second interesting result shown relatively large class queries including queries join arbitrary number streams computed bounded memory 
class queries computable bounded memory admit trivial characterization illustrate examples 
examples set example queries shown table data streams example queries 
domain attributes set integers 
standard relational algebra minor modifications represent queries 
specifically denotes duplicate eliminating projection operator duplicate preserving projection operator selection operator cross product operator 
place holder 
answer continuous query point time answer relational semantics bag input stream tuples seen far 
assume query evaluation system need store answer query stream tuples answer generated 
approach cause ambiguity monotonic queries considering 
monotonic queries acm transactions database systems vol 

month yy 
memory requirements continuous queries table example queries data streams 
bounded memory computable 
queries new input tuple causes deletion existing output tuple set output tuples grows continuously input tuples arrive ullman 
consider query selection projection data stream 
projection duplicate preserving simple filter evaluated tuple time processing stream 
evaluated extra memory storage stream tuples intermediate state 
projection duplicate eliminating need keep track distinct value greater far order eliminate duplicates answer 
case finite bound amount memory required evaluating query possible instances stream query equi join streams order correctly evaluate query necessary store distinct value seen far stream distinct value seen far stream requires unbounded space 
query similar query additional selection predicates attributes observe tuple stream join tuple stream corresponding values lie interval observation evaluate query bounded memory 
briefly describe evaluation strategy computing bounded memory 
evaluation strategies describe bounded memory evaluation queries involve keeping constant sized synopses stream synopsis stream summary tuples stream seen far contains sufficient state information compute answers correctly 
duplicate preserving case synopsis contains value interval count tuples seen far similarly synopsis contains value count tuples easy see synopses sufficient compute correctly 
example consider new tuple arriving stream acm transactions database systems vol 

month yy 
arvind arasu lie interval new tuple join tuple ignored 
lies exact number past tuples new tuple joins stored synopsis copies tuple generated output 
note crucial output project list attribute instance query computable bounded memory 
similar evaluation strategy designed compute duplicate eliminating case 
consider series queries duplicate eliminating projection 
note derived adding additional predicate derived adding additional predicates 
computable bounded memory 
query evaluated maintaining synopsis minimum value attribute tuples far maintaining synopsis maximum value attribute tuples far 
order see synopses sufficient consider arrival new tuple stream assume joins past tuple 
join condition follows 
clearly joins tuple minimum value attribute tuples 
determine joins tuple just checking strictly larger value stored synopsis similarly evaluated maintaining synopsis value min max tuples far maintaining value max min tuples far 
leave reader verify synopses sufficient correctly evaluate 
queries computed bounded memory projection 
note duplicate preserving projection sufficient just know new stream tuple joins past tuples need determine exact number past tuples joins 
easily verify synopses described earlier queries projection determine exact number past tuples new stream tuple joins 
contributions examples previous section suggest problem determining bounded memory computability continuous queries nontrivial 
contributions bounded memory computability queries consider conjunctive queries arithmetic comparisons optional aggregation multiple data streams specify algorithm determines query evaluated bounded amount memory possible instances data streams 
query evaluated bounded memory produce execution strategy constant sized synopses data streams characterizing memory requirements query possible instances streams 
query evaluated bounded memory query execution strategy identify specific instances input streams acm transactions database systems vol 

month yy 
memory requirements continuous queries strategy requires memory linear sum lengths input streams 
sliding windows continuous queries streams may apply sliding windows reflect semantics application cases simply solve unbounded memory problem babcock 
continuous query languages may support windows specifying fixed number stream tuples considered entire stream history time windows specifying stream tuples arrived specified time considered entire stream history 
row window stream definition implies need bounded synopsis query stream row window clearly computable bounded memory 
necessarily bound state required store time window arbitrary numbers stream tuples may arrive finite time interval 
furthermore interested studying case streams required bounded applying windows 
addition handling queries windows techniques determine queries time windows bounded memory computable suggest appropriate bounded synopses case 
overview organization section briefly surveys related 
section formally defines data streams continuous queries data streams query execution model problem statement 
section introduces notation terminology rest 
sections deal bounded memory computability known class queries select project join spj queries self join 
example queries section belong class 
hard determine bounded memory computability arbitrary spj queries directly examples suggest take indirect approach 
rewrite spj query union queries belongs special class call locally totally ordered queries lto queries short 
check lto query union bounded memory computable 
lto query special structure easier determine bounded memory computable 
original query bounded memory computable iff lto queries union bounded memory computable 
lto rewriting approach determining bounded memory computability spj queries section 
basic lto rewriting approach determining bounded memory computability requires time exponential size query 
section refines approach presents efficient polynomial time algorithm determine spj query computable bounded memory 
section presents execution strategy bounded memory computable queries 
section extends results larger class queries spj queries may include self joins optional aggregation 
proofs relegated electronic appendix 
acm transactions database systems vol 

month yy 
arvind arasu 
related extends original short title arasu 
material arasu includes memory efficient execution strategy queries executed bounded amount memory extensions class queries consideration support grouping aggregation 
done part stream stanford stream data manager project goal develop general purpose data stream management system dsms supports continuous queries 
continuous queries introduced terry 
babcock discuss new research directions continuous query processing 
ongoing research projects aimed developing continuous query processing systems aurora carney niagaracq chen stream telegraphcq 
specific related projects described 
best knowledge past continuous query processing considered problem characterizing memory requirements queries statically 
explored constraints streams minimize memory requirements 
babu widom identify static constraints techniques exploit constraints reduce memory requirements continuous queries 
tucker suggest mechanism embedding dynamic constraints streams 
differs studies worst case memory requirement assuming constraints input streams 
evaluation strategies propose bounded memory computable queries similar chomicki 
chomicki characterize memory requirements evaluation strategies 
lot non memory related aspects processing adaptivity approximation sharing state related queries 
madden study adaptivity sharing continuous queries 
franklin consider variant continuous queries answer query need computed continuously intermittently demand 
shah propose new adaptive operator parallelizing query evaluation 
large body data streams focused specific tasks streams computing quantiles aggregates 
usually tasks require unbounded memory category provides approximate answers static guarantees accuracy answer 
manku consider maintaining approximate quantiles streams vitter studies problem maintaining fixed size random samples streams alon consider problem computing frequency moments feigenbaum compute differences streams gilbert guha consider problem maintaining histograms data streams datar maintain statistics sliding windows data streams babcock consider sampling scenario gehrke develop histogram techniques provide approximate answers specific class queries called correlated aggregate queries dobra synopses sketches alon acm transactions database systems vol 

month yy 
memory requirements continuous queries provide approximate answers aggregates joins 

query language execution model problem statement formally define model data streams initial query class semantics queries streams 
formalize query execution model state problem determining query evaluated bounded memory 
continuous data streams continuous data stream simply stream potentially infinite stream relational tuples 
stream fixed schema known finite set attributes 
assume domain attribute set integers 
results easily extend discrete totally ordered domain attributes 
assume streams bags tuple appear number times stream 
instance stream point time bag stream tuples seen point 
assume streams generated independent source meaning query evaluation algorithm control streams 
assumption important implications 
stream read source read order generated source 
query evaluation algorithm course store part stream local memory access subsequently 
second query involves multiple streams evaluation plan assumptions relative order tuples different streams read 
term interleaving denote exact interleaved sequence tuples different input streams read 
particular input instance consists input streams particular interleaving 
queries continuous data streams query traditional database specified finite data sets query answer function entire input data 
data streams potentially infinite continuously arriving streams typically queried continuous queries answer query point time function input streams seen far 
answer changes continuously new input stream tuples arrive 
languages semantics continuous queries ongoing topic research arasu 
purposes consider simple class continuous queries semantics relatively easy define 
class queries consider select project join spj queries optional aggregation 
standard relational symbols modifications represent continuous spj queries 
relational symbols denote selection cartesian product operators respectively 
denote duplicate preserving projection operators respectively 
variable symbol represent projection operators 
spj query form 
sn list projected attributes selection predicate 
sn denote input data streams 
restrict spj queries selection predicate acm transactions database systems vol 

month yy 
arvind arasu conjunction atomic predicates 
atomic predicate form si op sj different form si op op comparison operators constant integer 
results extended straightforward way include operators 
atomic predicate form si op si si op involving attributes just stream called filter called join 
simplify presentation start assuming self joins query si sj extend results include self joins section 
semantics continuous spj queries aggregation simple extension semantics traditional relational case 
output continuous spj query stream point time bag tuples output stream corresponds result applying spj query traditional relational semantics bag tuples input streams arrived far 
note semantics unambiguous spj queries aggregation monotonic ullman 
representation semantics continuous spj queries aggregation section 
sections spj query implicitly refers spj query aggregation 
execution model problem specification assume query evaluation environment access local memory example store information input streams seen far 
say unit memory store attribute value count 
concerned memory storage answers spj queries answer data stream aggregate queries covered section 
goal characterize worst case memory requirements queries possible input stream instances interleaving section 
turns worst case memory requirement queries consider falls asymptotic classes linear size input bounded constant 
suffices characterize class queries evaluated bounded amount memory 
definition 
query computable bounded memory exists constant algorithm evaluates query fewer units memory possible instances interleavings section input streams query 
focus primarily problem identifying exactly class queries 
proof query bounded memory computable requires space linear size input electronic appendix 
assume count takes unit memory number bits necessary represent count grows logarithmically number items counted 
practice count require words memory modern computer architecture 
acm transactions database systems vol 

month yy 
memory requirements continuous queries table ii 
notation query stream set streams appear set constants appear set attributes stream set attributes streams set elements 
preliminaries definitions section introduces notation terminology reviews basic concepts discrete mathematics results 
described section initially consider spj queries form sn duplicate eliminating projection duplicate preserving projection 
streams list projected attributes important discussion may write query selection predicate 
notation represent queries identical selection predicate 
example query obtained query just replacing selection predicate predicate 
convenience represent selection predicate set conjunction atomic predicates 
recall section consider queries selection predicate conjunction atomic predicates 
set atomic predicates satisfiable exists assignment integer values attributes predicate set evaluate true 
example set atomic predicates satisfiable 
note general problem boolean expression satisfiability intractable exist efficient algorithms check satisfiability conjunction convention set atomic predicates ullman 
observe query unsatisfiable selection predicate empty output stream trivially computable bounded memory 
rest assume selection predicates queries considered satisfiable mentioned 
term element refer constant integer value attribute stream 
table ii lists various notation related constants attributes elements query rest 
example query table 
transitive closure set atomic predicates denoted set atomic predicates logically implied predicates linear ordering integers implicitly determining transitive closure 
example transitive closure set atomic predicates set 
simplicity assume transitive closure contains atomic predicates involving elements occurring continuing previous example predicate occur transitive closure logically implied set predicates 
assumption ensures transitive closure finite set atomic predicates finite 
note queries equivalent acm transactions database systems vol 

month yy 
arvind arasu definition 
inequality predicate said redundant conditions hold exists element exists constant integer exists constant integer example predicate redundant sets 
removing redundant predicates leaves transitive closure unchanged sufficient consider nonredundant predicates query determining bounded memory computability section 
converse true atomic predicate removal leaves transitive closure unchanged necessarily redundant definition 
example predicates set redundant removing predicate leaves transitive closure unchanged 
definition redundancy depends constant values subtle way example predicate redundant set set 
subtlety arises evaluating filter conditions requires additional memory see theorem exact details clearer characterization bounded memory computable queries section 
definition 
set atomic predicates set atomic predicates induced set elements denoted ind set predicates involve elements definition 
set elements totally ordered set predicates elements exactly atomic predicates definition 
set predicates equality predicates set partition elements equivalence classes elements belong equivalence class definition 
set predicates attribute lower bounded exists atomic predicate atomic predicate constant similarly attribute upper bounded exists atomic predicate atomic predicate 
attribute bounded upper bounded lower bounded unbounded 
note attribute upper bounded resp 
lower bounded resp 
upper bounded unbounded definition 
definitions context query implicitly refer selection condition query 
example term bounded attributes query refers attributes query bounded selection predicate query 
acm transactions database systems vol 

month yy 
memory requirements continuous queries 
bounded memory computability spj queries section provides characterization bounded memory computable spj queries 
order determine bounded memory computability spj queries special class queries call locally totally ordered queries lto queries short 
informally lto query imposes stream query total ordering attributes stream constants query 
spj query converted lto query repeatedly adding filter conditions selection predicate adding different sets filter conditions results different lto queries 
show spj query bounded memory computable iff lto queries derived adding filter conditions bounded memory computable 
special structure lto queries easier determine bounded memory computable 
definition 
spj query locally totally ordered set elements totally ordered definition lto queries maximal filter queries certain sense adding additional filter conditions involving selection predicate lto query results equivalent query selection predicate resulting query unsatisfiable 
consider spj query streams 
set elements totally ordered set elements totally ordered comparable 
lto query 
query formed adding additional predicate lto query set elements totally ordered 
form lto query spj query adding filter conditions selection predicate ensure stream appearing set totally ordered 
lto query formed way said derived formal definition derived lto queries takes account equivalence queries transitive closure selection predicates 
definition 
lto query pl said derived spj query pl arbitrary set filter predicates 
instance example query table derive lto query adding filter predicates selection predicate 
bounded memory computability spj query directly related bounded memory computability set lto queries derived formalized theorem 
theorem 
spj query bounded memory computable iff lto queries derived bounded memory computable 
proof 
assume bounded memory computable 
query set filter conditions bounded memory computable 
straightforward bounded memory evaluation strategy follows acm transactions database systems vol 

month yy 
arvind arasu bounded memory evaluation strategy check additional filter conditions output done additional memory 
lto query derived formed adding just filter conditions bounded memory computable 
completes part proof 
lto queries derived involve just elements finite number lto queries differentiate queries transitive closure selection predicates 

qm enumeration lto queries derived claim equivalent union lto queries derived qi 
union operator duplicate preserving projection operator duplicate eliminating projection duplicate eliminating 
example illustrates equivalence 
formal proof generalized easily example 
consider spj query involving streams 
lto queries derived formed adding predicates respectively selection predicate consider tuple stream tuple stream successfully join query satisfy predicates depending value equal greater tuples join exactly fail 
conversely tuples stream stream join queries join query join predicates subset predicates 
equivalent duplicate preserving duplicate eliminating union 
note derived lto query duplicate eliminating output tuple may produced different lto queries duplicate eliminating union necessary remove duplicates outputs queries 
equivalence qi derive bounded memory evaluation strategy lto queries qi computable 
evaluation strategy simpler projection evaluate bounded memory lto query 
qm transfer output queries output duplicate eliminating projection evaluation strategy evaluates lto query independently 
addition remembers set output tuples produced far lto query uses set remove duplicates 
remembering set output tuples require unbounded memory prove theorem number output tuples bounded memory computable lto query duplicate eliminating projection bounded 
theorem reduces problem determining spj query computable determining lto query bounded memory computable 
bounded memory computability lto query depends special sets attributes identified selection predicate query 
definition 
consider query stream si 
maxref si set unbounded attributes definition si participate acm transactions database systems vol 

month yy 
memory requirements continuous queries fig 

maxref minref nonredundant definition inequality join sj si minref si similarly defined set unbounded attributes si participate nonredundant inequality join form si sj note maxref minref stream depend selection predicate query 
particular depend query lto query 
example 
illustrates maxref minref example set predicates involving attributes streams 
inequality join predicate elements represented directed edge elements example edge represents atomic predicate 
attributes belonging stream indicated enclosing rectangle example attributes stream maxref due predicates minref 
attribute appear maxref predicate redundant 
stream maxref minref 
attribute appear maxref bounded 
stream maxref minref 
consider cases lto queries duplicate preserving projection duplicate eliminating projection separately 
lto queries duplicate preserving projection duplicate preserving lto queries involve stream computed bounded memory joins predicate filter computed tuple time 
theorem characterizes computability queries involving stream 
theorem 
sn lto query 
bounded memory computable definition iff attribute project list bounded 
equality join predicate si sj si sj bounded 
acm transactions database systems vol 

month yy 
arvind arasu maxref si minref si 
section informally discusses ideas theorem 
formal proof part derived straightforward way discussion formal proof part electronic appendix 
informally conditions state ignore attributes involved filter conditions handle filter conditions memory attributes influence output bounded 
conditions directly state attribute project list attribute involved equality join condition bounded 
lto queries condition equivalent statement nonredundant inequality join predicate involves bounded attributes see lemma electronic appendix 
part theorem describe bounded memory evaluation strategy conditions hold 
evaluation strategy uses observation bounded attributes influence output filter conditions accounted 
evaluation strategy maintains synopses streams 
synopsis si conceptually bag tuples formed projecting bounded attributes si tuples si seen far satisfy filter conditions si 
keep memory bounded si stores distinct tuples maintains number times distinct tuple appears bag 
number distinct tuples synopsis bounded attribute bounded 
new stream tuple si arrives stream si synopsis si updated synopses streams determine new output tuples resulting join si earlier tuples streams 
update synopsis si tuple si checked filter conditions si appear si satisfies filter conditions projection bounded attributes si computed stored synopsis 
straightforward see synopses streams maintained similarly contain sufficient information compute new output tuples resulting join si earlier tuples streams nonredundant join conditions projections involve bounded attributes 
example illustrates evaluation strategy 
example 
consider lto query streams 
synopsis stream formed projecting attribute bag tuples seen far satisfy filter conditions tuples having value strictly attribute value greater attribute 
note enforce filter condition occurs synopsis bag tuples values 
synopsis compactly represented storing value number tuples synopsis similarly synopsis contains count tuples seen far consider arrival new tuple lies outside range join tuple ignored lies range joins earlier tuples having just number tuples synopsis new output tuples resulting arrival determined synopsis similarly new acm transactions database systems vol 

month yy 
memory requirements continuous queries output tuples resulting arrival new tuple determined synopsis consider part theorem 
formal proof appears electronic appendix 
give intuition examples 
condition satisfied unbounded attribute influences output projection attribute attribute nonredundant join predicate 
evaluation algorithm forced worst case remember unbounded number values attribute requiring unbounded memory 
example illustrates existence unbounded attribute project list force evaluation algorithm unbounded space example illustrates unbounded attribute nonredundant join predicate 
example 
consider lto query streams 
projection attribute clearly bounded 
consider instant evaluation input tuples 
vn vi arrived stream tuple arrived stream evaluation algorithm remember values 
vn instant arrival tuple stream require algorithm produce values output 
arbitrarily large evaluation algorithm requires unbounded memory worst case 
example 
consider lto query streams 
projection attribute query bounded exists nonredundant inequality join predicate involving unbounded attributes 
minref maxref nonempty violating condition 
assert computed bounded memory 
sake contradiction suppose exists algorithm evaluate fewer constant units memory 
construct class input scenarios show algorithm fail produce correct output input scenarios 
define sets tuples 

consider class input scenarios subset tuples chosen arrives stream order tuples arrive matter followed tuple chosen arrives stream input scenario consider instant tuples stream arrived single tuple stream 
algorithm state instant algorithm fewer units memory number distinct states finite 
subsets sufficiently large exist distinct subsets algorithm ends state seeing tuples subset 
subsets tuple smallest value 
assume loss generality consider input scenarios class followed tuple stream followed tuple output arrival tuple differs scenarios count tuples output case constructed acm transactions database systems vol 

month yy 
arvind arasu greater output case constructed algorithm unable distinguish give answer cases answer incorrect 
lto queries duplicate eliminating projection section presents characterization lto queries duplicate eliminating projection 
theorem 
sn lto query 
computable definition iff attribute project list bounded 
equality join predicate si sj si sj bounded 
maxref si eq minref si eq 
condition eq denotes number equivalence classes element set partitioned set predicates theorem differs theorem respects 
condition theorem condition theorem allows stream attribute set attributes belonging equivalence class participating nonredundant inequality join predicate 
second theorem applicable duplicate eliminating lto queries including queries just stream theorem holds duplicate preserving lto queries involving stream 
duplicate preserving lto queries involving just stream bounded memory computable 
duplicate preserving case discuss ideas theorem section formal proof part theorem derived discussion formal proof case electronic appendix 
part theorem describe bounded memory evaluation strategy conditions satisfied 
duplicate preserving case evaluation algorithm maintains synopsis stream summarizing set tuples seen far stream addition remembers output tuples produced far ensure duplicate elimination 
note condition guarantees set possible output tuples bounded size 
synopsis stream si depends values maxref si minref si 
simplest case occurs maxref si minref si empty 
maintain synopsis si case new input tuple si si checked filter conditions si si satisfies filter conditions projection bounded attributes si inserted synopsis 
duplicate insertions synopsis ignored 
words synopsis si set bag tuples resulting projecting bounded attributes si tuples seen far si satisfy filter conditions removing duplicates resulting projected tuples 
size set clearly bounded projected tuples involve bounded attributes 
easy verify fact nonredundant join predicates si involve bounded attributes output tuple produced original bag tuples acm transactions database systems vol 

month yy 
memory requirements continuous queries si joining tuples streams produced projected set tuples synopsis si joining set tuples streams 
consider case maxref si empty 
condition follows minref si empty 
unbounded attribute si involved nonredundant inequality predicate si sj 
case synopsis si contains attribute schema addition usual bounded attributes si maintained follows 
input tuple si stream si satisfies filter conditions si tuple sp formed projecting si bounded attributes si computed 
tuple sp current synopsis agrees sp bounded attributes sp inserted synopsis exists tuple sp tuple sp sp having larger value attribute retained synopsis discarded 
tuples differ value attribute value check predicate si sj output tuple produced discarded tuple produced tuple retained synopsis 
tuples si agree bounded attributes satisfy filter conditions si tuple maximum value chosen projection stored synopsis si 
relatively straightforward verify instant set tuples synopsis behave exactly entire bag tuples si far output concerned 
case minref si empty maxref si empty handled analogously 
example illustrates evaluation strategy described 
example 
consider query streams obtained query example replacing duplicate preserving projection duplicate eliminating 
duplicate eliminating version query bounded memory computable duplicate preserving version 
schema synopsis contains attribute bounded attribute occurs minref 
single possible value satisfies filter conditions synopsis contains tuple tuple exists minimum value tuples 
synopsis contains tuple tuple maximum value far 
new tuple joined synopsis analogously new tuple joined synopsis query output successful join tuple successful join results output subsequent joins ignored 
conditions restrictive duplicate eliminating queries duplicate preserving queries duplicate eliminating case new stream tuple arrives sufficient know new tuple produces output tuple joining earlier tuples streams duplicate preserving case necessary know number different ways new tuple joins tuples streams produce output tuple 
query example check new tuple joins earlier tuple producing output tuple tuple tmax maximum acm transactions database systems vol 

month yy 
arvind arasu value attribute greater store synopsis suffices new tuple joins tuple joins tmax 
determine exact number tuples new tuple joins need remember entire distribution values seen far stream illustrated example 
part theorem example illustrates violation condition force evaluation strategy unbounded memory 
formal proof covering conditions electronic appendix 
example 
consider query streams 
query nonredundant inequality join predicates violates condition 
consider instant evaluation tuples arrived stream tuple arrived stream tuple exists potential tuple joins tuples 
evaluation strategy remember tuples arbitrarily large requires unbounded memory 
summary summarize section reduced problem characterizing computability spj queries problem characterizing computability special class queries called lto queries 
sections characterization bounded memory computable duplicate preserving duplicate eliminating lto queries respectively 
results section determine spj query computable bounded memory checking theorem theorem lto query derived definition computable bounded memory suggest evaluation strategy computable bounded memory rewrite duplicate preserving union lto queries derived evaluate lto query independently accumulate output lto queries theorem 
naive technique checking bounded memory computability spj queries evaluating inefficient 
number lto queries derived spj query usually exponential number attributes spj query 
sections basic ideas section derive efficient techniques checking evaluation avoid explicitly rewriting query lto queries 

checking algorithm section presents simple polynomial algorithm determines spj query sn bounded memory computable explicitly checking lto query derived algorithm shown 
handles duplicate preserving duplicate eliminating queries 
terms kmax kmin algorithm denote acm transactions database systems vol 

month yy 
memory requirements continuous queries input spj query sn output computable bounded memory 

satisfiable return 
attribute unbounded return 
exists predicate si sj attribute unbounded return 
form query empty projection list ind kmax kmin selection predicate joining streams attributes computable bounded memory theorems return 
kmin kmax denote minimum maximum constant values respectively appear 
return 
fig 

algorithm check bounded memory computability spj queries 
maximum minimum constant values respectively appearing algorithm proceeds steps 
step checks trivially computable bounded memory 
steps respectively check conditions theorem theorem violated lto query derived conditions violated bounded memory computable returned corresponding step returned step 
briefly describe steps check conditions explicitly enumerating derived lto query 
steps observation unbounded attribute remains unbounded lto query derived conversely unbounded attribute lto query derived unbounded 
step observation implies unbounded attribute belonging remains unbounded lto query derived violating condition 
similarly step unbounded attributes involved equality join remain unbounded lto query derived violating condition 
step algorithm uses fact just nonredundant predicates maxref stream minref suffice witness violation condition 
predicates involve attributes violation condition detected checking queries attributes constructed appropriate way 
concreteness duplicate eliminating projection case duplicate preserving projection argued similarly 
assume lto query ql derived violates condition theorem 
exist nonredundant inequality join predicates involving common stream si cause maxref si eq minref si eq 
denote set attributes participating 
query constructed step computable bounded memory algorithm correctly returns 
conversely query constructed step bounded memory computable due violation condition lto query derived condition violated lto query ql derived acm transactions database systems vol 

month yy 
arvind arasu fig 

example illustrating checking algorithm example illustrates step algorithm example input query 
example 
illustrates step algorithm example input query 
query represented selection predicate projected attributes relevant step 
inequality join predicate elements represented directed edge elements attributes belonging stream indicated enclosing rectangle 
figures show input query duplicate eliminating projection streams lto query ql derived query bounded memory computable ql violates condition theorem maxref due 
shows query constructed set attributes involved violation condition ql step algorithm 
query bounded memory computable lto query derived violates condition 
observe related ql way related clearly steps executed polynomial time size input query 
query step size check lto queries acm transactions database systems vol 

month yy 
memory requirements continuous queries constant time 
subsets having cardinality step takes polynomial time 
algorithm polynomial size input query 

query evaluation strategy described section naive evaluation strategy spj queries rewrite query union lto queries evaluate lto query independently accumulate output 
section evaluation strategy efficient computationally uses memory 
intuitively efficient evaluation strategy logically merges individual synopses maintained lto query naive evaluation strategy single synopsis 
substantial redundancy different synopses naive strategy merged synopsis larger individual synopses efficient evaluation strategy uses significantly memory naive strategy factor roughly equal number lto queries 
introduce notation describe evaluation strategy 
uppercase letters denote streams corresponding lowercase letters denote instances streams 
example si denotes instance stream si 
recall section instance stream point time bag tuples seen far stream 
query streams 
sn 
sn denotes output instances si streams seen 
evaluation strategy duplicate preserving queries queries separately 
evaluation strategy duplicate preserving queries consider bounded memory computable duplicate preserving query sn 
ignore trivial case 
case lto queries evaluation strategy maintains synopsis syn si summarizing current instance si stream 
synopsis syn si bag tuples having schema si property equivalent si purposes evaluating formally si 
sn syn 
syn sn 
new tuple arrives stream evaluation strategy joins new tuple synopses streams outputs resulting tuples 
property synopses described guarantees correctness evaluation strategy 
order maintain synopsis si tuples si logically partitioned bounded number buckets 
kmax kmin denote maximum minimum constant value appearing respectively 
denote set integers kmax kmin kmin kmin 
kmax 
partition domain integers non overlapping ranges kmin kmin kmin 
kmax kmax kmax ranges unbounded intermediate ones span exactly integer 
bucket si assigns attribute si ranges 
si distinct buckets si corresponding possible assignments ranges attributes 
acm transactions database systems vol 

month yy 
arvind arasu notation denote range identified bucket attribute writing range kmin range range kmax 
tuple belongs bucket value attribute falls range assigned bucket 
clearly tuple belongs single bucket 
example 
consider query table query kmax kmin 
different buckets stream 
example bucket bucket ranges 
tuples value attribute value attribute value greater attribute belong bucket 
tuples belonging bucket equivalent purposes evaluating words joins set tuples streams produce output tuple joins set tuples produce output tuple 
equivalence property holds computable duplicate preserving queries formally proven electronic appendix 
example illustrates equivalence property 
example 
consider query shown example 
consider bucket ranges 
tuples bucket value attribute consequently join tuple stream form producing output fail join tuple 
equivalence property maintain synopsis si 
bucket stream si count denote number tuples si seen far belong denote tuple belonging appears si 
synopsis si consists count copies corresponding bucket si discounting tuples fail satisfy filter conditions si 
equivalence property count copies tuple equivalent bag count tuples belong synopsis si equivalent bag tuples si seen far 
physically synopsis si represented storing bucket count requires bounded memory number buckets bounded 
evaluation strategy duplicate eliminating queries consider bounded memory computable duplicate eliminating query sn 
case duplicate preserving queries evaluation strategy summarizes current stream instances si bounded memory synopsis syn si equivalent si evaluating 
sn syn 
syn sn 
maintain synopsis si tuples si partitioned buckets exactly case duplicate preserving queries 
case duplicate preserving queries property tuples belonging bucket equivalent respect valid duplicate eliminating queries 
weaker property holds finite set bag tuples belonging bucket possible pick subset representative acm transactions database systems vol 

month yy 
memory requirements continuous queries tuples equivalent entire set purpose evaluating property synopsis contains bucket si tuples representing bag tuples si seen far belong satisfy filter conditions si 
informally pick tuple maximum value maxref attribute definition tuple minimum value minref attribute representative tuples 
bucket associate set filter predicates pb tuples belonging bucket satisfy pb 
set pb contains atomic predicate corresponding attribute si atomic predicate corresponding kmin atomic predicate atomic predicate kmax 
definition maxref minref bucket differs slightly definition takes account additional filter predicates pb tuples belonging satisfy 
definition 
consider query stream si 
bucket si maxref si defined set unbounded attributes si pb participate nonredundant inequality join sj si pb minref si similarly defined set unbounded attributes si participate nonredundant inequality join form si sj pb representative tuples bucket si picked follows maxref si nonempty pick tuple maximum value min maxref si 
minref si nonempty pick tuple minimum value max minref si 
maxref si minref si empty pick tuple appears si 
example 
consider query streams 
reader verify computable 
consider bucket ranges 
predicate pb bucket 
attributes unbounded predicate pb attribute bounded pb unbounded predicate occur maxref si due nonredundant predicates 
minref si empty 
representative tuple sufficient bucket tuple maximum value min tuples si seen far belong 
extensions section extend results larger class queries 
section considers queries self joins section considers queries grouping aggregation 
acm transactions database systems vol 

month yy 
arvind arasu queries self joins self join query stream appears join list 
notation 
denote different occurrences stream query 
instance query join stream attribute characterization bounded memory computable self join queries differs slightly non self join queries due implicit constraint streams point time instances self join streams 
additional constraint affects characterization duplicate eliminating queries 
duplicate preserving queries characterization bounded memory computability theorems continues hold 
proofs theorems modified slightly currently assume instances streams arbitrary 
characterization remains unchanged checking algorithm section efficient evaluation strategy section duplicate preserving queries self joins 
duplicate eliminating queries reduction bounded memory computability spj queries lto queries holds theorem characterization bounded memory computable lto queries theorem example illustrates 
example 
consider self join lto query 
equality join unbounded attributes violates condition theorem equivalent query clearly bounded memory computable 
conditions theorem sufficient ensure self join lto query computable bounded memory necessary exist queries query example violate conditions computable bounded memory 
informally occurrences stream query example redundant allowed rewritten just occurrence theorem fails queries redundant streams 
words duplicate eliminating lto query redundant streams bounded memory computable iff conditions hold 
strategy handling duplicate eliminating lto queries rewrite queries redundant streams theorem check bounded memory computability rewritten queries 
formalize redundant streams show query rewritten redundant streams 
definition 
stream said redundant spj query exists stream sk op sk op op sj sk op sk filter condition filter condition sk 
op sl sk op sl acm transactions database systems vol 

month yy 
memory requirements continuous queries list projected attributes sj sk case say covers sj example covers vice versa 
sk covers sj spj query query obtained eliminating replacing occurrences sk equivalent repeatedly rewriting step eliminate redundant streams query 
summarize duplicate eliminating query self joins bounded memory computable iff lto queries derived bounded memory computable 
order determine duplicate eliminating lto query computable remove redundant streams query check resulting rewritten query bounded memory computable theorem 
currently know extend efficient checking section evaluation algorithms section handle duplicate eliminating spj queries self joins extending algorithms 
queries grouping aggregation extend main results queries involving aggregation optionally grouping 
queries involving standard aggregate functions sum count min max avg count distinct median provide necessary sufficient conditions bounded memory computability argue query bounded memory computable requires worst case space linear size input theorems 
queries involve user defined aggregate functions provide set sufficient conditions computability theorems 
stating necessary conditions bounded memory computability apply aggregate functions difficult easily design nonstandard aggregate functions admit special optimization tricks 
relational symbol denote grouping aggregation operator 
query involving grouping aggregation simply aggregate query general form ggf sn possibly empty set grouping attributes set aggregate expressions 
aggregate expression form si aggregate function sum count 
aggregate query ggf sn equivalent sql query select 
sn group answer aggregate query point time answer standard relational algebra semantics bag input stream tuples seen far 
aggregate queries nonmonotonic meaning stream output tuples spj query 
different technique producing answer aggregate query 
point time require evaluation strategy store current answer aggregate query memory 
count memory store query answer determining aggregate query evaluated bounded memory 
trivially approach implies aggregate query unbounded result size unbounded number groups bounded memory computable 
acm transactions database systems vol 

month yy 
arvind arasu classification gray divides aggregate functions categories distributive algebraic holistic 
consider bag values single value drawn domain 
aggregate function domain distributive computed aggregate function algebraic distributive exists synopsis function computed stored bounded memory computed aggregate function holistic distributive algebraic 
distributive algebraic aggregate function computed online fashion bounded amount memory holistic aggregate function 
standard aggregate functions sum count min max distributive avg algebraic computed synopsis containing sum count count distinct median holistic 
classify aggregate functions duplicate sensitive 
bag values set distinct elements aggregate function duplicate insensitive bags duplicate sensitive 
functions min max count distinct duplicate insensitive sum count avg median duplicate sensitive 
theorem 
single stream aggregate query ggf computed bounded memory grouping attribute bounded aggregate expression holistic unbounded 
proof 
partition input tuples satisfy groups defined grouping attributes 
bounded number groups grouping attributes bounded 
group values distributive algebraic aggregates maintained bounded memory definition 
attribute aggregated holistic aggregate function maintain counts number times value occurs group condition attribute bounded counts maintained bounded memory 
counts completely capture distribution group allowing holistic aggregates computed 
consider multi stream aggregate query ggf sn 
si si denote set attributes aggregate expressions define characteristic query sn aggregate functions duplicate insensitive 
theorem 
consider aggregate query ggf sn 
characteristic query computed bounded memory proof 
provide bounded memory evaluation strategy evaluating evaluate subroutine characteristic query appropriate algorithm section 
output tuples generated subroutine partition groups defined grouping attributes group maintain counts number occurrences value attributes aggregated 
duplicate preserving counts complete description acm transactions database systems vol 

month yy 
memory requirements continuous queries distribution aggregated attributes sufficient compute aggregate functions group 
duplicate eliminating number times attribute value occurred lost matter duplicate eliminating aggregates duplicate insensitive 
fact computable bounded memory implies grouping attributes aggregated attributes bounded total memory required post processing output bounded 
necessary sufficient conditions determining aggregate query involving standard aggregates bounded memory computable 
consider single multi stream queries separately 
theorem 
ggf aggregate query single stream aggregate functions drawn sum count min max avg count distinct median 
bounded memory computable iff grouping attribute bounded aggregate expression holistic count distinct median unbounded 
proof 
theorem states conditions theorem necessary sufficient standard aggregates 
direction special case theorem 
direction straightforward 
observed earlier grouping attribute bounded keep size output bounded 
condition known computing number distinct values median bag requires memory proportional number distinct values bag implies attributes aggregated count distinct median bounded 
reduced characteristic query aggregate query ggf sn defined way characteristic query defined earlier ex cept attributes project list grouping attributes 
formally reduced characteristic query sn aggregate functions 
theorem 
ggf sn aggregate query multiple streams involving standard aggregates sum count avg max min count distinct median 
reduced characteristic query bounded memory computable iff computable bounded memory 
aggregate expression count distinct si median si si bounded 
aggregate expression max si si unbounded maxref si empty maxref si eq si maxref si similarly aggregate expression min si si unbounded minref si empty minref si eq si minref si 
discuss ideas theorem 
formal proof derived discussion 
acm transactions database systems vol 

month yy 
arvind arasu loss generality assume consists just aggregate expression 
aggregate query having aggregate expressions equivalently rewritten natural join grouping attributes output aggregate queries having aggregate expression original query identical 
example query ag sum max equivalent ag sum ag max 
set possible groups bounded memory computable aggregate query bounded query aggregate expression bounded memory computable iff queries aggregate expression derived bounded memory computable 
rest discussion assume contains expression form si 
break discussion theorem cases depending type aggregate function single aggregate expression holistic count distinct median non holistic duplicate sensitive sum count avg non holistic duplicate insensitive max min 
cases discuss arguments proof 
holistic aggregates count distinct median relevant conditions theorem reduce sufficiency conditions theorem 
part proof holistic aggregates special case proof theorem 
part proof assume bounded memory computable violating condition 
non computability results unbounded attribute project list causes violation condition theorem lto query join predicates cause violation conditions theorem 
case clearly computable grouping attributes bounded case informally checking join predicates requires unbounded memory evaluating aggregation top join feasible bounded memory 
definition holistic aggregates aggregated attribute si bounded bounded memory computability condition necessary 
consider case duplicate sensitive aggregates sum count avg 
aggregates condition relevant bounded memory computable iff bounded memory computable 
consider part proof 
note condition relaxes sufficiency conditions theorem aggregates possible evaluate query aggregated attribute unbounded 
query involving aggregates need evaluated suggested proof theorem computing join streams projecting grouping aggregated attributes result join computing aggregate projections 
partially push aggregation join possible compute aggregates unbounded aggregated attributes 
examples illustrates evaluation strategy 
example 
consider aggregate query cg sum streams 
aggregation unbounded attribute assert acm transactions database systems vol 

month yy 
memory requirements continuous queries computable bounded memory 
evaluation strategy maintains synopsis addition maintains current answer query required semantics aggregate queries 
synopsis contains value interval sum attribute tuples seen far synopsis contains value count tuples seen far arrival new tuple changes output follows value add sum corresponding current synopsis group output 
similarly arrival new tuple changes output follows nv denote current count tuples synopsis add value nv group output 
reader verify evaluation strategy correctly computes output aggregated attribute si bounded evaluation strategy theorem 
evaluation strategy section modified follows 
maintain synopsis stream 
synopses streams si recall si aggregated attribute remain unchanged 
order maintain synopsis si tuples si partitioned buckets exactly described section 
bucket addition remembering representative tuple count tuples remember aggregate attribute example aggregate function sum remember sum attribute tuples belonging bucket 
reader verify synopses sufficient answer technique similar shown example 
proof bounded memory computable argue bounded memory computable exactly holistic aggregates 
consider case min max 
discuss max discussion min analogous 
consider part 
aggregated attribute si bounded satisfies conditions theorem evaluation strategy proof theorem 
si bounded bounded memory computability depends maxref si 
maxref si empty partially push max aggregate join exactly duplicate sensitive queries bucket synopsis si maintain maximum value attribute tuples belong bucket 
maxref si non empty condition states si attribute maxref si ignoring attributes belonging equivalence class bounded memory computable 
informally maximum value attributes maxref needed buckets evaluation predicate attribute maxref si ignoring attributes belonging equivalence class conflict maximum value stored bucket exactly maximum value checking computing max 
part bounded memory computable argue bounded memory computable exactly case holistic aggregates 
attribute maxref si proof similar proof theorem case maxref si eq 
acm transactions database systems vol 

month yy 
arvind arasu 
discussion results assumption attributes discrete ordered domains 
relax assumption follows 
define sat attribute set predicates set possible values assigned true assignment values rest attributes boundedness attribute definition generalized bounded set predicates iff sat constant 
definition boundedness extends theorems attributes arbitrary domains 
assume atomic predicate form domain attributes ordered 
addition allowing attributes arbitrary domains useful handle richer set predicates atomic predicates domain specific operators disjunctions atomic predicates 
expanding class predicates important avenue 
results sections assume data inputs query consist solely continuous data streams 
case queries streams query evaluation algorithm control instances interleavings input streams 
queries relations stored conventional databases instances relations finite may partially known query processor form statistics attributes 
conventional database system query evaluation algorithm usually control ordering interleaving relations 
cases traditional settings desirable perform query processing pass relation 
cases results generate evaluation plans constant amount additional memory regardless relation sizes 
electronic appendix electronic appendix article accessed acm digital library visiting url www acm org pubs citations journals tods yy 
appendix contains proofs theorems main body 
acknowledgments rajeev motwani jeff ullman entire stream group stanford useful discussions 
alon matias szegedy 
space complexity approximating frequency moments 
journal computer system sciences feb 
arasu babcock babu widom 
characterizing memory requirements queries continuous data streams 
proc 
st acm sigact sigmod sigart symp 
principles database systems 
acm new york 
arasu babu widom 
semantics concrete language continuous queries streams relations 
tech 
rep stanford edu pub stanford university 
nov babcock babu datar motwani widom 
models issues data stream systems 
proc 
st acm sigact sigmod sigart symp 
principles database systems 
acm new york 
acm transactions database systems vol 

month yy 
memory requirements continuous queries babcock datar motwani 
sampling moving window streaming data 
proc 
th annual acm siam symp 
discrete algorithms 
acm siam new york 
babu widom 
exploiting constraints reduce memory overhead continuous queries data streams 
tech 
rep stanford edu pub stanford university 
nov carney 
monitoring streams new class data management applications 
proc 
th intl 
conf 
large data bases 
morgan kaufmann san mateo ca 
cooper 
telegraphcq continuous dataflow processing uncertain world 
proc 
st conf 
innovative data systems research 

franklin 
streaming queries streaming data 
proc 
th intl 
conf 
large data bases 
morgan kaufmann san mateo ca 
chen dewitt tian wang 
niagaracq scalable continuous query system internet databases 
proc 
acm sigmod intl 
conf 
management data 
acm new york 
chomicki 
efficient checking temporal integrity constraints bounded history encoding 
acm trans 
database systems 
cranor johnson shkapenyuk 
gigascope stream database network applications 
proc 
acm sigmod intl 
conf 
management data 
acm new york 
datar gionis indyk motwani 
maintaining stream statistics sliding windows 
proc 
th annual acm siam symp 
discrete algorithms 
acm siam new york 
dobra garofalakis gehrke rastogi 
processing complex aggregate queries data streams 
proc 
acm sigmod intl 
conf 
management data 
acm new york 
feigenbaum kannan strauss viswanathan 
approximate difference algorithm massive data streams 
proc 
th annual symp 
foundations computer science 
ieee computer society los alamitos ca 
gehrke 
special issue data stream processing 
ieee computer society bulletin technical comm 
data engg 
march 
gehrke korn srivastava 
computing correlated aggregates continual data streams 
proc 
acm sigmod intl 
conf 
management data 
acm new york 
gilbert guha 
fast small space algorithms approximate histogram maintenance 
proc 
th annual acm symp 
theory computing 
acm new york 
ozsu 
issues data stream management 
sigmod record june 
gray chaudhuri 
data cube relational aggregation operator generalizing group cross tab sub totals 
data mining knowledge discovery mar 
greenwald khanna 
space efficient online computation quantile summaries 
proc 
acm sigmod intl 
conf 
management data 
acm new york 
guha koudas shim 
data streams histograms 
proc 
rd annual acm symp 
theory computing 
acm new york 
madden shah hellerstein raman 
continuously adaptive continuous queries streams 
proc 
acm sigmod intl 
conf 
management data 
acm new york 
manku rajagopalan lindsay 
random sampling techniques space efficient online computation order statistics large datasets 
proc 
acm sigmod intl 
conf 
management data 
acm new york 
acm transactions database systems vol 

month yy 
arvind arasu shah hellerstein franklin 
flux adaptive partitioning operator continuous query systems 
proc 
th intl 
conf 
data engineering 
ieee computer society los alamitos ca 
stream 
stanford stream data management project 
www db stanford edu stream 
terry goldberg nichols oki 
continuous queries append databases 
proc 
acm sigmod intl 
conf 
management data 
acm new york 

home page 
www com 
tucker maier sheard fegaras 
exploiting punctuation semantics continuous data streams 
ieee trans 
knowledge data engg 

ullman 
principles database knowledge base systems 
vol 
computer science press rockville maryland chapter 
ullman 
principles database knowledge base systems 
vol 
ii 
computer science press rockville maryland chapter 
vitter 
random sampling reservoir 
acm trans 
mathematical software mar 
acm transactions database systems vol 

month yy 
memory requirements continuous queries app document online appendix characterizing memory requirements queries continuous data streams arvind arasu brian babcock babu jon jennifer widom stanford university acm transactions database systems vol 

month yy pages app 
proofs section lemma 
lto query satisfiable maxref si minref si si iff nonredundant non equality join predicate sj sk attributes sj sk bounded 
proof 
part proof follows directly definition maxref minref definition 
part proof consider nonredundant atomic predicate sj sk clearly sj sk bounded minref sj maxref sk nonempty 
show impossible exactly sj si bounded bounded 
loss generality assume sj bounded sk implies sj sj constant integers 
sk bounded lto query sk sk implies unsatisfiable si sk redundant leads contradiction case 
proof theorems section prove theorems identify duplicate eliminating lto queries respectively computed bounded memory 
proofs theorems sections 
formalize proofs 
proofs proceed follows 
theorems similar differences condition special case single stream queries combine proofs part 
proof technique generalization technique examples show conditions theorems violated query generate arbitrarily large set input tuples permission digital hard copy part material fee personal classroom provided copies distributed profit commercial advantage acm copyright server notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
yy acm yy acm transactions database systems vol 

month yy 
app arvind arasu evaluation strategy query provably needs remember tuple set correct execution proving query bounded memory computable 
proof technique formalized lemma 
actual set input tuples generate proof depends conditions violated projection operator query structural properties query schema input streams selection predicate 
lemma handles violation condition theorems lemma handles violation condition theorems lemma handles violation condition theorem lemma handles violation condition theorem 
simplify presentation lemmas generating entire input tuples generate attribute values small subset attributes involved violating condition lemma fill values remaining attributes 
set attributes denote tuple schema denotes tuple stream denote projection tuple attributes stream shorthand respectively 
disjoint sets attributes tuples denotes tuple uses mapping attributes attributes order construct input instances query proof need tuples streams occur join satisfy conditions selection predicate convenience constructing tuple assigns value attribute relevant query 
call tuple valid satisfies predicate query eq 
em denote equivalence classes elements induced recall definition element equivalence classes section 
inequality predicates induce partial ordering equivalence classes ei ej exist elements ei ei ej ej ei ej loss generality assume equivalence classes numbered topological sort order ei ej valid tuple assigns value attributes equivalence class 
discussing valid tuples may attribute equivalence class interchangeably 
assume query considered section 
proofs extended straightforward way 
lemma 
eq number equivalence classes elements lto query eq set unbounded equivalence classes tuple assigns values classes form valid tuple assigns value equivalence classes eq form eq ei ej ei ej 
lower bounded ei definition ei 
upper bounded ei ei 
note ei ej individual numeric values 
acm transactions database systems vol 

month yy 
memory requirements continuous queries app proof 
intuitively lemma asserts values unbounded equivalence classes fixed tuple generate values equivalence classes satisfy selection predicate provided values assigned classes sufficiently far apart constants query 
lemma proved formally constructing mapping equivalence classes eq 
set predicates satisfiable exists valid tuple 
tuple mapping bounded equivalence classes ei bounded ei ei 
lower bounded equivalence class ei eq jmi max ej 
constant define ei jmi 
define ei jmi 
upper bounded equivalence class ei eq jmi min ej 
constant define ei jmi 
define ei jmi 
straightforward prove tuple valid 
lemma 
lto query list projected attributes 
attribute unbounded 
computable bounded memory duplicate eliminating projection 
proof 
belong stream sa 
ea equivalence class unbounded integer construct valid tuples 
tn defined ti different value attribute ti tj construct input instances 
input instance consists order different subset set tuples sa 
tn sa stream sa tuples streams 
claim correct evaluation algorithm query different memory state seeing input instances 
consider cases 
case 
case query involves stream 
inputs ii contain tuples streams sa answer input empty 
consider inputs ii ij 
loss generality assume exists tuple tk sa occurs ii ij 
consider set tuples tk sx sx 
set tuples appears input ii tuple tk answer 
tuple tk answer occurs ij 
evaluation algorithm query memory state seeing ii ij produce wrong answer inputs ii followed ij followed case duplicate eliminating projection 
assume case holds 
answer seeing ii projection tuples ii attributes consider distinct inputs ii ij loss generality tuple tk occurs ii ij 
tuple tk appears acm transactions database systems vol 

month yy 
app arvind arasu ii new tuples produced answer tk duplicate 
tk appears ij tuple tk produced answer tk appears 
evaluation algorithm memory state seeing ii ij produce wrong answer input scenarios 
correct evaluation algorithm needs log bits memory required encode different states 
computable bounded memory 
lemma 
lto query 
computable bounded memory value exists stream valid tuples 
tn defined projections tuples distinct ti tj ti tj valid proof 
consider value construct inputs 
input consists order different subset set tuples 
tn stream tuple streams 
claim correct evaluation algorithm different memory state seeing inputs 
inputs ii contains tuples streams answer input empty 
consider inputs ii ij 
loss generality assume exists tuple tk occurs ii ij 
consider set tuples tk 
set tuples appears input ii new answer tuple tk generated 
appears input ij new answer tuples generated second condition lemma 
evaluation algorithm memory state seeing ii ij produce wrong answer inputs ii followed ij followed correct evaluation algorithm needs log bits memory computable bounded memory 
lemma 
lto query 
equality join condition form si sj attributes unbounded 
computable bounded memory 
proof 
denote common unbounded equivalence class construct valid tuples 
tn defined tuple assigns different value equivalence class tk tl observe tuples satisfy conditions lemma si lemma lemma 
projections tk si tuples si distinct differ attribute equivalence class 
tuple tk si tl si valid si sj satisfied 
lemma computable bounded memory 
lemma 
duplicate preserving lto query maxref minref 
computable bounded memory 
acm transactions database systems vol 

month yy 
memory requirements continuous queries app proof 
prove case maxref 
proof minref symmetric 
definition maxref exists nonredundant inequality join 
ea eb denote equivalence classes induced belong respectively 
note equivalence classes distinct satisfiable 
assume ea eb upper bounded 
loss generality case lower bounded symmetric case lower bounded upper bounded disallowed definition maxref notational convenience denote 
kmax represent maximum constant occurring eq ea eb 
integer define tuples 
ti ea kmax ti eb kmax im 
tuples defined lemma construct valid tuples 
tn defined kmax eb ea eb ea tn eb tn ea construct inputs 
input consists order different subset set tuples 
tn stream tuples streams 
claim evaluation algorithm query different memory state seeing inputs 
inputs ii contain tuples streams answer input empty 
consider inputs ii ij 
tk tuple largest value tuples appearing ii ij 
loss generality assume tk appears ii ij 
note tuples tl occur ii ij 
consider set tuples tk sx sx sx 
consider input cases occurrence ii occurrence ij 
answer case equal answer case additional tuple tk 
definition tuples join tk produce tk answer 
tuples join tuple tl cause predicate violated 
possible tuples join tuples tl choice tuple tl occurs ii ij occurs lead answer cases 
consequently evaluation algorithm memory state seeing ii ij produce wrong answer inputs described 
correct evaluation algorithm needs log bits memory computable bounded memory 
lemma 
duplicate eliminating lto query maxref eq minref eq 
computable bounded memory 
proof 
assume equality joins unbounded attributes different streams lemma applies 
proof split cases 
case show number generate tuples 
tn satisfy conditions lemma proving computable bounded memory 
generate values attributes tuple lemma fill values tuples 
acm transactions database systems vol 

month yy 
app arvind arasu lemma denote 
case minref eq 
case exist nonredundant atomic predicates definition minref attributes unbounded belong different equivalence classes 
attributes stream lto query totally ordered assume loss generality claim attributes unbounded belong different equivalence classes 
noted unbounded belong different equivalence classes 
attributes unbounded redundant contradicts definition minref 
assume equality joins unbounded attributes belonging different streams attributes unbounded equivalence class belong stream 
equivalence class equivalence class predicates imply redundant 
proves claim 
ea eb ec ed equivalence classes respectively 
recall convention subscripts equivalence classes ei topological sort order meaning ei ej 
predicates imply case eb ec imply redundant 
ec eb ec eb unrelated 
case construct valid topological sort ordering satisfying loss generality assume consider subcases case depending attributes lower bounded upper bounded 
kmin kmax denote smallest largest constants occurring respectively 
eq 
case lower bounded 
select values ti ea ti eb ti ec ti ed 
ea ec ea ec 
tn ea tn ec tn eb tn ed 
eb ed kmin lemma construct tuples 
tn defined assignment values equivalence classes set ea eb ec ed 
projections ti stream distinct ti tj tuple ti tj valid ti ed tj eb violating predicate ti ea tj ec violating predicate 
follows lemma query computable bounded memory 
case lower bounded 
case tuples 
tn constructed kmax ea ec ea ec 
tn ea tn ec tn eb tn ed 
eb ed remainder argument proceeds similarly case 
acm transactions database systems vol 

month yy 
memory requirements continuous queries app case upper bounded lower bounded 
case 
tn satisfy ea ec ea ec 
tn ea tn ec kmin kmax tn eb tn ed 
eb ed remainder argument parallels case 
completes proof case 
case maxref eq 
symmetric proof case 
case maxref eq maxref eq 
case exist nonredundant atomic predicates consider subcases 
subcase specify relationships need hold values chosen projections tuples 
tn set ea eb ec ed 
remaining details analogous proof case 
note attribute belong equivalence class similarly attribute belong equivalence class 
case lower bounded upper bounded 
assume lower bounded 
proof attributes upper bounded symmetric 
generate tuples 
tn property ti tj values assigned ti attributes smaller values assigned tj ti tj 
ti assigns values attributes predicates satisfied 
example belong distinct equivalence classes ea eb ec ed tuples generated satisfy kmax mt ed eb ec ea ed eb ec ea 
tn ed tn eb tn ec tn ea case lower bounded upper bounded 
respectively lower bounded predicate respectively redundant 
assume upper bounded lower bounded 
ea eb ec ed equivalence classes respectively 
equivalence classes unsatisfiable 
case tuples 
tn satisfy ec ea ec ea 
tn ec tn ea kmin kmax eb ed eb ed 
tn eb tn ed case lower bounded upper bounded symmetric 
proofs section section proves correctness evaluation strategy bounded memory computable spj queries self joins described section 
consider duplicate preserving duplicate eliminating queries separately 
acm transactions database systems vol 

month yy 
app arvind arasu duplicate preserving queries consider bounded memory computable duplicate preserving query sn 
recall section evaluation strategy involves maintaining synopses syn si current instance si stream si synopses syn si satisfy property equivalent si purposes evaluating 
sn syn 
syn sn recall 
sn output bag tuples si 
synopsis si contains representative tuple bucket count tuples seen far belong bucket ignoring tuples fail satisfy filter conditions si 
lemma proves tuples belonging bucket equivalent purposes evaluating lemma proof lemma 
theorem proves correctness evaluation strategy 
lemmas proofs stated context bounded memory computable query sn 
lemma 
inequality join predicate si sj unbounded upper bounded lower bounded 
proof 
assume 
checking algorithm table returns step 
implies computable bounded memory contradiction 
lemma 

tn set tuples belonging streams 
sn respectively join satisfy produce output tuple tuple si satisfies filter conditions si belongs bucket ti 
set tuples ti join produce output tuple proof 
computable bounded memory attributes agree bounded attributes 
project list bounded 
clearly ti tuples satisfy produce output tuple tuples tuples satisfy atomic predicates involve si differ si tuple 
prove satisfies atomic predicates involving attribute si 
consider filter predicates equality join predicates inequality join predicates separately 
definition satisfies filter predicates si 
computable bounded memory equality join predicates involve bounded attributes 
ti agree bounded attributes tuples satisfy equality join predicates consider inequality join predicate si sj 
prove valid considering cases 
tj kmin ti kmax case ti 
tj 
ti kmin case definition bucket kmin 
ti kmin implies attribute unbounded attribute bounded kmin tj kmax tj 
attribute unbounded lemma follows upper bounded acm transactions database systems vol 

month yy 
memory requirements continuous queries app lower bounded 
lower bounded kmin tj tj 
ti kmax case occur 
tj ti tj kmax 
unbounded 
lemma follows upper bounded implies ti kmax contradiction 
similarly show tuples satisfy inequality join predicate si sj 
tuples belong bucket satisfy filter predicates involving attributes si indistinguishable strategy retaining representative tuple bucket replicating times number tuples belonging bucket produces correct output 
theorem 
instances si input streams si 
sn syn 
syn sn 
proof 
straightforward lemma 
duplicate eliminating queries consider bounded memory computable duplicate eliminating query sn 
recall section synopsis syn si instance si stream si consists representative tuples bucket selected tuples seen far belonging bucket ignoring tuples fail satisfy filter predicates si 
representative tuples bucket si picked follows maxref si nonempty pick tuple maximum value min maxref si 
denote representative tuple tmax rest section 
minref si nonempty pick tuple minimum value max minref si 
denote tuple tmin 
maxref si minref si empty pick tuple appears si 
denote tuple 
simplify proofs partition maxref si sets si si defined follows 
si maxref si si maxref si 
similarly partition minref si sets si si ranges assigned attributes bucket lemma 
bucket si maxref si 
nonredundant predicate pb 
pb 
minref si 
nonredundant predicate pb 
pb acm transactions database systems vol 

month yy 
app arvind arasu proof 
sketch proof part proof part symmetric 
computable bounded memory predicates pb filters pb computable bounded memory 
suppose sake contradiction part incorrect pb maxref si definition exists nonredundant predicate pb verified checking algorithm returns step query pb 
implies pb computable bounded memory contradiction 
lemma 
bucket si si si empty 
si si empty 
proof 
provide proof part proof part symmetric 
suppose sake contradiction part hold 
exist attributes si si 
definition maxref exists nonredundant predicate pb follows lemma pb kmin pb kmax pb imply redundant pb contradiction 
lemma 
bucket si maxref si minref si nonempty si si nonempty si si empty 
denote set attributes involved nonredundant predicates si involved nonredundant predicates si 
nonredundant means nonredundant pb set attributes form equivalence class pb 
proof 
maxref si minref si 
definition exist attributes atomic predicates nonredundant pb 
belong equivalence class checking algorithm returns step query pb implying computable bounded memory contradiction 
follows attributes maxref si occur si implying si nonempty si empty 
symmetric argument follows si nonempty si empty 
proves part 
proof part ymax denote set attributes involved nonredundant inequality joins form si 
similarly ymin denote set attributes involved nonredundant inequality joins si 
nonredundant means nonredundant pb definition ymin ymax 
attributes proof part arbitrary attributes ymax ymin respectively 
belong equivalence class arbitrary choice attribute ymax belongs equivalence class attribute acm transactions database systems vol 

month yy 
memory requirements continuous queries app ymin 
ymin ymax nonempty follows attributes belong equivalence class 
theorem 
instances si input streams si 
sn syn 
syn sn 
proof 
syn si si follows syn 
syn sn 
sn 
prove 
sn syn 
syn sn holds 

sn formed joining tuples 
tn ti si 
claim exist tuples syn si join produce output tuple bi bucket stream si tuple ti belongs 
tuple representative tuples bi described earlier identified follows 
maxref si bi nonempty minref si bi empty pick tmax bi minref si bi nonempty maxref si bi empty pick tmin bi maxref si bi minref si bi empty pick bi maxref si bi minref si bi empty tmax bi tmin bi exist syn si 
pick tuples depending tuples 
tn described 
maxref si bi minref si bi empty infer lemma si bi si bi nonempty si bi si bi empty 
denote set attributes streams involved nonredundant inequality join attribute maxref si bi minref si bi 
lemma states attributes belong equivalence class 
tuples 
tn assign value say attributes smaller kmin pick tmin bi greater kmax pick tmax bi arbitrarily pick tmin bi tmax bi computable bounded memory attributes project list bounded 
clearly ti agree bounded attributes 
tuples satisfy conditions produce output tuple computable bounded memory equality join predicates satisfy involve bounded attributes 
set tuples equality join predicates definition tuples syn si satisfy filter conditions involving attributes si 
tuples satisfy filter conditions inequality join predicates remaining type predicate considered 
simplifies proof prove stronger statement tuples satisfy inequality join predicates pb 
pbn 
consider nonredundant inequality join predicate pb 
pbn 
attributes belong streams sl sm respectively 
clearly tuples 
tn satisfy predicates pb 
pbn tl tm 
nonredundant follows upper bounded lower bounded lower bounded upper bounded respect predicates pb 
pbn 
loss generality assume lower bounded upper bounded 
nonredundant pb 
pbn acm transactions database systems vol 

month yy 
app arvind arasu filter follows nonredundant pbl pbm 
sl bl sm bm 
repeated application lemma shown predicate pb 
pbn sl bl sm bm 
max tl sl bl min tm sm bm claim tmin bl picked tmax bm picked sl bl nonempty follows lemma maxref sl bl empty pick tmin bl similarly minref sm bm empty pick tmax bm possible minref sm bm nonempty lemma allows sm bm obviously nonempty sm bm nonempty 
case pick depending common value assigned 
tn attributes involved nonredundant pm inequality join attributes maxref sm bm minref sm bm 
value greater kmax lower bounded tmax bm picked case 
definition tmin bl tmax bm follows max sl bl max tl sl bl min tm sm bm min sm bm holds implying tuples 
inequality join predicates pb 
pbn 
received month year revised month year accepted month year acm transactions database systems vol 

month yy 
satisfy 
