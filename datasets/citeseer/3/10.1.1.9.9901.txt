optimistic evaluation adaptive evaluation strategy non strict programs robert computer laboratory university cambridge robert cl cam ac uk lazy programs beautiful slow build thunks 
simple measurements show thunks unnecessary fact evaluated cheap 
describe optimistic evaluation evaluation strategy exploits observation 
optimistic evaluation complements compile time analyses run time experiments evaluates thunk speculatively abortion mechanism back bad choice 
run time adaption mechanism records expressions unsuitable speculative evaluation arranges evaluated lazily 
implemented optimistic evaluation glasgow haskell compiler 
results encouraging programs speed significantly improve dramatically go slower 
categories subject descriptors programming languages language classifications applicative functional languages lazy evaluation programming languages processors code generation optimization profiling general terms performance languages theory keywords lazy evaluation online profiling haskell 
lazy evaluation great programmers carries significant run time overheads 
evaluating function argument call lazy evaluation thunk suspension passes 
function needs value argument forces permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
icfp august uppsala sweden 
copyright acm 
simon peyton jones microsoft research cambridge simonpj microsoft com thunk 
argument passing mechanism called call contrast common call value 
extra memory traffic caused thunk creation forcing lazy programs perform noticeably worse strict counterparts time space 
compilers lazy languages sophisticated static analyses turn call need slow sound call value fast dangerous 
basic analyses strictness analysis identifies expressions evaluated analysis locates expressions certain cheap safe evaluate 
static analysis conservative forcing keep thunks probably unnecessary provably unnecessary 
shows measurements taken glasgow haskell compiler mature optimising compiler haskell ghc implements strictness analysis analysis reasons discussed section 
shows thunks cheap usually 
exact definition cheap usually important data prima facie evidence big opportunity 
language implementation call value thunks overheads laziness reduced significantly 
presents realistic approach optimistic evaluation just 
optimistic evaluation decides run time evaluated eagerly provides abortion mechanism backs eager computations go long 
contributions idea optimistic evaluation se obvious see section 
obvious cheap benefits exceed costs avoid easier get big speedups programs accept big slowdowns robust run full scale application programs modification mature optimising compiler exploited easy wins 
section describe mechanisms meet goals 
demonstrated practice implementing glasgow haskell compiler ghc 
optimistic evaluation slippery topic 
give operational semantics lazy evaluator enhanced optimistic evaluation section 
machine allows refine general design choices precise form 
performance numbers encouraging produced stable extended version ghc able compile arbitrary haskell programs 
tested set reasonably large realistic programs produced geometric mean speedup just program slowing 
significantly naively written programs suffer space leaks speed massively improvements greater common 
results compiler mature ghc big news 
example strictness analysis buys 
baseline mature begun explore design space optimistic evaluation confident initial results improved 

optimistic evaluation approach compiling lazy programs involves modifying back compiler run time system 
existing analyses transformations applied usual program simplified form thunk allocation done expression section 
back modified follows expression compiled build thunk right hand side evaluate right hand side speculatively section 
depends state run time adjustable switch expression 
set switches known speculation configuration 
configuration initialised lets speculative 
evaluator finds speculatively evaluating expensive expression abortion suspend speculative computation building special continuation thunk heap 
execution continues body speculative right hand side suspended section 
recursively generated structures infinite lists generated chunks reducing costs laziness avoiding doing lots unneeded section 
online profiling find lets expensive evaluate rarely section 
profiler modifies speculation configuration switching speculative evaluation offending lets evaluate right hand sides lazily strictly 
just cache exploits principle locality optimistic evaluation exploits principle thunks cheap ultimately evaluated 
practice realistic implementation requires quite array mechanisms abortion adaption online profiling support percentage dynamically allocated thunks cheap usually queens primes integrate gen exp digits digits sieve infer anna constraints wheel sieve rsa atom boyer thunks commonly optimistic evaluation really addition care real world details errors input output 
sub sections introduce mechanisms time 
identifying addressing concerns main contributions 
avoid continual tackle related section 
term speculative evaluation mean evaluation result may needed optimistic evaluation describes entire evaluation strategy abortion profiling adaption 
expressions intermediate language consumed code generator expression construct allocates thunks 
design chooses dynamically allocate thunk evaluate right hand side speculatively 
example rhs body code generator translates code behaves logically value rhs lazy thunk compute rhs needed evaluate body current implementation associates static switch case 
possible choices 
example function map different contexts desirable switch take calling context account 
explored context dependent possibilities complexity costs dynamic switches overwhelm uncertain benefits 
case ghc aggressive inlining tends reduce particular problem 
rhs large compilation scheme result code bloat 
avoid lifting right hand sides expressions new functions 
abortion point optimistic evaluation callby value hope evaluation terminate quickly 
obviously essential way recover optimism turns unfounded 
role abortion 
evaluator detects speculation going long time aborts current speculations course nested resuming started outermost speculation 
detecting speculation running long done ways choice important long imposes minimal overheads normal execution 
way running code aware long running actively call run time system run fixed amount time 
approach currently implement periodic sample points look state running program 
execution remains speculation sample points consider speculation gone long 
abortion implemented different ways 
current scheme shares implementation handling asynchronous exceptions 
suspension created heap containing aborted computation 
result needed computation resume point left 
abortion turns rare event tens program run need particularly efficient 
abortion guarantee correctness program deliver results lazy counterpart 
optionally turn static switch aborted lets run lazily strategies possible 
get crude bound total time space consumed aborted computations 
finitely lets program turning abortion bounds take place life program limit entire program runs lazily 
wasted done abortion bounded twice sample interval 
evaluation consider program generates infinite stream integers 
int int rest rest speculative evaluation rest thunk evaluation certain abort 

evaluating speculatively evaluate speculatively evaluate 
long turns speculative evaluation rest making completely lazy 
big lost opportunity lazily evaluating lazily generated list tail cell returned sure evaluated 
thunks easily caught optimistic evaluation cheap 
really create list chunks elements 
creating chunk rest evaluated speculatively 
chunk finished example elements created rest switches lazy evaluation causing function terminate quickly 
approach largely removes overheads laziness thunks lazy allows infinite data structures 
behaviour useful finite lists completely evaluated 
lazy programmers generate filter paradigm relying laziness avoid creating large intermediate list 
compiler knew intermediate list completely evaluated bad plan evaluate strictly 
evaluation better 
way implement evaluation limit deeply speculation nested 
code behaves semantically note generalises code section limit value rhs lazy thunk rhs evaluate body count number nested speculations currently inside limit limit deeply particular speculated 
intuition deeper speculation stack new speculation useful 
limit adjusted run time control extent may speculated 
exceptions errors consider function bad error bad haskell error function prints error message halts program 
optimistic evaluation may evaluate bad knowing bad needed 
obviously unacceptable print halt program lazy evaluation false 
issue applies exceptions kinds including divide zero black hole detection 
ghc error raises exception halting program 
exception dispatch mechanism tears frames stack conventional way 
change needed modify existing dispatch mechanism recognise speculative evaluation frame bind variable thunk re raises exception 
behaves catch statement preventing exceptions raised speculative execution escaping 
unsafe input output optimistic evaluation safe haskell pure language evaluation side effects 
input output safely partitioned io monad danger speculative computations performing haskell programs impure function unsafeperformio 
speculatively evaluating calls function cause observable behaviour different lazy implementation 
safe abort io computations io operation may locked resource temporarily put global data structures invalid state 
reasons opted disallow speculation unsafeperformio 
speculation attempts apply functions abort immediately 

online profiling abortion may guarantee correctness section guarantee efficiency 
turns mechanisms described far programs run faster run dramatically slower 
example constraints program nofib runs times slower 

detailed investigation shows programs build moderately expensive thunks seldom 
thunks cheap trigger abortion aggregate waste massive amounts time space 
obvious solution trigger abortion quickly starting speculative evaluation limiting wasted 
approach fails exploit thunks cheap support evaluation 
order know expression speculated need know amount potentially wasted outweighs amount lazy evaluation overhead potentially avoided 
obtain information form online profiling 
idealised profiling describing idealised profiling scheme profiled time 
maintain static counters incremented speculative evaluation right hand side begun 
records amount wasted speculations 
quotient wastage quotient average amount wasted speculation 
wastage quotient larger cost allocating updating thunk speculation wasting reduce extent speculated 
fact critical threshold tunable implementation 
mean reasonable measure execution cost time allocation 
idealised model just think global register incremented regularly execution proceeds discuss practical implementation section 
record speculation includes done compute value computing sub speculations values needed 
operationally may imagine global register saved speculative evaluation righthand side zeroed evaluation right hand side 
sub speculation needed 
profiler attribute costs lazy evaluation 
example consider expensive 
evaluation speculatively evaluate expensive turns needed costs expensive attributed speculating perfectly correct value 
implement idea 
speculation completes wrap returned value special indirection closure contains returned value amount done produce evaluation needs value perform addition evaluates closure bound just bound thunk 
indirection evaluated adds global counter subtracts static counter transferring costs small important point speculating save restore counter increment thunk allocation cost 
motivation ensure cost attribution regardless speculated 
scheme attribute cost speculative evaluation fair 
example speculative evaluation incur cost evaluating thunk fact needed anyway real cost speculating tiny just incrementing value 
safe estimate cost speculation simply accept approximation 
safety guarantee program runs slowly lazy evaluation profiler spot react reducing amount speculation 
profiler assumes slowdown due speculation due wasted speculations 
wasted wastage quotient greater thunk allocation cost 
profiler sees property reduces amount speculation done 
eventually speculation configuration settle faster lazy evaluation worst case speculation disabled execution reverts back lazy evaluation 
safety property holds approximate profiling scheme provided approximate scheme conservative overestimates total amount wasted 
random sampling inefficient profile time profile random selection speculations 
regular intervals called sample points profile active speculation sample point finishes 
double measured approximate complete execution cost speculation 
sources error 
sample randomly time see expensive speculations frequently inexpensive ones 
fact see section space usage major factor 
stack stack time sample point speculation speculation underestimating wasted time sample point speculation speculation overestimating wasted believe practice problem particularly expensive speculations ones wasting 
second reasonably assume sample point uniformly distributed moment speculation begins moment ends ticks attributed speculation may uniformly distributed period 
example expensive expensive 
attributed cost evaluating expensive evaluating expensive attributed furthermore evaluation expensive precedes evaluation expensive 
place sample point middle speculation get estimate done 
illustrated counted shaded ignored unshaded 
alas estimates safe 
turns problem subtle reason 
example speculation speculation finished 
assume expensive exactly amount expensive 
sample point chance falling start speculation chance falling 
sample point falls speculation starts attribute underestimating units 
sample point falls speculation starts profile speculation attribute done expensive overestimating average units factor comes doubling measured cost mentioned 
net effect estimate cost 
example front loaded extreme case 
informal argument generalised show sampling approach estimate costs 
implementing profiling implement profiling overwriting return frames stack 
sample point walk stack find return frames active speculations 
return frames overwritten address profiling system routine real return address away safe keeping 
speculation finishes jump back profiling system hijacked return point 
profiler calculates estimate done speculation 
available timers accurate allow accurate measure time elapsed speculation amount heap allocated speculation 
fairly reasonable estimate provided ensure recursions allocate heap 

complex 
time reader may thinking isn complicated 
really need abortion expressions evaluation special handling io online profiling 
answer fold 
just compiler needs lot bullets gun tackle widely varying programs believe true optimistic evaluation 
idea practice real programs mature compiler just lot cases cover 
contributions precisely explored idea deeply expose cases 
section quantifies effect removing individual bullets 
second actual implementation ghc overly complex 
changes compiler minor lines program 
changes run time system significant run time system lines added lines altered lines certainly trivial increase reasonable major innovation 

operational semantics remarked optimistic evaluation subtle 
extremely helpful write formal operational semantics explain exactly happens speculative evaluation abortion adaption 
section briefly semantics 
simple language language haskell 
externally visible haskell language complex compiler reduces simple language variable xi case pi constructor app case analysis thunk creation abstraction application exn exception error xi pattern match xi exn values var var value upd app app app exn exn case case pi pi case pi xi pk xi case exn pi exn lazy new spec spec new binder unique 
allows uniquely refer binder 
functions constructors applied variables expressions 
follows point thunk created 
case expression arbitrary expression build thunk 
restrict non recursive expressions 
restrict expressiveness language user fixed point combinator 
simplify semantics recursive expressions problematic speculated 
omit literals primitive operators sake brevity 
adding introduces extra complications 
exceptions errors section handed exactly described treating exception value control operator 
operational framework describe program execution small step operational semantics describing program state changes execution proceeds 
main transition relation takes form meaning state evolves step 
components state follows 
represents heap 
function mapping names expressions 
expression currently evaluated 
stack continuations containing done forms speculation return binding pi case choose pattern pi application arg update thunk bound write denote number speculation frames stack refer speculation depth 
operational semantics evaluation speculation configuration 
maps binder natural number number says deeply speculating allowed create new speculation 
lazy 
online profiling may change mapping program running 
transition rules 
absolutely conventional interesting ones optimistic evaluation 
rule lazy depth limit current speculation depth 
rule simply builds thunk heap address binds rule spec greater current speculation depth pushes return frame begins evaluation righthand side 
return spec decrements binds address computed value 
series sample points online profiler runs 
things change speculation configuration second abort running speculations 
process abortion described transitions 
abortion rule removes continuation stack undoing rule put 
sound keep applying rules stack empty point continuing speculative continuation removed stack implementation stops point 
merit having operational semantics allows formalise profiling semantics described section 
elaborated semantics describe profiling cost attribution space prevents showing 

performance measured effect optimistic evaluation programs 
programs taken real subset nofib suite taken spectral subset 
programs reasonably sized realistic programs 
ghc lines mean benchmarks lines 
programs selected performance results obtained 
spec new 
case pi case pi app upd ran program modified compiler ghc compiler implementation forked 
results normal ghc done optimisations enabled 
tests performed mhz pentium iii mbytes memory 
implementation benchmarked remember speculation configurations runs 
reduce effect cold start arranged benchmark run seconds 
summarise results tests 
full results please refer appendix rsa reptile prolog atom parser sphere infer mandel fluid clausify compress constraints anna boyer ghc benchmark run time relative normal ghc execution time shows effect optimistic evaluation run time 
results encouraging 
average speedup just programs speed dramatically program slows 
expect results depend nature program 
program strict inner loop strictness analyser solves little room improvement 
similarly inner loop inherently lazy improve things extra overhead having branch slow things 
case rsa speculation virtually effect rsa spends time inside library written results reflect single fixed set tuning parameters thunk cost threshold section chose manual experimentation 
changing parameters improve run time particular program significantly cost worsening 
sophisticated profiling strategy achieve minimal run time program remains seen 
operational semantics abortion heap residency programs extremely inefficient executed lazily contain space leak 
people post programs haskell mailing list asking going slowly 
example simple word counting program 
inner loop slightly simplified count char int int int int int count nw nc nw nc count cs new nw nc case normal count cs nw new nc white count cs nw nc time loop sees character increments accumulating parameter nc 
lazy evaluation long chain addition thunks builds length proportional size input file 
contrast optimistic version evaluates addition speculatively program runs constant space 
optimistic evaluation speeds program unable produce input file small allow lazy implementation terminate reasonable time large allow optimistic implementation run long accurately timed 
residency column appendix shows effect maximum heap size benchmark set mean normal ghc 
surprisingly improvement smaller count real programs space leaks cured programs space 
optimistic evaluation reduce prevalence unexpectedly bad space behaviour common problem haskell programmers welcome step forward 
code size code size increases significantly average 
due need generate lazy strict versions expressions 
paid attention code bloat confident reduced substantially demonstrate 
performance comes performance improvement come 
get performance results simpler system 
shows performance simplified variants system relative full optimistic implementation 
shows performance altered versions normal ghc relative normal ghc 
evaluation 
bars show effect switching evaluation 
semi rsa reptile prolog atom parser sphere infer mandel fluid clausify compress constraints anna boyer ghc strictness profile run times simplified implementations lazy rsa reptile prolog atom parser sphere infer mandel fluid clausify compress constraints anna boyer ghc strictness effect changes normal ghc evaluation turned expression reduction depth allowed cases 
programs largely unaffected suffer significantly 
constraints speeds 
semi tagging 
implementation optimistic evaluation uses optimisation called semi tagging briefly explain 
evaluating case expression ghc normally jumps entry point scrutinee passing vector return addresses possible constructor 
scrutinee value entry point simply return relevant return address 
alternative plan called semi tagging jumping scrutinee entry point test scrutinee evaluated 
case avoid slow indirect call return 
bars show effect enabling semi tagging relative baseline ghc optimistic evaluation 
normal lazy evaluation scrutinee unevaluated semi tagging win average average speedup 
optimistic evaluation evaluated semi tagging gives consistent improvement 
semi bars relative full optimistic evaluator show switching optimistically evaluated pro gram run slower 
short optimistic evaluation turns mixed blessing consistent substantial win 
real bonus originally anticipate 
strictness analysis 
strictness bars show effect turning ghc strictness analysis 
shows strictness analysis usually big win normal ghc see effect switching strictness analysis implementation far smaller 
absence strictness analysis win optimistic evaluation far greater ones report 
profiling 
profile bars show effect disabling online profiling 
programs largely unaffected programs constraints slow massively 
programs justify profiling section goal give acceptable performance cases occasional massive unpredictable slow downs 
overheads 
lazy bars show happens pay costs optimistic evaluation get benefits 
experiment set map lets done lazily 
comparing normal ghc baseline graph shows overheads profiler mechanism impose normal evaluation 

related static analyses static analysis possible preferred results analysis enable cascade transformations optimisations static choices compiled straight line code better register allocation 
ghc fairly sophisticated strictness analyser results relative baseline strictness analysis 
switch speedups optimistic evaluation greater 
promising static analysis fax cheap eagerness analysis attempts thunks guaranteed cheap evaluate call value sound waste result 
development dynamic cheap eagerness uses complicated analysis add extra depth parameter selected recursive functions plus explicit cut test achieve effect similar evaluation 
cheap eagerness built sophisticated flow analysis 
thunk cheap 
depends evaluated argument function need examine calls function straightforward higher order program 
worse program analysis causes problems separate compilation big problem shipping pre compiled libraries 
problems may soluble example compiling multiple clones function suitable different evaluation pattern additional implementation complexity significant 
implement cheap eagerness ghc comparison purposes 
sufficiently clever program static analysis discover cheap thunks find online profiler 
critical difference find cheap thunks particularly clever requiring particularly complex implementation getting way separate compilation 
fax reports promising speedups generally range relative baseline compiler appropriate compare figures directly 
fax careful point baseline compiler prototype strictness analyser simple benchmarks small 
improvements analysis may turn persuasive sophisticated strictness analyser program optimiser baseline 
strictness analysis require program flow analysis readily adapts separate compilation 
exist static analyses improve performance lazy programs 
particular grin project takes different spin static analysis 
program analysis discover case expression set thunk expressions evaluated point 
bodies expressions inlined usage sites avoiding cost lazy evaluation 
transformations prevent lazy space leaks 
eager haskell eager haskell developed simultaneously independently 
basic premise identical eager evaluation default abortion mechanism back eagerness turns 
implementation different 
eager haskell evaluates absolutely eagerly periodically aborts running computation right back root 
abortion frequent lest costs dominate infrequent lest wasted 
abortion mechanism different allows computation proceed function call builds thunk making call 
net effect somewhat similar evaluation appears require entirely new code generator 
main advantage eager haskell adaptively decide expressions appropriate evaluate eagerly eager haskell evaluates eagerly 
programs eager evaluation plan eager haskell gets similar speedups optimistic evaluation 
programs laziness plays important role eager haskell slow relative normal ghc factor 
extreme case constraints program eager haskell goes times slower normal ghc optimistic evaluation slows 
eager haskell users encouraged deal problems annotating programs laziness annotations optimistic evaluation require 
easier get speedups cases accepting big slow downs 
hard tell eager haskell wins reduced solve big slow problem automated way 
speculative parallelism parallel programming community making speculation exploit parallel processors long time 
aim spare processors arranging evaluate expressions known needed 
large amount field cite small subset 
variants multilisp allow programmer suggest expression evaluated speculatively 
mattson speculatively evaluates lazy expressions parallel 
local speculation speculations local processor waiting reducing minimum size useful speculation 
speculatively evaluates logic programming expressions parallel user able annotate speculations priority 
major preoccupation speculative parallelism achieving large granularity potential gain parallelism cancelled cost spawning synchronisation 
setting exact reverse holds 
large thunk done lazily cost allocating updating swamped evaluation costs cheap thunks want speculate 
haynes friedman describe explicit engines process abstraction programmer spawn resource limited thread 
engine certain amount fuel fuel runs engine returns continuation engine fuel 
engines coarse grain explicit user control big differences 
strand takes eager parallelism baseline strives aggregate partition tiny threads larger compound threads 
ways closer call need bit parallel evaluation scheduled uniprocessor callby value aggregates lazy thread parent 
issues quite different schauser puts difficulty put thread communication load balancing constraints 
furthermore thread partitioning static approach dynamic 
strand lazy thread creation strives thread creation free case required 
successful variant idea cilk parent thread saves continuation optimistically executing spawned child child blocks processor resume saved continuation 
processors steal saved continuation 
big difference cilk threads assumed required possibility lazy thunk needed crux matter 
summary despite common theme speculative evaluation declarative setting little overlap concerns speculation parallelism optimistic evaluation 
evaluation evaluation strategy designed reduce space leaks described section 
evaluating expression garbage collection evaluator little bit expression hope evaluating avoiding having build thunk 
eager haskell expressions eagerly evaluated amount evaluation done abortion significantly smaller simple evaluations allowed 
small amount useful causing programs run slower 
evaluation implemented lml compiler 
branch prediction modern processors 
processor speculatively execute whichever side branch thought 
optimistic evaluation observation running program guide speculation 
static analysis guide branch prediction 
online profiling existing language implementations including implementations java language hotspot jalapeno 
implementations techniques self 
systems similar techniques optimistic evaluation apply laziness 
feedback directed optimisation widely technique static compilers 
program run special profiling mode recording statistics behaviour program 
statistics compiler optimisation choices compiling final version program 
commercial compilers technique 
principle compiling configuration program making adapt run time done 

goal allow programmer write programs lazy language having strictness annotations order obtain performance 
measurements show optimistic evaluation improve performance relative tough baseline 
implementation represents just point large design space just explore 
encouraging get results early things get better 
particular looking heap usage profiling 
shown section optimistic evaluation speeds programs preventing filling heap thunks 
current system take heap behaviour account deciding expressions evaluated optimistically missing opportunities speed programs 
plan explore ways making better decisions account behaviour heap 
proving worst case performance 
stressed importance avoiding bad performance particular programs 
experiments show program run slower system normal ghc 
prove property 
operational semantics section preliminary suggests prove online profiler eventually find expressions waste optimistic evaluation constant factor worse ordinary call need fixed overheads speculation configuration converged preparation 
hundreds papers compilation techniques call value hundreds call 
far know independent explore rich territory choosing dynamically extremes 
implementation described freely available ghc cvs readers encouraged download look 
plan include optimistic evaluation release version ghc soon 
acknowledgments grateful generous support microsoft research funded studentship author 
manuel chakravarty fergus henderson jan willem simon marlow greg morrisett alan mycroft nick nethercote andy pitts norman ramsey john reppy richard sharp provided useful suggestions 

augustsson johnsson 
chalmers lazy ml compiler 
computer journal apr 
ball larus 
branch prediction free 
acm conference programming languages design implementation pldi pages 
acm june 

code optimisation techniques lazy functional languages 
phd thesis chalmers university technology sweden april 
burke 
choi fink grove hind sarkar serrano sreedhar srinivasan whaley 
jalapeno dynamic optimizing compiler java 
proceedings acm java grande conference 
burton 
speculative computation parallelism functional programming 
ieee trans computers dec 
chakravarty 
lazy thread task creation parallel graph reduction 
international workshop implementing functional languages lecture notes computer science 
springer verlag 

fax cheap eagerness speculative evaluation lazy functional language 
acm sigplan international conference functional programming icfp montreal sept 
acm 

fax dynamic cheap eagerness 
proceedings workshop implementing functional languages 
springer verlag 
acm workshop feedback directed dynamic optimization 
leiserson randall 
implementation cilk multithreaded language 
acm conference programming languages design implementation pldi volume pages atlanta may 
acm 
gustavsson 
type sharing analysis update avoidance optimisation 
acm sigplan international conference functional programming icfp volume acm sigplan notices baltimore 
acm 
halstead 
multilisp language concurrent symbolic computation 
acm transactions programming languages systems oct 
hammond donnell editors 
functional programming glasgow workshops computing 
springer verlag 
haynes friedman 
engines build process abstractions 
conference record acm symposium lisp functional programming 
lzle 
adaptive optimization self reconciling high performance exploratory programming 
ph thesis computer science department stanford university mar 
hughes 
functional programming matters 
computer journal apr 

speculative computation priorities concurrent logic languages 
conference 
gosling 
java language environment white 
technical report sun microsystems 


eager haskell resource bounded execution yields efficient iteration 
haskell workshop pittsburgh 


hybrid eager lazy evaluation efficient compilation haskell 
phd thesis massachusetts institute technology june 
marlow peyton jones moran reppy 
asynchronous exceptions haskell 
acm conference programming languages design implementation pldi pages snowbird utah june 
acm 
mattson 
effective speculative evaluation technique parallel graph reduction 
ph thesis department computer science engineering university california san diego feb 
mattson jr griswold 
local speculative evaluation distributed graph reduction 
hammond donnell pages 
maurer 
isn tail recursive 
message posted haskell mailing list haskell org haskell march html mar 
mohr kranz halstead 
lazy task creation technique increasing granularity parallel programs 
ieee transactions parallel distributed systems july 
moran lassen peyton jones 
imprecise exceptions inductively 
higher order operational techniques semantics third international workshop number electronic notes theoretical computer science pages 
elsevier 

speculative computation multilisp 
phd thesis mit lab computer science dec 
partain 
nofib benchmark suite haskell programs 
launchbury sansom editors functional programming glasgow workshops computing pages 
springer verlag 
peyton jones hall hammond partain wadler 
glasgow haskell compiler technical overview 
proceedings joint framework information technology technical conference keele pages 
dti serc mar 
peyton jones marlow reid 
stg runtime system revised 
technical report microsoft research february 
part ghc source package 
peyton jones partain 
measuring effectiveness simple strictness analyser 
hammond donnell pages 
peyton jones reid hoare marlow henderson 
semantics imprecise exceptions 
acm conference programming languages design implementation pldi pages atlanta may 
acm 
peyton jones wadler 
imperative functional programming 
th acm symposium principles programming languages popl pages 
acm jan 
schauser culler goldstein 
separation constraint partitioning new algorithm partitioning non strict programs sequential threads 
nd acm symposium principles programming languages popl pages 
acm jan 
sestoft 
deriving lazy machine 
journal functional programming 
smith 
study branch prediction strategies 
international symposium computer architecture 
sun microsystems 
java hotspot virtual machine white 
traub 
sequential implementation lenient programming languages 
ph thesis mit lab computer science 
von 
evaluation 
licentiate thesis chalmers university technology may 
wadler hughes 
projections strictness analysis 
kahn editor functional programming languages computer architecture 
springer verlag lncs sept 
table test statistics normal ghc optimistic vs normal ghc vs normal ghc vs optimistic test name code run code run code heap semi semi lines time size time size dency tagging lazy tagging profile ghc boyer anna constraints compress clausify fluid mandel infer sphere parser atom prolog reptile rsa minimum maximum geometric mean arithmetic mean 
