acm symposium principles programming languages popl january ownership types object encapsulation chandrasekhar boyapati laboratory computer science massachusetts technology cambridge ma chandra lcs mit edu ownership types provide statically enforceable way specifying object encapsulation enable local reasoning program correctness object oriented languages 
type system enforces strict object encapsulation constraining allow efficient implementation important constructs iterators 
argues right way solve problem allow objects classes defined module privileged access representations show inner classes 
approach allows programmers express constructs iterators supports local reasoning correctness classes class inner classes reasoned module 
sketches variant ownership types enable efficient software upgrades persistent object stores 
categories subject descriptors programming languages language constructs software engineering program verification general terms languages verification theory keywords ownership types object encapsulation software upgrades ability reason locally program correctness crucial dealing large programs 
local reasoning allows correctness dealt module time 
module specification describes expected behavior 
goal prove module satisfies research supported part darpa contract nsf iis ntt 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
popl january new orleans louisiana usa 
copyright acm barbara liskov laboratory computer science massachusetts technology cambridge ma liskov lcs mit edu shrira department computer science brandeis university waltham ma cs brandeis edu specification specifications code modules 
way complexity proof effort formal informal kept control 
local reasoning approach sound separate verification individual modules suffices ensure correctness composite program 
key sound local reasoning object oriented languages object encapsulation 
consider example stack object implemented linked list 
local reasoning correctness stack implementation possible objects outside directly access list nodes list nodes encapsulated presents variant ownership types specifying statically enforcing object encapsulation 
ownership types program declare owns list nodes 
type system statically ensures list nodes encapsulated type system enforces strict object encapsulation constraining allow efficient implementation important constructs iterators 
consider example iterator mentioned stack object iterator encapsulated outside iterator encapsulated directly access list nodes run efficiently 
previous ownership type systems constraining support constructs iterators permissive support local reasoning example allowed objects outside mentioned stack object temporarily get direct access list nodes :10.1.1.23.2115:10.1.1.59.6498:10.1.1.1.5802
argues right way solve problem provide special access privileges objects belonging classes module show inner classes 
variant ownership types allows inner class objects privileged access representations corresponding outer class objects 
principled violation encapsulation allows programmers express constructs iterators inner classes supports local reasoning correctness classes 
system supports local reasoning class inner classes reasoned module 
describes variant ownership types enables efficient software upgrades persistent object stores 
interest software upgrades led ownership types 
shows ownership types ensure code upgrading objects observe broken invariants interfaces unknown time written possible programmers reason correctness upgrades 
organized follows 
section discusses object encapsulation 
section describes variant ownership types enforcing object encapsulation 
section presents formal description type system 
section shows ownership types enable modular upgrades 
section discusses related section concludes 
object encapsulation object encapsulation important provides ability reason locally program correctness 
reasoning class object oriented program involves reasoning behavior objects belonging class 
typically objects point subobjects represent containing object 
local reasoning class correctness possible subobjects fully encapsulated subobjects accessible containing object 
condition supports local reasoning ensures outside objects interact subobjects calling methods containing object 
containing object control subobjects 
full encapsulation needed 
encapsulation required subobjects containing object depends 
object depends subobject calls methods furthermore calls expose mutable behavior way affects invariants stack object implemented linked list depends list items contained list 
code outside manipulate list invalidate correctness stack implementation 
code outside safely items contained doesn call methods depends identities items identities change 
similarly set immutable elements depend elements invokes equals ensure elements set equal elements immutable 
local reasoning class possible objects class encapsulate object depend 
strict object encapsulation constraining prevents efficient implementation important constructs iterators 
example run efficiently iterator abovementioned stack object needs access list nodes provide access allow objects iterators violate encapsulation 
local reasoning possible provided violations encapsulation limited code contained module 
example stack iterator imple 
object owner 

owner object world 

owner object change time 

ownership relation forms tree rooted world 
ownership properties world ownership relation mented module reason correctness locally examining code module 
ownership types encapsulation ownership types provide statically enforceable way specifying object encapsulation :10.1.1.23.2115:10.1.1.59.6498:10.1.1.1.5802
idea object subobjects depends preventing accessible outside 
section presents ownership type system 
system similar described main difference support constructs iterators type system allows temporary violations encapsulation 
disallow violation 
support constructs iterators inner classes 
key type system concept object ownership 
object owner 
owner object special owner called world 
type system statically guarantees ownership properties shown 
presents example ownership relation 
draw arrow owns special owner world owns objects owns owns owns 
ownership allows program statically declare encapsulation boundaries capture dependencies 
object objects depends 
system enforces encapsulation inside encapsulation boundary outside access 
object accesses object pointer methods obtain pointer 
inside encapsulation boundary outside access 
object allowed access objects owns ancestors ownership tree objects globally accessible objects objects owned world 
access objects 
note analogy nested procedures proc var class tstack towner tnode towner head null void push towner value tnode towner newnode new tnode towner value head head newnode towner pop head null return null towner value head value head head return value class tnode towner tnode towner towner value tnode towner tnode towner value towner value return value tnode towner return class towner class void test tstack new tstack tstack world new tstack world tstack world world new tstack world world tstack world new tstack world tstack head tnode head tnode stack objects tstack head head tnode tnode head value head value head value head value world tstack head head tnode tnode head value head value ownership relation owner polymorphism type system context java language augmented ownership types 
class definition parameterized owners 
owner parameter special identifies owner corresponding object 
owner parameters propagate ownership information 
parameterization allows programmers implement generic class objects different owners 
parameterization similar parametric polymorphism parameters owners types 
owner instantiated world owner parameter 
objects owned encapsulated objects accessed outside 
objects owned world accessed 
proc var proc 
say xn pn children pn 
pn access pn children ancestors pn children global variables procedures 
class towner towner 
tstack towner clauses constrain owners shows example 
tstack stack objects 
implemented linked list 
tstack class parameterized towner 
stack owner owns tstack object towner owns objects contained tstack 
code specifies tstack object owns nodes list list nodes accessed outside tstack object 
type tstack instantiated owner parameters 
means tstack owned object created objects 
tstack owned object objects owned world 
tstack owned world objects 
ownership relation depicted assuming stacks contain elements 
dotted line indicates object directly indirectly owned world 
constraints owners type xn multiple owners type system statically enforces constraint xi 
recall ownership relation forms tree rooted world 
notation means descendant ownership tree 
notation means descendant ownership tree 
type tstack illegal world 
constraint 
extend parameterized methods 
method xn xk 
object type xn restriction xi 
constraints needed provide encapsulation presence subtyping 
illustrates point example 
check ownership constraints modularly necessary programmers specify additional constraints class method parameters 
example type legal towner 
allow programmers specify additional constraints clauses type system enforces constraints 
example class specifies towner 
instantiation satisfy constraint illegal 
subtyping rule declaring subtype owner parameter supertype subtype addition course supertype satisfy constraints owners 
owners match example shows type annotations written explicitly 
automatically inferred 
see section details 
class tstack towner tnode towner head null 
tstackenum towner elements towner return new tstackenum towner class tstackenum towner implements tenumeration towner tnode tstack towner current tstackenum current tstack head towner getnext current null return null towner current value current current return boolean hasmoreelements return current null class void test tstack world new tstack world tenumeration world elements tenumeration world world elements interface tenumeration towner towner getnext boolean hasmoreelements tstack iterator special corresponding objects 
tstack towner subtype object towner subtype object world owners match 
inner classes inner classes similar member inner classes java 
inner class definitions nested inside classes 
shows example 
inner class tstackenum implements iterator tstack elements method tstack provides way create iterator tstack 
tstack code similar 
recall owner instantiated world owner parameter 
inner class owner instantiated outer class 
feature allows inner object access objects encapsulated outer objects 
owner current field instantiated tstack 
current field accesses list nodes encapsulated outer tstack object 
inner class parameterized owners just regular class 
system outer class parameters automatically visible inside inner class 
inner class uses outer class parameter explicitly include outer class parameter declaration 
tstackenum declaration includes owner parameter towner outer class 
towner visible inside tstackenum 
tstackenum declaration class tstack towner tnode towner head null 
class tstackenum towner implements tenumeration towner tnode tstack towner current 
towner getnext writes reads tstack 
boolean hasmoreelements reads 
interface tenumeration towner towner getnext writes reads world boolean hasmoreelements reads tstack iterator effects include 
visible inside tstackenum 
note example elements method parameterized 
allows program create different iterators different owners 
elements returns iterator type tstackenum towner type legal case towner 
requirement captured clause 
note tstack towner tstackenum towner declared subtype tenumeration towner allows create iterator encapsulated tstack program pass objects outside 
general inner classes implement wrappers expose limited interface outer object 
program create wrapper encapsulated subobject pass wrapper object outside encapsulation boundary 
encapsulation theorem system provides encapsulation property theorem 
access object owned 

inner class object proof 
consider code class 

variable type declared static scope class owner world formal class parameter formal method parameter outer class 
show cases constraint holds 
cases constraint holds trivially 
cases constraint holds 
fifth case 
object class access object owned cases inner object fifth case 
class int int size reads return void add int writes 

class intstack vec new void push int writes vec add 
void vo intstack vo writes reads int size push assert size reasoning aliasing side effects discussion variant ownership types supports local reasoning provided programmer declares depended objects owned 
theorem implies owned objects accessed inside owner inner objects 
ownership captures depends relation described section local reasoning correctness class possible class inner classes reasoned module 
ownership types expressive 
allow efficient implementation constructs iterators wrappers 
furthermore allow programs create wrappers contexts underlying object inaccessible 
ability illustrated iterator globally tstack iterating 
ownership type system support constructs iterators generally accessible wrappers ensuring local reasoning 
discuss section 
effects clauses system contains effects clauses useful specifying assumptions hold method boundaries enable modular reasoning checking programs 
effects ownership types enable modular upgrades describe section 
system allows programmers specify reads writes clauses 
consider method specifies writes wn reads rm 
method write object call methods write wi 
method read object call methods read wi rj 
allow method read write objects named writes clause 
shows tstack iterator uses effects similar tstack iterator 
example hasmoreelements method reads object 
getnext method reads objects owned tstack writes reads object 
defn defn class cn formal extends constr body body field meth cn owner object owner cn owner owner formal world cn constr owner owner owner owner defn meth mn formal arg effects constr effects reads owner writes owner field fd arg int formal new new arg fd fd mn owner cn class names fd field names mn method names variable names owner names grammar effects clauses conjunction subtyping effects overridden method subsume effects overriding method 
difficult specify precisely effects method 
example difficult specify precisely read effects getnext method tenumeration class tenumeration expected supertype subtypes tstack enum tenumeration name specific objects getnext methods subtypes 
accommodate cases allow escape mechanism method include world effects clauses 
ownership types effects locally reason side effects method calls 
consider example code shows intstack implemented vec 
adopted example 
example method receives arguments intstack condition assert statement true aliased vec 
example method uses clause specify 
ownership relation forms tree see constraint implies aliased vec 
furthermore size declares reads objects owned intstack push declares writes reads objects owned intstack 
possible reason locally size push interfere condition assert statement true 
type system section presents formal description type system 
simplify presentation key ideas describe type system context core subset java known classic java :10.1.1.23.8118
add inner classes classic java augment type system ownership types 
approach extends java similar languages 
type checking presents grammar 
core type system set rules reasoning typing judgment prog defn world world constr world owner world constr env xi yj constr constr owner owner world owner world owner defn class cn cn def cn cn def cn owner constr wf cn field class cn extends constr field meth owner formal owner owner type class cn constr cn cn owner oi oi constr fn fij oij fk fij ok oij subtype refl meth method declared cn cn subtype trans class cn 
meth 
meth cn field field declared class cn 
field 
field cn exp sub wf env exp new cn new cn cn exp arg arg arg wf env wf dom wf refl owner subtype owner trans cn owner cn type int int type object owner object cn cn class cn extends cn cn cn cn cn cn cn fn env owner wf dom owner wf method inherited meth cn cn class cn extends cn cn meth fn cn field inherited field cn cn class cn extends cn cn field fn cn exp ref cn fd cn fd exp new cn new cn cn env constr constr constr wf owner constr constr wf method method owner constr arg wf mn arg reads writes constr field field fd exp type world world exp ref assign cn fd cn fd exp var exp invoke mn tj yj reads writes constr cn cn cn cn xj tj om fm owner oi oi om fm constr om fm om fm mn om fm type checking rules judgment meaning program yields type defn defn formed class class owner owner constr constraint constr satisfied effect subsumed effect formed type wf subtype typing environment formed field class declares inherits field meth class declares inherits meth field field formed field meth meth formed method expression type expression type read write effects subsumed typing judgments program checked included provide information class definitions 
environment providing types free variables subsume read write effects type define typing environment owner constr 
define effects define type system judgments 
rules judgments 
rules number predicates shown 
predicates similar predicates :10.1.1.23.8118
simplicity treat outermost classes rules inner classes class 
cn denote cn cn fk kn soundness type system type checking rules ensure program typed program respects properties described 
complete syntactic proof type soundness constructed defining operational semantics extending operational semantics classic java proving typed programs reach error state generalized subject reduction theorem holds typed programs :10.1.1.23.8118
subject reduction theorem states semantic interpretation term type invariant reduction 
proof straightforward tedious omitted 
type inference type system explicitly typed principle onerous fully annotate method extra type information 
combination inference chosen defaults significantly reduce number annotations needed practice 
describe intraprocedural type inference algorithm default types similar approach :10.1.1.1.5802
lines code changed express java programs ownership type system :10.1.1.1.5802
emphasize approach inference purely intraprocedural infer method signatures types instance variables 
uses default completion partial type specifications cases minimize required annotations 
approach permits separate compilation 
predicate meaning cycles class hierarchy class declared twice class contains inner classes name declared inherited class contains fields name declared inherited class contains methods name overriding methods return type parameter types methods overridden 
read write effects overriding method superseded overridden methods predicates type checking rules runtime overhead system described purely static type system 
ownership relations compile time type checking preserved runtime 
consequently programs runtime overhead compared regular java programs 
fact way compile run program system convert regular program type checking removing owner parameters constraints owners effects clauses 
language java purely statically typed 
java allows downcasts checked runtime 
suppose object declared type object downcast vector result operation depends information available runtime type checker verify compile time right owner parameter assume object vector 
safely support downcasts system keep ownership information runtime 
similar keeping runtime information parameterized types 
describes efficiently ownership keeping runtime information objects potentially involved downcasts types multiple parameters 
upgrades persistent object stores section shows ownership types effects clauses enable modular reasoning correctness upgrades persistent object store 
desire achieve reasoning motivation ownership types encapsulation 
persistent object store contains conventional objects similar find object oriented language java 
applications access persistent objects atomic transactions necessary ensure consistency stored objects transactions allow concurrent access mask failures 
upgrades needed system improve object implementations correct errors change interfaces face changing application requirements includes incompatible changes interfaces new interface support methods old 
providing satisfactory solution upgrades persistent object stores long standing challenge 
upgrade persistent object store defined set class upgrades class objects need change 
class upgrade triple old class new class tf indicates objects belonging old class transformed transform function tf provided programmer objects new class 
tf takes old class object newly allocated new class object initializes new class object old class object 
upgrade infrastructure causes new class object take identity old class object objects point old class object point new class object 
upgrade executed transforming objects classes replaced 
transforms interfere application access store performed efficiently space time 
addition done safely important persistent state corrupted 
previous approaches provide satisfactory solution challenges application access database running upgrade keep copies database limit expressive power transforms transform functions allowed method calls 
system provides efficient solution 
performs upgrades lazily 
object transformed just application accesses application transaction interrupted run transform function 
transform runs transaction transaction commits application transaction resumed 
system allows upgrades run parallel earlier ones 
object pending transforms run upgrade order 
furthermore transform transaction encounters object pending transform earlier upgrade interrupted just application transform run pending transform continues execution pending transform commits 
details :10.1.1.1.7195
ownership types safe upgrades upgrade system efficient expressive delay application transactions avoids versions copies objects limit expressive power transform functions 
needs support modular reasoning correctness transform functions 
possible transform function encounters object interfaces invariants existed upgrade started reality transform function run application transactions transform transactions 
variant ownership types enable modular reasoning correctness transform functions 
system checks statically transform functions satisfy constraint ownership effects declarations effects clauses state objects tfs access 
tf accesses objects owns directly transitively 
transform functions satisfy ownership frequently captures depends relation discussed section typically transform functions access objects 
discuss support modular reasoning transform functions hold 
implementation ensures 
object affected upgrade accessed object owned ensure mechanisms 
owned object encapsulated type system guarantees accessed 
owned object shared inner class object system causes accessed just inner class object upgrade 
mechanism described detail 
holds prove order processing transforms cause problems 
particular show applications interfere transform functions transform functions unrelated objects interfere transform functions related objects run pre determined order object transformed owned subobjects 
proofs 
holds ensure transform functions encounter expected interfaces invariants 
supports modular reasoning transform function reasoned extra method old class 
related euclid languages considered problem aliasing 
stressed need better treatment aliasing object oriented programs 
early islands balloons focused fully encapsulated objects subobjects object access accessible outside object 
universes enforces full encapsulation read 
full encapsulation significantly limits expressiveness needed 
esc java pointed encapsulation required subobjects containing object depends esc java unable enforce encapsulation 
ownership types encapsulation ownership types provide statically enforceable way specifying object encapsulation 
proposed formalized 
systems enforce strict object encapsulation significantly limiting expressiveness 
require subtype owners supertype 
tstack towner subtype object support iterators 
prfj scj joe extended ownership types support natural form subtyping 
violating encapsulation joe introduces constraint type multiple owners owner owners 
result joe program create pointer object object owned 
prfj scj allow object contain pointers subobjects owned different object effects clauses prevent program pointers 
systems effectively enforce encapsulation object fields 
support constructs iterators allow method local variables violate encapsulation 
support local reasoning 
uses ownership types aid program understanding 
ownership type systems allows programmers ownership information reason aliasing 
flexible ownership type systems 
ownership type systems enforce encapsulation properties 
illustrated example 
ownership types extended inner classes 
systems enforce property stated section support local reasoning 
ownership types enforce properties 
parameterized race free java prfj uses ownership type system prevent data races multithreaded programs 
safe concurrent java scj extends prevent data races deadlocks 
systems combined approach enforce object encapsulation prevent data races deadlocks 
sketches way doing 
combines region types type system statically ensure object encapsulation safe region memory management 
related type systems linear types unique pointers control object aliasing 
linear types low level languages support safe explicit memory deallocation track resource usage 
linear types unique pointers orthogonal ownership types conjunction provide expressive systems 
prfj system combines ownership types conventional unique pointers 
proposes better approach allows program specify unique external pointer object internal pointers object subobjects 
effects clauses useful specifying assumptions hold method boundaries 
effects enable modular checking programs 
prfj system combine effects ownership types statically prevent data races 
combine effects ownership preventing deadlocks program understanding 
uses effects ownership enable lazy upgrades 
data groups name groups objects effects clause write modular specifications presence subtyping 
ownership types provide alternate way writing modular specifications 
ownership types name groups objects effects clause name owner name objects transitively owned owner 
presents example expressed ownership types 
data groups implemented theorem prover principle flexible 
pivot uniqueness imposes drastic restrictions pivot fields 
ownership types impose restrictions require owner object unique 
owner exclusion constraint hard coded 
system programmers specify arbitrary constraints owners clauses owner exclusion default 
systems tvla pale roles specify shape local object graph detail ownership types 
tvla verify properties input program tree output tree 
pale verify data structures expressed graph types 
roles verify global properties participation objects multiple data structures 
roles support compositional interprocedural analysis 
contrast systems take exponential time verification ownership types provide lightweight practical way constrain aliasing 
object encapsulation enables sound local reasoning program correctness object oriented languages 
ownership types provide way specifying statically enforcing object encapsulation 
type system enforces strict object encapsulation constraining allow efficient implementation important constructs iterators 
argues right way solve problem allow objects classes defined module privileged access representations 
show inner classes 
variant ownership types allows objects inner classes privileged access representations corresponding objects outer classes 
principled violation encapsulation allows programmers express constructs iterators wrappers inner classes 
system allows wrappers global contexts objects wrap 
system supports local reasoning correctness classes class inner classes reasoned module 
describes ownership type system expressive support iterators wrappers supporting local reasoning 
addition describes application technique enable modular reasoning upgrades persistent object stores 
ownership types purposes preventing data races deadlocks safe region memory management 
ownership types require little programming overhead type checking fast scalable provide benefits offer promising approach making object oriented programs reliable 
acknowledgments daniel jackson viktor greg nelson martin rinard alexandru useful discussions comments earlier drafts 
agesen freund mitchell 
adding type parameterization java language 
object oriented programming systems languages applications oopsla october 
aldrich chambers 
alias annotations program understanding 
object oriented programming systems languages applications oopsla november 
almeida 
balloon types controlling sharing state data types 
european conference object oriented programming ecoop june 
atkinson hamilton 
scalable recoverable implementation object evolution pjama platform 
persistent object systems pos september 
atkinson jordan spence 
design issues persistent java type safe object oriented orthogonally persistent system 
persistent object systems pos may 
banerjee naumann 
representation independence confinement access control 
principles programming languages popl january 
banerjee kim kim korth 
semantics implementation schema evolution object oriented databases 
acm sigmod international conference management data may 
vitek 
confined types 
object oriented programming systems languages applications oopsla october 
boyapati 
distributed persistent java system 
sm thesis massachusetts institute technology september 
boyapati lee rinard 
safe runtime downcasts ownership types 
technical report tr mit laboratory computer science june 
boyapati lee rinard 
ownership types safe programming preventing data races deadlocks 
object oriented programming systems languages applications oopsla november 
boyapati liskov shrira 
ownership types safe lazy upgrades object oriented databases 
technical report tr mit laboratory computer science july 
boyapati liskov shrira moh richman 
lazy modular upgrades persistent object stores 
submitted publication november 
boyapati rinard 
parameterized type system race free java programs 
object oriented programming systems languages applications oopsla october 
boyapati jr rinard 
ownership types safe region memory management real time java 
submitted publication november 
bracha odersky stoutamire wadler 
making safe past adding genericity java programming language 
object oriented programming systems languages applications oopsla october 
gemstone data management system 
kim lochovsky editors object oriented concepts databases applications 

carey persistent applications 
acm sigmod international conference management data may 
clarke 
object ownership containment 
phd thesis university new south wales australia july 
clarke drossopoulou 
ownership encapsulation disjointness type effect 
object oriented programming systems languages applications oopsla november 
clarke noble potter 
simple ownership types object containment 
european conference object oriented programming ecoop june 
clarke potter noble 
ownership types flexible alias protection 
object oriented programming systems languages applications oopsla october 
clarke 
external uniqueness 
workshop foundations object oriented languages fool january 
crary walker morrisett 
typed memory management calculus capabilities 
principles programming languages popl january 
day gruber liskov myers 
subtypes vs clauses constraining parametric polymorphism 
object oriented programming systems languages applications oopsla october 
deline fahndrich 
enforcing high level protocols low level software 
programming language design implementation pldi june 
deline fahndrich 
adoption focus practical linear types imperative programming 
programming language design implementation pldi june 
detlefs leino nelson 
rep exposure 
research report compaq systems research center july 
deux story 
ieee transactions knowledge data engineering tkde march 
flanagan freund 
type race detection java 
programming language design implementation pldi june 
flatt krishnamurthi felleisen :10.1.1.23.8118
classes mixins 
principles programming languages popl january 
gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley 
gosling joy steele 
java language specification 
addison wesley 
greenhouse boyland 
object oriented effects system 
european conference object oriented programming ecoop june 
grossman morrisett jim hicks wang cheney 
region memory management cyclone 
programming language design implementation pldi june 
hogg 
islands aliasing protection object oriented languages 
object oriented programming systems languages applications oopsla october 
hogg lea wills de 
geneva convention treatment object aliasing 
oops messenger april 
javasoft 
inner class specification february 
available java sun com products jdk 
klarlund schwartzbach 
graph types 
principles programming languages popl january 
lam rinard 
role analysis 
principles programming languages popl january 
lampson horning london mitchell popek 
report programming language euclid 
sigplan notices february 
leino 
data groups specifying modification extended state 
object oriented programming systems languages applications oopsla october 
leino nelson 
data abstraction information hiding 
research report compaq systems research center november 
leino poetzsch heffter zhou 
data groups specify check side effects 
programming language design implementation pldi june 
lerner habermann 
schema evolution database reorganization 
object oriented programming systems languages applications oopsla october 
liskov castro shrira adya 
providing persistent objects distributed systems 
european conference object oriented programming ecoop june 
liskov moh richman shrira cheung boyapati 
safe lazy software upgrades object oriented databases 
technical report tr mit laboratory computer science june 
liskov snyder atkinson schaffert 
abstraction mechanisms clu 
communications acm cacm august 
lucassen gifford 
polymorphic effect systems 
principles programming languages popl january 
madsen moller pedersen nygaard 
object oriented programming beta programming language 
addison wesley 
minsky 
alias free pointers 
european conference object oriented programming ecoop july 
moeller schwartzbach 
pointer assertion logic engine 
programming language design implementation pldi june 
muller poetzsch heffter 
universes type system controlling representation exposure 
poetzsch heffter meyer editors programming languages fundamentals programming 

myers bank liskov 
parameterized types java 
principles programming languages popl january 
noble 
iterators encapsulation 
technology object oriented languages systems tools june 
object design objectstore advanced api user guide release 
stein 
class modification gemstone object oriented dbms 
object oriented programming systems languages applications oopsla october 
sagiv reps wilhelm 
solving shape analysis problems languages destructive updating 
transactions programming languages systems toplas january 
boyapati jr rinard 
type system safe region memory management real time java 
technical report tr mit laboratory computer science november 
tofte talpin 
region memory management 
information computation february 

parametric polymorphism java approach translation reflective features 
object oriented programming systems languages applications oopsla october 
wadler 
linear types change world 
broy jones editors programming concepts methods 

wright felleisen 
syntactic approach type soundness 
information computation november 
