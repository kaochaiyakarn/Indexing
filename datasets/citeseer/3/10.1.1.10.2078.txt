brics ds nygaard domain theory concurrency brics basic research computer science domain theory concurrency nygaard brics dissertation series ds issn november copyright nygaard 
brics department computer science university aarhus 
rights reserved 
reproduction part permitted educational research condition copyright notice included copy 
see back inner page list brics dissertation series publications 
copies may obtained contacting brics department computer science university aarhus ny munkegade building dk aarhus denmark telephone telefax internet brics brics dk brics publications general accessible world wide web anonymous ftp urls www brics dk ftp ftp brics dk document subdirectory ds domain theory concurrency nygaard phd dissertation department computer science university aarhus denmark domain theory concurrency dissertation faculty science university aarhus partial fulfilment requirements phd degree nygaard july st revised december th concurrent computation mathematical treatment similar provided sequential computation domain theory denotational semantics scott strachey 
simple domain theory concurrency 
categorical model linear logic associated comonads highlights role linearity concurrent computation 
choices comonad yield expressive metalanguages higher order processes arising canonical constructions model 
denotational semantics fully respect contextual equivalence 
language called hopla higher order process language derives exponential linear logic 
viewed extension simply typed lambda calculus ccs nondeterministic sum prefix operations types express form computation path process capable 
hopla directly encode calculi ccs ccs process passing mobile ambients public names straightforward operational semantics supporting standard bisimulation congruence 
denotational operational semantics related simple proofs soundness adequacy 
full abstraction implies contextual equivalence coincides logical equivalence fragment hennessy milner logic linking simulation equivalence 
language called ne hopla weakening comonad yields model ne linear logic 
language adds hopla interesting tensor operation price linearity constraints occurrences variables 
tensor understood juxtaposition independent processes allows ne hopla encode processes kind treatments nondeterministic dataflow 
domain theory generalised presheaf models providing refined treatment nondeterministic branching supporting notions bisimulation 
operational semantics hopla guided idea derivations transitions operational semantics correspond elements presheaf denotations 
similar guidelines lead operational semantics order fragment ne hopla 
extension operational semantics full language stable denotational semantics associates computation minimal input necessary 
semantics provided event structures agrees presheaf semantics order exposes tensor operation simple parallel composition event structures 
categorical model obtained presheaves rich structure points expressive languages hopla ne hopla particular concerning extensions cover independence models 
thesis concludes discussion related fully fledged domain theory concurrency 
acknowledgments supervisor glynn winskel years joint expert leadership introducing things life research habit ale committee members pierre louis curien guy mccusker thoughtful detailed comments corrections suggestions improving thesis pino rosolini people disi university genoa hospitality stay helpful comments especially matas friendship marcelo fiore insightful suggestions part exam erik schmidt mogens nielsen early encouragement sta students daimi brics creating stimulating working environment forcing life studies trying family boldly asking questions research answers incomprehensible 
certainly wish wife support patience faith nygaard denmark december vi contents sequential computation 
concurrent computation 
domain theory concurrency 
path semantics domain theory path sets processes path sets 
nondeterministic domains 
linear nonlinear maps 
hopla denotational semantics 
useful identities 
full abstraction 
operational semantics 
simulation 
expressive power 
ne hopla denotational semantics 
useful identities 
full abstraction 
operational semantics 
expressive power 
vii ii presheaf semantics domain theory presheaves processes presheaves 
presheaf categories 
linear nonlinear maps 
strong correspondence finitary hopla 
full hopla 
ne hopla 
event structure representation event structures 
representations 
stable denotational semantics 
stable operational semantics 
higher order processes 
summary 
related 
viii chapter theories sequential computation concern transformations input output defined sequence basic computational steps 
sequential programs implement mathematical functions mapping set possible inputs set possible outputs 
class functions arising way understood 
computer built church kleene turing established notion computable function captured untyped lambda calculus recursive functions turing machines unison 
basic models give little guidance design reason programming languages domain theory denotational semantics scott strachey provide global mathematical setting sequential computation building top foundational theories 
places programming languages connection connects mathematical worlds algebra topology logic inspires programming languages type disciplines methods reasoning 
majority real computer systems merely computing output input 
main purpose ongoing interaction environment central aspect behaviour changing patterns interaction time 
input output paradigm sequential computation immediately applicable 
theories concurrent computation concern behaviour systems communicating autonomous processes 
contrast sequential computation class computable processes universal status global mathematical guidance provided domain theory missing 
consequence theories concurrency form fragmented picture 
point thesis show state airs need persist 
develop simple domain theory processes 
inspires process programming languages denotational semantics map programs mathematical functions processes combining input output paradigm notion process interacting environment 
chapter 
section recalls prominent features scott strachey approach focusing structure provides theories sequential computation 
contrasted situation concurrent computation section seemingly incompatible theories abundant 
described thesis part broader programme research unifying theory 
ort outlined section gives overview thesis 
sequential computation purpose section establish notation give overview concepts sequential computation wish advance concurrent setting 
ll take granted basic understanding untyped lambda calculus including concepts free bound variables substitution equivalence reduction see elementary account information 
denotational semantics strachey meaning denotation program construct representation contribution behaviour specified untyped lambda calculus 
instance commands imperative programming languages may represented partial mappings states states state function variable names locations values 
names simple values may represented church numerals similar encodings allow equality tests customary leave detail write skip 
notation stands encoding conditional equals reduces true 
ll similar notation similar kinds tests thesis 
hallmark denotational semantics compositionality meaning denotation compound program construct inductively terms denotations constituents 
example meaning command sequence functional composition meanings 
consider loop denoting map states booleans 
loop semantics unfolding skip 

sequential computation denotation loop satisfy fw 
clearly definition recurs righthand side equation fw 
untyped lambda calculus fixed point operator def satisfying lambda terms define def fw wanted 
denotations kinds infinite computational behaviour recursive procedures compositionally similar way 
domains course really just translation programming language command language untyped lambda calculus 
mathematical foundations provided scott famous construction model untyped lambda calculus certain ordered structures called domains 
domains come variants see 
domain complete partial order cpo element written 
completeness means chain ordered chain indexed natural numbers upper bound written monotone map domains said continuous preserves completeness structure fd chains 
continuous endofunctions domains special interest admit fixed points obtained fix 
gives alternative combinator untyped lambda calculus form typed fixed point operator fix domain domain continuous maps pointwise ordering fd gd 
domains denotational semantics program constructs denote elements domains 
construction model untyped lambda calculus involves finding domain interpret lambda terms 
considering self application xx combinator note second occurrence type term xx type chapter 
occurrence assigned type type need isomorphism scott fundamental contribution construct nontrivial solution recursive domain equation 
intuition domains obtained considering commands previous section 
may mapped elements domain def domain representing states 
wellknown commands terminate run certain states denotation map states element thought undefined state knowledge state 
ordering understood intuitively information map considered informative yields informative output input 
denotation loop considered previous section obtained fixed point fix continuous map defined 
approximation fixed point denotation th unfolding loop zero unfoldings represented map 
chain intuitively chain increasing information denotation loop 
universal constructions scott construction gave birth domain theory fact lot provide model untyped lambda calculus 
forms informative mathematical world give denotational semantics programming languages mapping program constructs elements domains domains function types constructs 
important study possible constructions domains customary employ category theory 
category theory ective tool investigating structure guided notion universal construction 
constructions characterised behaviour implementation way similar data types 
introductions category theory classic remains mac lane book 
simplicity ll consider just cpos continuous maps 
continuous functions cpos compose functions identity function continuous cpo cpos continuous functions form category ll call cpo 
category products objects cartesian product ab posets associated projections fst ab snd implements behaviour characterising implementation isomorphism pair maps object cpo tupled form unique map property fst 
sequential computation snd ll write unique map fst snd ab empty product singleton cpo terminal object associated unique maps constantly cpo exponentials obtained poset continuous maps ordered pointwise defined 
associated object map app app def fa 
construction satisfies universal property map cpo unique map curry app curry cpo finite products exponentials cartesian closed model intuitionistic propositional logic see information correspondence intuitionistic logic categorical structure 
category cpo coproducts objects disjoint juxtaposition cpos obvious injection maps inl inr maps cpo unique map inl inr empty coproduct initial object empty cpo empty map unique map cpo simply typed lambda calculus illustrate universal constructions define denotational semantics programming language 
simply typed lambda calculus directly suggested constructions available cpo 
types grammar 
interpreted objects cpo obvious way 
raw syntax terms 
variables abstraction application fst snd unit pairing projections inl inr injections inl inr match sums variables match term inl inr binding occurrences bind occurrences variable bodies respectively 
assume variables 
distinct 
syntactic judgement 
stands map 
chapter 
cpo 
ll write environment list 
abbreviate denotation empty corresponding product singleton cpo 
term formation rules displayed alongside interpretations constructors maps cpo maps denoted premises denoted cf 
:10.1.1.120.180
assume variables environment list distinct 
structural rules 
rules handling environment lists follows rules weakening exchange obvious isomorphisms right unit symmetry 
rule contraction variable fresh map usual diagonal 
function space 
interpreted exponentials cpo curry tu app products 
interpreted products cpo tu fst fst snd snd 
sequential computation sums 
interpreted coproducts cpo inl inl inr inr inl inr dist rule map dist isomorphism witnessing products distribute sums cpo 
analogy type constructors logical connectives typing derivations correspond proofs assumptions intuitionistic logic 
called curry howard isomorphism see ch 
full account 
induction rules prove substitution lemma essentially saying reduction valid lemma substitution suppose disjoint 
denotation composition 
proposition equational properties universal constructions substitution lemma get equivalences fst snd inl inl inr inr inl inr proposition uniqueness properties universal constructions get equivalences fst snd inl inl inr inr chapter 
metalanguage denotational semantics programming language specified lines assigning kind program construct suitable domain compositional mapping sending individual constructs kind elements chosen domain 
domains tend function spaces quickly cumbersome check maps continuous functions 
problem addressed providing metalanguage sequential programming 
show terms metalanguage denote continuous functions specifying denotational semantics programming language interest metalanguage rest assured maps construct function space type continuous map 
directly canonical constructions simply typed lambda calculus candidate metalanguage fact lacks fixed point operators types interpreted cpos domains 
cpo turned domain adding new element copy element gives rise element distinct 
ordering write dom full subcategory cpo objects domains 
dom inherits cartesian closed structure cpo combination universal constructions lifting obtain typed lambda calculus fixed point operator type interpret typing rule rec ll go details 
chapter winskel book gives information di erent uses lifting give rise di erent calculi di erent evaluation strategies call value call name 
metalanguage employ lazy strategy subterms evaluated needed 
addition recursion terms need add recursive types deal infinite data types natural numbers 
full metalanguage types grammar 
symbol drawn set type variables defining recursive types closed type expressions interpreted domains 
expression interpreted solution defining equation expression may contain shall confuse closed expression domain domain 
recursive domain equations form solved information systems characterising solutions isomorphism abs inverse call 
sequential computation rep associated typing rules abs rep prove analogue substitution lemma extended language add equations rec rec rep abs proposition 
hand items proposition fail lazy evaluation strategy 
example natural numbers defined def constant zero operations successor addition curried defined zero def abs inl succ def abs inr add def rec rep inl inr succ zero succ add programming languages ml haskell data type constructors pattern matching eliminate need abs rep ml write datatype zero succ fun add zero add succ succ add ability mirror functional programming way illustrates expressiveness metalanguage 
operational semantics stands metalanguage inferior strachey original approach respect reduction untyped lambda calculus provides executable specification language implementation contrasted 
fortunately metalanguage admits operational interpretation building proposition 
operational semantics defines evaluation relation value closed formed term generated grammar inl inr abs 
chapter 
denotations values satisfy intuitively values represent positive information 
evaluation relation defined inductively structural operational semantics leave obvious symmetric rules rec rec fst inl inl inr abs abs abs rep proposition operational semantics satisfies determinacy suppose type correctness suppose properties proved induction derivation rules 
relating operational denotational semantics small programming languages considered research purposes defined directly operational semantics underlying denotational semantics 
reason operational semantics flexible ideal exploration programming concepts 
flexibility edged sword leading ad hoc constructions 
apparent tries relate formally compare di erent languages 
link global mathematical setting provided domain theory left syntactic translations hard find justify understand 
problem purely syntactic approach lack reasoning methods 
consider open terms suppose prefer performance reasons 
verify optimisation sound need show terms equivalent contexts amount programming tell apart 
hard see follows terms contextually equivalent defined 
define program closed term type term holes term may put form program operational semantics full scale languages tend defined informally prose 
standard ml noteworthy exception 

sequential computation call program context 
suppose write program contexts zero zero terms said contextually equivalent unfortunately quite hard prove contextual equivalence quantification program contexts 
easier show terms denotation suitable link denotational semantics useful 
standard results shown proposition soundness suppose 
proposition adequacy suppose 
soundness proved induction derivation rules proposition 
adequacy quite bit harder involving logical relations trick deal recursive types exploits representation information systems clever abs rep constructors see ch 

follows soundness adequacy terms denotation contextually equivalent 
result called computational adequacy theorem computational adequacy depending exact nature denotational semantics may able show converse implication 
called full abstraction kind holy grail semantics normally di cult obtain 
denotational semantics metalanguage fully 
contains elements parallel definable metalanguage distinguish terms operational semantics 
berry stable domain theory rules elements parallel demanding output function associated unique minimal input 
problematic elements remain known domain fully semantics language metalanguage 
curiously problem capture domain theory sequentiality sequential computation 
chapter 
concurrent computation broadly speaking approaches concurrency start syntax process calculus specific mathematical model processes 
indicate diversity approaches 
process calculi milner tried apply standard semantic techniques seen concurrent programming language failed 
particular milner viewing program function memory states identifying programs def def sense program full control memory 
interference program say change behaviour program program behave nondeterministically changing 
problem interaction storage number programs 
kind problem arises interactions programs machines machine user 
led milner search fundamental new calculus interaction communication central idea 
primitive notion indivisible interaction put forward independently milner hoare milner case embodied calculus communicating systems ccs 
basic lambda calculus untyped 
set names def set complemented names 
range labels def complementation extended def range set actions def occur syntax ccs processes 
variables rec recursion nondeterministic sum prefixing atomic action parallel composition restriction names relabelling nondeterministic sum indexing set may arbitrary set write empty typical finite sum 
relabelling functions extended def rl def operational semantics defines transition 
concurrent computation relation closed ccs terms actions labels 
rec rec intuitively means process willing er communication channel named continue process channel understood broad sense cf 
example milner book 
addition process willing er complementary communication channel processes communicate signalling environment special action communication taken place 
communication involving transition take place 
example model beer ee vending machines customer ccs 
names set standing accept money beer ee 
vending machine sell beer ee choice machine money accepted 
machine possibilities available action accepting money 
customer just wants beer 
def def def vending machines serve single customer inactive 
longer lasting machines specified recursion rec 
operational semantics obtain transitions process note system encounters deadlock state machine insists delivering ee customer accept 
contrast deadlock occur starting chapter 
ccs accompanied notion process equivalence simulation ability process mirror behaviour 
equivalence distinguishes processes intuitively unable simulate formally relation processes bisimulation holds 


bisimilarity written largest bisimulation 
demand second item satisfied called simulation said simulate simulates said simulation equivalent 
note simulation equivalence strictly weaker bisimilarity simulations need reverse images 
example vending machines example bisimilar relates requirement 
relate 
requirement 
fails process perform action matched 
machine simulates converse true 
bisimilarity congruence ccs context allows kind local reasoning possible denotational semantics cf 
section need quantify contexts show may replace program 
bisimilarity logical characterisation hennessy milner logic modal logic formulae 
notion satisfaction written defined def def def hold 
write empty finite conjunctions respectively 
formula satisfied process 
processes bisimilar satisfy exactly formulae 
fragment hennessy milner logic obtained leaving negation characteristic simulation equivalence restricting logic finite conjunctions restricts characterising power image finite processes processes set finite 
example formula satisfied witnessing machines bisimilar simulation equivalent 

concurrent computation vending machines transition systems milner seminal led study variety process calculi suitable notions bisimulation pattern see annotated bibliography 
cases calculi complicated ccs allowing communication processes thomsen chocs new name generation calculus quickly di cult give reasonable definition bisimulation shown yield congruence particularly higher order features combined name generation 
case point cardelli gordon ambient calculus calculus notion bisimulation need adjusted ad hoc fashion 
lot energy local optimisations specific process calculi optimisations may obscure connections global picture operational semantics hard relate compare di erent calculi 
lessons learnt remain isolated lack commonality global framework provide 
process models hope suitable mathematical model processes provide global framework 
years researchers concurrency theory produced large number di erent process models just picture fragmented 
list transition system quadruple tran set states initial state alphabet labels tran transition relation 
common write tran ccs gives rise transition system closed process term states closed terms initial state labels actions transitions derived operational rules 
vending machine processes example give rise transition systems 
customary leave unreachable states pictures 
note definition bisimulation previous section sense transition system transition systems bisimilar bisimulation relating initial states 
chapter 
vending machines synchronisation trees synchronisation tree transition system underlying graph tree initial state root 
transition system unfolded synchronisation tree unwinding loops removing unreachable states duplicating states reachable way 
transition systems unfold trees 
trace set simply prefix closed set finite words alphabet 
synchronisation tree label set gives rise trace set containing words obtained concatenating labels finite path root node tree 
conversely trace set gives rise synchronisation tree states elements root empty string transition relation trace sets away nondeterministic branching behaviour processes 
vending machine processes give rise trace set ab ac trace equivalent simulation equivalent 
models interleaving models means reduce parallelism nondeterminism 
vending machine terminology models distinguish vending machines running parallel ready serve beer ready serve ee single vending machine serve order vs 
variety models concurrency discern increasing independence models causal partial order models processes di erent 
independence models thread partial order model checking security protocols nondeterministic dataflow self timed circuits term rewriting game semantics analysis distributed algorithms 
interleaving models domain theoretic treatment powerdomains domains resumptions approach fall short accommodating independence models insists nondeterministic choice actions time 

concurrent computation key independence models include petri nets asynchronous transition systems closely related understood transition systems independence structure added event structures obtained unfolding transition systems synchronisation trees mazurkiewicz trace sets trace sets independence structure underlying alphabet 
give flavour independence models ll need give definition particular kind event structures prime event structures binary conflict just called event structures 
event structure triple set events partial order causality binary symmetric irreflexive relation conflict defined 
data satisfy def finite 
ii configuration subset closed 
ii consistent 

event structure models process follows set contains set events possibly occur execution process 
causality relation expresses events depend conflict relation expresses events exclude binary fashion 
configuration represents point execution process collecting events occurred far 
example ccs process modelled event structure events serving beer ee 
events depend exclude causality relation identity conflict relation empty 
configurations 
hand process modelled events events indexed conflict events indexed 
configurations 
interestingly event structures representations domains match berry stable domain theory 
nondeterministic dataflow di erent model describing reactive systems input output ports interacting environment reading values letters alphabet input ports producing values output ports see top part 
essential idea dataflow paradigm collection networks chapter 
aa bb merge abab abab fork abab abab aa bb merge abab fork abab abab nondeterministic dataflow combined single larger network possibly connecting free input output ports bottom part 
wires understood unbounded bu ers 
usually assumed wires connected port 
connecting ports network yields feedback loop operation called trace 
kahn observed give semantics deterministic dataflow interleaving model recognised independence model useful nondeterministic case 
domain theory concurrency plethora models hardly surprising relations di erent approaches unclear hampering technology transfer 
ideas may rediscovered example special event structures reappear strand spaces reasoning security protocols 
discuss providing structure field 
categorical structure handbook chapter winskel nielsen concentrates understanding structure di erent models relate :10.1.1.21.5791
category theory natural tool task 
exception dataflow model turned category morphisms stand simulations 
example individual transition systems form objects category assuming common alphabet brevity tran tran transition systems morphism function tran implies fs fs tran expresses may simulated synchronisation trees form subcategory operation unfolding results right adjoint inclusion functor models related similar way 
particular interleaving models seen independence models trivial independence structure associated functors part adjunctions 

domain theory concurrency presentation models categories precise relate 
operations nondeterministic sum parallel composition process calculi exposed universal constructions categorical models 
give uniform semantics di erent calculi exploiting preservation properties adjoints relate semantics calculus di erent models 
bisimulation open maps joyal nielsen winskel gave impetus approach sweeping definition bisimulation categorical models open maps 
idea single maps categories preserve behaviour reflect 
case map transition systems mean fs tran exists tran fs clear equivalent demanding graph functional bisimulation transition systems bisimulation function 
see requirement amounts categorical terms consider finite sequence transitions 
morphism induces simulating sequence fr fr fs 
reflects behaviour extension say fr fr fs reflected extension 
chosen compatible fs sequences transition systems objects clearly ll refer just 
extends witnessed obvious morphism sequence sequence morphisms square left commutes 
commutativity just fact simulation extended simulation chapter 
reflection requirement stated saying commutative square split commutative triangles right 
commutativity upper triangle expresses sequence simulates extension sequence simulating lower triangle amounts saying extension compatible sequence simulating reasonable think objects computation paths respect model transition systems correspond sequences transitions 
general category models subcategory objects morphisms thought computation paths ways extend 
define open maps morphisms morphisms commuting square left split commuting triangles right 
open maps account functional bisimulations get possible bisimulations models said open map bisimilar exists span open maps 
case transition systems subcategory finite sequences open map bisimilarity coincides park milner notion defined section 
reasonable equivalences obtained models suitable choices subcategories paths see 
presheaf models course freedom choice path category problematic reason expect models furnish natural choice case 
category theory provides helpful suggestion 
studied class categories called presheaf categories canonical choice path category 
objects presheaf category presheaves understood collection processes constructed underlying path category freely adding coproducts nondeterministic sums paths gluing paths identifying subpaths creating sheaves computation paths processes branching behaviour 
alternative view presheaf seen process assigns computation path set ways simulated realised process 
path category finite sequences transitions presheaf category category synchronisation forests objects sets synchronisations trees presheaf may assign way simulating empty transition sequence 
restricting note terminology open map presheaf categories open maps defined satisfy joyal moerdijk axioms open maps toposes presheaf categories prime example 

domain theory concurrency rooted presheaves presheaves correspond synchronisation trees open map bisimilarity coincides park milner notion 
guided intuitions categorical situation joyal nielsen winskel suggested presheaves general model processes 
presheaf models subsequently studied winskel phd students cattani hildebrandt number coworkers 
shown presheaf models expressive encompass generalise wide range existing models notions concurrent computation including ccs languages models equivalences higher order features nondeterministic dataflow independence models name generation 
domain theory concurrency domain theory handled higher order processes independence models name generation possessed operational interpretation provide global mathematical framework theories concurrency 
light presheaf models candidate framework 
cattani winskel drawn attention categorical model linear logic associated pseudo comonads presheaves 
linear maps preserve open map bisimilarity restricted model important process operations including prefixing 
weakening comonad derives model ne linear logic sense jacobs morphisms ne maps allow prefixing preserve open map bisimilarity 
led winskel discovery expressive metalanguage concurrency 
terms language interpreted ne maps open map bisimilarity automatically congruence 
ne linearity restricts copying allows process ignore input allow investigate behaviour input context 
matches general situation distributed setting processes interact peers little control 
starting point hope operational semantics ne language provide general operational understanding presheaf models 
result operational semantics order fragment ne language guided idea derivations transitions operational semantics correspond presheaf denotations 
operational semantics indicated tensor ne linear logic understood parallel composition independent processes 
intuition backed event structure representation definable presheaves tensor operation corresponds simple parallel composition event structures got juxtaposition 
chapter 
proved di cult extend operational semantics ne language order led consider exponential linear logic giving rise model intuitionistic logic expressive metalanguage 
language called hopla higher order process language viewed lambda calculus extended ccs nondeterministic sum prefix operations 
contrast ne metalanguage call ne hopla hopla allows process copy input investigate behaviour di erent contexts 
intuitively hopla process receives code input process full control execution 
ne hopla viewed variation hopla obtained adding tensor cost linearity constraints variables 
hopla supports straightforward operational semantics guided presheaf model 
hopla operational semantics simple felt presentation denotational semantics su ered significant overhead terms category theory needed 
turned hopla ne hopla obtained working simpler domain theory avoiding categorical structure 
presheaf models directly computation paths line followed originally di erent direction 
hennessy semantics ccs process passing process denotes set computation paths 
ll call kind semantics path semantics similarity trace semantics cases processes denote downwards closed sets computation paths corresponding notion process equivalence called path equivalence equality sets 
computation paths may structure traditional traces allowing path semantics take nondeterministic branching account limited way 
fact path equivalence linked simulation equivalence image finite processes 
path semantics presheaf semantics seen variations common idea process denotes form characteristic function truth values sets 
path set may viewed special presheaf yields realiser path 
extra structure presheaves saying computation path may realised allows incorporation complete branching information 
path sets considerably simpler presheaves furnish models su ciently rich structure show languages arise canonical constructions path sets 
path semantics admits simple proofs full abstraction showing path equivalence coincides contextual equivalence 
path semantics stand 
provides little guidance operational semantics capture branching information characterise bisimulation extensions deal independence models catered 

domain theory concurrency overview thesis author progress report papers coauthored glynn winskel linearity process languages 
lics 
hopla higher order process language 
concur 
full abstraction hopla 
concur 
domain theory concurrency 
appear theoretical computer science special issue domain theory 
part concentrates simple domain theory concurrency path sets part ii discusses guidance provided extra structure presheaves 
chapter shows path sets give rise simpler version abovementioned categorical model linear logic associated comonads avoiding categorical structure 
chapter presents metalanguage hopla shows operations arise canonical constructions underlying path set model exponential linear logic 
path semantics shown fully contextual equivalence coincides path equivalence 
language straightforward operational semantics endowed standard bisimulation congruence 
denotational operational semantics related simple proofs soundness adequacy 
contextual equivalence shown coincide logical equivalence fragment hennessy milner logic characterises simulation equivalence 
expressive power hopla indicated encodings calculi ccs ccs process passing mobile ambients public names 
progress extending hopla name generation 
chapter presents ne metalanguage called ne hopla 
adds hopla interesting tensor operation price linearity constraints occurrences variables 
denotational semantics directly canonical constructions path sets weakening comonad shown fully 
interleaving operational semantics order fragment language provided proofs soundness adequacy 
shown tensor operation allows ne hopla encode nondeterministic dataflow processes feedback loops 
chapter shows extra structure presheaves capture branching behaviour processes provides brief overview categorical models considered cattani winskel 
chapter 
chapter proves correspondence results relating derivations operational semantics languages presheaf denotations 
chapter unpublished 
studies independence structure tensor operation ne hopla defining event structure semantics language order provides representation presheaf denotations 
tensor operation denotes simple parallel composition event structures got juxtaposition 
event structure semantics analogous berry stable denotational semantics diverges presheaf semantics higher order 
representation alternative stable operational semantics order fragment ne hopla 
derivations correspond configurations event structures elements presheaves 
stable semantics agrees operational semantics chapter shows refine independence structure 
extended higher order processes proof correspondence denotational semantics extension 
chapter concludes summary thesis discussion related fully fledged domain theory concurrency particular concerning name generation independence models bisimilarity 
part path semantics chapter domain theory path sets chapter presents simple domain theory path sets 
section introduces path semantics processes highlights di erence path semantics traditional trace semantics 
path semantics processes represented elements nondeterministic domains properties investigated section 
observation nondeterministic domains free completions highlights natural notion map domains leads categorical model linear logic section 
maps category linear maps restricted important operations prefixing linear discipline linear logic consider linear maps domain comonad 
choice comonad exponential linear logic gives rise scott continuous maps model intuitionistic logic choice yields model ne linear logic 
constructions models induced linear category adjunctions 
processes path sets path semantics processes represented sets computation paths 
paths elements preorders called path orders function process types describing set possible paths processes type sub path ordering 
process type represented downwards closed subset called path set 
illustrate consider path order poset nonempty strings set 
actions ordered prefix ordering 
elements atomic actions processes ccs path set represents process set finite sequences actions process perform 
just trace semantics trace sets include empty string chapter 
domain theory path sets computation paths non empty 
nondeterministic sum interpreted union path sets inactive process represented empty set paths 
prefixing action maps path set path set 
trace semantics gives representation processes 
example consider ccs processes example 
interpreted path set ab ac 
processes example distinguished refining notion path 
strings atomic actions may consider paths defined inductively rule judgement mean path element path order 
intuitively process perform path 
perform action able perform paths set 

ordering defined inductively preorder defined arbitrary subsets 
ranging finite subset define change interpretation prefixing prefixing action maps path set set 
interpretation nondeterministic sum unchanged 
example example processes represented path sets respectively 
extra element denotation distinguishes 
path order associated notion prefixing may bit contrived point definitions canonical constructions path sets see section 
show section path equivalence respect path orders linked simulation equivalence 
image finite ccs processes alphabet may simulate representations path sets identical 

nondeterministic domains nondeterministic domains path sets path order may ordered inclusion form poset ll think domain meanings processes type poset interesting properties 
complete lattice joins union 
sense hennessy plotkin nondeterministic domain joins interpret nondeterministic sums processes 
accordingly family elements write join 
typical finite join written empty join empty path set inactive process written 
second important property join certain prime elements prime algebraic complete lattice 
primes closures individual elements representing process may perform computation path map reflects preserves order embeds clearly prime algebraicity amounts saying union elements 
characterised abstractly free join completion meaning join complete ii join complete poset monotone map unique join preserving map diagram left commutes 
fp 
call extension uniqueness follows 
notice may instantiate poset form drawing attention join preserving maps freeness property join preserving maps bijective correspondence monotone maps element represented characteristic function monotone map op opposite order simple poset op 
uncurrying yields chain op op op op op 
order op provides function space type 
ll investigate additional type structure hand 
chapter 
domain theory path sets linear nonlinear maps write lin category path orders 
objects maps arrows 
turns lin structure understood categorical model girard linear logic 
accordingly ll call arrows lin linear maps 
linear maps represented elements op downwards closed subsets order op relational presentation exposes involution central understanding lin categorical model classical linear logic 
involution linear logic yielding object op clearly downwards closed subsets op correspond downwards closed subsets op op op showing maps correspond maps lin 
tensor product product preorders singleton order unit tensor 
linear function space obtained op products disjoint juxtaposition preorders 
element identified pair provides projections lin 
general just binary products projections defined similarly 
universal property products collection maps tupled form unique map property empty product empty order terminal object associated unique maps constantly path order told lin autonomous category symmetric monoidal closed category object finite products products required seely definition model linear logic 
fact lin coproducts objects juxtaposition coinciding products 
injection maps lin derive obvious injections disjoint sum preorders 
empty coproduct empty order zero object 
collapse products coproducts highlights lin arbitrary 
isomorphism lin op homset lin seen commutative monoid neutral element map written multiplication union written 
composition lin bilinear family objects diagram oo ap 

linear nonlinear maps processes type may intuitively perform computation paths component path orders see lin rich structure 
linear maps restrictive 
join preserving particular preserve empty join 
prefixing linear maps send inactive process 
continuous maps looking broader notion maps nondeterministic domains follow discipline linear logic consider non linear maps maps domain exponential 
choice suitable exponential lin got preorder obtained free finite join completion concretely defined finite subsets elements ordering 
example path order section built exponential particular choice tagging actions inductive definition may think solution equation precise section 
equivalence induced preorder obtain poset free finite join completion obvious inclusion completion get map 

finite sums primes finite isolated compact elements map assumes role 
directed join finite elements 
free directed join completion means monotone map directed join complete poset unique directed join preserving scott continuous map diagram commutes 
fp 
known ideal completion note obtained applying hoare powerdomain ideal completion 
powerdomains considered may possible smyth powerdomain characterise may behaviour processes 
chapter 
domain theory path sets uniqueness called extension follows 
replace nondeterministic domain freeness properties bijective correspondence linear maps continuous maps define category cts path orders 
objects continuous maps arrows 
arrows allow process operations including prefixing expressed 
structure cts induced lin adjunction categories 
linear maps continuous cts lin subcategory shares objects 
saw bijection lin cts 
fact natural adjunction inclusion lin cts right adjoint 
map extends map cts 
conversely extends map lin 
maps unit counit respectively adjunction example prefix operation associated path order section defined unit injections 
chapter ll unit interpret anonymous action prefix operation counit interpret corresponding destructor 
left adjoint functor cts lin arrows bijection maps lin cts inverse maps cts lin 
call transpose respectively course transposing twice yields back original map 
lin subcategory cts counit map cts right adjoints preserve products cts finite products lin 
cts symmetric monoidal category lin fact adjunction symmetric monoidal 
detail isomorphisms path orders mapping pair union element written form 
isomorphisms induce isomorphisms names lin natural 
commute associativity symmetry unit maps lin 
linear nonlinear maps cts lin cts making symmetric monoidal 
follows inclusion lin cts symmetric monoidal unit counit monoidal transformations 
maps cts natural corresponding maps extension map qq 
unit diagrams commute counit satisfies similar properties 
vv diagram left written str str strength viewed monad cts natural transformation 
map str linear second argument 
assuming str nat 
linearity nat 
str recall category lin symmetric monoidal closed functor right adjoint object natural isomorphism provides right adjoint defined functor cts chain cts lin lin lin cts cts natural demonstrates cts cartesian closed known 
adjunction lin cts satisfies conditions put forward benton categorical model intuitionistic linear logic strengthening seely see survey models 
chapter 
domain theory path sets ne maps move lin cts allowed interpret prefixing 
fact cheaply 
category cts obtained lin exponential allows arbitrary copying linear logic 
element consists possibly computation paths element path order understood intuitively describing compound computation path associated running copies process type maps cts corresponding maps lin allow input copied 
copying generally restricted distributed computation 
communication received result single run process communicated 
course process code sent copied 
generally receiver possibility copying state ongoing computation 
hand ignoring process easy 
reason operations distributed computation property ne linearity computation path process arising application operation input process resulted computation path input process 
note particular prefix operations ne sense wish observe just initial action ccs process computation path needed observing longer path involve single computation path recall diagram says linear maps determined values single paths elements adjunction lin cts continuous maps determined values compound paths diagram 
summarise linear operations single path input ne operations path input continuous operations number paths input 
ne maps defined values singleton copies paths empty path 
accordingly ne maps derive lifting operation adding new element thought empty computation path copy path order produce path order abstractly empty join completion concretely take contain empty set written singletons ordered 
linear nonlinear maps example path order non empty strings prefix ordering discussed section obtained isomorphism solution equation obvious inclusion poset obtained empty join completion obtain map 
ll range remainder chapter 
map assumes role get 
join manifestly nonempty fact free closure nonempty joins 
means monotone map nonempty join complete poset unique preserving ne map diagram commutes fp 
uniqueness called extension follows 
replace nondeterministic domain freeness properties bijective correspondence linear maps ne maps define category path orders 
objects ne maps arrows 
structure induced lin adjunction categories inclusion lin linear maps ne right adjoint lin 
unit counit lin left adjoint lin obtained precisely section example time unit tagging interpret usual prefix operations associated path order ll base anonymous action prefix operation directly unit chapter 
chapter 
domain theory path sets category inherits products lin way cts 
cts category cartesian closed isomorphic lin 
hand easily define tensor operation path orders isomorphic simply take 
paths consist possibly empty path possibly empty path path set thought process performing parallel computation paths type type arrows define extension map defined 
unit tensor empty path order elements correspond maps ll write element pointed map tensor symmetric monoidal category adjunction symmetric monoidal 
obvious isomorphisms path orders induce natural isomorphisms lin obtain monoidal strength precisely cts 
monoidal closed structure lin natural isomorphism provide right adjoint defined functor chain lin lin lin natural demonstrates symmetric monoidal closed unit tensor terminal model ne linear logic observed jacobs 
chapter hopla higher order process language hopla higher order process language economic expressive language higher order nondeterministic processes 
language typed 
type process describes possible computation paths process perform 
computation paths may kind considered example may represent input output behaviour process hennessy 
typing judgement 
means process yields computation paths processes computation paths 
assigned variables 
respectively 
types built function space sum anonymous action prefix type recursive definition 
language viewed extension simply typed lambda calculus 
interpreted cartesian closed category cts types interpreted path orders judgements interpreted arrows cts 
general language allows processes copied discarded arbitrarily 
particular language allow write terms take process argument copy set copies parallel composition 
operations nature linear certain arguments 
linearity detected denotational semantics interpreted subcategory lin cts amounts property preserving nondeterministic sums 
denotational semantics section canonical sense operations language arise canonical constructions underlying model 
universal properties constructions induce chapter 
hopla number useful results semantics collected section 
section shows denotational semantics fully characterising contextual equivalence path equivalence 
hopla supports straightforward operational semantics section simple proofs soundness adequacy 
standard notion bisimulation shown congruence section full abstraction links contextual equivalence simulation equivalence fragment hennessy milner logic 
notable express kinds concurrent processes language language features typical process calculi built nondeterministic sum prefix operations 
particular parallel composition processes la ccs defined hopla primitive construct 
section contains encodings ccs ccs process passing mobile ambients public names 
formally defining language discuss informally constructs associated sum prefix types remainder language just simply typed lambda calculus plus nondeterministic sums sum prefix types central expressiveness 
sum type constructed family types written interpreted lin sum product coproduct 
associated injection tagging term constructors producing term sum type term type conversely projection term constructors produce term type term sum type 
injections projections interpreted structural maps lin cf 

accordingly semantics identify process process inactive process 
injections projections distribute nondeterministic sum linearity processes identified 
prefix type form describes computation paths anonymous action call performed resuming computation path prefix type associated prefix operation process type type prefix match prefix type variable type generally involves term matches pattern passes results successful matches particular prefixing matching yields single successful match processes identified 
prefix match linear argument possibly multiple results successful matches nondeterministically summed interpretations identical 
sum type give names anonymous actions encode ccs processes 
recall example recursive type ccs processes equation ccs process term type obtain term type anonymous prefixing type tagging identifying recursive type unfolding type corresponding ccs process obtained prefixing action 
example ccs processes translated hopla terms def def type process identities easily deduced properties projection prefix match projection prefix match combination test process type perform ccs action 
linearity possible successor gives rise di erent component nondeterministic sum successors get inactive process 
nonlinear term test ability perform di erent actions 
get note occurrences allow process copy input force copy take di erent computation path 
intuitively uses computation paths input linear cf 
discussion section semantically preserve nondeterministic sums shows interpretation lies outside lin 
hopla contexts strong distinguish vending machine processes 
full abstraction result section shows follows fact path set interpretations processes di erent cf 
example 
example illustrates way combining sum prefix types yields prefix sum type original treatment hopla 
decomposition embodied hopla defined increases expressiveness language example include type winskel ccs late value passing ensuring operation language canonical semantics 
chapter 
hopla denotational semantics types grammar 
symbol drawn set type variables defining recursive types closed type expressions interpreted path orders 
vector notation abbreviates 

interpreted component solution defining equations 
expressions 
may contain 
shall write abbreviation tuple component confuse closed expression path order path order 
simultaneous recursive equations path orders solved information systems 
convenient give concrete inductive characterisation language paths abs 
ranges finite sets paths 
notation pairs function space op language complemented formation rules judgements meaning belongs displayed alongside rules defining ordering judgements recall means ap 
abs abs abs information systems yields representation tagging abs recursive types done help proof adequacy section 
straight equality recursive type unfolding get isomorphism abs inverse call rep example solution equation example formally written composing rules sum prefix types obtain rule deriving elements identical abs tag abs 

denotational semantics raw syntax hopla terms 
variables rec recursive definition nondeterministic sum abstraction application injection projection prefix operation match abs rep folding unfolding variable match term binding occurrence scope 
closed type expressions assume variables 
distinct 
syntactic judgement 
stands map 
cts 
ll write environment list 
abbreviate denotation suppressing typing information 
environment list empty corresponding product empty path order term formation rules displayed alongside interpretations constructors maps cts maps denoted premises denoted cf 
:10.1.1.120.180
assume variables environment list appears distinct 
structural rules 
rules handling environment lists follows cts cts formation rule contraction variable fresh map usual diagonal 
ll write obvious extension components note chapter 
hopla recursive definition 
complete lattice admits continuous maps 
continuous fixedpoint fix obtained 
rec fix fix fixed point cts continuous operation mapping cts composition 
nondeterministic sum 
path order associated join operation cts tuple join ll write finite sums 
function space 
noted section category cts cartesian closed function space correspondence curry maps maps cts inverse called uncurry obtain application app uncurry 
curry app sum type 
category cts coproducts build useful sum type lin 
properties obviously satisfied cts construction universal subcategory linear maps composition generally bilinear cts 
ll write empty finite sum types 
product pairing projection terms fst snd encoded respectively type terms 
denotational semantics prefixing 
adjunction lin cts provides type constructor unit counit may interpret term constructors respectively 
behaviour respect maps cts fits anonymous prefix operation 
universal property type free variable type interpreted map cts transpose unique map lin type ll interpret prefix match tu 
type interpretation yields tu substitution lemma lemma match identified wanted 
linearity match distribute nondeterministic sum 
clearly generalises case open term free variables need strength map distribute exponential corresponding product 
proposition shows general definition satisfies required properties 
str recursive types 
folding unfolding recursive types accompanied term constructors abs rep abs abs rep rep example translation example ccs processes syntax abs folding recursive type formally translations interpretations follows cf 
example abs abs abs abs abs abs abs abs abs abs abs abs abs abs abs abs abs abs abs abs ll continue dispense abs rep examples clarity 
chapter 
hopla useful identities provide technical results path semantics proofs 
useful reasoning encodings process calculi see section 
lemma substitution suppose disjoint 
denotation composition 
proof 
rule induction term formation rules induction hypothesis suppose permutation 
associated isomorphism 
disjoint 
denotation 
substitution lemma follows statement ll abbreviate generic substitution 
identity case 
suppose derived rule identity 
case want show done 
semantically wanted 
identity case 
suppose derived rule identity 
occurring 
case want show derived repeated weakening 
semantic result follows cts cts naturality weakening case 
suppose obtained weakening permutation 
disjoint 
want show 
occur freely 
induction hypothesis wanted 

useful identities exchange show equals cts 
cts cts cts cts ind hyp 
wanted 
weakening case 
suppose obtained weakening permutation 
disjoint 
want show induction hypothesis obtain weakening 
repeated exchange yields wanted derivation 
exchange need show cts equals cts 
cts cts cts nat 
cts cts ind hyp 
wanted 
exchange 
directly induction hypothesis 
contraction case 
suppose obtained contraction permutation 
disjoint 
want show 
induction hypothesis 


done 
assuming 
simplicity show 
equals 

ind hyp 
contraction case 
suppose obtained contraction permutation chapter 
hopla 
disjoint 
renaming necessary may assume variables occur freely want show induction hypothesis repeated exchange yields contraction 
occur freely exchange yields wanted derivation 
exchange show equals 
immediate induction hypothesis 
recursive definition 
suppose rec obtained permutation 
disjoint 
renaming necessary may assume occur freely want show rec induction hypothesis exchange yields rec occur freely rec rec done 
exchange need show rec rec 
rec fix maps rec fix mapping show mathematical induction basis 
naturality step 
nat 
ind hyp 
ind hyp 
wanted 
mathematical induction wanted equality equality fixed points follow 
nondeterministic sum 
suppose obtained permutation 
disjoint 
want show induction hypotheses done 

useful identities exchange need show 
ind hyp 
wanted 
abstraction 
suppose obtained permutation 
disjoint 
renaming necessary may assume occur freely want show induction hypothesis exchange yields occur freely done 
exchange show curry curry 
app curry app curry prop 
curry ind hyp 
wanted equality follows universal property curry application 
suppose obtained permutation 

disjoint 
want show induction hypotheses renaming variables fresh names derivation get typing rule application 
repeated exchange contraction get done 
assume simplicity empty 
show app equals app app app app app nat 
app app ind hyp 
wanted 
injection 
suppose obtained permutation 
chapter 
hopla disjoint 
want show induction hypothesis done 
exchange need show 
immediate induction hypothesis 
prefix match 
suppose obtained permutation 

disjoint 
renaming necessary may assume occur freely want show induction hypotheses repeated exchange derivation renaming variables fresh names derivation get typing rule prefix match 
exchange contraction repeatedly get assumption done 
assume simplicity empty 
show str equals str str str nat 
str str ind hyp 
str str nat 
str str str 
functor str ind hyp 
str wanted 
remaining cases projection prefixing folding unfolding handled similarly injection 
rule induction proof complete 
proposition suppose rec rec proof 
renaming variables get disjoint 
substitution lemma rec denotation rec 

useful identities suitable exchange contraction substituting get rec denotation rec 
fix fix denotation rec property fixed point fix fix wanted 
proposition suppose disjoint 

ii suppose 
iii suppose 
iv suppose suitable 
proof 
calculate follows app curry app curry univ prop 
curry substitution lemma ii calculate follows curry app univ prop 
curry iii iv obtained linearity curry uncurry proposition suppose 
ii suppose 
iii suppose 
iv suppose 
chapter 
hopla proof 
ii follow properties iii iv obtained linearity proposition suppose disjoint 

ii suppose disjoint 

proof 
calculate follows str str univ prop 
substitution lemma ii calculate follows str str linearity nd arg 
str str linearity wanted 
proposition suppose 
rep abs 
ii suppose abs rep 
iii suppose abs abs 
iv suppose rep rep 
proof 
maps abs rep inverses linear 

full abstraction full abstraction ll show path equivalence captures notion contextual equivalence defined denotational semantics 
operational formulation prove adequacy section 
contextual equivalence formally type respecting relation typing judgements 
relation relates syntactic identities ll notation relations respect types ll write just typing information irrelevant clear context 
define program closed term type type values simplest type allows denotational semantics distinguish processes called observations 
making observations program amounts saying 
program context term holes term may put form program observations denotational semantics give rise type respecting contextual preorder 
suppose say related contextual preorder written program contexts 
say contextually equivalent 
full abstraction result implies contextual equivalence coincides path equivalence 
formulate associated preorders theorem full abstraction suppose 
proof 
suppose program context 
compositionality monotonicity wanted 
prove converse define path closed term type program context respectively realise consume path induction structure ll need aware technique applied guy mccusker prove full abstraction version idealized algol 
chapter 
hopla consumers finite sets paths def def def abs def abs def def def abs def rep def pn def pn note 
syntax depends choice permutation elements semantics obtained di erent permutations 
fresh variable follows substitution lemma 
suppose closed 
get 
follows 
open terms suppose 
writing closed term likewise get 
proof complete 
operational semantics hopla operational semantics actions defined abs 
closed term ranges labels associated sum types 
actions assigned types judgements form intuitively performing action turns process type process type abs 
operational semantics notice type unique operational rules define relation rec rec abs abs abs rep example derivation fragments show operational semantics validates equivalence abs abs rep abs actions abs carry information contexts derivation tree 
similar labels appears 
operational rules type correct proposition proof 
rule induction operational rules 
abstraction 
suppose derived typing actions induction hypothesis yields wanted 
note substitution formed follows typing rules 
explicit types operational rules missing rules 
needed ensure types agree transitions 
chapter 
hopla application 
suppose derived premise typing rules induction hypothesis yields wanted 
prefixing 
suppose typing rules wanted 
prefix match 
suppose derived induction hypothesis applied right premise get wanted 
note induction hypothesis left premise 
substitution formed 
remaining cases handled similarly 
accordance ll write soundness adequacy operational semantics gives rise notion observation process may observe action deriving ll start reducing general observations observations transitions lemma order simplify stating proving soundness adequacy results 
intuitively reduction comes applying contexts carried action process cf 
example 
formally define syntactic operator structural induction left column 
convenience right column defines corresponding linear maps property 
def def def abs def rep def app def def abs def rep lemma proof 
structural induction exploiting fact operational rule deriving transitions constructs application injection folding abs abs rep 
operational semantics function space 
argue follows ind hyp 
def 
sum 
argue follows ind hyp 
def 
prefix 
argue follows def 
recursion 
argue follows abs rep rep ind hyp 
abs def 
abs structural induction complete 
proposition soundness 
proof 
rule induction transition rules 
ll dispense typing information transitions clarity 
recursive definition 
suppose rec derived rec induction hypothesis proposition rec rec 
nondeterministic sum 
suppose derived induction hypothesis linearity 
abstraction 
suppose derived induction hypothesis proposition 
chapter 
hopla application 
suppose derived induction hypothesis 
injection 
suppose derived induction hypothesis proposition 
projection 
suppose derived induction hypothesis 
prefixing 
consider transition definition 
prefix match 
suppose derived induction hypothesis induction hypothesis proposition monotonicity 
fold 
suppose abs abs derived induction hypothesis proposition rep abs abs abs 
unfold 
suppose rep derived abs induction hypothesis abs rep 
rule induction complete 
prove adequacy logical relations subsets closed terms type intuitively means paths operationally realised recursive types relations defined structural induction type employ trick essentially due martin lof see ch 

define auxiliary relations paths closed terms type induction structure def def 
ap def def abs def rep 
operational semantics lemma main lemma suppose proof 
need technical results proved induction structure paths 
says closed left closed right relation defined implies lemma lemma follows lemma subset closure written satisfies lemma freely 
proof main lemma proceeds structural induction terms induction hypothesis suppose 



ll abbreviate 

substitution 

variable 
show 
amounts remarks equivalent recursive definition 
rec show rec rec 
rec fix maps composition 
ll show induction rec 
having done may argue follows rec fix rec implies existence rec rec wanted 
basis 

definition get type term step 
suppose rec 
assumption lemma induction hypothesis structural induction rec 
chapter 
hopla rec 
transition rules rec rec rec 
conclude rec mathematical induction complete 
nondeterministic sum 
show 
exists induction hypothesis 
transition rules wanted 
abstraction 
show 
denotational semantics 
show 
suppose show transition rules su cient show 
induction hypothesis know done 
application 
show 
suppose denotational semantics exists induction hypothesis 
means induction hypothesis get wanted 
injection 
show ap 
suppose denotational semantics show ap means 
transition rules su cient show 
induction hypothesis wanted 
projection 
show 
suppose denotational semantics induction hypothesis ap ap means wanted 
prefixing 
show 
suppose denotational semantics show transition rules provide derivation show 
operational semantics 
induction hypothesis wanted 
prefix match 
renaming necessary may assume show 
suppose denotational semantics exists induction hypothesis exists induction hypothesis 
transition rules wanted 
fold 
abs show abs abs 
suppose abs abs induction hypothesis rep abs rep abs means abs abs wanted 
unfold 
rep show rep rep 
suppose rep abs induction hypothesis abs rep wanted 
structural induction complete 
proposition adequacy suppose 
proof 
direction follows soundness 
converse assume 
downwards closed subset element 
main lemma implies existence term lemma 
full abstraction operational semantics adequacy allows operational formulation contextual equivalence 
addition observing arbitrary transitions transitions processes prefix type may observe just transitions programs 
ll write 
notions observation equivalent chapter 
hopla adequacy 
terms related contextual preorder program contexts 
full abstraction formulated terms operational preorder 
inclusion holds program contexts 
correspondence result consider process prefix type successors transitions take nondeterministic sum prefixed process behaving identically ranges terms lemma linear maps generalise statement pertaining types theorem 
result subsumes soundness adequacy prove need strengthen main lemma lemma suppose 
proof 
direction follows main lemma 
converse shown induction structure paths function space 
suppose proof full abstraction get term main lemma 
definition yields induction hypothesis obtain follows 
sum type 
suppose ap definition means induction hypothesis follows 
prefix type 
suppose definition exists term applying induction hypothesis paths get follows 
soundness wanted 
recursive types 
suppose abs definition means rep induction hypothesis rep abs follows 
induction complete 
theorem correspondence ranges terms 
simulation proof 
inclusion just reformulation soundness 
converse assume 
main lemma definition means exists term lemma get lemma yields follows 
chapter correspondence result strengthened call strong correspondence relating derivations operational semantics presheaf denotations 
simulation ll consider standard notions process equivalence typed simulation 
type respecting relation closed terms bisimulation holds 


section bisimilarity written largest bisimulation second item satisfied called simulation 
simulation equivalence path semantics capture branching behaviour processes characterise bisimilarity presheaf semantics needed see part ii 
example processes denotation clearly bisimilar 
logic link path equivalence simulation 
detail consider fragment hennessy milner logic possibility finite conjunctions noted characteristic simulation equivalence case image finite processes 
ranging actions formulae grammar 
empty conjunction written write conjunction type formulae judgements idea processes type described formulae type typed notion satisfaction written defined def def 
chapter 
hopla note closed terms type related logical preorder written formulae say logically equivalent 
adequacy adapting proof full abstraction show logical equivalence coincides contextual equivalence associated preorders theorem closed terms type 
proof 
formula construct program context property 
define def def def abs def rep def 
follows formulae implies 
direction follows adequacy 
converse observe program contexts full abstraction proof subsumed contexts detail terms realising finite sets paths define actions formulae induction paths ap def def def abs def abs def def def abs def obtain ap proof full abstraction adequacy follows implies note proof establishes link paths actions ap 
example context 
example distinguish ccs processes 

simulation bisimilarity start listing unsurprising results bisimilarity mirroring section 
types left brevity 
proposition closed formed terms rec rec rep abs abs rep abs abs rep rep proof 
postulated case identity relation extended pair bisimulation 
ll show bisimilarity congruence hopla 
notation concerning type respecting relations needed 
suppose environment list 
closure substitution relates closed terms write open extension relating closures ll write restriction type respecting relation closed terms 
type respecting relation write induced relation actions inductively abs abs chapter 
hopla theorem bisimilarity congruence 
proof 
employ howe method adapted typed setting gordon typing environments 
lists finite mappings need add structural rules definition precongruence candidate shown 
howe reflexive ii operator respecting iii iv disjoint vi equivalence relation transitive closure symmetric just need show simulation bisimulation vi 
particular 
follows iii congruence equivalence relation ii operator respecting 
prove simulation induction derivations operational semantics 
fact need induction hypothesis slightly stronger expect actions actions simulation holds 
need stronger hypothesis clear case application 
case proved way assuming term constructor possibly involving binding obtain definition existence term assumption action show transition having showed cases conclude follows transition follows iv 
avoid repetition part left 
recursive definition 
suppose rec rec derived rec action rec exists term rec ii rec rec get rec rec induction hypothesis get rec rec nondeterministic sum 
suppose derived action 
simulation fresh rec rec abs abs rep rep precongruence candidate chapter 
hopla exist terms induction hypothesis applied get abstraction 
suppose derived action particular exists term induction hypothesis get application 
suppose derived action exist terms induction hypothesis get su notice stronger induction hypothesis allows choose label obtain transition injection projection 
suppose derived action exists term induction hypothesis get projection handled symmetrically 
prefixing 
suppose exists term get transition operational rules 
prefix match 
suppose derived action exist terms induction hypothesis applied get get applying induction hypothesis case yields fold unfold 
analogous injection projection 
induction complete 

simulation corollary equivalent ii closed terms 
iii closed terms proof 
implies ii direct consequence theorem reflexivity bisimilarity yields implication ii iii 
ll show iii implies 
suppose closed terms operational rules assumption bisimilar get requirement handled symmetrically 
applicative bisimilarity type respecting relation closed terms called applicative bisimulation holds 



rep rep 
applicative bisimilarity largest applicative bisimulation 
proposition bisimilarity applicative bisimilarity coincide 
proof 
congruence follows applicative bisimulation converse observe actions suppose consider transition lemma get lemma get symmetric way show transitions matched conclude bisimulation 
bisimilarity largest thing 
chapter 
hopla expressive power give examples encodings illustrating expressive power hopla 
start encoding prefix sum construct useful subsequent examples 
prefixed sum consider family types prefixed sum type stands type describes computation paths action performed resuming computation path prefixed sum associated prefix operations process type def type prefix match def prefix sum type type generally involves variable proposition propositions get ll write typical finite prefixed sum 
note prefixed sum obtained coproduct lin 
implies prefixed sum weak coproduct cts 
universal property coproduct lin adjunction lin cts chain isomorphisms lin lin cts natural reading chain backwards tuple maps components sum cts correspond unique linear map prefixed sum cts 
prefixed sum coproduct cts fact required mediating morphism unique subcategory linear maps 
ccs ccs set names def set labels def set actions 
type ccs processes specified solution equation prefixed sum 
terms ccs translated hopla function 
expressive power defined structural induction 
def rec def rec def def def par def res def rel operations parallel composition par curried convenience restriction res names relabelling rel mapping abbreviations recursively defined processes par def rec res def rec rel def rec rn rn operational semantics ccs induced translation agrees milner proposition derivable ccs hopla 
conversely hopla 
ccs 
follows translations ccs terms bisimilar hopla strongly bisimilar ccs 
recover milner expansion law directly properties prefixed sum 
process type path equivalence bisimilarity sum prefixed terms 
write application par terms type suppose 
propositions path set equals denotation expansion 
theorem proposition rephrased bisimilarity path equivalence 
chapter 
hopla higher order ccs language considered hennessy ccs processes passed channels names language seen extension thomsen chocs 
translation hopla follow hennessy defining types satisfy equations 
chiefly interested parallel composition processes par type parallel composition really family mutually dependent operations including components par type say abstractions compose parallel concretions components tupled product parallel composition defined simultaneous recursive definition 
writing components solution denotation parallel composition processes equals denotation expansion fst snd snd fst 
summations ranges labels bisimulation induced higher order ccs terms expected corresponding bisimulation relation defined applicative bisimulation restricted types processes concretions abstractions mobile ambients public names translate ambient calculus public names hopla winskel presheaf semantics mobile ambients 
translation follows similar lines process passing language 
assume fixed set ambient names syntax ambients extended processes include concretions abstractions repl open open 
syntax departs little 
adopt slightly di erent notation concretions abstractions see page encode binary product 
expressive power translation hopla clear 
constructor repl means replication 
usual convention subterm form repl closed 
intended behave repl translated hopla recursion parallel composition defined 
types ambients recursively ranges open open 
previous sections parallel composition family operations binary operation processes par family defined simultaneous recursive definition 
write components solution 
open open open open snd fst mv fst snd fst snd fst snd remaining cases symmetrically 
obtain obvious expansion law parallel composition way ccs 
ambient creation defined recursively hopla operation fst snd open 
denotations ambients determined capabilities ambient perform internal actions enter parallel ambient called action exit ambient requests action exited requests action opened open entered ambient initial actions forms restricted away 
ambient creation complicated parallel composition 
chapter 
hopla surprising ambient creation corresponds intuitively putting process parallel wall membrane mediates communications process converting actions restricting away 
tree containment structure ambients captured chain open perform 
obtain expansion theorem ambient creation 
process ranges atomic actions ambients equals denotation fst snd open 
rephrased bisimilarity path equivalence 
extensions progress extending hopla name generation 
return chapter 
hopla distinguished invisible action issue support operational equivalences weak bisimulation 
provides mathematical framework weak bisimilarity context presheaf models may starting point 
atomic actions time hopla cope independence 
chapter ll discuss language hopla built ne category cts 
tensor operation allow simple forms independence expressed 
chapter ne hopla ne hopla typed process language structure language adds hopla tensor operation comes price linearity constraints variable occurrences 
tensor understood juxtaposition independent processes intuition obtained nondeterministic dataflow 
consider processes 
drawing dataflow networks top labelling wires type values transmitted understand tensor product juxtaposition middle part tensor match composition bottom part feeding output tensor nondeterministic dataflow chapter 
affine hopla extension tensor comes price linearity constraints occurrences variables 
particular language allow write operation takes process input copies sets copies parallel composition 
operation computation paths input ne section 
note di erence copying input process copying particular interaction 
fork operation nondeterministic dataflow copies values sent output streams 
linear ne operation way copying process transmits input nondeterministic choices process preserved output fork example attaching fork process nondeterministically chooses outputting letter letter give rise output lines possibility cross output 
ll follow structure previous chapter focus ne hopla departs hopla 
giving denotational semantics proving expected results sections prove full abstraction section adapting argument hopla 
operational semantics order fragment ne hopla provided section proof correspondence soundness adequacy 
section discusses expressive power language shows encode processes fork proved challenging extend operational semantics higher order 
tensor match process interpreted composition ne may produce output obtaining input ne distribute nondeterministic sums prefix match 
means force transition order tensor match transition match need inactive 
words rule prefix match hopla operational semantics tensor match 
obliged complicated environments built tensor matches operational semantics interaction environments higher order processes problematic giving operational semantics full ne hopla 
problem caused environments complicate reasoning operational semantics 
instance expect satisfy diamond property process perform action left right component tensor opposite order 
direct proof need take account changes environment transitions obvious 
ll return point chapter 
lacking satisfactory operational semantics considered simulation ne language 

denotational semantics denotational semantics types grammar 
closed type expressions interpreted path orders 

exponential replaced weakening comonad type understood intuitively type processes may perform anonymous action ll call continuing process type solution recursive type definitions proceed hopla replacing finite sets paths sets size writing empty set 
abs stands pair paths non 
formation rules displayed alongside rules defining ordering 
note path orders interpreting types ne hopla posets exponential comonad maps posets posets 
ap abs abs abs continue prefixing terms di erence syntax hopla addition term constructors associated tensor type 
variables rec recursive definition nondeterministic sum abstraction application tensor operation match injection projection prefix operation match abs rep folding unfolding chapter 
affine hopla pattern match term tensor similar variables binding occurrences body 
closed type expressions 
distinct variables 
syntactic judgement 
stands map 
environment list empty corresponding tensor product empty path order term formation rules ne language similar hopla replacing handling environment lists type constructors 
discuss remaining di erences 
new rules introduced tensor operation important di erence lack contraction ne language 
restricts substitution common term distinct variables copying 
counterpart model absence suitable diagonal map objects example map general map consider term free variables shown explicitly corresponding map generally entail may corresponding map example intuitively computation involves inputs input twice interpreted syntactic condition see assume prefixed sum paths abbreviated 
confusing paths corresponding primes nonempty join sent needed preserve nonempty joins 

useful identities occurrences variables ensures computation set variables 
raw term 
say set variables crossed subterms form tensor application tensor match prefix match free occurrences variables appearing set crossed uses inputs computation semantically interpreted map behaves identically input case holds cf 
lemma interpreted composition maps satisfies usual properties diagonal natural transformation 
ll write obvious generalisation fold tensor product give rule recursively defined processes crossed rec fix fix fixed point continuous operation mapping composition 
useful identities counterparts results hopla section proved ne language 
particular general substitution lemma formulated follows lemma substitution suppose 

crossed disjoint 
denotation composition 
proof 
similar proof hopla replacing 
note naturality precisely cases hopla allows variables crossed recursion application prefix match 
fortunately need naturality 
give cases rule induction tensor constructs writing chapter 
affine hopla tensor 
suppose obtained set 
assumption crossed variables occur freely occur loss generality assume 
permutation 
permutation disjoint 
want show induction hypotheses typing rule tensor yields repeated exchange yields wanted 
exchange show 
follows immediately induction hypothesis 
tensor match 
suppose obtained set 
assumption crossed variables occur freely occur assume case simpler 
assume permutation 
permutation disjoint 
renaming necessary may assume variables occur freely want show induction hypothesis repeated exchange get typing rule tensor match 
exchange get wanted 
exchange show equals 
follows directly induction hypothesis 
incorporating requirement non crossed variables remaining cases similar proof hopla omit 
easy rule induction typing rules shows substitution lemma allows single variable substitutions lemma crossed proposition suppose rec rec proof 
proceed proof proposition obtaining disjoint renaming variables substitution lemma get rec denoting rec 

full abstraction sets crossed crossed rec 
repeated exchange substitution lemma may perform substitutions obtain rec denotation rec 
fix fix denotation rec properties abstraction application sums prefixing constructs folding unfolding hopla 
proposition suppose pairwise disjoint 

ii suppose suitable 
iii suppose 
suitable 
iv suppose occur 
proof 
properties consequences tensor match interpreted composition 
follows exchange applications substitution lemma 
ii iii hold composition linear ne 
iv follows associativity composition 
full abstraction hopla take program closed term type linearity constraints program contexts hole 
notion contextual preorder section 
contextual equivalence coincides path equivalence chapter 
affine hopla theorem full abstraction terms 
proof 
path consumers defined proof full abstraction hopla restricting terms cases element 
terms corresponding paths tensor type defined fresh variable proceed proof theorem 
operational semantics operational semantics order fragment ne hopla uses actions abs 
type actions typing judgements hopla type unique abs left function space actions actions correspond directly atomic paths 
atomic paths sublanguage paths cf 
generated grammar abs 
letting path type correspond action get obvious bijective correspondence atomic paths actions 
mean fragment obtained leaving function space abstraction application 
call order fragment able handle tensor match viewed abstraction immediate application order function 

operational semantics accordingly ll interpret action corresponding path observe isomorphic poset elements properly extend associated inclusion sending get map lin sending hopla actions abs maps fact just defined 
action symmetric version give rise similar equations def str str symmetric version monoidal strength defined chapter 
useful result str str str nat 
str operational semantics hopla proofs soundness adequacy benefited fact needed apply closed terms 
ne case fortunate tensor match 
interpreted composition 
suggests open term take transition environment syntactically environments lists matches empty list 
notational convenience ll write term inductively def def environment exports set variables empty environment exports empty set exports exports free variables plus possibly variables exported names 
may formalise judgement 
chapter 
affine hopla distinct denotes path set term 
term environment written give judgement denotation term variables exported free ll avoid book keeping regarding lists treating finite mappings exported variables types 
writing ll imply ordering variables 
incorporating environments operational rules shown 
define transition relation rules assumed respectively free overshadowed environment rule tensor match variables implicitly renamed avoid exported variables environment transitions change length variables environments lemma 
form 

proof 
easy rule induction operational rules 
ll write transitions empty environment 
rules typed way operational rules hopla additionally transitions change types exported variables lemma suppose 

proof 
rule induction operational rules 
variable 
suppose derived set induction hypothesis typing wanted 

operational semantics rec rec abs abs abs rep operational rules order ne hopla chapter 
affine hopla tensor 
suppose derived free variables induction hypothesis typing yields wanted 
tensor match 
assumption variables renamed necessary ensure exported variables 
done induction hypothesis 
remaining rules handled similarly 
ll write ll need syntactic operators show completeness operational semantics validates result lemma saying observations transitions reduced observations transitions lemma trivial context generated grammar 
context fresh variables 
proof 
structural induction give details case 
supposing derive fresh variables induction hypothesis means context 

operational semantics complete derivation just context 
reverse implication follows argument backwards 
correspondence result ll prove correspondence soundness adequacy exploiting linearity constraints variable occurrences ne language 
allows replace logical relations founded induction size measure terms 
course method works language obtained replacing general recursion finite unfoldings 
ll extend result cover full recursion 
term rec typed way rec interpreted th approximation denotation rec induction rec def rec def rec 
corresponding operational rule rec rec define ordinal size measure terms environments see 
need ordinals arises possibly infinite sum 
natural addition ordinals see def 
operation associative commutative identity strictly monotone argument 
variables crossed occur di erent components nondeterministic sum prove lemma suppose 

crossed disjoint 

proof 
structural induction transitions accompanied decrease size lemma suppose 
chapter 
affine hopla def rec def rec def rec def sup def def def def def def abs def rep def def def def size measure proof 
easy rule induction operational rules lemma prefix match rule 
define founded relation relates premise rules lemma rule lexicographic order proof 
straightforward case analysis lemma prefix match rule 
rule tensor match needs second clause definition 
lemma assume finitary language ranges terms 
operational semantics proof 
founded induction induction hypothesis assume variables 
range environments terms proceed case analysis variable 
possible rules derivations depending structure assumed variable free overshadowed variables exported free assumption ind hyp 
linearity nat 
assumption wanted 
possible rule handled symmetrically 
recursive definition 
possible rule rec rec rec rec ind hyp 
wanted 
nondeterministic sum 
possible rule chapter 
affine hopla str str linearity str linearity st arg 
str str ind hyp 
wanted 
tensor 
possible rules free variables ind hyp 
linearity nat 
wanted 
rule handled symmetrically 
tensor match 
possible rule assumed variables renamed necessary variables exported assumption ind hyp 
assumption wanted 

operational semantics injection 
possible rule str str str ind hyp 
wanted 
projection 
possible rule str str str ind hyp 
wanted 
prefixing 
possible rule str str 
id str prop 
str wanted 
chapter 
affine hopla prefix match 
possible rule free variables symmetry maps may assume interpreted composition str 
str str str 
id 
ind hyp 
linearity univ prop 
subst 
lemma ind hyp 
wanted 
folding unfolding 
similar injection projection 
founded induction proof complete 
ll prove correspondence general recursion 
write term obtained replacing subterms form rec rec 
conversely write term obtained removing indices subterms rec clearly 
theorem correspondence order fragment full recursion ranges terms proof 
follows linearity lemma ranges terms transition matched transition term just terms statement theorem 
follows 

operational semantics converse suppose derivation unfolds subterm rec number times derivation finite exists transition wanted 
independence stands operational semantics gives interleaving model order fragment atomic steps tensor component time 
fully match understanding tensor operation juxtaposition independent processes 
transitions upper part diamond expect able prove existence term transitions lower part completing diamond formally exhibit operational semantics asynchronous transition system 
direct proof diamond property treatment independence structure ne language wait chapter 
function space don know extend operational semantics function space general may reuse actions hopla define rules side condition closed term allowed open term actions free variables remaining rules deal 
example consider attempted derivation transition chapter 
affine hopla top correspondence lost 
presently know fix 
adding action closed destroys property actions correspond atomic paths 
may simply definitions proof correspondence extended size actions account defining founded relation def def def abs def def def expressive power subject linearity constraints occurrences variables ne language expressive power hopla 
particular calculi discussed section encoded restriction variable occur freely sides parallel composition 
prefixed sum stands ne hopla 
prefixing translated di erent semantics 
example replacing solution equation defining type ccs processes isomorphic path order nonempty strings alphabet ccs actions 
semantics ccs translation ne hopla essentially trace semantics 
illustrated fact ccs processes semantics ne hopla told apart nonlinear hopla context saw examples 
nondeterministic dataflow interestingly tensor type ne hopla allows define processes kind treatments nondeterministic dataflow cf 
possible hopla 
illustrate define recursively prefixed sum essentially consists streams sequences 
define dataflow processes properties determined properties denotational semantics particular proposition process type produces identical parallel 
expressive power streams output rec 
denotation set pairs strings prefix vice versa 
notice entanglement sides tensor choices side ect choice 
process fork type produces output streams copies input stream 
fork rec 
fork fork containing cross terms 
process merge type merges streams 
merge rec 
merge 
operational semantics extension section may execute processes get transitions fork fork note term remembers action left hand side tensor ensuring side behave way 
extensions possible extensions name generation invisible actions discussed hopla apply ne hopla 
trace operation represent dataflow processes feedback loops definable ne hopla obtained compositional relational semantics nondeterministic dataflow feedback shown impossible brock ackerman 
refined notion relation spells di erent ways input output dataflow process related semantics fact possible 
refinement obtained moving presheaf version ne category 
chapter 
affine hopla part ii presheaf semantics chapter domain theory presheaves consider ccs processes 
translations hopla ne hopla denote path sets 
nondeterministic sum interpreted union means processes represented path set 
bisimilar path semantics captures branching structure processes characterise bisimilarity 
noted domain theory path sets simple version earlier informative domain theory presheaves 
recall section path sets correspond monotone functions op modelling process path set ect representing process characteristic function paths truth values 
simple truth values take sets replacing category sets functions set obtain functors op set traditionally called presheaves 
viewed process presheaf op set associates path set xp elements ll think standing ways path realised process process di erent ways realising path way presheaf representation distinguish processes 
intuition nondeterministic sum processes represented presheaves disjoint union keep track di erent ways paths realised 
sum presheaves contribution disjoint union sets empty sum presheaves presheaf empty contribution notion presheaf sense small category chapter 
domain theory presheaves extra generality exploited dealing independence models 
particular event structures seen special kinds presheaves categories pomsets 
category ll think arrow expressing way path extended path ll call path category 
processes presheaves consider presheaf path order nonempty sequences alphabet 
functor op set assigns string set xs pair prefix function xs xs opposite direction 
understood follows xs process capable performing realised way 
intuitively capable performing shorter sequence particular sequence function simply map realiser realiser process represented presheaf follows 
nondeterministic sum ways may perform sequence way may perform sequence aa 
map element set say aa singleton say 
sequences possible elements mapped empty set 
just ways performing say may lead performing longer sequence aa aa xaa xa map 
likewise process represented presheaf mapping aa singleton see 
presheaves representations di erent presheaves keep track nondeterministic branching 
illustrated noticing presheaves bijective correspondence synchronisation trees underlying alphabet imagine adding empty sequence forming path order element 
agree process perform empty sequence exactly way add roots turning branches obtain 
generally presheaves correspond sets trees forest set roots 
adding root presheaf amounts lifting construction analogous section 
path category may add new initial object obtain path category associated construction operation presheaf singleton xp 
presheaves obtained isomorphism images called rooted 

presheaf categories proposition presheaf decomposition sum rooted presheaves presheaf isomorphism xp unique arrow general presheaf decomposition rooted components exhibits corresponding forest set trees 
construction tree presheaf generalised arbitrary presheaves 
general construction gives rise categorical version transition system called category elements presheaf 
path category op set presheaf category elements written elts objects pairs xp morphisms form arrow xe case rooted presheaves synchronisation trees obtained categories elements closed identity maps compositions edges 
shows category elements presheaves 
identity maps left clarity 
presheaf categories presheaves path category objects functor category op set arrows natural transformations 
spelled natural transformation presheaves family functions xp satisfying arrow square commutes 
xp xe oo xp fp entirely obvious process concept amounts replay terms categories elements 
function xp natural transformation induces map elts objects elts elts sending 
naturality simply functoriality elts sends morphisms elts morphisms elts example define natural transformation presheaves see 
fp means equivalently elts maps 
preserves transitions categories elements think functional simulation relation transition systems 
chapter 
domain theory presheaves xaa aa xa presheaves xaa aa xa oo oo oo presheaves synchronisation trees aa aa aa aa oo aa oo aa cc presheaves categories elements aa aa oo aa oo oo presheaves natural transformation 
presheaf categories presheaf category limits colimits pointwise particular object corresponding limits colimits sets 
exposes nondeterministic sum coproduct presheaves empty coproduct 
colimits generalised joins reasonable view presheaf categories generalised nondeterministic domains 
presheaf category associated canonical functor standardly called yoneda functor saying view paths processes images yoneda called provide straightforward generalisation notion primes nondeterministic domains chapter 
intuitively maps computation path process may single computation shape path extension simulation computation longer 
intuition natural transformation shows process may simulate process capable performing just path set xp intuitively set natural transformations 
content lemma yoneda xp naturally classic result directly generalises equivalence path sets 
immediate consequence yoneda functor full faithful allowing view essentially subcategory situation canonical example situation led joyal nielsen winskel open map bisimulation 
yoneda lemma map open situation left may complete square right fp oo fp oo oo transition system intuition just requires reflect preserve transitions expected 
analogue saying path set union primes presheaf colimit elts 
role colimit glue paths dictated category elements counterpart freeness property chapter 
domain theory presheaves free colimit completion functor category colimits colimit preserving functor determined isomorphism see page elts fp 
suggests considering colimit preserving functors presheaf categories 
freeness property functors correspond isomorphism functors chain equivalences op set op set op 
path category op provides function space 
linear nonlinear maps obtain categories lin cts intuitively way corresponding categories obtained section giving rise categorical model linear logic pseudo comonads models intuitionistic logic ne linear logic respectively 
give brief overview details 
write lin category objects path categories arrows colimit preserving functors associated presheaf categories natural transformations cells 
equivalence categories lin op set provides relational exposition maps lin paths related set ways just related related path set case 
exposes op involution linear logic 
useful chapter functors op set stand maps lin 
functors called profunctors bimodules distributors see elementary 
bicategory profunctors prof lin equivalence 
ll write op set 
composition profunctors obtained coend formula 
intuitively role coend away communication processes 
linear nonlinear maps analogue exponential obtained free finite colimit completion shown inclusion functor free filtered colimit completion see 
follows maps lin correspond isomorphism filtered colimit preserving continuous functors operation extends functor cts lin adjoint inclusion lin cts categories 
unit adjunction 
likewise inclusion sending acting free connected colimit completion maps lin correspond isomorphism connected colimit preserving ne functors lifting extends functor lin functor lin takes decomposition def cf 
proposition 
functor pseudo left adjoint inclusion lin unit operation section 
maps represented profunctors composition mirrored composition profunctors 
useful way defining composition follows 
currying obtain functor curry lifting sending curry composition obtained composition curry profunctors curry 
see categorical situation presheaves path sets universal constructions properties carry need replace straight equality isomorphism 
ne hopla interpretation types posets paths path set case hopla need move path categories generally category just poset 
solutions recursive type equations obtained characterising solutions isomorphism 
fact type constructors preserve inclusions categories argument recursive types interpreted limits chains inclusions 
interpretation recursive types identical unfoldings may elide abs rep isomorphisms 
ll exploit chapter 
operator preserves property essentially small equivalent category objects form set 
su cient ensure category 
chapter 
domain theory presheaves exception properties chapter sections shown hold isomorphism presheaf setting 
exception equation section 
fails tensor match ne matched term ne means preserving connected colimits just nonempty joins sums coproducts manifestly connected 
di erence notion ne moving path sets presheaves central distinguishing power presheaf semantics 
interpretation term ne map allowing ne maps preserve nonempty joins validates 
presheaf semantics ne hopla distinguishes terms cases 
prefixing interpreted lifting construct section indicated analogous adding root synchronisation forest forming tree 
presheaf semantics ne hopla interprets processes presheaves corresponding usual synchronisation tree representations figures 
follows immediately presheaf semantics hopla ne hopla fully respect contextual equivalence full abstraction results part contexts distinguishing terms 
chapter strong correspondence despite correspondence results theorems path semantics really explain operational semantics hopla ne hopla 
processes equated path semantics results hold operational semantics extra rule 
clearly wrong 
chapter provides explanation operational rules chapters relating presheaf denotations derivations operational semantics 
terms actions correspondence results state equality ranges terms stronger correspondence obtained presheaf semantics replacing sum successor terms sum derivations need replace equality isomorphism 
operational rules designed strong correspondence mind 
rule violate strong correspondence 
section prove result finitary hopla leaving recursive types recursive process definitions 
succeeded extending proof full hopla 
progress outlined section 
strong correspondence ne hopla easier see section 
chapter 
strong correspondence finitary hopla recursive types give simple proof strong correspondence hopla 
proof easily extended handle recursively defined processes interesting recursive types leave recursion terms types 
proof uses logical predicates closed terms type defined structural induction types def 
aq ap def def sum ranges derivations logical predicates extend actions follows abs structural induction types lemma suppose actions 
recall lemma says fact derivations bijective correspondence ll fact freely 
addition ll presheaf versions propositions saying presheaf semantics isomorphisms lemma main lemma terms finitary hopla 
proof 
structural induction terms induction hypothesis suppose 


ll abbreviate 



finitary hopla variable 
immediate 
nondeterministic sum 
lemma show 
letting range derivations derivations operational rules linearity ind hyp 
induction hypothesis wanted 
abstraction 
lemma show particular 
letting range derivations derivations operational rules def 
ind hyp 
induction hypothesis wanted 
application 
induction hypothesis definition yields aq wanted 
injection 
lemma show 
letting range derivations derivations operational rules def 
ind hyp 
chapter 
strong correspondence induction hypothesis wanted 
projection 
induction hypothesis ap definition wanted 
prefixing 
just derivation identity definition induction hypothesis 
prefix match lemma renaming necessary distinct show 
induction hypothesis yields derivations letting range derivations derivations operational rules compositionality linearity ind hyp 
induction hypothesis aq induction hypothesis wanted 
structural induction complete 
theorem strong correspondence suppose finite hopla 
ranges derivations proof 
main lemma 
ranges derivations result follows lemma 
full hopla extending result full language particular including recursive types reasonable try imitate logical relations section 
relation path set 
full hopla closed term understood intuitively saying paths operationally realised generalising presheaves led say path may realised give set ways may realised led turn logical relations presheaves replace 
straightforward realisability interpretation obtain uq tp tp abs rep tp ranges derivations particular set obtained replacing universal quantification product implication function space formula stands problem 
free completion paths interpreted finite colimits finite sets paths 
immediately obvious define formal language paths morphisms paths structural induction sense 
problem considered slightly roundabout approach starting definition nondeterministic evaluation relation closed formed term generated grammar abs 
evaluation relation defined rules rec rec abs abs abs rep rule induction implies expected 
lemma suppose bijective correspondence pairs derivations derivations proof 
induction defines map pairs derivations derivation derivation chapter 
strong correspondence derivations types omitted clarity notation mean derivation conversely induction defines map derivations pairs derivation derivation exploited definition unique subderivation deriving abs abs subderivation may apply inductively strict subderivations 
maps shown inverses straightforward inductions derivations 
non value define def ranges derivations values presheaves defined wellfounded induction lexicographic product founded relation path objects morphisms structural order values 
defining equations def def def tp def tm tp def def abs vp def vp abs def vm ranges finite colimits objects notation pairs op notation images injection map path categories 
map maps tuple tuple ll drop injection brevity 
lemma presheaves defined 
proof 
founded relation paths obtained axiom foundation saying relation founded 
set theoretic encoding pairs sets injects pairs sets 
full hopla def def rec rec def rec rec def def def abs abs abs abs def abs abs abs rep def abs abs abs rep definition chapter 
strong correspondence def def rec rec def rec rec def subderivation def subderivation abs abs def abs abs abs abs abs rep def abs rep subderivation abs abs definition 
full hopla finite colimits presheaves functors pairs functions sets 
function objects set pairs pp 
pp 
founded order paths satisfying pp extend order morphisms product construction def relate paths morphisms def def clauses definition presheaves paths morphisms mentioned left hand side related needed right hand side 
particular obtain set need consider path objects pp morphisms paths 
fourth clause path morphism mentioned sides structural size value decreases 
founded induction lexicographic product structural order values presheaves defined 
definition show result corresponding main lemma lemma section 
ll need auxiliary notation 
consider family 
ll write obvious map second maps respectively 
want map xy application yields map fg xy path application coend formula derivation unique morphism coend vertex wedge chapter 
strong correspondence functor 
square app app commutes 
app maps take fg xy lemma main lemma set nonempty 
proof 
structural induction open terms induction hypothesis suppose free variables 
closed terms map 

natural ll abbreviate 

ll suppress free variables possible 
variable 
immediate projections product natural recursion 
want map rec rec ll start showing map rec rec rec th approximation denotation rec 
basis 
rec empty presheaf may empty natural transformation 
step 
suppose rec rec induction hypothesis structural induction natural transformation rec rec 
rec rec obvious isomorphism rec rec take 
mathematical induction complete 
map rec rec induction empty natural transformation diagram shape colimit denotation rec show rec vertex 
full hopla corresponding cocone done take unique mediating morphism colimit rec clearly show triangle commutes rec rec rec proceed mathematical induction 
base case obvious empty 
induction step suppose diagram commutes 
need show wanted equality follows naturality commutativity diagram 
mathematical induction complete rec vertex cocone wanted 
nondeterministic sum 
want map induction hypothesis map take abstraction 
want map need function natural note induction hypothesis provides natural transformation 
take component map naturality follows naturality naturality follows naturality application 
want map induction hypothesis maps take prefixing 
want map induction hypothesis map take prefix match 
want map 
induction hypothesis map letting range derivations note chapter 
strong correspondence denotational semantics derivation canonical map corresponding fact path sets induces unique mediating map coend coend induction hypothesis get natural transformation may take 
remaining cases treated similarly 
combine result approach section logical predicate natural transformations prefix type ensure got just map suitable bijection giving strong correspondence main lemma 
expect define predicates predicates defined founded induction lexicographic product show definedness presheaves value derivation provides map define terms 
proof lines progress 
alternative way obtaining main lemma possible avoiding nondeterministic evaluation 
direct definition presheaves di erent treatment recursive types 
approach uses realisability version lemma flexible may able adjust behave respect suitable logical predicates ne hopla ne hopla presheaf proposition rooted component decomposition 
affine hopla lifting interprets prefixing proving strong correspondence amounts showing elements correspond bijectively derivations theorem strong correspondence suppose ne hopla 
ranges derivations proof 
sketch ne hopla finite unfoldings recursively defined processes founded induction size measure essentially repeating proof lemma showing correspondence finite unfoldings 
presheaf semantics recursively defined processes type interpreted colimits form composed universal constructions constructions preserve natural transformations components injections colimit contribution isomorphism allows kind reasoning proof theorem extending result full recursion 
chapter 
strong correspondence chapter event structure representation study independence structure tensor operation ne hopla giving event structure semantics language 
order agrees presheaf semantics presheaves corresponding finite configurations representing event structure 
representation open terms ne hopla associates configuration minimal input needed corresponding realisation 
analogous berry stability requirement cf 
section 
stability meant avoid functions parallel hopla ne hopla allow functions expressed 
consider term 
path semantics term interpreted function mapping 
function stable path set dominates inputs unique minimal input associated output 
intuitively way realising output associated minimal input paths respectively 
presheaf semantics needed distinguish di erent realisations computation path 
presheaf semantics just output realisation input realisation input 
section reviews event structures basic constructions notions morphism 
put section provide representations path orders order fragment ne hopla certain kinds profunctors 
section shows representable profunctors include order language 
provides alternative denotational semantics fragment 
chapter 
event structure representation alternative operational semantics order fragment considered section 
allows easy proof diamond property discussed section 
section briefly outlines event structure denotational semantics extends higher types loss correspondence presheaf semantics 
tentative extension operational semantics fully general rules function space provided 
event structures repeat definition event structures girard notation consistency complement conflict reflexive closure written complement 
specifying relation clearly determines 
event structure triple set events partial order causality binary symmetric irreflexive relation conflict defined 
data satisfy def finite 
ii configuration subset downwards closed 
ii consistent ll write partial order finite configurations ordered inclusion 
note empty set belongs pointed configurations said compatible written exists configuration event structures viewed elements cpo admit fixed points continuous operations 
event structures 
say substructure written ii iii clearly event structure 
event structures ordered form large cpo cpo fact elements form proper class set 
element upper bound chain 
event structures 
extends tuples event structures obvious point wise way 
operation tuples event structures monotone continuous monotone continuous argument separately 
su ces check monotonicity continuity unary operations monotone unary operation continuous continuous events chain event event 
list basic constructions event structures clearly monotone sum 
define events disjoint union concreteness causality def conflict def 
subset configuration form poset coalesced sum posets 
assume chain events form event event pair event event monotonicity wanted 
tensor 
define events disjoint union causality def conflict def subset configuration form 

chain event may form event 
pair event 
events form event event event continuous 
continuity argument obtained symmetrically 
lifting 
define events 
causality inclusion 
conflict incompatibility 
chapter 
event structure representation subset configuration empty form 
chain event may form event 
event 
event event event 
lifting continuous 
representations may constructions give meaning types order fragment ne hopla 
range finite maps type variables event structures 
define def def def def def th component fixed point mapping sending tuple event structures tuple 

ll confuse closed expression event structure event structure 
induction syntax types show isomorphic corresponding path order chapter 
ll path notation chapter configurations event structure ranging nonempty configurations configurations 
unfortunate consequence stands nonempty configurations possibly empty configurations ll avoid confusion 
ll write terms ne hopla consider presheaf op set path order constructing category elements obtain monotone function elts posets elts sending map discrete fibration 
general functor discrete fibration ox object unique arrow mapped 
representations discreteness fibration lies uniqueness arrow case elts take 
functor elts category presheaves equivalent category discrete fibrations 
right adjoint elts maps discrete fibration presheaf xq ox 
represent discrete fibrations presheaves strict morphisms called output morphisms 
output morphism map implies oe oe oe output morphisms compose extend directly strict monotone maps configurations 
identity morphism output morphism inclusion associated substructure relation lemma output morphism 
extension configurations discrete fibration 
proof 
consider configurations ox show unique ox subset oe injective consistent subsets unique subset image just need show configuration oe configurations downwards closed oe output morphism oe follows downwards closed 
consistency immediate subset configuration output morphisms give rise discrete fibrations presheaves path order 
strict presheaf rooted isomorphic presheaf path order elts 
presheaves represented way able represent closed terms ne hopla ground type course give compositional event structure semantics language need show interpret open terms need representation profunctors path orders event structures 
get help category theory 
ignore lifting moment 
category prof profunctors equivalent category discrete 
starting constructs category elements elts objects triples arrows marcelo fiore making aware connection 
chapter 
event structure representation obvious projections elts elts yield span elts dual notion fibration associated operator objects fibration 
span satisfies certain coherence discreteness axioms ect starting span construct ox elts compose constructing pullback quotienting way similar happens coend formula ensure span bifibration 
ll go detail lack way representing maps event structures 
consider stable profunctors curried functors curry preserve pullbacks 
pullbacks isomorphism intersection compatible configurations unique minimal accordingly collapse category elements elts input side retain triples input minimal 
turns ordinary monotone map restores discrete fibration collapse isomorphic category elements presheaf curry reuse output morphisms output side map represented input morphism event structures 
input morphism map extension map got def monotone strict 
input morphisms compose map input morphism event structure extension identity 
note composition input morphism output morphism input morphism 

representations way led consider spans event structures input output morphisms respectively 
guided span induces rooted stable ox 
note replaced identity map inclusion 
rooted means singleton 
isomorphism rooted profunctors correspond profunctors path orders 
ll notation span write represented elts curry 
ll write spn category objects spans arrows output morphisms vertices spans diagram commutes input side oe oe morphisms spans correspond natural transformations represented profunctors 
proposition functor spn prof full faithful 
proof 
consider morphism spans write represented profunctors 
construct natural transformation extended map configurations 
ox oe show span morphisms diagram commute nose correspond natural transformations naturality squares pullbacks 
condition just rephrasing berry stability requirement morphisms may appropriate 
chapter 
event structure representation ox ox wanted 
naturality consider square oo 
ox ox oe wanted 
conversely consider natural transformation event natural transformation 
output morphism means 
output morphism define oe immediately obtain oe 
oe oe oe diagram commutes way wanted 
preserves consistency maps configurations configurations oe oe oe oe follows output morphism 
preserves output morphism 
maps inverses 
direction starting morphism spans obvious 
converse need show natural transformation completely determined values prime configurations 

ox naturality implies ox ox done 
spn embeds prof 
nice point give independent characterisation represented profunctors allowing abstractly 
don 
note restricting morphisms spn induced substructure relation obtain large cpo ordered restrictions events allows give meaning recursively defined spans 
spans compose adjoining pullback way similar need quotienting vertex 
spans 
representations construct span defining events 
causality def consistency def maps second projections proposition shows amounts adjoining pullback diagram working category posets monotone maps 
proposition map input morphism output morphism 
map isomorphism 
proof 
note configuration 

compatible consistent subset subset image output morphism 
map input morphism construction 
show output morphism suppose 

implies contradiction wanted 
consider 
need show 
definition events implies existence unique wanted 
converse su ces observe preserves causality 


true subset mapping pair get part wanted isomorphism 
converse consider define def 
consistency follows components compatible subsets second components consistent elements follows downwards closure 
just need show mappings mutual inverses 
mapping 
conversely mapping pair chapter 
event structure representation exists unique conclude subset property 
done 
way input output morphisms compose maps form span ll take composition spans 
proposition situation 
proof 
composition coend curry 
coend set isomorphic suitable quotient curry 
stable minimal inputs representatives equivalence classes describe composition curry input minimal 
properties representations isomorphic 
proposition yields set isomorphic oc wanted 
naturality immediate naturality square built inclusions isomorphism 
naturality suppose pair unique induces unique belongs image 
need show corresponding configurations 
stable denotational semantics related just need show oc 
obtained oc identity represented span 
identity composition expect spn suitable sub bicategory prof stable denotational semantics mirror constructions maps section continuous constructions spans get event structure version presheaf denotational semantics ne hopla order 
spans represent maps equivalence prof 
ll notation represented map identity 
span representing identity map products 
product path order represented sum event structures 
projections represented spans 
family spans representing maps construct representation unique isomorphism map form span defining 
empty product empty event structure unique map represented empty span 
nondeterministic sum map represented span tensor 
spans representing maps obtain representation tensor product span 
unit tensor construction empty event structure right identities represented spans 
left identities represented similarly 
symmetry map represented span 
weak diagonals represented spans defined 
chapter 
event structure representation sums 
sum type path order projections represented way product 
injections represented spans 
prefixing 
prefix type path order represented lifting corresponding event structure 
unit represented span obvious inclusion events configurations conversely counit represented span 
represented span represented span nonempty configuration corresponding image input morphism ox output morphism 
strength maps str represented spans str str str 
definition nonempty configuration vertex image str recursive definitions 
remarks proof theorem fixed points spn yield results colimits constructions 
ll write map obtained rules defined path semantics section presheaf version 
similarly ll write span obtained rules interpreting morphisms spans 
straightforward induction typing derivation proposition suppose formed term order fragment ne hopla 

span interpreting 
ll write set configurations ox propositions provide characterisation sets 
proposition 
ii 
iii obtained weakening 
iv obtained exchange 

stable denotational semantics proof 
empty configuration unique configuration empty image output morphism 
ii identity span vertex input output morphisms identity maps configurations 
iii interpreted weakening interpreted composition zz proposition configurations composition correspond bijectively triples configurations satisfying configurations composition bijective correspondence configurations 
configuration composition corresponding sent input morphism output morphism oc wanted 
iv similar iii 
proposition rec rec abs abs rep abs proof 
give proof prefix match cases handled similarly 
section defined composition str 
obtain composition spans yy ou str zz chapter 
event structure representation proposition nonempty configurations composition correspond pairs str nonempty configurations bijective correspondence pairs configuration pair associated input output 
remaining spans yy proposition nonempty configurations span bijective correspondence pairs nonempty configurations bijective correspondence configurations associated input output final proposition see nonempty configurations bijective correspondence pairs nonempty configurations bijective correspondence pairs associated input output done 
stable operational semantics propositions suggest alternative operational semantics firstorder ne hopla obviating need environments section exploiting stability 
cost having transitions open terms 
consider open term interpretation span element set ll derivation transition form isomorphism obtained span defined section 
operational rules derive transitions syntactic representation unique minimal input needed derived transition 
call operational semantics stable 
operation configuration define 
stable operational semantics events causality obtained restricting conflict obtained restricting subset configuration configuration disjoint poset isomorphic poset elements construction extends spans lemma get span ox oe 
proof 
event show configuration 
configuration configuration 
input morphism configuration consistent maps events configurations 
input morphism follows immediately input morphism 
show oe event ox 
ox show oe oe definition oe oe follows output morphism 
sends events events ox 
preserves causality oe ox ox means wanted 
configuration event structure interpretation type taken synonym def def def def abs def operational rules consider environment list 
ll write path list 
case shall write environment list 
confuse configuration turn confused 
chapter 
event structure representation reasonable way define operational rules transitions form need rules handling weakening exchange 
clearly rules hope obtaining bijective correspondence derivations configurations 
ll global type environment assigning types variables corresponding path maps path type variables path map written 
ll write environment list agrees sense occurs path map assigns variables mentioned viewed path list conversely path list extends path map mapping variables 
restrict disjoint ll write path map obtained concatenation lists 
operational rules shown 
semantics parameterised global typing environment left implicit 
transition relation defined path maps terms paths rules type correct proposition suppose global typing environment 
proof 
rule induction operational rules 
bottom 
consider transition done 
variable 
consider transition bot wanted 
tensor 
suppose derived induction hypotheses get typing rule tensor done 
tensor match 
suppose derived 
stable operational semantics rec rec abs abs abs rep stable operational semantics order ne hopla induction hypotheses get hypothesis yields 
typing rule tensor match yields wanted 
prefixing 
suppose derived induction hypothesis get done 
prefix match 
suppose derived induction hypothesis get hypothesis yields 
substitution lemma yields wanted 
remaining rules handled similarly 
strong correspondence result relating derivations configurations obtained directly propositions 
theorem strong correspondence 
bijection set derivations set 
chapter 
event structure representation proof 
unique derivation rule axiom transitions path transition non 
derivation mapped unique element cf 
proposition part 
just need relate derivations nonempty configurations 
recursion treated finite unfoldings section omit details 
proof proceeds structural induction identity 
unique derivation writing path list obtained extending map derivation unique configuration corresponding cf 
proposition parts ii iii 
nondeterministic sum 
ind hyp 
prop 
wanted 
tensor 
ind hyp 
prop 
wanted 
tensor match 
ind hyp 
prop 
wanted 
prefix 
ind hyp 
prop 
wanted 

stable operational semantics prefix match 
ind hyp 
prop 
wanted 
remaining cases treated similarly 
theorem says successor term transitions section shows able compose derivations restrict obtain derivations smaller output 
matches corresponding operations configurations soundness result follow cf 
proposition 
operations derivations ll consider composition restriction syntactic operations derivations 
corresponds extension configurations addition compatible events corresponds restriction operation configurations induced output maps 
defining composition derivations need technical lemma lemma suppose disjoint 
proof 
result proved structural induction induction hypothesis suppose 

crossed disjoint 


result follows rule transitions 
ll write path obtained configuration treat syntactic operator paths def def def def def abs def abs chapter 
event structure representation composition paths extends composition path lists obvious way 
suppose derivation derivation defined figures derivation save space typing information omitted figures 
derivation ll write restricted derivation defined figures 
note residual derivation obtained reading equations def defining composition definition operations allow extend bijection strong correspondence result complete representation spans derivations 
disjoint determine spans isomorphism 
consider interpretation strong correspondence result properties output morphisms events correspond derivations prime configuration path list label yield images event events represented derivations oe exists derivation oe oe prove proposition soundness 
derivation 
proof 
span span 
represented derivations derivations derivation represent precisely configurations extending 
consider event isomorphism know belongs event corresponding 
derivation px representing ox derivation restricts restricts residual derivation pe oe restricts restricts 
means derivation pe oe 
lemma done 

stable operational semantics def def def rec rec def rec rec def def def composition derivations chapter 
event structure representation def def def def induced lemma 
abs abs def abs abs abs rep def abs rep composition derivations continued 
stable operational semantics def def rec rec def rec rec def def def restriction derivations chapter 
event structure representation def def def def abs abs abs def abs abs abs rep def abs abs rep restriction derivations continued 
stable operational semantics relating operational semantics relate stable operational semantics original operational semantics chapter 
note actions chapter correspond atomic paths strong correspondence derivations stable semantics correspond configurations event structure representation elements presheaf denotation strong correspondence original operational semantics relates derivations 
bijective correspondence derivations stable semantics derivations original semantics 
note actions atomic paths correspond singleton configurations properties output morphisms configuration mapped singleton configuration singleton 
derivations semantics correspond events vertex image output morphism 
complete picture able relate sequences transitions original operational semantics configurations 
involves ability ignore ordering occurrences independent events events related unrelated causality ordering corresponding transitions 
events vertex independent independent images output morphism 
independence events type induces syntactic independence relation actions reflexive closure congruence actions satisfying actions ignore ordering transitions corresponding independent events need diamond property discussed section 
corollary result shows labelled derivations matched successor terms identical 
proposition suppose original operational semantics chapter stable operational semantics 
proof 
rule induction original operational rules induction hypothesis suppose 
defined path maps environments follows true chapter 
event structure representation inductively def 

ll omit typing information transitions 
note exists 
variable 
suppose derived induction hypothesis premise equivalent existence derivation 
equivalent definition stable operational rules yields derivation done 
rule variables handled symmetrically 
tensor 
suppose derived induction hypothesis premise equivalent existence derivation 
stable operational semantics exists derivation wanted 
tensor match 
suppose derived induction hypothesis premise equivalent existence derivation 
definition means derivation 
stable operational semantics derivation wanted 
prefix match 
suppose derived induction hypothesis premise equivalent existence derivation 
induction hypothesis second premise equivalent existence derivation 
lemma implies exists derivation derivation 
derivation get derivation wanted 
conversely derivation induces derivations 
done 
remaining rules handled similarly 

higher order processes corollary diamond property holds original operational semantics 
proof 
omit typing information 
derivations original semantics corresponding derivations stable operational semantics proposition 
composition derivation restriction obtain derivation residual derivation proposition get corresponding derivations original semantics wanted 
follows easily transitions original semantics transitions replacing actions events sitting exhibit original operational semantics asynchronous transition system 
higher order processes event structure semantics extends higher order processes price correspondence presheaf semantics fails 
event structures define event structure describing configurations 
subset write 

configuration ii 
iii 
defines stable family configurations event set 
event structure events induces stable family configurations events configurations elements family 
construction part adjunction categories event structures stable families right adjoint constructs stable family event structure events prime configurations family 
prime configurations nonempty subsets satisfying ii strengthened demanding empty form 
adjunction yields bijective correspondence output morphisms morphisms stable families morphisms bijective correspondence spans chapter 
event structure representation direction correspondence span sent map oe 
adjunction corresponds output morphism bijective correspondence spans spn obtain isomorphism categories spn spn 
indicates function space spans category spn plays role op showing function space lin maps lin 
families configurations defining trivial renaming events isomorphism event set induces isomorphism 
obtain chain isomorphisms spn spn spn spn 
take evidence spn monoidal closed structure omit details 
denotational rules function space section provide full language ne hopla stable denotational semantics 
stable operational semantics extended full ne hopla allowing configurations functions spaces labels transitions form tag configuration extra information needed rule lambda abstraction label transition currying configuration represented premise projections determine complicated labels extra semantic information needed operational semantics denotational nature 
reasonable look simple labels replace function space configurations 
obvious attempt paths section 
leads rules rules behave wanted don proof pinpointing correspondence event structure semantics 

higher order processes problem paths contain little information describe configuration generally configurations best derivations correspond equivalence classes configurations vertex equivalence relating configurations images projections 
hope able adapt proofs strong correspondence soundness accordingly 
chapter 
event structure representation chapter section summarises thesis section discusses related aiming extending basic domain theory fuller coverage concurrent computation 
summary simple domain theory concurrent processes framework scott strachey 
processes represented sets computation paths hennessy full abstraction ccs process passing 
ordered inclusion path sets form nondeterministic domains expressive metalanguages concurrency hopla ne hopla canonical constructions domains 
denotational semantics fully contextual equivalence characterised equality path set denotations 
may argue nondeterministic processes considered better fit scott domain theory sequential programs 
domains constructed computation paths form intuitive basis prime elements useful giving simple adequacy proofs somewhat subtle information ordering replaced concrete inclusion path sets metalanguages arise directly canonical constructions domains extra notion evaluation strategy needs catered lifting full abstraction easy consequence expressiveness respect computation paths 
domain theory path sets simple version earlier informative domain theory presheaves 
compared path set semantics process presheaf says computation path may performed process yields set ways may realised 
extra structure presheaves takes nondeterministic branching behaviour processes account 
presheaf semantics metalanguages inform operational se chapter 
mantics derivations corresponding presheaves 
strengthens correspondence results obtained path semantics subsuming standard soundness adequacy results 
domain theory metalanguages highlighted role linearity concurrent computation distinguishing linear ne continuous process operations respectively exactly finite number computation paths input providing path output 
continuous operations embodied hopla receive code processes free copies code order explore behaviour input di erent contexts 
ne operations embodied ne hopla allow copying examine input single context 
operations realistic distributed setting processes interact peers sent code 
linear operations restricted allowed ignore input nontrivial behaviour 
linear operations 
useful reasoning processes attentive linearity amounts preserving nondeterministic sums leading expansion laws 
metalanguages shown expressive handle nondeterminism prefixing higher order processes extent allowing direct encodings ccs ccs process passing mobile ambients public names ne language suitable restrictions variable occurrences remarkable process constructs metalanguages far encodings concerned nondeterministic sums prefix operations 
particular parallel composition ambient creation defined languages need primitive constructs 
ne hopla additional construct tensor operation allows ne metalanguage encode dataflow processes multiple communication lines 
event structure representation order fragment ne language exposed tensor juxtaposition independent processes 
related main extensions concern name generation independence models bisimulation 
name generation encodings ccs process passing mobile ambients public names show metalanguages express certain forms mobility processes virtue allowing process passing 
kind mobility mobility communication links arises name generation calculus 
inspired hopla winskel defined 
related higher order process language name generation allowing encodings full ambient calculus calculus 
extensions add type names function spaces type supporting new name generation abstraction new denotational semantics extension currently developed addresses question function spaces exist obvious model extending 
operational semantics hopla stages indexed current set names 
independence event structure representation ne hopla exposes ne language yields independence model concurrency 
coverage independence models limited 
spans event structures chapter allow defining trace operation nondeterministic dataflow 
representable profunctors stable rooted called stable port profunctors give fully denotational semantics nondeterministic dataflow trace 
operation spans trace maps span events prime configurations satisfying certain requirement ect input type previously output 
conflict event structure general binary relation spans generalised allow vertices general event structures consistency predicate replacing conflict relation 
noted section trace expressed ne hopla best extend syntax operational semantics ne language accommodate trace known 
importantly show event structure denotations ne hopla impoverished coincide standard independence semantics ccs 
term corresponding interpretation events poset linear order 
contrast standard semantics parallel composition modelled event structure mutually consistent events unrelated 
move ne hopla defining semantics 
guidelines lacking ne language got presheaf models concurrency ingredients product presheaves pomset augmentation cartesian liftings extending match operators ne hopla play critical role 
suggests exploring event structure representations general spans event structures new comonad yielding rigid chapter 
form prefixing 
general point categories obtained presheaves rich structure pointing expressive languages hopla ne hopla 
particular ne category accommodates independence model event structures extent supporting standard event structure semantics ccs related languages trace nondeterministic dataflow 
bisimulation presheaf models come built semantic notion bisimulation derived open maps general reasons equivalence congruence metalanguages 
general reasons remarkable result cattani winskel says morphisms lin preserve open maps respect situation diagram left definition means open 
cattani winskel show morphisms preserve open maps respect situation center diagram show morphisms cts preserve open maps respect situation right diagram 
ll return 
open map bisimilarity preserved cases giving congruence results free process languages interpreted lin cts 
part motivation winskel original ne hopla hope operational semantics full ne hopla provide operational coinductive characterisation open map bisimilarity 
unfortunately operational semantics ne language extended higher order processes general stable operational semantics correct helpful underlying event structure semantics diverges presheaf semantics 
full operational semantics hopla notion open map degenerates isomorphisms congruence result trivial 
collapse open maps cts suggests look choices exponential 
presentation hopla universal constructions helpful evaluating candidates 
stands general operational understanding open map bisimulation obtained 
fact metalanguages may 
related able provide understanding 
recall maps lin correspond profunctors op set 
bicategory prof profunctors lin lin bicategory prof involution maps correspond dual just lin map corresponds map output input 
duality open maps open map bisimulation higher order processes take account input output 
higher order processes defined bisimilar yield bisimilar outputs common input cf 
section 
simply won type discipline nontrivial output input 
hand traditional process languages types don support duality 
line understanding open map bisimulation higher order design process language duality 
language support types prof extended suitable pseudo comonad 
ideally obtain coinductive characterisation open map bisimulation higher order operational semantics 
chapter 
bibliography abramsky 
lazy lambda calculus 
turner editor 
research topics functional programming 
addison wesley 
abramsky 
computational interpretations linear logic 
theoretical computer science 
abramsky jung 
domain theory 
abramsky editors 
handbook logic computer science 
volume 
semantic structures 
oxford university press 
abramsky 
game semantics programming languages 
proc 
mfcs lncs 

categories asynchronous systems 
phd thesis university sussex 
barendregt 
lambda calculus 
syntax semantics 
revised edition north holland 
benton 
mixed linear non linear logic proofs terms models extended 
proc 
csl lncs 
berry 
des lambda types 
de doctorat etat universite paris vii 
borceux 
handbook categorical algebra basic category theory 
cambridge university press 
brauer reisig rozenberg editors 
petri nets central models properties 
lncs 
brauer reisig rozenberg editors 
petri nets applications relationships models concurrency 
lncs 
:10.1.1.120.180
axiomatic approach adequacy 
ph dissertation university aarhus 
brics dissertation series ds 
bibliography brock ackerman 
scenarios model nondeterminate computation 
proc 
formalization programming concepts lncs 
cardelli gordon 
anytime modal logics mobile ambients 
proc 
popl 
cardelli gordon 
commitment relation ambient calculus 
note 
october th 
available research 
microsoft com adg 
cattani winskel 
presheaf models concurrency 
proc 
csl lncs 
cattani stark winskel 
presheaf models calculus 
proc 
ctcs lncs 
cattani fiore winskel 
theory recursive domains applications concurrency 
proc 
lics 
cattani 
presheaf models concurrency 
ph dissertation university aarhus 
brics dissertation series ds 
cattani winskel 
profunctors open maps bisimulation 
manuscript 
available www cl cam ac uk gw 
church 
unsolvable problem elementary number theory 
american journal mathematics 
winskel 
events security protocols 
proc 
th acm conference computer communications security 
dal 
mobile processes commented bibliography 
editors 
modelling verification parallel processes lncs 
dennis 
data flow computation 
broy editor 
control flow data flow concepts distributed programming 
springerverlag 
fiore cattani winskel 
weak bisimulation open maps 
proc 
lics 
editor 
proc 
eighth international symposium circuits systems 
ieee 
bibliography 
girard 
linear logic 
theoretical computer science 
gordon 
bisimilarity theory functional programming 
proc 
mfps entcs 
gray 
fibred categories 
proc 
la jolla conference categorical algebra springer verlag 
hennessy plotkin 
full abstraction simple parallel programming language 
proc 
mfcs lncs 
hennessy milner 
algebraic laws nondeterminism concurrency 
journal acm 
hennessy 
fully denotational model higher order processes 
information computation 
hildebrandt panangaden winskel 
relational model non deterministic dataflow 
proc 
concur lncs 
hildebrandt 
fully presheaf semantics sccs finite delay 
proc 
ctcs entcs 
hildebrandt 
categorical models concurrency independence fairness dataflow 
ph dissertation university aarhus 
brics dissertation series ds 
hoare 
communicating sequential processes 
communications acm 
hoare 
model communicating sequential processes 
technical monograph prg university oxford computing laboratory 
howe 
proving congruence bisimulation functional programming languages 
information computation 
hyland 
ong 
full abstraction pcf parts ii iii 
information computation 
jacobs 
semantics weakening contraction 
annals pure applied logic 
joyal moerdijk 
completeness theorem open maps 
annals pure applied logic 
joyal nielsen winskel 
bisimulation open maps 
information computation 
bibliography kahn 
semantics simple language parallel programming 
information processing 
kelly 
basic concepts enriched category theory 
london math 
soc 
lecture note series cambridge university press 
kleene 
definability recursiveness 
duke mathematical journal 
lambek scott 
higher order categorical logic 
cambridge university press 
lamport 
time clocks ordering events distributed system 
communications acm 
larsen winskel 
information systems solve recursive domain equations ectively 
proc 
semantics data types lncs 
levy 
basic set theory 
springer verlag 
mac lane moerdijk 
sheaves geometry logic 
springer verlag 
mac lane 
categories working mathematician 
second edition springer 
mazurkiewicz 
basic notions trace theory 
proc 
rex summer school lncs 
mccusker 
fully relational model syntactic control interference 
proc 
csl lncs 


categorical models linear logic revisited 
submitted theoretical computer science 

bisimulation proof methods mobile ambients 
proc 
icalp lncs 
milner 
calculus communicating systems 
lncs springerverlag 
milner 
communication concurrency 
prentice hall 
milner parrow walker 
calculus mobile processes parts ii 
information computation 
milner tofte harper macqueen 
definition standard ml revised 
mit press 
bibliography milner 
communicating mobile systems calculus 
cambridge university press 
morris 
lambda calculus models programming languages 
phd thesis mit 
nielsen plotkin winskel 
petri nets event structures domains part theoretical computer science 
nygaard 
operational understanding presheaf models 
progress report university aarhus 
available www daimi au dk nygaard 
nygaard winskel 
linearity process languages 
proc 
lics 
nygaard winskel 
hopla higher order process language 
proc 
concur lncs 
nygaard winskel 
full abstraction hopla 
proc 
concur lncs 
nygaard winskel 
domain theory concurrency 
appear theoretical computer science special issue domain theory 
park 
concurrency automata infinite sequences 
proc 
theoretical computer science th gi conference lncs 
peled pratt holzmann editors 
proc 
partial order methods verification 
dimacs american mathematical society 
pierce 
basic category theory computer scientists 
mit press 
pierce 
types programming languages 
mit press 
pitts 
relational properties domains 
information computation 
plotkin 
powerdomain construction 
siam journal computing 
plotkin 
lcf considered programming language 
theoretical computer science 
bibliography plotkin 
structural approach operational semantics 
lecture notes daimi fn department computer science university aarhus 
wood 

journal pure applied algebra 
sangiorgi 
expressing mobility process algebra 
order higher order paradigms 
phd thesis university edinburgh 
sangiorgi 
bisimulation higher order process calculi 
information computation 
sangiorgi walker 
calculus 
theory mobile processes 
cambridge university press 
scott 
outline mathematical theory computation 
proc 
th annual princeton conference information sciences systems 
scott 
domains denotational semantics 
proc 
icalp lncs 
scott strachey 
mathematical semantics computer languages 
proc 
symposium computers automata microwave research institute symposia series vol 

seely 
linear logic autonomous categories cofree coalgebras 
proc 
categories computer science logic contemporary mathematics 
shields 
concurrent machines 
computer journal 
strachey 
fundamental concepts programming languages 
higher order logic symbolic computation 
taylor 
practical foundations mathematics 
cambridge university press 
javier thayer herzog guttman 
strand spaces security protocol correct 
proc 
ieee symposium security privacy 
thomsen 
calculus higher order communicating systems 
proc 
popl 
turing 
computability definability 
journal symbolic logic 
bibliography van glabbeek 
linear time branching time spectrum 
proc 
concur lncs 
winskel 
events computation 
phd thesis university edinburgh 
available www cl cam ac uk gw 
winskel 
powerdomains modality 
theoretical computer science 
winskel 
event structures 

winskel 
event structures 
proc 
rex summer school lncs 
winskel 
formal semantics programming languages 

mit press 
winskel nielsen 
models concurrency 
abramsky editors 
handbook logic computer science 
volume 
semantic modelling 
oxford university press 
winskel 
presheaf semantics value passing processes 
proc 
concur lncs 
winskel 
linear metalanguage concurrency 
proc 
amast lncs 
winskel 
presheaf semantics mobile ambients 
manuscript 
winskel 
event structures presheaves representation theorems 
proc 
concur lncs 
winskel 
manuscript 
brics dissertation series publications ds nygaard 
domain theory concurrency 
november 
phd thesis 
xiii pp 
ds paulo oliva 
proof mining subsystems analysis 
september 
phd thesis 
xii pp 
ds 
cryptographic protocols root extracting 
august 
phd thesis 
xii pp 
ds serge fehr 
secure multi player protocols fundamentals generality efficiency 
august 
phd thesis 
xii pp 
ds mads jurik 
extensions paillier cryptosystem applications protocols 
august 
phd thesis 
xii pp 
ds jesper nielsen 
protocol security cryptographic model 
august 
phd thesis 
xiv pp 
ds mario jos 
formal calculus categories 
june 
phd thesis 
xiv 
ds 
models evolutionary algorithms applications system identification control optimization 
june 
phd thesis 
xiv pp 
ds giuseppe 
applying formal methods programming language design implementation 
june 
phd thesis 
xvi 
ds federico 
language semantics methods security protocols 
may 
phd thesis 
xii 
ds ji 
decidability complexity issues infinite state processes 

phd thesis 
xii pp 
ds frank valencia 
temporal concurrent constraint programming 
february 
phd thesis 
xvii 
ds claus brabrand 
domain specific languages interactive web services 
january 
phd thesis 
xiv pp 
ds pagh 
hashing randomness dictionaries 
october 
phd thesis 
pp 
ds anders mller 
program verification monadic secondorder logic languages web service development 
september 
phd thesis 
xvi pp 
