prix indexing querying xml prufer sequences praveen rao moon cs arizona edu technical report propose new way indexing xml documents processing twig patterns xml database 
xml document database transformed sequence labels prufer method constructs correspondence trees sequences 
query processing twig pattern transformed prufer sequence 
performing subsequence matching set sequences database performing series refinement phases developed find occurrences twig pattern database 
approach allows holistic processing twig pattern breaking twig root leaf paths processing paths individually 
furthermore show correct answers false dismissals false alarms 
experimental results demonstrate performance benefits proposed techniques 
july department computer science university arizona tucson az sponsored part national science foundation career award iis nsf 
iis research infrastructure program eia 
supported prop fund state arizona korea science engineering foundation 
authors assume responsibility contents 
extensible markup language xml emerged new standard information representation exchange internet problem storing indexing querying xml documents major issues database research 
relationships elements xml document defined nested structures xml documents modeled trees nodes labeled tags queries formulated retrieve documents specifying structures values 
xml query languages xpath xquery structures xml documents typically expressed linear paths twig patterns values xml elements part selection predicates 
example path expression xpath syntax book author name john title qualifies xml documents specifying twig pattern composed elements book author name title xml document value selection predicate name john 
queries path expression major foci research indexing querying xml documents 
past years main thrusts research activities processing path join queries retrieving xml data approaches structural index numbering schemes 
approaches structural index facilitate traversing hierarchy xml documents referencing structural information documents dataguide representative objects index approximate path summary index :10.1.1.41.3258
structural indexes help reduce search space processing path twig queries 
class approaches form numbering scheme encodes element positional information hierarchy xml document belongs 
numbering schemes reported literature designed tree traversal order pre postorder extended preorder textual positions start tags containment property absolute region coordinate :10.1.1.21.8854
numbering scheme embedded labeled trees xml documents structural relationship ancestor descendant pair elements determined quickly traversing entire tree 
join algorithms developed take advantage extraordinary opportunity ciently process path twig queries :10.1.1.21.8854
particular shown twigstack algorithms optimal processing path twig queries processing cost linearly proportional sum input data query results 
previous approaches numbering schemes process twig query processing root leaf paths twig separately merging results individual paths 
ort optimize twig query processing breaking twig merging results propose new way indexing xml documents finding twig patterns xml database 
developed system called prix prufer sequences indexing xml indexing xml documents processing twig queries 
prix system xml document database transformed sequence labels prufer method constructs correspondence trees sequences 
query processing twig pattern transformed prufer sequence 
performing subsequence matching indexed sequences database performing series filtering refinement phases developed find occurrences twig pattern database 
developed independently di ers considerably new indexing method called vist converts trees sequences 
main contributions summarized follows 
propose new idea transforming xml documents sequences prufer method 
show twig matches performing subsequence match set sequences performing series refinement phases 
show approach returns correct answers false alarms false dismissals 
approach allows holistic processing twig queries breaking twig root leaf paths processing individually 
additionally tree sequence transformation guarantees worst case bound index size linear total number nodes xml document trees 
prix pronounced french word grand prix 
article author author title year jack jill xml pq pq pq pq pq pq pr pr doc doc query xml document false alarms vist sample xml document illustration false alarms vist developed ective optimizations speed subsequence match phase query processing 
rest organized follows 
section discuss background motivations 
section architectural overview prix system 
section section provide necessary theoretical background describe implementation issues prix system 
section experimental results 
lastly section summarizes contributions 
background motivations xml documents modeled ordered labeled trees shown 
node tree corresponds element value 
values represented character data cdata pcdata occur leaf nodes 
tree edges represent relationship elements element value 
element list attribute value pairs associated 
attribute usually represented subelement element 
special distinction elements attributes subsequent discussions 
research ort focused indexing querying xml documents 
finding occurrences query pattern xml documents core operations xml databases 
briefly describe contributions xml pattern matching twigstack vist 
discuss drawbacks motivate proposed approach 
twigstack algorithms bruno proposed optimal xml pattern matching algorithms 
stack algorithms process input streams element instances tag appears query twig 
twigstack algorithms operate positional representation element instances find twig matches 
variant twigstack algorithm denoted uses xb trees speed processing input lists long 
xb trees useful skipping sections input lists missing matches 
limitations 
ectiveness skipping data depends distribution matches input lists 
matches scattered dataset algorithm drills lower regions tree including leaves order avoid missing matches 
drawback twigstack algorithms su ers suboptimality parent child relationships query twig 
algorithm produce partial match path twig combined partial match path twig 
example consider query twig nodes branches containing parent child relationships 
algorithm match pattern data common ancestor parent 
match discarded merge post processing step algorithm 
cost post processing may trivial 
vist wang proposed new method called vist transforms xml data trees twig queries structure encoded sequences 
structure encoded sequence dimensional sequence symbol prefix pairs pn represents node xml document tree represents path root node node vist performs subsequence matching structure encoded sequences find twig patterns xml documents 
sequences stored trie 
imminent drawbacks tree transformation vist worst case storage requirement tree index named higher linear total number elements xml documents 
example consider unary tree nodes 
case total size structure encoded sequence 
index requires space store symbol prefix keys 
drawback vist query processing strategy may result false alarms 
illustrates case 
structure encoded sequence query twig subsequence structure encoded sequence doc doc twig pattern occurs doc match detected doc false alarm 
motivations key motivations develop method allows holistic processing twig queries breaking twig root leaf paths processing individually construct tree sequence transformation total storage requirement linear total number tree nodes transform trees sequences index similarity documents taken advantage reduce total amount data needs searched query processing 
overview prix approach section prufer method constructs correspondence trees sequences describe prufer sequences indexing xml data processing twig queries prix system 
architectural overview prix system 
prufer sequences labeled trees prufer proposed method constructed correspondence labeled tree sequence removing nodes tree time 
algorithm construct sequence tree tn nodes labeled works follows 
tn delete leaf smallest label form smaller tree tn denote label node parent deleted node 
repeat process tn determine parent node deleted continue nodes joined edge left 
sequence called prufer sequence tree tn sequence original tree tn reconstructed 
length prufer sequence tree tn 
prix approach construct prufer sequence length tn continuing deletion nodes till node left 
correspondence preserved 
modified construction simplifies proofs lemmas theorems section 
indexing transforming xml documents prufer sequences discussions follow xml document represented labeled tree node associated element tag number 
example root element xml document tag number pair 
numbering scheme label xml document tree long associates node tree unique number total number nodes 
guarantees mapping tree sequence 
prix system loss generality chosen postorder uniquely number tree nodes continue discussions postorder numbering scheme 
tree nodes labeled unique postorder numbers prufer sequence constructed xml document node removal method described section 
sequence consists entirely postorder numbers called nps numbered prufer sequence 
number nps replaced corresponding tag new sequence consists xml tags constructed 
call sequence lps labeled prufer sequence 
set stored database unique occasionally refer nps postorder number sequence lps tree tree disconnected connected xml document tree query twig query engine twig matches documents xml labeled prufer sequences indexing engine list xml tags construction prufer sequence database implemented sax parser trees numbered prufer sequences leaves twig query prufer sequence construction sequence leaves numbered prufer sequence virtual trie index sequences subsequences filtering post processing refinement numbered prufer sequences leaves matching architectural overview prix document identifiers 
order support fast subsequence matching set indexed string indexing structure 
index sequences tree similar way proposed vist approach 
example tree lps nps 
processing twig queries prufer sequences query twig transformed prufer sequence xml documents 
non matches filtered subsequence matching indexed sequences twig matches applying series refinement strategies 
filtering refinement phases described section 
shows architectural overview indexing query processing units prix described section section 
high level overview system shall move explain symbol description query twig collection xml documents set labeled prufer sequences set subsequences identical subset represent trees connected lps labeled prufer sequence tree nps numbered prufer sequence tree label returns label associated vertex number returns number associated vertex table notations process finding twig matches 
finding twig matches simplify presentation concepts section shall notations listed table 
formally problem finding twig matches stated follows collection xml documents query twig report occurrences twig 
restrict handling twig equality predicates 
initially deal problem finding occurrences twig wildcards 
section explain query wildcards processed 
addition address problem finding ordered twig matches 
section explain unordered twig matches 
finding twig matches prix system involves series filtering refinement phases filtering subsequence matching refinement connectedness refinement structure refinement leaf nodes 
filtering subsequence matching filtering phase system involves subsequence matching 
classical definition subsequence stated follows 
definition subsequence string obtained deleting zero symbols string 
phase query twig find subsequences set match lps 
shall discuss significance subsequence matching lemma theorem 
lemma tree nodes numbered postorder node deleted th time prufer sequence construction node numbered proof 
prove theorem induction number nodes tree 
construction prufer sequences time leaf node smallest label deleted tree give smaller tree 
tn tree obtained node deletions 
simplicity refer node numbered node denote node deleted th time prufer sequence construction node 
basis induction true 
node leaf deleted 
true 
node parent node leaf node deleted 
node leaf tn case node deleted node 
induction hypothesis true node deleted th time 
nodes assigned consecutive postorder numbers prove true 
possible scenarios nodes numbered postorder refer 
node child node node leaf th deletion nodes 
induction hypothesis nodes deleted 
smallest leaf node tn deleted 
true 
node leaf tn induction hypothesis node smallest leaf tn true 
proved lemma 
result nodes tree smaller postorder number node deleted node prufer sequence construction 
addition th element nps denotes postorder number parent node subsequent discussions shall frequently notations number 
label 
described table 
note node numbered numbering scheme postorder 
lemma state theorem 
theorem tree subgraph tree lps subsequence lps 
proof 
trees numbered postorder 
tree nodes order deletion nodes prufer sequence construction tree subgraph set nodes deleted prufer sequence construction tree order nodes prove deleted tree lemma true pair nodes number number 
subgraph pair nodes number number nodes number number 
nodes satisfy relation number number tree deleted tree lemma 
label label lps subsequence lps 
theorem evident finding subsequence matches lps guaranteed false dismissals 
example consider trees 
tree lps nps 
tree lps nps 
labeled subgraph lps matches subsequence lps positions 
postorder number sequence subsequence 
note may subsequence lps matches lps 
refinement connectedness subsequences matched filtering phase examined property connectedness 
subsequences labels subsequence correspond nodes connected representing tree tree 
denote set subsequences satisfy connectedness property formally state necessary condition subsequence satisfy predicate theorem tree nps subsequence lps postorder number sequence tree nodes corresponding labels connected representing tree element max 
proof 
subgraph nodes correspond labels node number number 
goal show represents tree connected acyclic graph 
define edge set nodes adjacent adjacent nodes numbered postorder tree node highest number represent root call node nodes definitely non root nodes 
call vertices lemma conclude occurrence node postorder number say occurs th position nps number th position nps postorder number parent prufer sequence construction deletion child smallest leaf node 
node occurrence number occurs th position node number occurs th position node parent edge condition true node exists path node node connected acyclic subgraph tree represents tree 
intuition theorem follows 
index occurrence postorder number nps 
occurrence result deletion child prufer sequence construction 
child deleted lemma node 
number th index nps say postorder number parent node followed indicates edge node node example consider subsequences sa sb lps tree 
sa postorder number sequence na 
sb postorder number sequence nb 
nps 
nodes represented labels sa form disconnected graph shown 
case max na na na 
occurrence postorder number na nd position index aj 
na followed na 
theorem satisfied 
nodes represented elements sb represent tree shown theorem satisfied 
shall refer sequences satisfy theorem tree sequences 
refinement structure tree sequences obtained previous refinement phase refined query twig structure 
phase determine structure tree represented tree sequence matches query twig structure 
noted lps tree contains non leaf node labels 
addition lps nps label postorder number leaf node stored database 
lps tree contains non leaf node labels filtering subsequence matching followed refinement connectedness structure find twig matches data tree tree structure query tree non leaf node labels match non leaf node labels query twig 
edge call matches partial twig matches 
find complete twig match leaf node labels partially matched twig data matched leaf node labels query twig 
explained section 
notion gaps tree nodes delve details refinement structure shall introduce notion gap tree nodes gap consistency tree sequences 
definition gap nodes tree defined di erence postorder numbers nodes gap tree nodes computed nps tree 
definition tree sequence said gap consistent tree sequence 
length 
pair adjacent elements corresponding adjacent elements gaps gb sign ga gb 
note gap consistency symmetric relation 
example consider tree 
lps nps 
subsequence lps ns postorder number sequence ns postorder number sequence gap consistent gap st pair elements st pair elements nd pair elements nd pair elements rd pair elements rd pair elements 
intuitively gap nodes data tree gives idea nodes occur postorder traversal nodes 
similar case nodes query twig 
nodes traversed query twig compared data twig indicates structural di erence data query twig 
concept forms basis theorem states necessary su cient condition partial twig match 
key observation theorem number times number occurs nps indicates number child nodes tree positions occurs nps depend subtrees rooted node formalize observation defining property called frequency consistency 
definition tree sequences frequency consistent 
length 
na nb postorder number sequences respectively 
ai th element na nb respectively 
ai occurs times na positions occurs times nb positions 
kt kq tree tree tree tree gap nodes note frequency consistency equivalence relation 
example example sequences frequency consistent 
st element ns occurs position 
st element ns occurs position 
nd element ns occurs positions 
nd element ns occurs positions 
similar case remaining elements ns ns state necessary su cient condition partial twig match 
proof omitted due lack space 
theorem tree partial twig match tree 
lps matches subsequence lps tree sequence 
lps gap consistent frequency consistent subsequence proof 
suppose partial match tree matches tree subgraph leaf node labels may match leaf node labels lemma lps subsequence lps 
set nodes deleted relative order prufer sequence construction postorder numbering tree respectively 
furthermore structure matching non leaf nodes number child nodes 
lps matches subsequence lps represents tree tree sequence postorder number sequence nps frequency consistent 
goal show lps gap consistent consider nodes tree label label adjacent elements lps label occurs label 
qq postorder numbers nodes tree note nodes internal nodes nodes nodes match respectively 
label label adjacent rt st postorder numbers nodes tree denote number nodes tree 
gap gap possible scenarios nodes case child child refer 
subtree rooted nodes postorder number rt st subtree rooted nodes postorder number qq know matches tree subgraph virtue postorder numbering st rt gq qq 
sign gq 
case descendant descendant refer 
mq number nodes postorder number nq qq nq number nodes postorder number st rt virtue postorder numbering rt st gq qq mq 
nodes tree nodes tree nodes tree nodes tree possible scenarios matches tree subgraph mq sign gq 
case nodes label label number number nodes label label number number 
trivial case 
zero 
lps matches subsequence lps tree sequence 
lps gap consistent frequency consistent tree subgraph represents lps 
proof lps gap consistent lps frequency consistent 
know lps lps identical 
goal show nps nps identical 
shall contradiction prove 
trees nodes numbered postorder 
nq nps nps assume largest index nq 
index nq number nodes trees nq nq refer node numbered node lemma tree parent node numbered postorder number parent node postorder number similarly tree parent node numbered postorder number parent node postorder number consider relationships case 
situation occur lps lps gap consistent case 
gap zero 
lps gap consistent lps gap consistent true 
assumption false 
case refer 
loss generality assume numbered postorder 
tree node parent numbered node parent numbered contradicts fact numbered postorder node descendant node assumption false 
similar argument swapping roles show assumption false 
assumption false true 
case refer 
loss generality assume scenario shown nodes 
dotted line indicates ancestor descendant relationship nodes 
node parent node 
node node child postorder number greater node child node child result lemma nq know lps frequency consistent means th th due postorder numbering root tree highest number child node deleted prufer sequence construction 
lps nps nps lps identical gap consistent consistent frequency subsequence lps postorder number sequence data query sequences element postorder number sequence equal 
lps frequency consistent th th element nq equal 
implies nq contradicts original assumption largest index nq assumption false 
similar argument show assumption false 
true 
cases conclude original assumption largest index nq false 
nps nps identical 
prufer sequence corresponds unique labeled tree correspondence matches labels leaf nodes label may match 
partial match di erent relationships data query sequences described section illustrated 
consider tree xml document subgraph tree query twig 
dark regions lps nps correspond deletion nodes prufer sequence construction root 
dark regions lps nps form sequences respectively 
lemmas theorems described section section section conclude lps identical nps gap consistent nps frequency consistent 
refinement matching leaf nodes final refinement phase leaf node labels query twig tested leaf node labels partially matched data find complete twig matches 
example leaf nodes tree stored database 
tree query twig 
lps matches subsequence lps positions 
postorder number sequence 
lps gap consistent frequency consistent match leaf follows 
leaf postorder number parent node matches node numbered rd element data tree 
node numbered occurs th position rd element lps may leaf 
leaf node list similarly match leaf parent matches node st element position nps 
child node node matches leaf labels may match partial twig match 
nodes number leaf list search lps nps find pair nd position lps nps refinement phase eliminated special treatment leaf nodes query twig data trees 
key idea leaf nodes query twig data trees appear nodes examined subsequence matching refinement connectedness structure phases 
section explain process detail 
processing wildcards shall explain processing wildcards example 
example find query pattern tree 
transformed prufer sequences ignoring wildcards 
result lps nps 
wild card query handled current method allows finding occurrences query tree data tree 
process wildcard middle query simple modification refinement connectedness phase 
lps matches subsequence positions lps 
postorder number sequence 
theorem subsequence discarded occurrence followed parent node numbered 
avoid check occurrence node lead node follows series edges recall th element nps postorder number parent node tree lemma 
nps 
recursively check 
example find match 
checking nodes examine 
processing wildcard simply test match 
subsequences pass test move phase 
implementation issues prix system theoretical background section shall move explain implementation aspects prix system 
building prufer sequences prix system prufer sequences constructed xml document trees nodes numbered postorder method described section 
proposed tree sequence transformation causes nodes lower levels tree deleted 
results bottom transformation tree 
shall show experiments bottom transformation useful process query ciently 
indexing sequences trees set labeled prufer sequences xml documents indexed order support fast subsequence matching query processing 
maintaining memory index sequences trie unsuitable index size grows linearly total length sequences 
essence build cient disk index 
fact prufer sequences indexed technique string indexing matching 
current version prix system index labeled prufer sequences trees similar way wang built virtual trie trees 
virtual trie shall briefly explain process indexing sequences virtual trie 
consider trie set sequences 
node trie labeled 
example root node labeled range max int 
child nodes root labeled subranges open interval max int subranges disjoint completely contained parent range 
property recursively satisfied non leaf node trie 
essence provide positional representation nodes trie 
addition node unique identifier 
order quickly find descendants node trie shall containment property 
la ra positional representation node lb rb positional representation node node descendant node trie la lb rb ra performing range query interval la ra set node ids trie obtain descendants node :10.1.1.21.8854
en en positional representation occurrences symbol trie 
prix system symbol build tree indexes positional representation occurrence symbol trie key 
shall refer index trie symbol index 
addition store separate tree list document identifiers sequences node id trie key 
index called docid index 
building separate trie symbol index distinct value cdata combine single index 
due presence large number distinct values xml documents technique helps considerably reducing total number indexes prix 
note su cient store virtual trie 
su xes need indexed subsequences performing range queries trie symbol indexes described section 
vist proposed dynamic labeling scheme assign number ranges building physical trie name virtual trie set sequences 
dynamic labeling scheme su ers scope underflows long sequences large alphabet sizes di cult implement 
order reduce scope underflows pre allocate number ranges small subset nodes trie 
remaining nodes assigned ranges dynamic labeling scheme 
order build memory trie prefixes sequences length small number compared actual length sequences 
node memory trie allocated number range frequency length sequences prefixes share node 
space complexity size trie grows linearly total length sequences stored 
prix system length prufer sequence linear number nodes edges tree 
index size linear total number tree nodes vist guarantee linear worst case bound index size 
refer section 
filtering subsequence matching sk sequence length denote lps query twig process finding occurrences subsequence trie symbol indexes shown algorithm 
algorithm invoked max int 
range query open interval performed tq si trie symbol index si 
line 
node id returned range query line subsequence documents closed interval fetched docid index line 
positional representation node id 
case 

recursively invoked element sequence range 
line position match th element level node trie stored solutions range query line ids nodes descendants nodes si virtual trie 
line algorithm outputs document tree identifier list contains positions lps subsequence match 
note simple optimizations done subsequence matching 
example range search return answers skip range searches ranges contained range 
noted subsequence matching phase bound 
total number range queries issued phase depends length sequence algorithm 
goal reduce number paths explored virtual trie find subsequences 
experiments observed prix virtue bottom tree transformation performed fewer range queries vist process query patterns 
node upper levels query twig high selectivity nodes twig low selectivities performing subsequence match left right expensive 
label node appear middle propose solution incorporate prix 
sj represent label build trie say indexes data trees left right 
build trie say indexes data trees reverse order right left 
order find subsequences algorithm filtering algorithm input qs query sequence index qr range output document tree identifier denotes positions subsequence match procedure tq si foreach level output invoke 
sequence sj sk 
invoke 
sequence sj 
partial results combined determine instances subsequence data 
query optimizer node selectivity information determine node avoid low selectivity nodes searched subsequence matching reducing total cost 
refinement phases set ordered pairs document identifier denotes positions subsequence match output algorithm examined refinement phases 
steps refinement phases shown algorithm 
nps set leaf nodes read database passed input algorithm 
input subsequence refined connectedness theorem lines 
note algorithm handle wildcards easily extended mentioned section modifying line 
subsequence refined structure testing gap consistency definition lines 
subsequence tested frequency consistency definition lines 
algorithm matches leaf nodes query twig lines 
line report twig match 
optimizations query performance prix improved simple extensions 
subsequence matching phase bound dictates query performance queries high selectivities 
section shall introduce interesting optimizations speed subsequence matching 
optimization propose construction extended prufer sequences 
second optimization propose upper bounding distance metric subsequence matching 
extended prufer sequences prufer sequence tree described section contains labels non leaf nodes 
call sequence regular prufer sequence 
tree extended adding virtual child node leaf nodes 
prufer sequence extended tree contains labels nodes original tree 
shall refer new sequence extended prufer sequence 
case xml value nodes strings character data xml document tree extended adding virtual child nodes 
similarly query extended transforming sequences 
shall refer index regular prufer sequences index extended prufer sequences 
indexing extended prufer sequences useful processing twig queries values 
queries value nodes usually high selectivities extended prufer sequences provide higher pruning power regular prufer sequences subsequence matching 
result subsequence matching fewer root leaf paths explored virtual trie algorithm refinement algorithms input nd nq ld lq nd nps tree nq nps query twig ld list leaves tree lq list leaves positions subsequence match lps output report twig match procedure nd nq ld lq test connectedness refinement connectedness maxn max nd nd nd nd maxn nd nd nd return test gap consistency refinement structure nd nd nq nq return return return test frequency consistency refinement structure nq nq nd nd return match leaves refinement matching leaves foreach lq lq lps nps return report twig match return compared virtual trie queries values 
twig queries values indexing regular prufer sequences recommended 
note extended prufer sequences longer ufer sequences increase length proportional number leaf nodes original tree 
prix system coexist 
query optimizer choose indexes presence absence values twig queries 
easy query optimizer detect values queries sax parsers separate callback routines values attributes elements 
upper bounding distance metric order speed subsequence matching reduce number range queries performed algorithm missing solutions 
achieve pruning node ids line algorithm inferring subsequence match node descendant virtual trie part final solution 
regard tree lps nps tree lps nps xml document trees computing developed upper bounding distance metric property prufer sequences 
collection ordered labeled trees xml document trees node label define distance metric pair follows 
definition maximum postorder gap node label defined maximum di erence postorder numbers child node labeled 
example di erence postorder numbers child node label tree tree 
occurrence label trees child 
shall explain usefulness distance metric subsequence matching 
recall lemma showed th node deleted prufer sequence construction node numbered consider tree 
deletion node numbered child node corresponds lps 
deletion node child node numbered corresponds second lps 
postorder gap child node denotes far apart occurrence node label 
recall occurrence node label followed parent node label 
consider query twig root node labeled nodes second child respectively 
nodes child 
regular prufer sequence query twig 
cb prefix child query sequence matches lps positions 
similarly matches lps 
refer pair pair subsequence cb 
helps discarding certain subsequences definitely part final solution 
prune cb subsequences condition occurs positions lps definitely part final solution parent cb subsequences lps pairs may final solution 
matching cb prufer sequence label matched discard subsequences bd parent query 
note child query twig 
twig match data trees occurs occurrence lps trees 
occurs positions lps forms subsequence bd definitely part final solution 
example subsequence bd lps pair fails satisfy requirement 
subsequence cbd positions lps discarded missing solutions 
summarizes purpose metric 
query twig set labels adjacent lps occurs 
node labeled child node labeled subsequence ab pair satisfy relation result twig match 
algorithm filtering algorithm upper bounding distance metric input qs query sequence index qr range output document tree identifier denotes positions subsequence match procedure tq si foreach level child goto discard current ancestor goto discard current output 
node labeled ancestor node labeled subsequence ab pair satisfy relation result twig match 
upper bounding distance metric described section helps pruning search space subsequence matching 
easily extend algorithm incorporate upper bounding distance metric computing line testing appropriate condition label extended algorithm called described algorithm 
algorithm invoked max int 
xml computed unique tag name including values 
value nodes leaf nodes xml document tree 
note metric defined definition coarse grained 
granularity improved maintaining occurrence symbol virtual trie avoiding refinement matching leaf nodes explain final refinement phase matching leaf nodes avoided special leaf nodes query twig 
key idea leaf nodes query twig appear lps nodes examined filtering refinement phases 
twig queries value nodes cdata pcdata prix uses extended prufer sequences 
value nodes leaf nodes original query twig extending twig adding virtual leaf nodes examined subsequence matching refinement phases 
virtual leaf nodes query twig match virtual leaf nodes data trees value nodes extended consistent way data trees query 
result final refinement leaf nodes phase need performed 
element nodes element attribute tags leaf nodes original query twig 
extend nodes original query twig virtual leaf nodes 
example find occurrences query pattern tree shown 
lps nps 
lps query pattern extending leaf node recall number times number occurs nps denotes number children node example label due node space requirement linear total length sequences 
positions lps nps results twig matches refinement structure phase 
matches redundant 
number redundant matches proportional number child nodes node labeled example discard redundant matches subsequence matching choosing subsequence label corresponding occurrence node nps 
note solutions 
element nodes leaf nodes original query twig parent child edges assign upper bounding distance metric element nodes 
algorithm discards redundant matches modifications 
element nodes ancestor descendant edges discard redundant matches refinement phases 
ordered unordered twig matches prix prufer sequence constructed numbering query twig postorder find ordered twig matches 
order find unordered matches prufer sequence di erent arrangements branches query twig constructed tested twig matches 
number twig branches query usually small small number configurations arrangements need tested 
process implemented ciently identifying common prefixes sequences di erent twig configurations order avoid repeating subsequence matching common prefixes sequences 
configurations may yield solutions 
example shall explain twig configurations quickly eliminated 
example consider query twig article key tr title xml year 
attribute tag name key considered subelement article root leaf paths branches 
shall construct extended prufer sequence query twig 
twig arrangement value tag xml appears value tag lps arrangement value tag appears tag xml lps 
tag appears tag xml data sequences eliminate arrangement ensuring xml descendant virtual trie 
check done faster performing complete subsequence match 
case root leaf path resulting attribute tag key need rearrange paths 
time indexing xml documents treat attribute tag key child article 
query twig transformed similarly treating key child article 
query twig arrangement tested xml appears lps simplicity experimented queries query twig arrangement data trees 
description prix architecture section describe di erent components prix architecture 
document parsing xml documents parsed event driven sax parser 
output sax parser set start tags element attribute value xml documents 
tags output order encountered parsing 
sax parser output fed indexing engine 
indexing engine elements values attributes hashed integers ine cient store directly character strings 
indexing engine constructs prufer sequences xml document tree reading sax parser output 
algorithm constructing prufer sequences described section 
algorithm uses stack number tree nodes postorder starting 
postorder numbers unique labels tree sequence transformation 
sequences labeled prufer sequence lps numbered prufer sequence nps constructed 
element lps corresponds hashed value element attribute value 
query workload indexing engine build regular extended prufer sequences index 
dataset name size mbytes elements attributes max depth sequences dblp swissprot treebank table datasets order support fast subsequence matching lps indexed trie 
nodes trie assigned number ranges support containment queries 
note su xes lps need stored subsequences algorithm 
virtual trie built trees 
unique label lps tree built store number ranges instances label trie 
nps leaf nodes stored database flat files 
querying engine xpath query parsed lps nps constructed 
subsequences match query lps xml data searching virtual trie 
document identifiers data trees matching subsequence determined 
nature query querying engine choose subsequence match phase 
postprocessing performed matching subsequences discard non matches 
post processing step involves phases refinement connectedness refinement structure refinement leaf nodes required 
nps corresponding matching document identifiers fetched database 
nps query refinement connectedness structure performed 
refinement phases occurrences query twig output 
experimental results experiments compared query performance prix vist twigstack 
implemented algorithms prix vist twigstack tree implementation gist indexes 
vist symbol prefix pairs structure encoded sequences directly stored tree 
experimental setup ran experiments ghz pentium processor mb ram running solaris 
gb eide disk drive store data indexes 
code compiled gnu compiler version 
direct feature available solaris enabled avoid operating system cache ects 
experiments bu er pool size fixed pages 
page size 
prix vist byte number ranges label nodes virtual trie 
twigstack byte number ranges label nodes xml document trees 
data sets experimented datasets shown table 
datasets obtained university washington xml repository 
chose datasets di erent characteristic 
document trees dblp dataset similarity structure shallow 
document trees swissprot dataset bushy shallow 
document trees treebank dataset skinny recursion element names 
table provides additional information maximum depth number elements datasets 
constructed prufer sequences structure encoded sequences collection xml document trees dataset 
table shows number sequences constructed dataset 
queries xpath queries listed table tested experiments 
queries di erent characteristics terms selectivity presence values twig structure 
table shows number twig query dataset twig matches inproceedings author jim gray year dblp www editor url dblp title text semantic analysis patterns dblp entry keyword swissprot entry ref author mueller author keller swissprot entry org author swissprot np sym treebank np rbr jjr pp treebank np pp np nns nn nn treebank table xpath queries vist prix sec time elapsed elapsed time xpath queries table occurrences query 
treebank dataset values encrypted chose queries values character data 
performance analysis summarize performance results total time elapsed queries listed table 
discuss benefits prix vist 
prix vs vist section shall compare performance prix vist 
tested queries dblp dataset 
query twig query nodes branches 
query twig query nodes branches 
query single path query nodes 
values values 
prix performed significantly better vist queries comparable performance query prix vist total time disk io total time disk io secs pages secs pages secs pages secs pages table dblp prix vs vist query prix vist total time disk io total time disk io secs pages secs pages secs pages secs pages table swissprot prix vs vist query prix vist total time disk io total time disk io secs pages secs pages secs pages secs pages table treebank prix vs vist query table shows total time taken physical pages read disk process queries performance trend query similar refer 
noted presence values vist structure encoded sequences reduces sharing root paths trie 
worst case sequence cause root leaf path trie 
presence root node prefix symbol prefix pair structure encoded sequences reduces sharing trie 
similarly prix presence values extended prufer sequences reduces sharing root leaf paths trie 
bottom transformation query twig data prix plays crucial role reducing query processing time 
selectivities value nodes usually higher element nodes labels lps query twig may occur frequently virtual trie compared labels sequence 
cases paths virtual trie need examined find subsequences 
implies smaller number range queries processed algorithm 
contrast vist top transformation twig resulted large number nodes paths virtual trie examined subsequence matching commonly occurring tag names 
example tag names author title su ered behavior 
prix process queries clearly outperformed vist 
vist processed query comparably 
occurrences tag name www dblp dataset editor descendants trie 
prix processing comparable performance 
swissprot dataset prix clearly outperformed vist queries query simple path query nodes twig query nodes branches 
twig query nodes branches 
queries values 
table shows performance results queries performance trend query similar refer 
mentioned earlier vist top transformation twig deteriorated query processing considerably 
tag names ref org resulted range queries subsequence matching 
increased disk slowed query processing 
hand prix process processed ciently 
demonstrates advantage bottom transformation prix 
drawback vist point processing queries wildcards datasets nesting tag names 
tested queries treebank dataset 
queries values 
query single path query nodes query twig branches nodes 
query branches nodes 
table shows performance results queries performance trend query similar refer 
vist processed wildcards way 
index searched symbol prefix keys 
key symbol matched 
tag name occurred di erent depths treebank dataset addition occurring frequently dataset 
resulted symbol prefix key matches 
unique symbol prefix keys matched index processing addition occurrences symbol prefix key 
paths virtual trie searched query twig stack twig total time disk io total time disk io secs pages secs pages secs pages secs pages secs pages secs pages table dblp twigstack vs query prix twig total time disk io total time disk io secs pages secs pages secs pages secs pages secs pages secs pages table comparable performances prix subsequences 
similar case query tag name np occurred frequently di erent depths treebank dataset 
case unique symbol prefix keys matched index processing prix process queries outperformed vist 
bottomup transformation query twig resulted paths searched virtual trie 
note prix system presence wildcards add extra overhead subsequence matching refer section 
prix vs twigstack section compare performance prix 
uses xb trees skip nodes sorted input stream 
note queries table tested twigstack performed worse 
example table shows performance results twigstack dblp dataset 
queries prix gave comparable performances 
table shows performance results queries similar trend performance observed queries refer 
expected processed queries ciently solutions queries distributed certain regions data xb trees ective skipping nodes input streams 
hand prix processed queries ciently bottom processing strategy 
shall analyze query performance prix queries shown table 
compared prix di erent scenarios distribution possible solutions dataset sub optimality parent child relationships 
distribution possible solutions data set ectiveness skipping input data xb trees dependent distribution solutions dataset 
nodes di erent branches query twig occur di erent nearby documents input data algorithm forced drill lower regions xb trees possibly leaves verify nodes represent solution 
queries tested behavior 
query prix twig total time disk io total time disk io secs pages secs pages secs pages secs pages secs pages secs pages table prix vs case tag name www scattered dblp dataset 
tag names editor url occurred frequently dataset documents near documents www elements input data 
caused drill lower regions xb trees times order eliminate nodes solution set 
process increased disk prix processed times faster 
xml documents dblp dataset similarity terms tree structure 
resulted sharing root leaf paths virtual trie regular prufer sequences 
example root leaf path virtual trie shared upto regular prufer sequences 
result total number nodes virtual trie reduced 
range queries required find subsequence matches processing query prix processed times faster 
swissprot dataset documents pattern entry org scattered input data 
documents author tags descendants entry 
addition tags author occurred frequently documents near documents containing input data 
result forced drill lower regions including leaves xb trees times order eliminate partial matches 
caused increase io slowed query processing 
prix able quickly eliminate partial matching documents subsequence matching shared root leaf path virtual trie 
sub optimality parent child relationships tested query demonstrate fact twigstack su er sub optimality parent child edges query twig refer section 
query parent child edges 
expected prix processed times faster 
treebank dataset similar documents scattered input data tag name np ancestor parent tag names pp rbr jjr 
matched documents possible solutions due sub optimality 
hand prix able quickly eliminate false matches subsequence matching upper bounding distance metric associated tag name rbr jjr rbr jjr case 
tag name np occur immediately rbr jjr lps documents falsely matched 
documents shared root leaf path virtual trie 
resulted reduced disk io prix compared 
related research done semistructured xml databases years 
query processing optimization received attention context 
lore system addressed issues query processing 
dataguide provides concise accurate summaries semi structured databases :10.1.1.41.3258
hugh addressed di erent aspects cost query optimizer xml 
join algorithms proposed numbering schemes process path twig queries 
system decomposes complex path expression collection basic path expressions processes :10.1.1.21.8854
developed structural join algorithms tree merge stack tree processing xml query patterns 
bruno proposed twigstack algorithms showed cpu optimal large class query twig patterns 
wang proposed indexing method called vist subsequence matching processing twig queries mapping trees sequences 
system prix maps trees sequences di ers considerably details vist 
new paradigm xml pattern matching 
transform xml documents prufer sequences 
find occurrences query twig subsequence matching performed set sequences followed series refinement phases 
provide theoretical background show correctness approach 
state art techniques approach processes twig queries breaking root leaf paths processing individually 
propose interesting optimizations speed subsequence matching 
provide empirical results demonstrate cient processing twig queries prix system 
part explore behavior prix system di erent query characteristics cardinality result set analyze query running time complexity 
jagadish nick koudas patel divesh srivastava wu 
structural joins primitive cient xml query pattern matching 
proceedings th ieee international conference data engineering san jose california february 
anders scott don chamberlin mary fernandez michael kay jonathan robie simon 
xml path language xpath working draft 
technical report wd xpath world wide web consortium august 
scott don chamberlin mary fernandez daniela florescu jonathan robie simon 
xquery xml query language working draft 
technical report wd xquery world wide web consortium august 
tim bray jean paoli sperberg mcqueen eve maler 
extensible markup language xml second edition recommendation 
technical report rec xml world wide web consortium october 
nicolas bruno nick koudas divesh srivastava 
holistic twig joins optimal xml pattern matching 
proceedings acm sigmod conference madison wisconsin june 

chien zhang zaniolo 
cient structural joins indexed xml documents 
proceedings th vldb conference hong kong china august 
paul dietz 
maintaining order linked list 
proceedings fourteenth annual acm symposium theory computing pages san francisco california may 
roy goldman jennifer widom :10.1.1.41.3258
dataguides enabling query formulation optimization semistructured databases 
proceedings rd vldb conference pages athens greece august 
torsten 
accelerating xpath location steps 
proceedings acm sigmod conference madison wisconsin june 
joseph hellerstein je rey naughton avi pfe er 
generalized search trees database systems 
proceedings rd vldb conference pages zurich switzerland september 
kaushik bohannon naughton korth 
covering indexes branching path queries 
proceedings acm sigmod conference madison wisconsin june 
kaushik shenoy bohannon 
exploiting local similarity cient indexing paths graph structured data 
proceedings th ieee international conference data engineering san jose california february 
li moon :10.1.1.21.8854
indexing querying xml data regular path expressions 
proceedings th vldb conference pages rome italy september 
jason mchugh jennifer widom 
query optimization xml 
proceedings th vldb conference pages edinburgh scotland august 
tova milo dan suciu 
index structures path expressions 
proceedings th international conference database theory pages jerusalem israel january 
nestorov ullman wiener chawathe 
representative objects concise representations semistructured hierarchical data 
proceedings th ieee international conference data engineering birmingham april 
prufer 
eines uber 
archiv fur mathematik und physik 
uw xml repository 
available 
www cs washington edu research 
wang park wei fan philip yu 
vist dynamic index method querying xml data tree structures 
proceedings acm sigmod conference san diego ca june 
yoshikawa 
xrel approach storage retrieval xml documents relational databases 
acm transactions internet technology august 
chun zhang je rey naughton david dewitt luo guy lohman 
supporting containment queries relational database management systems 
proceedings acm sigmod conference pages santa barbara california may 

