revealing class structure zoomable concept lattices uri dekel department computer science technion israel institute technology haifa israel cs technion ac il joseph yossi gil department computer science technion israel institute technology haifa israel cs technion ac il apply formal concept analysis understanding analysis code inspection individual java classes 
concept maximal set methods fields field method method uses field 
real life case study shows mathematical lattice concepts valuable means studying interface large class understanding discovering errors structure performing effective inspection code 

belady lehman laws program evolution dynamics applicable classes oo object oriented world just older kinds modules 
deals problem understanding analyzing restoring order classes entropy increased time due called horizontal evolution 
principal tool studying oo classes formal concept analysis fca technique clustering entities commonly called objects share common attributes formal concepts organized concept lattice 
fca birkhoff considerably enriched ganter wille different applications software engineering 
example snelting fca re engineer multiple configurations program application technique searching software libraries demonstrated researchers 
prominent application studying legacy non oo code usually purpose finding modules organizing hierarchical oo structure 
application objects global variables program common blocks tran attributes procedures fortran subroutines 
formal concept maximal set digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
copyright acm xxxxx xx xx xx 
ables maximal set procedures variables procedures procedures variables 
formal concepts clusters concepts serve candidates modules classes partial order relation defined lattice candidates inheritance relationship 
implicit assumption application field access class cohesion strongest version methods class fields 
obvious step apply fca similar fashion manually coded modular oo code fields take role global variables methods procedures programs 
specifically ask natural question classes coded humans obey cohesion assumption 
data set non trivial non internal classes drawn cpp data set classes fail obey strong cohesion assumption 
hypothesis research failures may reveal internal structure indicate imperfections inconsistencies asymmetries bugs design 
hypothesis strengthened famous lcom lack cohesion methods metric variants expressing belief considerable overlap sets fields method 
main proviso usage patterns fields methods fundamental understanding functionality implementation class 
rationale set fields representing class volatile set services provides cases possible implementations operation fields 
motivating factor abundance large classes interface may constitute hundreds features tens fields implementation 
shopping list approach pp encourages programmer develop large classes particularly easy inheritance multiple inheritance 
size large classes exceed legacy systems suffer disorder imposed continuous maintenance 
attracted large classes argued booch pp micro development process associated unorganized ad hoc macro process project defined 
hope find data set quarter public methods classes methods 
horizontal summands implicit modules classes reasonable design flat non oo program 
fca serve exposing internal structure classes including layers implementation may useful tasks feature categorization pp documentation code inspection requirement tracing re engineering code 
facilitate exposition class structure fca toolbox views diagrams automatically generated 
abstracting class information zooming focusing interesting details zooming 
appropriate context selection fca full signatures source code auxiliary information embedded call graph horizontal decomposition cluster concepts name concepts eliminate field names zoom zoom fig 
fca zoom zoom toolbox shown fig 
user starts choosing appropriate context variant applying fca 
selection different ways depending perspective class examination takes 
resulting lattice detailed user zoom number tasks eliminating field names naming concepts responsibility legend abbreviated notation responsibilities abstraction lattice clustering concepts finding components horizontal decomposition 
conversely user zoom presenting full method signatures displaying auxiliary information access levels methods classes defined viewing embedded call graph technique super imposing method call graph class concept lattice studying full source code method 
prototype tool eliciting desired class context computing drawing lattice 
envisage enveloping graphic browser dynamically add remove details 
tools discussed part semi structured stage methodology applying fca explore oo class learning interface examining structure inspecting code single individual 
methodology intended improve unstructured ad hoc review classes developers course micro development process 
activities methodology automated research possibly included supporting ai tools 
methodology demonstrated molecule large class public methods loc drawn chemistry development kit cdk open source library chemistry bioinformatics related classes 
prior selection case study familiar library affiliated authors way 
particular knowledge application domain 
evidence efficacy methodology despite limitations revealed problems cdk sourceforge net build confirmed errors developers expected fixed versions 
detailed worked example drawn graph theory domain 
benefits technique class customers shortening learning curve developers ability find inconsistencies missing superfluous operations feature categorization pp 
significance stems fact tasks common development activities amateur projects professional developers large industrial projects 
advantage methodology toolbox incur overhead rigorous process invoked need basis 
easy implement learn smoothly integrated development environments 
research apply fca individual oo classes 
common application fca ties oo inheritance hierarchy partial order defined lattice 
godin mili hierarchy construction objects methods attributes class names 
similarly fca automatically create hierarchy java interfaces 
snelting tip show oo hierarchy improved fca discovers features tend client programs 
outline sec 
presents concept analysis demonstrates reverse engineering small java class 
stage methodology includes checking interface zooming activities abstraction lattice responsibility legend described sec 

sec 
dedicated stage ii zoom details implementation embedded call graph 
stage iii code inspection discussed sec 
shown sensible reading order selected 
sec 
concludes outlines directions research 

concept analysis section reviews theory fca demonstrates studying pnt simple java class 
fca starts context triple sets oa 
say binary relation set objects set attributes fig 
depicts relation set objects consists fields pnt set attributes consists methods 
check marks denote field accessed directly indirectly method 
fact relation fig 
generated automatically compiled class file technique useful reverse engineering 
subset objects corresponding subset common attributes denoted attribute iff object similarly subset attributes corresponding set common objects object iff july personal communication attributes getx setx gety sety setcolor pnt draw objects color context getx setx pnt draw getx setx gety gety pnt setcolor draw pnt draw pnt draw color pnt draw color setcolor pnt draw gety sety pnt draw pnt draw concept lattice color setcolor pnt draw getx setx gety sety sparse lattice fig 
field access context pnt lattice depictions attribute pair called formal concept 
context pnt concept formed set fields accessed methods pnt draw 
concept subconcept dominated concept denoted equivalently 
concept called superconcept third concept dominates directly 
set resp 
set concepts directly dominate dominated partial order concepts depicted diagram called concept lattice 
concept lattice class pnt depicted fig 

wille fundamental theorem concept lattices states concept lattice complete lattice unique infimum concepts concept unique supremum 
follows lattice unique top concept fig 
unique bottom concept 
number fields number methods 
number different concepts exponential precisely min 
fact pnt class min indicates fields tend 
research relies natural assumption tendency general phenomena 
classes data set number concepts linear 
classes considering concepts need examine fewer pieces information considering isolated methods 
redundant information depicted fig 

sparse lattice fig 
compact representation fields methods listed concept introduces field method introduced unique lowest highest concept appears 
sparse lattice partitions set methods fields disjoint subsets may empty containing methods exactly fields related 
structure imposed method set easier study 
fields certain method collected traversing concepts dominated concept method 
conversely methods certain field collected concepts dominate field concept 
uncluttered representation fig 
highlights asymmetric structure 
moment pondering reveals coordinates symmetric 
reason probably pnt inherits class represents dimensional point 
surmise fig 
pnt main components coordinates color 
section elaborates done 

stage interface analysis stage methodology study class interface concept lattice partitions public methods concepts organizes layers abstraction 
stage primarily concerned interface process pure forced peek implementation shown running example details implementation interface 
conversely incomplete interface definition elaborated examining implementation 
steps activities stage necessarily carried sequence 
turn describing briefly 
step set expectations 
concepts lattice created automatically interpretation done human mental effort main clues names signatures methods 
order sense identifiers essential familiar vocabulary generally human context class operates 
step serve purpose unique concept analysis 
determine program entities provide features human concepts problem known literature different meaning term concept concept assignment 
step set expectations human concepts class role functionality solely non program information including prior familiarity problem domain specification documents supporting texts 
cdk knowing molecule corresponds realworld entity guess primary purpose manage collections atoms bonds 
speculate instance single atom single connected pair specific classes represent entities 
guesses possible 
step explore environment 
examine interfaces implemented class gain insight domain functionality 
interfaces may tell responsibilities assumed class help categorization methods 
unfortunately interfaces implemented molecule tell class pretty standard second turns creative programmer invention realizing global constants 
addition examine super sub classes class analysis 
molecule inherits turn inherits 
subclasses molecule library polymer subclass biopolymer 
learn inheritance hierarchy provides quite coarse classification molecules distinction fluids solids metals organic compounds exists properties provided class 
sense method signatures need familiar types class 
molecule find classes atom bond expected point point awt graphical toolkit suggesting class may provide capability calculating spatial properties molecule individual atoms 
step context selection 
lattice construction begins selection appropriate class context 
fig 
lists different options making selection 
methods parameter options static protected default access private inherited overridden fields parameter options static access parameter options read write fig 
parameters context selection choices orthogonal private methods selected exclude protected default access methods 
normally select overridden methods selecting inherited methods 
choosing don care read write means read write access method field 
interface analysis start called eiffel jargon flat short form 
underlined table specific choices public methods disregarding static status methods defined ancestors included overridden 
class fields included context regardless visibility static status 
incidence relation includes write access 
distinguish direct indirect access field 
customary relevant literature attempted 
applying fca molecule conveniently organizes methods public fields concepts 
step layers lattice layout 
expect sophisticated methods fields located higher lattice 
examining class lattices concepts layer tend similar properties 
example fig 
dominates bottom concept directly 
similar introduces single field accessor mutator 
layer bottom layer layer layer layer top layer top string bottom string bottom concept top concept fig 
layers components example lattice fig 
shows partitioning example lattice layers 
formally bottom string resp 
top string consists bottom top concept concepts resp 
bottom top string 
concept bottom layer called layer bottom string descendants 
top layer defined similarly include concepts bottom layer 
concepts internal layers 
concept belongs layer belong top layer ii dominates concepts layer iii dominates concept layer 
slightly different definition layers employed find visually pleasing layouts lattices 
lattices drawn concepts layer appear horizontal level 
fig 
lays sparse concept lattice computed class molecule 
cluttered layout highlights fact half concepts bottom layer represent basic operations inspectors mutators accessors minimal sets variables 
visible large concepts descending order 
contains bond boolean atom atom bond bond atom int atom int atom atom atom vector atom bond atom int atom double atom double bond bond int bond atom atom boolean atoms enumeration object void void object object object object void add void double void clone object void molecule molecule molecule int int molecule molecule flags boolean pointers vector contains atom boolean get point get point atom atom int atom atom void int void atom void int int double remove void atom void tostring string int int int void int int int int void void bond void void object object void object object object object void object object string void int string vector int vector void string string void string string void string string void atom int atom void int atom atom void int int void int bond int bond void bond void int title string string string void fig 
fully annotated concept lattice molecule fields invisible user omitted annotations concepts 
remains cluttered displays signatures public members class 
step simplify concepts annotations 
simplify picture try replace list methods label concept concise semantical description role 
doing rely vocabulary information gathered steps 
unknown terms methods retained exploration 
example second largest concept methods contains atom get get atom int 
responsibilities captured concept summarized retrieving removing atoms retrieving atom serial number calculating center points 
methods tostring remove 
pretty easy guess meaning methods presents unfamiliar term connection matrix retain exploration 
similarly includes methods telling responsibility concept manage property nature property remains unknown stage 
cases textual descriptions summarized naming concepts 
responsibility legend fig 
describes specialized notation scheme names including provisions free text concatenation responsibilities 
depicts outline lattice class molecule 
see example responsibility concept clone merge intersect clear molecules 
note concepts contain public methods fields considered unknowns stage 
guided newly concept names layers examination fig 
reveals interface molecule divided main categories management nearly entire state done probably 
ii management large number independent fields record fashion 
fields include list remarks list listeners lists physical properties mysterious fields lists chemical names title 
infer fields independent methods combine category 
iii direct management interdependent properties 
features include atom bond 
interdependency revealed fact united second higher layers 
iv methods dealing abstractions ties atoms bonds 
step demonstrate breakdown supported automatic process horizontal decomposition 
singleton components corresponds fields category ii 
furthermore process highlights bugs inconsistencies implementation 
step horizontal decomposition 
consider concept lattice class pnt fig 

top bottom concepts lattice removed obtain disjoint graph components dealing coordinates color 
components suggest henceforth full signature trimmed extent required distinguish overloaded methods 
ing class aggregate classes coordinate color 
lattice consisting disjoint components connected top bottom concepts called horizontally decomposable hd 
precisely undirected graph obtained concept lattice ignoring edge directionality removing top bottom strings 
unconnected say horizontally decomposable components horizontal summands corresponding connected component singleton components called trivial components 
note technical generalize definition arbitrary hierarchies 
literature offers slightly different definition may applicable alternative zoom tool 
example lattice fig 
hd shaded components components trivial 
crucial characteristic hd methods component invoke methods access fields components 
component represents independent functionality offered class 
functionalities combined high level operations 
lattice molecule fig 
hd components trivial 
examining see sole responsibility manage title property 
delving details implementation hd highlights potential problem title handled constructor appears component 
problem confirmed bug developers corrected subsequent release 
probable glitch field public inspector mutator 
hd large component gives trivial components large non trivial component consisting surrounded dashed line 
trivial components correspond independent features class component introduces auxiliary field methods manage 
potential problem fields cloning operation appears step abstraction lattice 
clear component represents cohesive portion interface atoms bonds interrelationship 
significance concepts direct dominance relations immediately obvious 
general outline lattice may information needs abstracted 
methods top layer group concepts lower levels 
rationale methods largest subsets fields represent highest level abstraction fields sets fields higher abstractions inclined believe strong tie sets 
consider formal context objects concepts class lattice attributes concepts top layer object attribute dominance relationship corresponding concepts 
fca yield abstraction lattice concepts clusters semi lattice structure physical property index atom degree shallow copy atom listener property chemical name name bond title title atom atom add bond bind atoms add atom connection matrix tostring unbind atoms bond bond order atom degree connected atoms clone merge intersect clear flags cons pointers responsibility legend exposed field named operate single operate single collection operate multiple collection get enumeration iterator additional responsibility cons constructor unfamiliar name 
text free text name fig 
outline lattice molecule component responsibility legend 
concepts original lattice 
abstraction lattice fig 
interesting concepts single cluster 
consider abstraction lattice component depicted fig 

edge clusters indicates concept usually high level dominating cluster dominates concept dominated cluster 
cluster names chosen manually 
abstraction lattice organizes original concepts clusters reducing number edges 
bond bond order atom degree connected atoms index atom degree atoms bond connection matrix tostring unbind atoms add bond bind atoms base unknown add atom bonds atom bond entire state add bond add atom atom atom shallow copy atom clone merge clear fig 
abstraction lattice component molecule abstraction lattice heuristics groups related operations separated different concepts due differences low level implementation 
stated differently pyramid abstractions methods set fields concept sets methods cluster 
kuipers moonen propose clustering technique relies user point related concepts merged system 
see automatic clustering works consider example concepts bind atoms add bond 
automatic clustering highlights similarity services 
examining lattice structure easy surmise inserts bond existing atoms may lead inconsistency binding atoms molecules 
example cluster named bonds reveals notions atom degree bond related 
observe add bond add atom clusters unknown concepts concepts public methods fields clustered 
educated guess readily confirmed stages ii iii unknown contains utilities related resizing collections 
bit information abstraction lattice significant 
example clear clusters base atoms distinct 
step match services expectations 
time examine detail services supplied class matching expectations built steps 
pyramid abstractions serves directory services fact road map journey 
searching functionality may mark related clusters zoom concepts methods examining name full signature accompanying documentation javadoc comments 
partial matches expectations discoveries way dynamically added list 
example searching bond management functionality examine clusters bonds add bonds atom bond left study concepts clusters directly related bond management 
search functionalities careful examination signatures highlights inconsistencies design flaws 
example find returns double method concept presumably computes sum bond orders returns int 
examining methods occurring concept suggests class designers apply consistent naming convention 
concept find methods atom atom atom distinct responsibilities clear names 
write examination 
step identify core auxiliary wrapper services 
class designers follow mentioned meyer shopping list approach classes provide coherent exhaustive set services 
trying understand functionality class sense focus core auxiliary services 
roughly speaking service core essential usability class emulated services 
auxiliary services thrown completeness client convenience 
auxiliary services merely wrap services adding minimal functionality process 
wrappers may example negate return value set default argument adapt type arguments return value cases wrapper concept operation wraps 
method metrics code length mccabe cyclomatic complexity provide valuable clues automatic identification wrappers 
typical characteristic wrapper calls just function overloaded name 
difficult semi automatically distinguish core non wrapper auxiliary methods 
clue core methods tend lower level concepts zero calls methods class called methods low level concepts 
section show implementation gives clues distinction 

stage ii implementation analysis zoom implementation details 
stage study carried inspecting source code 
examine methods call graph computed compiled representation 
zoom class lattice including method signatures examining names fields omitted previous stage invisible user studying fields method uses methods field hope understand class state realized state viewed modified class methods 
steps stage thought check list items code inspection 
customary methodologies precedence relation steps strict 
step construct embedded call graph 
call graph powerful tool understanding interrelations methods making distinction core auxiliary wrapper methods 
argued seminal lanza ducasse class blueprints shape graph give immediate clues semantical organization class 
embedded call graph ecg novel diagram obtained superimposing call graph class concept lattice node method embedded block concept introduces 
fig 
depicts ecg pnt ecg larger class molecule component circa graphical elements better viewed line 
setcolor getx setx gety sety draw point color fig 
embedded call graph pnt ecg thought semantic driven heuristic laying class call graph 
rationale edge crossings minimized definition methods invoke methods appear concept dominated ones 
stated differently recursive mutually recursive calls cycles call graph limited single concept 
nice property ecg lattice hd edges component cross 
ecg useful understanding interrelationship methods concept cluster 
calls methods wrapping calls 
ecg molecule easily identified candidates wrapping relationships int atom ii overloaded versions iii overloaded versions 
step identify unused fields 
early stages development unused private fields common methods stubs fields tend disappear class nears completion 
mature classes maintenance result dead code particular dead fields 
fields exist show top concept lattice top string 
molecule unused field flags public check clients removed 
void bond void void contains atom boolean get point get point atom atom int atom atom void int void contains bond boolean atom atom bond bond atom int atom int atom atom atom vector atom bond atom int atom double atom double bond bond int bond atom atom boolean int int int int int void int int int int void double remove void atom void tostring string atom void clone object double void void add void int int int atom int atom void int atom atom void atoms atom int bond int bond void bond void bonds bond int int void int fig 
zoomed concept lattice component step discover fields role 
fields examined introducing concept 
trivial components represents field accessor methods 
lattice shows fields independent exhibiting record behavior 
role fields easily zooming java doc information accessor methods 
zoomed concept lattice fig 
shows component responsible fields atoms atom int bonds bond int int 
role fields pretty obvious names 
role introduced slightly difficult reveal methods field 
consider dominating concepts deal addition removal bonds atoms 
field name guess molecule dynamically grows arrays bonds atoms field specifies chunk size 
surprisingly lattice write access context find modified inserting bonds atoms 
mental note check code inspection chunk size change 
step investigate fields interdependency 
layer structure lattice particular non empty second layer concepts layer concepts multiple fields highlights strong ties fields 
lattice concepts second layer reveal atoms closely connected bonds 
interdependency pairs fields indicated name similarity 
moment pondering raises suspicion information number atoms bonds duplicated 
take note check code inspection class methods violate invariant number non empty entries atoms bonds equal 
step assess field names quality 
role field understood check named properly preferable purpose preferable implementation instance maintains listeners operates vector field named inserts objects type 
name field probably changed 
step examine entire state methods 
class methods intended operate entire state duties construction cloning serializing printing methods introduced upper level concepts 
step identify methods check uses fields 
exceptions may indicate field redundant removed error implementation method 
learned outline lattice molecule fig 
title flags fields initialized cloned due bug 
location bottom concept indicates obvious error implementation 
examining concepts reveals clone buggy constructors handles fields dealing atoms bonds 
zooming introducing class information member find atoms bonds introduced 
molecule overrides clone overriding version fails clone fields introduced molecule 
step study asymmetries 
saw pnt asymmetries class lattice telling 
indications include repeated code incomplete interface inappropriate inheritance asymmetries fig 

example comparison suggests interface misses method comparison reveals asymmetry method 
step check method access patterns 
time check information collected field names roles method uses precisely fields 
appropriate write access read access contexts check methods expected kind access 
design flaws molecule 
example recalling interdependency atoms array noticing touch array dominate identify potential problem confirmed bug class developers 
similar problem update 
step examine non public methods 
fully understand class understand methods take part interface 
recalculate lattice context includes methods 
selection ecg show dead private methods 
running example addition protected methods introduces new concept class lattice 
new lattice shows methods manage field 

stage iii lattice directed code inspection pointed roper wood inheritance dynamic binding small methods exaggerate effects making inspection oo code difficult procedural code 
section propose ameliorate planned sensible order inspecting methods class 
experiments show planned inspection oo code effective ad hoc visit 
making case order lattice structure 
inspection follows check list items discovered previous stages 
addition propose specific inspection tasks lent analysis 

lattice directed inspection order source oo class may spread files may lost initial organization laws program evolution dynamics 
planning alternative effective order class read hope related methods appear increasing probability detecting duplications increase opportunities code sharing 
objective reduce mental load human inspector offering hierarchical organization minimizing number forward 
objective served simple rule particular order items items inspected ascending complexity order 
rationale rule obvious reader keep mind average reading process fewer bits information 
propose lattice inspection order code introduced concept read 
idea similar meyer suggestion methods organized groups responsibility global order sorted lexicographically group local order 
difference concepts responsibility driven global order automatic feature categorization calling patterns local order 
global order sort concepts components ascending layer cluster 
rationale methods component class members fields methods component similarly methods layer refer members higher layer 
concepts cluster expected related read 
choosing order components apply simple rule 
local order embedded call graph determine order methods concept read possible method read members refers 
cycles call graph concept ties independent methods broken simple rule 
method simplicity may subjective method metrics reasonable approximation simple methods tend short contain branching instructions low mccabe complexity invoke methods 

inspection tasks applying steps stages ii individual class generates questions answered code inspection 
example deferred code inspection issue maintaining consistency atoms interpenetration term connection matrix absent documentation exact role 
fact class specific inspection tasks coming top ordinary general purpose tasks rules inspection strategy 
add number general inspection tasks inspired concept lattice approach 
task find duplicate services 
methods provide functionality expected set fields regardless implementation details 
methods concept 
idea reminiscent employment signatures search keys function libraries 
conversely search duplication enhanced searching functions identical signatures 
running example find molecule fig 
introduces methods atom atom despite name dissimilarity supply exactly service 
task identify code sharing opportunities 
similar rationale methods carry similar computation methods neighboring concept 
int int int int int int int serving slightly different purposes identical implementation lends sharing 
task verify low level methods bypassed 
oo advocate trust optimizers introduce trivial methods simple opera recall cycles concept boundaries tions field access delegation 
methods tend low level concepts 
neglect misguided temptation optimize probably reasons cases higher level methods bypass supplied trivial methods 
inspection task search especially high level methods code fragments replaced existing low level methods 
manually feed patterns bypassed methods low level concepts star diagrams engine 
automatic approach examine edges emanating high level concept ecg 
bypass indicator number edges small 
edges leading non directly dominated concept may indicate bypass 
molecule example methods directly bond fields respective accessors 

research research apply fca individual oo classes 
main claim class internal structure revealed selecting appropriate context fig 
dozens variants zooming ensuing lattice fig 

related line research check validity claim context kinds objects methods attributes types 
stage methodology supports main claim showing variety ways non trivial discoveries semi structured process lattice mere inspection interface delving implementation details lattice directed examination source 
needless say practical experience required methodology sealed released 
independent contribution reading order sec 

research challenge verify efficacy controlled experiment 
detailed example showed class lattices help detecting flaws improving design 
empirical study validate approach appropriately selected null hypothesis 
opportunities improvement elaborated 
example access level methods bond restricted may violate class invariants add bond foreign atoms 
preliminary full re engineering class yielded simpler elegant lattice 
intriguing research question certain topological properties concept lattice serve metric design 
astute reader probably noticed component corresponds base molecule 
show class maintenance changes traced examining evolution class concept lattices 
exciting research direction unified treatise class lattices including vertical inheritance horizontal maintenance evolution incorporating lattice representing inheritance 
difficult incorporate lattice class field lattice containing class generate system wide operational context 

antoniol merlo 
method reorganize legacy systems concept analysis 
iwpc pp 

belady lehman 
laws program evolution dynamics 
ibm syst 

biggerstaff webster 
concept assignment problem program understanding 
icse pp 

birkhoff 
lattice theory 
american mathematical society providence ri usa nd edition 
booch 
object solutions 
managing object oriented project 
addison wesley 
chidamber kemerer 
metrics suite object oriented design 
oopsla pp 

chidamber kemerer 
metrics suite object oriented design 
ieee trans 
softw 
eng 
cohen gil 
self calibration metrics java methods 
tools pacific pp 

dekel 
applications concept lattices code inspection review 
proc 
israeli 
prog 
lang 
dev 
env 
ibm haifa research lab july 
www haifa il ibm com info ple 
roper wood 
object oriented inspection face 
icse pp 

roper wood 
systematic object oriented inspection empirical study 
icse pp 

fischer 
specification browsing software component libraries 
ase pp 

ganter wille 
concept analysis mathematical foundations 
springer 
graham 
software inspection 
addison wesley 
godin mili 
building maintaining analysis level class hierarchies galois lattices 
oopsla pp 

henderson sellers 
object oriented metrics 
prentice hall 
leblanc 
computing interfaces java 
ase pp 

griswold 
tool support refactoring java programs 
tech 
rep cs dept comp 
sci 
eng ucsd july 
kuipers moonen 
types concept analysis legacy systems 
iwpc 
lanza ducasse 
categorization classes visualization internal structure class blueprint 
oopsla pp 

lindig 
concept component retrieval 
working notes ijcai workshop formal approaches reuse plans proofs programs pp 

lindig snelting 
assessing modular structure legacy code mathematical concept analysis 
icse pp 

mccabe 
complexity measure 
ieee trans 
softw 
eng dec 
meyer 
eiffel language 
prentice hall 
meyer 
reusable software base object oriented component libraries 
prentice hall 
mezini 
maintaining consistency class libraries evolution 
oopsla pp 


types search keys function libraries 
fun 
prog 
shen park 
concept retrieval classes access behavior methods 
proc 
int 
conf 
inf 
reuse integration pp 

reps identifying modules concept analysis 
icsm pp 

snelting 
reengineering configurations mathematical concept analysis 
acm trans 
soft 
eng 

snelting tip 
understanding class hierarchies concept analysis 
acm trans 
prog 
lang 
syst 
smith 
chemistry development kit cdk java library structural chemo bioinformatics 
submitted publication 
sugiyama toda 
methods visual understanding hierarchical system structures 
ieee trans 
sys man cybernetics 
tonella 
concept analysis module restructuring 
ieee trans 
softw 
eng april 
van deursen kuipers 
identifying objects cluster concept analysis 
icse pp 

wille 
restructuring lattice theory approach hierarchies concepts 
rival ed ordered sets pp 

reidel 
