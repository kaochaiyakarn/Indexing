early search tractable ways reasoning programs jones august traces important steps history research reasoning programs 
main focus sequential imperative programs comments concurrency 
initially researchers focussed ways verifying program satisfies specification programs equivalent 
time clear post facto verification practical small programs attention turned verification methods support development programs larger programs necessary exploit notation compositionality 
coping concurrent algorithms challenging extensions considered briefly 
main thesis idea reasoning programs written search find tractable methods 
contents proofs sequential algorithms pre hoare 
hoare axioms 
post hoare 

formal development methods stepwise design 
data structures 
development methods 
controversies 
issues concurrent programs 
language semantics 
machine supported verification 
novel languages 
ieee 
please cite version ieee annals history computing vol pp 
version restores section numbering life dates deleted sections 
ieee version accessible computer org annals abs htm program judged correct respect independent specification achieve 
simple calculation shows testing ensure correctness relatively straightforward programs program simple way forward pointing decision points maximum paths branch points cause repetition 
shows programs upwards branch points paths tested fact 
general way determining paths bug occurs path designed correctly 
bugs avoided technique testing establish software satisfies specification 
fortunately assumptions discussed possible reason computer programs 
ideal relatively short specification basis proof putative implementation satisfies specification 
proofs contain errors correlation complexity risk errors 
attempts reduce risk accepting invalid proofs touched appropriate structuring developments reduce complexity discussed section proof support tools reviewed section 
traces important steps history research program verification 
central thesis need reason programs apparent creation research challenge find tractable methods 
section describes detail history verification sequential imperative algorithms 
time clear post facto verification limited small programs section explains early results applied change way programs developed 
coping concurrent algorithms challenging extensions considered section 
proofs sequential algorithms imperative programs thought terms ects computer executes 
operational thinking severe limitations making human slow imitation computer yield deep understanding 
interestingly alan turing classic entscheidungsproblem tur introduced idea turing machine thought experiment prove deep result formal systems 
written program knows errors easily larger program greater risk errors detected testing 
section indicates pioneers computer programming aware need reason programs order ensure desired properties 
cases property sought show reasons clear real history example author historian 
biases author selective knowledge current text open criticism conscious personal person singular 
best provide source subsequent historical research 
topic largely ignored numerical analysis 
reprinted dav pp 
program satisfied specification errors 
search tractable notations specifying reasoning programs 
sections trace main line development key publication sir charles antony richard hoare pivotal point related central issues discussed section 
pre hoare fact possible reason computer programs evident pioneers electronic computing 
herman heine john von neumann wrote explains assertion boxes see record reasons believing series operation boxes particular ect 
begins discussion shows von neumann believed task coding non trivial cf 
pp actual code problem sequence coded symbols expressing sequence words half words words placed memory order cause machine perform desired planned sequence operations amounts solving problem question 
precise sequence codes impose desired sequence actions mechanism scans sequence codes ects instructions contain 
just linear scanning coded sequence remaining procedure unchanged form matters quite simple 
coding problem machine merely name indicates translating meaningful text instructions govern solving problem consideration language language mathematics planner conceived problem numerical procedure decided solve problem language code 
case 
convinced general grounds actual experience coding specific numerical problems main di culty lies just point 
move indicate direction proposal cf 
problem find simple step step methods di culties overcome 
coding static process translation technique providing dynamic normally just tony hoare show initials 
intended publisher asked full names year birth key people included preserved version 
brian randell pointed concern correctness pre electronic phase charles wrote verification formulae placed operation cards see ran pp 
zuse earliest programming languages see heinz kindly checked prof zuse confirms concern shared specific provisions correctness arguments 
reprinted tau pp page number version 
background control automatic evolution meaning viewed logical problem represents new branch formal logics 
propose show course report task mastered 
basic design approach plan flowchart 
describing operation boxes substitution boxes key concept assertions comes text cf 
consider changes limitations domains variability bound variables individually interrelationships 
may true reaches certain point flow diagram bound variables necessarily possess certain specified values possess certain properties satisfy certain relations 
furthermore may point indicate validity limitations 
reason denote area validity limitations asserted special box call assertion box 
description consistency operation assertion boxes checked interesting example described follows cf 
interval question immediately preceded assertion box expression field virtue relations validated assertion box equal expression valid field storage position constancy interval immediately preceding assertion box 
demonstration completely obvious desirable give indications nature main stages proof may included assertions assertions box place proof may assertion box field consideration 
discussion approximation processes round errors write cf 
di cult avoid errors omissions simplest problems 
frequent cases inner diagram obvious diagram completed 
flexibility system 
corrections modifications type applied stage process throwing gear procedure drawing diagram particular creating necessity starting 
reasons clear interesting quote earlier part induction cf 
reason may move times region memory operations performed may repetitive 
definitions induction integer variable iterative processes successive approximations 
simplify nomenclature call simple iterative process type induction simple induction 
multiplicity iterative processes superposed crossing called multiple induction 
conclude observe course circling induction loop variable induction variable change variable initial value entering loop 
junction alternative box induction loop preceded substitution boxes paths lead loop path leads loop 
exit induction loop induction variable usually final value known advance rate mathematical symbol introduced 
amounts restriction domain variability induction variable exit crossed restricted final value value 
clearly shows authors concerned problem correctness clear idea possible desirable reason programs 
essential point possibility add form assertions separate served discuss ect operations program evident writing programs 
similar observation milestone 
tur alan turing conference cambridge england begins check routine sense making sure right 
order man checks may di cult task programmer number definite assertions checked individually correctness programme easily follows 
provides beautiful account just typed pages 
quotation turing motivation clear provides example answer opening question 
aim reason program general just reduce errors detecting exceptional cases hand tests 
turing begins analogy carries addition assertions decorate flow diagrams decompose task checking 
programming example tackled computing factorial multiplier multiplication carried repeated addition standard example demonstrating ways reasoning programs 
flow diagram annotations shown 
turing wrote printed text turing contains transcription errors took considerable ort decipher mj contains corrected version relates 
turing proof factorial routine factorial changed familiar 
notation 
explains assertions follows typical moment process recorded sr change sr addition 
change transfer 
unfortunately coding system su ciently generally known justify giving routine process full flow diagram fig 
su cient illustration 
box flow diagram represents straight sequence instructions changes control 
convention dashed letter indicates value process represented box 
ii letter represents initial value quantity 
equate similar letters appearing di erent boxes intended identifications valid content line store content line store content line store content line store content line store intended sr sort 
order assist checker programmer assertions various states machine reach 
assertions may tabulated fig 
assertions states certain particular quantities control corresponding letters flow diagram 
column table situation control 
quantities needed specify condition machine completely case su cient give upper part table gives various contents store lines various conditions machine restrictions quantities may call inductive variables 
lower part tells conditions occur 
checker verify columns corresponding initial condition stopped condition agree claims routine 
case claim start control condition line shall find quantity line machine stops 
provided condition ignored 
upper part lower part concern question overflow discussed clean termination 
verify assertions lower half table correct 
doing columns may taken order quite independently 
column checker argue flow diagram see box applies 
upper part column 
entry line 
entries turing programming language hindrance idea primed dashed versions identifiers returned section 
turing addresses question termination checker verify process comes 
assisted programmer giving definite assertion verified 
may take form quantity asserted decrease continually vanish machine stops 
pure mathematician natural give ordinal number 
problem ordinal form thing give integer case steps decrease 
step decrease 
course checking process comes time involved may estimated arranging decreasing quantity represents upper bound time till machine stops 
comparison floyd language assertions clearly limited 
key idea logical statements relate values variables 
early date turing remarkable economical exposition 
respective dates tur tempting speculate turing knew earlier 
turing visited von neumann cf 
hod discussed 
reputation working possible turing refinement von neumann earlier ideas 
course pure speculation unwise significant part turing reputation depended nonce presentation 
link support speculation term inductive variable pointed douglas discussion followed turing talk probably obvious choice terminology pioneers hit purely coincidence 
tur appears known influenced subsequent research program verification 
early papers indicate tractability research challenge basic idea programs subject formal arguments apparent early history programming 
fact mathematicians coming computing key di erence notations mathematics programming languages designed manipulation mind di cult reason primarily designed facilitate translation cient machine code 
compelling explanation decade elapsed landmark development field 
possible reasons include focus hardware developments period optimism development programming languages expression programs clear contain errors 
fact hardware restrictive programming task complex 
true far programmers mistakes period 
developments hardware possible implement systems inadequacy testing increasingly evident 
may western joint computer conference john mccarthy issued call investigate mathematical theory computation accessible source slightly extended version contribution mcc 
includes provocative sentences reasonable hope relationship computation mathematical logic fruitful century analysis physics 
development relationship demands concern applications mathematical elegance 
impact call stimulate mccarthy played significant early part formally describing semantics programming languages 
di cult issues formulating descriptions reasons tackling problem clear reason programs language semantics unknown proving program certain properties language description fruitless compiler language faithfully reflects description 
topic language semantics completely separated program verification outline major issues section 
mccarthy attention reasoning recursive functions imperative programs focus mcc describes recursion induction mcc discusses lisp language mcc shows link recursive functions programs 
citation includes clear statement goals 
example primarily able prove procedures solve problems 
debugging program prove meets specifications proof checked computer program 
possible formal systems required easy write proofs 
problem slightly touched statement computer arithmetic exact rules reasoning evaluation expressions 
van wijngaarden lee pointed mccarthy said design inter alia algol stated gentleman propose didn know implement see 
years father dutch computer science published vw contains careful discussion problems reasoning finite computer arithmetic sketches axioms support proofs 
van wijngaarden cambridge conference attempt link quite separate contribution turing 
content ignorance turing source link hoare years van wijngaarden talk see section 
year saw crucial step forward papers robert floyd peter naur major influence subsequent 
appears naur floyd developed ideas independently 
naur nau includes final note similar concepts developed independently robert floyd unpublished communicated privately 
presumably version floyd dated may normally cited flo proceedings conference took place april 
floyd private communication july confirmed time naur met summer ideas worked publications ected 
floyd influential naur largely presents formal foundation clear independent contributions great significance research program verification 
naur general snapshots nau written comments text algol programs clear statements relationships variables expressions formal language see 
arguments believed similarly carefully constructed stated formal logic 
naur opens consequence lack influence mathematical thinking way computer programming currently pursued regular systematic proof procedures realization proof procedures exist unknown large majority programmers 
spite clear statement obvious writings naur views proof weapons program designer interested formality sake 
account controversy sparked naur see section 
wishing form picture development research program verification strongly advised read flo 
floyd describes edsger dijkstra described turing award lecture dij decision computing influenced van wijngaarden 
dijkstra adds moral story course careful give advice younger people follow 
mentioned little said problems numerical analysis 
fact early research reasoning programs confined discrete data notable exception hes 
asked alive checks colleagues jaco de bakker michel turned memories verbal 
floyd prior discussed 
naur develop ideas action clusters nau fit thoughtful little known book nau 
example naur general snapshots challenge faced authors discussed section proving properties form initial values program variables satisfy relation final values completion satisfy relation summary approach taken notion interpretation program association proposition connection flow control program proposition asserted hold connection taken 
floyd method annotating flow chart assertions propositions relate values variables 
example floyd sample program computes integer division successive subtraction see finds describe situation quotient remainder dividing positive integers addition assertions concerned correct outcome ordered pairs annotations provide termination argument 
floyd clearly saw essential subsequent authors agreed 
generality order predicate calculus assertions explicit role loop invariants key contributions 
floyd gives precise verification conditions ensure assertions correspond statements flow diagrams 
floyd looks strongest verifiable consequents 
tackled way starts assertion written statement tries conclude strongest assertion true statement executed 
viewpoint leads complicated rule assignment statement consequent uses existential quantifier 
floyd discovered simpler backward rule 
rule jim king see section david charles cooper hoare responsible informing backwards rule wisely adopted key 
floyd landmark includes discussion verification conditions required algol subset floyd give rules specific language constructs recognises place general axioms true semantic definition 
compared edsger dijkstra conditions predicate transformers discussed section 
hinted title flo assigning meaning programs main thrust way proving programs correct quote establishment formal standards proofs programs languages admit assignments transfer control proposal semantics programming language may defined independently processors language establishing standards rigour proofs programs language appear novel mccarthy done similar programming languages evaluation recursive functions 
floyd unaware turing interesting note important di erence floyd method turing floyd allows arbitrary logical expressions assertions relate values variables complicated ways appears constrained explicit expressions values variables 
example clear state turing system divides prime number program 
mentions general expressions problems system 
important fact floyd er formal rules checking verification conditions 
doubt huge ect floyd follows 
floyd saw contribution semantics program proof method interesting record floyd comment modes proof correctness termination original ideas perlis may earliest appearance unpublished 
traced gor 
fair say argues correctness flow chart systematic way handling assertions 
formulate interesting induction rule function property set storage positions remains unchanged instruction program remains unchanged program 
presumably reason maurice wilkes argues wil turing tur anticipate floyd contribution turing word assertion point separate need show execution program terminate 
missing concept loop invariant 
di culty dick hamlet ralph london 
example floyd interpreted programs hoare axioms widely cited mentioned section hoa 
tracing evolution fascinating 
tony hoare attended ifip working conference formal language description languages baden bei wien austria give talk comment ste pp need leave languages undefined key points 
meeting ifip working group followed baden conference tony hoare discussed definition functions properties result abs non negative equal argument negation thereof 
hoare attended members european computer manufacturers association ecma pl standardization group tc course language semantics pursued ibm laboratory vienna 
stayed imperial hotel sketch axiomatic written 
notice precedes naur floyd publications 
part draft dated december evolve hoa written brief period employment national computer centre manchester 
part privately circulated axiomatized execution traces partial order clearly stated goals axiomatic basis 
objectives clear coherent notion axiomatize programming language concepts discussed 
arrival belfast take chair october hoare draft floyd 
major impact hoa 
part draft dated december reflects floyd ideas strongly resembles final journal version hoa 
part data manipulation clearly influenced van wijngaarden ideas providing axioms data overflow arithmetic part program execution crucial step known hoare triples 
hoare writes papers mentioned floyd naur van wijngaarden cited suggestion specification proof techniques provides adequate formal definition programming language appears flo 
formal treatment program execution clearly derived floyd 
main contributions author appear suggestion axioms may provide simple solution problem leaving certain aspects language undefined comprehensive evaluation possible benefits gained adopting approach program proving language definition 
reason impact hoa clarity exposition 
hoare grasped significance floyd contribution key change major papers hoare reprinted hj 
description follows generated link material book consists private communications hoare current author 
peter lucas recalls having sent tony hoare response earlier drafts copy preprint floyd 
published people find floyd article easy reading remember making trip pittsburgh august ask bob floyd help tation 
hoare triples contain pre post condition placed piece program 
hoare placed braces program constructs move bracket assertions braces indicative role commentary program text 
read operationally stating assignment statement executed state values providing execution terminates state execution assignment values assertion true 
example taken development hoa algol version division successive subtraction example flo 
illustrates number points 
inference valid assignment statement uses right hand side value extracting value initial state left hand side value indicating variable change final state 
particular inference instance simple perspicuous schema hoare presents axiom assignment variable identifier expression obtained substituting occurrences hoare points axiom schema described purely syntactic terms easy check finite text conforms pattern 
mentioned backward rule assignment far simpler forward verification condition flo 
hoare heard new rule cooper sabbatical carnegie institute technology carnegie mellon university gave talk belfast return 
axiom schema valid certain assumptions subtle points subscripted variables discussed apt 
mention just restrictions consider possibility identifiers denote location cases instances axiom schema may correspond possible interpretation 
languages permit sharing occurs call name algol call variable pascal writing cient programs 
hoare gives hoa general rules consequence justify strengthening pre conditions weakening post conditions understanding version dana scott invited vienna laboratory original intention discuss floyd contribution semantics impact hand written note dbs brought described joint joe stoy history program language semantics 
furthermore maurice wilkes writes letter tony hoare august 
loop invariants 
idea apparently simple really deep 
grasped fully confess floyd patient time look subject way 
strictly substitution free occurrences rules composition instances conclude rule iteration particularly interesting clearly shows role invariant constructs statements plays part induction hypothesis inductive proofs 
establish iteration rule establish termination 
hoare points section reservations notation interpreted provided program successfully terminates properties results described result referred partial opposed total correctness 
invaluable contribution rules ect needing reason operationally program execution program proof sequence lines mediated axioms inference rules 
possible view floyd flow diagrams statically temptation think operationally greater 
important steps development mathematical notation presenting proof hoare triples encourages clear thinking 
crucial aspect hoare triples compositional way floyd flow diagrams 
point explored section 
subsequent papers tackle features programming languages identified areas covered hoare 
notably hw attempted provide axioms significant portion pascal 
obvious line research hoare stated aim style axioms language definitions 
time shown languages designed explicit constraint axiomatic semantics task providing complete axiomatization impractical 
languages euclid gch designed axiomatic definition mind aspire today design language denotational operational semantics see section main guide considerations proof additional insurance tractability 
progress stage languages designed relatively minor abstractions architecture hardware object programs run see section 
narrowest interpretation dijkstra famous letter hoa ch ach dr dr apt argued goal ambitious 
hoare presentation april meeting ifip working group vienna responded challenge taken arithmetic peano axioms formalized task 
editor dij just coding rules avoidance goto statements seen step tractability programs reasoning compilation 
fact issues raised debate structured programming wider ddh dij dij wir wir transformed thinking programming task 
form semantics consistent 
impact observation assumptions possible claim proof provides knowledge program execution returned section issue proving inference rules hoare socalled axioms consistent model oriented semantics considered lau hl don 
peter lauer member ibm laboratory vienna went belfast phd hoare supervision 
post hoare hoare linked ideas van wijngaarden floyd gave topic program verification boost making theoretically possible idea tractable technique 
section reviews detailed issues remain resolved major step history related section 
program verification ideas narrow sense section transition research papers post graduate textbooks dij undergraduate texts 
leaving aside plethora notational details substantive issues distinguish approaches simplest form program verification 
publications assertions pre conditions invariants postconditions predicates state 
seemingly innocent decision causes problems writing meaningful specifications 
example specification division task discussed requires final state implementation arbitrarily change ensure correct answer 
simple case specify way changes values allowed case program specifically intended change large data structure place sorting matrix inversion possible get post conditions final state 
number techniques auxiliary variables record initial values compared ect making step post conditions assertions states 
done early man distinguished vdm see section approaches jon 
seeing natural way specifications set proof rules tolerated jon clumsy comparison hoa 
fortunately peter henry george aczel wrote extensive unpublished note january shows elegant set rules proofs predicates states 
fact detailed technical assessment focuses questions consistency completeness apt apt important study db 
example gri bac 
aczel writes specifications hoa familiar specification explicitly express mind 
flexible powerful approach advocated cli jones book jon 
rules appear elaborate rules extensions single state case 
changes aczel showed convenient post condition old new values state variables 
significant issue appear divergent approaches way partial functions handled proofs programs 
mathematicians find division zero nuisance partial functions common computing require systematic handling 
non denoting terms arise recursive definitions basic operators data types sequences 
need prove results logical formulae include terms partial functions casts doubt applicability classical logic 
mccarthy mcc recognise problem 
approaches handling partial functions attempt salvage classical logic include avoiding function application variant equality notions 
alternative accept need nonclassical logic 
frequently non classical logic adopts non strict non commutative conditional versions propositional operators alternatively commutative non strict operators defined stephen kleene strong truth tables 
consistent complete proof system logic vdm 
logic partial functions analyzes approaches reasoning partial functions 
area research mentioned various notions induction 
key results david michael ritchie park par hans bekic dana scott fully explored language semantics 
concept structural induction central program proofs deserves 
rodney burstall showed usefulness rule talk yorktown heights conference published bur connections recursion induction discussed mccarthy conference 
essentially structural induction shows inductive proofs constructors objects trees conducted directly need recast numerical induction nesting depth 
seen citations floyd hoare contribution traced shows main flow development research 
necessarily value judgement collect section papers influence just accident timing unforeseen factors 
compared original rules partial correctness hoare 
resulting rules vdm publications jon 
including similar specifications gives clear concise comparison state approach tar goes far pre conditions predicates states 
led embarrassment current author seminar tyne hoare gave talk accepted post conditions states convention pleased waiting give talk set slides see luk sco mm bla che hoo bli avr ktb cj 
normally just david park 
order avoid confusion show initial 
ralph london produced string early papers lon lon lon lon lon lon verification topics 
early avenue research programs involved proofs equivalence schemas flowcharts uninterpreted operations boxes 
majority results un decidability 
early papers russian yan japanese iga scientists important 
november conference mathematical theory computation ibm yorktown heights research laboratory zohar manna methods john mccarthy argument move away schemas represented lpp 
papers longer appear topic time shown mccarthy right audience witnessed robust defence mike paterson just completed cambridge phd pat supervision david park 
paterson research interests moved focus complexity theory serious loss verification research 
algebraic semantics see interesting echo schema research 
david cooper mentioned connection sabbatical carnegie institute technology wrote available carnegie published coo considers equivalence iterative recursive forms programs 
influence transformational development methods alternative approach formal development programs 
basic idea simple program specification 
program written su ciently constrained language correctness obvious 
reason program example purely functional language hopelessly ine cient starting point series transformations yield usable implementation 
major piece area appears john darlington phd research thesis dar supervised burstall 
cooper published proceedings coo annual machine intelligence workshop lists series things nice find programs 
include program solve problem program equivalent equivalent programs cient 
cites early london lon evans eva proofs recognisers 
cooper professor computing swansea university research assistants robin milner october december 
zohar manna thesis man written carnegie institute technology carnegie mellon university expresses debt guidance research floyd supervisor perlis 
printed april part report clear role predicate calculus reasoning programs 
particular manna focuses problem termination shows semi decidable 
manna impact useful reviews contained rut db ers ers pp 
see db bd 
sophisticated system transformational development cip computer aided intuition guided programming group technische universitat munich bw cip cip 
current topic include sa par 
ed 
citations taken secondary material 
citations man suggest 
rod burstall consistently produced seminal contributions proposals idea intermittent assertions 
tasks produce clearer proofs floyd assertions linked flow control 
invited talk ifip bur additionally broke predicate calculus introducing temporal logic see section 
formal development methods crucial test program development ideas scale develop large programs exponential growth ort 
section plots course proofs tiny programs development methods applied industry 
stepwise design methods hoa reasoning programs natural attempt apply larger programs original publications 
unfortunately quickly clear set axioms construct proof complete program inadequate response challenge creating non trivial programs 
fact people evident hoare 
earliest publications concerned cient programs related sorting famous sorting program quicksort hoa 
publishing hoa attempted method presenting program reasoning justify find program published quicksort 
fact submitted draft proof form communications acm cacm referees length opacity proofs arguing di cult gain confidence presentation 
hoare came independently realization saw necessary move presentation design decisions taken justified time 
revised published hoa relies rules hoa uses justify stage development time 
specifications sub operations completely formalized crucial step development methods discussed section 
post facto proof program satisfies specification possible correct program attempts construct proofs trivial programs provide cost ective way detecting errors 
alternative making step development justifying done huge advantages approach mirrors developer normally proceeds potential detect errors soon 
addition fact testing relied uncover errors applied code developed 
move formal stepwise process potential formalism increase productivity program text book man influential subsequent research temporal logics 
applications fh hoa 
development reducing scrap rework inherent basing design erroneous decisions detected testing 
order ideas precise worth saying notion satisfaction 
described floyd specification pre post conditions assertions states 
assertions written order predicate calculus provides precise notion set states assertion true 
implementation said satisfy specification states pre condition true implementation terminates yields state post condition true 
notion satisfaction discussing specifications sub components 
need support stepwise development gives rise requirement compositionality 
notion easy illustrate context developing sequential programs 
suppose program specification implemented 
designer decompose task sub tasks specifications recorded design show execution followed satisfy specification compositional method implementations satisfy specifications combined yield implementation satisfies words specifications sub components tell developers need know task 
easy illustrate sequential programs di cult achieve section explains issue compositionality significant complication development concurrent programs 
able justify stages design significant step forward developers situation prove complete correct programs satisfied specifications 
task finding code assertions remains 
general requires human intuition design programs possible provide heuristics easier decide tackle particular forms specification 
heuristics studied extensively predicate transformers 
step forwards backwards assignment axiom described dijkstra proposed regarding program constructs ways transforming required post condition weakest pre condition guarantee successful termination dij 
viewing inference triples ask weakest precondition terminate deliver state true 
weakest pre condition just change viewpoint interesting consequences 
firstly nice calculus predicate transformers 
writing wp weakest pre condition statement achieve state satisfying wp wp wp dijkstra claim dij tightened things bit hoa justified handles total correctness including termination researchers working suggestive term independence principle 
hoare axioms covered partial correctness dijkstra guarded commands embody prompt clear handling non determinacy strong anti operational flavour dijkstra explanations 
return point helping programmer discover valid steps development dijkstra monograph dij goes long way teaching discover correct designs 
addition providing predicate transformer semantics specific programming language contains main structured programming constructs dij presents conditions predicate transformers satisfy 
data structures specification useful starting point development shorter clearer program satisfies 
post conditions easier formulate compact programs written standard algorithmic language 
particular conjunction negation powerful ways expressing desired result needing describe compute 
examples preceding sections variables values numbers computing problems discussed terms values elaborate structure 
finding ways representing values linearly addressable memory challenges program design 
unfortunately outcome design rarely short tractable sense easily determine properties 
clear specification design methods able cope richer data structures numbers 
particular developers necessary write specifications terms class states find ways relating representation chosen design process 
example relational database system specified succinctly terms mappings finite functions relation keys sets tuples final representation involve complex chains pointers order achieve reasonable performance update query operations 
mccarthy call largest formal descriptions programming languages 
ibm laboratory vienna forefront see section 
cooperation ibm uk laboratory di erent ways modelling access local variables arisen 
concern definitions equivalent 
peter lucas undertook proof luc models defined language twin machine combined di erent representations underlying state 
predicate defined valid elements cross product essentially fixed relation representations 
prompted cli ord jones write vienna report jon highlighted advantage functional relationship representation abstraction possible representations october meeting ifip part play development cf 
mike nice history gri pp firm rejection arguments unnecessarily operational way remained hallmark 
full discussion predicate transformers ds see dr 
called refinement calculus development described bac mor impact goes cuto 
value 
arthur john robin milner worked problem swansea see example mil mil mil careful algebraic view simulation stanford technical report mil 
hoare topic hoa common citations area 
uses function representation abstraction basis set proof obligations 
hoare acknowledges milner influence value area diminished knows christopher strachey described idea burstall mid considered obvious worth writing 
indication strachey idea developing programs data objects seen str outlines design program play checkers 
view date contribution impossible resist giving quotes early days programming say years ago mathematicians think su cient care able write programs correct 
greatly surprise case rare exceptions programs written contained numerous errors 
programming techniques improved immensely early days process finding correcting errors programs known graphically debugging remains di cult confused unsatisfactory operation 
doubt current techniques nearly reached limit programming 
improve techniques 
left di cult interesting potentially rewarding problem concerning programming languages 
lay firm mathematical foundation construction hierarchical systems programs develop calculus manipulating 
simplest way record relationship space states representations function 
functions called abstraction retrieve functions formulate correctness conditions program development steps concerned design data opposed development algorithms 
data refinement reification occurs early design program importance obtaining productivity formal methods 
surprising relatively books give prominence topic 
number technicalities clearer time 
approach described called model oriented contrast normally just robin milner 
order avoid confusion cited show initial 
robin milner pointed private communication february submission journal acm topic thought referees obvious warrant publication 
milner rightly comments things don di cult useful 
exceptions include jon rey mor summary vdm research data reification jon 
property oriented approach described section 
risk model chosen overly concrete sense conserves non essential information 
notion bias quite precise jon 
purpose specification fix behaviour visible operations arguments results underlying state model hidden sort 
bias inevitable implementation obfuscate specification subsequent design justifications burdensome 
terms freedom implementation bias full abstraction characterize equivalence class specifications retain information support intended function system 
specifications abstraction functions implementation 
systems possible achieve exactly sort freedom bias 
particular systems specifications allow non determinacy need implementation states contain information dropped designing implementations 
proof rules idea relations abstraction representation developed nip hhs 
sense precise papers rules complete 
model oriented specifications described fits flow ideas count early publications observe initially research called property oriented specifications data types 
observation model oriented specification contain unnecessary detail led researchers seek specifications appear contain model 
look peano axioms natural numbers see stimulus idea came key approach define data type signatures operators axioms giving relationships operators 
example fix part behaviour stack saying pushing element stack popping stack returns original value 
extent specifications peano axioms natural numbers exponents specifications call algebraic specifications 
claiming monopoly term said little unfair textbooks happily follow peano characterizations natural numbers model rational numbers 
commonly cited early gut 
see mor mor 
fact luc internal lucas walk employs idea presenting operations relationships uses stacks example 
lucas papers developed citations interesting note considered huge model definition pl programming language characterized storage component axioms accessible source material version pl definition bw 
jon uses correctness notion rests preserving relevant properties 
number technicalities property oriented specifications 
example di erent initial final loose interpretations see nip 
useful historical sketch 
axioms choice influences implementations proved satisfy specifications 
acute minds succeeded proving classes data types specified finite set axioms called hidden functions employed 
casts doubt claim techniques avoid danger implementation bias 
handle property oriented specifications partial operators ones nondeterministic issues full agreement absent 
useful view model property oriented split concepts domain applicability data types naturally viewed collections immutable values description best terms state 
interesting technical questions inter relationship approaches 
coming model side view property oriented specification providing model terms word algebra operators unbiased model comes word algebra type generators property oriented viewpoint say model oriented specifications ones particular set hidden functions operators underlying types sets mappings 
development methods ideas operation decomposition data refinement combined sense systems developed 
required coherent notation set proof obligations 
called vienna development method vdm earliest attempts create coherence 
history ibm vienna laboratory contribution formal methods fitted su ce say vdm grew earlier formal description programming languages 
earliest full length expositions vdm bj jon concerned denotational semantics development compilers relates general program development 
vdm specifications model oriented module defines class states series operations change depend states precise notions operation decomposition data reification part development method 
vdm organisations far originated 
specification language closely related vdm known 
jean raymond abrial originator little published asm early form 
researchers continued develop apply oxford university published number books 
development method associated vdm undergoing british international standardization 
development methods include applied stack implementations high level programming language chip design gy 
text books area include em em 
publications bj jon jon 
see example proceedings vdm symposia pt pt 
located conference proceedings published bpt 
treatments evolved include hay spi spi 
key technical problem way large specifications built components 
clear bg provides valuable starting point problem area active research disagreement 
controversies history controversies extent confused issue really done development method dlp example asserts concept proof mathematics misunderstood program verification 
acceptance proofs mathematics argued social process putative proofs subjected public scrutiny lengthy detailed logical derivations justify steps development programs quite mathematical proofs 
criticism discern truth argument debate sparked article mainly concerned extent position attacked straw man way active scientists thinking 
fact structuring program design justifiable steps usefully compared level normal mathematical proof 
incentive critical applications check tedious detail subsidiary lemmas cross check residual errors 
message hidden need structure knowledge computing science 
ole johan dahl people appreciate formal development programs progress knowledge accumulated application form theories 
papers dah jon hold hope real structuring knowledge computing ideas knowledge evolve way mathematical theories built time 
late violent debate correspondence pages cacm caused fet title program verification idea suggests casts doubt enterprise verifying programs 
interesting point raised debate reasoning algorithm tells outcome program run machine 
attack pinpoints potential weaknesses recall earliest orts apply formalism aimed languages development compilers precisely clear researchers task verifying programs language undermined compilers language contained errors 
furthermore realization compiler developed assumptions meaning instructions object machine led scientists apply verification ideas design hardware 
course remain danger physical failure hardware far undetected errors concerned devices far reliable mechanical systems 
point simply aware absolute reliability unattainable hope message understood devise weapon systems fact serious issue probably received little attention spite having raised verification community 
probably biggest danger claims verification mol 
seen guarantee fitness purpose repeat theoretically possible prove listed assumptions program satisfies formal specification 
formal text specification useful issue susceptible mathematical argument 
issues indicated issues relate program verification explored detail basic theory sequential programs 
section touches issues secondary literature cited order provide pointers fields 
concurrent programs sequential programs considered run isolation 
reality rarely case modern computers resources machine shared programs operating system part task provide illusion isolation 
operating system member interesting class programs concurrency issue 
class programs contains important society 
example programs handle airline seat reservations handle messages agents negotiating resource places flights 
area di culty comes concurrent programs respond particular times stimuli come physical sensors 
stay field programs control aircraft landing class 
concurrent real time programs extremely di cult design public aware flaws news items delayed launches space shuttle 
confined programming clear incentive apply formality process designing complex hardware area ability handle concurrency essential 
example operating system suggests concurrency best confined kernel programs systems built large parts designed assumption isolation 
leaves core concurrent programs design 
cacy testing inadequate way ensuring correctness sequential programs reduced fact running program twice give di erent results depending happens environment 
formal methods verifying concurrent programs vitally important 
unfortunately consensus evolved best handle concurrency 
part certainly due diverse nature tasks covered seen symptom field trying find tractable methods 
identify key 
edsger dijkstra major impact research concurrent systems 
early design operating system led understand necessity careful arguments correctness prolific sources challenge problems 
example style contained dij uses semaphores order control concurrent processes 
dijkstra privately circulated series notes posing challenges provided crucial stimulus concurrency research 
science asking right questions people solving problems 
clearest paths development making concurrent programs tractable seen hoare 
semaphores low level device controlling concurrency adequate achieve particular ect lack structure way checking properly 
hoare conditional critical sections hoa monitors hoa progressively richer constructs structure rules certain sorts potential error 
hoare concept monitor implemented programming language pascal plus 
language constructs intended harness shared variable concurrency programs interfere changing common variables 
hoare step language called communicating sequential programs csp hoa variables shared processes 
represents larger discontinuity csp seen step path increasing structure concurrency tractable 
communication processes handled synchronous message handling interference processes disappeared manifests terms di ering results interactions 
hoare contribution illustrative pretend done vacuum 
fact development monitor idea closely paralleled brinch hansen see bh bh 
robin milner ccs calculus communicating systems mil key respects similar csp ccs designed programming language 
milner writes private communication december designing ccs calculus eye algebraic theory aiming small repertoire theoretical constructions hit notion synchronized communication hoare proposed csp means control proliferation programming constructions 
agreement di erent viewpoints encouraging 
extensive research ccs focussed notions observational equivalence agents processes 
park proposed important concept bisimulation par 
development methods designing concurrent programs bears interesting resemblance sequential cousins 
methods initially explained post facto proofs mind ideas evaluated see form basis development methods 
observation fail yield usable development methods concurrent systems 
problem compositionality 
relatively simple completely characterize sub components executed isolation interfering programs di cult specify way facilitates separate development 
description csp hoa 
see bh bh 
revised rewritten mil 
am available stanford report february fact processes interfere states reflected constructing equivalent non deterministic sequential program needs number assertions related exponentially size programs 
approach way compositional correctness processes considered final code available 
susan owicki wrote thesis supervision david gries 
owicki thesis broke task verifying concurrent programs stages treats sequential programs second checks proof process interfered statements process vice versa 
meant meaningful verification conducted separately clear called owicki gries method leaves open risk development meets requirements discarded detailed code designed case interference freedom test 
researchers realized way controlling interference built specifications fp specifies interference development method sense suggested jon uses rely guarantee conditions provide partial specification interference rely guarantee approach published independently mc 
significant literature developed compositional methods overview dr 
proof methods discussed far nearly classical logic order predicate calculus 
mentioned burstall suggested bur form temporal logic development programs 
appear amir pnueli person suggest temporal logic specifying developing concurrent programs pnu temporal logic framework issue compositionality tackled bkp 
major contributor formalisms concurrency leslie lamport contributions outlined issues safety liveness lam proposed novel temporal logic actions lam 
early attempt formalism operating systems lau 
number putative development methods evolved concurrent programs 
unity method cm widely discussed 
mentioned section parallel systems quite diverse 
contentious issue emerged contrast interleaving true concurrency 
position taken carl adam petri working petri nets pet pet pet 
language semantics separate historical language semantics needs written outline major issues section 
see og related method described lam 
developed jon st 
see hdr 
published journal form pnu 
see lam lam 
useful overview contained 
study languages partitioned syntax semantics pragmatics heinz applied terminology programming languages 
valid strings language suggestion structure defined syntax 
history area little main topic current su ce say adequate method defining syntax programming languages backus naur form employed description algol bbg 
finding ways defining semantics meaning strings challenging 
topic pragmatics pursued 
program programming language user interested running input data determine output result 
interpreter programming language program runs computer interprets statements transform input values output implementations basic interpreters 
translator compiler translates programs language object programs machine language computer object program run translate input output 
ways recording semantics programming languages abstractions interpreters translators 
attempts write formal semantics programming languages interpreters 
performed exactly function interpreters program input values computed output 
written machine language written mathematical functions possible reason 
earliest papers mccarthy mcc describes tiny programming language ideas calvin elgot peter john landin provided basis definitions major programming languages 
major milestone ifip working conference formal language description languages baden bei wien proceedings ste capture key discussions 
vienna group involved went tackle semantics large complex language pl vienna group called descriptive style universal language definition notation known vienna definition language 
interpreters said give operational semantics language meaning program plus input data program se 
problems description reason implementations language 
definitions way shown mp larger languages papers vienna group luc 
compiler maps programs programming language language denotational semantics maps programs understood set denotations 
denotations mathematical functions input output meaning program discussed independently particular input values 
simplify task proving implementations early view see gor 
background ibm laboratory vienna see luc luc personal chr pp 
fuller account vienna history planned language semantics 
called npl uk national physical laboratory pointed prior claim acronym see pp 
secondary material includes lw 
general results 
strachey landin lan lan major early steps denotational semantics problems program components denotations functions type domain includes type posed foundational problems solved dana scott 
scott discovered models reflexive domains whilst oxford programming research group led strachey denotational semantics major research topic sco sco sco sco ss sco sto classic exposition 
interestingly vienna group went adopt denotational approach develop vdm bj 
controversy 
peter naur attack formalization nau 
current author cited fair enter discussion controversy 
su ce say naur position early contributions appears formalism tool pursued isolation applications 
advantages denotational definitions mistake assume operational definitions 
considerable technical di culties especially concurrency finding appropriate denotations 
furthermore di culties reasoning operational definitions greatly reduced care exercised avoid unnecessary mechanistic features 
gordon david plotkin proposals structured operational semantics plo provide widely notation describing programming languages 
operational denotational descriptions thought fixing semantics terms sort model 
proposals descriptions programming languages 
fact section covers approach floyd hoare claimed inference rules provide semantics language hoare called axiomatic semantics 
approach avoids need models describe semantics giving sets equivalences texts language 
examples approach include iga db bac rh hhh 
method known algebraic semantics works best language constructs pleasing algebraic properties associativity distributivity 
echo quest tractability design languages 
machine supported verification concept formal proof definable terms symbol manipulation operations surprising theorem proving early task considered machine support key papers include ns mcc wan rob goo db 
spectrum approaches ranging proof checkers attempts write programs discover proofs 
proof checkers easy write require user generate complete detailed proof 
automatic theorem provers non trivial theories impossible build general major challenge artificial intelligence 
best known development heuristics known boyer moore theorem prover bm appears di cult control 
see luc kin citations taken secondary material ed 
researchers sought find balance user controls strategy machine performs symbol manipulation 
influential area lcf mil gmw subsequent systems 
particular interest series prl systems see 
novel languages memory called von neumann computer linear sequence cells bits bytes words programmers map programs data hand 
time considerable progress finding tractable languages construct programs 
languages fortran programmer task easier making possible write program terms named variables addresses linear memory computed compiler 
just example symbol manipulation powers computers employed aid task machines 
small steps away raw interface machine researchers began investigate question radically di erent languages overcome challenge designing programs solve problems 
languages reflect idea store computer changed updating operation known imperative languages updating performed assignment statements 
assignment statements undesirable property called variables program contain di erent values di erent points execution program 
problem compounded languages fortran updating operation written resulting statements nonsense read equations 
time fact program variables behave mathematical variables led series suggestions alternative names 
problems reasoning imperative programs 
seen way problem reason programs assertions 
radical approach ban assignment statements languages purely functional 
hope programs languages easier reason point view strongly bac 
hope easier realize ensuing challenge finding purely functional languages ciently translated machine code 
time writing cient programs written imperative impure functional languages research machine architectures pure functional languages cient question expressing inherently state tasks 
step functional languages ask extent translator logic constructed dream see computer execute specification obviating need design program 
undecidability reasonably powerful logic shows limitations expressiveness logic languages decidable logics propositional calculus unacceptably slow decision procedures 
approach clearly espoused kow defined subset general logic horn clauses useful survey articles cra kem lin 
book see pau 
help translator find cient search strategies adding control information 
cornerstones japanese fifth generation programme machines usable exploiting languages prolog 
appear conviction today approach general solution programming problems clearly role logic languages computing tasks 
development novel non procedural languages gives insight important aspect science computing 
physical science astronomy scientists study reality face nature models match reality 
pure mathematics generate system choosing axioms studying consequences beauty main criterion 
computing 
clear discussion reaction finding class language intractable change language sounds mathematics 
way execute programs physical devices cient design implementations huge engineering task 
true growth capacity performance electronic devices possible trade away machine efficiency results better human ort works linear exponential factors 
computer science progressed developers choosing new abstractions tractable predecessors developing theories match new reality created computer engineering attempts provide cient implementations abstractions 
better example developments relating communication concurrency 
steps away shared variable concurrency languages provided queued message passing km mac hint history process algebras discussed section 
occam inm rh development csp transputers provide architecture language 
see growth theoretical concept realization silicon took decade 
trend development usable languages called object oriented 
genesis dahl nygaard simula language dmn 
languages smalltalk gr ei el mey recognised having potential increase productivity programmers progress studying concurrency framework ame 
text extended version published instituto della la dei program verification 
am grateful richard giordano don ian hayes lee peter lindsay robin milner jose nuno brian randell mike comments drafts fritz bauer martin david cooper bob floyd dick hamlet tony hoare ralph london fred schneider john tucker maurice wilkes heinz input 
project discussed meetings ifip 
brian randell lee drew attention michael mahoney history helped avoid number trivial amateur mistakes 
am survey contained rob alan robinson wrote key rob 
extremely grateful alison painstaking checking bibliographic information achieved current level 
jon lee came rescue faced challenge merging ieee improvements back ach ashcroft clint hoare 
remarks program proving jumps functions 
acta informatica 
am ashcroft manna 
formalization properties parallel programs 
meltzer michie editors machine intelligence pages 
edinburgh university press 
ame america 
issues design parallel object oriented language 
formal aspects computing 
apt apt 
years hoare logic survey part acm transactions programming languages systems 
apt apt 
years hoare logic survey part ii nondeterminism 
theoretical computer science 

abrial 
non deterministic system specification 
kah pages 
asm 
abrial meyer 
specification language 
editors construction programs pages 
cambridge 
avr avron 
natural valued logics characterization proof theory 
journal symbolic logic march 
bac backus 
programming liberated von neuman style functional style algebra programs 
communications acm 
bac back 
correctness preserving program refinements proof theory applications 
technical report mathematisch centrum tract 
bac backhouse 
program construction verification 
prenticehall international 
bbg backus bauer green katz mccarthy naur perlis van wijngaarden 
revised report algorithmic language algol 
communications acm 
bekic bjrner jones lucas 
formal definition pl subset 
technical report ibm laboratory vienna december 
barringer cheng jones 
logic covering undefinedness program proofs 
acta informatica 
bd burstall darlington 
transformation system developing recursive programs 
journal acm 
bekic 
programming languages definition volume lecture notes computer science 
springer verlag 
bg burstall goguen 
informal specifications clear 
bm pages 

bh brinch hansen 
concurrent pascal programming language operating system design 
technical report information science cal tech april 
bh brinch hansen 
programming methodology operating system design 
rosenfeld editor information processing pages 
proceedings ifip 
bh brinch hansen 
programming language concurrent pascal 
ieee transactions software engineering june 
bh brinch hansen 
distributed processes concurrent programming concept 
communications acm 
bjrner hoare langmaack editors 
vdm vdm formal methods software development volume lecture notes computer science 
springer verlag 
bj bjrner jones editors 
vienna development method meta language volume lecture notes computer science 
springer verlag 
bj bjrner jones 
formal specification software development 
prentice hall international 
bjrner jones mac neuhold editors 
vdm formal definition volume lecture notes computer science 
springer verlag 
bkp barringer kuiper pnueli 
compose temporal logic specification 
proceedings th acm stoc pages washington april may 
bla 
partial valued logic 
phd thesis oxford university 
bli 
valued predicates software specification validation 
pages 
bm boyer moore 
computational logic 
academic press 
bm boyer moore 
correctness problem computer science 
international lecture series computer science 
academic press london 
bloomfield marshall jones editors 
vdm vdm way ahead volume lecture notes computer science 
springer verlag 
bpt blum paul editors 
mathematical studies information processing volume lecture notes computer science 
springer verlag 
bur burstall 
proving properties programs structural induction 
computer journal 
earlier available experimental programming report edinburgh 
bur burstall 
program proving hand simulation little induction 
rosenfeld editor information processing pages 
proceedings ifip 
bw bekic walk 
formalization storage properties 
editor eng pages 

bw bauer 
algorithmic language program development 
springer verlag 
constable implementing mathematics nuprl proof development system 
prentice hall 

de roever 
assertional data reification proofs survey perspective 
morris shaw editors th refinement workshop pages 
springer verlag 
ch clint hoare 
program proving jumps functions 
acta informatica 
che cheng 
logic partial functions 
phd thesis university manchester 
chr editor 
heinz ein 
oldenbourg 
cip cip language group 
munich project cip volume wide spectrum language cip volume lecture notes computer science 
springer verlag 
cip cip system group 
munich project cip volume ii program transformation system cip volume lecture notes computer science 
springer verlag 
cj cheng jones 
usability logics handle partial functions 
morgan woodcock editors rd refinement workshop pages 
springer verlag 
cm chandy misra 
parallel program design foundation 
addison wesley 
coo cooper 
equivalence certain computations 
bcs computer journal 
coo cooper 
mathematical proofs computer programs 
collins michie editors machine intelligence pages 
boyd 
cra craigen 
technical review verification systems rm fdm revised special 
technical report fr sharp associates august 
dah 
dahl 
program proving practical 
editors eec crest course programming foundations pages 

printed technical report institute informatics university oslo 
dar darlington 
semantic approach automatic program improvement 
phd thesis university edinburgh 
dav davis 
undecidable 
raven press 
db de bakker 
axiomatics simple assignment statements 
technical report mathematisch centrum amsterdam june 
db de bakker 
semantics programming languages 
tou editor advances information systems science volume pages 
plenum press 
db de bruijn 
mathematical language automath usage extensions 
symposium automatic demonstration volume lecture notes mathematics pages 
springer verlag 
db darlington burstall 
system automatically improves programs 
acta informatica 
db de bakker 
mathematical theory program correctness 
prentice hall international 
dbs de bakker scott 
theory programs 
manuscript notes ibm seminar vienna august 
ddh 
dahl dijkstra hoare editors 
structured programming 
academic press 
dij dijkstra 
constructive approach problem program correctness 
bit 
dij dijkstra 
cooperating sequential processes 
editor programming languages pages 
academic press new york 
dij dijkstra 
go statement considered harmful 
communications acm 
dij dijkstra 
short art programming 
eindhoven 
dij dijkstra 
humble programmer 
communications acm 
dij dijkstra 
guarded commands formal derivation programs 
communications acm 
dij dijkstra 
discipline programming 
prentice hall 
dlp demillo lipton perlis 
social processes proofs theorems programs 
communications acm may 
dmn 
dahl nygaard 
simula common base language 
technical report norwegian computing center oslo 
don donahue 
complementary definitions programming language semantics 
technical report csrg university toronto canada november 
dr 
de roever 
recursion parameter mechanisms axiomatic approach 
editor automata languages programming volume lecture notes computer science 
springer verlag 
dr 
de roever 
call value versus call name proof theoretic comparison 
technical report iw mathematical center amsterdam september 
dr 
de roever 
dijkstra predicate transformer nondeterminism recursion termination 
technical report university rennes 
dr 
de roever 
quest compositionality survey assertion proof systems concurrent programs part concurrency shared variables 
nc pages 
ds dijkstra scholten 
predicate calculus program semantics 
springer verlag 
em ehrig mahr 
fundamentals algebraic specification equations initial semantics 
eatcs monographs theoretical computer science 
springer verlag 
em ehrig mahr 
fundamentals algebraic specification module specifications constraints 
eatcs monographs theoretical computer science 
springer verlag 
eng 
symposium semantics algorithmic languages 
number lecture notes mathematics 
springer verlag 
ers ershov 
theory program schemata 
editor information processing volume pages 
northholland 
proceedings ifip 
ers ershov 
origins programming discourses methodology 
springer verlag 
original russian 
eva evans 
syntax analysis production language 
phd thesis carnegie institute technology 
fet fetzer 
program verification idea 
communications acm 
fh foley hoare 
proof recursive program quicksort 
bcs computer journal november 
flo floyd 
assigning meanings programs 
proc 
symp 
applied mathematics vol mathematical aspects computer science pages 
american mathematical society 
fp francez pnueli 
proof method cyclic programs 
acta informatica 
gch cohen hoch hunter hare 
report language version 
technical report cmp university texas austin september 
guttag horning wing 
larch easy pieces 
technical report dec src july 
gmw gordon milner wadsworth 
edinburgh lcf volume lecture notes computer science 
springer verlag berlin 
goo 
realization program proving system 
phd thesis university wisconsin 
gor 
common programming language task final report 
ad ur 
contract 
da sc da proj 
pr elc part section logical design formal mixed languages 
gor 
specification languages mechanical languages processors baker dozen 
communications acm 
gr goldberg robson 
smalltalk language implementation 
addison wesley 
gri gries editor 
programming methodology collection articles members ifip 
springer verlag 
gri gries 
science programming 
springer verlag 
goguen thatcher wagner wright 
initial algebra semantics 
technical report rc ibm yorktown heights january th 
goguen thatcher wagner wright 
initial algebra semantics continuous algebras 
journal acm 
gut guttag 
specification application programming data types 
phd thesis university toronto computer systems research group september 
csrg 
von neumann 
planning coding problems electronic computing instrument 
part ii vol 
report prepared army ord 
dept republished pages tau 
gy young 
mathematical methods digital systems development 
pt pages 
hay hayes editor 
specification case studies 
prentice hall international 
hdr 
de roever 
quest goes survey proof systems partial correctness csp 
de bakker 
de roever rozenberg editors current trends concurrency volume lecture notes computer science 
springer verlag 

logic programming 
prentice hall international 
hes hull 
correctness numerical algorithms 
acm sigplan notices january 
hhh hoare hayes morgan roscoe sanders spivey 
laws programming 
communications acm 
see ibid 
hhs hoare sanders 
data refinement refined resume 
robinet wilhelm editors esop volume lecture notes computer science pages 
springer verlag 
hj hoare jones editors 
essays computing science 
prentice hall international 
hl hoare lauer 
consistent complementary formal theories semantics programming languages 
acta informatica 
hoa hoare 
algorithm partition algorithm quicksort algorithm find 
communications acm july 
hoa hoare 
axiomatic basis computer programming 
communications acm october 
hoa hoare 
procedures parameters axiomatic approach 
editor eng pages 

hoa hoare 
proof program find 
communications acm january 
hoa hoare 
proof structured program sieve eratosthenes 
computer journal november 
hoa hoare 
proof correctness data representations 
acta informatica 
hoa hoare 
theory parallel programming 
hoare editors operating system techniques pages 
academic press 
hoa hoare 
monitors operating system structuring concept 
communications acm october 
hoa hoare 
communicating sequential processes 
communications acm august 
hoa hoare 
communicating sequential processes 
prenticehall 
hod hodges 
alan turing 
burnett books 
vintage edition 
hoo 
partial predicate logic computer science 
acta informatica 
hw hoare wirth 
axiomatic definition programming language pascal 
acta informatica 
iga igarashi 
axiomatic approach equivalence problems algorithms applications 
phd thesis university tokyo 
reprinted report computer centre university tokyo 
inm inmos 
occam manual 
prentice hall 
jon jones 
technique showing functions preserve relation domains 
technical report lr ibm laboratory vienna april 
jon jones 
formal development correct algorithms example earley recogniser 
acm sigplan notices january 
jon jones 
formal development programs 
technical report ibm laboratory april 
jon jones 
implementation bias constructive specification objects 
unpublished manuscript september 
jon jones 
constructing theory data structure aid program development 
acta informatica 
jon jones 
software development rigorous approach 
prentice hall international 
jon jones 
development methods computer programs including notion interference 
phd thesis oxford university june 
printed technical monograph 
prg 
jon jones 
specification design parallel programs 
mason editor information processing pages 
north holland 
jon jones 
systematic software development vdm 
prentice hall international 
jon jones 
vdm proof obligations justification 
pages 
springer verlag 
jon jones 
data reification 
mcdermid editor theory practice refinement pages 
butterworths 
kah kahn editor 
semantics concurrent computation proceedings france volume lecture notes computer science 
springer verlag berlin 
kem kemmerer 
verification assessment study final report volume overview directions 
technical report cr library 
national computer security center maryland usa march 
kin king 
program verifier 
phd thesis department computer science carnegie mellon university 
km kahn macqueen 
coroutines networks parallel processes 
editor information processing pages 
kow kowalski 
algorithm logic control 
communications acm 
ktb tarlecki 
valued logic software specification validation 
pages 
lam lamport 
proving correctness programs 
ieee transactions software engineering 
lam lamport 
hoare logic concurrent programs 
acta informatica 
lam lamport 
control predicates better dummy variables reasoning program control 
acm transactions programming languages systems april 
lam lamport 
temporal logic actions 
technical report dec src 
lan landin 
mechanical evaluation expressions 
computer journal 
lan landin 
correspondence algol church lambda notation 
parts ii 
communications acm 
lau lauer 
consistent formal theories semantics programming languages 
phd thesis queen university belfast 
printed tr ibm lab 
vienna 
lau lauer 
correctness operating systems 
phd thesis carnegie mellon university 
london guttag horning lampson mitchell popek 
proof rules programming language euclid 
acta informatica 
lin lindsay 
survey mechanical support formal reasoning 
software engineering journal january 
lon london 
computer program discovering proving sequential recognition rules formed formulas defined backus normal form grammar 
phd thesis carnegie institute technology 
lon london 
correctness proof fisher algorithm inductive assertions 
technical report university wisconsin computer sciences dept october 
lon london 
experience inductive assertions proving programs correct 
technical report university wisconsin computer sciences dept may 
lon london 
proof algorithms new kind certification 
communications acm 
lon london 
proving programs correct techniques examples 
bit 
lon london 
correctness compilers lisp subset 
technical report cs computer science dept stanford university october 
lpp luckham park paterson 
formalised computer programs 
journal computer system sciences 
luc luckham 
resolution principal theorem proving 
collins michie editors machine intelligence pages 
boyd 
luc lucas 
constructive realizations block concept equivalence 
technical report tr ibm laboratory vienna june 
luc lucas 
semantics programming languages software devices 
rus pages 

luc lucas 
formal semantics programming languages 
ibm journal research development september 
luc lucas 
vdm origins hopes achievements 
pages 
luk lukasiewicz 
valued logic 

lw lucas walk 
formal description pl volume part annual review automatic programming 
pergamon press 
mac macqueen 
models distributed computing 
technical report inria france april 
man manna 
termination algorithms 
phd thesis university april 
man manna 
mathematical theory computation 
mcgraw hill 
mc misra chandy 
proofs networks processes 
ieee transactions software engineering 
mcc mccarthy 
programs common sense 
conference mechanization thought processes 
mcc mccarthy 
recursive functions symbolic expressions computation machine part communications acm april 
mcc mccarthy 
basis mathematical theory computation 
bra ort hirschberg editors computer programming formal systems pages 
north holland publishing 
slightly extended corrected version talk may western joint computer conference 
mcc mccarthy 
mathematical science computation 
editor information processing pages 
north holland 
mcc mccarthy 
formal description subset algol 
ste pages 
mey meyer 
object oriented software construction 
prentice hall 
mil milner 
di culty verifying program unnatural data representation 
technical report computation services dept university college swansea january 
mil milner 
formal notion simulation programs 
technical report department computer science university college swansea october 
mil milner 
algebraic definition simulation programs 
technical report cs computer science dept stanford university february 
mil milner 
program simulation extended formal notion 
technical report university college swansea april 
mil milner 
logic computable functions description machine implementation 
technical report stan cs computer science department stanford university may 
mil milner 
calculus communicating systems volume lecture notes computer science 
springer verlag 
mil milner 
communication concurrency 
prentice hall 
mj morris jones 
early program proof alan turing 
annals history computing april 
mm manna mccarthy 
properties programs partial function logic 
meltzer michie editors machine intelligence pages 
edinburgh university press 
mol moller 
formal derivation pointer algorithms 
broy editor informatik und mathematik pages 
springer verlag 
mor morris 
advice compilers proving correct 
acm symposium principles programming languages pages 
acm 
mor morris 
types sets 
acm symposium principles programming languages pages 
acm october 
mor morgan 
programming specifications 
prentice hall 
mp mccarthy painter 
correctness compiler arithmetic expressions 
technical report cs computer science department stanford university april 
see pages proc 
symp 
applied mathematics vol mathematical aspects computer science american mathematical society 
nau naur 
proof algorithms general snapshots 
bit 
nau naur 
programming action clusters 
bit 
nau naur 
concise survey computer methods 

nau naur 
formalization program development 
bit 
nc neuhold 
formal models programming 
north holland 
proceedings ifip tc working conference role models information processing 
vienna austria january february 
nip nipkow 
behavioural implementation concepts nondeterministic data types 
phd thesis university manchester 
reprinted umcs may 
nip nipkow 
non deterministic data types models implementations 
acta informatica 
ns newell simon 
logic theory machine 
ire transactions information theory pages 
og owicki gries 
axiomatic proof technique parallel programs acta informatica 
owicki 
axiomatic proof techniques parallel programs 
phd thesis department computer science cornell university 
published technical report 
par park 
fixpoint induction proofs program properties 
meltzer michie editors machine intelligence pages 
edinburgh university press 
par park 
concurrency automata infinite sequences 
theoretical computer science th gi conference karlsruhe march number lecture notes computer science pages 
springer verlag 
par 
specification transformation programs formal approach software development 
springer verlag 
pat paterson 
equivalence problems model computation 
phd thesis university cambridge 
pau paulson 
logic computation interactive proof cambridge lcf 
cambridge university press 
pet petri 
kommunikation mit 
phd thesis university darmstadt 
pet petri 
prozesse 
technical report isf gmd bonn 
pet petri 
non sequential processes 
technical report isf gmd bonn 
translation isf 
plo plotkin 
structural approach operational semantics 
technical report daimi fn aarhus university 
pnu pnueli 
temporal semantics concurrent programs 
tel aviv university 
pnu pnueli 
temporal semantics concurrent programs 
theoretical computer science 
pt editors 
vdm formal software development methods 
vol conference contributions volume lecture notes computer science 
springer verlag 
pt editors 
vdm formal software development methods 
vol tutorials volume lecture notes computer science 
springer verlag 
ran randell 
origins digital computers selected papers 
springer verlag second edition 
rey reynolds 
craft programming 
prentice hall international 
rh roscoe hoare 
laws occam programming 
technical report prg oxford university computing laboratory programming research group 
rob robinson 
machine oriented logic resolution principle 
journal acm 
rob robinson 
logic logic programming 
communications acm march 
rozenberg 
advances petri nets volume lecture notes computer science 
springer verlag 
rus 
formal semantics programming languages 
prenticehall 
courant computer science symposium september 
rut rutledge 
program schemata 
journal acm january 
sa anderson 
algorithm synthesis comparative study 
springer verlag 
sco scott 
existence description formal logic 
editor bertrand russell philosopher century pages 
allen unwin 
sco scott 
construction model calculus 
manuscript november 
sco scott 
models calculus 
manuscript draft december 
sco scott 
outline mathematical theory computation 
technical report prg oxford university computing laboratory programming research group november 
sco scott 
simplified construction calculus models 
manuscript april 
sco scott 
data types lattices 
technical report prg oxford university programming research group september 
reprinted siam journal computing volume pp 
manuscript version dated 
spi spivey 
understanding specification language formal semantics 
cambridge tracts computer science 
cambridge university press 
spi spivey 
notation manual 
prentice hall international 
ss strachey scott 
mathematical semantics simple languages august 
read princeton 
ste steel 
formal language description languages computer programming 
north holland 
sto stoy 
denotational semantics scott strachey approach programming language theory 
mit press 
st 
development parallel programs shared datastructures 
phd thesis manchester university 
published technical report umcs 
str strachey 
systems analysis programming 
scientific american september 
tar tarlecki 
language specified programs 
science computer programming 
tau editor 
john von neumann collected works volume design computers theory automata numerical analysis 
pergamon press 
tur turing 
computable numbers application entscheidungsproblem 
proceedings london mathematical society series 
correction published ibid 
tur turing 
checking large routine 
report conference high speed automatic calculating machines pages 
university mathematical laboratory cambridge june 
vw van wijngaarden 
numerical analysis independent science 
bit 
text talk 
wan wang 
mechanical mathematics 
ibm journal research development 
richard wexelblat editor 
history programming languages 
academic press 
wil wilkes 
memoirs computer pioneer 
mit press 
wir wirth 
systematic programming 
prenticehall 
wir wirth 
algorithms data structures programs 
prenticehall 
yan 
logical algorithm schemata 
problems cybernetics 

semiotics programming languages 
communications acm 

formalization history 
newcastle ibm seminar 
zilles 
specifications data types 
technical report progress report 
zuse 
der computer 
springer verlag 

compositionality concurrency partial correctness proof theories networks processes relationship 
phd thesis technical university eindhoven 
available lncs springer verlag 

