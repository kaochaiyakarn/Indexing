design implementation pjava submitted pos atkinson jordan spence design issues persistent java type safe object oriented orthogonally persistent system atkinson jordan spence february object oriented programming language java receiving attention popular commercial programming language regular structure safety features modern constructs 
presents novel opportunity safety potential popularity orthogonal persistence defined reachability widely available 
report design system provides persistence changes java language 
design includes ambitious goals transactional flexibility includes simple transactional behaviour sufficient applications 
report issues encountered design obvious solution 
outline proposed implementation 
report issues raised designing addition implementation orthogonal persistence java language 
principles orthogonal persistence known atkinson morrison 
orthogonally persistent language ps algol atkinson conceived order add persistence existing language minimal perturbation initial semantics implementation 
efforts build persistent system java similar motivation 
primary concern show orthogonal persistence achieved beneficial impact programmer productivity 
seek achieve broader set facilities supported language demonstrate orthogonal persistence beneficial large commercial programming projects 
typically projects currently built languages relational object oriented databases 
reports steps experiment show construction maintenance persistent application systems pas supported effectively orthogonally persistent language 
support general purpose orthogonally persistent system java language gosling gosling 
system called pjava 
evaluate pjava re coding pjava pas developed supported oodb jordan 
requires prototype persistent java runtime called pjava superseded complete robust engineered run time called pjava measurement experience version pas running pjava provide design data pjava goals pjava design pjava seeks provide orthogonally persistent system meets goals 
loss safety utilising persistence ideally increase consistency 
impact performance programs persistence minimum performance penalties possible performance gains 
minimal changes language 
simple subliminal persistence programmers satisfied default model transactions 
sophisticated precise control transactional programming require 
orthogonal persistence requires values type class equal rights longevity brevity 
longevity requires adequate mechanisms recovery software media failure adequate facilities system evolution 
persistence permits arbitrary data 
java trademark sun microsystems design implementation pjava submitted pos atkinson jordan spence structures preserved execution re executions 
data structures include bindings set verifying compliance java type rules safety mechanisms available re subsequent executions re applying checks 
re uses results earlier executions may provide performance gains 
goal met entirety changes required language definition 
new classes provided java machine jam modified order provide orthogonal persistence transactional facilities 
goal derives desire transition persistent programming easy 
goal supports expert programmers may want satisfy users requiring particular forms transaction design experiments cscw features java relevant pjava java language currently receiving attention osf 
provides golden opportunity increase industrial experience orthogonal persistence investigate feasibility benefits orthogonal persistence wider range applications may expected grow larger current generation pass built commercially 
java particularly suited care designers taken safe gosling type system defined rigorously enforced pointers space managed implicitly java machine explicitly application programmer 
existence native methods written threatens safety excluded contexts kept away persistent stores 
class loader performs dynamic binding necessary enable new code access persistent data code atkinson performs security checks restrict code required safety levels 
offers safe incremental construction large pass 
type system determines range values pjava support nice combination simplicity regularity completeness achieved powerful type constructor rules 
base types similar exception booleans properly differentiated pointer types 
constructors class interface array denoted 
class constructor implements single inheritance provides definition set labelled attributes class combination properties public protected private package determining visibility outside class definition visibility modifier provided default package protection assumed visible classes package static dynamic determining value associated class instance class method value determining code associated attribute final prevents attribute case static variables updated base type constructed type determining internally pointer represent value denotes synchronized indicates threads refused access object class attribute property transient defined reserved field modifier language definition allocated function interfaces provide general mechanism polymorphism 
define signature set object attributes 
class includes attributes defined irrespective attributes offers context requires interface type 
extensive growing library classes available existing java system 
treated specially implementation orthogonal persistence implemented java perform operations relevant persistence 
ignore modifier transient suspect designers java intend indicate fields object set null object stabilised reconstructed 
support semantics provide restoration call backs reconstructing derived data labelled way 
design implementation pjava submitted pos atkinson jordan spence class class classes instances class contain definition classes provide access method code thread class represents independent thread execution may run concurrently threads lock providing explicit locking implicit mutex provided synchronized insufficient variety classes concerned io screen management features java packages relevant design implementation discussed 

design issues pjava section presents issues encountered design pjava 
principles desiderata principles established orthogonal persistence atkinson atkinson morrison naturally re applied context follows 
principle orthogonality states values type equal rights persistence longevity brevity 
context need identify carefully constitutes values 
clearly base types values language constructed base types included 
naturally includes objects arrays design includes classes code 
jam treats instances class class specially having special loading rules different storage arrangements 
argue instances class treated identically persistence purposes classes object stable store guarantee code manipulate available see 
treating classes consistently data results pjava store self contained self describing 
particular sufficient information garbage collection schema edit 
compared oodbms incomplete information contents particularly making persistent usually forced treat class definitions schema code separately specially 
principle persistence independence states code form irrespective longevity data acts 
implies example transfers explicitly programmed 
essence persistence independence achieved pjava code semantics language vary consequence variations longevity data 
principle persistence identification states straightforward consistent mechanism determining longevity values 
pjava values object instances base type values attributes object instance static variables behave attributes instances class class 
identifying persistence reduces identifying long object instance persist attributes instances persist 
maintain pointer space management safety java reachability atkinson morrison 
pjava ensures objects continue exist long transitively reachable distinguished persistent root store instance class pjavastore additional considerations influenced design safety may compromised persistence 
pointed safety java essential foundation security osf invaluable programmer productivity 
type pointer safety compromised way pjava 
natural consequence applying principle persistence independence 
separation policy mechanism recognised desirable operating system design rashid 
operating system context generally achieved allowing system programmers supply code defines policy 
application programmers expected provide code finer grained mechanisms programming language implementation unacceptably costly frequent referrals application code 
policies 
pjava store program run instance pjavastore visible time 
design implementation pjava submitted pos atkinson jordan spence predetermined pjava meet goal general purpose 
compromise achieved building mechanisms modifiable storing classes stable store example allowing application programmer control issues re initialisation recovery form transactions take 
application programmers burdened supplying code default policies provided 
default meet application needs application programmer need supply policy defining code 
stores orthogonal persistence pjava program normally started conjunction existing populated stable store specified environment variable command line parameter default similar mechanism 
exceptional circumstances pjava may create new empty stable store populate 
certain objects classes needed implementation persistence consequently stable store default 
pjava store contain object class pjavastore class instance containing static variables code manipulate pjavastore object 
pjava arranges pjavastore object class instance accessible code executing pjava program 
objects classes faulted needed 
mentioned pjavastore root persistence reachability stable store contains 
method aname anobject pjavastore anobject behave persistent root 
re accessed normally subsequent executions aname 
objects reachable anobject preserved 
objects reachable result accessible object faulting data structures traversed standard repertoire java operations 
mechanism enables programmer graph objects values contain lifetime extending current execution 
objects retained long reachable pjavastore registered 
life terminated subsequent program executions unreachable 
may occur assignment objects graph replacing object null 
may occur connection index severed call aname space eventually recovered garbage collection 
operations persistent roots available test exist obtain names methods associated pjavastore described 
full details pjavastore methods pjava system may atkinson 
classes code object instance class persistent necessary ensure information may needed operate isn persistent simultaneously persist 
additional information includes class super classes class methods objects reachable static variables classes current values fields including derived super classes 
illustrated class extends private private static public 
new persistent classes values fields persistent 
promotion algorithm recurse additional classes values objects classes persistent reached 
index classes persistent maintained pjavastore 
methods interrogate index method may provided remove class longer instances 
subsequent execution runtime system ensures methods associated super classes run extends guarantee safety java gives execution multiple executions 
checks verifications performed compiler class loader validated code stored ensure code operate original guarantees integrity persistent design implementation pjava submitted pos atkinson jordan spence life 
benefits safety costs 
additional benefits include avoiding repeated checks re utilising optimisations introduced earlier executions 
schema collection class definitions store grow incrementally new classes needed application 
aspects schema evolution support platform evolution need special support 
example special loader needed replace method code revised code repair bug 
additional mechanisms needed alter class definition ways new fields new methods changed signatures methods provided pjava initially pas implementors achieve effects store re builds 
stabilisation initialisation restoration global stabilisation durability stabilisation process ensuring data durable 
successful stabilise data concerned available restart subsequent software failure 
available media failure depends number redundant copies data extent media failure 
section default form stabilisation global stabilisation discussed 
partial stabilisation snapshots see 
call pjavastore method achieve global stabilisation 
ensures changes start pjava program execution previous stabilise durable 
objects brought stable store modified new objects reachable modified objects classes introduced new objects written atomically disk 
call simply mutates instance pjavastore 
pjavastore object modified object registered root object start graph possibly new reachable objects 
default transactional behaviour default transactional behaviour pjava implicit call successfully terminating program 
program fails handle exception terminate unsuccessfully leave stable store unchanged unhandled exception default equivalent transaction abort 
pjava program behaves default single transaction stable store associated 
object preserved stabilise holds state completed stabilise 
state determines values object variables reloaded subsequent execution 
pjava object may static variables effectively variables associated instance object class 
issues arising static variables name suggests static variables initialised class loaded program execution java 
pjava see need different semantics static variables persistently static variables initialised class loaded pjava program migrated stable store transiently static variables re initialised original initialisation code time execution pjava causes brought stable store 
example requiring variable persistently static form occur pas issues part numbers 
class part need static variable hold issued part number 
method increment issue part number 
part number variable re initialised time pjava program run instances class part sequences part numbers re issued repeatedly 
example requiring transiently static form consider application charges operations applied instances particular class 
start variable holding accumulated charge initial value time charge applied customer 

ize spelling form identifiers introduced pjava consistent java 
result habit ise form text forms usually correct english spellings 
design implementation pjava submitted pos atkinson jordan spence pjava supports forms 
default static variables persistently static 
supports constants described java static final variables 
contemplated allowing programmers register pjavastore classes transiently static 
led unresolved concern relationship classes reflected static re initialisation sequence 
example suppose classes specialisations class class specialisation class suppose application programmer includes register transiently static classes 
implications classes 
example classes transiently static inconsistency result automatic registration exception raised 
considerations led application programmers decide call backs described 
recovery initialisation call backs pjava allows application programmer specify recovery initialisation behaviour 
java pjava execution ultimately calls main method class specified command line 
call pjava run recovery code previous execution pjava terminated unsuccessfully system media failure final stabilise 
main pjava run arbitrary sequence call backs supplied pas programmer 
pas emphasised call backs supplied previous successful execution 
ways setting sequence restoration call backs 
involve calling methods pjavastore 
method rc allows application programmer provide sequence rc call backs replace previous sequence 
call backs called pjava runtime order supplied array 
method rc class provides sequence call backs specified class 
applied order execution class loaded global call backs 
methods provided obtain previous settings sequences 
call backs may implementation interface 
called parameter indicates pjava performing restore normal restart retry 
restore occurs incomplete stabilise media failure 
retry occurs previous attempt bootstrap call back raised unhandled exception tried perform operation allowed call back sequence 
call backs purposes examples 
verify certain consistency constraints hold store report administrator warn user abort execution 
call backs kind accumulate successive classes defined may generated design tools 
establish extent previous execution completed task 
create transient structures derivable stored structure 
display visualisation data derived stable store suit current user context 
allow refinements initialisation policy static variables 
permit application team develop sophisticated virtual machine top pjava initialise state working entirely pjava 
transactions pjava major issues considered design flexible transaction model pjava threads transactions compose simple interface programmers predefined transaction models primitives best support programmers defining new transactional models 
transactions threads order code written independently compose properly necessary nested transactions supported 
package may written transactions 
package 
observe field modifier transient conjunction static indicate static variable 
design implementation pjava submitted pos atkinson jordan spence package transactions directly compose correctly understandable reasonable semantics 
initially considered restrictive regimes constraining transaction single thread 
sight appears simplify pjava programming model possible restricted models suffer drawbacks prohibit code reasonable allow surely generate problems independently written code combined 
example consider transaction required obtain edit complex value 
value displayed forms simultaneously different windows allow user changes form visualise views manipulation graphical textual view semantic data model schema 
edits feedback organised terms operating threads 
edit transaction 
hand thread supporting long editing session run series transactions user choose secure far 
similarly expect code package may utilise threads utilise transactions composition pjava programs requires transaction may contain threads thread may contain sequence possibly nested transactions 
issue fully resolved 
principle parsimony language design appears violated 
transactions threads support concurrent operations 
nuance thread model concerned programming programmers understanding set cooperating threads interactions transactional model concerned programming programmers aware simultaneous activities 
programs get larger programmers able visualise thread interactions write thread safe code protected synchronize explicit locks anyway 
similarly longer transactions supported programmers need supportive constructive interaction transactions 
may eventually prove possible elide thread transaction constructs 
goal minimising perturbations existing constructs currently results constructs 
number application programmers grow consequently number independently written concurrent threads grows mandatory code thread safe 
point replacement threads transactions little execution cost relieve programmers managing locks synchrony 
code pjava run transaction 
encompassing transaction explicitly initiated implicit transaction associated program see 
contentious issue 
means write barrier monitoring updates threads times 
clearly threads useless example thread monitors system clock displays time wish restore previous state restart 
far haven able devise scheme allow non transactional threads doesn potentially breach safety consistency requirements 
apparent wide range transactional behaviours useful different applications bancilhon garcia molina salem pu chrysanthis ramamritham kaiser pu gray reuter kaiser pu 
support transactions pjava experiment test wide range transactions available providing small set primitives composed achieve transactional behaviours 
logical properties compositions explored gruber atkinson 
preliminary studies performance real applications undertaken far 
recursive structure computations modern language java form nested transaction moss rothermel required result program composition calls code contain transactions 
choice nested transaction semantics example effects inner transactions may propagated parents durable top transaction commits may durable immediately sibling concurrency may supported parent child concurrency may available children may constrained lifetime parent may allowed escape 
design implementation pjava submitted pos atkinson jordan spence design supports sibling parent child concurrency rothermel defaults non escaping children durability achieved top level transactions may nested 
primitives provided allow programmer arrange earlier durability escaping transactions 
primitives capable supporting various forms longrunning transactions sagas garcia molina salem 
achieve flexibility class provided 
specialisations class hold definitions transaction management policy transactions run control 
instances specialisations run individual transactions policy 
transactions different policy regimes may executing concurrently predictable behaviour 
specialisations provided initially 
provides typical flat acid transaction model dbms 
expects brief transaction suppresses transaction operations inner transactions 
updates durable releases locks terminal commit provides nested transactions parent child sibling concurrency 
transactions updates durable outermost transactions commit inner transactions undo abort delegate updates locks parents commit 
external transactional api division available transactional facilities external internal api matter convention 
fact transactional facilities available programmers 
need review reliance convention 
intended standard external transactional api provided instances specialisations satisfy application programmers 
api hides implementation details application programmers program methods 
methods allow programmer associate object satisfies runnable interface instance 
code runnable object activated constrained conform transaction model implemented 
programmers methods start execution state execution running aborted completed claim results synchronously asynchronously 
default transactions run synchronously transaction performs start operation suspended initiated transaction completes 
possible launch transactions asynchronously making methods useful 
kill transaction wait individual group transactions achieve certain state completed aborted 
internal transactional api programmers wish define new transactional models defining specialisation sophisticated internal transactional api utilises set transaction building primitives 
instances construct track set objects updated transactions associated 
internal api provides methods creating binding threads particular 
threads associated precisely book keeper 
important functionalities ability snapshot ability delegate updates example capability pass updates parents nested transactions may durable delegate undo updates 
snapshot creation captures state updated set objects basis undo redo operations 
state optionally durable captured guaranteeing continued availability phase commit long transactions similar capability snapshots 
may necessary avail 
concept delegation formally described chrysanthis ramamritham 
design implementation pjava submitted pos atkinson jordan spence able identified set objects accessed thread 
typical specify set objects locks updates delegated transaction 
snapshot produced retain ordering 
possible apply method snapshot perform set updates restore saved state 
implies application intervening snapshots 
undo operation application restore method snapshot correspond redo operation 
snapshot may included set durable formed omitted set 
snapshots may disabled 
snapshot durable disabled permanence acid transaction achieved 
snapshots available programmers wishing build redo undo command set transactional purposes 
transaction represent locks accumulated transactions 
provide mechanism specifying exclusion models default writer readers delegation 
delegation locks similar way delegation updates definition nested transactions example 
normally delegation updates locks occur step may separated example chained transactions transaction commits pass locks updates stabilised gray reuter 
illustrates constructs snapshot may combined 
update operations snapshot operations sn shown execution history 
addition snapshot stabilise shown large arrow 
possible disable sequence snapshots stabilisation performed 
initial snapshot sn formed implicitly created default point roll back 
rollbacks automatically performed thread bound th fails handle exception 
th update th logged including updates threads stacks static local variables internal api complicated external api expect sufficient programmers content default transactional model 
goal allow application programmers easily negotiated ramp increasing transactional sophistication 
evaluation facilities independent application programmers show separation default behaviour external internal apis paid 
reasonably efficient mechanisms support individual primitives known intuition feasible compose tested 
points program may decide rollback crash points program may decide rollback crash hidden initial snapshot point system automatically recovers crash stab crash sn sn sn sn new sn th program execution trace show snapshot operations design implementation pjava submitted pos atkinson jordan spence 
implementation issues space permits brief sketch implementation plans 
pjava requires changes java machine jam java run time special classes provided java listed section 
addition need implement classes pjavastore snapshot 
implemented partly java partly extensions java run time 
tutorial general mechanisms required incrementally load stabilise persistent store persistence reachability atkinson morrison 
nomenclature 
pjava object cache architecture architecture pjava architecture pjava represented 
main features notice 
existing jam disturbed minimally particular garbage collected heap handles uses access transient objects heap retain format standard java 
changes interpreter minimal 
persistence activities handled structures object cache buffer pool 
object object cache addressed jam handles distinct class pcd handle pool garbage collected heap swizzle copy steal wal buffer manager pid class rot object fault pid pjava programmers point view buffer pool object cache manager object cache rvm jam stable store page fault rvm map design implementation pjava submitted pos atkinson jordan spence transient objects 
handles collected resident object table rot 
object cache bootstrapped loading pjavastore class object instances 
objects faulted cache pid rot dereferenced 
objects promoted garbage collected heap allocated new handles rot pids part stabilise 
written stable store disk 
executing java program requires class resident lookup persistent class directory pcd performed 
standard class loading mechanism java class pcd 
buffer pool implemented top rvm satyanarayanan steal policy dirty pages written back commit pages begins final phase stabilisation pin pages long 
objects copied buffer pool object cache faulted copied back buffer pool stabilise updated 
object copying policy chosen increase density active objects object cache cockshott white dewitt moss kim 
swizzling faulting whilst java application programmer viewpoint objects appear directly surface level indirection 
able exploit existing indirection handles faulting swizzling mechanism 
adopted eager indirect swizzling moss objects lazy swizzling arrays methods 
clustered technique described class data 
rationale decisions objects usually small eagerly swizzling allocating handles pointers expected expensive arrays potentially large require excessive handle space processing time remains seen accessed arrays elements accessed code operations class data left unperturbed reconstruct java data structures fault class continuing 
program tries handle need test residence potentially fault object 
soon object faulted object cache pids swizzled point handles rot 
hasn partially swizzled far new handle added rot 
handle rot holds corresponding pid 
swizzling horizon maintained handles objects 
swizzling thread safe necessary ensure threads concurrently fault object images object potentially updated independently 
achieved optimistic policy 
assumed relatively rare threads attempt handle simultaneously 
residency test performed locking 
object non resident object faulting mutex acquired test re performed 
thread finds object non resident thread faulting object 
way residency checks resident objects avoid mutex overhead 
clustered class loading observing napier system morrison find group objects loaded start program 
evasive action phenomena repeated pjava pjavastore object class objects classes depend perform start brought 
require class loaded internal objects related objects loaded avoid residency checks object faults class class implementation 

imposed rvm pjava 
measurements bailey 
design implementation pjava submitted pos atkinson jordan spence avoid repeated object faults internal residency checks classes treated specially 
stabilisation class including internal objects classes objects intimately depends shipped store object 
faulted reverse process reconstructs internal data structures indirect links handles closely associated objects 
generalisation slightly extensive set commonly classes objects achieve fast program initialisation clustering extensive set stable store loading pjavastore object class 
promoting new objects pjava program stabilises new objects garbage collected heap promoted 
performing application java garbage collection scanner handles rot identified having updated stabilise 
copied object cache allocated handles rot 
step allocate pids stable store point size stable store recorded pjavastore object says store ends 
written directly disk single transfer passing rvm 
need put information log stage 
crash occurs stage recovery mechanism behave written store old size pids unallocated updated pjavastore object written back 
pjavastore object updated new size highest pid rvm transaction write back modified objects object cache 
logged 
commits stabilise succeeds new objects visible 
aborts crash occurs modifications objects visible restart 
include change store size new objects ignored 
database load high rate creation new objects 
avoids writing log avoids complex allocation new objects 
believe consequence database load significantly accelerated loss stable store integrity 
features implementation discussed include performance measurements mechanisms introduced 

related section reconsidered revised final submission 
early ps algol atkinson focused providing orthogonal persistence default model transaction stabilisation similar default pjava 
concurrent threads provided cps algol 
potential primitives support flexible transactions discussed 
system napier continued tradition persistent threads foundation transactions munro 
similar scheme tycoon reported matthes schmidt 
systems support pre emptive thread scheduling require thread safe object faulting 
groups considered provision flexible model transactions 
chrysanthis ramamritham chrysanthis ramamritham began formal model commenced study implementation mechanisms martin ramamritham 
morrison stemple proposed partially automated synthesis programs primitive synchronisation stabilisation actions applied context store accepts concurrent overlapping updates stemple morrison munro 
detailed survey analysis utility proposed transactional primitives forming wide range transactions preliminary investigation feasibility previously 
system closest philosophy persistent version standard ml produced project haines 
stabilisation snapshot foundation transactions 
clouds project provides set primitives variety transaction models synthesised ahamad 
systems different primitives languages differ 
insufficient experience available support comparison 
projects underway produce persistent forms java 
far know orthogonal persistence persistence determined reachability 
aim similar levels transactional flexibility unknown 
design implementation pjava submitted pos atkinson jordan spence 
design system pjava 
alternative platform java language provision completely orthogonal persistence data meta data classes code methods 
goals pjava attract wider form persistence support wide range applications 
achieve goals simple transactional model provided default composable primitives provided describing complex transactional behaviour 
normally complex behaviours programmed specialising class 
shells including specialisations standard external api majority application programmers able code ready sophisticated transaction models aware details transaction implementation 
syntax java unchanged minimal changes semantics certain operations 
particular reduction safety afforded java 
envisage pjava mainly server software applets 
example crossword server written pjava crossword presenter applet java 
presenter remote user select crossword view clues user may ask presenter preserve partial solution return 
clues stored server stable store 
users progressed solution increments shipped back stable store preserve 
failure returning occasion user resume earlier puzzle partial solution retrieved store shipped presenter 
communication java applet pjava server protocol available java 
implementation prototype pjava presents default transactional behaviour omits planned optimisations progress 
anticipated preliminary report experience prototype performance available pos workshop 
prototype followed succession releases leading functionality described 
experience earlier versions identify need design changes 
testing applications phase development case tools geographic information system gis examples 
measurements loads identify optimisations focus 
early task development integrated store management scheme including disk garbage collection 
design issues easily resolved concerning semantics pjava include re initialise static variables persistent classes take note class relationships organising static variable initialisation top level transactions pjava analogous unix processes maintain analogy transaction need manufacture set static variables emulate behaviour respect static variables say separate programs run transactions common database combination transactions threads seek construct serves purposes choose set transaction primitives implement minimal performance costs 
presently preferred solutions design issues implemented tested applications 
hoped forms persistent java developed exploit novel opportunity language safe looks popular commercially important 
permit comparison various outcomes design choices importantly may enable application teams industries enjoy benefits persistent programming 

supported sun collaborative awards program 
builds research technology developed european community basic research action fide 
design implementation pjava submitted pos atkinson jordan spence bibliography atkinson atkinson editor 
fully integrated data environments springer verlag 
atkinson atkinson spence 
pjava design working document available www dcs gla ac uk susan pjava atkinson morrison atkinson morrison 
orthogonal persistent object systems vldb journal pp 
atkinson atkinson buneman morrison 
binding type checking database programming languages computer journal pp april 
atkinson atkinson chisholm cockshott marshall 
algorithms persistent heap ieee software practice engineering march 
bailey bailey 
personal communication university glasgow february 
bancilhon bancilhon kim korth 
model cad transactions proc 
th int 
conf 
large database pages 
ahamad ahamad 
operating system mechanisms distributed object fault tolerant computing technical report git cc school information computer sciences georgia institute technology atlanta georgia october 
chrysanthis ramamritham chrysanthis ramamritham 
synthesis extended transaction models acta acm tods pp september 
chrysanthis ramamritham chrysanthis ramamritham 
formalism extended transaction models proc 
th int 
conf 
large database pages barcelona september 
cockshott cockshott atkinson chisholm bailey morrison 
persistent object management systems ieee software practice engineering 

conception de de adapts aux client 
ph thesis universit pierre marie curie paris vi jussieu 
september 
gruber gruber 
efficient customizable concurrency control graph locking capabilities atkinson benzaken maier editors persistent object systems proc 
sixth int 
workshop persistent object systems workshops computing provence france september 
springer verlag collaboration british computer society pages 
gruber valduriez 
locking oodbms clients supporting nested transactions proc 
th int 
conf 
data engineering pages taipei taiwan march 
garcia molina salem garcia molina salem 
sagas proc 
acm sigmod int 
conf 
management data pages 
design implementation pjava submitted pos atkinson jordan spence gosling gosling 
java language environment white 
sun microsystems computer may 
gosling gosling joy steele 
java language specification 
addison wesley 
gray reuter gray reuter 
transaction processing concept techniques 
morgan kaufman 
haines haines nettles wing 
composing firstclass transaction appear acm toplas 
rothermel rothermel 
concurrency control issues nested transactions vldb journal 
jordan jordan van de software configuration management objectoriented database proc 
usenix conference object oriented technologies monterey california june 
kaiser pu kaiser pu 
cooperative transaction multiuser environments 
chapter pages kim editor 
modern database system object model interoperability 
addison wesley acm press 
kaiser pu kaiser pu 
dynamic restructuring transactions chapter pages database transaction models advanced applications data management systems series morgan kaufman san mateo ca 
elmagarmid editor 
kim kim chou woelk 
integrating object oriented programming system database system oopsla int 
conf pages september 

building flexible multilevel transactions distributed persistent environment chapter pages atkinson buneman morrison data types persistence proceedings workshop persistent object systems scotland august 
martin ramamritham martin ramamritham 
aries rh robust support delegation rewriting history 
technical report university massachusetts amherst massachusetts june 
satyanarayanan satyanarayanan 
recoverable virtual memory 
rvm release cmu january 
matthes schmidt matthes schmidt 
persistent threads proceedings twentieth international conference large databases pages santiago chile 
morrison morrison connor cutts kirby munro atkinson 
napier persistent programming language environment chapter atkinson 
moss moss 
working objects swizzle swizzle 
ieee transactions software engineering august 
design implementation pjava submitted pos atkinson jordan spence moss moss 
nested transactions approach reliable distributed computing 
phd thesis massachussets institute technology april 
munro munro connor morrison stemple 
concurrent shadow paging architecture atkinson benzaken maier editors persistent object systems proc 
sixth int 
workshop persistent object systems workshops computing provence france september 
springer verlag collaboration british computer society pages 
osf open software foundation 
java mobile code white december 
pu pu kaiser hutchinson 
split transactions open ended activities proc 
acm sigmod int 
conf 
management data pages los angeles california august 
rashid rashid baron forin golub jones orr 
mach foundation open systems proceedings second workshop workstation operating systems september 
stemple morrison stemple morrison 
specifying flexible concurrency control schemes operational approach chapter atkinson 
white dewitt white dewitt 
performance study alternative object faulting pointer swizzling strategies proc 
th int 
conf 
large database pages vancouver british columbia canada 
