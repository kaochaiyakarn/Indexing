basic description logics franz baader institut ur theoretische informatik fakult informatik tu dresden germany 
inf 
tu dresden 
de baader werner nutt department computing electrical engineering heriot watt university edinburgh www 

hw 
ac 
uk nutt baader calvanese mcguinness nardi patel schneider editors 
description logic handbook theory implementation applications 
cambridge university press 
chapter provides description logics formal language representing knowledge reasoning 
rst gives short overview ideas underlying description logics 
introduces syntax semantics covering basic constructors systems introduced literature way constructors build knowledge bases 
de nes typical inference problems shows interrelated describes di erent approaches ectively solving problems 
topics brie mentioned chapter treated detail subsequent chapters 
sketched previous chapter description logics dls name family knowledge representation kr formalisms represent knowledge application domain world rst de ning relevant concepts domain terminology concepts specify properties objects individuals occurring domain world description name description logics indicates characteristics languages predecessors equipped formal logic semantics 
distinguished feature emphasis reasoning central service reasoning allows infer implicitly represented knowledge knowledge explicitly contained knowledge base 
description logics support inference patterns occur applications intelligent information processing systems humans structure understand world classi cation concepts individuals 
classi cation previously names terminological knowledge representation languages concept languages term subsumption languages kl knowledge representation languages 
baader nutt concepts determines subconcept superconcept relationships called subsumption relationships dl concepts terminology allows structure terminology form subsumption hierarchy 
hierarchy provides useful information connection di erent concepts speed inference services 
classi cation individuals objects determines individual instance certain concept instance relationship implied description individual de nition concept 
provides useful information properties individual 
instance relationships may trigger application rules insert additional facts knowledge base 
description logics kr formalism kr usually assumes kr system answer queries user reasonable time reasoning procedures dl researchers interested decision procedures rst order theorem provers procedures terminate positive negative answers 
guarantee answer nite time need imply answer reasonable time investigating computational complexity dl decidable inference problems important issue 
decidability complexity inference problems depend expressive power dl hand 
hand expressive dls inference problems high complexity may undecidable 
hand weak dls ecient reasoning procedures may suciently expressive represent important concepts application 
mentioned previous chapter investigating trade expressivity dls complexity reasoning problems important issues dl research 
description logics descended called structured inheritance networks brachman introduced overcome ambiguities early semantic networks frames rst realized system kl brachman schmolze ideas rst put forward brachman structured inheritance networks largely shaped subsequent development dls basic syntactic building blocks atomic concepts unary predicates atomic roles binary predicates individuals constants 
expressive power language restricted uses small set epistemologically adequate constructors building complex concepts roles 
implicit knowledge concepts individuals inferred automatically help inference procedures 
particular subsumption relationships concepts instance relationships individuals concepts basic description logics play important ole links semantic networks explicitly introduced user subsumption relationships instance relationships inferred de nition concepts properties individuals 
rst logic semantics kl kr languages proposed inference problems subsumption provided precise meaning led rst formal investigations computational properties languages 
turned languages early dl systems expressive led undecidability subsumption problem schmidt schau patel schneider rst worst case complexity results levesque brachman nebel showed subsumption problem intractable polynomially solvable languages 
mentioned previous chapter starting point thorough investigation worst case complexity reasoning kl kr languages see chapter details 
turned intractability reasoning sense non polynomial worst case prevent dl useful practice provided sophisticated optimization techniques implementing system dl see chapter 
implementing dl system ecient implementation basic reasoning algorithms issue 
hand derived system services classi cation constructing subsumption hierarchy concepts de ned terminology optimized baader hand needs user application programming interface see chapter details 
implemented dl systems provide rule language seen simple ective application programming mechanism see subsection details 
section introduces basic formalism description logics 
way prototypical example rst introduces formalism describing concepts description language de nes terminological tbox assertional abox formalisms 
introduces basic reasoning problems shows related 
de nes rule language available implemented dl systems 
section describes algorithms solving basic reasoning problems dls 
shortly sketching structural subsumption algorithms concentrates tableau algorithms 
comments problem reasoning terminologies 
section describes additional language constructors included prototypical family description languages introduced sec baader nutt tbox abox kb description reasoning application programs rules language fig 

architecture knowledge representation system description logics 
tion considered literature available dl systems 
de nition basic formalism kr system description logics provides facilities set knowledge bases reason content manipulate 
sketches architecture system see chapter information dl systems knowledge base kb comprises components tbox abox 
tbox introduces terminology vocabulary application domain abox contains assertions named individuals terms vocabulary 
vocabulary consists concepts denote sets individuals roles denote binary relationships individuals 
addition atomic concepts roles concept role names dl systems allow users build complex descriptions concepts roles 
tbox assign names complex descriptions 
language building descriptions characteristic dl system di erent systems distinguished description languages 
description language model theoretic semantics 
statements tbox abox identi ed formulae rst order logic cases slight extension 
dl system stores terminologies assertions ers services reason 
typical reasoning tasks terminology determine description satis able non contradictory basic description logics description general rst subsumes second 
important problems abox nd set assertions consistent model assertions abox entail particular individual instance concept description 
satis ability checks descriptions consistency checks sets assertions useful determine knowledge base meaningful 
subsumption tests organize concepts terminology hierarchy generality 
concept description conceived query describing set objects interested 
instance tests retrieve individuals satisfy query 
application kr system embedded larger environment 
components interact kr component querying knowledge base modifying adding retracting concepts roles assertions 
restricted mechanism add assertions rules 
rules extension logical core formalism interpreted logically 
systems addition providing application programming interface consists functions de ned logical semantics provide escape hatch application programs operate kb arbitrary ways 
description languages elementary descriptions atomic concepts atomic roles 
complex descriptions built inductively concept constructors 
notation letters atomic concepts letter atomic roles letters concept descriptions 
description languages distinguished constructors provide 
sequel shall discuss various languages family languages 
language attributive language introduced schmidt schau smolka minimal language practical interest 
languages family extensions basic description language concept descriptions formed syntax rule atomic concept universal concept bottom concept atomic negation intersection baader nutt value restriction limited existential quanti cation 
note negation applied atomic concepts top concept allowed scope existential quanti cation role 
historical reasons sublanguage obtained disallowing atomic negation called fl sublanguage fl obtained disallowing limited existential quanti cation called fl give examples expressed suppose person female atomic concepts 
person female person female concepts describing intuitively persons female female 
addition suppose haschild atomic role form concepts person haschild person haschild female denoting persons child persons children female 
bottom concept describe persons child concept person haschild 
order de ne formal semantics concepts consider interpretations consist non empty set 
domain interpretation interpretation function assigns atomic concept set atomic role binary relation interpretation function extended concept descriptions inductive de nitions fa 
fa 
say concepts equivalent write interpretations instance going back de nition semantics concepts easily veri es haschild female haschild student haschild female student equivalent 
family languages obtain expressive languages add constructors union concepts indicated letter written interpreted basic description logics full existential quanti cation indicated letter written interpreted fa 
note di ers arbitrary concepts allowed occur scope existential quanti er 
number restrictions indicated letter written nr restriction nr restriction ranges nonnegative integers 
interpreted nr 
gj nr 
gj respectively 
denotes cardinality set 
semantic viewpoint coding numbers number restrictions immaterial 
complexity analysis inferences matter number represented binary decimal notation string length binary decimal notation allows compact representation 
negation arbitrary concepts indicated letter complement written interpreted additional constructors example describe persons child children female person haschild haschild haschild female extending subset constructors yields particular language 
name language string form letter name stands presence corresponding constructor 
instance alen extension full existential quanti cation number restrictions see appendix dl terminology extend naming scheme expressive dls 
semantic point view languages distinct 
semantics enforces equivalences ctd cu union full existential quanti cation expressed negation 
conversely combination union full existential quanti cation gives baader nutt possibility express negation concepts equivalent negation normal form see section 
assume union full existential quanti cation available language contains negation vice versa 
follows modulo equivalences mentioned languages written letters 
hard see languages obtained way pairwise non equivalent 
sequel shall distinguish language negation counterpart union full existential quanti cation 
vein shall letter letters ue language names 
instance shall write alc alue alcn description languages fragments predicate logic semantics concepts identi es description languages fragments rst order predicate logic 
interpretation respectively assigns atomic concept role unary binary relation 
view atomic concepts roles unary binary predicates 
concept translated ectively predicate logic formula free variable interpretation set elements 
satisfying exactly atomic concept translated formula constructors intersection union negation translated logical conjunction disjunction negation respectively translated atomic role value restriction existential quanti cation captured formulae new variable number restrictions expressed formulae nr 
nr 
note equality predicate needed express number restrictions concepts number restrictions translated equality free formulae 
may argue concepts translated predicate logic need special syntax 
translations show particular number restrictions variable free syntax description logics concise 
seen section lends easily development algorithms 
basic description logics detailed analysis connection fragments rst order predicate logic dls chapter 
terminologies seen form complex descriptions concepts describe classes objects 
introduce terminological axioms statements concepts roles related 
single de nitions speci axioms identify terminologies sets de nitions introduce atomic concepts abbreviations names complex concepts 
de nitions terminology contain cycles may adopt xpoint semantics unequivocal 
discuss types terminologies xpoint models exist 
terminological axioms general case terminological axioms form concepts roles 
axioms rst kind called inclusions axioms second kind called equalities 
simplify exposition deal axioms involving concepts 
semantics axioms de ned expect 
interpretation satis es inclusion satis es equality set axioms satis es satis es element satis es axiom resp 
set axioms say model axiom resp 
set axioms 
axioms sets axioms equivalent models 
de nitions equality left hand side atomic concept de nition 
de nitions introduce symbolic names complex descriptions 
instance axiom mother woman haschild person associate description right hand side name mother 
symbolic names may abbreviations descriptions 
example de ned father analogously mother de ne parent parent mother father set de nitions unequivocal 
call nite set de nitions baader nutt woman person female man person woman mother woman haschild person father man haschild person parent father mother grandmother mother haschild parent mother haschild mother haschild woman wife woman man fig 

terminology tbox concepts family relationships 
terminology tbox symbolic name de ned atomic concept axiom left hand side shows terminology concepts concerned family relationships 
suppose terminology 
divide atomic concepts occurring sets name symbols occur left hand side axiom base symbols occur right hand side axioms 
name symbols called de ned concepts base symbols primitive concepts expect terminology de nes name symbols terms base symbols precise 
base interpretation interpretation interprets base symbols 
base interpretation 
interpretation interprets name symbols extension domain agrees base symbols 
say de base interpretation exactly extension model words know base symbols stand de meaning name symbols completely determined 
obviously terminology de equivalent terminology de 
question terminology de related question de nitions cyclic 
instance terminology consists single axiom human animal human contains cycle special case simple 
general de ne cycles terminology follows 
atomic concepts occurring say directly uses appears right hand side note papers notion primitive concept di erent meaning synonymous call atomic concepts denote atomic left hand sides concept inclusions 
basic description logics woman person female man person person female mother person female haschild person father person person female haschild person parent person person female haschild person person female haschild person grandmother person female haschild person haschild person person female haschild person person female haschild person person female haschild person haschild person female haschild person haschild person female wife person female person person female fig 

expansion family tbox 
de nition call uses transitive closure relation directly uses 
contains cycle exists atomic concept uses 
called acyclic 
unique extensions need exist terminology contains cycles 
consider instance terminology contains axiom 
human name symbol animal base symbols 
interpretation relates animal extensions possible interpret human way axiom satis ed human interpreted set animals species set animals property animal contains 
contrast terminology acyclic de 
reason expand iterative process de nitions replacing occurrence name right hand side de nition concepts stands 
cycle set de nitions process eventually stops terminology consisting solely de nitions form contains base symbols name symbols 
call expansion note size expansion exponential size original terminology nebel family tbox acyclic 
compute expansion shown 
proposition acyclic terminology expansion 
name base symbols baader nutt ii equivalent iii de 
proof terminology 
suppose de nitions occurs concept obtained replacing occurrence terminology obtained replacing de nition terminologies name base symbols 
obtained replacing equals equals terminologies models 
obtained sequence replacement steps ones proves claims ii 
suppose interpretation base symbols 
extend interpretation covers name symbols setting de nition clearly model extension model shows de 
de equivalent characteristic acyclic terminologies sense precise uniquely de ne name symbols terms base symbols 
course terminologies cycles de 
consider instance consisting axiom cycle 
au equivalent bottom concept axiom equivalent acyclic axiom example typical general situation 
theorem de alc terminology equivalent acyclic terminology 
theorem reformulation beth de nability theorem gabbay modal propositional logic shown schild notational variant alc 
fixpoint semantics terminological cycles semantics studied far essentially semantics rst order logic terminologies de impact essentially acyclic 
nebel shall call semantics descriptive semantics distinguish xpoint semantics introduced 
fixpoint semantics basic description logics motivated fact situations intuitively cyclic de nitions meaningful intuition captured greatest xpoint semantics 
example suppose want specify concept man male spring short 
particular man mos man sons 
mos de ned cycles mos man haschild man want statement llers transitive closure role haschild 
recursive de nition natural 
man having male spring man children men having male spring man haschild order achieve desired meaning interpret de nition appropriate xpoint semantics 
shall show greatest xpoint semantics captures intuition 
cycles appear want model recursive structures binary trees 
example suppose set objects trees binary relation branch objects leads tree subtrees 
binary trees trees subtrees binary trees binarytree tree branch branch binarytree de nition xpoint semantics yield desired meaning 
example xpoint semantics 
give formal de nition xpoint semantics 
terminology name symbol occurs exactly left hand side axiom view mapping associates name symbol concept description notation interpretation model characterization xpoint equation 
exploit similarity introduce family mappings interpretation model xpoint mapping 
terminology xed base interpretation denote set extensions tj mapping example taken nebel baader nutt maps extension extension tj de ned tj name symbol xpoint tj tj tj name symbols 
means de nition tj means model proves result 
proposition terminology interpretation restriction base symbols model xpoint tj preceding proposition terminology de base interpretation unique extension xpoint tj example get feel cyclic terminologies de discuss example terminology consists axiom 
consider base interpretation de ned charles james man haschild charles charles james james 
means charles die member james 
want identify xpoints note individual children llers haschild interpretation haschild matter interpreted 
xpoint extension james haschild conclude james 
extension comprises exactly james 
easy check xpoint 
addition james charles members charles belong concept 
easily check extension interprets entire domain xpoint xpoint 
order give de impact cyclic terminology single particular xpoint mapping tj 
de ne partial ordering extensions say name symbol example name symbol 
basic description logics xpoint tj xpoint lfp xpoint say xpoint model xpoint tj base interpretation xpoint semantics admit xpoint models intended interpretations 
greatest xpoints gfp greatest xpoint models greatest xpoint semantics de ned analogously 
example greatest xpoint tj existence xpoint models greatest xpoint models need exist terminology 
example simple example consider axiom model axiom implies 
absurdity 
terminology containing axiom models gfp lfp models 
cases models xpoints exist greatest 
example consider terminology single axiom base interpretation 
fa bg xpoint extensions de ned fag fbg 
comparable respect 
order identify terminologies property base interpretation exists greatest xpoint extension draw results lattice theory 
recall lattice complete family elements upper bound 
introduced partial ordering 
family interpretations de ne pointwise union name symbol upper bound shows ext complete lattice 
function lattice monotone tarski fixpoint theorem tarski says monotone function complete lattice set xpoints nonempty forms complete lattice 
particular greatest xpoint 
de ne terminology monotone mapping tj monotone base interpretations tarski theorem terminologies greatest baader nutt xpoints 
apply theorem able recognize monotone terminologies 
simple syntactic criterion 
call terminology negation free negation occurs 
induction depth concept descriptions check negation free alcn terminology monotone 
proposition negation free terminology base interpretation exist extensions lfp model gfp model respectively 
negation free terminologies general class terminologies having greatest xpoints 
seen proposition acyclic terminologies de base interpretation admit single extension model greatest xpoint model 
obtain re ned criterion existence greatest xpoints pay attention interplay cycles negation 
associate terminology dependency graph nodes name symbols contains axiom occurrence name symbol arc arcs labeled positive negative 
arc positive occurs scope number negations negative occurs scope odd number negations 
sequence nodes path arc 
path cycle proposition terminology cycle contains number negative arcs 
monotone 
call terminology satisfying precondition proposition syntactically monotone 
terminologies inclusion axioms certain concepts may unable de ne completely 
case state necessary conditions concept membership inclusion 
call inclusion left hand side atomic specialization 
example male knowledge engineer thinks de nition woman example tbox satisfactory feels able de ne concept woman detail require woman person specialization woman person allow specializations terminology terminology loses basic description logics de impact acyclic 
set axioms generalized terminology left hand side axiom atomic concept atomic concept axiom occurs left hand side 
shall transform generalized terminology regular terminology containing de nitions equivalent sense speci ed 
obtain choosing specialization new base symbol replacing specialization de nition terminology normalization tbox contains specialization normalization contains de nition woman woman person intuitively additional base symbol woman stands qualities distinguish woman persons 
normalization results tbox de nition woman similar family tbox 
proposition generalized terminology normalization 
model model model model domain agrees atomic concepts roles proof rst claim holds model satis es implies conversely model extension de ned model implies satis es theory inclusion axioms add expressivity terminologies 
practice convenient means introduce terms terminology de ned completely 
world descriptions second component knowledge base addition terminology tbox world description abox 
assertions individuals abox describes speci state airs application domain terms concepts roles 
concept role atoms abox may de ned names tbox 
abox introduces individuals giving names asserts properties individuals 
denote individual baader nutt mary father peter haschild mary peter haschild peter harry haschild mary paul fig 

world description abox 
names concepts roles assertions kinds abox rst kind called concept assertions states belongs interpretation second kind called role assertions states ller role instance peter paul mary individual names father peter means peter father haschild mary paul means paul child mary 
abox denoted nite set assertions 
shows example abox 
simpli ed view abox seen instance relational database unary binary relations 
contrary closed world semantics classical databases semantics aboxes open world semantics normally knowledge representation systems applied situations assume knowledge kb complete 
tbox imposes semantic relationships concepts roles abox counterparts database semantics 
give semantics aboxes extending interpretations individual names 
interpretation 
maps atomic concepts roles sets relations addition maps individual name element 
assume distinct individual names denote distinct objects 
mapping respect unique name assumption una distinct names interpretation satis es concept assertion satis es role assertion interpretation satis es abox satis es assertion case say model assertion abox 
satis es assertion abox respect tbox addition model model model abstraction concrete world concepts interpreted subsets domain required tbox membership individuals concepts relationships terms roles respect assertions abox 
discuss implications di erence semantics section 
basic description logics individual names description language convenient allow individual names called nominals abox description language 
concept constructors employing individuals occur systems investigated literature 
basic set constructor written fa individual names 
expect set concept interpreted fa fa sets description language instance de ne concept permanent members un security council france russia uk 
language union constructor constructor fag singleton sets adds sucient expressiveness describe arbitrary nite sets semantics set constructor equation concepts fa fa 
fa equivalent 
constructor involving individual names lls constructor role semantics constructor de ned fd 
stands set objects ller role description language singleton sets full existential quanti cation lls add new equation implies fag equivalent 
note nally lls allows express role assertions concept assertions interpretation satis es satis es fbg 
inferences knowledge representation system dls able perform speci kinds reasoning 
said purpose knowledge representation system goes storing concept de nitions assertions 
knowledge base comprising tbox abox semantics equivalent set axioms rst order predicate logic 
set axioms contains implicit knowledge explicit inferences 
example tbox abox conclude mary grandmother knowledge explicitly stated assertion 
baader nutt di erent kinds reasoning performed dl system see chapter de ned logical inferences 
shall discuss inferences rst concepts tboxes aboxes nally tboxes aboxes 
turn main inference problem consistency check aboxes inferences reduced 
reasoning tasks concepts knowledge engineer models domain constructs terminology say de ning new concepts possibly terms de ned 
process important nd newly de ned concept sense contradictory 
logical point view concept sense interpretation satis es axioms model concept denotes nonempty set interpretation 
concept property said satis able respect unsatis able 
checking satis ability concepts key inference 
shall see number important inferences concepts reduced un satis ability 
instance order check domain model correct optimize queries formulated concepts may want know concept general subsumption problem 
concept subsumed concept model set denoted subset set denoted algorithms check subsumption employed organize concepts tbox taxonomy generality 
interesting relationships concepts equivalence disjointness 
properties formally de ned follows 
tbox 
satis ability concept satis able respect exists model nonempty 
case say model subsumption concept subsumed concept respect model case write equivalence concepts equivalent respect model case write disjointness concepts disjoint respect model tbox clear context drop quali cation respect drop quali cation special case tbox empty basic description logics simply write subsumed equivalent 
example respect tbox person subsumes woman woman parent subsume mother mother subsumes grandmother 
woman man father mother disjoint 
subsumption relationships follow de nitions semantics 
man disjoint woman due fact man subsumed negation woman 
traditionally basic reasoning mechanism provided dl systems checked subsumption concepts 
fact sucient implement inferences seen reductions 
proposition reduction subsumption concepts unsatis able subsumed ii equivalent subsumed subsumed iii disjoint subsumed 
statements hold respect tbox 
description languages implemented actual dl systems provide intersection operator contain unsatis able concept 
dl systems check subsumption perform inferences de ned 
addition intersection system allows form negation description reduce subsumption equivalence disjointness concepts satis ability problem see smolka 
proposition reduction unsatis ability concepts subsumed unsatis able ii equivalent unsatis able iii disjoint unsatis able 
statements hold respect tbox 
reduction subsumption easily understood recalls sets 
reduction equivalence correct equivalent subsumed subsumed reduction disjointness just rephrasing de nition 
baader nutt proposition order obtain decision procedures inferences discussed sucient develop algorithms decide satis ability concepts provided language decide satis ability supports conjunction negation arbitrary concepts 
fact observation motivated researchers study description languages concept form negation concept smolka schmidt schau smolka donini approach consider satis ability checking principal inference gave rise new kind algorithms reasoning dls understood specialized tableaux calculi see section chapter chapter 
generation dl systems kris baader hollunder crack fact horrocks dlp patel schneider race haarslev oller satis ability checking considerable amount research spent development ecient implementation techniques approach baader horrocks horrocks patel schneider haarslev oller language full negation subsumption equivalence reduced unsatis ability simple way shown proposition inferences may di erent complexity 
seen proposition viewpoint worst case complexity subsumption general inference language 
proposition shows unsatis ability special case problems 
proposition reducing unsatis ability concept 
equivalent unsatis able ii subsumed iii equivalent iv disjoint 
statements hold respect tbox 
propositions see order obtain upper lower complexity bounds inferences concepts languages suces assess lower bounds unsatis ability upper bounds subsumption 
precisely language upper bound complexity subsumption problem upper bound complexity ability equivalence disjointness problem 
lower bound complexity ability problem lower bound complexity subsumption equivalence disjointness problem 
basic description logics eliminating tbox applications concepts usually come context tbox 
developing reasoning procedures conceptually easier tbox amounts assume empty 
show acyclic tbox reduce reasoning problems respect problems respect empty tbox 
seen proposition equivalent expansion recall expansion de nition form contains base symbols name symbols 
concept de ne expansion respect concept obtained replacing occurrence name symbol concept de nition expansion example obtain expansion concept woman man respect tbox considering expanded tbox replacing woman man right hand sides de nitions expansion 
results concept person female person person female readily deduce number facts expansions 
expansion obtained replacing names descriptions way interpreted way model follows satis able satis able contains de ned names satis able satis able 
yields satis able satis able 
concept contain base symbols implies similar arguments show disjoint disjoint 
baader nutt summing expanding concepts respect acyclic tbox allows get rid tbox reasoning problems 
going back example means order verify man woman disjoint respect family tbox amounts checking man woman unsatis able suces check concept unsatis able 
expanding concepts may computationally costly worst case size exponential size may larger factor exponential size complexity analysis diculty reasoning respect tboxes shows expansion de nitions source complexity avoided see subsection chapter chapter 
reasoning tasks aboxes knowledge engineer designed terminology reasoning services dl system check concepts satis able expected subsumption relationships hold abox lled assertions individuals 
recall abox contains kinds assertions concept assertions form role assertions form 
course representation knowledge consistent viewpoint logic draw arbitrary 
example abox contains assertions mother mary father mary system able nd family tbox statements inconsistent 
terms model theoretic semantics easily give formal de nition consistency 
abox consistent respect tbox interpretation model simply say consistent consistent respect empty tbox 
example set assertions mary father mary consistent respect empty tbox restrictions interpretation mother father concepts interpreted way common element 
assertions consistent respect family tbox model mother father interpreted disjoint sets 
similarly concepts checking consistency abox respect acyclic tbox reduced checking expanded abox 
de ne expansion respect abox obtained replacing concept assertion assertion expansion respect model concept expand concept assertions description language considered provide constructors role descriptions considered tboxes role de nitions 
basic description logics expansion interpreted way 
consistent 
contain name symbol de ned consistent consistent 
conclude consistent expansion consistent 
technique check consistency alcn aboxes discussed section 
inferences going introduce de ned respect tbox abox 
case consistency reasoning tasks aboxes respect acyclic tboxes reduced reasoning expanded aboxes 
sake simplicity shall give de nitions inferences aboxes leave reader formulate appropriate generalization inferences respect tboxes verify reduced inferences expansions provided tbox acyclic 
abox pose queries relationships concepts roles individuals 
prototypical abox inference queries instance check check assertion entailed abox 
say assertion entailed write interpretation satis es model satis es role assertion instance check easy description language contain constructors form complex roles 
form reduce instance check consistency problem aboxes connection inconsistent 
reasoning concepts reduced consistency checking 
seen proposition important reasoning problems concepts reduced decide concept un satis able 
similarly concept satis ability reduced abox consistency concept satis able fc consistent arbitrarily chosen individual name 
conversely schaerf shown abox consistency reduced concept satis ability languages set lls constructor schaerf constructors available instance checking may harder satis ability subsumption problem donini applications usually complex inferences consistency instance description language richer tboxes contain role de nitions clearly taken account de nition expansions 
baader nutt checking required 
consider knowledge base means store information individuals may want know individuals instances concept description description language formulate queries 
example may want know system parents children instance entitled speci family tax break 
retrieval problem abox concept nd individuals 
non optimized algorithm retrieval query realized testing individual occurring abox instance query concept dual inference retrieval realization problem individual set concepts nd speci concepts set 
speci concepts minimal respect subsumption ordering realization instance systems generate natural language terms indexed concepts term precise possible object occurring discourse 
closed vs open world semantics analogy established databases hand dl knowledge bases hand see chapter 
schema database compared tbox instance actual data compared abox 
semantics aboxes di ers usual semantics database instances 
database instance represents exactly interpretation classes relations schema interpreted objects tuples instance abox represents di erent interpretations models 
consequence absence information database instance interpreted negative information absence information abox indicates lack knowledge 
example assertion peter haschild peter harry database understood representation fact peter child harry 
abox assertion expresses fact harry child peter 
abox models harry child brothers sisters 
consequently knows assertion harry male deduce peter children male 
way stating abox harry child doing explicitly adding assertion haschild peter 
means information database understood complete information abox general viewed incomplete 
semantics aboxes characterized open world semantics traditional semantics databases characterized semantics 
basic description logics haschild haschild haschild haschild fig 

abox oe view consequences way queries answered 
essentially query description class objects 
setting assume queries concept descriptions 
database sense introduced listing single nite interpretation 
nite interpretation say written set assertions form atomic concept atomic role 
set looks syntactically abox abox di erence semantics 
answering query represented complex concept database amounts computing de ned section 
logical point view means query evaluation database logical reasoning nite model checking evaluation formula xed nite model 
abox represents possibly nitely interpretations models query answering complex requires nontrivial reasoning 
concerned semantical issues algorithmic aspects treated section 
illustrate di erence semantics identi es database single model open world semantics aboxes discuss called example stimulated number theoretical developments dl research 
example example story ancient greek mythology 
nutshell story killed father married mother children 
children 
suppose abox oe represents rudimentary facts events 
sake example abox asserts represented atomic concept 
suppose want know abox child child 
expressed entailment problem oe haschild haschild may tempted reason follows 
children abox 
baader nutt 
child 
tells 
child looking 
child tells 
child looking 
reasoning claim assertion entailed 
correct reasoning di erent 
models oe divided classes 
model rst kind child child isn 
model second kind child child isn 
models child child child 
means assertion haschild haschild entailed oe example shows open world reasoning may require case analyses 
explained detail chapter reasons inferences dls complex query answering databases 
rules knowledge bases discussed far consist tbox abox denote knowledge base pair 
dl systems classic brachman loom macgregor addition terminologies world descriptions rules express knowledge 
simplest variant rules expressions form concepts 
meaning rule individual proved instance derive instance 
rules called trigger rules 
operationally semantics nite set trigger rules described forward reasoning process 
starting initial knowledge base series knowledge bases constructed obtained adding new assertion contains rule holds contain 
process eventually halts initial knowledge base contains nitely individuals nitely rules 
nitely assertions possibly added 
result rule applica basic description logics tions knowledge base tbox abox augmented membership assertions introduced rules 
call nal knowledge base procedural extension denote easy see procedural extension independent order rule applications 
consequently set trigger rules uniquely speci es generate knowledge base extended knowledge base semantics knowledge base augmented set trigger rules understood set models de nes semantics trigger rules operationally 
preferable specify semantics declaratively prove extension computed trigger rules correctly represents semantics 
tempting declarative semantics inclusion axioms semantics rules 
correctly re ect operational semantics 
important di erence trigger rule inclusion axiom trigger rule equivalent contrapositive addition applying trigger rules case analysis 
example inclusions imply object belongs trigger rules applies individual proven 
order capture meaning trigger rules declarative way augment description logics operator refer objects domain knowledge base knows domain 
epistemic operator 
information epistemic operators dls chapter 
introduce operator enrich syntax semantics description languages 
originally operator de ned alc donini subsection discuss extend basic language languages proceed analogously see chapter 
add case syntax rule section allows construct epistemic concepts kc epistemic concept 
intuitively concept kc denotes objects knowledge base knows instances translate trigger rules inclusion axioms kc intuitively operator front concept ect axiom applicable individuals appear abox abox tbox imply instances restricted applicability prevents baader nutt inclusion axiom uencing satis ability subsumption relationships concepts 
sequel de ne formal semantics operator exactly ect 
rule knowledge base triple tbox abox set rules written inclusion axioms form 
procedural extension triple knowledge base obtained applying trigger rules described 
semantics epistemic inclusions de ned way applies individuals knowledge base provably instances arbitrary domain elements case dropped semantics go rst order logic interpret concepts roles individuals model knowledge knowledge base 
fact knowledge base knowledge domain understood way considers subset set interpretations possible states world 
individuals interpreted elements interpretations known formal modify de nition ordinary rst order interpretations assuming xed countably nite set 
domain interpretation common domain assumption ii mapping individuals domain elements xes way individuals interpreted rigid term assumption 
common domain assumption guarantees interpretations speak domain 
rigid term assumption allows identify individual symbols exactly domain element 
assumptions essentially reduce number possible interpretations 
consequence properties satis ability subsumption concepts independently de ne respect arbitrary interpretations satisfy assumptions 
de ne epistemic interpretation pair rstorder interpretation set rst order interpretations satisfying assumptions 
epistemic interpretation gives rise unique mapping associating concepts roles subsets 

respectively 
atomic concepts negated atomic concepts atomic roles 
agrees 
intersections value restrictions existential quanti cations de nition similar 
fa 
basic description logics fa 
constructors 
de ned analogously 
note concept occurrence sets identical 
set interpretations comes play de ne semantics epistemic operator kc possible allow operator occur front roles de ne semantics role expressions form kr analogously 
epistemic roles needed explain semantics rules restrict epistemic concepts 
epistemic interpretation satis es inclusion equality satis es assertion assertion satis es rule knowledge base satis es axiom assertion rule epistemic model rule knowledge base maximal nonempty set rst order interpretations epistemic interpretation satis es note rst order satis able set rst order models epistemic model rule knowledge base rule set empty 
similar statement holds arbitrary rule knowledge bases 
show epistemic models union implies maximality epistemic models 
proposition rule knowledge base rst order satis able 
unique epistemic model 
example consist rule eats rule states individuals known students eat junk food 
consider rule knowledge base peter determine epistemic model rst order interpretation satisfy student peter baader nutt true peter known student 
satis es rule assertion eats peter holds domain element 
interpretation student 
peter domain element rule applies 
summing epistemic model consists exactly rst order models eats peter demonstrate example epistemic semantics rules disallows contrapositive reasoning 
consider rule knowledge base eats peter case eats peter true rst order interpretation epistemic model maximality interpretation peter student peter student 
peter known student 
epistemic model consists exactly rst order models rule satis ed antecedent false 
clearly procedural extension rule knowledge base contains assertions satis ed epistemic model shown assertions added rule applications fact stated proposition rst order representation information implicit rules see donini proof 
proposition rule knowledge base 
rstorder satis able epistemic model consists precisely rst order models procedural extension 
reasoning algorithms section seen relevant inference problems reduced consistency problem aboxes provided dl hand allows conjunction negation 
description languages early day dl systems allow negation 
dls subsumption concepts usually computed called structural subsumption algorithms algorithms compare syntactic structure possibly normalized concept descriptions 
rst subsection consider algorithms detail 
usually ecient complete simple languages little expressivity 
particular dls full negation disjunction handled structural subsumption algorithms 
basic description logics languages called tableau algorithms turned useful 
area description logics rst tableau algorithm schmidt schau smolka satis ability alc concepts 
approach employed obtain sound complete satis ability subsumption algorithms great variety dls extending alc see hollunder hollunder baader donini baader sattler languages number restrictions baader transitive closure roles sattler horrocks sattler transitive roles baader hanschke hanschke haarslev constructors allow refer concrete domains numbers 
addition extended consistency problem aboxes hollunder baader hollunder donini haarslev oller tboxes allowing general sets inclusion axioms buchheit baader second subsection rst tableau satis ability algorithm alcn concepts show extended algorithm consistency problem aboxes nally explain general inclusion axioms taken account 
third subsection concerned reasoning acyclic cyclic terminologies 
designing new algorithms reasoning dls try reduce problem known inference problem logics see chapter 
example decidability inference problems alc dls obtained consequence known decidability result variable fragment rst order predicate logic 
language consists formulae rst order predicate logic built help predicate symbols including equality constant symbols function symbols variables decidability shown easy see appropriately re variable names concept description language alc translated formula free variable see borgida details 
direct translation concept description yields formula 

subformula contain variable re renaming bound variable yields equivalent formula 
uses variables 
connection alc shows extension alc constructors expressed help variables yields decidable dl 
number restrictions composition roles examples constructors expressed number restrictions expressed extension counting quanti ers shown decidable gr adel noted complexity decision procedures obtained way usually higher necessary example baader nutt satis ability problem nexptime complete satis ability alc concept descriptions pspace complete 
decision procedures lower complexity obtained connection dls propositional modal logics 
schild rst observe language alc syntactic variant propositional multimodal logic extension alc transitive closure roles baader corresponds propositional dynamic logic pdl 
particular algorithms propositional modal logics deciding satis ability similar tableau algorithms newly developed dls 
connection dls modal logics transfer decidability results modal logics dls schild de giacomo lenzerini see chapter 
tableau algorithms decidability certain propositional modal logics corresponding dls shown establishing nite model property see fitting section logic showing formula concept satis able satis able nite interpretation employing tree automata see vardi wolper 
structural subsumption algorithms algorithms usually proceed phases 
descriptions tested subsumption normalized syntactic structure normal forms compared 
simplicity rst explain ideas underlying approach small language fl allows conjunction ud value restrictions 
subsequently show bottom concept atomic negation number restrictions nr nr handled 
evidently fl extension bottom atomic negation sublanguages adding number restrictions resulting language yields dl aln fl concept description normal form form 
am 
am distinct concept names distinct role names fl concept descriptions normal form 
easy see description transformed equivalent normal form associativity commutativity idempotence fact descriptions equivalent 
proposition 
am 
basic description logics normal form fl concept description 

normal form fl concept description conditions hold exists 
ii exists easy see characterization subsumption sound direction proposition holds complete direction proposition holds 
characterization yields obvious recursive algorithm computing subsumption easily shown polynomial time complexity levesque brachman extend fl language constructors express unsatis able concepts hand change de nition normal form 
hand structural comparison normal forms take account unsatis able concept subsumed concept 
simplest dl occurs fl 
extension fl bottom concept 
fl 
concept description normal form form 
am 
am distinct concept names di erent distinct role names fl 
concept descriptions normal form 
normal form easily computed 
principle just computes fl normal form description treated ordinary concept name 
ub 
replace description 
apply procedure recursively example fl normal form 
yields fl 
normal form structural subsumption algorithm fl 
works just fl di erence subsumed description 
example au 
recursive comparison fl 
normal forms au au 
au au nally leads comparison extension fl 
atomic negation negation applied concept names treated similarly 
computation normal form negated baader nutt concept names just treated concept names 
name negation occur level normal form added treated described 
example au rst transformed au au au 
au nally 
structural comparison normal forms treats negated concept names just concept names 
consider language aln additional presence number restrictions leads new type con ict 
hand case atomic negation number restrictions may con icting 
hand restrictions nr con ict value restrictions 
prohibit role successors 
computing normal form treat number restrictions concept names take care new types con icts introducing normalization described 
structural comparison normal forms take account inherent subsumption relationships number restrictions nr 
detailed description structural subsumption algorithm working graph data structure language extending aln borgida patel schneider larger dls structural subsumption algorithms usually fail complete 
particular treat disjunction full negation full existential restriction languages including constructors tableau approach designing subsumption algorithms turned quite useful 
tableau algorithms directly testing subsumption concept descriptions algorithms negation reduce subsumption un satis ability concept descriptions seen subsection unsatis able 
describing tableau satis ability algorithm alcn detail illustrate underlying ideas simple examples 
concept names role name 
rst example assume want know subsumed 
means check concept description unsatis able 
push negation signs far possible description de morgan rules usual rules quanti ers 
result obtain basic description logics description negation normal form negation occurs front concept names 
try construct nite interpretation 
means exist individual 
element algorithm just generates individual say imposes constraint 
conjunction concept descriptions means satisfy constraints deduce exist individual analogously implies existence individual situation assume possibly impose constraints individuals newly introduced satisfy existential restrictions existential restriction algorithm introduces new individual role ller individual satisfy constraints expressed restriction 
satisfy value restriction introduced llers obtain additional constraints algorithm uses value restrictions interaction de ned role relationships impose new constraints individuals 
means choose possibilities 
assume clashes constraint means search path leads obvious contradiction 
choose analogously choose order satisfy constraint creating contradiction disjunctive constraints algorithm tries possibilities successive attempts 
backtrack reaches obvious contradiction individual satisfy constraints obviously con icting 
example satis ed constraints encountering obvious contradiction 
shows satis able subsumed 
algorithm generated interpretation witness fact 
fb dg fcg fdg 
baader nutt interpretation means second example add number restriction rst concept example want know subsumed 
intuitively answer rst concept ensures ller coincides ller ller 
tableau satis ability algorithm rst proceeds di erence additional constraint order satisfy constraint llers identi ed 
number restriction violated algorithm identify different role llers 
example individual belong leads clash 
search counterexample subsumption relationship fails algorithm concludes 
tableau satis ability algorithm alcn describe algorithm formally need introduce appropriate data structure represent constraints belongs interpretation ller 
original smolka papers tableau algorithms dls introduce new notion constraint system purpose 
look types constraints expressed see represented abox assertions 
seen second example presence number restrictions may lead identi cation di erent individual names 
reason impose unique name assumption una aboxes considered algorithm 
allow explicit inequality assertions form individual names obvious semantics interpretation satis es assertions assumed symmetric saying belongs abox saying belongs alcn concept negation normal form 
order test satis ability algorithm starts abox fc applies consistency preserving transformation rules see abox rules apply 
complete abox obtained way contain obvious contradiction called clash consistent satis able inconsistent unsatis able 
transformation rules handle disjunction restrictions non deterministic sense basic description logics rule condition contains uc contain 
action fc rule condition contains 
action fc fc rule condition contains individual name action fc individual name occurring rule condition contains contain 
action fc rule condition contains nr individual names contained action fr ng fy ng yn distinct individual names occurring rule condition contains distinct individual names yn nr yn action pair abox obtained replacing occurrence fig 

transformation rules satis ability algorithm 
abox transformed nitely new aboxes original abox consistent new aboxes 
reason consider nite sets aboxes fa single aboxes 
set consistent consistent 
rule applied nite set aboxes follows takes element replaces abox aboxes nitely aboxes lemma easy consequence de nition transformation rules lemma soundness assume obtained nite set aboxes application transformation rule 
consistent consistent 
second important property set transformation rules transformation process terminates baader nutt lemma termination alcn concept description negation normal form 
nite sequence rule applications ffc gg 
main reasons lemma hold 
lemma abox contained 
individual occurring unique sequence role names unique sequence individual names fr case say occurs level individual name level maximal role depth maximal nesting constructors involving roles bounded maximal role depth minus 
consequently level individual bounded maximal role depth consequently number di erent concept assertions bounded size number di erent role successors individuals role name bounded sum numbers occurring restrictions plus number di erent existential restrictions starting ffc gg obtain nite number rule applications set aboxes rules apply 
abox called complete transformation rules applies 
consistency set complete aboxes decided looking obvious contradictions called clashes 
abox contains clash situations occurs individual name ii fa individual name concept name iii nr fr fy individual names nonnegative integer role name obviously abox contains clash consistent 
aboxes contain clash inconsistent soundness lemma fc inconsistent 
consequently unsatis able 
complete aboxes clash free consistent 
soundness rules implies consistency fc satis ability detailed proof termination set rules extending baader sattler termination proof slightly di erent set rules donini basic description logics lemma completeness complete clash free abox model 
lemma proved de ning canonical interpretation ia induced domain 
ia ia consists individual names occurring ii atomic concepts de ne ia fx ag iii atomic roles de ne ia ag 
de nition ia satis es role assertions induction structure concept descriptions easy show satis es concept assertions 
inequality assertions satis ed di erent individual names 
facts stated lemma imply canonical interpretation shape nite tree depth linearly bounded size branching factor bounded sum numbers occurring restrictions plus number di erent existential restrictions consequently alcn nite tree model property satis able concept satis able nite interpretation shape tree root belongs sum seen transformation rules reduce satis ability alcn concept negation normal form consistency nite set complete aboxes 
addition consistency decided looking obvious contradictions clashes 
theorem decidable alcn concept satis able 
complexity issues tableau satis ability algorithm alcn may need exponential time space 
fact size canonical interpretation built algorithm may exponential size concept description 
example consider descriptions inductively de ned follows obviously size grows linearly input description satis ability algorithm introduced generates complete clash free abox canonical model full binary tree depth consists individuals 
satis ability algorithm modi ed needs baader nutt polynomial space 
main reason di erent branches tree model generated algorithm investigated separately 
complexity class coincides pspace savitch sucient describe non deterministic algorithm polynomial space non deterministic rule may simply assume algorithm chooses correct alternative 
principle modi ed algorithm works follows starts fc applies rules long possible checks clashes form ii generates necessary direct successors rule iii generates necessary identi cations direct successors rule checks clashes caused restrictions iv successively handles successors way 
identi cation remaining successors treated separately algorithm needs store path tree model generated direct successors individuals path information successors investigated 
know length path linear size input description remaining obstacle way pspace algorithm fact number direct successors individual path depends numbers restrictions 
assumed numbers written base representation size representation coincides number represented problem 
bases larger numbers decimal notation number represented may exponential size representation 
example representation requires digits base representation 
introduce successors required restrictions polynomial space size concept description numbers description written decimal notation 
turns successors required restrictions need introduced 
individual obtains successor due application rule rule need applied role simply introduce successor representative 
order detect inconsistencies due con icting number restrictions need add new type clash nr nonnegative integers canonical interpretation obtained modi ed algorithm need satisfy restrictions easily modi ed interpretation duplicating successors precisely subtrees starting successors 
basic description logics theorem satis ability alcn concept descriptions pspace complete 
argument shows problem pspace 
hardness result follows fact satis ability problem pspace hard sublanguage alc shown reduction validity quanti ed boolean formulae schmidt schau smolka subsumption satis ability alcn concept descriptions reduced linear time shows subsumption alcn concept descriptions pspace complete 
extension consistency problem aboxes tableau satis ability algorithm described subsection easily extended algorithm decides consistency alcn aboxes 
alcn abox concept descriptions negation normal form 
test consistency rst add inequality assertions pair distinct individual names occurring abox obtained way 
consistency algorithm applies rules singleton set fa soundness completeness rule set shown 
unfortunately algorithm need terminate imposes speci strategy order rule applications 
example consider abox fr applying rule introduce new successor fr rule adds assertion triggers application rule obtain new abox successors rule applicable replacing occurrence obtain abox fa individual names assertion irrelevant identical reason continue obtain nite chain rule applications 
easily regain termination requiring generating rules rules may applied rules applicable 
takes care una 
baader nutt example strategy prevent application rule abox rule applicable 
applying rule replaces rule longer applicable successor belongs similar idea reduce consistency problem alcn aboxes satis ability alcn concept descriptions hollunder principle reduction works follows preprocessing step applies transformation rules old individuals individuals original abox 
subsequently forget role assertions individual name preprocessed abox satis ability algorithm applied conjunction concept assertions see hollunder details 
theorem consistency alcn aboxes pspace complete 
extension general inclusion axioms subsections considered satis ability problem concept descriptions consistency problem aboxes underlying tbox 
fact acyclic tboxes simply expand de nitions see subsection 
expansion longer possibly allows general inclusion axioms form may complex descriptions 
considering nitely axiom sucient consider single axiom 
axiom simply says individual belong concept tableau algorithm introduced easily modi ed takes axiom account individuals original individuals ones newly generated rule simply asserted belong modi cation may obviously lead nontermination algorithm 
example consider happens algorithm applied test consistency abox fa axiom algorithm generates nite sequence aboxes individuals fr individuals receive concept assertions may say algorithms run cycle 
termination regained trying detect cyclic computations blocking application generating rules application rules individual blocked individual abox fd ag fd ag 
main idea underlying blocking blocked individual role successors generating new ones 
basic description logics example generating new successor example simply successor yields interpretation fx obviously model axiom avoid cyclic blocking vice versa consider enumeration individual names de ne individual may blocked individuals occur enumeration 
technical assumptions sure algorithm notion blocking sound complete terminating see buchheit baader details 
consistency alcn aboxes general inclusion axioms decidable 
noted algorithm longer pspace may generate role paths exponential length blocking occurs 
fact language alc satis ability single general inclusion axiom known exptime hard schild see chapter 
tableau algorithm sketched nexptime algorithm 
translation technique mentioned section shown de giacomo alcn aboxes general inclusion axioms translated pdl satis ability decided exponential time 
exptime tableau algorithm alc general inclusion axiom described donini massacci theorem consistency alcn aboxes general inclusion axioms exptime complete 
extension language constructors tableau approach designing concept satis ability abox consistency algorithms employed languages concept role constructors 
principle new constructor requires new rule rule usually obtained simply considering semantics constructor 
soundness rule easy show 
problematic completeness termination take interactions di erent rules account 
seen termination obtained application rules restricted appropriate strategy 
course may impose strategy show destroy completeness 
reasoning terminologies recall terminologies tboxes sets concept de nitions equalities form atomic atomic concept occurs left hand side 
rst comment brie complexity baader nutt reasoning acyclic terminologies consider detail reasoning cyclic terminologies 
acyclic terminologies shown section reasoning acyclic terminologies reduced reasoning terminologies rst expanding tbox replacing name symbols de nitions terminology 
unfortunately expanded tbox may exponentially larger original nebel increases complexity reasoning 
nebel shows complexity general avoided language fl subsumption concept descriptions tested polynomial time see section subsumption acyclic terminologies conp complete see section 
expressive languages presence acyclic tboxes may may increase complexity subsumption problem 
example subsumption concept descriptions language alc pspace complete subsumption acyclic terminologies lutz course order obtain pspace algorithm subsumption alc acyclic tboxes rst expand tbox completely need exponential space 
main idea uses tableau algorithm described section di erence receives concept descriptions containing name symbols input 
expansion done demand tableau algorithm encounters assertion form name occurring left hand side de nition tbox adds assertion 
expand stage 
hard show really yields pspace algorithm satis ability subsumption concepts acyclic tboxes alc lutz extensions alc technique longer works 
example language extends alc functional roles agreements disagreements chains functional roles see section 
satis ability concepts pspace complete language hollunder nutt satis ability concepts acyclic terminologies nexptime complete lutz cyclic terminologies cyclic terminologies expansion longer possible terminate 
descriptive semantics cyclic terminologies special case terminologies general inclusion axioms 
tableau algorithm handling general inclusion axioms introduced subsection cyclic alcn tboxes descriptive semantics 
cyclic alc basic description logics tboxes xpoint semantics connection description logics propositional modal logics turns useful 
fact syntactically monotone alc tboxes greatest xpoint semantics expressed propositional calculus extension propositional multimodal logic km xpoint operators see schild de giacomo lenzerini chapter details 
reasoning general inclusion axioms alc reasoning propositional calculus exptime complete reductions yield exptime upper bound reasoning cyclic terminologies sublanguages alc 
expressive dls ecient algorithms obtained help techniques nite automata 
baader sketch techniques small language fl results extended language aln develop results fl steps starting alternative characterization subsumption fl concept descriptions extending characterization cyclic tboxes greatest xpoint semantics 
baader considers cyclic fl tboxes descriptive xpoint semantics 
semantics characterization subsumption involved particular characterization subsumption descriptive semantics depends nite automata working nite words called uchi automata 
acyclic tboxes seen special case cyclic tboxes types semantics coincide 
subsection equivalence ud rewrite rule left right order compute structural subsumption normal form fl concept descriptions 
rule opposite direction obtain di erent normal form call concept centered normal form groups concept description concept names role names structural subsumption normal form 
rule fl concept description transformed equivalent description conjunction descriptions form 
rm necessarily distinct role names rm concept name abbreviate 
rm 
rm 
rm viewed word alphabet role names 
addition 
write fw nite set words 
term considered equivalent top concept means added conjunction changing meaning concept 
abbreviations pair fl concept descriptions containing concept names rewritten 

nite sets words alphabet role names 
normal baader nutt rs fig 

tbox corresponding automaton 
form provides characterization subsumption fl concept descriptions baader narendran size concept normal forms polynomial size original descriptions inclusion tests realized polynomial time yields polynomial time decision procedure subsumption fl fact shown baader structural subsumption algorithm fl seen special implementation inclusion tests 
characterization subsumption inclusion nite sets words extended cyclic tboxes greatest xpoint semantics follows 
tbox translated nite automaton states concept names occurring transitions induced value restrictions occurring see example baader formal de nition 
name symbol base symbol language la set words labeling paths languages la represent value restrictions satis ed instances concept intuition mind characterization subsumption cyclic fl tboxes greatest xpoint semantics surprising la la base symbols example fig 
la ss rss la obviously languages la regular regular language obtained language 
inclusion regular languages pspace complete problem garey johnson shows subsumption cyclic fl tboxes greatest xpoint semantics pspace complete baader strictly speaking obtain nite automaton word transitions transitions may labeled word letter 
basic description logics acyclic terminology automaton acyclic 
inclusion languages accepted acyclic nite automata conp complete proves nebel result subsumption acyclic fl tboxes conp complete nebel language extensions section introduced language alcn prototypical description logic 
applications expressive power alcn sucient 
reason various language constructors introduced literature employed systems 
roughly language extensions put categories lack better name call classical nonclassical extensions 
intuitively classical extension semantics easily de ned model theoretic framework introduced section de ning semantics nonclassical constructor problematic requires extension model theoretic framework semantics epistemic operator introduced section 
section brie introduce important classical extensions description logics 
inference procedures expressive dls discussed chapter 
nonclassical extensions subject chapter 
addition constructors build complex roles introduce expressive number restrictions constructors allow express relationships role ller sets di erent complex roles 
role constructors roles interpreted binary relations quite natural employ usual operations binary relations boolean operators composition inverse transitive closure role forming constructors 
syntax semantics constructors de ned follows de nition role constructors role name role description atomic role role descriptions intersection union complement composition transitive closure inverse role descriptions 
interpretation extended complex role descriptions follows ii 
iii transitive closure baader nutt iv 
example union roles de ne role haschild transitive closure haschild expresses role spring 
inverse haschild yields role 
complexity satis ability subsumption concepts language alcn called literature extends alcn intersection roles investigated donini shown problems pspace complete provided numbers occurring number restrictions written base representation size representation coincides number represented 
tobies shows result hold non unary coding numbers 
decidability extension alcn boolean operators inverse operator immediate consequence fact concepts extended language expressed rst order predicate logic variables counting quanti ers known decidable nexptime gr adel lutz sattler show alc extended role complement exptime complete alc extended role intersection atomic role complement nexptime complete 
baader dl alc trans extends alc transitive closure composition union roles introduced subsumption satis ability alc trans concepts shown decidable 
schild observation schild alc trans just syntactic variant propositional dynamic logic pdl fischer ladner yields exact complexity subsumption satis ability alc trans exptime complete fischer ladner pratt extension alc trans inverse constructor corresponds converse pdl fischer ladner shown decidable deterministic exponential time vardi extension alc trans change properties obtained dl signi cant way things complex number restrictions inverse roles added alc trans alc trans alc trans inverse nite model property alc trans extended inverse number restrictions 
easy see concept satis able nite interpretation nite 
dl exptime complete subsumption satis ability problem 
fact de giacomo number restrictions inverse roles boolean operators roles added alc trans exptime decidability shown ingenious reduction decision problem alc trans noted basic description logics atomic roles inverse may occur number restrictions complement roles built respect xed role contain roles need interpreted universal role 

shall see allowing complex roles inside number restrictions may easily cause undecidability 
expressive number restrictions di erent ways expressive power number restrictions enhanced 
consider called quali ed number restrictions number restrictions concerned role llers belonging certain concept 
example role haschild simple number restrictions introduced state number children certain limits concept haschild haschild 
quali ed number restrictions express sons daughters haschild male haschild female adding quali ed number restrictions alc leaves important inference problems subsumption satis ability concepts consistency aboxes decidable worst case complexity pspace complete 
membership pspace rst shown case numbers occurring number restrictions written base representation hollunder baader hollunder proved case binary equivalently decimal representation numbers tobies language stays decidable general sets inclusion axioms allowed buchheit second allow complex role expressions inside number restrictions 
mentioned allowing boolean operators inverse operator number restrictions alcn leaves known decidable 
baader sattler languages allow composition roles number restrictions considered 
extension alc number restrictions involving composition decidable satis ability subsumption problem 
hand number restrictions involving composition union inverse number restrictions involving composition intersection added satis ability subsumption undecidable baader sattler alc trans extension number restrictions involving composition undecidable baader sattler third replace explicit numbers number restrictions variables note composition expressed baader nutt stand arbitrary nonnegative integers baader sattler allows example de ne concept persons having daughters sons explicitly saying sons daughters person person expressive power language increased introducing explicit quanti cation numeric variables 
example important know numeric variables introduced value restriction 
illustrated concept person haschild haschild haschild introducing numerical variable universal value restriction sure children person number children 
stands existential quanti cation universal quanti cation numerical variables comes negation 
baader sattler shown alcn extended symbolic number restrictions universal existential quanti cation numerical variables undecidable satis ability subsumption problem 
restricts language existential quanti cation numerical variables negation atomic concepts satis ability decidable subsumption remains undecidable 
role value maps role value maps family expressive concept constructors available original kl system 
allow relate sets role llers role chains 
de nition role value maps role chain composition 
role names 
role chains concepts maps 
called containment role value map called equality role value map 
interpretation extended role value maps follows fa 

ii fa 
example concept person haschild knows basic description logics describes persons knowing friends children person describes persons having favorite foods spouse 
unfortunately presence role value maps subsumption problem undecidable language allows conjunction value restriction additional constructors schmidt schau see chapter 
avoid problem may restrict attention role chains functional roles called attributes features literature 
interpretation interprets role functional role implies assume set role names partitioned set functional roles set ordinary roles 
interpretation interpret functional roles 
usually write functional roles small letters possibly index 
de nition agreements role chains functional roles concepts agreement disagreement 
interpretation extended agreements disagreements follows fa 
ii fa 
literature agreement constructor called constructor 
note role chains functional roles role ller respective role chain 
note semantics agreements disagreements requires role llers exist equal distinct belong concept 
example usual interpretation functional roles haschild 
concept person describes persons name coincides name mother name father 
restriction functional roles reasoning alc extended agreements disagreements decidable hollunder nutt structural subsumption algorithm language provided classic system includes constructor borgida patel schneider general inclusion axioms transitive closure functional roles cyclic de nitions allowed agreements disagreements chains functional roles cause subsumption undecidable nebel baader nutt baader additional types role interaction constructors similar agreements role value maps investigated hanschke maarten de rijke pointers literature beth de nability modal logics 
bibliography baader hanschke franz baader philipp hanschke 
schema integrating concrete domains concept languages 
proc 
th int 
joint conf 
arti cial intelligence ijcai pages 
baader hollunder franz baader bernhard hollunder 
terminological knowledge representation system complete inference algorithm 
proc 
workshop processing declarative knowledge volume lecture notes arti cial intelligence pages 
springer 
baader narendran franz baader narendran 
uni cation concept terms description logics 
prade editor proc 
th eur 
conf 
arti cial intelligence ecai pages 
john wiley sons 
baader sattler franz baader ulrike sattler 
description logics symbolic number restrictions 
proc 
th eur 
conf 
arti cial intelligence ecai pages 
john wiley sons 
baader sattler franz baader ulrike sattler 
number restrictions complex roles description logics preliminary report 
proc 
th int 
conf 
principles knowledge representation reasoning kr pages 
baader sattler franz baader ulrike sattler 
expressive number restrictions description logics 
logic computation 
baader franz baader hans urgen bernhard nebel werner nutt gert smolka 
expressivity feature logics negation functional uncertainty sort equations 
logic language information 
baader franz baader enrico franconi bernhard hollunder bernhard nebel hans urgen pro 
empirical analysis optimization techniques terminological representation systems making kris get move 
applied arti cial intelligence 
special issue knowledge base management 
baader franz baader martin buchheit bernhard hollunder 
cardinality restrictions concepts 
arti cial intelligence 
baader franz baader ralf ralf molitor 
structural subsumption considered automata theoretic point view 
proc 
description logic workshop dl 
ceur electronic workshop proceedings ceur ws 
org vol 
baader franz baader 
augmenting concept languages transitive closure roles alternative terminological cycles 
proc 
th int 
joint conf 
arti cial intelligence ijcai 
baader franz baader 
automata theory characterizing semantics terminological cycles 
ann 
mathematics arti cial intelligence 
basic description logics borgida patel schneider alexander borgida peter patel schneider 
semantics complete algorithm subsumption classic description logic 
arti cial intelligence research 
borgida alexander borgida 
relative expressiveness description logics predicate logics 
arti cial intelligence 
brachman schmolze ronald brachman james schmolze 
overview kl knowledge representation system 
cognitive science 
brachman ronald brachman deborah mcguinness peter lori resnick alexander borgida 
living classic kl language 
john sowa editor principles semantic networks pages 
morgan kaufmann los altos 
brachman ronald brachman 
concept structural foundations semantic networks 
int 
journal man machine studies 
brachman ronald brachman 
structured inheritance networks 
woods brachman editors research natural language understanding quarterly progress report bbn report pages 
bolt beranek newman cambridge mass 
franconi tessaris 
implementing testing expressive description logics preliminary report 
proc 
description logic workshop dl pages 
buchheit martin buchheit francesco donini andrea schaerf 
decidable reasoning terminological knowledge representation systems 
arti cial intelligence research 
de giacomo lenzerini giuseppe de giacomo maurizio lenzerini 
boosting correspondence description logics propositional dynamic logics 
proc 
th nat 
conf 
arti cial intelligence aaai pages 
aaai press mit press 
de giacomo lenzerini giuseppe de giacomo maurizio lenzerini 
concept language number restrictions xpoints relationship calculus 
proc 
th eur 
conf 
arti cial intelligence ecai pages 
de giacomo lenzerini giuseppe de giacomo maurizio lenzerini 
uniform framework concept de nitions description logics 
arti cial intelligence research 
de giacomo giuseppe de giacomo 
decidability class knowledge representation formalisms 
phd thesis dipartimento di informatica sistemistica universit di roma la sapienza 
donini massacci francesco donini fabio massacci 
exptime tableaux alc 
arti cial intelligence 
donini francesco donini maurizio lenzerini daniele nardi werner nutt 
tractable concept languages 
proc 
th int 
joint conf 
arti cial intelligence ijcai pages sydney australia 
donini francesco donini maurizio lenzerini daniele nardi werner nutt andrea schaerf 
adding epistemic operators concept languages 
proc 
rd int 
conf 
principles knowledge representation reasoning kr pages 
morgan kaufmann los altos 
donini francesco donini maurizio lenzerini daniele nardi andrea schaerf 
deduction concept languages subsumption instance checking 
logic computation 
baader nutt donini francesco donini maurizio lenzerini daniele nardi werner nutt 
complexity concept languages 
information computation 
donini francesco donini maurizio lenzerini daniele nardi werner nutt andrea schaerf 
epistemic operator description logics 
arti cial intelligence 
fischer ladner michael fischer richard ladner 
propositional dynamic logic regular programs 
computer system sciences 
fitting melvin fitting 
basic modal logic 
handbook logic arti cial intelligence logic programming volume pages 
oxford science publications 
gabbay dov gabbay 
craig interpolation theorem modal logics 
proceedings logic conference volume lecture notes mathematics pages 
springer 
garey johnson garey johnson 
computers intractability guide np completeness 
freeman san francisco ca usa 
gr adel erich gr adel martin otto eric rosen 
variable logic counting decidable 
proc 
th ieee symp 
logic computer science lics pages 
ieee computer society press 
haarslev oller volker haarslev ralf oller 
expressive abox reasoning number restrictions role hierarchies transitively closed roles 
proc 
th int 
conf 
principles knowledge representation reasoning kr pages 
haarslev oller volker haarslev ralf oller 
high performance reasoning large knowledge bases practical case study 
proc 
th int 
joint conf 
arti cial intelligence ijcai pages 
haarslev oller volker haarslev ralf oller 
racer system description 
proc 
int 
joint conf 
automated reasoning volume lecture notes arti cial intelligence pages 
springer 
haarslev volker haarslev carsten lutz ralf oller 
description logic concrete domains role forming predicates 
logic computation 
hanschke philipp hanschke 
specifying role interaction concept languages 
proc 
rd int 
conf 
principles knowledge representation reasoning kr pages 
morgan kaufmann los altos 
hollunder baader bernhard hollunder franz baader 
qualifying number restrictions concept languages 
technical report rr deutsches forschungszentrum ur intelligenz dfki kaiserslautern germany 
abridged version appeared proc 
nd int 
conf 
principles knowledge representation reasoning kr 
hollunder nutt bernhard hollunder werner nutt 
subsumption algorithms concept languages 
technical report rr deutsches forschungszentrum ur intelligenz dfki kaiserslautern germany 
hollunder bernhard hollunder werner nutt manfred schmidt schau 
subsumption algorithms concept description languages 
proc 
th eur 
conf 
arti cial intelligence ecai pages london united kingdom 
pitman 
basic description logics hollunder bernhard hollunder 
hybrid inferences kl knowledge representation systems 
proc 
german workshop arti cial intelligence pages 
springer 
hollunder bernhard hollunder 
consistency checking reduced satis ability concepts terminological systems 
ann 
mathematics arti cial intelligence 
horrocks patel schneider ian horrocks peter patel schneider 
optimizing description logic subsumption 
logic computation 
horrocks sattler ian horrocks ulrike sattler 
description logic transitive inverse roles role hierarchies 
logic computation 
horrocks ian horrocks 
expressive description logic fact ction 
proc 
th int 
conf 
principles knowledge representation reasoning kr pages 
ralf 
characterizing semantics terminological cycles aln nite automata 
proc 
th int 
conf 
principles knowledge representation reasoning kr pages 
levesque brachman hector levesque ron brachman 
expressiveness tractability knowledge representation reasoning 
computational intelligence 
lutz sattler carsten lutz ulrike sattler 
complexity reasoning boolean modal logic 
proc 
advances modal logic 
lutz carsten lutz 
complexity terminological reasoning revisited 
proc 
th int 
conf 
logic programming automated reasoning lpar volume lecture notes arti cial intelligence pages 
springer 
macgregor robert macgregor 
evolving technology classi cation knowledge representation systems 
john sowa editor principles semantic networks pages 
morgan kaufmann los altos 
michael 
languages variables 
zeitschrift ur mathematische logik und grundlagen der mathematik 
nebel bernhard nebel 
computational complexity terminological reasoning back 
arti cial intelligence 
nebel bernhard nebel 
terminological reasoning inherently intractable 
arti cial intelligence 
nebel bernhard nebel 
terminological cycles semantics computational properties 
john sowa editor principles semantic networks pages 
morgan kaufmann los altos 

complexity variable logic counting 
proc 
th ieee symp 
logic computer science lics pages 
ieee computer society press 
patel schneider peter patel schneider 
undecidability subsumption 
arti cial intelligence 
patel schneider peter patel schneider 
dlp 
proc 
description logic workshop dl pages 
ceur electronic workshop proceedings ceur ws org vol 
pratt pratt 
models program logic 
proc 
th annual symp 
foundations computer science focs pages 
pratt pratt 
near optimal method reasoning action 
baader nutt computer system sciences 
sattler ulrike sattler 
concept language extended di erent kinds transitive roles 
unter ste en editors proc 
th german annual conf 
arti cial intelligence ki number lecture notes arti cial intelligence pages 
springer 
savitch savitch 
relationship nondeterministic deterministic tape complexities 
computer system sciences 
schaerf andrea schaerf 
reasoning individuals concept languages 
data knowledge engineering 
schild klaus schild 
correspondence theory terminological logics preliminary report 
proc 
th int 
joint conf 
arti cial intelligence ijcai pages 
schild klaus schild 
combining terminological logics tense logic 
proc 
th portuguese conf 
arti cial intelligence volume lecture notes computer science pages 
springer 
schild klaus schild 
terminological cycles propositional calculus 
doyle sandewall torasso editors proc 
th int 
conf 
principles knowledge representation reasoning kr pages bonn germany 
morgan kaufmann los altos 
schmidt schau smolka manfred schmidt schau gert smolka 
attributive concept descriptions complements 
arti cial intelligence 
schmidt schau manfred schmidt schau 
subsumption kl undecidable 
ron brachman hector levesque ray reiter editors proc 
st int 
conf 
principles knowledge representation reasoning kr pages 
morgan kaufmann los altos 
smolka gert smolka 
feature logic subsorts 
technical report ibm box stuttgart germany 
tarski alfred tarski 
lattice theoretical xpoint theorem applications 
paci journal mathematics 
tobies stephan tobies 
pspace algorithm graded modal logic 
ganzinger editor proc 
th int 
conf 
automated deduction cade volume lecture notes arti cial intelligence pages 
springer 
tobies stephan tobies 
pspace reasoning graded modal logics 
logic computation 
vardi wolper moshe vardi pierre wolper 
automata theoretic techniques modal logics programs 
computer system sciences 
preliminary version appeared proc 
th acm sigact symp 
theory computing stoc 
vardi moshe vardi 
taming converse reasoning way computations 
parikh editor proc 
th workshop logics programs volume lecture notes computer science pages 
springer 
