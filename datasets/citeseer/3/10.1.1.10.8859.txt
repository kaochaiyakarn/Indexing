strategies fusing logic control local application specific transformations patricia johann eelco visser technical report uu cs institute information computing sciences utrecht university february copyright patricia johann eelco visser issn address patricia johann department computer science rutgers university nj www crab rutgers edu crab rutgers edu eelco visser institute information computing sciences utrecht university box tb utrecht www cs uu nl visser visser acm org strategies fusing logic control local application specific transformations patricia johann eelco visser department computer science rutgers university nj www 
crab 
rutgers 
edu crab rutgers edu institute information computing sciences universiteit utrecht box tb utrecht netherlands www 
cs 
uu 
nl visser visser acm org programming supports separation logical concerns issues control program construction 
separation concerns leads reduced code size increased reusability code main disadvantage computational overhead incurs 
fusion techniques combine reusability programs efficiency specialized programs 
stratego language program transformation paradigm rewriting strategies 
stratego transformation rules define basic transformation steps user definable strategies control application rules program 
problem specific rules highly generic strategies apply kept separate elements combined mix match fashion produce variety program transformations 
instances separation concerns leads inefficient implementations 
show inefficiencies remedied fusion 
furthermore show fusion implemented rewriting strategies studying detail application rewriting strategies fusion generic innermost strategy sets arbitrary rewrite rules 
optimization programs optimization applies specified stratego 
contributions twofold 
place show optimize reason rewriting strategies opens new area strategy optimization 
second place demonstrate optimizations implemented effectively local application specific transformations 
techniques applicable transformation programs languages stratego 

programming techniques support generic definition algorithmic functionality way different configurations algorithms obtained composing appropriate specializations generic components 
generic components specialized different ways resulting instances reused combinations 
advantages programming reduced code size increased modularity programs 
disadvantage programming separation supports logical concerns issues control program construction introduce considerable overhead simple computations 
contrast code written specifically implement particular problem instance effectively logic control arrive efficient implementation possible generically 
challenge programming maintain high level separation concerns simultaneously achieving efficiency intermingled programs 

fusing compositions programs fusion techniques mitigate tension modularity efficiency automatically deriving efficient versions programs composite versions 
achieved pieces generic components code relevant specific problem instances 
deforestation functional programs example intermediate data structures eliminated fusing function compositions :10.1.1.30.9032
style numeric programming fusion enables transformation algebraic style programming resembling mathematical specification numeric programs updating style function arguments overwritten order reuse memory allocated large matrices 
fusion optimize individual software components complete applications constructed automation packs enormous potential programming large 
experienced programmer easily optimize small program keyboard hand optimization modest programs difficult error prone 
programs larger complex difficulty fusing programs hand pronounced 
automatic fusion tools allow programmer program style compromising program efficiency 

programming stratego consider programming fusion techniques stratego :10.1.1.35.1581
stratego domain specific language specification program transformation systems paradigm rewriting strategies 
separates specification basic transformation rules specification strategies means rules applied 
strategies control application transformation rules programmed small set primitive strategy combinators 
combinators support definition generic patterns control turn allows strategies rules composed necessary achieve various program transformations 
resulting style programming leads concise reusable specifications program transformation systems 
due genericity strategies information perform tasks efficiently specializations strategies implemented efficiently 

generic innermost strategy pattern control particular interest innermost term traversal 
innermost traversal foundation successful evaluation mechanisms variety programming languages widespread automated deduction 
innermost evaluation strategy obtained specializing generic innermost traversal strategy parameterized particular set rules applied subject term innermost traversal set evaluation rules innermost normalization strategies suitable applications obtained similar manner 
despite ease generic innermost traversal strategies defined stratego efficiency concerns prevented stratego programmers practice 
innermost normalization strategy innermost takes argument transformation normalizes terms respect transformation 
application innermost form innermost 
rn optimized specific transformation rules ri 
innermost normalization proceeds traversing subject term bottom applying specified transformation rules subterm 
rule ri successfully reduces subterm strategy innermost 
rn applied bottom reduct order normalize 
result subterms reduct subterms original subterm reconsidered normalization 
fact depending structure right hand side ri subterms reduct correspond variables left hand side ri may reconsidered normalization number times 
course subterms normalized ri applied subject term need considered renormalization 
fusing control captured innermost logic embodied set rules rn yields implementation innermost 
rn renormalization variable subterms completely avoided 

fusing innermost transformation rules develop transformation stratego programs fuses generic innermost traversal set rules instantiated 
optimization fully automatable implemented stratego 
section prove correct respect operational semantics stratego programs transforms 
contributions twofold 
place show reasoning optimizing strategies rewriting proceed opening new area symbolic computation strategies 
second place demonstrate effective implementation optimizations stratego combination interesting techniques idioms 
writing transformations concrete syntax object language specification easier understand 
dynamic rules allows definition contextsensitive transformations 
introduce idiom cascading local application specific transformations allows specification complex transformations sets simple rules 
application techniques restricted particular optimization innermost traversals studied optimizations stratego programs transformations programs languages 
fusion optimization described techniques implement part stratego compiler version 

outline remainder organized follows 
section cover basics stratego introduce generic stratego specification innermost normalization 
section explore different idioms program transformation sketch realization stratego 
particular explain concepts local application specific transformations 
section discuss shortcomings modular specification innermost optimized version innermost strategy argue automatic derivation optimized programs modular ones needed 
section shows informally optimized specification innermost derived systematic way original specification 
sections discuss implementation transformation stratego 
section formalizes syntax semantics stratego 
section explains stratego programs transform stratego programs 
section formalizes transformation rules section 
section presents strategy combines rules complete fusion transformation 
novel uses stratego highlighted defining fusion transformation strategy correctness transformation established introduced 
section discusses previous related 
see www stratego language org distribution stratego compiler library 

rewriting strategies stratego stratego language specifying program transformations 
key design choice language separation logic control 
logic program transformations captured rewrite rules programmable rewriting strategies control application rules 
section informally describe subset stratego object transformations 
illustrate show small specification simplifies expressions natural numbers addition generic specification innermost normalization 
formal description syntax operational semantics subset stratego concerned section 

signatures terms stratego programs transformed expressed order terms 
signatures describe structure terms 
term signature nullary constructor application tn ary constructor terms ti example zero succ zero plus succ zero zero terms signature 
note terms variable free definition 

rewrite rules rewrite rules express basic transformations terms 
rewrite rule form label rule term patterns left hand side right hand side respectively 
term pattern variable nullary constructor application pn ary constructor term patterns pi 
write vars variables occurring pattern regard terms term patterns containing variables 
shows rewrite rules simplify sums natural numbers 
indicated stratego provides simple module structure allows modules import modules 
module peano signature sorts nat constructors zero nat succ nat nat plus nat nat nat rules plus zero plus succ succ plus example stratego module signature rewrite rules 
module apply peano imports innermost peano strategies main innermost peano rules 
rule applies term pattern matches variables replaced terms way result precisely applying effect transforming term obtained replacing variables subterms correspond 
example rule transforms term plus succ zero succ zero term succ plus zero succ zero 
corresponds zero corresponds succ zero 
normal interpretation term rewriting terms normalized exhaustively applying rewrite rules subterms applications possible 
term plus succ zero zero instance normalizes term succ zero rules normalizing term respect rules specification desirable rewrite systems need confluent terminating careful control necessary 
common solution introduce additional constructors signatures encode control means additional rules specify order original rules applied 
programmable rewriting strategies provide alternative mechanism achieving control avoiding new constructors rules 

combining rules strategies figures illustrate strategies control rewriting 
gives generic definition notion innermost normalization transformation strategy instantiated selection rules achieve normalization terms rules 
instance strategy main defined normalize nat terms innermost strategy instantiated rules 
general transformation rules reduction strategies defined independently combined various ways 
different selection rules rules applied different strategy 
possible stratego develop library valid transformation rules applied various strategies needed 

rewriting strategies rewriting strategy program transforms terms fails doing 
case success result transformed term course original term 
case failure result 
module innermost strategies try id bottomup bottomup innermost bottomup try innermost generic traversal strategies 
rewrite rules just strategies apply transformations roots terms 
strategies combined complex strategies means stratego strategy operators 
identity strategy id succeeds leaves subject term unchanged 
failure strategy fail fails 
sequential composition strategies attempts apply subject term 
succeeds applies result fails 
deterministic choice strategies attempts apply subject term 
fails attempts apply subject term 
fail fails 
recursive closure rec strategy attempts apply subject term strategy obtained replacing occurrence variable strategy rec 
negation strategy succeeds identity transformation fails fails succeeds 
strategy definition xn introduces new strategy operator parameterized strategies xn having body definitions recursive 
fact recursion operator rec shorthand recursive definition 
term traversal strategy combinators just described combine strategies apply transformation rules roots subject terms 
order apply rule subterm subject term term traversed 
stratego defines primitive operators expose direct subterms constructor application 
combined operators described define wide variety complete term traversals 
purposes restrict discussion traversal operators congruence operators operator 
congruence operators provide mechanism term traversal stratego 
constructor corresponding congruence operator denoted ary constructor corresponding congruence operator defines strategy sn 
strategy applies terms form tn 
results term tn provided application strategy si term ti succeeds result ti 
application si ti fails application sn tn fails 
congruence operators support definition traversals specific data type stratego provides combinators composing generic traversals 
operator applies direct subterms ti constructor application tn 
succeeds application direct subterm succeeds 
case resulting term constructor application tn term ti obtained applying ti 
note identity constants constructor applications children 
example definition strategy bottomup 
strategy expression bottomup specifies applied recursively direct subterms subterms subject term 
succeeds applied resulting term 
definition bottomup captures generic notion bottom traversal term 

innermost normalization innermost strategy defined bottomup 
performs bottom traversal term applying strategy try innermost subterm 
subterm applying try innermost subterms transformation applied 
succeeds reduct resulting transformation recursively normalized 
fails subterm normal form 
innermost strategy captures notion parallel innermost reduction 
specifications innermost normalization possible stratego representations strategies general unique 
particular unfolding definition innermost twice folding local recursion arrive alternative specification innermost bottomup try innermost bottomup try bottomup try innermost bottomup rec try bottomup 
transformation techniques idioms section briefly outline extension stratego concrete syntax dynamic rules discuss number useful transformation idioms show stratego naturally supports implementation 
hand idioms motivate programmable strategies 
tools applied fusion transformation 

concrete syntax previous section saw stratego define transformations syntax trees representing programs transformed text representations 
direct manipulation syntax trees unwieldy larger program fragments 
stratego supports specification transformation rules concrete syntax object language 
example concrete syntax declare transformation strategy expressions equivalent transformation syntax trees seq seq seq concrete syntax merely syntactic sugar specification transformations corresponding syntax 

dynamic rules programmable rewriting strategies provide control application rewrite rules 
limitation pure rewriting rewrite rules context free 
rewrite rule information obtained pattern matching subject term case conditional rewriting subterms subject term 
transformations information context program fragment needed 
extension strategies scoped dynamic rules possible access information 
standard rewrite rules stratego dynamic rules generated runtime access information available generation contexts 
example strategy transformation rule defines replacement call ss appropriate instantiation body definition declare inline rule rules strategy ss ss rule generated context definition strategy applied call sites ss 
see section details 
dynamic rules class entities applied part global term traversal 
possible restrict application dynamic rules certain parts subject terms rule scopes limit live range rules 

cascading transformations basic idiom program transformation achieved term rewriting cascading transformations 
applying single complex transformation algorithm program number small independent transformations applied combination program program unit achieve desired effect 
individual transformation step achieves little cumulative effect significant transformation feeds results ones came 
cascading transformations key example compilation transformation approach applied glasgow haskell compiler 
ghc applies large number small trivial program transformations programs achieve large scale optimization accumulating small program changes 
common cascading transformations accomplished exhaustively applying rewrite rules subject term 
stratego definition cascading normalization strategy respect rules 
rn formalized innermost strategy simplify innermost 
rn strategies possible 
example ghc simplifier applies rules single traversal program tree rules applied way way 
expressed stratego strategy simplify repeat 
rn repeat try repeat 
staged transformations cascading transformations apply number rules entire program 
cases appropriate 
instance transformations may inverses repeatedly applying lead non termination 
remedy difficulty stratego supports idiom staged transformation 
staged computation transformations applied subject term stages 
stage rules particular subset entire set available rules applied 
program transformation system idiom called sequence normal forms program tree transformed sequence steps performs normalization respect specified set rules 
stratego idiom expressed directly simplify innermost 
ak innermost 
bl 
innermost 
cm staged transformations applied fruitfully combination cascading transformations transformation sequence stages stage cascading transformation 
ghc simplifier mentioned effect staged transformation simplification traversal program tree repeated alternated various analyses 
hand steps staged transformation quite different idioms involve complex monolithic computations 
advantage separating rules strategies particularly compelling case staged transformations 
rules defined independently particular stages easy reuse different stages 

local transformations conventional program optimization transformations applied program 
optimizing imperative programs example complex transformations applied entire programs 
ghc style compilation small transformation steps applied programs 
introduce style transformation mixture ideas 
applying complex transformation algorithm program staged cascading transformations accumulate small transformation steps large effect 
applying transformations subject program wish apply locally selected parts subject program 
allows transformations rules beneficial applied 
example strategy achieves transformation transformation trigger transformation innermost 
strategy descends term subterm encountered transformation succeeds 
case strategy trigger transformation recognizes program fragment transformed 
cascading transformations applied locally terms transformation triggered 
course sophisticated strategies finding application locations applying rules locally 
key observation underlying idiom remains transformations applied local special knowledge subject program point application 
allows application rules applicable 

application specific transformations optimizers usually generic transformations transformations derived semantics programming language consideration generic analyses applied subject programs 
knowledge specific application hand available possible achieve better results 
application specific transformations allow special knowledge specific application specific library transformations 
conventional fusion techniques functional programming languages foldr build fusion destroy unfoldr fusion hylo fusion application specific transformations 
foldr build rule example relies programs written terms specialized program constructs build foldr encode uniform production consumption algebraic data structures respectively 
rule assumes constructs exhibit particular operational behaviors way verified compiler fusion performs program transformation correct respect assumption 
possible provide application specific transformations ghc user definable rewrite rules applied part simplification 
fusion transformation innermost relies library knowledge general program analysis 
order ensure innermost strategy program conforms expected semantics definition matched library definition 
matching successful strategy inlined call optimized 
general approach transformation cascading style locally applicable transformation rules applied 
key step transformation insight algorithm syntactic manipulation transformation considered encoding insight 
syntax directed application specific program transformations achieve greater degree optimization effectively possible general program analysis 

optimized specification innermost reduction previous sections seen variety generic rewriting strategies composed combinators strategies turn encode wide variety transformation idioms 
done preserving separation rules strategies 
generality come price 
inspection specification innermost strategy reveals inefficiency resulting way traverses terms 
difficulty subterms normalized may reconsidered normalization number times 
consider transformation term innermost module apply peano strategies main bottomup rec plus zero plus succ succ plus id optimized strategy 
strategy 
definition innermost applied subterm proper subterms normal form 
example term matching left hand side plus succ rule subterms corresponding variables normalized 
appropriate instance right hand side succ plus constructed normalized innermost 
entails terms bound completely renormalized variable subterms completely traversed rules tried subterms 
variable subterms terms normal form actual transformation occurs course specification innermost requires traversal 
traversing entirety subterm resulting application rule leads suboptimal performance normalization strategy 

optimizing innermost suboptimal complexity innermost strategy direct result separation concerns generic strategy rules parameterized 
knowledge specific rules normalization hand efficient implementation innermost strategy achieved 
example specific case innermost normalization respect rules efficient definition 
definition completely avoids renormalization variable subterms 
original definition innermost optimized definition performs innermost normalization term respect rules renormalizing subterm term resulting single step reduction optimized strategy recursively applies reduction strategy non variable subterms reduct 
examination optimized strategy shows accomplished 
original innermost strategy strategy performs bottom traversal 
node recursive strategy tries apply rule rule vacuously succeeds id separating rules strategy rules intertwined 
effectively rules rephrased terms true primitive actions rewriting pattern matching pat pattern instantiation build 
rule rephrased plus zero rule rephrased plus succ succ plus scope pattern variables delimited scope construct xn 
see section formal definitions pat pat variable scope 
applying complete innermost strategy reduct rule application inner recursive strategy invoked subterms reduct may normal form 
particular applied variable subterms left hand side rule known normal form 
notation denotes application strategy instance term determined current bindings 
scoped strategy replaces subject term form plus zero subterm similarly second replaces term form plus succ term obtained applying strategy term obtained applying succ term obtained applying plus applied 

effect optimization rules strategy quite effective seen benchmark results 
benchmark innermost reduce terms form plus succ zero nested deep 
reduction plus requires steps entire reduction requires steps 
results show run time original strategy grows faster optimized version 
fusing strategies rules apply significantly efficient implementations transformations achieved 
writing tangled specifications rewrite systems attractive leads complex specifications specifications rules tied specific transformations reused ones 
furthermore explicit recursive invocation transformation right hand side rules clear belongs original transformation rule belongs strategy 
understanding maintaining rules difficult 
entangled specification efficient modular better development 
automatically fusing generic strategy arguments attractive 
see possible 
section show optimized version derived generic version 
section show automatic fusion derive optimized rewrites plain fused time sec time sec zero plus succ zero benchmark results unoptimized optimized transformation innermost applied terms generated 
table shows number rewrites rule applications performed strategies time seconds number rewrite steps second 
benchmarks performed ghz pentium gb ram benchmark uses 
definition innermost generic version 
original optimized versions operational semantics proved section 

deriving optimized specification section show optimized implementation derived strategy innermost systematic transformation 
demonstrate derivation technique applying specific program innermost optimize application innermost selection rules equally 
remainder formalize stratego transformation rules develop strategy automatically applying correct order 
goal derivation fuse recursive invocation innermost right hand sides rules achieve rules inline unfold strategy definitions order arrive single expression containing complete specification innermost strategy 
bottomup strategy distributed right hand sides rules innermost applied 

desugaring rules stratego rules primitives 
rules expressed terms constructs rule just syntactic sugar strategy definition xn xi variables occurring rule 
similarities original definition innermost optimized definition apparent observe rules represent strategy definitions plus zero plus succ succ plus respectively 

inlining definitions step derivation consists inlining definitions replacing call strategy body definition 
xn definition strategy operator call sn operator replaced sn xn strategy obtained replacing formal parameters body actual arguments 
case main strategy inlining gives innermost definition innermost derivation page expands bottomup rec try bottomup inlining definitions rules gives bottomup rec try plus zero plus succ succ plus bottomup 
sequential composition choice step derivation right distribute bottomup strategy deterministic choice operator rule rule valid strategy expressions 
consider term succeed fails succeeds 
strategy fail application attempted succeed 
hand rule hold guaranteed succeed situation success failure sides rule determined wholly success failure id succeeds strategy try succeeds parameter strategy recursive strategy guaranteed succeed 
turn implies bottomup guaranteed succeed right distribution bottomup rule valid 
gives bottomup rec try plus zero bottomup plus succ succ plus bottomup 
sequential composition scope order apply bottomup right hand sides argument rules try need bring scope rules applying transformation xs xs rule valid variables xs free 
application transforms bottomup rec try plus zero bottomup plus succ succ plus bottomup 
strategy application apply bottomup term built right hand side rule 
get bottomup rec try plus zero bottomup plus succ bottomup succ plus 
distribution bottomup application bottomup constructor application leads derivation bottomup tn definition bottomup bottomup tn semantics sequential composition bottomup tn semantics bottomup bottomup tn repeatedly applying rule bottomup tn bottomup bottomup tn bottomup distributed term constructions right hand sides rules variables encountered 
doing running example gives bottomup rec try plus zero bottomup plus succ succ plus bottomup bottomup 
avoiding renormalization may observation bottomup variable originating left hand side rule rewrite right hand sides rule arguments try 
words vs contains variables occurring vs vs strategy occurrences bottomup replaced 
observation valid terms matching variables left hand side rule normal form 
observation relies non local information needs example know variables appear give rise transformation local sense applied single strategy 
specifically transformation bottomup applied selected part program control particular program transformation strategy 
arrive desired optimized version innermost bottomup rec try plus zero plus succ succ plus sp dn xn mpat xn sn sn rec id fail mpat mpat tn xn tn syntax stratego subset 
syntax semantics stratego section formalize syntax operational semantics stratego described informally sections 
concrete syntax aid definition transformations optimize applications innermost welldefined operational semantics enable prove transformations correct 
formalize elements stratego needed results 

syntax syntax subset stratego concerned appears 
name stands strategy term pattern depending context 
numbered item syntactic class counterpart 
stratego program sp listing strategy definitions 
strategy definition introduces parameterized strategy operator 
strategy application match primitive mpat match pattern application build primitive build pattern scoped strategy clause application traversal operator strategy sequential composition strategies deterministic choice strategies negation strategy application defined strategy operator appropriate number argument strategies application congruence operator appropriate number strategies recursive closure strategy identity strategy failure strategy 
constructs introduced informally sections 
formal semantics subsection 
match pattern mpat variable fixed arity constructor applied appropriate number match patterns 
build pattern variable fixed arity constructor applied appropriate number build patterns strategy applied build pattern 
stratego rules conditions introduced keyword 
operation applies strategy subject term 
succeeds original subject term restored newly obtained variable bindings kept 
conditional rule form denotes strategy definition xn 
body strategy matches attempts satisfy condition succeeds appropriate instance built 
conditional rules apply conditions clauses succeed 
term fixed arity constructor applied appropriate number terms 
pair term component environment second 
environment function variables terms finite domain 
write dom domain environment 
operational semantics gives operational semantics subset stratego concerned 
rules formalize earlier informal notion applying strategies terms 
formally strategies applied term environment pairs produce new pairs 
strategy pair write denote application informally speak applying strategy term explicit accompanying environment 
symbol denotes failure strategy application 
lists positive rules stratego 
strategy application rule applies root term component application fails 
course possible computations nonterminating 
notion environment extending rule match patterns 
say extends binding appears 
case write addition environment pat pattern pat instance pat obtained replacing occurrences variables pat bindings environment containing bindings xn xn denotes environment derived undoing bindings xi 
union environments disjoint domains denoted 
write xn really mean strategy definition stratego program currently consideration 
evaluation relative stratego program 
features stratego operational semantics worth calling special attention 
relation deterministic strategy id fail xn xn sn sn rec rec pat dom dom var pat dom pat pat pat pat 
patn en tn en pat patn tn en xn xn xn xi xi tn en tn en tn tn en sn tn en tn en sn tn tn en operational semantics stratego subset term environment pair exactly possible pair result application consequence necessarily confluent 
second stratego operational semantics structural compositional 
result standard syntax directed induction techniques prove properties relation 
techniques sections prove transformations optimizing applications innermost correct respect operational semantics stratego 

stratego transformations stratego sections discuss implement transformation stratego programs fuses applications innermost rules applied 
section introduce basic transformation rules transformation prove correctness 
section strategy apply rules prove correct 
strategy transformations optimize applications innermost implemented stratego strategies 

concrete syntax discussed section concrete syntax stratego defined specifying program transformations 
order distinguish syntax object expressions subjects transformations meta expressions implement transformations quotations 
term pat indicates term pattern transformed strategy represents strategy expression 
ambiguities arise leave term strategy prefixes 

correctness transformations correctness optimizing transformation proved transformation introduced 
informally strategy transformation said correct meaning input strategy transformation meaning transformed strategy 
depending application meaning assigned strategies different ways 
study strategy transformations operational behavior strategies interest 
formalize notion correctness follows 
strategy expressions 
transformation correct pairs iff 
stratego semantics compositional applying meaning preserving transformation strategy context root object language term represents preserves meaning strategy 
sequence meaning preserving strategy transformations strategy term meaning preserving 
strategies just ways apply transformation rules parts terms context establish correctness individual rules applied optimize innermost strategies assured strategy apply various parts terms correct 

preprocessing desugaring preprocessing desugaring takes place transformation begins 
preprocessing consists renaming various identifiers desugaring expands rules definitions scoped match build strategies 
module fusion rules imports stratego rules pat pat term pat term pat seq choice rules xs xs xs xs term bottomup ts term ts map term bottomup ts ts distribution association rules 
preprocessing desugaring clearly preserve meanings strategies 
example correctness strategy inlining follows semantics strategy definitions 

transformation rules rules derivation section formalized stratego rules 
prove correctness rule 
section combine rules strategy optimizes occurrences innermost strategy stratego specifications 
associate composition right rule associates sequential composition strategies right 
proposition pairs iff 
proof exist pair 
turn implies existence pair 
imply 
fact gives desired 
converse similar 
introduce application rule formalizes assertion section pat shorthand pat proposition pairs pat iff pat 
proof follows immediately semantics pat 
application sequence rule replaces application strategy application strategy sequential composition strategies 
place pattern pat appear strategy build pattern 
syntax build patterns see pat appear term pattern context 
prove correctness show effects left right hand sides context 
proposition pairs term pattern context con 
con pat iff con pat 
proof induction context con 
assume context empty 
pat iff pat 
holds iff exists pat 
proposition pat holds iff pat iff exists pair pat 
holds iff turn hold iff 
pat holds iff pat pat iff pat 
assume proposition proven contexts depth con 
context depth form con 
con 
context depth con pat iff pat con pat patn 
case iff form tn form tn en argument term ti ti ei ti ei 
particular happens iff con pat ti ei ti ei 
induction case iff con pat ti ei ti ei turn holds iff pat con pat patn iff con pat 
sequence choice left rule distributes sequential composition left deterministic choice strategies 
proposition pairs iff 
proof exists 

case 
second 
case 

case exist pair 
implies desired 
second case exist 
case 
may conclude case 
sequence choice right rule distributes sequential composition right deterministic choice strategies 
discussed section valid guaranteed succeed 
reflected implementation means dynamic rules mechanism 
seq choice strategy applied strategy expression known succeed 
matches strategy expression dynamic rule generated specific strategy 
prove correctness generated rule assuming guaranteed succeed 
proposition pairs succeeds iff 
proof exist pair 
entails 
case second 
case 

case exist 

second case holds succeeds hypothesis furthermore implies exists pair 
desired 
sequence scope right rule extends scope include strategy composed right 
proposition pairs xs iff xs 
proof renaming assume variables xs occur 
xs xs effect delimiting scope xs composition behave strategy input pair 
sequence scope left rule extends scope include strategy composed left 
proposition pairs xs iff xs 
proof renaming assume variables xs occur 
xs xs effect delimiting scope xs composition behave strategy input pair 
bottomup constructor rule distributes bottomup constructor application 
rule uses map strategy operator distribute application bottomup list arguments constructor 
rule transforms build pattern form bottomup pat patn build pattern bottomup pat bottomup patn 
transformation assume pattern matches constructor pattern strategy proposition suppose pattern matches free variables done 
pairs term pattern context con con bottomup pat patn iff con bottomup pat bottomup patn 
proof induction depth context 
give proof base case con empty context inductive case similar 
definition bottomup bottomup pat patn iff bottomup pat patn 
holds iff pat patn bottomup iff exist pairs pat patn bottomup 

pat patn tn iff sub pattern pi ti 
constant assumption bind variables 
holds iff precisely tn 
semantics operator happens iff bottomup tn tn bottomup ti ti precisely tn 
case iff bottomup ti iff bottomup ti case iff bottomup pat bottomup patn 
holds iff bottomup pat bottomup patn correctness proved base case 

transformation strategy derivation section implicitly particular strategy apply rewrite rules optimize applications innermost 
specifically applied rules certain subterms certain order 
section explicit strategy show coded stratego argue optimized strategies resulting application observable behavior ones derived 

fusion strategy strategy employed strategy fusion 
strategy transforms complete stratego specification composed main 
declare inline rules generates strategy operator definition rewrite rule inlines calls strategy operator 

check library definitions verifies library definitions certain strategy operators conform expected semantics 

innermost fusion uses top traversal fuse calls innermost 
consider detail subsections 
note combinator turns transformation program deal command line options input output terms 
goal section argue fusion preserves meanings specifications proposition strategy definition specification transformed fusion pairs iff 
arguing constituent strategies declare inline rules check library definitions innermost fusion preserves meanings strategies correct 
fusion declare inline rules check library definitions innermost fusion fusion strategy 
declare inline rules specification signature id strategies map declare inline rule declare inline rule rules strategy ss ss inline rules rec try scope id seq match id build id scope id seq match id seq id build id 
inlining inline strategy definitions initially argument innermost deterministic choice rules 
order specialize innermost choice rules rule definition desugared scoped match build representation 
ensures innermost strategy optimized right form processing inline rules 

generating inlining rules defines strategy declare inline rules generates strategy definition specification inlining rule 
done mapping declare inline rule list strategy definitions specification 
strategy declare inline rule matches strategy definition generates rule specific definition 
rule generated dynamically inherits bindings variables context corresponding strategy definition 
generated inlining rule matches strategy application sn replaces body strategy definition formal parameters replaced actual parameters sn 
order prevent name capture original strategy definition renamed renames bound strategy term pattern variables 
substitution actuals formals achieved substitution strategy 
proposition rule generated application declare inline rule strategy definition result applying strategy expression sn sn iff proof corresponds body formal parameters replaced actual parameters follows immediately semantics strategy calls 
correctness declare inline rules follows immediately proposition 
proposition strategy declare inline rules identity transformation specifications generates strategy definition meaning preserving inlining rule 
proof congruence strategy declare inline rules match strategy definition declare inline rule rules constructed declare inline rule changes term applied 
declare inline rule applied strategy definition turn map previous proposition generates correct inlining rule 

inlining rules inlining rules generated applied changing meanings programs 
replacing call useful strategy point view code size danger non termination inliner expanding recursive calls 
inlining best applied selectively 
case current transformation rules passed arguments innermost strategy inlined 
inline rules strategy inlines calls strategy expression toplevel calls calls arguments deterministic choice operator inlined 
particular inlining stops desugared rule encountered 
calls embedded clauses rules inlined 
strategy call inlined inline rules applied instantiated body strategy 
properly handles definitions form simplify innermost rule set rule set rule set 
rule set 
bm abstractions sets rules passed arguments innermost 
check library definitions check try try check innermost innermost check bottomup bottomup check innermost innermost new strategy innermost bottomup try innermost check implementations generic strategies proposition strategy inline rules meaning preserving transformation strategy expressions reduces strategy expressions form 
sn si strategy calls 
proof stated proposition meaning preserving 
entire computational effect inline rules apply subexpressions meaning preserving 
strategy replaces call residing left choice operator definition 

verifying library definitions innermost fusion strategy application specific assumptions semantics certain strategy operators library 
particular specifications innermost bottomup try assumed meaning forms 
just assumptions leave programmer library writer sure case 
libraries subject change extended safer build check assumptions valid 
strategy check library definitions verifies assumptions valid check strategies checks form specific strategy definition 
strategy check innermost innermost example inlines definition innermost library newly named strategy argument 
strategy resulting inlining matched expected result 
match succeeds iff library definition innermost proper form 
strategies check try try check bottomup bottomup perform similar verifications 
possible match semantically equivalent variants strategy definition account possible definitions implement particular strategy 
verifying library definitions application specific 
providing general program analysis de definition implements particular strategy knowledge application hand enable transformation 
proposition strategy check library definitions identity transformation specifications succeeds context set rules definitions try innermost bottomup expected semantics 
proof strategy change term applied 
check strategies match definition try innermost bottomup expected definitions fail incompatible definitions 

innermost fusion step fusion strategy traversal specification pass traversal tries apply innermost fusion 
innermost fusion rule defined consists parts 
part prepares argument call innermost fusion second part performs fusion build bottomup third part realizes goal transformation prevents renormalization variable subterms 
assumed desugaring inlining verification performed prior application innermost fusion 
assume inlining rules strategy definition disposal library functions expected meanings 

preparing fusion innermost fusion rule recognizes call innermost replaces canonical implementation argument strategy inlined fused 
rule generates fresh variable new strategy primitive 
primitive creates new name guaranteed occur term processed transformation 
fresh variable rule replaces innermost unfolding strategy 
replacement correct proposition observation innermost fusion strategies semantics proposition 
proposition strategy strategy variable occurring pairs innermost iff bottomup rec try bottomup proof definition innermost innermost iff bottomup try innermost 
applying definition innermost get innermost fusion innermost bottomup rec try new seq choice strategy bottomup bottomup var strategy bottomup inline rules fuse bottomup bottomup prevent renormalization innermost fusion strategy bottomup try bottomup try innermost recursive pattern emerging folded bottomup rec try bottomup unfolding strategy leads sequence transformations unfolding innermost 
knowledge local context innermost fusion rule generates dynamic rules 
seq choice strategy generates instance rule bottomup term distribute 
justified propositions 
proposition succeeds bottomup succeeds term environment exist term environment bottomup 
proof induction terms 
base case form 
semantics bottomup 
semantics sequential composition fact succeeds exist bottomup 
definition bottomup bottomup 
inductive case form tn terms tn 
induction hypothesis exist bottomup exist bottomup exist tn en bottomup tn en tn en 
semantics bottomup tn tn en 
semantics sequential composition fact succeeds exist bottomup tn en 
bottomup tn definition bottomup 
proposition context strategy fuse bottomup innermost fuse bottomup bottomup rec try bottomup strategy bottomup guaranteed succeed 
proof observe try guaranteed succeed 
try id application fails try succeeds 
particular try bottomup succeeds 
conclude succeeds 
previous proposition bottomup succeeds 
strategy bottomup var generates rules eliminate application bottomup variables left hand side rules 
elaborated 
preparatory steps rule innermost fusion inlines rules argument innermost 
results strategy equivalent proposition 
subsequently inlined rules fused bottomup applications bottomup variables left hand sides rules eliminated prevent renormalization 

performing fusion fusion right hand sides rules bottomup strategy implemented fuse bottomup strategy 
rules effect applying inner occurrence bottomup variable occurrence right hand side normalizing rule 
transformation correct correctness individual transformation rules proposition ensures correctness instance 

preventing renormalization final step fusion transformation transformation applications bottomup form bottomup just variable occurring left hand side normalization rules application prevent renormalization apply rules cond apply rules rec try scope id bottomup var bu rules replace application bu cond replace application bu replace application replace map rules replace term term replace prevent renormalization occurs right hand side rule 
transformation implemented strategy prevent renormalization 
strategy performs traversal fused argument innermost traversal strategy apply rules applies branches choice scope rule 
rule applies rules 
rules generated bottomup var specific bottomup expression rules fused 
actual application replacement done rule replace application 
takes triple strategy removed left hand side right hand side rule 
strategy yields list variables term pattern 
map expression generates variable left hand side replace rule replaces occurrence just variable replace rules applied right hand side traversal yielding new right hand side 

correctness far shown steps correct prevent renormalization 
remains proven valid replace bottomup variable left hand side argument rules innermost 
need prove bottomup identity terms bound variables left hand side rule terms normal form 
definition strategy say normal form environments subterm apply subterm 
proposition term normal form innermost innermost identity transformation terms normal form 
proof base case nullary constructor application reason follows innermost iff innermost try innermost iff try innermost normal form try innermost succeeds id id desired 
inductive case tn assume smaller terms proposition holds 
innermost iff innermost try innermost iff exist innermost try innermost innermost holds iff induction hypothesis innermost innermost innermost tn en tn innermost innermost innermost tn en tn en ti precisely ti 
en 
identical try innermost iff try innermost iff id normal form conclude innermost holds innermost 
saw holds theorem proved 
corollary normal form bottomup innermost bottomup innermost identity transformation terms form 
proof bottomup innermost just applies innermost subterms subject term proposition ensures identity terms normal form 
proposition innermost form innermost reduces terms normal form 
proof induction depth derivation witnesses fact innermost 
base case consider shortest derivation 
occurs nullary constructor innermost semantics try innermost 
try innermost id case 
semantics sequential composition innermost 
inductive case assume innermost holds proposition proven derivations shorter innermost 
reason follows innermost iff innermost try innermost iff exist innermost try innermost tn 
semantics terms tn environments en innermost innermost tn en tn en induction hypothesis terms tn normal form 
tn en 
distinguish cases 
case try innermost 
tn ti normal form proper subterm normal form apply normal form 
second case innermost 
induction hypothesis normal form 
corollary innermost tn tn en ti normal form 
proof immediately semantics previous proposition 
proposition application form innermost strategy applied root term proper subterms normal form 
proof application form innermost applied root term exist tn precisely tn innermost try innermost 
corollary ti normal form proper subterm normal form 
corollary application form innermost choice form 
sn si rule form xs terms bound variables normal form recursive application innermost terms right hand side identity transformation 
replacement application bottomup variables bound left hand side rule valid 
corollary assuming rules available definitions stratego program hand assuming library definitions try bottomup innermost expected semantics transformation rule innermost fusion transforms application innermost equivalent strategy expression 
corollary fusion transformation meaning preserving transformation stratego specifications 

discussion shown local application specific transformations optimize programs fusing logic control 
strategies play important roles approach 
appear programming devices subject optimization 
second taken local application specific transformation rules provide language automatic optimizations strategy programs specified elegant manner 
shown strategies specify elegant automatic optimizing transformations reduce inefficiencies associated genericity strategies programming tools 
approach number interesting transformation techniques idioms 
avoid manipulation large unwieldy syntax trees specifying transformation rules optimization terms concrete syntax object language 
addition optimizing strategy relies heavily stratego ability generate rewrite rules run time 
dynamic rules access information available generation contexts allow specification transformations possible express standard context free rewrite rules 
transformation strategies rewriting necessarily perform cascading transformations applying combination number small independent transformations achieve large scale effect 
limit availability certain transformations specific parts computations idiom staged transformation break transformation phases 
staged computations local transformations allow limit applicability transformation rules albeit different way 
local transformation uses special knowledge subject program point application perform computations beneficial applied entire program 
staged transformations local transformations available computation applicable subject term certain criteria met 
application specific transformations take special knowledge step allowing certain information specific library entire specification transformation 
application specific transformations optimization innermost normalization ensure library functions appropriate forms semantics 
stratego supports transformation idioms 
optimization strategy relies included optimization phase stratego compiler version 
specialization innermost strategy rules applied decreases complexity number rewrite steps reaching rewrites second example rewrite system 
noted rules complex left hand side cost rewrite step higher 
efficiency improvement respect unoptimized case dramatic 

previous elaboration earlier implementation innermost fusion 
earlier appeared print stratego extended dynamic rules syntax extensively specification 
extensions greatly improved clarified specification 
strategies optimize programs defined terms strategies 
example eliminate intermediate data structures functional programs 
strategies build optimizers intermediate format ml programs 
cases strategies conjunction small local transformations achieve large scale optimization effects 

related 
staged cascading transformation small local transformations dubbed humble transformations 
transformations extensively optimizing compilers compilation transformation idiom 
degree compilers necessarily recognizable rewrite rules implementation 
advantage programmable strategies approach transformation steps formulated separate rewrite rules combined optimization phases means strategies 

traversal optimization optimization innermost inspired general functional program optimization 
optimization scheme compositions functions uniformly consume algebraic data structures functions uniformly produce substitution instances 
scheme generic data structures proved correct respect operational semantics haskell languages 
involve completely incorporating ideas underlying scheme strategy languages arrive generally applicable provably correct optimizations strategy program patterns 
particular aim see innermost fusion technique described specialization innermost generic automatable fusion strategy provably correct respect operational semantics 
importance optimizing term traversals functional transformation systems discussed 
term traversals modelled fold functions fold algebras consideration updateable standard fusion techniques functional programs immediately applicable 
fusion techniques may provide means implementing optimizations automatically shortcut recursion term traversals 
suggested shortcuts recursion term traversals regarded program specialization specialization seen automated instance traditional fold unfold program optimization methodology optimization traversals achievable fold unfold transformations 
connections deserving investigation 

application specific optimization modern programming languages suited expressing programs compilers languages derive efficient implementations combinations abstractions 
generic optimizations clever disadvantage respect programmer additional information semantics program 
emerging approach domain specific application specific optimization extending capabilities compilers letting programmer specify additional information programs 
examples broadway compiler aims software libraries portable efficient allowing automatically customized different hardware software environments 
user definable rules glasgow haskell compiler ghc allow programmer state identities program expressions compiler simplify programs 
project compilers adapted semantic information adt natural abstraction level 
transformation described uses approach uses reasoning programmer specific library definition definition innermost derive efficient implementations 
specification currently stage provided compiler aim stratego compiler extensible arbitrary user definable transformations 

results demonstrate rewriting strategies optimizing programs implemented effectively elegantly local application specific transformations 
optimizing strategy fuses innermost normalizations terms respect collections rn standard rewrite rules 
optimizing strategies applications bottomup common term traversals choices standard rewrite rules useful 
rewrite rules respect term normalized generate side conditions usually equality certain subterms modulo normalization verified order assure applicability 
cases version innermost fusion strategy handles applications innermost choices conditional rewrite rules useful 
may try extend fusion technique dimensions traversal rules simultaneously 
generally may aim develop general theory traversal fusion stratego 
additional measurements needed evaluate optimizations achieved innermost fusion strategy similar benchmarks extensions strategy order 
interesting know mechanical derivation innermost fusion extensions possible definitions strategies degree stratego compiler fused 
acknowledgments patricia johann supported part national science foundation ccr 
simon peyton jones andrew tolmach roy dyckhoff wrs referees remarks previous version 
appel 
compiling continuations 
cambridge university press 
boyle 
programming program transformation approach reusing programs 
biggerstaff perlis editors software reusability volume pages 
acm press 
boyle winter 
program transformation system simplifying development numerical software 
arge editors modern software tools scientific computing pages 
birkh user 
dinesh haveraaen heering 
algebraic programming style numerical software optimization 
scientific programming 
fradet tayer 
compilation functional languages program transformation 
acm transactions programming languages systems jan 
gill launchbury peyton jones 
short cut deforestation 
functional programming languages computer architecture fpca pages 
acm press 
lin 
annotation language optimizing software libraries 
second conference domain specific languages dsl austin texas october 
usenix 
www usenix org events dsl html 
haveraaen johansen 
formal software engineering computational modeling 
nordic journal computing 
johann 
short cut fusion proved improved 
taha editor semantics applications implementation program generation volume lecture notes computer science pages florence italy 
springer verlag 
johann visser 
warm fusion stratego case study generation program transformation systems 
annals mathematics artificial intelligence 
johann visser 
fusing logic control local transformations example optimization 
gramlich lucas editors workshop reduction strategies rewriting programming wrs volume electronic notes theoretical computer science utrecht netherlands may 
elsevier science publishers 
jones gomard sestoft 
partial evaluation automatic program generation 
prentice hall 
kelsey hudak 
realistic compilation program transformation 
acm conference principles programming languages pages january 
kelsey 
compilation program transformation 
phd thesis yale university may 
mmel visser 
functional transformation systems 
proceedings th international workshop functional logic programming spain july 
launchbury sheard 
warm fusion deriving build recursive definitions 
jones editor functional programming languages computer architecture fpca pages 
acm press june 
muchnick 
advanced compiler design implementation 
morgan kaufmann publishers 
peyton jones tolmach hoare 
playing rules rewriting practical optimisation technique ghc 
hinze editor haskell workshop firenze italy september 
acm sigplan 
peyton jones hall hammond partain wadler 
glasgow haskell compiler overview 
uk joint framework information technology technical conference march 
peyton jones santos 
transformation optimiser haskell 
science computer programming september 
schupp gregor musser 
user extensible simplification type optimizer generators 
wilhelm editor compiler construction cc volume lecture notes computer science pages genova italy april 
springer verlag 

shortcut fusion accumulating parameters functions 
proceedings seventh acm sigplan international conference functional programming icfp pages 
acm press 
takano meijer 
shortcut deforestation calculational form 
peyton jones editor functional programming computer architecture fpca san diego california june 
visser 
scoped dynamic rewrite rules 
van den brand verma editors rule programming rule volume electronic notes theoretical computer science 
elsevier science publishers september 
visser 
stratego language program transformation rewriting strategies 
system description stratego 
middeldorp editor rewriting techniques applications rta volume lecture notes computer science pages 
springer verlag may 
visser 
meta programming concrete object syntax 
batory consel taha editors generative programming component engineering volume lecture notes computer science pages pittsburgh pa usa october 
springer verlag 
visser 
benaissa tolmach 
building program optimizers rewriting strategies 
proceedings third acm sigplan international conference functional programming icfp pages 
acm press september 
wadler 
deforestation transforming programs eliminate trees 
theoretical computer science 
hu takeichi 
calculational fusion system hylo 
ifip tc working conference algorithmic languages calculi pages 
chapman hall february 

