ieee journal selected areas communications vol 
january language information flow security andrei sabelfeld andrew myers current standard security practices provide substantial assurance behavior computing system satisfies important security policies confidentiality 
confidentiality policy assert secret input data inferred attacker attacker observations system output policy regulates information flow 
conventional security mechanisms access control encryption directly address enforcement information flow policies 
promising new approach developed programming language techniques specifying enforcing information flow policies 
article survey past decades research information flow security particularly focusing uses static program analysis enforce information flow policies 
give structured view area identify important open challenges 
index terms computer security confidentiality information flow noninterference security type systems covert channels security policies concurrency 
protecting confidentiality information manipulated computing systems long standing increasingly important problem 
little assurance current computing systems protect data confidentiality integrity existing theoretical frameworks expressing security properties inadequate practical techniques enforcing properties unsatisfactory 
article discuss language techniques particular program semantics analysis specification enforcement security policies data confidentiality 
language mechanisms especially interesting standard security mechanisms unsatisfactory protecting confidential information emerging large networked information systems 
military medical financial information systems web services mail shopping business business transactions applications create serious privacy questions answers 
analyzing confidentiality properties computing system difficult insecurity arises unintentional errors design implementation 
additionally modern computing systems commonly incorporate manuscript received april revised august 
supported part onr part nsf career award part alfred sloan research fellowship 
opinions findings recommendations contained material authors necessarily reflect views department navy office naval research national science foundation alfred sloan foundation 
sabelfeld myers computer science department upson hall cornell university ithaca ny usa mail andr ei cs cornell edu 
untrusted possibly malicious hosts code making assurance confidentiality difficult 
standard way protect confidential data discretionary access control privilege required order access files objects containing confidential data 
access control checks place restrictions release information propagation 
information released container accessing program may error improperly transmit information form 
unrealistic assume programs large computing system trustworthy security mechanisms signature verification antivirus scanning provide assurance confidentiality maintained checked program 
ensure information accordance relevant confidentiality policies necessary analyze information flows program complexity modern computing systems manual analysis infeasible 
belief system secure respect confidentiality arise rigorous analysis showing system enforces confidentiality policies users 
analysis show information controlled confidentiality policy flow location policy violated 
confidentiality policies wish enforce information flow policies mechanisms enforce information flow controls 
information flow policies natural way apply known systems principle design specification computer security requirements consider specifications security 
truly secure system confidentiality policies precisely expressed translated mechanisms enforce 
practical methods controlling information flow researchers time 
promising new approach developed authors type systems information flow 
security typed language types program variables expressions augmented annotations specify policies typed data 
security policies enforced compile time type checking add little run time overhead 
ordinary type checking security type checking inherently compositional secure subsystems combine form larger secure system long external type signatures subsystems agree 
development security models models formalize security terms program behavior provided powerful reasoning techniques properties security type systems guarantee :10.1.1.40.1122:10.1.1.149.7391:10.1.1.149.7391
properties increase security assurance expressed terms program behavior provide suitable ieee journal selected areas communications vol 
january vocabulary policies programs 
rest article organized follows 
section ii gives background problem protecting confidentiality including existing security techniques unsatisfactory 
section iii illustrates basics techniques giving examples security condition security type system 
section iv gives structured overview field 
section identifies important challenges 
article closes section vi 
ii 
background terminology security properties relating confidentiality somewhat inconsistent 
article specification enforcement strong confidentiality policies information flow 
framework assumed computation confidential information possible important prevent results computation leaking partial information confidential inputs 
kind security described lampson seminal article information confinement known secrecy 
confinement secrecy describe related weaker security properties 
context capability systems confinement refers ability prevent capabilities authority transmitted improperly 
similarly cryptographic protocols builds dolev yao model secret information assumed indivisible leaked insertion entirety message 
privacy refer protection confidentiality principal synonym anonymity 
clarity term confidentiality 
stated term security refers confidentiality article 
standard security mechanisms difficulty strongly protecting confidential information known time research addressing problem relatively little impact design commercially available computing systems 
systems employ security mechanisms access control capabilities firewalls antivirus software useful see standard security mechanisms fall short 
access control embodied access control lists capabilities important part current security infrastructure 
example file may assigned access control permissions prevent users owner reading file precisely permissions prevent processes authorized file owner reading file 
access control control data read file 
soundly enforce confidentiality access control policy necessary file access privilege processes improperly transmit leak confidential data precisely processes obey stronger information flow policy 
access control mechanisms identify processes access control useful substitute information flow control 
common security enforcement mechanisms firewalls encryption antivirus software useful protecting confidential information 
mechanisms provide security 
example firewall protects confidential information preventing communication outside 
practical systems firewalls permit communication directions communication violates confidentiality lies outside scope firewall mechanism 
similarly encryption secure information channel communicating endpoints access information 
encryption provides assurance data decrypted computation receiver respects confidentiality transmitted data 
antivirus software detecting patterns previously known malicious behavior code offers limited protection new attacks 
related language security language mechanisms security goals protecting confidentiality 
language security mechanism java runtime environment provides known set security mechanisms java applets including bytecode verifier sandbox model stack inspection 
mechanisms language enforced java language bytecode verifier uses static program analysis 
mechanisms intended control information flow effective protecting confidential data 
bytecode verifier ensures applications respect java type system object forged private fields directly accessed 
protection private fields important confidentiality static powerful access control mechanisms 
sandbox model restricts classes java applet name malicious applet may violate confidentiality communicating host downloaded 
stack inspection dynamic access control mechanism helps protect integrity address confidentiality 
language techniques ongoing security research goal type safety protect machine subversion mobile code general security policies enforced 
language addresses security policies 
covert channels mechanisms signaling information computing system known channels 
channels exploit mechanism primary purpose information transfer called covert channels pose greatest challenge preventing improper information leaks 
covert channels fall categories implicit flows signal information control structure program 
sabelfeld myers language information flow security termination channels signal information termination nontermination computation 
timing channels signal information time action occurs data associated action 
action may program termination sensitive information obtained total execution time program 
probabilistic channels signal information changing probability distribution observable data 
channels dangerous attacker repeatedly run computation observe stochastic properties 
resource exhaustion channels signal information possible exhaustion finite shared resource memory disk space 
power channels embed information power consumed computer assuming attacker measure consumption 
covert channels concern depends attackers observe computing system 
example power channels important smart cards draw power untrusted terminal inserted 
program secure computer power requirements part larger insecure system run real computer 
computing system said protect confidential information respect model attackers users able observe execution 
integrity biba observed integrity treated dual confidentiality enforced controlling information flows 
confidentiality requires information prevented flowing inappropriate destinations dually integrity requires information prevented flowing inappropriate sources 
integrity important difference confidentiality computing system damage integrity interaction external world simply computing data incorrectly 
strong enforcement integrity requires proving program correctness daunting obstacle 
mandatory access control early confidentiality problem fenton bell lapadula developed mandatory access control 
approach data item labeled corresponding security level simple confidentiality policy 
information flow controlled augmenting ordinary computation data running program simultaneous computation corresponding label controls dissemination 
approach prescribed department defense orange book secure systems proved restrictive general 
apart obvious computational storage overhead weakness purely run time enforcement mechanisms identifying implicit information flows 
implicit flows arise control structure program fig 

implicit flow 
mod skip opposed explicit flows caused directly passing confidential data public variable 
simplicity suppose sensitivity levels high low corresponding greater lesser confidentiality respectively 
consider code contains flow high variable low variable code insecure exactly effect explicit flow assignment mod 
clearly insecurity code arises assignment control context conditioned confidential variable mandatory access control catch assignment introducing process sensitivity label keeps track sensitivity data control process 
assignment detected run time high process updates low variable 
consider case assignment run time check occurs value high variable learned observing holds 
fact variable data structure assumed contain confidential information modified statement inside function called 
determining modifications possible requires evaluating possible execution paths program feasible run time 
confidentiality obtained example ensuring process sensitivity label remains high rest program effectively treating values read variables confidential statement completes 
approach process label increase monotonically sensitivity execution 
reduction sensitivity process label example return procedure creates possible security violation implicit flow 
effect monotonically increasing labels known label creep problem dynamic enforcement mechanisms 
variable field data structure assigned value different sensitivity currently contains necessary apply maximum labels stored value 
data labels tend creep upwards 
label creep dynamic labeling systems restrictive generally useful results computation tend labeled sensitively intended 
static information flow control denning denning observed static program analysis control information flow increased precision low run time overhead 
static characterizations information flow implemented theorem provers 
information flow analyses performed type checking focus ieee journal selected areas communications vol 
january article 
type checking approach implemented jif compiler 
type checking approach program expression security type parts ordinary type int label describes value may 
labels mandatory access control mechanisms labels completely static computed run time 
way type checking carried label defines information flow policy labeled data 
security enforced type checking compiler reads program containing labeled types typechecking program ensures program contain improper information flows run time 
type system language security type system enforces information flow policies 
ability track implicit flows accurately major advantages static enforcement information flow control 
control implicit flows correctly introduce program counter label pc tracks dependencies program counter 
consider example 
branches statement static label pc high capturing dependency program counter assignment considered secure label assigned variable restrictive pc 
second assignment label low occurs control context pc high justifies rejection program insecure 
program counter label corresponds dynamic process sensitivity label mandatory access control important difference statement statement assigned static pc label statement preceding 
assignment secure arriving statement tells statement executed regardless value may surprising static checking improve accuracy 
reason dynamic enforcement information single program execution compiletime type checking prove possible execution paths statement contain insecure assignments 
consequence general fact confidentiality property single execution path property set executable paths 
notice branch statement terminate attacker infer value termination nontermination program 
example termination covert channel 
discuss covert channels section iv 
noninterference user wishes keep data confidential state policy stipulating data visible users affected confidential data 
policy allows programs manipulate modify private data long visible outputs programs improperly reveal information data 
policy sort noninterference policy states confidential data may interfere affect public data 
skip var exp exp exp fig 

command syntax 
attacker unauthorized user assumed allowed view information confidential public 
usual method showing noninterference holds demonstrate attacker observe difference executions differ confidential input 
noninterference naturally expressed semantic models program execution 
idea goes back cohen early strong dependency 
mclean argues noninterference programs context trace semantics 
suggests automatic security enforcement mechanism 
iii 
basics language information flow techniques proving security type system enforces noninterference developed increasingly complex programming languages 
section introduce approach exploring simple security type system enforces noninterference security policy 
consider simple imperative language syntax 
language skip assignment sequential composition conditional loop constructs 
write typical variables high low confidentiality respectively 
assume expressions exp formed applying total arithmetic operations constants variables 
semantics security noninterference programs essentially means variation confidential high input cause variation public low output 
intuition rigorously formalized machinery programming language semantics 
assume computation starts input state sh sl pair consisting initial values respectively 
program terminates output state output values high low variables diverges 
semantics program command function maps input state output state program fails terminate 
variation high input described equivalence relation inputs equivalent agree low values iff sl 
observational power attacker characterized relation behaviors defined semantics behaviors related iff indistinguishable attacker 
relation said reflect low view system 
equivalence relation symmetric reflexive 
semantic model noninterference formalized follows secure iff sabelfeld myers language information flow security exp high vars exp exp low pc skip pc exp pc pc pc exp pc pc pc pc exp fig 

security type system 
exp low low exp exp pc pc pc exp high low reads input states share low values behaviors program executed states indistinguishable attacker particular model observable behavior depends desired security property 
example language may set iff implies assumption condition corresponds absence strong dependency variable variable condition program secure low output low input unaffected changes high input 
program secure final values depend initial value programs skip clearly insecure example initial high values gives different final values program initial value 
security type system security type system collection typing rules describe security type assigned program expression types subprograms subexpressions 
write exp mean expression exp type typing rules 
assertion known typing judgment 
similarly judgment pc means program typable security context pc 
purposes security context just program counter label pc cf 
section ii 
presents typing rules simple language 
system fact equivalent type system volpano 
expression types security contexts high low 
rules expression including constants variable type high expression type low occurrences consider rules 
commands skip exp typable context 
command exp typable exp type low 
prevents explicit flows 
notice exp typable low context combination rest purely compositional rules disallows implicit flows 
notice high command ensures assignments low variables justifies requirement rules loop high guard branches loop body typable high context 
refer loops high guard high loops conditionals high condition high conditionals 
rule subsumption rule 
guarantees program typable high context typable low context 
rule allows reset program counter low high conditional loop avoiding source label creep cf 
sections ii ii 
examples typed programs low high skip 
expected example programs explicit implicit insecure flows skip typable 
iv 
trends language information flow considered succinct examples express noninterference style security policy low view relations static certification style security analysis type system 
true value representations lies connection 
ultimate goal formalizing confidentiality properties tools expressive ensure rigorous security policies 
information flow prior mid nineties typically handled policies analyses separation volpano establish explicit connection 
cast denning style analysis type system similar showed program typable secure condition 
result improves security assurance extensional security definition 
definition expressed low view standard semantic model opposed ad hoc security semantics security semantics underlying previous approaches 
identify directions research language security branch meeting point noninterference static certification enriching expressiveness underlying programming language ii exploring impact concurrency security iii analyzing covert channels iv refining security policies 
rest section sketch directions 
diagram illustrates structure current intended serve road map interested reader follow evolution described recommended provided diagram 
language expressiveness major line research information flow pursues goal accommodating increased expressiveness modern programming languages 
concentrate progress procedures functions exceptions objects 
procedures volpano smith give type system language order procedures prove guarantees noninterference 
type system relies heavily polymorphism studied concept type systems 
polymorphism means type commands expressions may generic may depend context 
example procedures may polymorphic security types ieee journal selected areas communications vol 
january static certification procedures sound security analysis functions exceptions objects nondeterminism termination threads timing distribution probability noninterference declassification admissibility relative security quantitative security expressiveness concurrency covert channels security policies fig :10.1.1.35.8514

evolution language information flow 
invocation adjusted low high context 
recall high context corresponds high program counter program point inside high conditional loop 
notice example type system simple polymorphic rules pc typed high low depending context 
functions heintze riecke consider information flow slam calculus functional language calculus supports class functions functions usable ordinary values :10.1.1.40.1122
propose type system confidentiality integrity slam prove noninterference theorem logical relations 
extend slam type system state concurrency prove noninterference 
zdancewic myers define secure calculus class continuations state prove type system enforces noninterference 
continuations expressive control construct functions 
show fragment slam augmented state encoded continuation passing style calculus loss precision 
pottier show systematic way extend conventional type systems flow control functional setting 
approach simplifies correctness proofs allowing extracted correctness proofs original type system 
pottier simonet prove noninterference extension purely functional part slam extended exceptions type polymorphism 
exceptions exceptions java raised language event run time error division 
may programmer signal exceptional conditions 
exceptions caught special language construct resulting nonlocal transfer control create implicit flows 
caught exception may create implicit flow information 
volpano smith propose simple restrictive type system handling exceptions 
myers argues may lead loss precision analysis introduces path labels allow finer grained tracking implicit flows caused exceptions 
pottier simonet suggest similarly fine grained analysis exceptions give noninterference proofs functional setting 
objects objects important language feature subsume class functions class functions encoded objects 
jflow language extends java type system tracking information flow 
language implemented jif compiler 
barthe consider information flow simple object oriented language abadi cardelli functional object calculi show type system enforces noninterference 
banerjee naumann develop security type system java imperative object oriented language show enforces noninterference 
concurrency principle concurrency considered language extensions previous section 
nature concurrent computation raises new concerns low view model making concurrency major topic 
nondeterminism step concurrency nondeterministic computation 
noninterference originally defined property deterministic computations 
straightforward way generalize nondeterminism sabelfeld myers language information flow security consider observable behavior program set possible results 
interpretation security condition section iii means high inputs may affect set possible low outputs 
known possibilistic security condition 
substantial body possibilistic generalizations noninterference nondeterministic setting 
context programming languages ban tre bryce le tayer suggest analysis tracks dependencies variables language nondeterministic choice operator 
leino joshi define elegant equational security property nondeterministic programs 
define program hh havoc informal semantics set arbitrary value 
program considered secure iff hh hh hh appropriate equivalence relation sets final values 
occurrence hh effect equalizes set possible final values equation intuitive reading scrambling initial value reflect set final values possibilistic security condition 
advantages approach flexibility choice verification conditions proving equational security 
sabelfeld sands formalize number security specifications partial equivalence relations pers equational security condition instance 
abadi adapt pers program analysis reason variations spirit low view deterministic setting :10.1.1.34.3298
extension pers handle nondeterministic security develops link low view relations equivalence relations programs exhibit nondeterminism 
thread concurrency consider multithreaded programs executed single processor 
complication concurrent models high part program states protected times computation 
example consider program thread secure initial secret value overridden constant 
security compromised case secure program runs parallel 
program may update value secret high variable immediately executed thread 
issue security multithreaded computation tightly connected timing probability sensitive security 
assuming scheduler determines thread selected step exhibits potentially probabilistic behavior behavior reflected choice thread executed 
execution order lowlevel computation may affected 
focus probability sensitive security section iv 
contrast earlier security concurrent programs smith volpano prove noninterference multithreaded language :10.1.1.149.7391
show requirements imposed addition enforced sequential languages sufficient noninterference purely nondeterministic scheduler loop may high guard high conditional may contain loop branch 
programs analysis determines secure meet possibilistic security condition may insecure practice 
example program skip denotes parallel composition long timeconsuming series skip commands considered secure 
schedulers round robin executed 
encoding timing leak direct leak assignments sequential parallel composition 
set possible results program independent assuming nondeterministic scheduler refinements program possible outcomes eliminated choosing scheduler secure 
concurrent setting possibilistic security subject refinement attacks 
volpano smith investigates security presence uniform scheduler scheduler selects thread pool live threads uniform probability distribution gives security specification rejects program insecure :10.1.1.149.4907
scheduling policies may vary implementation implementation sabelfeld sands argue scheduler independent security robust respect wide class potentially probabilistic schedulers prove noninterference result security type system 
smith independently boudol castellani observe high loop considered secure concurrent setting provided low assignments follow loop 
enforced respective type systems 
smith type system guarantees probabilistic noninterference 
boudol castellani typing rules extended schedulers result typed system consisting threads scheduler satisfy possibilistic noninterference 
sabelfeld extends definition noninterference type system handle thread synchronization 
effect synchronization similar loops type system rules synchronization depends high data order ensure noninterference 
honda taken approach secure concurrent languages security type systems asynchronous calculus general model concurrent computation threads implicit 
channel types languages may annotated number attributes describe possible communication patterns notably channel types may linear affine meaning channel may exactly message respectively 
complex security type systems able enforce noninterference precision type systems concurrent languages 
pottier presents syntactic technique extends calculus calculus pairs processes 
noninterference reduced safety property calculus ieee journal selected areas communications vol 
january property established subject reduction standard technique showing soundness type systems 
technique noninterference results functional languages 
zdancewic develops alternate approach checking security concurrent systems idea determinism developed roscoe context csp 
program considered secure results viewed low view relation deterministic despite considering high inputs chosen nondeterministically 
security condition generalizes noninterference possibilistic subject refinement attacks 
may rule useful nondeterminism 
zdancewic gives security type system concurrent language supports arbitrary number processes message passing communication including class channels shows type system combined suitable alias analysis enforces security condition 
distribution understanding security distributed setting pressing needs 
distributed systems naturally concurrent new issues raised setting distributed programs ability exchange messages communications may observed extent attackers 
second systems distributed precisely serve needs multiple principals fully trust 
way needed provide security despite mutual distrust 
third distributed systems components host machines fail failures may include complete subversion components malicious attackers 
subverted host may continue simulate proper functioning improperly release data receives may attempt compromise behavior components system cause violate confidentiality 
early confidentiality definitions language distributed systems phrased terms security logic lacked rigorous relation program semantics 
reitman logic addresses security messagepassing primitives commonly distributed programs 
ban tre bryce logic formalizes security properties language synchronous message passing 
sabelfeld mantel investigate security implications various communication primitives 
consider blocking vs nonblocking synchronous vs asynchronous primitives message passing propose type system enforces timing sensitive noninterference language features multithreading message passing 
relatively little addressed problem information flow distributed system incorporates mutual distrust arbitrary component failure 
zdancewic propose implement architecture called secure program partitioning address issues 
goal architecture protect confidentiality multiple principals trust principals partial differing trust host machines available computation 
setting informal security condition security principal threatened failure host principal trusts 
sequential security typed program automatically partitioned fine grained manner communicating subprograms run securely available hosts carry original computation 
security types language specify confidentiality integrity policies prevent untrusted hosts subverting security critical decisions 
system intended allow enforcement security policies go noninterference proof system enforces noninterference property 
theorem integrity control flow partitioned program proved 
language techniques useful modeling analyzing information flow security protocols 
abadi shows confidentiality achieved typing distributed security protocols presence encryption :10.1.1.35.8514
abadi blanchet deals types protocols involving public key encryption 
pierce protocols employs logical relations reasoning low view systems presence encryption 
covert channels recall section ii covert channels ways transfer information computing system mechanisms intended function information channels 
example implicit flows examples covert storage channels 
kinds covert channels difficult identify example information flows resulting dependencies sensitive data observable behavior system timing system stochastic behavior 
assumption attacker capable observations reflected low view system 
termination channels assuming attacker observe program termination nontermination program skip longer secure 
volpano smith argue termination sensitive noninterference 
noninterference expressed condition low view relation relates behaviors iff diverge terminate low equal final states iff 
order prevent termination attacks type system disallows high loops requires high conditionals loops branches 
abadi establish connection security analysis types program analyses binding time analysis call tracking program slicing :10.1.1.34.3298
analyses related properties identify dependency properties 
abadi express dependency terms pers calculus variation calculus 
show pers capture termination sensitive security 
binding time analysis particularly close security analysis 
field partial evaluation binding time analysis divides program terms static known partial evaluation time dynamic supplied 
correctness condition binding time analysis states static term depends dynamic variable 
viewing dynamic high sabelfeld myers language information flow security static low obtain connection security 
connection partial evaluation explored sabelfeld sands barthe thiemann 
timing channels practice nontermination distinguished time consuming computation 
termination channel viewed instance timing channel 
timing channels serious threat see timing attack rsa encryption 
seen section iv timing channels particularly dangerous presence concurrent threads may result information leaks 
timing sensitive noninterference formalized condition low view relation relates behaviors iff diverge terminate number execution steps low equal final states 
high conditional may generate timing leak skip cf 
section iv 
volpano smith suggest restricting high conditionals loops branches wrapping high conditional protect statement execution atomic 
discipline enforced accompanying type system 
approach closing timing leaks example studied technique programming languages program transformation 
transformation represented type system type assignments form sl original program result transformation sl low slice low slice sl different involve high data replaced dummy commands effect high variables 
ensures sl original program rejected case potential explicit implicit insecure information flow accepted transformed program free timing leaks 
core rule type transformation system sl sl exp high sl sl false exp exp sl sl skip sl sl predicate true iff assignment low variable command skip command acts timing wise possible branch rule performs cross copying slices branches high equalize execution time branches 
approach adapted transforming timing leaks languages concurrency sabelfeld sands distribution sabelfeld mantel 
probabilistic channels low view enhanced probabilistic property behaviors indistinguishable attacker iff distribution low output 
formalization captures probabilistic leaks 
illustrate probabilistic leak adaptation example 
assuming high variable pin stores digit number consider intuitively insecure program pin rand probabilistic choice operator selects lefthand side command probability right hand side probability rand function returning random value range uniform distribution 
purely possibilistic conditions program secure :10.1.1.149.7391:10.1.1.149.7391
varying pin change set possible outcomes change probability outcomes reflected probability sensitive definitions 
definitions non language specific settings include mclean flow model probabilistic noninterference 
sabelfeld sands lift model probabilistic powerdomains characterize probabilistic noninterference 
important contribution compositionality result guarantees secure programs plugged appropriate context resulting program secure 
due property correctness proofs security type systems compositional straightforward exemplified 
observed section iv scheduler concurrent setting may probabilistic 
volpano smith type system captures probabilistic flows resulting uniform scheduler multithreaded language :10.1.1.149.4907:10.1.1.149.4907
sabelfeld sands connect probabilistic security probabilistic bisimulation standard semantic model probabilistic computation 
benefit connection security condition improves precision previous probability sensitive definitions 
extend language dynamic thread creation prove scheduler independent timing sensitive noninterference security analysis 
correctness proofs accommodated compositional security definition implies noninterference 
security policies useful extensional property noninterference imposes restrictions possible meet practice 
particular noninterference rejects downgrading security level information high low 
declassification necessary order allow secret value encrypted passed publicly observable medium 
example password checking program 
clearly result program depends secret password matches publicly supplied data 
attempts accommodate downgrading policies active area research 
myers liskov introduce decentralized model security labels selective declassification permitted basis static analysis process authority relationships principals 
security labels additional structure describes entities capable performing declassification 
model supports labeling computations performed behalf mutually principals 
cryptographic protocols depend encryption downgrading information security levels necessity 
abadi type systems guarantee confidentiality calculus cryptographic protocols spi ieee journal selected areas communications vol :10.1.1.35.8514
january calculus 
secret keys usage hidden low view extensional security condition 
abadi blanchet type system analyzes dolev yao secrecy spi calculus 
dam admissibility jvm applets weakening noninterference 
analyze online payment protocol involves encryption secrets show desired admissibility property 
admissibility corresponds security policy explicitly states dependencies data allowed program including caused downgrading 
subsequent separates protocol specification implementation 
proposed security condition guarantees admissible program information flows intended protocol specification explicitly recorded confidentiality policy 
security condition termination timing sensitive agreeing noninterference modulo flows allowed protocol specification 
approach realized guarded command implementation language includes encryption decryption iteration message passing exception constructs 
systems containing intentional downgrading channels introduce possibility channels exploited downgrade information intended programmer 
zdancewic myers propose robust declassification security property prevents exploitation channels 
robust declassification says active attacker affect system behavior learn passive attacker may observe system behavior 
presumption information flows visible passive attacker intended 
volpano smith concentrate scenario password checking program 
provide type system allows operations similar password queries give security assurance probabilistic complexity typed program leak secrets polynomial length secret time second secret leaks possible negligible probability 
continuing line volpano proves leaking passwords system passwords stored images way function easier breaking way function 
laud complexity theoretic security specification relies computational indistinguishability polynomialtime length secret adversary imperative language 
specification accompanied sound analysis accepts program enc encryption key useful allow limited bandwidth information leaks 
example may consider program queries digit number matches secret pin secure probability leakage case threshold value 
early ideas quantitative security opposed qualitative go back denning provide automated tools estimating bandwidth 
clark propose inference rules aid computing estimates information flow resulted statements imperative language 
di pierro suggest approximate noninterference thought noninterference provide probability sensitive program analyses ensures precise approximate noninterference probabilistic constraint programming calculus 
extension concerned sound analysis geared attacker able external observations system average state limited number steps 
lowe quantitative definition information flow intended measure capacity covert channels process algebra setting 
quantitative definitions definition shannon information theory 
models lowe definition sensitive nondeterminism 
amount leaked information number different behaviors high level user distinguished low level user 
open challenges section discusses challenges language security researchers 
challenges natural goals emerging existing directions described section iv investigated crucial practical enforcement security policies 
system wide security computer systems secure weakest point system wide security model essential guarantee system components secure combination 
challenging direction integration language information flow system wide information flow control 
secure program partitioning approach zdancewic directly addresses notion system wide security 
prevents attacks distributed system considered explicitly models distrust principals hosts 
mantel sabelfeld step direction proposing way integrate language confidentiality properties local computation framework global properties 
link level facilitates modular system design 
rigorous connections areas security protocols trust management desirable 
certifying compilation potential weakness compiler validate information flows places type checker code generator compiler trusted computed base tcb 
clearly desirable perform analysis code close executed code possible avoiding trust dependencies 
important malicious code distributed form programs low level machine language confused low level confidentiality data java applets activex components 
certifying compilation attractive way generate machine code sabelfeld myers language information flow security annotated necessary information perform static validation 
java bytecode verification typed assembly language primarily guarantee memory safety examples approach 
low level languages received attention studies secure information flow 
difficulty checking information flow low level languages useful information program structure lost compilation 
consequently typical source language techniques generalize straightforwardly 
zdancewic myers type system ensures noninterference low level programs control construct continuations correspond indirect branches machine code level 
ordered linear continuation types enforce stack discipline permits high precision analysis 
worthwhile direction adapting techniques security machine code information flow example typed assembly languages guarantee machine code violate type safety code proof program satisfies security policy distributed code checked execution 
abstraction violating attacks inevitable model attacker abstraction removes possibly important details real attacker 
abstraction enables real attacker circumvent security mechanisms mounting attack lies outside model 
example attack security cache attack 
consider example variables high 
independently sensitive data program executes number instructions 
presence cache execution time shorter initial value time assignment executed value cache 
attack prevented cross copying transformation ensures memory cells referenced branches possible attacks remain instruction cache virtual memory behavior 
example demonstrates vital abstractions attacker model adequate respect potential attacks 
dynamic policies common assumption language information flow information flow policies known statically compile time 
realistic assumption large computing system 
example files file system attached security policies permissions changed dynamically 
permissions enforced policies programs accessing file system able enforce dynamically changing security policies 
dynamic security policies proposed language setting implemented jif compiler 
jif security type system types may annotated confidentiality labels refer variables type label 
labels may class values labels values 
types depend values computed run time dependent types topic long interest programming languages community 
dynamic security policies important area dynamic labels known introduce unsoundness jif type system currently noninterference results fragment supports 
difficulty adding dynamic labels computed run time create additional information channel controlled type system 
type system provably controls information channel unnecessarily restrictive welcome result 
practical issues efforts spent accommodating richer languages modeling elaborate attacks supported investigation impact restrictiveness programmer 
question place possible write efficient secure programs violate security requirements 
timing sensitive setting step sands show basic algorithmic building blocks sorting searching manipulate secret data securely implemented substantial loss efficiency objects asymptotic complexities sorting searching log log respectively 
implementations exist support inference 
experience needed deeper understanding practical implications secure information flow 
general problem confidentiality programs undecidable 
example consider program uses low variables 
clearly reduce undecidable problem diverges problem program skip secure 
example specific termination insensitive security program true skip reduction termination sensitive security 
important security static analyses reject secure programs necessarily conservative 
research aimed improving precision type systems deserves attention 
approaches type systems offer valuable alternatives accurate flexible security analyses 
focus section 
variations static analysis security control data flow analyses established areas program analysis concerned dependencies due ieee journal selected areas communications vol 
january control data flow natural match tracking security dependencies programs 
type systems general intuitive understood reason control data flow analyses type systems lack principal type general type command expression may result loss precision 
demonstrate controlflow analysis establish bell lapadula security properties calculus 
context firewalls formalized ambients nielson show statically reject firewalls may accept attacker fails provide required password 
devise controlflow analysis guarantees dolev yao secrecy spi calculus 
suggest conservative extension analysis enforces noninterference confidentiality 
clark propose high precision control security analysis higher order imperative language 
particular analysis traces global flows accurately type systems 
example accepts secure program secure termination sensitive termination insensitive interpretations condition 
typical security type system rejects program 
framework interpretation powerful methodology designing static analyses sound construction 
malacaria hankin develop information flow analysis interpretation setting game semantics 
proposes interpretation security analysis generalizes security type system volpano 
vi 
argued standard security practices capable enforcing confidentiality policies mechanisms access control encryption firewalls digital signatures antivirus scanning address fundamental problem tracking flow information computing systems 
run time monitoring operating systems calls similarly limited information flow policies properties single execution general require monitoring possible execution paths 
hand clear evidence benefits provided language security mechanisms build technology static analysis language semantics 
section summarize benefits security type systems semantic security models emphasize compositional nature 
conclude discussing related 
security type systems type systems attractive implementing static security analyses 
natural augment type annotations security labels 
type systems allow compositional reasoning necessity scalability applied larger programs 
developed features type systems usefully applied security analysis 
examples include subtyping polymorphism dependent types linear types type directed translation 
semantics security models semantics models suitable describing policies noninterference extensions 
models allow precise formulation attacker view system 
view described relation program behaviors behaviors related distinguishable attacker 
attackers varying capabilities modeled straightforwardly different attacker views correspond different security properties 
particular shown represent timing probabilistic behavior programs attacker capable making timing probability sensitive distinctions 
compositionality number advantages associated security type systems security 
compositionality especially valuable context security properties 
folklore security community security properties compose cf 
compositionality fundamental programming languages 
type systems security conditions compositional ensures plugging secure programs context gives secure program 
compositionality greatly facilitates correctness proofs program analyses 
related language techniques large body noninterference setting process algebras ccs csp see overview calculus spi calculus eventbased systems 
notably idea representing attackers view relations common studies noninterference process algebra 
compositionality reasoning essential part security investigations event systems 
type systems widely ensuring confidentiality properties spi calculus variations calculus 
timing probability sensitive confidentiality explored focardi aldini respectively variations ccs 
lowe explored quantitative information flow csp cf 
section iv 
practical security mechanism progress language techniques soundly enforcing confidentiality policies continues approach may soon important part standard security practice 
areas needed semantics information flow needed concurrent distributed systems useful security guarantees provided ruling useful secure programs 
new type systems static analyses needed notion formed typable program closely approximates semantic notion security 
certifying compilers needed security typed languages compilers source languages jif complex part trusted computing sabelfeld myers language information flow security base 
current security type systems expressive support security typed low level target language 
inability express enforce security policies serious problem current computing infrastructure language techniques appear essential solution problem 
acknowledgment authors hicks helpful comments anonymous reviewers useful feedback 
saltzer reed clark arguments system design acm transactions computer systems vol 
pp 
nov 
palsberg rb trust calculus proc 
symposium static analysis 
sept number lncs pp 
springer verlag 
volpano smith irvine sound type system secure flow analysis computer security vol 
pp 

myers liskov decentralized model information flow control proc 
acm symp 
operating system principles oct pp 

heintze riecke slam calculus programming secrecy integrity proc 
acm symp 
principles programming languages jan pp 

smith volpano secure information flow multithreaded imperative language proc 
acm symp 
principles programming languages jan pp 

myers jflow practical static information flow control proc 
acm symp 
principles programming languages jan pp 

barthe partial evaluation non interference object calculi proc 
flops 
nov vol 
lncs pp 
springer verlag 
volpano smith probabilistic noninterference concurrent language computer security vol 
pp 
nov 
transforming timing leaks proc 
acm symp 
principles programming languages jan pp 

sabelfeld sands probabilistic noninterference multithreaded programs proc 
ieee computer security foundations workshop july pp 

zdancewic myers secure information flow cps proc 
european symposium programming 
apr vol 
lncs pp 
springer verlag 
banerjee naumann secure information flow pointer confinement java language proc 
ieee computer security foundations workshop june pp 

pottier simonet information flow inference ml proc 
acm symp 
principles programming languages jan pp 

abadi banerjee heintze riecke core calculus dependency proc 
acm symp 
principles programming languages jan pp 

pottier information flow inference free proc 
acm international conference functional programming sept pp 

sabelfeld sands model secure information flow sequential programs higher order symbolic computation vol 
pp 
mar 
lampson note confinement problem comm 
acm vol 
pp 
oct 
dolev yao security public key protocols ieee transactions information theory vol 
pp 
aug 
lampson protection proc 
princeton symposium information sciences systems princeton university mar pp 
reprinted operating systems review vol 
pp 
jan 
dennis programming semantics multiprogrammed computations comm 
acm vol 
pp 
mar 
wulf cohen jones levin pierson pollack hydra kernel multiprocessor system comm 
acm vol 
pp 
june 
box layman mendelsohn nielsen thatte simple object access protocol soap www org tr soap may 
lindholm yellin java virtual machine addison wesley reading ma may 
mueller java security tech 
rep sun microsystems palo alto ca 
wallach appel felten security architecture known stack inspection security mechanism language systems acm transactions software engineering methodology vol 
pp 
oct 
wahbe lucco anderson graham efficient fault isolation proc 
acm symp 
operating system principles dec pp 

morrisett walker crary glew system typed assembly language acm toplas vol 
pp 
may 
wagner static analysis computer security new techniques software assurance ph thesis university california berkeley 
necula proof carrying code proc 
acm symp 
principles programming languages jan pp 

schneider sasi enforcement security policies retrospective proc 
new security paradigm workshop sept pp 

evans flexible policy directed code safety proc 
ieee symp 
security privacy may pp 

schneider morrisett harper language approach security informatics years back years ahead vol 
lncs pp 

springer verlag 
biba integrity considerations secure computer systems tech 
rep esd tr usaf electronic systems division bedford ma apr available national technical information service springfield va ntis ad 
fenton information protection systems ph thesis university cambridge cambridge england 
fenton memoryless subsystems computing vol 
pp 
may 
bell lapadula secure computer systems mathematical foundations tech 
rep mtr vol 
mitre bedford ma 
lapadula bell secure computer systems mathematical model tech 
rep mtr vol 
mitre bedford ma reprinted computer security vol 
pp 

department defense department defense trusted computer system evaluation criteria dod std orange book edition dec 
denning denning certification programs secure information flow comm 
acm vol 
pp 
july 
denning cryptography data security addison wesley reading ma 
technique proving specifications multilevel secure tech 
rep csl sri international computer science lab menlo park california jan 
mchugh information flow tool proc 
ieee symp 
security privacy apr pp 

myers nystrom zheng zdancewic jif java information flow software release 
www cs cornell edu jif july 
mclean general theory composition trace sets closed selective interleaving functions proc 
ieee symp 
security privacy may pp 

volpano safety versus secrecy proc 
symposium static analysis 
sept vol 
lncs pp 
springer verlag 
goguen meseguer security policies security models proc 
ieee symp 
security privacy apr pp 

goguen meseguer unwinding inference control proc 
ieee symp 
security privacy apr pp 

ieee journal selected areas communications vol 
january cohen information transmission computational systems acm sigops operating systems review vol 
pp 

cohen information transmission sequential programs foundations secure computation demillo dobkin jones lipton eds pp 

academic press 
mclean proving noninterference functional correctness traces computer security vol 
pp 

andrews reitman axiomatic approach information flow programs acm toplas vol 
pp 
jan 
mizuno information flow control distributed object oriented system statically bound object variables proc 
national computer security conference pp 

mizuno fixed point approach inter procedural information flow control proc 
national computer security conference pp 

mizuno schmidt security flow control algorithm denotational semantics correctness proof formal aspects computing vol 
pp 


ban tre bryce information flow control parallel language framework proc 
ieee computer security foundations workshop june pp 


ban tre bryce le tayer compile time detection information flow sequential programs proc 
european symp 
research computer security 
vol 
lncs pp 
springer verlag 

ban tre bryce le tayer approach information security distributed systems proc 
ieee international workshop trends distributed computing systems pp 

rb trust data proc 
tapsoft fase 
may vol 
lncs pp 
springer verlag 
rb palsberg trust calculus functional programming vol 
pp 

rb trust dependence analysis ph thesis brics university aarhus aarhus denmark 
denning lattice model secure information flow comm 
acm vol 
pp 
may 
volpano smith type approach program security proc 
tapsoft 
apr vol 
lncs pp 
springer verlag 
abadi secrecy typing security protocols proc :10.1.1.35.8514
theoretical aspects computer software sept pp 

zdancewic myers robust declassification proc 
ieee computer security foundations workshop june pp 

joshi leino semantic approach secure information flow science computer programming vol 
pp 

volpano smith eliminating covert flows minimum typings proc 
ieee computer security foundations workshop pp 
june 
dam confidentiality mobile code case simple payment protocol proc 
ieee computer security foundations workshop july pp 

confidentiality implementations security protocols unpublished manuscript feb 
volpano smith verifying secrets relative secrecy proc 
acm symp 
principles programming languages jan pp 

zdancewic zheng nystrom myers untrusted hosts confidentiality secure program partitioning proc 
acm symp 
operating system principles oct pp 

sabelfeld mantel static confidentiality enforcement distributed programs proc 
symposium static analysis 
sept vol 
lncs pp 
springer verlag 
clark hunt malacaria quantitative analysis leakage confidential data quantitative aspects programming languages selected papers 
vol 
electronic notes theoretical computer science elsevier 
di pierro hankin approximate noninterference proc 
ieee computer security foundations workshop june pp 

barendregt lambda calculus syntax semantics north holland 
zdancewic myers secure information flow linear continuations higher order symbolic computation vol 
pp 
sept 
pottier simonet information flow inference ml acm toplas appear 
simonet fine grained information flow analysis calculus sum types proc 
ieee computer security foundations workshop june pp 

abadi cardelli theory objects monographs computer science 
springer verlag new york 
mclean general theory composition class possibilistic security properties ieee transactions software engineering vol 
pp 
jan 
sutherland model information proc 
national computer security conference sept pp 

mccullough specifications multi level security hook property proc 
ieee symp 
security privacy apr pp 

mantel possibilistic definitions security assembly kit proc 
ieee computer security foundations workshop july pp 

leino joshi semantic approach secure information flow proc 
mathematics program construction june vol 
lncs pp 

sabelfeld sands model secure information flow sequential programs proc 
european symposium programming 
mar vol 
lncs pp 
springer verlag 
volpano smith probabilistic noninterference concurrent language proc :10.1.1.149.4907
ieee computer security foundations workshop june pp 

smith new type system secure information flow proc 
ieee computer security foundations workshop june pp 

boudol castellani noninterference concurrent programs proc 
icalp july vol 
lncs pp 

boudol castellani non interference concurrent programs thread systems theoretical computer science vol 
pp 
june 
sabelfeld impact synchronisation secure information flow concurrent programs proc 
andrei ershov international conference perspectives system informatics 
july vol 
lncs pp 
springer verlag 
honda vasconcelos yoshida secure information flow typed process behaviour proc 
european symposium programming 
vol 
lncs pp 
springer verlag 
honda yoshida uniform type structure secure information flow proc 
acm symp 
principles programming languages jan pp 

pottier simple view type secure information flow proc 
ieee computer security foundations workshop june pp 

zdancewic programming languages information security ph thesis cornell university july 
roscoe csp determinism security modeling proc 
ieee symp 
security privacy may pp 

reitman information flow parallel programs axiomatic approach ph thesis cornell university 
abadi secrecy typing security protocols acm vol 
pp 
sept 
abadi blanchet secrecy types asymmetric communication proc 
foundations software science computation structure 
apr vol 
lncs pp 
springer verlag 
pierce logical relations encryption proc 
ieee computer security foundations workshop june pp 

thiemann enforcing security properties type specialization proc 
european symposium programming 
apr vol 
lncs springer verlag 
kocher timing attacks implementations diffie hellman rsa dss systems proc 
crypto 
vol 
lncs pp 
springer verlag 
mclean security models information flow proc 
ieee symp 
security privacy may pp 

gray iii probabilistic interference proc 
ieee symp 
security privacy may pp 

sabelfeld myers language information flow security syverson gray iii epistemic representation information flow security probabilistic systems proc 
ieee computer security foundations workshop june pp 

larsen skou bisimulation probabilistic testing information computation vol 
pp 
sept 
myers liskov complete safe information flow decentralized labels proc 
ieee symp 
security privacy may pp 

abadi gordon calculus cryptographic protocols spi calculus information computation vol 
pp 
jan 
secrecy mobile implementations security protocols licentiate thesis royal institute technology stockholm oct 
volpano secure way functions proc 
ieee computer security foundations workshop july pp 

laud semantics program analysis computationally secure information flow proc 
european symposium programming 
apr vol 
lncs pp 
springer verlag 
di pierro hankin probabilistic confinement declarative framework declarative programming selected papers agp 
vol 
electronic notes theoretical computer science elsevier 
di pierro hankin analysing approximate confinement uniform attacks proc 
symposium static analysis 
sept vol 
lncs pp 
springer verlag 
lowe quantifying information flow proc 
ieee computer security foundations workshop june pp 

shannon weaver mathematical theory communication university illinois press 
mantel sabelfeld generic approach security multi threaded programs proc 
ieee computer security foundations workshop june pp 

mantel sabelfeld unifying approach security distributed multi threaded programs computer security appear 
saltzer schroeder protection information computer systems proc 
ieee vol 
pp 
sept 
morrisett compiling types ph thesis carnegie mellon university dec published cmu tech report cmu cs 
type techniques covert channel elimination register allocation ph thesis chalmers university technology gothenburg university gothenburg sweden dec 
appel compiling continuations cambridge university press 
kozen language security proc 
mathematical foundations computer science 
sept vol 
lncs pp 
springer verlag 
sheldon gifford static dependent types class modules proc 
lisp functional programming june pp 

xi pfenning dependent types practical programming proc 
acm symp 
principles programming languages jan pp 

sands confidentiality algorithms proc 
ieee symp 
security privacy may pp 

nielson riis nielson hankin principles program analysis springer verlag 
degano riis nielson nielson security analysis flow logics current trends theoretical computer science rozenberg salomaa eds pp 

world scientific 
degano nielson riis nielson static analysis processes read write proc 
foundations software science computation structure 
apr number lncs pp 
springer verlag 
degano nielson riis nielson static analysis calculus applications security information computation vol 
pp 

cardelli gordon mobile ambients proc 
foundations software science computation structure 
apr vol 
lncs pp 
springer verlag 
nielson riis nielson hansen jensen validating firewalls mobile ambients proc 
concur 
number lncs pp 
springer verlag 
degano riis nielson nielson static analysis secrecy non interference networks processes proc 
pact 
sept vol 
lncs pp 
springer verlag 
clark hankin hunt information flow algol languages journal computer languages appear 
cousot cousot interpretation unified lattice model static analysis programs construction approximation fixpoints proc 
acm symp 
principles programming languages jan pp 

malacaria hankin non deterministic games program analysis application security proc 
ieee symp 
logic computer science pp 

mccusker game semantics logic computation proc 
marktoberdorf summer school berger schwichtenberg eds nato science series 
springer verlag 
security typings interpretation proc 
symposium static analysis 
sept vol 
lncs pp 
springer verlag 
mccullough noninterference composability security properties proc 
ieee symp 
security privacy may pp 

sabelfeld semantic models security sequential concurrent programs ph thesis chalmers university technology gothenburg university gothenburg sweden may 
focardi gorrieri classification security properties process algebras computer security vol 
pp 

ryan mathematical models computer security tutorial lectures foundations security analysis design focardi gorrieri eds vol 
lncs pp 

springer verlag 
ryan schneider process algebra non interference proc 
ieee computer security foundations workshop june pp 

mantel composition secure systems proc 
ieee symp 
security privacy may pp 

sewell vitek secure composition untrusted code wrappers causality types proc 
ieee computer security foundations workshop july pp 

hennessy information flow vs resource access asynchronous pi calculus extended proc 
icalp 
july vol 
lncs pp 
springer verlag 
duggan cryptographic types proc 
ieee computer security foundations workshop june pp 

focardi gorrieri information flow analysis discrete time process algebra proc 
ieee computer security foundations workshop july pp 

aldini probabilistic information flow process algebra proc 
concur 
aug vol 
lncs pp 
springer verlag 
andrei sabelfeld received ph degree computer science chalmers university technology gothenburg university gothenburg sweden 
research associate computer science department cornell university ithaca ny 
research developed link areas computer science programming languages computer security 
pursued certification confidentiality established principles programming languages 
andrew myers received ph degree computer science massachusetts institute technology cambridge 
assistant professor computer science department cornell university ithaca ny 
research interests include computer security programming languages distributed object systems 
language information flow focused systems languages expressive practical 
