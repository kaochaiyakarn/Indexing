spec programming system overview mike barnett rustan leino wolfram schulte microsoft research redmond wa usa leino schulte microsoft com manuscript may 

spec latest long line programming languages systems aimed improving development correct software 
describes goals architecture spec programming system consisting object oriented spec programming language spec compiler boogie static program verifier 
language includes constructs writing specifications capture programmer intentions methods data compiler emits run time checks enforce specifications verifier check consistency program specifications 
spec programming system currently development 
holy grail computer science ability support software engineers construction correct maintainable software 
techniques reasoning program correctness strong roots late prominently floyd hoare 
subsequent dozen years systems developed offer mechanical assistance proving programs correct see 
best influence process software engineer works aim enhance engineer primary thinking working tool programming language 
number programming languages designed especially correctness mind specification verification example pioneering languages euclid 
languages known eiffel turn embedded specifications run time checks dynamically checking correctness program run 
despite visionary underpinnings numerous technical challenges current software development practices remain costly error prone cf 

common forms specification informal natural language documentation standardized library interface descriptions relevance net framework see 
numerous programmer assumptions left unspecified complicates program maintenance implicit assumptions easily broken 
furthermore generally support making sure program works assumptions programmer mind programmer accidentally overlooked assumptions 
think program development improved assumptions recorded enforced 
realistically happen writing specifications easy provides just long term benefits immediate benefits 
spec programming system new attempt cost effective way produce high quality software 
programming system adopted widely provide complete infrastructure including libraries tools design support integrated editing capabilities importantly easily usable programmers 
approach integrate existing industrial strength platform net framework 
spec programming system rests spec programming language extension existing object oriented net programming language 
extensions consist specification constructs pre postconditions non null types facilities higher level data abstractions 
addition enrich programming constructs doing supports spec programming methodology 
allow interoperability existing net code libraries guarantee soundness long source comes spec 
specifications part program execution checked dynamically 
spec programming system consists language compiler automatic program verifier called boogie checks specifications statically 
spec system fully integrated microsoft visual studio environment 
main contributions spec programming system small extension popular language sound programming methodology permits specification reasoning object invariants presence callbacks tools enforce methodology ranging easily usable dynamic checking high assurance automatic static verification smooth adoption path programmers gradually start advantage benefits specification 
language spec language superset object oriented language targeted net platform 
features single inheritance classes implement multiple interfaces object dynamically dispatched methods exceptions mention features relevant 
spec adds type support distinguishing non null object possibly null object method specifications pre postconditions discipline managing exceptions support constraining data fields objects 
section explain features rationalize design 
non null types errors modern programs manifest null dereference errors suggesting importance programming language providing ability discriminate expressions may evaluate null sure experimental evidence see :10.1.1.5.2588
fact errors 
opted add type support discrimination spec think types offer easiest way programmers take advantage distinctions 
backward compatibility dictates type denote possibly null type spec corresponding non null type get new syntax spec chosen 
main complication non null type system arises addressing non null fields partially constructed objects illustrated example class student person transcript 
public student string name 
ei base name new transcript ei field declared non null type constructor needs assign nonnull value note example assignment occurs call base class constructor 
duration call null field accessible instance base class constructor dynamically dispatched method call 
violates type safety guarantees non null type system 
spec problem solved syntactically allowing constructors give initializers fields object constructed reachable program 
correct example writes class student person transcript 
public student string name 
ei new transcript ei base name note initializing expression constructor parameters useful feature deem vital non null type design 
spec requires initializers non null field 
spec allows non null types specify instance fields local variables formal parameters return types non null 
static fields declared non null avoiding issues partially initialized classes class initialization order array element types non null types avoiding problems array element initialization problems covariant arrays 
non null types palatable migrating programmers spec stipulates inference non local variables 
inference performed dataflow analysis spec compiler 
settled simple non null type system reasons 
problems null endemic object oriented programming providing solution attractive large number programmers 
second simple solution covers majority useful non null programming patterns 
third conditions go expressiveness non null type system programmers method class contracts described 
method contracts method including constructors properties indexers specification describes outlining contract callers implementations 
part specification preconditions declare conditions method allowed called caller responsibility 
postconditions declare conditions method allowed return 
throws set associated exceptional postconditions limit exceptions thrown method conditions 
frame conditions limit parts program state method allowed modify 
postconditions throws set exceptional postconditions frame conditions implementation responsibility 
method contracts establish responsibilities assign blame case error 
uniform error handling modern programming languages provided exception mechanism 
exception mechanisms net framework unconstrained spec adds support disciplined exceptions improve understandability maintenance programs 
prelude explaining method contracts describe spec view exceptions 
exceptions spec categorizes exceptions conditions signal 
looking exceptions pertaining particular methods goodenough categorizes exceptions domain failures range failures 
domain failure occurs method invoked illegal condition method precondition satisfied 
refine range failures admissible failures observed program errors 
admissible failure occurs method able complete intended operation parity received network packet wrong amount effort waiting input network socket amount time 
set admissible failures part contract callers implementations 
observed program error intrinsic error program array bounds error global failure particularly tied method memory error 
important consideration kinds exceptions expects program catch exception 
admissible failures part program intended possible behaviors expect correct programs catch handle admissible failures 
contrast correct programs exhibit domain failures observed program errors clear program react errors 
program handles failures outermost tier application thread 
considerations spec follows java letting programmers declare classes exceptions checked unchecked 
admissible failures signaled checked exceptions domain failures observed program errors signaled unchecked exceptions 
arraylist insert method int object inserts element arraylist specified index 
parameters public virtual void insert int index object value index zero index value inserted 
value object insert 
value null 
exceptions exception type condition index zero 
index greater count arraylist read 
arraylist fixed size 
fig 

net framework documentation method arraylist insert spec exception class implements interface considered checked exception 
preconditions important programmer assumption precondition 
simple example method precondition class arraylist public virtual void insert int index object value requires index index count requires 
precondition specifies index object inserted array list bounds list grow 
boogie attempts verify preconditions call sites reporting error 
event caller boogie applied fails establish precondition run time thrown representing domain failure 
net framework documentation method shown 
subtle difference net documentation insert specification 
specifications state expected caller difference lies action taken event preconditions violated 
support typical style net framework specifications spec introduces preconditions clauses 
tell compiler specified exception default event precondition violation detected run time class arraylist void insert int index object value requires index index count requires 
represents domain failure exception clause unchecked exception 
exception thrown evaluation precondition contract spec exception wrapped contract exception propagated 
contrast run time evaluation contracts jml exceptions caught surrounding formula treated returned boolean value certain rules see 
postconditions method specifications include postconditions 
example specify postconditions insert follows ensures count old count ensures value index ensures forall int index old ensures forall int index old count old postconditions say effect insert increase count insert value index keep elements relative positions 
example shows spec specification features line old count denotes value count entry method 
third line special function forall applied comprehension boolean expression old ranges integer values half open interval index boogie attempts verify implementation insert postconditions reporting error 
event implementation boogie applied fails establish postcondition run time thrown representing observed program error 
run time checking adopted eiffel mechanism evaluating old 
entry method expression old occurring postcondition evaluated resulting value saved away 
value old needed evaluation postcondition saved value 
note value old may fact needed evaluation postcondition due short circuit boolean expressions method terminate normally 
example illustrates general point differences checking contracts statically dynamically 
boogie knowledge program built data structures 
support quantifiers check postconditions insert statically 
contracts procedural abstraction problem static modular checking checking access limited part program 
likewise contracts higherlevel data structures problem static checking limitations decisions procedures axiomatizations theories 
dynamic checking straightforward 
hand dynamic checking postconditions quite involved old expressions mention quantified variables exemplified 
expect bulk specifications simple general point spec supports expressive specifications specifications push limits today checking technology 
exceptional postconditions java method invocation may result checked exception account exception method throws set 
example declaration char read throws 
checked exception class allows method throw checked exception allocated type subclass allowed throw checked exception 
spec compiler holds implementation throws set conservative control flow analysis 
throws clause spec mention checked exceptions 
spec allows throws declaration combined postcondition takes effect event exception thrown 
example exceptional postcondition void arraylist throws ensures count old count 
says length unchanged event method results restrictions possible program foil compiler throws set analysis undermine spec guarantee checked exception accounted 
consider example void exception new throw root exception class hierarchy exception unchecked exception comes exceptions unchecked 
checked exception assignable superclass 
consequently disallow throw statement method 
compiler throws set analysis works static types static types sufficient behavior 
static type expression throw statement unchecked exception compiler inserts run time check run time value exception fact checked exception 
information exceptions spec see companion exception safety 
frame conditions spec method contracts include modifies clauses known frame conditions restrict pieces program state method implementation allowed modify 
example class class int void modifies 
method permitted net effect value value exit method value entry 
realistic design modifies clauses includes facility abstracting program state reasons information hiding mentioned method contract 
example implementation arraylist insert going modify private representation arraylist private variables allowed mentioned explicitly contract public method 
wildcard 
example specification modifies arraylist allows field declared class arraylist modified 
spec supports flavors wildcards see additionally address problem specifying modification state subclasses cf :10.1.1.10.4654

wildcards just partial solution frame problem don extend aggregate objects 
example arraylist implementation consists array count 
modifies clause allows count array changed says array elements 
deal aggregate objects spec uses concept ownership 
say arraylist owns underlying array array committed arraylist modifications state committed objects need mentioned explicitly modifies clause 
details see describes connection object invariants 
frame conditions serve documentation enforced boogie currently enforced run time 
run time checking modifies clauses prohibitively expensive checking compare arbitrarily large portions method pre state post state 
second aiming smooth transition spec want liberal default modifies clause incur run time errors compiled programs correct 
unfortunately liberal default modified useful boogie slightly stricter default bound problematical programs 
boogie choose promising default omit run time checking modifies clauses 
inheritance specifications spec method contract inherited method overrides 
run time checks evoked method contract inherited 
specifications definitive reliable today documentation spec specifications code implementation easier read today manually written code checking preconditions lengthy 
method override add postconditions declaring additional ensures clauses 
override add exceptional postconditions exceptions throws set 
modifies clauses override allowed provided restrict locations mentioned base method 
spec allow changes precondition callers expect specification static resolution method agree dynamic checking 
methods declared interface specifications just methods declared class 
interfaces give rise form multiple inheritance class inherit method signature superclass implemented interfaces 
traditionally inherited specifications combined spec postconditions 
spec combines exceptional postconditions inherited specifications identical throws sets 
class implements interface method interface declaration method frame condition superset class implementation method 
spec combine preconditions reason explained 
obvious definitions syntactic brittle semantic require theorem proving spec uses radical solution allowing multiple inherited specifications requires clauses 
give example shows spec radical precondition solution 
consider interfaces interface void int requires interface void int requires suppose class wants implement interfaces case spec allow provide shared implementation class needs give explicit interface method implementations class void int 
void int 
explicit interface method implementations feature 
explicit interface method implementation accessed interface gets contract straight interface 
taken spec rules contract inheritance guarantee derived specification properly obeys behavioral subtyping rules 
custom attributes specifications provides custom attributes way attach arbitrary data program structures classes methods fields 
custom attribute compiled metadata standard format allows various applications read custom attributes attached particular declaration 
spec allows specification clause annotated custom attributes 
custom attributes allow users third party tools mark specifications ways 
instance spec compiler uses conditional custom attribute control specifications emitted run time checks current build 
example method int object object int lo int hi requires lo lo hi hi length conditional debug requires scores 
compiler emits run time checks preconditions debug build emits check precondition retail build 
supports common programming style debugging assertions see 
want property program runs correctly contract checking enabled runs correctly contract checking disabled 
require expressions appearing contracts pure meaning side effects throw checked exceptions 
compiler enforces condition conservative effect system 
class contracts specifying rules library abstraction done primarily method contracts spell expected caller caller expect return implementation 
specify design implementation primarily uses specifications constrain value space implementation data 
specifications called object invariants spell expected hold object data fields steady state object 
example class fragment class student students bool absent invariant students length absent length declares lengths arrays students absent 
see simple example possible object invariant hold possible language change lengths arrays simultaneously 
say object invariant holds steady states essentially means object currently operated 
methodology object invariants spec explicit object steady state versus exposed means object vulnerable modifications :10.1.1.10.4654
spec introduces block statement expose explicitly indicates object invariant may temporarily broken statement expose exposes object duration sub statement may operate fields field modifications object oriented program tend encapsulated class declares field expression usually 
object invariant supposed hold expose statement spec enforces run time check 
object invariants checked constructors flexibility allows initial check object invariant performed omit details 
default class superclasses declared invariant public method class implicit expose 
method body 
believe default disabled custom attribute method removes need explicit expose statements 
exposing object idempotent 
checked run time error expose reached exposed 
way expose mechanism similar thread non reentrant mutexes concurrent programming monitor invariants analog object invariants 
exposing idempotent able rely object invariant hold immediately inside expose block way idempotence thread reentrant mutexes means rely monitor invariant hold time mutex acquired 
spec object invariant methodology sound modifications field take place object exposed 
furthermore methodology structures object ownership relation induces dynamically changeable hierarchy 
modifications ownerships enforced boogie enforced run time 
object invariants declared class 
support modular checking invariants class need know invariants superclasses subclasses object invariants partitioned class frames class declares invariant :10.1.1.5.9485:10.1.1.10.4654
expose mechanism deals class frames 
reduce initial cost adding expose statements handle non virtual methods backward compatible way see spec allows expose statement expose class frame :10.1.1.10.4654
explain feature need show general form expose statement spec expose upto 
superclass static type expression upto omitted defaults static type expression precisely described statement exposes class frames currently exposed class frame exposing class frame 
non idempotence requires class frame exposed part operation 
expose block class frames exposed entry un exposed object invariant class frames checked 
done run time compiler emitted dynamically dispatched methods check invariants 
behavior exposing unknown number class frames particular behavior checking invariants class frames declarations may scope poses problem modular static verification 
stricter model expose boogie 
particular precondition expose upto 
enforced run time checks class frame un exposed derived un exposed class frame subclass boogie strengthens precondition requiring derived un exposed class frame exactly static type expression way boogie able find object invariants needs check expose block 
effect difference policy run time behavior enforced boogie means programmers easily get started writing running spec programs may need exert additional effort order obtain higher confidence program correctness assured boogie just additional effort required sure boogie modification ownership rules satisfied 
object invariants allowed mention constants fields arrays state independent methods confined methods 
method state independent depend mutable state 
confined method may depend state owned objects 
spec compiler includes conservative effect analysis check properties obeyed 
spec supports class invariants useful document assumptions static fields 
methodology constraints class invariants similar object invariants inheritance 
expose statement simply takes class object parameter 
system architecture spec programming system consists compiler runtime library boogie verifier 
compiler fully integrated microsoft visual studio environment terms project system build process design tools syntax highlighting features 
spec compiler differs ordinary compiler produce executable code program written spec language serializes specifications language independent format 
having specifications available separate compiled unit means program analysis verification tools consume specifications need modify spec compiler write new source language compiler 
potentially conflicting roles spec compiler met part spec compiler targets microsoft net common language runtime clr 
clr provides rich metadata facilities associating types information elements type system types methods fields 
spec compiler attaches serialized specification program component specification exists 
technically specifications serialized strings stored custom attributes 
names fully resolved renders format quite verbose easier tools consuming 
result design decision boogie consume compiled code source code 
additional benefit boogie verify code written languages spec long band process attaching contracts code 
process attach specifications net framework base class library bcl see section 
runtime checking spec preconditions postconditions turned inlined code 
performance reasons avoid creating extra methods fields compiled code 
inlined code tagged code corresponding spec contracts differentiated code comes rest spec program 
separation required analysis tool consumes spec contracts metadata 
instance boogie able determine code method meets postcondition combination non contract code followed code checks postcondition 
inlined code evaluates conditions violated throws contract exception 
unavoidable new methods created object invariants 
add method checks relevant invariants class declares invariant 
special object fields invariant level owner object added super class uses spec features subtree class hierarchy 
mentioned section runtime enforce methodology instance run time checking check object exposed updating field 
means error may go undetected run time caught boogie 
static verification intermediate language including metadata spec verifier boogie constructs program intermediate language 
simple language procedures implementations basic blocks consisting kinds statements assignments asserts assumes procedure calls cf 

inference system processes program interprocedural interpretation obtain properties loop invariants 
derived properties added program assert statements assume statements 
program goes transformations verification condition fed automatic theorem prover 
transformations cutting loops derive acyclic control flow graph introducing havoc statements done way preserves soundness analysis 
havoc statement assigns arbitrary value variable introducing havoc statements variables assigned loop causes theorem prover consider arbitrary loop iteration 
feedback delivered theorem prover user mapped back source program 
result programmers interact boogie prover making changes program source level instance adding contracts 
currently boogie uses simplify theorem prover intend switch new experimental theorem prover developed microsoft research 
band specifications net applications base class library form 
want provide specifications entire bcl 
gives client immediate benefit writing single contract 
raises problem provide mechanism attaching spec contracts code written 
note modify bcl implementation doing break versioning 
band specifications specifications code external spec compiled spec repository 
repository consulted case spec compiler boogie encounters method class requires specification compiler emits runtime checks boogie generates verification conditions method class original code attached specification 
writing contracts self contained examples easy realistic programming highly dependent libraries bcl 
large obstacle obtaining contracts existing libraries 
companion project working semi automatically generating contracts code 
automatically extracted preconditions current version bcl 
plans build translates spec method contracts natural language documentation entries 
example translate preconditions throws sets stylized exception tables net documentation see 
better keep documentation accurate date 
planning tool translating spec plain 
problems figuring field initializers need address 
tool allow spec normal development process 
instance microsoft development groups insist building products official microsoft compilers 
context spec function precompiler invisibility important gaining acceptance rigorous build environment 
related number programming languages designed especially correctness verification mind 
include pioneering languages euclid clu offered different degrees formality 
language include specifications integral part programming language specifications integrated source program aimed directly program verification interactive theorem prover 
designed programming methodology designing proving object data structures proofs done hand 
euclid specifications written programming language boolean expressions checked run time idea complicated specifications supplied comments external program verification tool 
clu programming methodology prominently included specifications recorded stylized comments 
modern systems contracts direct effect practical programs eiffel spark :10.1.1.10.4654
eiffel object oriented language years 
standard library documented contracts contracts fall prominently purview programmers 
contracts enforced dynamically 
full methodology modifies clauses object invariants presence callbacks possible obtain modular static verification 
hope bring successes eiffel net platform hope reach programmers provide methodology toolset static verification 
spark limited subset ada dynamic language features memory allocation subclassing large useful embedded applications :10.1.1.10.4654
praxis critical systems spark development industrial programs measurements indicate rigor provided spark cost effective 
spark offers selection static tools lightweight sanity checking full verification interactive theorem prover 
compatibility existing language high priority design spark just spec approach quite different 
ruling difficult features ada spark achieves property spark program compiled standard ada compiler retaining spark meaning spark specifications placed stylized ada comments compiler 
meet goal migrating normally skilled programmers language unable follow spark approach designing subset existing language 
designed spec superset existing language aiming support easy gradual adoption new features 
approach uses different methodology writing programs starting full specifications supporting machine aided process stepwise refining specifications compilable programs 
resulting programs similar expressiveness spark programs 
methodology success example constructing paris metro braking system software produces correct programs 
skills needed go refinement process steep learning curve system barrier programmers 
obvious extend methodology expressive abstractions object oriented programs today 
java modeling language jml notation writing specifications java programs :10.1.1.34.8403
jml specifications include rich flavors method contracts recorded java source code stylized comments 
impressive array tools build jml including tools documentation run time checking unit testing light weight contract checking program verification 
spec provides focused methodology jml example adopt full story object invariants presence callbacks 
design space spec somewhat constrained jml jml seek alter underlying programming language example spec introduce field initializers expose blocks 
language aspirations spec accessible widely specification language tailored object oriented net systems 
oriented supporting model development facilities model programs test case generation meta level state exploration 
experiences interface specification run time verification going project product group contributed design spec 
anna specification language ada lets programmers write important design decisions 
specifications compiled run time checks 
mechanical systems proving programs correct conceived built decades ago 
include early entirely automatic systems king deutsch stanford pascal verifier 
program verifiers include penelope ada loop java jml require interactive theorem proving :10.1.1.16.1895
setting early efforts sites german full motion extended static checker modula esc modula changed rules game leveraging power automatic theorem prover proving full functional correctness programs limited aim finding common errors programs 
continuing tradition esc java wrapped technology simpler contract language subset jml aiming deliver practical high precision tool normally skilled programmes 
key ingredient enables esc tools useful checking willingness certain errors lead simpler specification language better odds automatic theorem prover succeed 
boogie attempts completely verify program missing errors ability bound depend simplicity specifications 
spec provides limited type system non null types 
comprehensive type system solution proposed hndrich leino 
design deals complication non null fields introducing additional raw types partially constructed objects 
various abstraction facilities help define modifies clauses modern objectoriented languages proposed 
methodology object invariants modifies clauses relies object ownership impose structure heap :10.1.1.10.4654
similar effects achieved ownership types alias confinement strategies 
earliest seen dates back modifier unique specifies field points owned object 
concluding remarks core spec programming system spec programming methodology spec language spec compiler boogie static program verifier 
methodology prescribes time deal properly object invariants 
spec language embodies methodology spec enriches non null types contracts comprehensions quantifications 
spec compiler uses combination static analysis techniques run time checks guarantee soundness language 
verifier tries check consistency program specifications 
trying spec system practically useful software tool enables normally skilled programmers write verify assumptions 
start familiar programming language metaphor type checking exposing new capabilities static checking technology 
users switch spec system get immediate benefits users start access partially specified base class library users retrofit existing code new specifications users automatically extract requires clauses existing libraries part api documentation spec class comes free users pretty print spec 
design spec focused sequential programs optimistic methodology extended styles concurrent programs 
plausible spec direct help building secure applications 
interesting explore combination methodology stack walking mechanism code access security context existing libraries permissions authentication cryptography 
acknowledgments colleagues helped spec colin campbell rob deline manuel hndrich wolfgang tillmann 
peter ller david naumann contributed advanced versions methodology object invariants 
rob manuel members boogie project 
jim larus sriram rajamani provided support helpful discussions 
craig provided tool extracting contracts existing code 
big goes herman invaluable implementation spec programming language development environment 


abrial 
book assigning programs meanings 
cambridge university press 

allen ambler donald james browne wilhelm burger richard cohen charles hoch robert wells 
language specification implementation verifiable programs 
sigplan notices march 

thomas ball byron cook lahiri sriram rajamani 
automatic theorem proving predicate abstraction refinement 
proceedings cav 
appear 

john barnes 
high integrity software spark approach safety security 
addison wesley 
praxis critical systems limited 

mike barnett robert deline manuel hndrich rustan leino wolfram schulte 
verification object oriented programs invariants 
journal object technology 
appear 

mike barnett wolfgang clemens wolfram schulte clemens szyperski tillmann arthur watson 
serious specification composing components 
heinz schmidt judith stafford kurt editors proceedings th icse workshop component software engineering automated reasoning prediction may 

mike barnett wolfgang lev wolfram schulte tillmann 
tool environment model testing 
rd international workshop formal approaches testing software fates october 

mike barnett david naumann 
friends need bit maintaining invariants shared state 
mathematics program construction july 
appear 

mike barnett wolfram schulte 
specification behavior components 
informatica nov 

mike barnett wolfram schulte 
runtime verification net contracts 
journal systems software 

don box 
essential net volume common language runtime 
addison wesley 

chandrasekhar boyapati robert lee martin rinard 
ownership types safe programming preventing data races deadlocks 
proceedings acm sigplan conference object oriented programming systems languages applications oop sla volume number sigplan notices pages 
acm november 

lilian burdy cheon david cok michael ernst joe gary leavens rustan leino erik poll 
overview jml tools applications 
thomas arts wan fokkink editors eighth international workshop formal methods industrial critical systems volume electronic notes theoretical computer science pages 
elsevier june 
available org 

chapman 
industrial experience spark 
november 
available www praxis cs uk 

cheon 
runtime assertion checker java modeling language 
phd thesis iowa state university april 
available iowa state university department computer science technical report tr 

patrick cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
conference record fourth annual acm symposium principles programming languages pages 
acm january 

robert deline manuel hndrich 
enforcing high level protocols low level software 
proceedings acm sigplan conference programming language design implementation pldi volume number sigplan notices pages 
acm may 

robert deline manuel hndrich 
typestates objects 
ecoop object oriented programming th european conference june 
appear 

david detlefs greg nelson james saxe 
simplify theorem prover program checking 
technical report hpl hp labs july 

david detlefs rustan leino greg nelson james saxe 
extended static checking 
research report compaq systems research center december 

peter deutsch 
interactive program verifier 
phd thesis university california berkeley berkeley ca 

krishna kishore gary leavens 
forcing behavioral subtyping specification inheritance 
proceedings th international conference software engineering pages 
ieee 

manuel hndrich rustan leino 
declaring checking non null types object oriented language 
proceedings acm conference object oriented programming systems languages applications oopsla volume number sigplan notices pages 
acm november 

robert bruce findler matthias felleisen 
contract soundness object oriented languages 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla volume number sigplan notices pages 
acm november 

cormac flanagan rustan leino mark lillibridge greg nelson james saxe raymie stata 
extended static checking java 
proceedings acm sigplan conference programming language design implementation pldi volume number sigplan notices pages 
acm may 

robert floyd 
assigning meanings programs 
mathematical aspects computer science volume proceedings symposium applied mathematics pages 
american mathematical society 

steven german 
automating proofs absence common runtime errors 
conference record fifth annual acm symposium principles programming languages pages 

donald ralph london bledsoe 
interactive program verification system 
proceedings international conference reliable software pages 
acm 

john goodenough 
structured exception handling 
conference record second acm symposium principles programming languages pages 
acm january 

james gosling bill joy guy steele 
java tm language specification 
addison wesley 

polak 
formal verification ada programs 
ieee transactions software engineering september 

hoare 
axiomatic approach computer programming 
communications acm 

hoare 
monitors operating system structuring concept 
communications acm october 

james king 
symbolic execution program testing 
communications acm july 

james king 
program verifier 
phd thesis carnegie mellon university pittsburg pa september 

butler lampson james horning ralph london james mitchell gerald popek 
report programming language euclid 
technical report csl xerox parc october 
earlier version report appeared sigplan notices vol 
acm february 

gary leavens albert baker clyde ruby 
jml notation detailed design 
haim kilov bernhard rumpe ian simmonds editors behavioral specifications businesses systems pages 
kluwer academic publishers boston 

gary leavens albert baker clyde ruby 
preliminary design jml behavioral interface specification language java 
technical report iowa state university department computer science april 

rustan leino 
data groups specifying modification extended state 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla volume number sigplan notices pages 
acm october 

rustan leino todd millstein james saxe 
generating error traces verification condition counterexamples 
science computer programming 
appear 

rustan leino peter ller 
object invariants dynamic contexts 
ecoop object oriented programming th european conference june 
appear 

rustan leino greg nelson 
data abstraction information hiding 
acm transactions programming languages systems september 

rustan leino james saxe raymie stata 
checking java programs guarded commands 
bart jacobs gary leavens peter ller arnd poetzsch heffter editors formal techniques java programs technical report 
hagen may 

rustan leino wolfram schulte 
exception safety 
manuscript microsoft research april 
submitted 
available research microsoft com leino 

barbara liskov john guttag 
abstraction specification program development 
mit electrical engineering computer science series 
mit press 

luckham 
programming specifications anna language specifying ada programs 
texts monographs computer science 
springer verlag 

luckham german von henke karp milne oppen polak scherlis 
stanford pascal verifier user manual 
technical report stan cs stanford university 

charles mann 
software bad 
mit technology review july august 

steve mcconnell 
code complete practical handbook software construction 
microsoft press 

bertrand meyer 
object oriented software construction 
series computer science 
prentice hall international 

peter ller 
modular specification verification object oriented programs volume lecture notes computer science 
springer verlag 
phd thesis hagen 

rti health social economic research 
economic impact inadequate infrastructure software testing 
rti project national institute standards technology may 

shmuel sagiv thomas reps susan horwitz 
precise interprocedural dataflow analysis applications constant propagation 
theoretical computer science 

richard sites 
proving computer programs terminate cleanly 
phd thesis stanford university stanford ca may 
technical report stan cs 

joachim van den berg bart jacobs 
loop compiler java jml 
tiziana margaria wang yi editors tools algorithms construction analysis systems th international conference tacas volume lecture notes computer science pages 
springer april 

williams 
microsoft visual net 
microsoft press 

jeannette marie wing 
tiered approach specifying programs 
phd thesis mit department electrical engineering computer science may 
available mit laboratory computer science tr 

william wulf ralph london mary shaw 
construction verification programs 
ieee transactions software engineering se december 
