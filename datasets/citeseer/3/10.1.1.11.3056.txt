efficient precise datarace detection multithreaded object oriented programs jong deok choi ibm watson research center ibm com robert callahan ibm watson research center ibm com novel approach dynamic datarace detection multithreaded object oriented programs 
past techniques onthe fly datarace detection sacrificed precision performance leading false positive datarace reports maintained precision incurred significant overheads range 
contrast approach results false positives runtime overhead range making efficient precise 
performance improvement result unique combination complementary static dynamic optimization techniques 
categories subject descriptors programming techniques concurrent programming programming techniques object oriented programming software engineering testing debugging general terms experimentation languages measurement performance keywords dataraces race conditions debugging parallel programs synchronization multithreaded programming object oriented programming static dynamic analysis 
datarace occurs multithreaded program threads access memory location ordering constraints enforced accesses accesses write 
cases datarace programming error 
furthermore programs containing dataraces notoriously difficult debug exhibit different functional behaviors executed repeatedly set inputs execution order synchronization operations 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
appear pldi june berlin germany 
copyright acm 
lee univ washington klee cs washington edu vivek sarkar ibm watson research center ibm com univ wisconsin madison cs wisc edu sridharan mit mit edu detrimental effects dataraces reliability comprehensibility multithreaded software widely recognized tools automatic detection dataraces extremely valuable 
result substantial amount past building tools analysis detection dataraces :10.1.1.143.5635:10.1.1.161.222
previous dynamic datarace detection techniques relatively precise races reported correspond truly unsynchronized accesses shared memory 
detectors incur order magnitude overheads range 
approaches reduce overhead datarace detection cost decreased precision 
example monitoring dataraces object level memory location level reduced overheads datarace detection range resulted spurious race reports see section details 
presents novel approach dynamic datarace detection multithreaded object oriented programs efficient precise 
key idea approach relation section identify memory accesses provably redundant viewpoint datarace detection 
source reduction overhead approach report access pairs participate dataraces guarantees access reported distinct memory location involved datarace see section details 
approach results runtime overhead ranging runtime overhead previous approaches comparable precision 
performance obtained combination static dynamic optimization techniques complement reducing overhead detector 
furthermore dataraces reported system correspond actual bugs precise output tool allowed easily find understand problematic source code lines test programs 
shows architecture approach 
phase optional static datarace analysis produces static datarace set conservative set statements identified potentially participating dataraces 
statement belong static datarace set guaranteed cause datarace execution 
phase omitted static datarace set defaults statements contain memory accesses 
second phase instrumentation goal insert trace statements program points identified static datarace set 
insertion process optimized case instrumentation inserted redundant trace points program points program static analyzer static datarace set optimized instrumentation access events ignored non redundant trace points provide sufficient information datarace detection 
result second phase executable extended code generate access events program execution 
third phase optional runtime optimizer uses cache identify discard redundant access events contain new information 
runtime detector examines access events detects dataraces program execution 
instrumentation runtime detector phases guarantee precision approach optimization phases deliver efficiency approach practical 
results show necessary combine optimization phases static analysis optimized instrumentation runtime optimizer obtain maximum performance 
approach contrasts purely ahead time static datarace detection attempts report dataraces may occur possible program execution :10.1.1.143.5635
approach detects dataraces fly usually convenient mode user 
desired approach easily modified perform post mortem datarace detection creating log access events program execution performing final datarace detection phase line 
rest organized follows 
section defines conditions datarace may occur summarizes problem statement addressed 
section describes algorithm runtime datarace detector 
phase describe runtime datarace detector phase mandatory phase provides necessary background explaining optimization phases 
section presents caching mechanism key optimizations runtime optimizer uses identify delete redundant access events 
sections respectively describe static analysis optimized instrumentation phases shown 
section discuss implementation ownership model interaction weaker relation 
section contains experimental results obtained executing set multithreaded java programs prototype implementation approach 
section describes related section contains 

datarace conditions prob lem statement section formalize notion dataraces give example 
formalize problem dynamic datarace detection describe set dataraces guarantee detect report 
instrumented executable program execution access events architecture datarace detection system runtime optimizer cache dynamic datarace set runtime detector datarace conditions define datarace memory accesses satisfy conditions accesses memory location field object accesses write operation accesses executed different threads accesses guarded common synchronization object lock execution ordering enforced accesses example operations 
call conditions datarace conditions observe different datarace conditions assumed past datarace detection fork join programs 
general approach applicable monitor style synchronization primitives supported programming language operating system user 
example shows example program threads main andt 
statements labeled statement numbers labeled statement main thread 
expr denote field access expression statement 
convenience statements relevant dataraces elided example 
note performs write access statement creating starting andt 
thread calls contains accesses object fields write write read calls contains write access assume object point object 
accesses example memory location pair satisfies datarace conditions 
addition assume object point different objects execution 
statement instances belonging different threads guarded synchronization object satisfying third datarace conditions andt different threads execution ordering satisfying second fourth conditions 
exhibit datarace cause datarace example exists ordering andt satisfying fourth conditions 
definition dataraces identifies actual feasible dataraces program execution 
different associate memory location elements array 
certain memory models read generate datarace 
framework easily applied models dropping requirement accesses write 
thread main called thread class synchronized void foo 
public static void main string args 
synchronized 
thread new thread new start called thread start void bar 
synchronized class datarace definitions model mutual exclusion happened relation exclude feasible dataraces definition 
example assume point object different object pointed 
synchronized blocks protected lock 
thread acquires lock approach happened relation record fact statement execute 
doing lead conclude happened relation datarace contrast approach reports feasible datarace andt occurred acquired lock 
regard definition dataraces similar eraser detailed comparison eraser approach appears sections :10.1.1.161.222
thread start join operations third fourth datarace conditions indicate kinds inter thread serialization constructs avoid dataraces mutual exclusion synchronized methods blocks happened relations join operations 
section briefly discuss start operations handled detector mutual exclusion approximations 
rest approach datarace detection focusing mutual exclusion sole inter thread serialization construct 
precisely model join operation mutual exclusion introduce dummy synchronization object thread 
locks solely purpose datarace detection visible application 
dummy operation performed start execution mon exit operation performed 
thread parent thread performs join operation dummy mon enter operation performed thread completes 
dummy synchronizations help datarace detection system observe operations join execute concurrently operations 
difficult constraints way generally know advance threads started thread dummy locks held prior starting child threads 
ownership model approximate ordering constraints arise start oper example program threads 
ations 
define owner location thread accesses location 
start recording data accesses checking dataraces location location accessed thread owner 
approximate approach sufficient capture ordering constraints arise common case thread initializes data accessed child thread explicit locking 
details ownership model provided section 
datarace detection formally define datarace detection follows 
access event tuple identity logical memory location accessed identity thread performs access set locks held time access access type write read source location access instruction 
note source location information reporting bearing definitions optimizations 
access events simply accesses define follows write write program execution generates sequence access events 
performing datarace detection execution equivalent computing value condition definition capture ownership model described 
discussion ownership model effect design implementation deferred section 
dataraces reported set access pairs form datarace execution 
execution accesses algorithm attempts detect pairs worst case time space complexity possible pairs costs prohibitive large sequence accesses 
avoid costs detection algorithm guarantee enumeration pairs performs datarace detection previously defined 
memory location involved datarace detection algorithm reports access event participating datarace 
formally consider partitioning memory location sets boolean predicate indicate event pair define set dataraces reported approach definition 
non empty dynamic datarace detector detects reports access event debugging support report racing access moment occurs program program suspended current state examined aid debugging race 
algorithm reports previous access thread 
see 
furthermore static datarace analyzer discussed section provide usually small set source locations execution potentially race 
experience information combined study source code identify causes dataraces 
obtain full information rarely occurring dataraces program record replay tool dejavu dynamic detection runs dejavu recording expensive reconstruction occurs dejavu replay 
dejavu recording incurs approximately time overhead 

runtime datarace detection section describe algorithm dynamic datarace detection 
need report races program execution key techniques decrease cost algorithm 
weaker relation allows decrease number accesses need consider save representation access event history tries allows efficiently represent search past accesses 
weaker relation past access events access implies need considered performing datarace detection accesses 
weakly protected dataraces protected equally say weaker stronger 
exploiting weaker relationship accesses allows greatly reduce overhead datarace detection algorithm 
outline sufficient condition dynamically determining event weaker event memory location access type thread information contained event 
add possible values see section explanation specific threads reported approach 
past access event stored detector 
means distinct threads set encounter event 
intuition different threads access memory location access memory location non intersecting datarace accesses reads independent threads previously accessed location 
utilizing space optimization simplifies implementation reason report specific thread earlier access datarace 
define partial order threads access types follows write orderings define weaker partial order accesses definition 
access events theorem weaker 
past accesses accesses proof 
implies second implies third implies case new access implies write write write 
race detector ensures detect weaker store information weaker decreasing time space overhead sections show weaker relation filter events reach detector 
trie algorithm section describe runtime datarace detection algorithm tries represent event history 
detection algorithm unique memory location access event observed datarace detector represent history accesses location edge labeled trie 
edges trie labeled identifiers lock objects nodes hold thread access type information possibly empty set access events 
set locks access represented path root trie node corresponding access 
nodes tries thread field access type field 
internal nodes corresponding accesses assigned access type read special thread value meaning rare case tool reports spurious datarace optimization weaker relation suppress reporting real datarace allowing false positive report 
extra locking inserted user suppress spurious report overcomes deficiency 
threads 
define meet operator thread information access information write encounter access event check exists access history 
check performed traversal trie corresponding edges labeled lock identifiers depthfirst order 
traversal examine encountered node access type thread information see represents accesses weaker defined previous section 
traversal procedure guarantees memory location weakness conditions satisfied 
find node safely ignore maintaining reporting guarantees described section 
practice vast majority accesses filtered check 
weakness check fails check dataraces performing depth traversal trie 
node encountered cases case edge destination labeled lock identifier 
case shares lock accesses represented children 
datarace access represented subtree rooted need search deeper branch trie 
case ii 
case hold write 
case datarace differs previous thread accessed intersection lock sets empty access write 
report race immediately terminate traversal 
case iii 
case ii holds case traverse children 
checking races update trie information 
node trie path root labeled locks update 
exists add nodes edges create setting 
traverse trie remove stored accesses stronger newly added access 
implementation implemented algorithm java code straightforward 
algorithm runs online alongside program 
interface algorithm program discussed 
implementation uses memory addresses identify logical memory locations 
garbage collection move objects different addresses reuse addresses different objects 
respond garbage collection augmenting object address information stored data structures prototype implementation simply memory garbage collection occur 

runtime optimization algorithm described previous section reads event stream generated running target program 
reduce overhead race detection reduce number access events need fed detector combination static dynamic techniques 
section describes dynamic technique caching detect redundant accesses 
overview previous section describes access discarded seen weaker access 
experiments show benchmarks accesses discarded way 
check previous weaker access efficient possible introducing caches record previous accesses 
caches thread recording read recording write accesses 
cache indexed memory location 
program performs access location look appropriate cache 
cache design guarantees entry weaker access recorded algorithm required 
entry send information new access runtime detector add corresponding new entry cache 
cache policy recall access weaker access 
require entry access cache new access checked weaker 
guarantee observe simply currently executing thread occurs 
separate caches thread 
thread cache 
ensures cache operations require synchronization 
separate caches reads writes find entry look cache certainly access type 
ensure monitor set locks currently held thread 
program executes release lock evict cache 
ensures times cache subset currently held locks 
occurs know cache 
note java synchronization blocks reentrant thread release lock lock previously acquired 
ignore nested locks unlocks lock object requires cache entries evicted 
cache indexed memory location 
policy guarantees entries cache weaker access looked check thread id access type lock set stored cache entries 
thread releases lock need quickly evict cache entries lock sets contain 
exploit nested locking discipline imposed java language bytecode language rely fact bytecode generated java compiler 
discipline ensures time access generated cache entry lock lock acquired lock subsequently released 
lock currently held thread keep linked list cache entries lock acquired 
released evict entries list cache 
lists doubly linked individual cache entries quickly removed evicted due cache conflicts 
implementation entry direct mapped caches reads writes indexed memory address 
hash function multiplies bit memory address constant takes upper bits result 
cache code entirely written java executed jalape virtual machine 
ensure jalape optimizing compiler inlines calls cache lookup methods user program 
jalape calls ensure cache lookup code compiled efficient machine code array bounds checks 
cache lookup results hit requires powerpc instructions implementation 

static datarace analysis static datarace analysis algorithm formulates datarace analysis conjunction interthread control flow analysis pointsto analysis thread objects synchronization objects access objects 
formulation compute static datarace set set statement pairs may cause datarace execution 
statements part statement pair static datarace set non datarace statements need instrumented 
section give brief summary approach static datarace analysis 
detailed description 
describe static formulation datarace conditions section 
describe interthread control flow graph icfg represent sequential parallel interprocedural control flow section icfg points analysis compute static formulation datarace conditions section 
describe extension escape analysis improve precision static datarace analysis section 
datarace conditions statements datarace conditions defined section formulated conservatively follows static analysis true executions may access memory location may points information computation 
example may points information object andt statically determine may access memory location execution 
true executed thread points information thread objects computation 
points information thread objects runt ort statically determine statements may executed different threads 
true synchronized common lock points information synchronization objects computation 
points information synchronization objects pointed statically determine statements may executed different synchronization objects 
convenience ignore fourth datarace conditions section conservatively assume holds 
worth noting may approximations correctly conservative datarace analysis datarace conditions refer complements sets 
interthread control flow graph icfg icfg detailed interprocedural representation multithreaded program nodes represent instructions statements edges represent sequential parallel control flow 
method synchronized block distinguished entry exit nodes icfg 
icfg contains types control flow edges intraprocedural call return start 
types standard interprocedural control flow graph 
start edges unique icfg represent invocations start method thread object starts thread invokes method 
invocations arun method execute part calling thread 
join edges included icfg needed conservative static datarace analysis performed approach 
start edges referred interthread edges edges icfg called edges 
entry node target start edge called thread root node 
icfg path interthread edges path icfg path interthread edges interthread path 
interthread call graph icg interprocedural abstraction icfg designed practical scalable analysis large programs 
icg node created method synchronized block icfg 
inclusion separate icg nodes synchronized blocks notable difference icg standard call graphs 
points analysis points analysis employ static datarace analysis flow insensitive program analysis 
analysis distinct object created allocation site program 
object represents concrete objects created site execution 
points analysis computes access program set objects points path 
precise points analysis expensive general 
devised simple conservative points analysis notion single instance statements executes execution 
object created statement called single instance object 
access points object object object relation access object points relation details points analysis 
may pointsto sets access 
compute equation follows points information refers accessed field object class 
access set thread root nodes entry nodes exists icfg path 
compute follows points assume intraprocedural edges capture intraprocedural control flow including control flow arising exceptions 
special null object represent null 
information denotes pointer thread root node 
node synchronized method block access synchronization object set predecessor nodes icg 
compute set dataflow equations compute follows compute equation combining equations 
extending escape analysis past escape analysis normally identifies objects reachable threads thread created 
thread local object participate datarace 
java code frequently uses objects associated thread follow pattern susceptible data races 
particular say object accesses performed constructed starts running 
objects typically stored fields object escape thread creating thread local described 
usage common extended static analysis identify thread specific objects 
implemented simple effective approximation algorithm compute thread specific objects 
define thread specific methods recursively follows init methods thread objects methods invoked explicitly invoked result thread started non static method direct callers thread specific non static methods passing callee 
second define thread specific fields fields thread accessed getfield putfield operations thread specific method 
define unsafe thread thread execution may start initialization completes 
thread object conservatively identified unsafe constructor transitively call thread start escapes constructor 
thread safe unsafe 
definitions say object thread specific safe object reachable thread specific methods thread specific fields accesses thread specific object safe thread involved datarace 
accesses thread specific fields involved datarace 

compile time optimizations static datarace analysis phase improves performance dynamic detector eliminating consideration statements participate datarace 
approach compiletime optimization stems weaker relation defined section execution statement generates access discarded previous access weaker statement need instrumented 
section describe static form weaker relation loop peeling transformation avoid inserting instrumentation prove produce redundant access events 
static weaker relation denote set access events generated instrumentation statement execution 
define static weaker relation statements follows definition 
weaker written iff execution exists execution defined section exists thread start 
sophisticated interprocedural analysis required determine arbitrary 
developed conservative effective analysis computing belong method 
model instrumentation generates access events pseudo instruction object accessed field object accessed lock set held access access type read write 
operands treated uses values 
accesses static fields represents class field declared accesses array elements represents array index 
thread information explicitly modelled instruction attempt optimize thread boundaries thread information available instrumentation code runtime 
insert pseudo instruction instruction accesses field object static field array element optionally information static datarace analysis eliminate consideration instructions involved dataraces 
insertion attempt eliminate pseudo instructions static weaker relation 
define statements method follows definition 
true iff intraprocedural path contains exists method invocation intraprocedural path 
condition indicates executes execution instance method executes 
known concepts computing dominates written post dominates written experiments 
difficult prove statement post dominates java statement throw exception suspect effective 
second condition guarantees path contain start 
static weaker relation decomposed easily verifiable conditions notation explained show statement generates event weaker produced show equal directly check implies 
check nesting java synchronization blocks 
specifically verify condition true nesting level synchronization blocks deeper level block 
show analysis checks value number object 
conditions hold safely eliminate 
implementation section briefly describe implementation infrastructure optimized instrumentation 
instrumentation analysis weaker relation performed compilation method jalape optimizing compiler 
created new instruction high level intermediate representation hir compiler corresponding pseudo instruction instructions inserted previously described 
insertion statements conversion static single assignment ssa form performed dominance relation computed 
elimination redundant statements performed static relation utilizing existing value numbering phase 
remaining statements marked having unknown side effect ensure eliminated dead code jalape optimization phases truly unreachable 
completion jalape hir optimization phases expand statement call method dynamic detector force jalape inline call 
jalape optimizes hir 
hir representation converted lower level representations eventually machine code compiler optimization 
loop peeling loops key source redundant access events 
example loop consisting statement produce redundant access events iteration loop information recorded iteration 
issues redundant events difficult statically eliminate 
redundancy elimination static weaker relation applied remove instrumentation information produced iteration loop redundant 
furthermore perform standard loop invariant code motion hoist instrumentation outside loop statements potentially excepting instruction pei may throw exception bypass remaining instructions loop 
statements guaranteed execute loop condition initially true 
occur frequently java safety checks null pointer array bounds checks 
reduce generation redundant access events loops loop peeling program transformation 
transformation optimization 

pei trace optimization 

pei trace 
pei example loop peeling optimization creates new copy body loop iteration utilizes original body remaining iterations 
statements throughs show result loop peeling existing redundancy elimination applied loop ofs 
statement ats needed guard possibility loop executing 
statement ats modified ensure loop execute iteration executed throughs 
loop peeling statement loop body eliminated statements statically weaker 
resulting code traces write access achieving goal eliminating instrumentation loop 
unaware previous performs type program transformation decrease cost instrumentation 

ownership model preceding discussion ignores effects ownership model introduced section 
briefly consider ownership model interacts machinery 
implementation modified runtime race detector record memory location owner thread thread access memory location 
time location accessed check see current thread ignore access case 
time current thread say memory location shared set send access event subsequent events rest detector described section 
essentially access event stream filtered include accesses memory locations shared state 
interactions weaker relation run time compile time optimization phases rely concept access event weaker event case suppressed 
unfortunately presence ownership model definitions weaker section sufficient guarantee weaker implies suppressed 
difficulty arises event sent detector owned state changes shared state occurs 
situation suppressed 
run time optimization cache avoid problem forcibly evicting location thread cache shared 
harder avoid problem compile time optimization 
statements generally difficult prove accessed location state change owned shared introducing dynamic check ownership state eliminate benefit optimization 
truly sound compile time approach post dominance relationship post dominates access guaranteed weaker remove instrumentation safe object owned access suppressed object owned access suppressed 
unfortunately previously noted post dominance holds java bytecode instruction throw exception 
problem languages 
actual approach simply ignore interaction weaker ownership model static dynamic optimizations 
means theory tool may inadvertently suppress fail report races 
observe problems practice experiments verified races reported optimizations unsafe weaker relation enabled disabled 

experimental results evidence supporting major claims definition dataraces captures truly unsynchronized accesses fewer false alarms alternative definitions dataraces detected modest overhead especially compared datarace detection implementations 
program examples table lists programs experiments 
original sor benchmark manually hoisting loop invariant array subscript expressions inner loops 
optimization performed compiler intraprocedural analysis implemented jalape significant impact effectiveness optimizations 
modified elevator slightly force terminate simulation finishes normally just hangs 
benchmarks interactive cpu bound report performance results benchmarks 
performance table shows runtime performance algorithm selected variants demonstrate impact optimizations 
base records performance example instrumentation loop peeling 
full complete algorithm optimizations turned 
full static datarace detection turned access statements potential dataraces 
full static weaker check disabled disables loop peeling useless check 
turns loop peeling 
disables cache 
static datarace detection instrument accesses jalape runs memory program terminates 
obtained examples praun gross owe great 
configuration ran program times invocation vm reported best performing run 
enabled full optimization jalape disabled adaptive compilation 
jalape configured mark sweep garbage collector set heap size gb ram gc occurred 
test machine single mhz power cpu running aix 
overheads lower previously reported dynamic datarace detection algorithm 
benefits optimization vary benchmarks optimization vital benchmark 
programs tsp loops involving method calls recursive method calls benefit greatly cache 
programs dominated loops arrays benefit dominator analysis loop peeling 
measure space overhead directly jalape mixes program data virtual machine data making space measurements difficult 
instrumentation consumed space tsp requiring approximately memory thread threads trie nodes holding history memory locations 
scheme packing information multiple locations trie due space limitations 
estimate total amount memory instrumentation tsp 
accuracy table records number objects report dataraces algorithm selected variants 
normally output object field datarace occurs comparison purposes count number distinct objects mentioned 
full complete precise algorithm 
variant algorithm distinguish different fields object thread accessing appear datarace thread accessing hold common lock 
static fields class distinguished 
variant full wait location touched multiple threads starting monitor accesses 
report dataraces 
accesses field raytrace synchronized causing value potentially invalid fortunately value 
unsynchronized accesses spec test harness result incorrect output 
tsp serious datarace lead incorrect output 
report dataraces fields fact happen due higherlevel synchronization 
dataraces report sor truly unsynchronized accesses program uses barrier synchronization captured algorithm 
dataraces report true unsynchronized accesses causes 
size thread pool read written appropriate locking cause pool size invalid 
seriously unsynchronized assignment null thread cause program die nullpointerexception task completes just thread cancel 
nearly impossible find normal testing debugging 
fact previous mistakenly classified datarace benign possibly sort number spurious datarace reports 
fail distinguish fields produce spurious example lines code num 
dynamic threads description mtrt multithreaded ray tracer specjvm tsp traveling salesman problem solver eth sor modified successive relaxation benchmark eth elevator real time discrete event simulator web crawler application kernel developed eth concurrent programming library doug lea 
table benchmark programs characteristics example base full mtrt memory tsp sor example full mtrt tsp sor elevator table number objects dataraces reported race reports class fields immutable accessed synchronization 
produces spurious warnings objects fields thread local shared require synchronization 
report additional spurious dataraces fields 
benchmarks reports spurious dataraces data initialized thread passed child thread processing 
previous eraser object datarace detection uses looser definition dataraces datarace deemed occurred location single common lock held accesses :10.1.1.161.222
approach produces spurious datarace reports variables holding statistics accessed child threads holding common parent thread called join child threads synchronization 
scheme introduces threads access variables lock sets 
report datarace mutually intersecting single common lock 
summary benchmarks dataraces report true unsynchronized accesses correspond real bugs 
strict definition induces significantly spurious reports 

related past research datarace detection classified ahead fly mortem 
approaches offer different trade offs ease precision efficiency coverage dimensions 
ahead time datarace detection usually performed static table runtime performance datarace analysis tools yield high coverage considering space possible program executions identifying dataraces occur 
flanagan freund datarace detection tool static tool java tracks synchronization extended type inference checking 
guava dialect java statically disallows dataraces preventing concurrent accesses shared data 
instances classes belonging class category called monitor shared multiple threads 
serializing accesses fields methods shared data guava prevent dataraces 
boyapati rinard propose system type annotations java ensures typed program datarace free allows programmer write generic class subclass different protection mechanisms 

annotation static datarace detection tool ansi programs supports lock synchronization 
aiken gay statically detects dataraces spmd programs 
spmd programs employ barrier style synchronizations need track locks held statement 
static datarace analysis employed part datarace detection points analysis variables 
primary advantage static analysis approach efficiency due fact incurs runtime overhead 
advantage mitigated practice severe limitations precision due false positive reports ease due requirement presenting program static analysis tool augmented annotations aid analysis 
key advantage dynamic analysis approaches onthe fly post mortem datarace detection precision results false positives past advantage usually came high cost efficiency 
dynamic approach limited coverage static approach reports dataraces observed single dynamic execution 
cases dynamic tools improve coverage considering alternate orderings synchronization operations consistent actual events observed original program execution :10.1.1.161.222
schonberg introduced idea detecting dataraces proper locking discipline 
system employed detection approach happened relation called lock covers subtraction optimization uses notion similar weaker relation suggest optimization detector employ notion stages detection framework 
eraser similar approach datarace detection algorithm lock synchronization :10.1.1.161.222
eraser enforces constraint shared memory location protected unique lock execution reporting fewer spurious data races 
ownership model eraser eraser comparable handling join operation see section 
eraser works independently input source language instrumenting binary code runtime overhead range 
praun gross object race detection greatly improves eraser performance applying escape analysis filter non datarace statements detecting dataraces object level level memory location overhead ranges benchmarks space overhead 
coarser granularity datarace detection includes treating method call object write leads reporting dataraces true dataraces reported races indicate unordered concurrent accesses shared state 
example program report dataraces objects true dataraces object race detection reports dataraces true dataraces 
race definitions object race detection eraser imply report superset races report 
trade similar object race detection apply escape analysis trade analysis dynamically 
trade datarace detection differs happens relation 
trade adds runtime overhead ranging compared interpreter approximately space overhead 
commercial products dynamically detect dataraces java programs 
observed overhead ranging memory requirements practically impossible reasonably sized program 
min choi hardware scheme uses cache coherence protocol richards larus uses distributed shared memory dsm computer memory respectively collecting information fly datarace detection 
dynamic datarace detection techniques spmd programs post mortem tools fly tools collecting information actual executions software instrumentation 
post mortem approach offers possibility improving line efficiency moving bulk post mortem phase cost complicating ease 
size trace structure grow prohibitively large making post mortem approach infeasible long running programs 
dimension classify past datarace detection underlying concurrency model 
past datarace detection historically targeted multithreaded programs 
results applicable object concurrency models multithreaded object oriented programming languages java 
netzer miller categorize dynamic dataraces actual apparent feasible dataraces 
assuming point different synchronization objects andt actual feasible datarace occurs 
feasible datarace occurs introduces happened relation tot 
choi min describe identify reproduce race frontier set dataraces affected dataraces 
repeatedly reproducing correcting dataraces race frontier identify dataraces occur executions 

novel approach efficient precise datarace detection multithreaded object oriented programs 
approach consists unique combination static datarace analysis optimized instrumentation runtime access caching runtime detection phases 
approach results runtime overhead range past 
furthermore datarace definition precise test cases dataraces reported fact concurrent accesses shared memory locations ordering constraints 
results show feasible perform precise datarace detection production setting 
plan broaden static dynamic approach tackle problems deadlock detection immutability analysis 
intend enhance static analysis phases precise alias analysis algorithms 
plan integrate new analyses record replay capabilities dejavu debugger providing powerful platform reasoning behavior multithreaded programs 
acknowledgments members jikes rvm runtime group jikes rvm optimization group ibm watson research center help jikes rvm system 
referees committee members pldi insightful comments 
julian interprocedural analysis framework forms basis static datarace analysis 

aiken gay 
barrier inference 
proceedings th symposium principles programming languages popl pages january 
alpern jalape virtual machine 
ibm systems journal 
bacon strom 
guava dialect java data races 
acm conference object oriented programming systems languages applications 
blanchet 
escape analysis object oriented languages application java 
proceedings acm sigplan conference object oriented programming systems languages applications denver colorado november 
lzle 
removing synchronization java 
proceedings acm sigplan conference object oriented programming systems languages applications denver colorado november 
boyapati rinard 
parameterized type system race free java programs 
acm conference object oriented programming systems languages applications 
burke carini 
choi hind 
flow insensitive interprocedural alias analysis presence pointers 
th international workshop languages compilers parallel computing 
extended version published research report rc ibm watson research center september 

cheng feng leiserson randall stark 
detecting data races cilk programs locks 
proceedings tenth annual acm symposium parallel algorithms architectures 

choi alpern ngo sridharan vlissides 
perturbation free replay platform cross optimized multithreaded applications 
proceedings th ieee international parallel distributed processing symposium april 

choi gupta serrano sreedhar midkiff 
escape analysis java 
acm conference object oriented programming systems languages applications pages 

choi sarkar 
static datarace analysis multithreaded object oriented programs 
technical report ibm research 
report rc www research ibm com jalapeno dejavu 

choi min 
race frontier reproducing data races parallel program debugging 
proceedings third acm sigplan symposium principles practice parallel programming april 
de 
trade topological approach fly race detection java programs 
proceedings java virtual machine technology symposium jvm april 
schonberg 
detecting access anomalies programs critical sections 
proceedings acm onr workshop parallel distributed debugging published acm sigplan notices 
flanagan freund 
type race detection java 
proceedings acm sigplan conference programming language design implementation pldi pages june 
fredkin 
trie memory 
communications acm september 
kl group king street east toronto ontario canada 
getting started 
kuck associates fox drive champaign il usa 
user manual edition march 
min 
choi 
efficient cache access anomaly detection scheme 
proceedings th international conference architectural support programming languages operating systems asplos april 
netzer miller 
race conditions 
issues formalizations 
acm letters programming languages systems mar 
praun gross 
object race detection 
acm conference object oriented programming systems languages applications 
richards larus 
protocol data race detection 
proceedings acm sigmetrics symposium parallel distributed tools pages august 
ruf 
effective removal java 
sigplan conference programming language design implementation pages 
savage burrows nelson sobalvarro anderson :10.1.1.161.222
eraser dynamic data race detector multi threaded programs 
acm transactions computer systems 
schonberg 
fly detection access anomalies 
proceedings acm sigplan conference programming language design implementation pldi pages june 
steensgaard 
points analysis linear time 
proceedings annual acm sigplan sigact symposium principles programming languages popl pages january 
sterling 
static data race analysis tool 
usenix winter technical conference pages 
