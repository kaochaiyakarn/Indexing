journal machine learning research submitted published optimal structure identification greedy search david maxwell chickering dmax microsoft com microsoft research microsoft way redmond wa editor craig boutilier prove called meek conjecture 
particular show dag independence map dag exists finite sequence edge additions covered edge reversals edge modification remains independence map modifications shown meek result important consequence bayesian approaches learning bayesian networks data limit large sample size exists twophase greedy search algorithm applied particular sparsely connected search space provably identifies perfect map generative distribution perfect map dag 
provide new implementation search space equivalence classes states operators greedy search scored ciently local functions nodes domain 
synthetic real world datasets demonstrate phase greedy approach leads solutions learning finite sample sizes 

decade enormous amount machine learning literature problem learning bayesian networks data 
ph dissertation topic meek put forth conjecture true leads somewhat surprising result generative distribution perfect map dag defined observables exists sparse search space space state connected small fraction total states apply greedy search algorithm limit large number training cases identifies generative structure 
called meek conjecture stated follows 
denote dags independence map words independence implied structure implied structure exists finite sequence edge additions covered edge reversals applied properties edge change dag remains independence map edge changes intuitively plausible validity meek conjecture remained unknown 
bouckaert proved conjecture true di er exactly edge 
prove meek conjecture 
provide algorithm determining specific sequence edge modifications transforms david maxwell chickering 
chickering modification remains independence map assuming initially edges appear orientation edges appear opposite orientation sequence includes edge modifications 
algorithm similar proposed bouckaert 
particular choice edge modify depends parents children node sink node node children configurations parents children node reasonably easy identify edge modification prove remains independence map performing modification configurations algorithm proof essentially provided 

particular configuration parents children di cult choose edge modify 
configuration 
conjecture appropriate edge modification exists unable construct procedure identify 
assumption conjecture true meek devised phase greedy algorithm applies bayesian scoring criterion identify unique equivalence class dags perfect map generative distribution assuming equivalence class exists 
algorithm summarized follows 
start equivalence class corresponding dependencies greedily add dependencies considering possible single edge additions dags current equivalence class 
greedy algorithm stops local maximum apply greedy algorithm considers step possible single edge deletions dags current equivalence class 
algorithm terminates local maximum identified second phase 
fact algorithm identifies limit optimal equivalence class remarkable sparsity search space state search space connected states possible single edge additions single edge deletions dags state 
assuming generative model small expect number additions deletions small states encounter search 
phase greedy algorithm theoretical justification light meek conjecture true obvious question algorithm works practice 
words regard generative distribution perfect map dag data support asymptotic properties bayesian scoring criterion local maximum reached algorithm applied realworld data correspond model close score global maximum 
able answer question exhaustively enumerating scoring possible equivalence classes compare phase algorithm traditional search algorithms 
order perform desired greedy search able score possible single edge additions deletions dags contained equivalence class 
principle involve actual enumeration dags equivalence class dag edge changes scored 
fortunately chickering formulated search space allows cient traversal equivalence classes directly opposed traditional approach traversing dag space 
operators defined chickering correspond connectivity equivalence classes necessary phase search leverage existing results derive optimal structure identification greedy search appropriate operators relative ease 
show operators scored local functions nodes neighbors equivalence class representation search state space shares computational advantages traditional dag search spaces 
organized follows 
section describe notation introduce previous relevant 
section discuss meek conjecture detail algorithm identify edge modification necessary transformation 
postpone rigorous proof conjecture appendix provide intuition prove di cult step 
section discuss asymptotic properties bayesian scoring criterion show properties conjunction validity meek conjecture imply optimality phase greedy search algorithm 
section describe search space states search correspond equivalence classes dags operators correspond single edge additions deletions member dags 
show operators scored local functions nodes search state representation 
section apply phase greedy algorithm synthetic real world datasets di erent sizes 
compare solution quality algorithm traditional dag greedy search algorithm greedy search algorithm applied equivalence class space defined chickering 
synthetic data show phase algorithm superior task reconstructing generative structure 
real world data show phase algorithm competitive slightly slower due densely connected search space task identifying high scoring models 
section conclude summary discussion relevant research 
detailed proofs main results contained appendix 

background notation section introduce notation discuss previous relevant 
syntactical conventions 
denote variable upper case letter state value variable letter lower case 
denote set variables bold face capitalized letter letters pa na 
corresponding bold face lower case letter letters pa na denote assignment state value variable set 
calligraphic letters denote statistical models parameterized 
bayesian network models dag models parameterized bayesian network model set variables 
pair 
directed acyclic graph dag short consisting nodes correspondence variables directed edges connect nodes 
set parameter values specify conditional probability distributions denote subset parameter values define conditional probability node parents parameterized bayesian network represents joint distribution factors structure chickering follows 
pa pa pa set parents node structure bayesian network model represents independence constraints hold distribution represented bayesian network structure 
set independence constraints imposed structure equation characterized markov conditions constraints variable independent non descendants parents 
independence constraint holds derived markov conditions see pearl 
denote assertion dag imposes constraint independent set dag clear context 
numerous comparisons statistical models example compare dag models compare properties probability distributions corresponding properties dags 
simplify discussion assume comparison models defined set variables 
say example dags represent independence constraints assume defined set nodes 
descendants node denoted de set containing nodes reachable directed path ancestors node set nodes reach directed path length 
subset nodes say node maximal node ancestor equivalence independence maps dags distributionally equivalent bayesian network exists bayesian network define probability distribution vice versa 
dags independence equivalent independence constraints dags identical 
applications researchers assume conditional distribution node bayesian network model comes specific family distributions 
example assume conditional probability continuous variable sigmoid distribution 
distributional assumptions impose non independence constraints joint distribution lead dags independence equivalent distributionally equivalent 
remainder adopt common distribution assumptions literature bayesian network learning assume gaussian distributions continuous variables unconstrained multinomial distributions discrete variables 
assumptions notions equivalence identical say dags equivalent indicate distributionally independence equivalent 
denote equivalent 
equivalence reflexive symmetric transitive relation defines set equivalence classes network structures 
denote equivalence class dag models 
note optimal structure identification greedy search non bold character arguably misleading light convention bold face sets variables non bold character emphasize interpretation model set independence constraints opposed set dags 
set containment operator denote dag elements equivalence class 
write denote equivalence class denote particular equivalence class dag model belongs write 
note implies 
skeleton dag undirected graph resulting ignoring directionality edge 
structure dag ordered triple nodes contains edges adjacent verma pearl provide characterization equivalent dag models 
theorem verma pearl dags equivalent skeletons structures 
dag say edge covered identical parents exception parent 
covered pa pa significance covered edges evident result lemma chickering dag model result reversing edge dag equivalent covered transformational characterization equivalent dag models prove important main results 
theorem chickering pair dag models edges opposite orientation exists sequence distinct edge reversals properties 
edge reversed covered 
reversal dag 
reversals dag independence map dag independence relationship holds denote independence map symbol meant express fact contains edges independence map relation compare pair models just dag models impose independence constraints set variables 
reserve symbol comparisons dag models 
edge compelled edge exists dag equivalent edge compelled say reversible 
light theorem reversible edge exists dag equivalent edge oriented opposite direction 
say distribution contained dag exists set parameter values parameterized bayesian network model represents exactly 
chickering learning models data discussed section proof meek conjecture leads optimal greedy algorithm learning graphical models data 
concentrate bayesian methods learning graphical models roots date back je reys 
refer reader heckerman buntine review methods complete list relevant 
discuss algorithm conjunction alternative learning methods 
approaches bayesian network learning problem typically concentrate identifying dag models fit set observed data scoring criterion structure bayesian network identified usually straightforward estimate parameter values corresponding parameterized bayesian network 
bayesian approach learning dag models define model hypothesis observed data set iid samples distribution contains exactly independence constraints implied scoring criterion defined relative posterior relative log posterior observed data 
detailed discussion bayesian scoring criterion discussion alternative definitions section 
scoring criterion say decomposable written sum measures function node parents 
words decomposable scoring criterion applied dag expressed pa note data implicit right hand side equation 
say pa function parents intend mean data measure depends restricted columns corresponding parents 
explicit re write terms sum equation pa pa denotes data restricted columns corresponding variables set find convenient keep notation simple 
scoring criteria derived literature decomposable 
important property decomposable scoring criteria want compare scores dags need compare terms equation corresponding nodes di erent parent sets graphs 
proves particularly convenient search algorithms consider single edge changes dags section show decomposable scoring criterion leads cient implementation phase greedy search algorithm meek 
scoring criterion score equivalent pair equivalent dags necessarily case 
completed pdags implementation greedy search algorithm section search equivalence classes dag models opposed dag models 
optimal structure identification greedy search done chickering completed pdags define represent equivalence classes 
acyclic partially directed graph pdag short graph contains directed undirected edges represent equivalence class dags 
denote arbitrary pdag 
define equivalence class dags corresponding follows skeleton set structures 
theorem follows pdag containing directed edge edge participating structure undirected edge edge uniquely identifies equivalence class dags 
may pdags correspond equivalence class 
example dag interpreted pdag represent equivalence class 
dag skeleton set structures pdag directed edge orientation say consistent extension dag consistent extension contained dag consistent extension consistent extension pdag say admits consistent extension 
completed pdags represent equivalence classes dags 
recall compelled edge edge exists orientation member equivalence class reversible edge edge compelled 
completed pdag corresponding equivalence class pdag consisting directed edge compelled edge equivalence class undirected edge reversible edge equivalence class 
equivalence class dags completed pdag representation unique 
dag equivalence class consistent extension completed pdag representation class 
shows dag shows completed pdag 
pdags called patterns spirtes glymour scheines completed pdags called essential graphs andersson madigan perlman maximally oriented graphs meek 
dag completed pdag 
definitions skeleton set structures pdag obvious extensions definitions dags 
chickering 
meek conjecture section discuss meek conjecture detail constructive algorithm prove conjecture true 
provide examples help illustrate algorithm give insight researchers unable solve problem 
detailed proof postponed appendix recall transformational characterization equivalence section states transform sequence covered edge reversals 
meek conjecture analogous characterization independence map relation 
particular meek conjecture states transform sequence covered edge reversals single edge additions 
formally state main result 
theorem pair dags number edges opposite orientation number edges exist orientation exists sequence edge reversals additions properties 
edge reversed covered edge 
reversal addition dag 
reversals additions proof theorem constructive define algorithm shown takes input dags identifies edge added reversed 
show edge modification algorithm remains independence map closer sense fewer adjacency di erences number adjacency di erences fewer orientation di erences 
theorem immediate consequence validity algorithm apply edge operation convert calling algorithm repeatedly replacing call result algorithm words algorithm works follows 
common sink nodes identical parents dags removed dags 
remove mean remove consideration practice input dags need modified understood algorithm apply edge operation uses value calling convention local variables algorithm modify side ects 
algorithm identifies sink node sink node algorithm chooses parent node parent adds edge edge oriented opposite direction algorithm identifies unique edge step step discussed detail 
edge covered algorithm reverses edge terminates 
follows definition covered edge parent parent case algorithm adds edge parent parent case algorithm adds edge optimal structure identification greedy search algorithm apply edge operation input dags output dag results adding reversing edge 
set 
contain node sink dags pa pa remove incident edges dags 

sink node 
children parent parent add edge return 
de denote descendants de denote unique maximal element set maximal child descendant 
covered reverse return 
exists node parent parent add return 
parent parent add return algorithm identifies applies edge modification examples follow assume reader familiar separation criterion test independence relationships dag models 
familiar criterion refer appendix detailed definition description 
give example application algorithm 
consider dags shown respectively 
easy verify testing unique markov conditions hold separation consider call algorithm apply edge operation 
common sink nodes algorithm remove nodes step 
node sink node child easy see edge tested step edge covered algorithm reverses terminates 
resulting dag shown 
call algorithm apply edge operation dag returned previous call function 
call dags contain sink node single parent node removed consideration dags 
removal remaining common sinks parents algorithm proceeds step identifies sink node single child identify step edge tested step edge covered algorithm terminates dag shown 

guaranteed unique lemma appendix chickering call algorithm apply edge operation final time dag equal returned previous call 
removing dags algorithm adds edge step resulting dag shown identical dags example application algorithm apply edge operation 
original dag dag 
show dags resulting successive calls algorithm 
mentioned section validity edge modifications proved relative ease 
di cult case prove child sink node parent parent case step encountered key step selection specific child step algorithm 
step encountered simpler method choosing step 
particular su ce choose maximal child illustrate di cult case consider single step example 
shown 
choice adding second addition yields dag remains independence map 
particular add edge independence hc hold resulting dag 
show correct choice additions call algorithm 
common sink nodes unique sink node set descendants maximal element set maximal child descendant edge chosen algorithm considered steps 
edge covered parent parent algorithm adds edge step 
optimal structure identification greedy search dags example application algorithm apply 
fully understand selection step guarantees addition valid reader study proof appendix simply gain intuition provide insight step 
discussion assumes familiarity separation criterion familiarity concept active path defines criterion 
readers familiar concepts consult appendix provide relevant portions respectively help clarify discussion 
relevant portion demonstrate step leads valid edge addition step 
non standard definition active path appendix standard definition su ce discussion 
chickering recall node step maximal element de respect step look descendents pick maximal descendant respect note sink potential problem addition edge active path nodes conditioning set exists resulting graph active path exists reasonably easy show properties hold exists active path exist path includes edge descendant including belong conditioning set conditioning set 
properties see descendant descendant endpoints 
follows non descendant node path follows head head junction collider path 
second choice active path dag easy show active paths endpoints directed path pass node 
see exist active paths endpoints furthermore property paths edge 

concatenate identify active path implies descendants concatenation active paths active descendants endpoint concatenation directed path endpoint nodes edge away connected active path endpoint form active path 
logic choice step clear 
maximal node descendants ancestor nodes see lemma appendix 
means ancestor yield contradiction 

optimality greedy search section describe phase greedy search algorithm proposed meek show limit large samples algorithm identifies dag corresponding generative model model exists 
concerned theoretical properties algorithm postpone discussing implementation details section 
precise optimality result section need notation 
dag probability distribution say perfect map independence constraint implied structure independence implied structure holds exists dag perfect map probability distribution say dag perfect 
assumption case observed data iid sample dag perfect probability distribution 
optimal structure identification greedy search allow missing values iid sample results implicitly depend assumption parameters bayesian network identifiable 
assume remainder section empirical distribution defined data converges number records grows large 
remainder section organized follows 
section explore asymptotic behavior bayesian scoring criterion section detail phase greedy algorithm show takes advantage asymptotic behavior identify optimal solution 
section discuss applicability algorithm non bayesian scoring criteria bayesian scoring criteria definition structure hypothesis di ers section 
discuss violations assumption ect solution quality algorithm 
asymptotic behavior bayesian scoring criterion recall section bayesian scoring criterion dag measures relative posterior relative log posterior hypothesis independence constraints precisely independence constraints generative distribution 
loss generality express bayesian scoring criterion sb relative log posterior sb log log prior probability marginal likelihood 
marginal likelihood obtained integrating likelihood function equation applied record unknown parameters model 
definition consistent scoring criterion set data consisting records iid samples distribution 
scoring criterion consistent limit grows large properties hold 
contains contain 
contain contains fewer parameters geiger heckerman king meek show models consider containing gaussian multinomial distributions curved exponential models 
details class model important results shows mild assumptions parameter prior bayesian scoring criterion consistent curved exponential models 
particular shows equation curved exponential models approximated laplace method integrals yielding sb log log denotes maximum likelihood values network parameters denotes dimension number free parameters number records chickering terms approximation known bayesian information criterion bic 
presence error means approaches infinity approximation di er true relative log posterior constant 
shown bic consistent 
furthermore easy show leading term bic grows conclude error term increasingly significant grows large equation consistent 
prior term depend data grow absorbed error term equation 
asymptotic behavior bayesian scoring criterion depends marginal likelihood term 
consistency bayesian scoring criterion leads fact bic decomposable practical property criterion call local consistency 
intuitively scoring criterion locally consistent score dag model increases result adding edge eliminates independence constraint hold generative distribution decreases result adding edge eliminate constraint 
formally definition 
definition locally consistent scoring criterion set data consisting records iid samples distribution 
dag dag results adding edge scoring criterion locally consistent properties hold 
pa 
pa lemma bayesian scoring criterion locally consistent 
proof proof follows fact limit criterion ranks models order bic 
bic decomposable increase score results adding edge dag increase score results adding edge dag parents 
choose particular pa pa adding edge results complete dag edge pair nodes 
complete dag imposes constraints joint distribution lemma follows immediately consistency bic 
lemma see long edges added dag eliminate independence constraints contained generative distribution bayesian scoring criterion favor addition 
dag contains distribution lemma guarantees deletion unnecessary edge favored criterion 
properties allow prove optimality greedy search algorithm section 
phase optimal greedy search algorithm section detail phase greedy search algorithm called greedy equivalence search ges meek 
results section version proof meek ges optimal limit large datasets 
optimal structure identification greedy search remainder section assume bayesian scoring criterion conjunction search algorithm 
point concentrated dag models discussion learning data 
find convenient switch equivalence class interpretation dag hypotheses bayesian scoring criterion order clearly ges algorithm 
definition follows dags equivalence class correspond hypothesis 
denote hypothesis corresponding identical hypotheses dags contained furthermore definition bayesian scoring criterion score dag model equivalence class relative log posterior bayesian scoring criterion defined equivalence classes evaluated dag member class 
sb denote score equivalence class bayesian scoring criterion 
proceeding show equivalence class perfect map generative distribution optimal solution 
proposition denote equivalence class perfect map generative distribution denote number records limit large sb sb proof suppose case exists higher scoring equivalence class scoring criterion consistent case contains furthermore perfect map follows independence map dag dag know theorem exists sequence covered edge reversals edge additions transforms covered edge reversal score remains lemma remains equivalence class 
edge addition number parameters dag necessarily increases scoring criterion consistent score necessarily decreases 
optimal edge additions transformation contradicts supposition suggested name ges greedy algorithm searches equivalence classes dags 
greedy search general proceeds step evaluating neighbor current state moving highest score doing improves score 
set neighbors state search defines connectivity search space 
ges consists phases 
phase greedy search performed equivalence classes particular connectivity equivalence classes 
local maximum reached second phase proceeds previous local maximum second connectivity 
second phase reaches local maximum equivalence class returned solution 
ee denote neighbors state phase ges 
words equivalence class ee dag add single edge results dag theorem alternative way describing ee follows 
dag dag 
definition perfect map equivalence classes obvious extension definition dags 
chickering ee exists sequence covered edge reversals followed single edge addition followed sequence covered edge reversals transform ee denote neighbors state second phase ges 
definition ee completely analogous ee contains equivalence classes obtained deleting single edge dags show particular dag show members 
show dags reachable single edge addition member union corresponding equivalence classes constitutes ee dags equivalent ee contains single equivalence class corresponding independence constraints hypothesis 
show dags reachable single edge deletion member union corresponding equivalence classes constitutes ee 
dag single member ee members ee 
ges described follows 
initialize state search equivalence class corresponding unique dag edges 
state search corresponds possible marginal conditional independence constraints 
phase algorithm repeatedly replace member ee highest score replacement increases score 
local maximum reached move second phase algorithm repeatedly replace member ee highest score 
algorithm reaches local maximum second phase terminates solution equal current state optimal structure identification greedy search prove ges correctly identifies optimal solution limit steps 
show local maximum reached phase algorithm contains generative distribution 
theorem show equivalence class reached second phase perfect map generative distribution 
proof phase ges relies fact generative distribution dag perfect 
distribution obey composition independence axiom described pearl contrapositive stated follows variable independent set set exists singleton element independent set lemma denote equivalence class results phase ges denote distribution data generated denote number records limit large contains proof suppose consider contains independence constraint independence constraints characterized markov conditions exist node pa set non descendants furthermore composition axiom holds exist singleton non descendant dependence holds 
lemma implies dag results adding edge cyclic definition higher score clearly ee contradicts fact local maximum 
theorem show second phase ges add independence constraints deleting edges equivalence class corresponding generative distribution reached 
lemma denote equivalence class results ges denote dag perfect distribution data generated denote number records limit large perfect map proof lemma know second phase algorithm commence current state search algorithm contains guaranteed continue contain remainder algorithm argument 
consider move ges state contain definition ee move corresponds edge deletion dag 
follows immediately fact score consistent deletion decrease score contradicting fact ges greedy 
complete proof assume algorithm terminates sub optimal equivalence class optimal equivalence class 
proposition know perfect map contains follows independence map dag dag know theorem exists sequence covered edge reversals edge additions transforms edge addition sequence assumption consider dag precedes edge addition sequence 
clearly ee fewer parameters conclude consistency scoring criterion local maximum yielding contradiction 
chickering discussion section discuss subtle issues ges algorithm consider happens assumptions violated 
note phase ges depend theorem 
fact phase needed get large sample optimality 
identify equivalence class contains generative distribution simply start complete equivalence class independence constraints move immediately second phase 
problem course starting complete model realistic domain number parameters model prohibitively large 
hope phase identify model simple possible 
exist generative distributions distribution independence constraints phase fact reach complete model order identify appropriate equivalence class hope practice phase reach local maximum reasonably sparse 
section see real world domains exactly happens 
optimality proofs previous section depend scoring criterion bayesian criterion 
lemma phase ges holds scoring criterion locally consistent means result holds consistent criterion decomposable limit recall section consistency decomposability get local consistency 
proof proposition optimal structure perfect respect generative distribution proof lemma second phase ges theorem compare score equivalence classes comparing scores particular dags equivalence classes 
criterion bayesian criterion approach clearly justified 
score equivalence needed large sample optimality ges 
particular long dags equivalence class number parameters property easy show models consider containing gaussian multinomial distributions proofs remain valid consistent criterion 
see consider result proposition dags contain generative distribution fewer parameters consistent dag scoring criterion 
dags equivalence class number parameters 
proof contain generative distribution dags equivalence class number parameters result follows immediately definition consistency 
proposition easy see proofs proposition lemma hold modification consistent scoring criterion regardless criterion score equivalent 
things get bit tricky scoring criterion score equivalent interested highest scoring dag model may identifying optimal equivalence class 
particular enormous number dags contained equivalence class search dags find best model 
depending particulars scoring criterion search problem may may di cult 
optimal structure identification greedy search example popular scoring criterion score equivalent bayesian scoring criterion 
cooper derive closed form criterion multinomial conditional distributions making assumptions network parameter priors 
turns dags equivalence class get di erent values marginal likelihood terms criterion 
strictly speaking means hypothesis corresponding dag score simply hypothesis independence constraints 
fact reason scoring criterion score equivalent cooper herskovits constrain conditional parameter priors dags come particular restricted family distributions 
researchers easy implement fast evaluate 
furthermore score di erences members equivalence class typically small compared score di erences members di erent equivalence classes 
result researchers criterion identify dag interpret result mean algorithm identified equivalence class corresponding dag 
opposed accidental non score equivalence heckerman geiger chickering discuss bayesian scoring criterion learning causal networks 
case define hypothesis corresponding dag model assert addition independence properties generative distribution edge dag corresponds cause ect relationship 
turns resulting scoring criterion locally consistent described ges identify single equivalence class models search high scoring causal model 
real domains generative distribution dag perfect sense dag defined observables perfect 
case need refine definition hypothesis corresponding dag admitting hypotheses true 
relax hypothesis denote example assertion dag model fewest parameters represent joint distribution observables 
assumption exists dag defined set variables perfect map generative distribution observables subset composition axiom holds guaranteed limit identify independence map optimal hypothesis phase ges 
know second phase case resulting equivalence class minimal independence map optimal solution 
dag class remove edge contain generative distribution 
section explore potential problems dag perfect assumption applying ges algorithm real world data 
show section ges algorithm performs domains regardless large sample guarantees justified 

cient search space previous section provided theoretical justification ges algorithm proving limit large datasets algorithm identify optimal model 

technical di culty definition non equivalent dags satisfy conditions hypotheses mutually exclusive 
chickering result little importance search algorithm implemented reasonably cient manner 
point clear consider provably optimal search algorithm exhaustively enumerates evaluates possible structure number dags grows super exponentially number variables domain results perlman suggest number equivalence classes grows super exponentially algorithm practical importance small domains variables dags equivalence classes 
feasibility applying search algorithm practice depends complexity algorithm search space algorithm applied 
greedy search algorithm edges easy show total number search states visited ges domain variables exceed 
furthermore practice number states visited generally grows linearly greater concern simplicity algorithm complexity search space state visited greedy search algorithm need generate evaluate states reachable application single operator 
number neighbor states grows large neighbor state takes long evaluate simple greedy algorithm may terminate quickly 
chickering shows problem learning optimal structure bayesian scoring criterion np hard negative result suggests worst case connectivity search space algorithm encounters problem 
hope practice worst case scenario occur real world problems portion search space traversed ges sparse 
fact encounter portions search space dense search ciently choose consider heuristically selected subset candidate neighbors step albeit cost losing large sample optimality guarantee 
point density search space problem experiments performed including section 
section describe method ciently generating evaluating neighbors search state ges algorithm 
approach take builds chickering completed pdags described section represent states search operators defined algorithm search space equivalence classes ciently 
define search space corresponding phases ges algorithm section 
search space components 
set states 
representation scheme states 
set operators set states represents logical set solutions search problem representation scheme defines cient way represent states set operators search algorithm transform representation state optimal structure identification greedy search order traverse space systematic way 
phases ges correspond greedy search algorithm applied di erent search spaces di er set operators contain 
section states ges connectivity search space phases defined 
particular states search equivalence classes dags neighbors particular state ee ee depending ges second phase respectively 
furthermore completed pdags described section represent states search 
remains defining search space implementation operators 
state search represented completed pdag define sets operators define connectivity phases ges 
definitions pair nodes pdag neighbors connected undirected edge adjacent connected undirected edge directed edge 
definition insert non adjacent nodes subset neighbors adjacent insert operator modifies inserting directed edge directing previously undirected edge definition delete adjacent nodes connected subset neighbors adjacent delete operator modifies deleting edge directing previously undirected edge directing previously undirected edge insert operators implement connectivity phase ges delete operators implement connectivity second phase ges 
denote set argument insert operator node set tail node new structure result operator 
similarly delete operator node set head node new structure 
applying operator completed pdag resulting pdag necessarily completed 
may need convert pdag corresponding completed pdag representation resulting equivalence class accomplished steps extracting consistent extension completed pdag constructing completed pdag dag 
appendix provide implementation chickering steps conversion algorithm 
completed pdag results operator admits consistent extension say operator valid 
say operator valid allow application search space 
algorithm appendix converts pdags completed pdags takes time worst case number edges pdag maximum number parents node potentially problem domains chickering large number variables 
show ges operators search state generated evaluated ciently needing construct representation resulting states 
time completed pdag representation state needs constructed ges moves state best neighbor state identified current state replaced neighbor state 
furthermore algorithm depend number records data applied infrequently compared number times operators evaluated contribution run time ges insignificant 
easily testable conditions insert delete operators ensure valid 
define conditions need define semi directed path 
directed path edges may undirected 
formally definition semi directed path pdag path edge undirected directed away theorems corresponding corollaries demonstrate determine ciently insert delete operator valid score operator 
simplified notation results easy read pa denotes parents node completed pdag representation current state 
pa pa shorthand pa pa respectively 
na denote set nodes neighbors node adjacent node current state 
proofs results summarized table appendix theorem completed pdag denote result applying insert operator exists consistent extension adding edge results consistent extension 
na clique 
semi directed path contains node na corollary score equivalent decomposable scoring criterion increase score results applying valid operator insert completed pdag na pa na pa theorem completed pdag contains denote result applying operator delete exists consistent extension contains edge deleting edge results consistent extension na clique 
corollary score equivalent decomposable scoring criterion increase score results applying valid operator delete completed pdag na pa na pa optimal structure identification greedy search table necessary su cient validity conditions local change score operator operator validity tests change score insert na clique semi directed path contains node na na pa na pa delete na clique na pa na pa final step implementation ges method generate candidate operators move 
note majority operators step algorithm remain valid score step algorithm 
need generate re generate set operators corresponding pair nodes obvious approach definition definition directly generate operators regard validity conditions test validity conditions 
procedure detailed paragraph 
phase ges nodes adjacent corresponding set operators 
pair corresponding operators need generated define set neighbors adjacent denote power set contains possible subsets test validity possibly score result insert 
second phase ges nodes adjacent corresponding set operators 
pair corresponding operators need generated undirected edge directed edge define set neighbors adjacent denote power set test validity possibly score result delete 
set nodes size elements power set follows feasibility implementation ges large degree depend number neighbors nodes completed pdags encounter node neighbors may simply operators test 
particular phase algorithm order generate operators pair non adjacent nodes implementation slow neighbors adjacent similarly second phase algorithm implementation may slow adjacent neighbors adjacent chickering number tricks apply generate ciently candidate operators corresponding pair nodes 
consider validity condition insert operator table set na clique 
test fails set fail contains careful gain enormous savings generating candidates know valid 
similar optimization delete operator save cost performing validity test 
particular validity test delete operator passes set know pass set contains subset 
save time noting second validity condition insert operator passes pass contains note careful avoid generating distinct operators result neighbor state 
example delete delete result state need generated 
similar result insert operator set empty chickering parents insert insert result state 
unfortunately worst case exponential number valid operators particular state search 
mentioned prune neighbors heuristically situation search practical 
example choose search equivalence classes member dags upper bound number parents node 
case need consider polynomial number structure sets pair nodes 
experiments performed including section encounter domain ges encounters state neighbors 
evident simplicity validity conditions table number ways ciently update regenerate valid operators step ges 
example consider set insert operators corresponding nodes suppose operators generated scored step phase ges want know operators remain valid score applying operator 
table see neighbors changed validity condition hold previously valid operators adding edges phase clique remain clique 
furthermore parents node changed need check second validity condition assuming holds score operator higher best score seen far know regardless operator valid chosen step 
note obvious optimization ges alternative search algorithms described section cache away previously computed local scores corresponding node 
transition second phase ges operators scored explicit call scoring function 

operators defined edge undirected note definition delete symmetric optimal structure identification greedy search 
experimental results section evaluate ges algorithm synthetic real world data 
section synthetic data evaluate ges terms algorithm identify generative structure datasets finite 
section real world data evaluate solution quality total search time ges applied real data 
experiments compare ges alternative greedy search algorithms 
algorithm call space search traditional dag space greedy algorithm considers adding removing reversing edges step 
second search algorithm call space search greedy search equivalence classes operators defined chickering valid insert operators empty structures created contain previously undirected edges valid delete operators set empty directed edge reversed result pdag admits consistent extension length path undirected edges adjacent edges directed result pdag admits consistent extension 
shown chickering operators tested scored ciently 
bayesian bdeu scoring criterion discrete variables derived heckerman 
experiments 
bdeu criterion uses parameter prior uniform means requires prior equivalence sample size structure prior specify 
experiments prior equivalent sample size structure prior number free parameters dag 
denote number configurations parent set pa denote number states variable version bdeu criterion experiments log ij ijk ijk number records pa jth configuration ij ijk non bayesian constraint parameter needs corresponding sample size 
note equation scoring criterion decomposable 
synthetic data experiments experiments synthetic data generated datasets various sample sizes gold standard bayesian network known structure parameters 
order connectivity gold standard realistic constructed generative network follows 
took real world dataset dataset described detail section consisting roughly records domain discrete valued variables ran space search algorithm identify local maximum 
performed random space edge operations additions deletions reversals local maximum resulting structure defined edges gold standard 
parameterized gold standard sampling conditional multinomial parameters uniform dirichlet distribution 
chickering synthetic data experiments described follows 
generated random gold standards described considered sample sizes increments samples 
sample size created dataset appropriate number records gold standards 
sampled dataset learned bayesian networks greedy search algorithms checked networks equivalent gold standard 
contains results experiments 
plots algorithms number learned networks equivalent gold standard function sample size 
sample size number equivalent gold standard ges space space number learned networks equivalent generative structure function sample size 
see ges proved superior competing algorithms tasked identifying generative structure 
surprising models identified space equivalent generative structure identified space explanation virtue generating gold standards space may biasing experiment favor space 
gauge complexity domain recorded number edges number parameters maximum number parents gold standard models 
averages measurements respectively demonstrate experiment optimal equivalence classes sparse 
optimal structure identification greedy search real world data experiments real world datasets experiments 
datasets assume values missing random 
particular treat missing distinct discrete state 

microsoft web training data dataset available anonymous ftp uci machine learning repository contains instances users visiting www microsoft com web site day 
user data contains variable indicating user visited areas site 
popular areas sample users 

nielsen nielsen dataset contains data television watching behavior period 
data available courtesy nielsen media research 
data records user watched minutes network tv shows time period 
users study television shows 
popular shows experiments 

eachmovie eachmovie dataset consists viewer ratings movies 
data collected month period 
ratings popular movies sample viewers 
rating discrete variable missing provided integer 

dataset contains demographic internet data individuals month january 
internet variables experiments variables indicate category web site visited 

united states congressional voting records dataset contains congressional voting records representatives voting issues available anonymous ftp uci machine learning repository 
votes valued unknown 
representative political party dataset typically classification setting predict political party representative voting record 

mushroom mushroom dataset available anonymous ftp uci machine learning repository contains physical characteristics mushrooms mushroom poisonous edible 
physical characteristics mushroom discrete 
experiments considered variants ges algorithm deemed better suited real world domains 
inclusion variants motivated chickering number observations 
running phase ges case increase score applying insert operators words state reached phase local maximum respect phase operators 
second phase ges best delete operator better score best insert operator best insert operator increased score note situation impossible limit 
noticed practice number structures induced sets best insert delete operators respectively cases zero 
restrict size size get local maximum restrictions 
discussed section restriction reduces number operators need evaluate speed implementation 
ran experiments specific variants ges 
variant call ges simply applies ges repeatedly phase phase increases score 
ges ges experiments guaranteed find solution terms score ges 
second variant call ops performs greedy search insert operators delete operators step 
third variant call ops identical ops consider insert delete operators respectively 
results experiments table table 
table report dataset score maximum reached algorithm 
table report dataset total learning time seconds algorithm 
table scores model selected algorithms 
dataset ges ops ops space space nielsen eachmovie mushroom table total learning time seconds algorithm 
dataset ges time ops time ops time space time space time nielsen eachmovie mushroom optimal structure identification greedy search surprising see table algorithms performed terms resulting score 
ges variants identified model score better competing approaches believe di erences significant 
closer examination models interesting properties 
eachmovie algorithms resulted local maximum model contained compelled edges 
mushroom algorithms space resulted local maximum model contained compelled edges 
datasets ges variants traversed set states resulted local maximum 
models learned reasonably sparse 
local maxima experiments identified applying operators create structures algorithms essentially traversed set states 
expect domains complicated dependencies ges algorithms identify di erent models competing algorithms 
results section reason hope algorithms identify better models 
table see running times ges variants generally larger running times alternative algorithms 
investigate source increase time recorded number times local scoring function called algorithms 
table report total learning time milliseconds divided number times evaluation function called see datasets time roughly constant algorithms 
table total learning time milliseconds divided number calls evaluation function algorithm 
dataset ges time ops time ops time space time space time nielsen eachmovie mushroom cache local scores nodes searches operator re score due change local connectivity state requires average single call scoring function 
times table roughly equal time spent operator re score 
time constant conclude increase time due entirely additional operators need score re score step 
furthermore conclude validity tests insert delete operators 
chickering compared space space sample full datasets winning algorithm di erent results 
chickering cient time traverse search space ges variants dominated time spent scoring operators 

proved called meek conjecture showed result leads asymptotically optimal phase greedy search algorithm ges originally proposed meek 
provided new implementation search space ges applied operators algorithm scored ciently local functions nodes domain 
synthetic data demonstrated ges algorithm identify generative structure data ges algorithm superior regard greedy search alternative search spaces 
applied ges real world datasets saw solution quality roughly alternative greedy approaches 
time evaluation function call competing algorithms larger number neighbors state ges algorithm resulted slightly slower run times 
interesting extension investigate large sample optimality guarantees ges variant ges generative structure dag defined observables 
discussed section generative structure dag includes hidden variables composition axiom independence holds observables phase ges lead independence map optimal model 
know result second phase algorithm minimal independence map say stronger 
chickering meek consider situations composition axiom guaranteed hold investigate optimality guarantees ges situations 
unfortunate real world dataset experiments provide test bed algorithms 
suggest search strategy apply faced real data run simple fast dag greedy algorithm 
resulting model simple compelled edges edges probably able find better solution sophisticated algorithm 
model reasonably complicated hand may try apply ges variants 
recall ops algorithm section considers insert delete operators simultaneously 
interesting extension implement algorithm considers addition operators extra operators space algorithm chickering connect states adjacent ops space operators edge reversal operator operator structure directing undirected edges 
extension increase number evaluations need performed state combined search algorithm perform better 
acknowledgments special michael perlman revived interest meek conjecture long ago months pursuit proof 
discussions michael optimal structure identification greedy search perlman milan tomas robert steve proved extremely useful am grateful 
chris meek initially introduced conjecture helpful discussions 
provided useful comments earlier drafts include remco david heckerman rich neapolitan anonymous reviewers 
appendix detailed proof theorem appendix provide detailed proof theorem 
theorem immediate consequence lemma demonstrates correctness algorithm operation 
results proved properties separation criterion 
criterion detailed pearl test certain independence constraints implied dag model 
particular nodes said separated dag set nodes active path standard definition active path simple path node path converging arrows descendant converging arrows simple mean path passes node twice 
simplify proofs equivalent definition active path need simple node path converging arrows converging arrows words allowing segment included path virtue descendant belonging require path include sequence edges descendant back 
readers familiar celebrated bayes ball algorithm shachter testing separation expanded definition active path simply valid path ball take formally definitions 
definition collider denote path node called collider position path path contains converging arrows definition active path path dag active conditions hold 

element collider position 
element collider position direction terminal edge edge encountered traversal path active path important determining append active paths third active path 
say path terminal edge incident oriented chickering 
similarly path terminal edge incident oriented path endpoint say path lemma demonstrates create active path simply appending active paths 
lemma active path active path path concatenation active path proof paths junction collider 
furthermore concatenation satisfies conditions definition 
example consider dag shown assume 
follows lemma paths active concatenation active 
example dag active path 
proofs follow extensive lemma implicitly simplify presentation 
results example prove existence active path nodes showing active path node active path active path conclude properties active path need awkward argument applying lemma twice obvious lemma 
lemma corollaries provide main tools prove algorithm apply edge operation correct 
particular results expose properties active paths hold light edge addition dag 
lemma dag dag results adding edge active path active path properties hold 
contains edge 

endpoint active path endpoint optimal structure identification greedy search 
active paths endpoints active path endpoint active path endpoint 
active paths endpoints active path endpoint active path endpoint parents proof follows immediately path active follows path active 
follows fact sub path active path nodes definition active 
prove considering traversals consider traversal edge traversed time 
similarly consider traversal starting show traversals ends establish exists active path endpoints suppose contrary traversals node edge traversals append form active path violates property 
similarly follows edge traversals edge traversals form active path violation property 
loss generality assume active path property follows immediately traversal ended sub path active 
prove property assume traversal ended property follows immediately 
edge traversal node parent conclude active path consider parent form active path appending active path active path corollary dag dag results adding edge dag active path identified properties lemma corresponding active path endpoints proof follows immediately second corollary convenient main proof additions algorithm edges node sink independence map 
corollary dag dag results adding edge dag sink node contains edge active path active path active path chickering proof corollary property know active path endpoints active path endpoint parent loss generality assume active path preconditions corollary follows parent parent active path parent possibility 
consequently construct active path connecting active paths endpoints active path lemma key idea step algorithm allows remove nodes input dags order simplify problem 
lemma dags containing node sink dags pa pa denote subgraphs respectively result removing node coming edges 
proof case assume show active path exist establishing active path appears active assumption corresponding active path furthermore subgraph appear exist conclude active proving result 
remainder proof assume appears 
suppose implies occurs collider position 
consider traversal occurrence collider traversal 
sub path active path members definition active active identified conclude exists active path pass active path pass clearly paths active assumption follows exist corresponding active paths sub graph active furthermore path contains active 
means append active path create active path suppose sink node time occur endpoint 
loss generality assume degenerate case result follows trivially assume edge 
sink know edge denote edge 
clearly means active path include means path active assuming exist active path parent sets identical optimal structure identification greedy search follows edge exists constitutes active path appended create active path 
case assume show active path exist establishing active path exist assume loss generality subgraph active assumption follows exists corresponding active path sink node path active ready main proof need simple intermediate results proved verma pearl 
lemma verma pearl nodes adjacent dag set pa pa active path proposition dags edge edge proof follows immediately lemma fact edge constitutes active path include lemma dags contains structure contains structure adjacent proof suppose case contain structure adjacent proposition know adjacent supposition parent implies lemma exists conditioning set includes node include node node active path exists path active conditioning set includes excludes including set contradicts fact lemma proven 

lemma recall definition de included set 
lemma suppose node unique maximal element set de proof suppose maximal elements nodes descendants active path contain node de definition parent de lemma pa pa constitutes precisely set renders independent contradicting fact prove algorithm apply edge orientation correct 
lemma dags denote graph returned algorithm find edge operation 
dag operation edge reversal edge covered chickering proof step algorithm input dags simplified repeatedly removing common sink nodes parents dags 
denote simplified versions input dags 
follows immediately lemma find edge modification independence map resulting dag independence map dag results edge modification furthermore sink nodes removed covered edge reversal corresponds covered edge reversal concentrate identifying edge modify simplified problem 
notational simplicity denote simplified versions input dags remainder proof 
know step nodes conclude nodes removed step contradicting fact node identified step exist 
relevant portions dags edge addition step resulting edge addition children step simply choose node parent parent see return dag results adding know exists removed step 
consider active path active recall lemma property element 
sink know endpoint member endpoint know corollary property active path endpoint appending path edge identified active path follows immediately corollary active path conclude returned algorithm step get step child apply somewhat complicated rule choosing particular child concentrate see 
dag identify set de descendants turn attention dag identify maximal element set de respect lemma maximal element necessarily unique sink node follows descendant maximal child node step defined 
step algorithm covered lemma dag results reversing covered edge equivalent edge covered definition covered edge optimal structure identification greedy search selection node step example dag corresponding dag nodes including members de parent parent parent parent cases tested step step respectively 
relevant portion dags edge addition step results edge addition step parent parent return dag results adding see 
note directed path parent child addition create cycle 
see remains independence map consider active path active recall lemma property include edge case replace occurrence edge path construct active path conclude corollary property active path endpoint child connect active paths property know paths ends construct active path know corollary property active path endpoints active path endpoint parent loss generality assume active path path ends establish active path connecting paths active chickering path assume path ends node parent case adjacent sink parent argument adjacent structure adjacency established lemma adjacent adjacency established proposition 
parent construct active path connecting paths active path conclude returned algorithm step 
de de edge addition step example dag dag resulting edge addition corresponding dag step reached know parent parent return dag results adding edge see 
argue edge addition form cycle 
directed path node path child equal ancestor means ancestor contradicts fact maximal child descendant 
active path active recall lemma property include edge demonstrate corresponding active path consider case sink know include structure exists conclude lemma fact sink node edge exist corollary follows active path remainder proof consider case case member de replace occurrence edge active path 

descendant construct active path show active paths endpoint node chosen step algorithm 
lemma property active path endpoint descendant descendants including append active paths directed path optimal structure identification greedy search construct active paths endpoints follows exists corresponding active paths 
active path endpoints identify directed path endpoints element easily identify active path consider shortest directed path 
path reaches endpoint directed path constitutes active path endpoint means append active path endpoint create desired path 
path reaches element append directed path path opposite direction create active path endpoints 

connect active paths endpoints create desired path 
remains show descendant endpoints element turn attention back active path consider segment starts edge continues direction edge path ends edge encountered direction 
clearly directed path immediately ends endpoint member case node descendant unique lemma maximal element de follows descendant descendant conclude active path returned algorithm step prove main result state 
theorem pair dags number edges opposite orientation number edges exist orientation exists sequence edge reversals additions properties 
edge reversed covered edge 
reversal addition dag 
reversals additions proof properties follow immediately lemma simply apply edge operation algorithm find edge operation show algorithm called times 
covered edge reversed algorithm know see step reversal edge orientation reduced exactly remains constant sum reduced exactly 
edge added follows lemma independence map resulting dag proposition necessarily reduced case remains constant increased sum reduced 
chickering appendix operator proofs appendix provide proofs main results section 
show conditions table necessary su cient insert delete operator valid second phase respectively ges algorithm 
immediate corollary proof operator type increase score results 
appendix organized follows 
appendix provide numerous preliminary results majority proved chickering 
appendix provide main results insert delete operators respectively 
preliminary results main proofs appendix rely intermediate results proven chickering 
section enumerate intermediate results 
proposition characterizes conditions structure exists pdag 
proposition denote pair pdags 
structure conditions hold pa pa adjacent proof follows immediately definition structure 
results show edge status compelled reversible edges pdag constrain status edges 
edge compelled reversible pdag corresponding edge compelled reversible consistent extension pdag 
proposition chickering pdag admits consistent extension contains compelled edge edge directed undirected node adjacent edge compelled 
proposition chickering pdag admits consistent extension directed path consisting compelled edges 
edge compelled lemma chickering nodes form clique size pdag edges clique reversible third edge reversible 
lemma chickering directed edge completed pdag parent node reachable undirected edges 
lemma chickering nodes undirected clique size undirected component completed pdag denote total ordering nodes exists consistent extension edge orientations nodes consistent edge neighbor oriented optimal structure identification greedy search final set results properties semi directed paths see definition completed pdag 
lemma chickering completed pdag contains path exists directed edge path exists directed path corollary chickering completed pdag 
contains path consisting intermediate nodes contained set shortest semi directed path intermediate nodes contained consists exactly consecutive segments segment consists entirely undirected edges second segment consists entirely directed edges 
corollary chickering completed pdag 
contains path consisting intermediate nodes contained set shortest semi directed path intermediate nodes contained edge connects pair non consecutive nodes path 
lemma completed pdag contains semi directed path edge shortest semi directed path 
edge directed consistent extension directed path proof suppose edge directed away path 
corollary know edge reversible edge precedes 
corollary adjacent structure yielding contradiction 
conditions table include checking set neighbors node completed pdag clique 
follows immediately lemma set neighbors clique set neighbors clique undirected edges 
understood sections follow clique mean clique undirected edges 
say reversible parent pdag dag edge reversible 
similarly say compelled parent compelled 
analogous definitions reversible child compelled child 
insert operator section show conditions table necessary su cient determining insert operator valid phase ges 
particular show theorem conditions hold extract consistent extension completed pdag adding single directed edge results consistent extension completed pdag results applying operator 
part proof constructive identify specific add edge 
increase score results operator follows immediately 
need result chickering lemma completed pdag consistent extension denote completed pdag results applying operator insert clique consisting nodes neighbors adjacent denote graph results adding adjacencies set structures set reversible parents adjacent equal proof clearly adjacencies 
consistent extension di erence structures resulted modification completed pdag dag 
proposition fact insert operator reverse directed edges easy see set structures precisely set structures words set structures lose result performing insert operator set lose result adding precisely ones tails adjacent result edge addition 
establish result showing set structures gain result modifications set reversible parents equal clique clique undirected edges know lemma parent node parent node implies structure includes previously undirected edge edge 
follows set structures form member parent adjacent easy see set structures form parent adjacent consider set parents adjacent clearly set consists union compelled parents adjacent reversible parents adjacent set precisely set parents adjacent lemma follows 
theorem completed pdag denote result applying insert operator exists consistent extension adding edge results consistent extension 
na clique 
semi directed path contains node na proof condition implies clique follows lemma need identify consistent extension properties reversible parents adjacent precisely nodes directed path na clique neighbor nodes conclude na clique 
conclude lemma exists consistent extension reversible parents precisely nodes na nodes na adjacent satisfied remains shown directed path suppose exist path 
clearly optimal structure identification greedy search directed path corresponding semi directed path second condition lemma path pass node na parents yielding contradiction cyclic 
conclude satisfied 
suppose na clique nodes set adjacent 
consistent extension corresponding edges directed away contain structure loss generality assume edge na know edge directed contain structure implies graph results adding cyclic 
result adding include structure structure exists result insert operator consistent extension suppose exists semi directed path pass node na consider shortest path 
edge directed away conclude lemma directed path insert operator results converting resulting completed pdag representation pdag contains cycle pdag admit consistent extension 
edge path 
assumption na contains edge contains structure contains edge conclude lemma directed path consequently cyclic 
corollary score equivalent decomposable scoring criterion increase score results applying valid operator insert completed pdag na pa na pa proof follows immediately subtracting score score defined part theorem denotes dag results adding edge delete operator section show conditions table necessary su cient determining delete operator valid second phase ges 
particular show theorem conditions hold extract consistent extension completed pdag deleting single directed edge results consistent extension completed pdag results applying operator 
part proof constructive identify specific delete edge 
increase score results operator follows immediately 
need result chickering lemma completed pdag consistent extension includes edge denote completed pdag results applying operator delete consists nodes neighbors adjacent denote graph results deleting adjacencies structures set reversible children children equal proof clearly adjacencies 
consistent extension di erence structures resulted modification completed pdag dag 
proposition fact delete operator reverse directed edges easy see set structures precisely set structures particular set structures lose simply structures contain edge establish result showing set structures gain result modifications set reversible children children equal proposition definition delete operator immediately conclude set structure characterized structures forms edges exist structure formed adjacency removed zero edges directed delete operator exactly nodes demonstrate structures form occur 
loss generality assume member definition delete operator know directed edges incident directed 
structure exist adjacency change result delete conclude edge undirected proposition impossible conclude exist clearly set structures gained result deleting characterized structures form case simply common child lemma follows demonstrate common children precisely common compelled children unioned reversible children suppose exists child common compelled child compelled 
compelled conclude lemma compelled 
implies proposition compelled yielding contradiction 
theorem completed pdag contains denote result applying operator delete exists consistent extension contains edge deleting edge results consistent extension na clique 
optimal structure identification greedy search proof suppose na clique 
definition na follows na clique 
exists na clique know case conclude lemma extract consistent extension contains edge directed edges consistent ordering na remaining nodes 
clearly reversible children adjacent precisely nodes furthermore contains edge child adjacent child conclude lemma result deleting dag adjacencies structures dag dag lemma follows 
suppose exists consistent extension contains edge deleting edge results consistent extension lemma conclude set reversible children adjacent precisely set element na parent pair parents adjacent constitute structure contradicts fact edges reversible 
corollary score equivalent decomposable scoring criterion increase score results applying valid operator delete completed pdag na pa na pa proof follows immediately subtracting score score defined part theorem denotes dag results deleting edge appendix converting completed pdag section defined insert delete operators local modifications completed pdag representation current state 
described section result applying operator completed pdag pdag necessarily completed 
appendix describe conversion algorithm converts pdag completed pdag representation corresponding equivalence class 
recall conversion algorithm light results section need applied state visited ges evaluate ciently adjacent states greedy search conversion 
conversion algorithm fact combination algorithms described detail chickering 
algorithm refer pdag takes input pdag representation equivalence class outputs dag member class 
second algorithm refer dag takes input bayesian network structure outputs completed pdag representation equivalence class structure belongs 
clearly implement desired conversion calling pdag dag pdag results applying chickering operator calling dag consistent extension obtained algorithm 
consider simple implementation pdag dag due dor 
nx denote neighbors node pdag create dag contains directed edges edges 
repeat procedure select node going edges nx non empty nx pa clique 
admits consistent extension node guaranteed exist 
undirected edge incident insert directed edge remove incident edges continue node 
algorithm terminates nodes deleted algorithm order edges input dag output dag labeled total order edges 
perform topological sort nodes 
set 
unordered edges 
lowest ordered node unordered edge incident 
highest ordered node ordered 
label order 
algorithm produce total ordering edges dag 
algorithm algorithm label edges 
version dag provide originally derived chickering asymptotically optimal average 
algorithm labels edges dag compelled reversible labeling trivial construct corresponding completed pdag 
step algorithm define total ordering edges dag 
simplicity step separate procedure listed 
topological sort refers total ordering nodes ancestor precede ordering 
avoid confusion ordered nodes ordered edges capitalized node edge 
show algorithm chickering labels edges 
andersson madigan perlman 

characterization markov equivalence classes acyclic digraphs 
annals statistics 
buntine 

guide literature learning probabilistic networks data 
ieee transactions knowledge data engineering 
optimal structure identification greedy search algorithm label edges input dag output dag edge labeled compelled reversible 
order edges algorithm order edges 
label edge unknown 
edges labeled unknown 
lowest ordered edge labeled unknown 
edge labeled compelled 
parent 
label edge incident compelled 
goto 

label compelled 
exists edge parent 
label unknown edges incident compelled 

label unknown edges incident reversible algorithm label edge dag compelled reversible leads immediate implementation dag 
chickering 

transformational characterization bayesian network structures 
hanks besnard editors proceedings eleventh conference uncertainty artificial intelligence pages 
morgan kaufmann 
chickering 

learning bayesian networks np complete 
fisher lenz editors learning data artificial intelligence statistics pages 
springer verlag 
chickering 

learning equivalence classes bayesian network structures 
journal machine learning research 
chickering meek 

finding optimal bayesian networks 
darwiche friedman editors proceedings eighteenth conference uncertainty artificial intelligence pages 
morgan kaufmann 
cooper herskovits 

bayesian method induction probabilistic networks data 
machine learning 
dor 

simple algorithm construct consistent extension partially oriented graph 
technical report cognitive systems laboratory ucla computer science department 
chickering geiger heckerman king meek 

stratified exponential families graphical models model selection 
annals statistics 
perlman 

enumerating markov equivalence classes acyclic digraph models 
goldszmidt breese koller editors proceedings seventeenth conference uncertainty artificial intelligence pages 
morgan kaufmann 


choice model fit data exponential family 
annals statistics 
heckerman 

tutorial learning bayesian networks 
technical report microsoft research 
heckerman geiger chickering 

learning bayesian networks combination knowledge statistical data 
machine learning 
je reys 

theory probability 
oxford university press 
bouckaert 

characterizing inclusion bayesian networks 
breese koller editors proceedings seventeenth conference uncertainty artificial intelligence pages 
morgan kaufmann 
bouckaert 

inclusion problem 
technical report academy sciences czech republic institute information theory automation 
meek 

causal inference causal explanation background knowledge 
hanks besnard editors proceedings eleventh conference uncertainty artificial intelligence pages 
morgan kaufmann 
meek 

graphical models selecting causal statistical models 
phd thesis carnegie mellon university 
pearl 

probabilistic reasoning intelligent systems networks plausible inference 
morgan kaufmann san mateo ca 
shachter 

bayes ball rational determining irrelevance requisite information belief networks influence diagrams 
cooper moral editors proceedings fourteenth conference uncertainty artificial intelligence pages 
morgan kaufmann 
spirtes glymour scheines 

causation prediction search 
springer verlag new york 
verma pearl 

equivalence synthesis causal models 
henrion shachter kanal lemmer editors proceedings sixth conference uncertainty artificial intelligence pages 

