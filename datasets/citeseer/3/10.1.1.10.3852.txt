fundamenta informaticae ios press watershed transform definitions algorithms parallelization strategies jos roerdink arnold meijster institute mathematics computing science university groningen box av groningen netherlands email roe cs rug nl meijster rc rug nl 
watershed transform method choice image segmentation field mathematical morphology 
critical review definitions watershed transform associated sequential algorithms discuss various issues cause confusion literature 
need distinguish definition algorithm specification algorithm implementation pointed 
various examples illustrate differences watershed transforms different definitions implementations 
second part surveys approaches parallel implementation sequential watershed algorithms 
keywords mathematical morphology watershed transform watershed definition sequential algorithms parallel implementation 

grey scale mathematical morphology watershed transform originally proposed improved method choice image segmentation 
generally spoken image segmentation process isolating objects image background partitioning image disjoint regions region homogeneous respect property grey value texture 
watershed transform classified region segmentation approach 
intuitive idea underlying method comes geography landscape topographic relief flooded water watersheds divide lines domains attraction rain falling region 
alternative approach imagine landscape immersed lake holes local minima 
basins called catchment roerdink meijster watershed transform basins fill water starting local minima points water coming different basins meet dams built 
water level reached highest peak landscape process stopped 
result landscape partitioned regions basins separated dams called watershed lines simply watersheds 
simulating process image segmentation approaches may finds basins watersheds set complement computes complete partition image basins subsequently finds watersheds boundary detection 
explicit expression watershed transform denote labelling image points catchment basin unique label special label distinct labels catchment basins assigned points watersheds 
example simple image watershed transform fig 

note passing practice apply watershed transform original image morphological gradient 
produces watersheds points grey value discontinuity commonly desired image segmentation 
difficulties intuitive concept leaves room various formalizations 
different watershed definitions continuous functions briefly reviewed section 
main interest digital images freedom define watersheds discrete case unique definition path drop water follow 
sequential algorithms developed compute watershed transforms see survey 
divided classes specification recursive algorithm vincent soille distance functions meyer 
context parallel implementations exists notable tendency introducing definitions watershed transform enabling easier parallelization 
examples section 

examples watershed segmentation immersion see definition 
synthetic image watershed transform natural image watershed transform 
different basins indicated distinct grey values 
impression current literature watershed algorithms reader great confusion 
uncertain exactly definition watershed transform 
definition takes form specification roerdink meijster watershed transform algorithm 
careful distinction algorithm specification implementation cases lacking 
separation correctness assessment proposed algorithms impossible 
specification implementation adhere 
ad hoc modifications eliminate undesirable consequences watershed definition changes tend create new problems solving old 
optimizations introduced greater speed memory reduction process change outcome algorithm may go undetected case natural images 
questions purely academic algorithm widely medical image processing unwanted side effects avoided 
purpose twofold 
part critical review definitions watershed transform associated sequential algorithms emphasizing distinction definition algorithm specification algorithm implementation 
second part surveys main current approaches parallel implementation watershed algorithms 
essential difficulty lies fact watershed transform local concept 
decision pixel belongs basin purely local considerations 
problem algorithms result depends order pixels treated execution 
sequential case resolved fixing scanning order raster scan deterministic result obtained 
parallel implementation longer true outcome depends relative time instants different processors treat pixels unpredictable case asynchronous processors 
emphasis second part methodology trends current research 
point difficulties design parallel watershed algorithms 
efficiency results quoted extent order give reader idea currently achievable 
depth comparison large body results obtained different watershed algorithms different architectures different programming methodologies scope 
number issues concerning watershed transform discussed explicitly 
mention 
question accuracy watershed lines 
usually mind result close approximation continuous case 
digital distances playing role watershed calculation approximate euclidean distance 
chamfer distances efficient way achieve accurate watershed lines 
second watershed method original form produces severe oversegmentation image small basins produced due local minima input image see fig 

approaches exist remedy markers hierarchical watersheds marker watershed algorithms studied 
third consider dedicated hardware architectures fast computation watershed transforms related operations see 
architectures tend solve restricted class image processing tasks interest medium level image processing general purpose parallel architectures 
organization follows 
section preliminaries 
section presents definitions watershed transform continuous discrete case 
sequential watershed algorithms reviewed section 
section contains survey parallelization strategies watershed transform 
drawn section 
roerdink meijster watershed transform 
preliminaries section contains background material graphs see digital images 

graphs graph consists set vertices nodes set pairs vertices 
un directed graph set consists un ordered pairs 
directed graph write digraph 
unordered pair called edge ordered pair arc edge arc said incident adjacent vertices conversely called incident call neighbours 
set vertices neighbours denoted ng 
path length graph vertex vertex sequence vertices 
pi pi 
length path denoted length 
path called simple vertices distinct 
exists path vertex vertex say reachable denoted undirected graph connected vertex reachable vertex 
graph called subgraph elements incident vertices 
connected component graph maximal connected subgraph connected components partition vertices digraph path 
forms cycle path contains edge 
vertices cycle distinct speak simple cycle 
self loop cycle length 
undirected graph path 
forms cycle 
distinct 
graph cycles acyclic 
forest undirected acyclic graph tree connected undirected acyclic graph 
directed acyclic graph abbreviated dag 
weighted graph triple weight function defined edges 
valued graph triple weight function defined vertices 
level component level valued graph connected component set nodes value boundary level component level consists neighbours value different lower boundary set neighbours value smaller interior consists points boundary 
descending path path value increase 
denote set descending paths starting node node 
regional minimum minimum short level level component points neighbours value lower valued graph called lower complete node minimum neighbouring node lower value 

digital grids digital grid special kind graph 
usually works square grid vertices called pixels 
finite size number points set pixels endowed graph structure domain roerdink meijster watershed transform certain subset defining connectivity 
usual choices connectivity point edges horizontal vertical neighbours connectivity point connected horizontal vertical diagonal neighbours 
connected components set pixels defined applying definition graphs 
distances neighbouring nodes digital grid introduced associating nonnegative weight edge 
way weighted graph obtained 
distance non neighbouring pixels defined minimum path length paths depends graph structure grid connectivity 

digital images digital grey scale image triple graph usually digital grid function assigning integer value binary image takes values say foreground background 
called grey value altitude considering topographic relief 
range grey scale image takes set integers assumption 
plateau flat zone grey value level component image considered valued graph connected component pixels constant grey value threshold set level 
geodesic distance th 
points geodesic distance da minimum path length paths continuous case read infimum minimum 
subset define da da 
partitioned connected components bi 
geodesic influence zone set bi defined bi da bi da bj set union geodesic influence zones connected components bi complement set called skeleton influence zones consists points equidistant sense geodesic distance nearest connected components digital grids may points 
binary image domain defined identifying set foreground pixels 
roerdink meijster watershed transform 
definitions watershed transform section introduce definitions watershed transform may viewed generalization skeleton influence zones grey value images 
start continuous case followed definitions digital case algorithmic definition vincent soille definition topographical distance meyer 
discussion algorithms postponed section 

watershed definition continuous case watershed definition continuous case distance functions 
depending distance function may arrive different definitions 
restrict choices proposed 
assume image element space real twice continuously differentiable functions connected domain isolated critical points class morse functions forms example 
topographical distance points defined tf inf ds infimum paths smooth curves inside topographical distance point set defined tf mina tf 
path shortest tf distance path steepest slope 
motivates rigorous definition watershed transform 
definition 
watershed transform minima mk index set catchment basin cb mi minimum mi defined set points closer mi regional minimum mj cb mi mi tf mi mj tf mj watershed set points belong catchment basin cb mi 
label watershed transform mapping cb mi 
watershed transform assigns labels points different catchment basins uniquely labelled ii special label assigned points watershed roerdink meijster watershed transform 
watershed definitions discrete case problem arises digital images occurrence plateaus regions constant grey value may extend large image areas 
plateaus form difficulty trying extend continuous watershed definition topographical distances discrete images 
nonlocal effect major obstacle parallel implementation watershed algorithms see section 
algorithmic definition automatically takes care plateaus computes watershed transform level level level constitutes binary image computed 
original conn conn conn conn 
watershed transform square grid different connectivity 
original image minima indicated bold results immersion definition results topographical distance definition tf defined 

algorithmic definition immersion algorithmic definition watershed transform simulated immersion vincent soille see ch 
xi binary case 
digital grey value image hmin hmax minimum maximum value define recursion grey level increasing hmin hmax basins associated minima successively expanded 
xh denote union set basins computed level connected component threshold set th level cf 
new minimum extension basin xh case computes geodesic influence zone xh th cf 
section resulting update xh 
minh denote union regional minima altitude definition 
watershed immersion define recursion hmin xh minh xh hmin hmax watershed complement roerdink meijster watershed transform example watershed transform recurrence see fig 
labels basins denote watershed pixels figures follow minima pixels input image indicated bold 
note dependence connectivity 

watershed transform immersion connected grid showing relabelling watershed pixels 
original image labelling steps 
recursion case level non basin pixels pixels th xh potential candidates get assigned catchment basin step 
definition allows pixels grey value part basin processing level merged basin higher level 
pixels iteration equidistant nearest basins may provisionally labelled watershed pixels assigning label refer pixels pixels 
iteration label may change 
definitive labelling watershed pixel happen levels processed 
example fig 
discrete image square grid connectivity 
local minima zeroes basins pixels labelled labelling shown fig 

shows phenomenon relabelling pixels pixel second row second column labelled algorithm vincent soille implementation fact adhere definition see section 

watershed definition topographical distance follow presentation 
digital grey value image 
initially assume lower complete pixel minimum neighbour lower grey value 
assumption relaxed 
lower slope ls pixel defined maximal slope linking neighbours lower altitude 
formally ls max ng ng set neighbours pixel grid distance associated edge expression max operator defined zero 
note pixels neighbours higher grey value lower slope roerdink meijster watershed transform zero 
cost walking pixel neighbouring pixel defined ls cost ls ls ls definition 
set lower neighbours slope maximal equals value ls denoted 
set pixels denoted 
topographical distance path 
defined pi pi cost pi pi 
topographical distance minimum topographical distances paths tf min set paths denoted 
topographical distance point set defined tf mina tf 
call 
pn path steepest descent pn pi pi 

pixel said belong downstream exists path steepest descent pixel said belong upstream belongs downstream topographical distance property watershed definition crucially depends 
proposition 

path steepest descent 
path steepest descent 
proposition implies paths steepest descent geodesics shortest paths topographical distance function 
topographical distance digital images definition catchment basins watersheds continuous case cf 
definition 
consequence proposition cb mi set points upstream single minimum mi 
watershed consists points upstream minima paths steepest descent starting lead different minima 
corollary obvious 
corollary 
pixel upstream watershed pixel watershed pixel 
example watershed transform topographical distance fig 
de 
note result differs obtained immersion definition 
consequence definition digital case occurrence thick watersheds meaning watershed pixels form pixel thick lines extended areas 
example case connectivity fig 

result simulated immersion comparison thick watersheds occur watershed definition tend pronounced 
roerdink meijster watershed transform 
watershed transform square grid connectivity showing thick watersheds 
original image result topographical distance definition tf defined result immersion definition 

distance transform digital grid unit distance values edges binary image produces grey value image cost function equals edge outside minima watershed equals 
consider images lower complete 
plateau problem problems arise try extend approach images lower complete 
images non minima plateaus nonempty interior occur 
directly apply definitions topographical distance interior pixels plateau turns identically zero 
additional ordering relation pixels required 
usual solution compute geodesic distances lower boundary plateau 
formalized transforming image lower complete image definitions applied 
recall set descending paths starting pixel pixel length length path 
definition 
lower completion digital grey value image domain define function min length lc maxp 
lower completion flc defined flc lc lc roerdink meijster watershed transform 
image lower distance image lower complete image 
process lower completion transforms image lower complete image flc 
example fig 

function value zero minima pixels pixels equals length shortest path set pixels grey value lower refer lower distance lower complete flc algorithm lower completion section algorithm 
lower completion define order relation pixels flc flc 
lower completion function tf flc proper distance function equals domain minima excluded 
particular form lower slope cost function devised ensure steepest descent paths realize smallest topographical distance 
mapping define directed graph follows 
definition 
digital grey value image 
lower complete graph defined follows 
points having lower neighbour interior plateaus arc created geodesic distance lower boundary plateau greater lower complete graph acyclic dag 
definition 
watershed transform topographical distance grey value image flc lower completion mi collection minima basin cb mi corresponding minimum mi defined basin lower completion cb mi mi tf mi mj tf mj watershed defined 
roerdink meijster watershed transform basically define watershed transform topographical distance arbitrary digital grey value image watershed transform lower completion 

watershed transform topographical distance square grid connectivity showing effect lowering minima 
original image watershed labelling image minima set zero 
watershed labelling 
practice algorithms compute watershed transform images plateaus explicitly carry lower completion step assign plateau pixels basins way 
case algorithms called ordered queues 
cautionary note point algorithmic solutions lead results may differ varying degree result definition depending precise implementation 
discussed detail section 
lowering minima values 
meyer states watershed lines change replaces values minima value deepest 
statement correct definition watershed transform immersion easy verify 
definition topographical distance property fact hold observed 
example illustrating fig 
minima value value 
replacing value change result 
effect lowering value single minimum pixel propagates global way entire image image enlarged arbitrarily effect propagating accordingly 
isolated regions 
computing watershed transform regions image may arise completely surrounded watershed pixels 
example fig 

roerdink meijster watershed transform center pixel value watershed neighbours watershed pixel 
implementations watershed transforms topographical distance regions may fact temporarily permanently isolated see 
defect particular implementation corollary watershed pixels propagated 
problems solved ad hoc modifications implementation correctly implement definition 
original labelled 
watershed topographical distance connectivity 
original image output labelling pixels grey values 

watersheds local condition watershed algorithms exist construct watershed pixels assign pixel label minimum set basins image plane 
various motivations approach 
watershed lines may fact comprise large areas thick watersheds see fig 
higher connectivity alleviates problem 
implementations watershed transform topographical distance problems isolated regions caused watershed pixels see 
reason efficiency correct determination watershed pixels generally requires computation time memory 
explicit definition watershed transform topographical distance construct watershed lines introducing local condition 
definition 
image plateaus function assigning label pixel called watershed segmentation 
mi mj mk set minima 
pixel 
condition means lower neighbour cf 
definition 
new element input image labellings exist qualify watershed segmentation 
pixels labelled watershed points definition merged random choice basin belonging minimum mk 
example see fig 

meaning locality definition may subdivide image blocks labelling basins block independently results globally consistent final merging step 
increased locality advantageous parallel implementation roerdink meijster watershed transform watershed transform exactly context local condition proposed 
note locality misinterpreted saying watershed transform purely local operation merging step basins local blocks consistent resulting global basins extend large regions image fuller discussion see section 

watershed transform connected square grid 
original image result topographical distance definition watershed labellings consistent local condition definition 
input image contain watershed pixels definition output watershed algorithm definition longer deterministic depend order pixels treated execution algorithm 
sequential case deterministic result obtained fixing scanning order raster scan longer true parallel implementation case outcome depends relative time instants different processors treat pixels unpredictable case asynchronous processors 
principle considerable differences watershed labellings computed different runs algorithm may occur effect may small natural images 

sequential watershed algorithms generally spoken existing watershed algorithms simulate flooding process directly detect watershed points 
implementations computes basins touch watershed pixels generated 

watershed algorithms immersion 
vincent soille algorithm implementation watershed transform definition vincent soille 
want discuss implementation detail reproduce algorithm pseudocode see algorithm 
algorithm steps sorting pixels increasing grey value direct access pixels certain grey level ii flooding step proceeding level level starting minima 
implementation uses fifo queue pixels data structure operations roerdink meijster watershed transform performed fifo add queue adds pixel queue fifo remove queue returns removes element queue fifo init queue initializes empty queue fifo empty queue test returns true queue empty false 
algorithm assigns distinct label lab minimum associated basin iteratively flooding graph breadth algorithm follows 
flooding step nodes grey level label mask 
nodes labelled neighbours previous iteration inserted queue pixels geodesic influence zones propagated inside set masked pixels 
pixel adjacent different basins marked watershed node label 
pixel reached nodes label node merged corresponding basin 
pixels value mask belong set new minima level connected components get new label 
shown time complexity algorithm linear number pixels input image 
algorithm vincent soille watershed algorithm 
procedure watershed immersion input digital grey scale image im 
output labelled watershed image lab define init initial value lab image define mask initial value level define label watershed pixels define fictitious fictitious pixel current label fifo init queue lab init dist dist image distances sort pixels increasing order grey values minimum hmin maximum hmax start flooding hmin hmax geodesic level inside level im mask pixels level directly accessible sorting step lab mask neighbour lab lab initialize queue neighbours level current basins watersheds dist fifo add queue fifo add fictitious queue loop extend basins fifo remove queue fictitious fifo empty queue break fifo add fictitious queue roerdink meijster watershed transform fifo remove queue ng labelling inspecting neighbours dist lab lab belongs existing basin watersheds lab lab mask lab lab lab lab lab lab lab mask lab lab mask dist plateau pixel dist fifo add queue loop detect process new minima level im dist reset distance zero lab mask inside new minimum create new label fifo add queue lab fifo empty queue fifo remove queue ng inspect neighbours lab mask fifo add queue lab flooding vincent soille algorithm fact implement recursion reasons line numbers mentioned refer pseudocode algorithm 

level pixels grey value masked flooding line non basin pixels level definition require see discussion section 

labels catchment basins propagated labels pixels line 
need consequence previous point 
algorithm tries classify pixels pixels current grey level watershed labels roerdink meijster watershed transform propagated may case pixels grey value neighbourhood 

pixel adjacent different basins initially gets labelled allowed overwritten current grey level label neighbouring pixel pixel part basin lines 
motivation deviated watershed lines may result 
statement probably intuitive expectation case functions continuous space 
point view assessment correctness implementation solely agreement definition 
difficult modify algorithm order implement recursion exactly 
line pixels im masked queue initialized basin pixels drop disjunct lab line resetting distances line done line propagation rules lines slightly changed 
note theoretical time complexity change linear quadratic number pixels input image due repeated processing watershed pixels practice number pixels may small 

input image 
labelled level components 
components graph grey values nodes indicated 

tried formalize vincent soille algorithm computes defining modified recursion follows hmin xh xh minh xh th hmin hmax th term introduced ensure level pixels grey value added existing basins 
example fig 
pixel second row second column remains labelled 
modified recursion correctly represent implementation algorithm possible catchment basin disconnected th term 
fact unable find recursion formalizes computed algorithm 
roerdink meijster watershed transform 
components graph algorithm straightforward parallel implementation vincent soille algorithm difficult plateaus occur 
alternative approach proposed image transformed directed valued graph distinct neighbour values called components graph graph watershed transform computed simplified version vincent soille algorithm fifo queues longer necessary plateaus graph 
steps follows 
algorithm watershed transform topographical distance image integration dijkstra moore shortest paths algorithm 
procedure input lower complete digital grey scale image im cost function cost 
output labelled image lab define label watershed pixels uses distance image dist output dist im initialize lab dist local minima mi mi lab dist im initialize distance values minima find smallest distance value dist dist cost dist dist dist cost lab lab lab dist cost dist lab lab lab 
consider input image valued graph denotes grey value pixel transform components graph defined follows 
pixels level component ch level represented single node ch pair level components element cf 
fig 

compute watershed transform directed graph 

transform labelled graph back image 
pixels corresponding watershed node coloured white pixels black 
yields binary image plateaus representing watersheds original image 
thin watersheds obtained computing skeleton image different skeleton algorithms 
roerdink meijster watershed transform algorithm watershed transform topographical distance hill climbing 
procedure hill climbing input lower complete digital grey scale image im 
output labelled image lab define label watershed pixels initialize image lab distinct labels minima special label mask pixels ng im im interior pixels minima excluded empty select point minimal grey value remove label steepest upper neighbours lab mask lab lab lab lab lab lab 
watershed algorithms topographical distance shortest paths algorithms watershed transform respect topographical distance literature 
ordered algorithms 
nodes shortest topographical distance known ordered distance 
methods shortest paths algorithm associated names dijkstra moore 
integration algorithm integration lower slope image propagating distances starting regional minima 
distances related lower slope image cost function 
output distance value pixel equals input image 
pseudocode algorithm described detail section 
hill climbing geodesics points basin corresponding minimum paths steepest descent 
relation may inverted follows 
label minima distinct labels 
starting boundary pixels minima label pixels set steepest upper neighbours current pixel label labelled label differs case classified watershed pixel 
pseudocode algorithm see section details 
unordered algorithms 
shortest path algorithm berge assumes order treatment pixels classical raster scanning modes 
algorithm adapted flooding minima solving eikonal equation 
implementation iterative algorithm integrates lower slope input image see roerdink meijster watershed transform algorithm 
variant mentioned propagation labelled pixels steepest upper neighbours hill climbing 
algorithm watershed transform topographical distance sequential scanning image integration 
procedure sequential scanning input lower complete image im digital grid cost function cost 
output labelled image lab define label watershed pixels uses distance image dist output dist im initialize lab dist local minima mi mi lab dist im initialize distance values minima stable true stable boolean variable repeat pixels forward raster scan order propagate pixels backward raster scan order propagate stable procedure propagate ng scan order dist cost dist dist dist cost lab lab stable false lab dist cost dist lab lab lab stable false slightly different versions algorithms produce watershed labels lines algorithm lines algorithm lines algorithm omitted exact implementations definition 
pixels merged basin dependent order pixels treated different results may produced 
unfortunately discussion point missing 
fact algorithms agreement local definition watershed transform discussed section 
roerdink meijster watershed transform algorithm algorithm lower completion fifo queue 
procedure input digital grey scale image im 
output lower complete image lc 
fifo init queue initialize queue pixels lower neighbour lc lower neighbour fifo add queue lc dist dist integer variable fifo add fictitious queue insert fictitious pixel fifo empty queue fifo remove queue fictitious fifo empty queue fifo add fictitious queue dist dist lc dist ng im im lc fifo add queue lc prevent queueing twice put lower complete values output image lc lc dist im lc lc dist im roerdink meijster watershed transform solve plateau problem image may lower complete 
done linear time breadth algorithm fifo queue propagate distances cf 
algorithm 
case ordered algorithms alternative lower completion preprocessing ordered queues 
discussed detail 
consider initial step necessary algorithms detection minima 

minima detection usually flooding algorithm fifo queues minima detection 
union find algorithm implementing disjoint sets see computing connected components minima detection 
practice union find algorithm outperforms flooding algorithm 
algorithm computing level components breadth search fifo queue 
procedure input digital grey scale image im 
output image lab labelled level components 
define init initial value lab image lab init current label fifo init queue lab init lab fifo add queue fifo empty queue fifo remove queue ng im im lab init lab fifo add queue fifo algorithm 
standard flooding breadth implementations fifo queue find level components connected components pixels constant grey value cf 
algorithm 
component pixel stored empty fifo queue followed flooding process runs queue empty 
flooding process consists removing pixel queue inserting queue neighbours grey value labelled 
time complexity linear number edges graph 
roerdink meijster watershed transform practice image graph fixed connectivity complexity algorithm linear number pixels image 
construct algorithm better time complexity 
minimally required size queue known advance memory addressed unstructured manner causing performance degradation virtual memory especially parallel computers requires lot synchronization 

disjoint set forest sets integers 
union find algorithm 
union find algorithm disjoint sets stored trees forming disjoint set forest node pointing parent parent fig 
gives example sets integers stored 
node tree called root tree parent tree root chosen representative set stored tree 
sets merged united sufficient change root trees points root tree 
prevent height tree increasing drastically resulting longer search times find representatives path compression applied 
means root nodes path arbitrary node root set point directly root 
technique length paths roots rarely exceeds practical cases 
tarjan uses second technique called union rank prevent height trees growing drastically keeping resulting tree reasonably balanced merging trees 
shown time complexity algorithm techniques input size inverse ackermann function value smaller order practice algorithm regarded run linear time respect input 
algorithm computing connected components images turns path compression technique really pays ranking technique omitted 
disjoint set technique labelling connected components easily performed scan line fashion cf 
algorithm 
case nodes trees pixels 
denote lexicographical order pixels 
image pixels denotes 
scan line algorithm pixels visited lexicographical order 
denote pixel current pixel scanning 
order array parent maintained parent 
order prevents cycles iteratively evaluate parent find root tree containing denoted roerdink meijster watershed transform 
current pixel 
neighbours image value new set created setting parent exist neighbouring pixels grey value representatives neighbours computed lexicographically smallest chosen representative union sets containing neighbours 
paths neighbours compressed merged set 
second pass input image output image lab created 
root pixels get distinct label pixel path compressed making explicit order imposed parent see line algorithm gets label representative 
algorithm computation connected components images dimension size connectivity contrast algorithm rosenfeld works dimensional images connectivity 
restriction holds union find algorithm performs exact linear time post processing scan line 
situ variation algorithm possible array parent removed 
case image lab plays role output image parent array time 
resume discussion watershed algorithms topographical distance 

image integration dijkstra moore shortest paths algorithm 
directed weighted graph nonnegative weight function arcs dijkstra moore algorithm computes length shortest path source node node 
algorithm simply adapted computing watershed transform 
edge image considered pair arcs weight 
label image lab distance image dist introduced just case algorithm lab index minimum nearest dist distance minimum 
minimum wavefront started labelled index minimum started distance initialized value minimum cf 

wavefront reaches node propagated distance dist value placed dist lab set node reached wavefront propagated distance originated different minimum carries label case lab set artificial value designating watershed pixel 
pseudo code see algorithm 
input image non minima plateaus may lower completed 
alternative keep track distances lower border plateaus execution algorithm 
achieved ordered queues 
implementation ordered queues 
function algorithm implemented time complexity linear number pixels image 
realized data structure called hierarchical ordered queue oq priority queue fifo queues queue grey values image lower grey values higher priority 
oq processes lower grey roerdink meijster watershed transform algorithm scan line algorithm labelling level components disjoint sets 
procedure union find input grey scale image im digital grid 
output image lab labelled level components 
uses array parent pointers 
pass lexicographical order ng im im min min denotes minimum lexicographical order parent ng compress paths im im second pass current label lexicographical order parent root pixel lab parent parent parent resolve unresolved equivalences lab lab parent function pixel parent parent return procedure pixel pixel parent parent parent roerdink meijster watershed transform levels higher ones initialized labelled border pixels minima 
pixels grey value inserted fifo queue priority level oq 
pixels removed oq priority propagate labels non labelled neighbouring pixels inserted oq ii neighbouring labelled pixels oq change watershed pixels propagated label differs current label 
priority order grey values pixels propagate labels steepest upper neighbours plateaus synchronous breadth propagation labels coming different pixels lower border takes place 
oq automatically implements hierarchical order relation pixels preprocessing input image lower complete avoided 
noted oq give exactly result input image lower completed 
example image plateau pixels lower completion assigned different basins pixel labelled watershed pixel pixel equidistant minima oq algorithm may introduce watershed line points wavefronts coming different parts boundary meet 
exact location watershed line dependent processing order biased part lower boundary propagation proceeded 

algorithm requires updating set distances labels propagated pixels ordered queue implementation set pixels entered oq 
case lower complete image may propagate pixel neighbours cost function positive minima plateaus computed distance processed pixel increase algorithm change pixel entails redundant computation advantage memory needed encode set oq implementation image lower complete set properly encoded broadening watershed line may occur interior plateaus cost function identically zero 

hill climbing compared image integration hill climbing simpler distances computed labels simply propagated steepest upper neighbours see algorithm 
lower complete image determination upstream set pixel requires local computation 
image contains non minima plateaus may lower completed 
alternatively just ordered queues 
version algorithm compute watershed pixels distance values edges underlying grid equal eq 
case connected connected neighbourhoods practice may simply replace upstream set unlabelled neighbours algorithm processes pixels lowest grey value unlabelled neighbour pixel necessarily upstream labelled pixel inspected watershed labels assigned 
implies initial computation lower distances roerdink meijster watershed transform cost function avoided leading time memory efficient implementation 
course result exact dependent processing order 

left image corresponding dag right graph resolving watershed pixels surrounded box 

watershed transform union find algorithm union find algorithm described section modified compute watershed transform steps 

plateaus removed image computing lower completion flc see algorithm 
loop algorithm slightly adapted label minima pixels pixels lc 

lower complete image lower complete graph constructed see definition directed acyclic graph dag 
see fig 
example 
dag stored array pointer th steepest lower neighbour pixel number steepest lower neighbours connectivity 
minimum pixel chosen representative minimum pointer created 
array plays role parent level components algorithm note node parent steepest lower neighbour 
graph disjoint set forest case connected components 
dag constructed single pass scan line algorithm pixel neighbours referenced 

step apply union find algorithm dag 
pass similar algorithm 
resolving step modified watershed pixels detected points having paths dag distinct roots 
pseudocode resolving algorithm closely resembles tarjan operation see algorithm 
technique computes exact watershed transform topographical distance 
similar approach developed earlier parallel implementation watershed transform 
authors local condition watershed pixels computed see sections steepest lower neighbours exist arbitrarily chosen 
algorithm referred variant watershed transform union find graph dag disjoint set forest 
roerdink meijster watershed transform algorithm watershed transform topographical distance disjoint sets 
procedure union find watershed input lower complete graph 
output labelled image lab define label watershed pixels define fictitious coordinates watershed pixels initialize image lab distinct labels minima give label representative rep resolve rep lab lab rep lab function resolve pixel recursive function resolving downstream paths lower complete graph 
returns representative element pixel watershed pixel rep value rep con rep con indicates connectivity resolve rep rep rep con return rep 
parallelization roerdink meijster watershed transform section general remarks parallel computer systems parallel programming 
review parallelization strategies watershed transform distributed shared memory architectures 

general considerations 
parallel computer systems standard classification parallel computer systems types due flynn see details 
types encountered practice simd single instruction multiple data mimd multiple instruction multiple data 
simd computer processor elements simultaneously execute operation different data items mimd machine processors may execute different operations data 
mimd computers flexible general difficult program 
simd mimd computers shared memory distributed memory type 
shared memory parallel computer number processors single large memory accessible processors 
contrast distributed memory architecture processor local memory processor retrieve data memory processor messages communication network 
performance parallel computer dependent bandwidth connection processors memory maximum number simultaneous load store operations time unit 
shared memory systems typically bandwidth problem single memory conflicts may arise processors try access memory locations 
hand distributed memory mimd machines disadvantage communication processors slower shared memory machines synchronization overhead higher tasks communicate 
mismatch communication vs computational speed communication speed limiting factor distributed memory mimd architectures memory congestion usually speed limiting factor shared memory systems 
maximum amount process perform communication processors necessary called granularity grain size 
load balancing ensuring equal load different processors program execution important requirement parallel program design 
context important issue mapping assignment tasks processors 
may done statically initialization dynamically execution program 

parallel programming models various parallel programming models exist 
message passing programming tasks created interact sending receiving messages 
approach called spmd single program multiple data meaning processor runs program performing operations data space 
shared memory programming model tasks share common address space 
mechanisms locks semaphores may roerdink meijster watershed transform control access shared memory 
compare implementations watershed transform distributed memory machines making message passing shared memory architectures synchronization takes place shared variables 

classification parallel watershed algorithms classification current parallel implementations watershed transform domain decomposition distribute image processors regular way static mapping sequential algorithm subimage subdomain 
insert synchronization communication points result depends neighbouring subdomains 
merge obtain final solution 
functional decomposition simulating flooding local minima distribute local minima processors 
case efficiency depends crucially number local minima sizes corresponding basins 
load imbalance may arise sizes basins differ significantly 

speed versus scalability number processors 
define running time moment processor starts moment processor finishes 
speedup parallel algorithm measured sp execution time fastest serial algorithm processor 
replaced time needed execute algorithm formed starting point parallelization processor speaks relative speedup 
efficiency defined sp quality measure efficiency parallel algorithm close efficiency unity speedup curve approximates linear function sp speedup depends critically amount sequential computation 
fraction sequential operations amdahl law states maximum speedup achievable obeys sp implies small number sequential operations drastically limit achievable speedup sp matter processors 
usually speedup increasing function problem size overhead costs creating processes input output process synchronization constant increase slower grain size 
note algorithm slow time scaling properties 
roerdink meijster watershed transform 
watershed implementation distributed memory architectures case watershed algorithm usually domain decomposition distributed memory architectures 
granularity depends distribution data processors number processors image content 
subimages grains small relatively large number pixels boundary subdomains requiring communication 
algorithms discussed subsection image distributed stripes blocks di 
processors 
processor access overlap region mains determined neighbourhood ng boundary pixel 
di ng denoted extension subdomain di di id pixels di outside neighbours 
pixels boundary regions written process subdomain assigned available reading processors neighbouring subdomains 
approach division image rectangular blocks naturally leads implementation processors connected rectangular mesh topology example easily realizable transputer system transputer having communication links 
speedups usually measured excluding time needed image loading distribution retrieval saving 

hill climbing ordered queues watershed transform ordered queues discussed 
algorithm construct watershed lines 
program uses spmd approach synchronization messages master process 
image distributed blocks 
steps watershed computation 
minima detection plateaus examined breadth scans subimage fifo queue 
plateau spread different subdomains communication processors necessary merging parts different subdomains takes place 
may require repeated communication stabilization changes occur 

flooding local oq processor performs flooding subdomain ordered queues sequential algorithm 
allow flooding propagate neighbouring subdomains approaches considered 
processors tightly synchronized grey level analyzing border pixels subdomains steepest lower neighbours exist neighbours grey value extension area subdomains 
processor reaches synchronization level labels values extension areas exchanged neighbouring processors 
communication takes place label propagation stabilizes detected master process 
due tight synchronization considerable idle times introduced processors execute code approximately time 
second approach performs local flooding grey levels subdomain followed communication label propagation stabilizes 
reduces amount communication necessary 
roerdink meijster watershed transform performance measurements 
speedups schemes reported ch 

tight synchronization scheme implemented massively parallel reconfigurable network transputers pips parallel image processing system 
initial implementation loosely coupled cluster workstations pvm parallel virtual machine package resulted marginal speedups efficiency deteriorating quickly number processes increased 
second scheme implemented cray mimd distributed memory architecture nodes mpi message passing interface 
experimental results show moderate increase speedup number processors images speedup second scheme twice high scheme 
note schemes implemented different architectures 
natural images efficiency ranges processors processors 
stages algorithm minima detection flooding data dependent leading load imbalance 
artificial images large snake plateaus spread different subdomains speedup may marginal decrease number processors due extensive relabelling 
better performance obtained larger images 

hill climbing lower completion hill climbing lower completion preprocessing considered moga effectively explicitly introducing local condition definition 
addition algorithm studied see section 
algorithms steps minima detection ii lower completion iii flooding hill climbing respectively 
minima detection lower completion non minima plateaus requires repeated communication stabilization achieve global consistency 
flooding step considered labelling vertex lower complete graph label minimum connected path 
procedure choosing arbitrarily steepest lower neighbours pixel case exist turns dag disjoint set forest 
reduces amount non locality introduces scanning order dependence cf 
section 
algorithm forest labelled inside subdomains described fifo queue store root pixels resolved paths 
processors perform communication neighbours long unresolved paths subdomain 
processor decide locally terminate calculation global reduction operation necessary relabelling synchronization paths needed 
case hill climbing processor initializes raster scan fifo queue border pixels minima subdomain 
pixel removed queue propagates label pixels arc lower complete graph 
labels repeatedly exchanged neighbouring processors extension area initiating new labelling 
processor inactive soon pixels subdomain labelled 
summarizing plateaus treated breadth order labelling paths generated depth search breadth search hillclimbing respectively 
roerdink meijster watershed transform performance measurements 
implementations carried pips cray mpi 
speedup curves similar hillclimbing having shorter running times somewhat lower speedup 
efficiency decreases increasing number processors data dependent case artificial scenes system cray 
compared implementation ordered queues cf 
section time spent flooding reduced time stages increased due lower distance computation 
execution time improved significantly 
advantage may ordinary queues easier implement correctly ordered queues 

hill climbing ordered queues combined connected component operator parallelization hill climbing algorithm combined connected component operator considered local condition definition moga 
describe approach 
main idea solve watershed problem independently subdomains synchronization 
temporary labels assigned pixels flooded adjacent subdomains 
boundary connectivity information stored graph equivalence table 
global labels computed reduction operation resolving step union find algorithm cf 
section 
number processors computation global labels takes log steps independent complexity data 
problem strongly related connected component labelling problem 
algorithm images plateaus follows 
give local minima domain di globally unique label information 
give pixels temporary label globally unique downstream neighbours subdomain 
set boundary pixels requiring temporary label temp di di 

produce watershed segmentation consistent definition independently subdomain minima temporary labels seeds basins 
ordered queues non minima plateaus completely subdomain flooded accordance definition 
merge subdomains pairwise give labels subdomains globally consistent values linking basins grown pixels temporary label basins downstream efficient implementation step algorithm union find algorithm discussed section 
example consider fig 

shows watershed segmentation image fig 
consistent definition labellings possible 
consider subdivision image strips rows 
show result roerdink meijster watershed transform step step algorithm 
clearly step shown correct result definition obtained 
course real problem treat images plateaus 
procedure proposed 
define neighbour set plateau pixel union neighbour sets running boundary pixels plateau minimal geodesic distance extend definition replacing 
claim similar replacement algorithm watershed segmentation produced agreement extended definition 
easy see claim true 
replaced set temp defined may empty set may located subdomain far away di zero overlap di 
watershed segmentation algorithm produces result subdomain di completely independent downstream 
fact done assign temporary labels pixels extends subdomain adjacent 
case locality aimed introducing definition lost 
effectively annihilates idea computing watershed transform independently subdomain followed merging step requiring communication boundary information 
comes surprise implementation uses variant sequential watershed transform connected ordered queues iterative plateau correction required step algorithm labels distances stretched subdomain needing global synchronization step 
clearly demonstrates locality assumption implicit specification algorithm plateaus hold 

watershed definition 
original image watershed segmentation complete image result step parallel algorithm subdomains 
result step parallel algorithm subdomains 
similar approach moga 
difference approach non minima plateaus shared processors globally correct lower distance values computed flooding flooding relabelling wrongly labelled higher neighbourhoods plateaus necessary 
roerdink meijster watershed transform performance measurements 
experiments reported pips implementation mpi cray similar results 
linear speedup obtained number processors saturation sets 
efficiency processors ranges 
local minima detection local flooding takes time number processors large plateau correction time limiting factor images small plateaus 
implementation performs better respect scalability execution time implementation hill climbing discussed section 
data dependence severe due plateau correction step 

parallel watershed transform sequential scanning mention watershed algorithm sequential see section 
sequential algorithm slow method scaling properties parallel implementation 
implementation consists repeated raster anti raster scans subdomains message passing processors stabilization 
implementation carried mimd architecture cluster algorithm suitable simd computers queues 
parallel implementation steps detection minima ii lower completion image iii labelling minima iv flooding image integration 
labels boundaries subimages communicated processors 
computation stabilized subdomain new raster scans may necessary due changes boundary region caused processors 
master process detects global stabilization obtained 
subdomains equal size processor executes simple operations raster scan mode chances higher communication points reached approximately time resulting better load balance 
performance measurements 
implementations carried pips mpi cray ch 

approximately linear speedup close ideal line obtained cases efficiency drops number processors larger 
speedup may decrease small image size amount processor small 
larger image sizes yield higher speedups number processors 
algorithm data dependent images large snake plateaus speedup may drop increasing number processors 

summarizing performance results various parallel implementations discussed section section slow methods sequential scanning best scaling properties 
ordered queues relatively fast worst scaling distributed memory system local ordered queues need kept global order proper synchronization 
improvement hill climbing ordered queues marginal 
better results obtained combining ordered queue implementation connected component operator 
data dependence severe connected roerdink meijster watershed transform component operator allows computation globally correct labels fixed time complexity independent image content 
algorithms problems varying degree images containing large snake plateaus spread different subdomains speedup may marginal decrease increasing number processors 

shared memory implementations main motivation shared memory architectures watershed transform derives global data dependence caused extended basins grey value images 
requires direct access data may far separated memory 
reason shared memory obvious choice cf 
section 

components graph algorithm parallelization components graph algorithm cf 
section proposed 
pixels level component clustered single node components graph plateaus longer exist 
shared memory parallel programs similar sequential counterparts 
concurrent memory locations protected synchronization primitives 
steps 

level components labelling 
single processor labels level components entire image distributes input image labelled image processors 
processor slice consecutive scan lines approximately equal size assigned scan line overlap decided level components shared neighbouring processors 

parallel watershed transform graph 
processor builds local components graph image slice 
level components shared processors graphs processors disjoint 
processor performs adapted version flooding algorithm care shared vertices 

back transformation 
flooding processor transforms local components graph back image slice sequential case 

topographical distance algorithm ordered queue step algorithm detecting local minima see section 
computation lower slope cost function local operations easy parallelizable 
minima detection lower completion obtained step see section 
computation watershed transform graph algorithm compute watershed pixels 
processor computes basins approximately equal number minima 
strong data dependence sizes basins may differ substantially 
dynamic static mapping needed obtain performance 
roerdink meijster watershed transform 
topographical distance algorithm modified union find approach compute watershed transform relatively easy parallelize shared memory architectures 
phase input image transformed lower complete image fifo queues 
algorithm parallel architectures splitting domain image equally sized subdomains 
processor private fifo queue initializes seed points pixels lower boundary plateau private subdomain 
initialization processor starts propagating distances private image dist processors finished operation minimum dist images desired lower complete image 
computing minimum efficiently performed parallel called reduction operator parallel architectures 
computing lower complete image dag constructed single image pass pixel neighbours addressed 
dependence pixels far computation order concerned operation trivially performed parallel 
resolving phase easy parallelize replacing domain algorithm private domain processor 
note mapping procedure hybrid case initially processor starts pixels private domain resolving phase access pixels domains processors 

results 
timing results cray shared memory computer processors algorithm discussed section reported static mapping 
processors efficiency complete watershed computation ranges image minima image moderate amount minima 
images minima efficiency deteriorates 
speedup computing lower slope cost function linear number processors 
holds minima detection influence concurrent memory locations starts play major role processors typically 
number minima smaller speed gained processors 
practice number minima usually larger authors approach section progress 

summary reviewed various existing definitions watershed transform immersion shortest paths respect topographical distance function 
main sequential algorithms computing watershed transform definitions described 
emphasis put fact watershed algorithms literature adhere definition implementation algorithm proper specification 
strategies parallel implementation discussed distinguishing distributed memory shared memory architectures 
watershed algorithm immersion hard roerdink meijster watershed transform parallelize inherently sequential nature 
parallel implementation algorithm transformation components graph 
distance definition allows various parallel implementations 
main ones ordered queues repeated raster scanning modified union find algorithm combination 
main drawn review despite techniques architectures stage watershed transform remains global operation case parallel implementation modest speedups expected 
prasanna parallel architectures algorithms image component labeling 
ieee trans 
patt 
anal 
mach 
intell 

berge th orie des graphes ses applications 
paris 
watershed hierarchical segmentation waterfall algorithm 
mathematical morphology applications image processing serra soille eds 
kluwer acad 
publ dordrecht pp 

watersheds contour detection 
proc 
international workshop image processing real time edge motion detection estimation rennes september 
meyer morphological approach segmentation watershed transformation 
mathematical morphology image processing dougherty ed 
marcel dekker new york ch 
pp 

burkhardt lle schreiber parallel watershed algorithm 
proc 
th scandinavian conference image analysis finland pp 

moga connected component approach watershed segmentation 
mathematical morphology applications image signal processing roerdink eds 
kluwer acad 
publ dordrecht pp 

cormen leiserson rivest algorithms 
mit press 
iterative algorithms 
actes du second symposium europ en analyse quantitative des en sciences des mat october 
ed verlag stuttgart pp 

dijkstra note problems connexion graphs 
numerische mathematik 
dijkstra operating sequential processes 
programming languages ed 
academic press new york pp 

fast watershed algorithms analysis extensions 
spie vol 

proc 
spie symposium electronic imaging science technology nonlinear image processing february san jose convention center ca 
pp 

embrechts component labelling mimd multiprocessor 
comp 
vis 
graph 
im 
proc 

linear time union find strategies image processing 
theoretical computer science feb 
foster designing building parallel programs 
addison wesley reading ma 
gropp lusk skjellum mpi portable parallel programming message passing interface 
mit press cambridge ma 
pollack differential topology 
prentice hall englewood cliffs nj 
roerdink meijster watershed transform haralick shapiro survey image segmentation techniques 
comp 
vis 
graph 
im 
proc 

klein gauthier hardware implementation watershed zone algorithm hierarchical queue structure 
proc 
ieee workshop nonlinear signal image processing june greece pitas ed pp 

la son application aux des ques 
phd thesis ecole des mines paris 
meijster roerdink proposal implementation parallel watershed algorithm 
computer analysis images patterns ra eds vol 
lecture notes computer science 
springer verlag new york heidelberg berlin pp 

meijster roerdink computation watersheds parallel graph algorithms 
mathematical morphology applications image signal processing shafer butt eds 
kluwer acad 
publ dordrecht pp 

meijster roerdink disjoint set algorithm watershed transform 
proc 
ix european signal processing conference eusipco september rhodes greece theodoridis pitas eds pp 

meyer un algorithme optimal de de des 
proceedings th congress lyon france vol 
pp 

meyer topographic distance watershed lines 
signal processing 
meyer morphological segmentation 
visual commun 
image 

moga parallel watershed algorithms image segmentation 
phd thesis tampere university technology tampere finland feb 
moga parallel watershed transformation algorithms image segmentation 
parallel computing 
moga parallel watershed algorithm shortest path computation 
parallel programming applications fritzson eds 
ios press 
moga parallel image component labeling watershed transformation 
ieee trans 
patt 
anal 
mach 
intell 
may 
moga parallel marker image segmentation watershed transformation 
journal parallel distributed computing 
moga implementation distributed watershed algorithm 
mathematical morphology applications image processing serra soille eds 
kluwer acad 
publ dordrecht pp 

moga lle schreiber burkhardt parallel watershed algorithm sequential scanning 
proc 
ieee workshop nonlinear signal image processing june greece pitas ed pp 

moore shortest path maze 
proc 
intern 
symp 
theory switching vol 
annals computation laboratory harvard university pp 

dimensional critical point configuration graphs 
ieee trans 
patt 
anal 
mach 
intell 

schmitt watershed continuous function 
signal processing 
data dependent architecture seeded region growing strategy advanced morphological operators 
mathematical morphology applications image signal processing shafer butt eds 
kluwer acad 
publ dordrecht pp 

roerdink meijster watershed transform lle schreiber schulz pips general purpose parallel image processing system 
proceedings th dagm symposium vienna sept ed reihe informatik xpress springer verlag new york heidelberg berlin pp 

distance function approach gray level mathematical morphology 
mathematical morphology image processing dougherty ed 
marcel dekker new york ch 
pp 

pvm parallel virtual machine user guide tutorial networked parallel computing 
quinn parallel computing 
theory practice 
mcgraw hill new york ny 
roerdink meijster segmentation watersheds definition parallel implementation 
advances computer vision bajcsy eds 
springer wien new york pp 

rosenfeld distance functions digital pictures 
pattern recognition 
rosenfeld sequential operations digital picture processing 
ass 
comp 
mach 

samet connected component labeling quadtrees 
ass 
comp 
mach 

serra image analysis mathematical morphology 
academic press new york 
tarjan data structures network algorithms 
siam 
tarjan van leeuwen worst case analysis set union algorithms 
ass 
comp 
mach 

verbeek shading shape eikonal equation solved distance transform 
pattern recognition letters 
algorithms image sequence filtering coding image segmentation 
phd thesis tampere university technology tampere finland jan 
vincent algorithmes base de files de 
extension aux graphes 
phd thesis ecole nationale sup rieure des mines de paris 
vincent soille watersheds digital spaces efficient algorithm immersion simulations 
ieee trans 
patt 
anal 
mach 
intell 

